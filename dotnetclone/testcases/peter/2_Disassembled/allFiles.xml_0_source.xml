<project><name></name><description></description><prog_language></prog_language><source_elements>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="21" endline="23"><![CDATA[
             get {
                 return defaultInstance;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="18" endline="18"><![CDATA[
         private static Settings defaultInstance = ((Settings)(global
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="33" endline="42"><![CDATA[
         public Buffer(Stream s, bool isUserStream)
         {
             stream = s; this.isUserStream = isUserStream;
             fileLen = bufLen = (int)s.Length;
             if (stream.CanSeek && bufLen > MAX_BUFFER_LENGTH) bufLen = MAX_BUFFER_LENGTH;
             buf = new byte[bufLen];
             bufStart = Int32.MaxValue; // nothing in the buffer so far
             Pos = 0; // setup buffer to position 0 (start)
             if (bufLen == fileLen) Close();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="43" endline="54"><![CDATA[
 
         protected Buffer(Buffer b)
         { // called in UTF8Buffer constructor
             buf = b.buf;
             bufStart = b.bufStart;
             bufLen = b.bufLen;
             fileLen = b.fileLen;
             pos = b.pos;
             stream = b.stream;
             b.stream = null;
             isUserStream = b.isUserStream;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="55" endline="56"><![CDATA[
 
         ~Buffer() { Close(); }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="57" endline="65"><![CDATA[
 
         protected void Close()
         {
             if (!isUserStream && stream != null)
             {
                 stream.Close();
                 stream = null;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="66" endline="82"><![CDATA[
 
         public virtual int Read()
         {
             if (pos < bufLen)
             {
                 return buf[pos++];
             }
             else if (Pos < fileLen)
             {
                 Pos = Pos; // shift buffer start to Pos
                 return buf[pos++];
             }
             else
             {
                 return EOF;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="83" endline="90"><![CDATA[
 
         public int Peek()
         {
             int curPos = Pos;
             int ch = Read();
             Pos = curPos;
             return ch;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="91" endline="101"><![CDATA[
 
         public string GetString(int beg, int end)
         {
             int len = end - beg;
             char[] buf = new char[len];
             int oldPos = Pos;
             Pos = beg;
             for (int i = 0; i < len; i++) buf[i] = (char)Read();
             Pos = oldPos;
             return new String(buf);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="102" endline="105"><![CDATA[
 
         public int Pos
         {
             get { return pos + bufStart; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="106" endline="124"><![CDATA[
             set
             {
                 if (value < 0) value = 0;
                 else if (value > fileLen) value = fileLen;
                 if (value >= bufStart && value < bufStart + bufLen)
                 { // already in buffer
                     pos = value - bufStart;
                 }
                 else if (stream != null)
                 { // must be swapped in
                     stream.Seek(value, SeekOrigin.Begin);
                     bufLen = stream.Read(buf, 0, buf.Length);
                     bufStart = value; pos = 0;
                 }
                 else
                 {
                     pos = fileLen - bufStart; // make Pos return fileLen
                 }
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="125" endline="133"><![CDATA[
         }
     }
 
     //-----------------------------------------------------------------------------------
     // UTF8Buffer
     //-----------------------------------------------------------------------------------
     public class UTF8Buffer 
     {
         public UTF8Buffer(Buffer b) 
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="134" endline="173"><![CDATA[
 
         public override int Read()
         {
             int ch;
             do
             {
                 ch = base.Read();
                 // until we find a uft8 start (0xxxxxxx or 11xxxxxx)
             } while ((ch >= 128) && ((ch & 0xC0) != 0xC0) && (ch != EOF));
             if (ch < 128 || ch == EOF)
             {
                 // nothing to do, first 127 chars are the same in ascii and utf8
                 // 0xxxxxxx or end of file character
             }
             else if ((ch & 0xF0) == 0xF0)
             {
                 // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
                 int c1 = ch & 0x07; ch = base.Read();
                 int c2 = ch & 0x3F; ch = base.Read();
                 int c3 = ch & 0x3F; ch = base.Read();
                 int c4 = ch & 0x3F;
                 ch = (((((c1 << 6) | c2) << 6) | c3) << 6) | c4;
             }
             else if ((ch & 0xE0) == 0xE0)
             {
                 // 1110xxxx 10xxxxxx 10xxxxxx
                 int c1 = ch & 0x0F; ch = base.Read();
                 int c2 = ch & 0x3F; ch = base.Read();
                 int c3 = ch & 0x3F;
                 ch = (((c1 << 6) | c2) << 6) | c3;
             }
             else if ((ch & 0xC0) == 0xC0)
             {
                 // 110xxxxx 10xxxxxx
                 int c1 = ch & 0x1F; ch = base.Read();
                 int c2 = ch & 0x3F;
                 ch = (c1 << 6) | c2;
             }
             return ch;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="174" endline="215"><![CDATA[
     }
 
     //-----------------------------------------------------------------------------------
     // Scanner
     //-----------------------------------------------------------------------------------
     public class Scanner
     {
         const char EOL = '\n';
         const int eofSym = 0; /* pdt */
         const int maxT = 33;
         const int noSym = 33;
         char valCh;       // current input character (for token.val)
 
         public Buffer buffer; // scanner buffer
 
         Token t;          // current token
         int ch;           // current input character
         int pos;          // byte position of current character
         int col;          // column number of current character
         int line;         // line number of current character
         int oldEols;      // EOLs that appeared in a comment;
         Dictionary<int, int> start; // maps first token character to start state
 
         Token tokens;     // list of tokens already peeked (first token is a dummy)
         Token pt;         // current peek token
 
         char[] tval = new char[128]; // text of current token
         int tlen;         // length of current token
 
         public Scanner(string fileName)
         {
             try
             {
                 Stream stream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
                 buffer = new Buffer(stream, false);
                 Init();
             }
             catch (IOException)
             {
                 throw new FatalError("Cannot open file " + fileName);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="200" endline="221"><![CDATA[
         char[] tval = new char[128]; // text of current token
         int tlen;         // length of current token
 
         public Scanner(string fileName)
         {
             try
             {
                 Stream stream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
                 buffer = new Buffer(stream, false);
                 Init();
             }
             catch (IOException)
             {
                 throw new FatalError("Cannot open file " + fileName);
             }
         }
 
         public Scanner(Stream s)
         {
             buffer = new Buffer(s, true);
             Init();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="222" endline="265"><![CDATA[
 
         void Init()
         {
             pos = -1; line = 1; col = 0;
             oldEols = 0;
             NextCh();
             if (ch == 0xEF)
             { // check optional byte order mark for UTF-8
                 NextCh(); int ch1 = ch;
                 NextCh(); int ch2 = ch;
                 if (ch1 != 0xBB || ch2 != 0xBF)
                 {
                     throw new FatalError(String.Format("illegal byte order mark
                 }
                 buffer = new UTF8Buffer(buffer); col = 0;
                 NextCh();
             }
             start = new Dictionary<int, int>(128);
             for (int i = 95; i <= 95; ++i) start[i] = 1;
             for (int i = 97; i <= 116; ++i) start[i] = 1;
             for (int i = 118; i <= 122; ++i) start[i] = 1;
             for (int i = 10; i <= 10; ++i) start[i] = 2;
             for (int i = 13; i <= 13; ++i) start[i] = 2;
             for (int i = 9; i <= 9; ++i) start[i] = 3;
             for (int i = 11; i <= 12; ++i) start[i] = 3;
             for (int i = 32; i <= 32; ++i) start[i] = 3;
             for (int i = 48; i <= 57; ++i) start[i] = 4;
             start[46] = 21;
             start[34] = 7;
             start[44] = 10;
             start[123] = 11;
             start[125] = 12;
             start[35] = 13;
             start[58] = 14;
             start[42] = 15;
             start[59] = 16;
             start[45] = 17;
             start[37] = 18;
             start[117] = 22;
             start[41] = 20;
             start[Buffer.EOF] = -1;
 
             pt = tokens = new Token();  // first token is a dummy
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="266" endline="281"><![CDATA[
 
         void NextCh()
         {
             if (oldEols > 0) { ch = EOL; oldEols--; }
             else
             {
                 pos = buffer.Pos;
                 ch = buffer.Read(); col++;
                 // replace isolated '\r' by '\n' in order to make
                 // eol handling uniform across Windows, Unix and Mac
                 if (ch == '\r' && buffer.Peek() != '\n') ch = EOL;
                 if (ch == EOL) { line++; col = 0; }
             }
             valCh = (char)ch;
             if (ch != Buffer.EOF) ch = char.ToLower((char)ch);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="282" endline="293"><![CDATA[
 
         void AddCh()
         {
             if (tlen >= tval.Length)
             {
                 char[] newBuf = new char[2 * tval.Length];
                 Array.Copy(tval, 0, newBuf, 0, tval.Length);
                 tval = newBuf;
             }
             tval[tlen++] = valCh;
             NextCh();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="294" endline="325"><![CDATA[
 
 
 
         bool Comment0()
         {
             int level = 1, pos0 = pos, line0 = line, col0 = col;
             NextCh();
             if (ch == '*')
             {
                 NextCh();
                 for (; ; )
                 {
                     if (ch == '*')
                     {
                         NextCh();
                         if (ch == '/')
                         {
                             level--;
                             if (level == 0) { oldEols = line - line0; NextCh(); return true; }
                             NextCh();
                         }
                     }
                     else if (ch == Buffer.EOF) return false;
                     else NextCh();
                 }
             }
             else
             {
                 buffer.Pos = pos0; NextCh(); line = line0; col = col0;
             }
             return false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="326" endline="349"><![CDATA[
 
 
         void CheckLiteral()
         {
             switch (t.val.ToLower())
             {
                 case "ex"
                 case "em"
                 case "px"
                 case "cm"
                 case "mm"
                 case "pc"
                 case "in"
                 case "pt"
                 case "deg"
                 case "rad"
                 case "grad"
                 case "m"
                 case "s"
                 case "k"
                 case "hz"
                 default
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="350" endline="404"><![CDATA[
 
         Token NextToken()
         {
             while (ch == 10 || ch == 13) NextCh();
             if (ch == '/' && Comment0()) return NextToken();
             t = new Token();
             t.pos = pos; t.col = col; t.line = line;
             int state;
             try { state = start[ch]; }
             catch (KeyNotFoundException) { state = 0; }
             tlen = 0; AddCh();
 
             switch (state)
             {
                 case -1
                 case 0
                 case 1
                     if (ch == '-' || ch >= '0' && ch <= '9' || ch == '_' || ch >= 'a' && ch <= 'z') { AddCh(); goto case 1; } else { t.kind = 1; t.val = new String(tval, 0, tlen); CheckLiteral(); return t; }
                 case 2
                 case 3
                 case 4
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 4; } else if (ch == '.') { AddCh(); goto case 5; } else { t.kind = 4; break; }
                 case 5
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 6; } else { t.kind = noSym; break; }
                 case 6
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 6; } else { t.kind = 4; break; }
                 case 7
                     if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= '!' || ch >= '#' && ch <= '[' || ch >= ']' && ch <= 65535) { AddCh(); goto case 8; } else { t.kind = noSym; break; }
                 case 8
                     if (ch == '"') { AddCh(); goto case 9; } else { t.kind = noSym; break; }
                 case 9
                 case 10
                 case 11
                 case 12
                 case 13
                 case 14
                 case 15
                 case 16
                 case 17
                 case 18
                 case 19
                 case 20
                 case 21
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 4; } else { t.kind = 9; break; }
                 case 22
                     if (ch == '-' || ch >= '0' && ch <= '9' || ch == '_' || ch >= 'a' && ch <= 'q' || ch >= 's' && ch <= 'z') { AddCh(); goto case 1; } else if (ch == 'r') { AddCh(); goto case 23; } else { t.kind = 1; t.val = new String(tval, 0, tlen); CheckLiteral(); return t; }
                 case 23
                     if (ch == '-' || ch >= '0' && ch <= '9' || ch == '_' || ch >= 'a' && ch <= 'k' || ch >= 'm' && ch <= 'z') { AddCh(); goto case 1; } else if (ch == 'l') { AddCh(); goto case 24; } else { t.kind = 1; t.val = new String(tval, 0, tlen); CheckLiteral(); return t; }
                 case 24
                     if (ch == '-' || ch >= '0' && ch <= '9' || ch == '_' || ch >= 'a' && ch <= 'z') { AddCh(); goto case 1; } else if (ch == '(') { AddCh(); goto case 19; } else { t.kind = 1; t.val = new String(tval, 0, tlen); CheckLiteral(); return t; }
 
             }
             t.val = new String(tval, 0, tlen);
             return t;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="405" endline="418"><![CDATA[
 
         // get the next token (possibly a token already seen during peeking)
         public Token Scan()
         {
             if (tokens.next == null)
             {
                 return NextToken();
             }
             else
             {
                 pt = tokens = tokens.next;
                 return tokens;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="419" endline="438"><![CDATA[
 
         // peek for the next token, ignore pragmas
         public Token Peek()
         {
             if (pt.next == null)
             {
                 do
                 {
                     pt = pt.next = NextToken();
                 } while (pt.kind > maxT); // skip pragmas
             }
             else
             {
                 do
                 {
                     pt = pt.next;
                 } while (pt.kind > maxT);
             }
             return pt;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="439" endline="441"><![CDATA[
 
         // make sure that peeking starts at the current scan position
         public void ResetPeek() { pt = tokens; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="17" endline="117"><![CDATA[
         {
             Peter.CParser.Scanner scanner = new Peter.CParser.Scanner(fileName);
             Peter.CParser.Parser parser = new Peter.CParser.Parser(scanner);
             parser.Parse();
 
             // Include...
             TreeNode nInclude = new TreeNode("Includes");
             foreach (TokenMatch tm in parser.CodeInfo.Includes)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nInclude.Nodes.Add(n);
             }
             foreach (TokenMatch tm in parser.CodeInfo.Includes)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nInclude.Nodes.Add(n);
             }
             if (nInclude.Nodes.Count > 0)
             {
                 nodes.Add(nInclude);
             }
 
             // Defines...
             TreeNode nDefine = new TreeNode("Defines");
             foreach (TokenMatch tm in parser.CodeInfo.Defines)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nDefine.Nodes.Add(n);
             }
             foreach (TokenMatch tm in parser.CodeInfo.Defines)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nDefine.Nodes.Add(n);
             }
             if (nDefine.Nodes.Count > 0)
             {
                 nodes.Add(nDefine);
             }
 
             // GlobalVars...
             TreeNode nGlobalVars = new TreeNode("Global Variables");
             foreach (TokenMatch tm in parser.CodeInfo.GlobalVariables)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nGlobalVars.Nodes.Add(n);
             }
             foreach (TokenMatch tm in parser.CodeInfo.GlobalVariables)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nGlobalVars.Nodes.Add(n);
             }
             if (nGlobalVars.Nodes.Count > 0)
             {
                 nodes.Add(nGlobalVars);
                 nGlobalVars.Expand();
             }
 
             // Structs...
             TreeNode nStructs = new TreeNode("Structs");
             foreach (TokenMatch tm in parser.CodeInfo.Structs)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nStructs.Nodes.Add(n);
             }
             foreach (TokenMatch tm in parser.CodeInfo.Structs)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nStructs.Nodes.Add(n);
             }
             if (nStructs.Nodes.Count > 0)
             {
                 nodes.Add(nStructs);
                 nStructs.Expand();
             }
 
             // TypeDefs...
             TreeNode nTypeDefs = new TreeNode("TypeDefs");
             foreach (TokenMatch tm in parser.CodeInfo.TypeDefs)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nTypeDefs.Nodes.Add(n);
             }
             foreach (TokenMatch tm in parser.CodeInfo.TypeDefs)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nTypeDefs.Nodes.Add(n);
             }
             if (nTypeDefs.Nodes.Count > 0)
             {
                 nodes.Add(nTypeDefs);
                 nTypeDefs.Expand();
             }
 
             // Prototypes...
             TreeNode nPrototypes = new TreeNode("Prototypes");
             foreach (TokenMatch tm in parser.CodeInfo.Prototypes)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nPrototypes.Nodes.Add(n);
             }
             foreach (TokenMatch tm in parser.CodeInfo.Prototypes)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nPrototypes.Nodes.Add(n);
             }
             if (nPrototypes.Nodes.Count > 0)
             {
                 nodes.Add(nPrototypes);
                 nPrototypes.Expand();
             }
 
             // Functions...
             TreeNode nFunctions = new TreeNode("Functions");
             foreach (TokenMatch tm in parser.CodeInfo.Functions)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nFunctions.Nodes.Add(n);
             }
             foreach (TokenMatch tm in parser.CodeInfo.Functions)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nFunctions.Nodes.Add(n);
             }
             if (nFunctions.Nodes.Count > 0)
             {
                 nodes.Add(nFunctions);
                 nFunctions.Expand();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Settings.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGridGroup.cs" startline="83" endline="89"><![CDATA[
         public OutlookgGridDefaultGroup ()
         {
             val = null;
 
             this.column = null;
             height = 34; // default height
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGridGroup.cs" startline="90" endline="107"><![CDATA[
 
         #region IOutlookGridGroup Members
 
         public virtual string Text
         {
             get
             {
                 if (column == null)
                     return string.Format("Unbound group
                 else
                 {
                     OutlookGrid grid = (OutlookGrid)this.column.DataGridView;
                     if(grid.ShowItemCount)
                         return string.Format(/*"{0}
                     else
                         return string.Format("{0}", Value.ToString());
                 }
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGridGroup.cs" startline="108" endline="108"><![CDATA[
             set { text = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGridGroup.cs" startline="109" endline="113"><![CDATA[
         }
 
         public virtual object Value
         {
             get { return val; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGridGroup.cs" startline="114" endline="114"><![CDATA[
             set { val = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGridGroup.cs" startline="115" endline="119"><![CDATA[
         }
 
         public virtual bool Collapsed
         {
             get { return collapsed; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGridGroup.cs" startline="120" endline="120"><![CDATA[
             set { collapsed = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGridGroup.cs" startline="121" endline="125"><![CDATA[
         }
 
         public virtual DataGridViewColumn Column
         {
             get { return column; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGridGroup.cs" startline="126" endline="126"><![CDATA[
             set { column = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGridGroup.cs" startline="127" endline="131"><![CDATA[
         }
 
         public virtual int ItemCount
         {
             get { return itemCount; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGridGroup.cs" startline="132" endline="132"><![CDATA[
             set { itemCount = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGridGroup.cs" startline="133" endline="137"><![CDATA[
         }
 
         public virtual int Height
         {
             get { return height; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGridGroup.cs" startline="138" endline="138"><![CDATA[
             set { height = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGridGroup.cs" startline="139" endline="154"><![CDATA[
         }
 
         #endregion
 
         #region ICloneable Members
 
         public virtual object Clone ()
         {
             OutlookgGridDefaultGroup gr = new OutlookgGridDefaultGroup();
             gr.column = this.column;
             gr.val = this.val;
             gr.collapsed = this.collapsed;
             gr.text = this.text;
             gr.height = this.height;
             return gr;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGridGroup.cs" startline="155" endline="169"><![CDATA[
 
         #endregion
 
         #region IComparable Members
 
         /// <summary>
         /// this is a basic string comparison operation. 
         /// all items are grouped and categorised based on their string-appearance.
         /// </summary>
         /// <param name="obj">the value in the related column of the item to compare to</param>
         /// <returns></returns>
         public virtual int CompareTo (object obj)
         {
             return string.Compare(val.ToString(), obj.ToString());
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGridGroup.cs" startline="170" endline="191"><![CDATA[
 
         #endregion
     }
     #endregion OutlookgGridDefaultGroup - implementation of the default grouping style
 
     #region OutlookGridAlphabeticGroup - an alphabet group implementation
     /// <summary>
     /// this group simple example of an implementation which groups the items into Alphabetic categories
     /// based only on the first letter of each item
     /// 
     /// for this we need to override the Value property (used for comparison)
     /// and the CompareTo function.
     /// Also the Clone method must be overriden, so this Group object can create clones of itself.
     /// Cloning of the group is used by the OutlookGrid
     /// </summary>
     public class OutlookGridAlphabeticGroup 
     {
         public OutlookGridAlphabeticGroup ()
             
         {
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGridGroup.cs" startline="192" endline="198"><![CDATA[
 
         public override string Text
         {
             get
             {
                 return string.Format("Alphabetic
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGridGroup.cs" startline="199" endline="199"><![CDATA[
             set { text = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGridGroup.cs" startline="200" endline="204"><![CDATA[
         }
 
         public override object Value
         {
             get { return val; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGridGroup.cs" startline="205" endline="205"><![CDATA[
             set { val = value.ToString().Substring(0, 1).ToUpper(); }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGridGroup.cs" startline="206" endline="222"><![CDATA[
         }
 
         #region ICloneable Members
         /// <summary>
         /// each group class must implement the clone function
         /// </summary>
         /// <returns></returns>
         public override object Clone ()
         {
             OutlookGridAlphabeticGroup gr = new OutlookGridAlphabeticGroup();
             gr.column = this.column;
             gr.val = this.val;
             gr.collapsed = this.collapsed;
             gr.text = this.text;
             gr.height = this.height;
             return gr;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGridGroup.cs" startline="223" endline="237"><![CDATA[
 
         #endregion
 
         #region IComparable Members
         /// <summary>
         /// overide the CompareTo, so only the first character is compared, instead of the whole string
         /// this will result in classifying each item into a letter of the Alphabet.
         /// for instance, this is usefull when grouping names, they will be categorized under the letters A, B, C etc..
         /// </summary>
         /// <param name="obj"></param>
         /// <returns></returns>
         public override int CompareTo (object obj)
         {
             return string.Compare(val.ToString(), obj.ToString().Substring(0, 1).ToUpper());
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\JavaCodeInfo.cs" startline="14" endline="21"><![CDATA[
         public JavaCodeInfo()
         {
             this.m_Imports = new ArrayList();
             this.m_NameSpaces = new ArrayList();
             this.m_Fields = new ArrayList();
             this.m_Methods = new ArrayList();
             this.m_Constructors = new ArrayList();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\JavaCodeInfo.cs" startline="22" endline="28"><![CDATA[
 
         /// <summary>
         /// Gets or Sets the List of 'using ...' in the code...
         /// </summary>
         public ArrayList Imports
         {
             get { return this.m_Imports; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\JavaCodeInfo.cs" startline="29" endline="30"><![CDATA[
 
             set { this.m_Imports = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\JavaCodeInfo.cs" startline="31" endline="38"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets the List of 'namespace ...' in the code...
         /// </summary>
         public ArrayList NameSpaces
         {
             get { return this.m_NameSpaces; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\JavaCodeInfo.cs" startline="39" endline="40"><![CDATA[
 
             set { this.m_NameSpaces = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\JavaCodeInfo.cs" startline="41" endline="48"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets the List of Fields in the code...
         /// </summary>
         public ArrayList Fields
         {
             get { return this.m_Fields; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\JavaCodeInfo.cs" startline="49" endline="50"><![CDATA[
 
             set { this.m_Fields = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\JavaCodeInfo.cs" startline="51" endline="58"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets the List of Methods in the code...
         /// </summary>
         public ArrayList Methods
         {
             get { return this.m_Methods; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\JavaCodeInfo.cs" startline="59" endline="60"><![CDATA[
 
             set { this.m_Methods = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\JavaCodeInfo.cs" startline="61" endline="68"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets the List of Constructors in the code...
         /// </summary>
         public ArrayList Constructors
         {
             get { return this.m_Constructors; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\JavaCodeInfo.cs" startline="69" endline="70"><![CDATA[
 
             set { this.m_Constructors = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\Parser.cs" startline="26" endline="39"><![CDATA[
         int errDist = minErrDist;
 
         public CSS CSSDocument;
 
         /*------------------------------------------------------------------------*
          *----- SCANNER DESCRIPTION ----------------------------------------------*
          *------------------------------------------------------------------------*/
 
 
         public Parser(Scanner scanner)
         {
             this.scanner = scanner;
             errors = new Errors();
         }
 
         void SynErr(int n)
         {
             if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n);
             errDist = 0;
         }
 
         public void SemErr(string msg)
         {
             if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg);
             errDist = 0;
         }
 
         void Get()
         {
             for (; ; )
             {
                 t = la;
                 la = scanner.Scan();
                 if (la.kind <= maxT) { ++errDist; break; }
 
                 la = t;
             }
         }
 
         void Expect(int n)
         {
             if (la.kind == n) Get(); else { SynErr(n); }
         }
 
         bool StartOf(int s)
         {
             return set[s, la.kind];
         }
 
         void ExpectWeak(int n, int follow)
         {
             if (la.kind == n) Get();
             else
             {
                 SynErr(n);
                 while (!StartOf(follow)) Get();
             }
         }
 
 
         bool WeakSeparator(int n, int syFol, int repFol)
         {
             int kind = la.kind;
             if (kind == n) { Get(); return true; }
             else if (StartOf(repFol)) { return false; }
             else
             {
                 SynErr(n);
                 while (!(set[syFol, kind] || set[repFol, kind] || set[0, kind]))
                 {
                     Get();
                     kind = la.kind;
                 }
                 return StartOf(syFol);
             }
         }
 
 
         void CSSDoc()
         {
             CSSDocument = new CSS();
             Selector sel = null;
             Tag tag = null;
 
             while (la.kind == 3)
             {
                 Get();
             }
             while (StartOf(1))
             {
                 SubTags(out tag);
                 sel = new Selector();
                 CSSDocument.Selectors.Add(sel);
                 if (tag != null) { sel.Tags.Add(tag); }
 
                 while (la.kind == 3)
                 {
                     Get();
                 }
                 while (la.kind == 6)
                 {
                     Get();
                     tag = null;
                     while (la.kind == 3)
                     {
                         Get();
                     }
                     SubTags(out tag);
                     if (tag != null) { sel.Tags.Add(tag); }
                 }
                 Expect(7);
                 while (la.kind == 1 || la.kind == 3)
                 {
                     if (la.val.Equals(";")) { break; }
                     Property p = null;
 
                     while (la.kind == 3)
                     {
                         Get();
                     }
                     if (la.val.Equals("}")) { break; }
                     PropertyDecl(out p);
                     sel.Properties.Add(p); p = null;
                 }
                 while (la.kind == 3)
                 {
                     Get();
                 }
                 Expect(8);
                 while (la.kind == 3)
                 {
                     Get();
                 }
             }
         }
 
         void SubTags(out Tag tag)
         {
             tag = null;
             Tag sub = null;
             Tag tmp = null;
 
             SelectorName(out tag);
             tmp = tag;
             while (la.kind == 3)
             {
                 Get();
                 while (la.kind == 3)
                 {
                     Get();
                 }
                 if (la.val.Equals("{")) { return; }
                 SelectorName(out sub);
                 tmp.SubTags.Add(sub);
                 tmp = sub;
 
             }
             while (la.kind == 3)
             {
                 Get();
             }
         }
 
         void PropertyDecl(out Property p)
         {
             p = new Property();
             Expect(1);
             p.Attribute = t.val;
             while (la.kind == 3)
             {
                 Get();
             }
             Expect(11);
             while (StartOf(2))
             {
                 PropertyValue pv = null;
                 while (la.kind == 3)
                 {
                     Get();
                 }
                 PropertyValue(out pv);
                 if (pv != null) { p.Values.Add(pv); }
                 while (la.kind == 3)
                 {
                     Get();
                 }
                 if (la.kind == 6)
                 {
                     Get();
                 }
             }
             ExpectWeak(13, 3);
         }
 
         void SelectorName(out Tag tag)
         {
             tag = new Tag();
             bool cls = false;
             bool id = false;
             bool pseudo = false;
 
             if (la.kind == 9 || la.kind == 10 || la.kind == 11)
             {
                 if (la.kind == 9)
                 {
                     Get();
                     cls = true;
                 }
                 else if (la.kind == 10)
                 {
                     Get();
                     id = true;
                 }
                 else
                 {
                     Get();
                     pseudo = true;
                 }
             }
             if (la.kind == 1)
             {
                 Get();
             }
             else if (la.kind == 12)
             {
                 Get();
             }
             else SynErr(34);
             if (cls)
             {
                 tag.Class = t.val; tag.TagType |= TagType.Classed;
             }
             else if (id)
             {
                 tag.Id = t.val; tag.TagType |= TagType.IDed;
             }
             else if (pseudo)
             {
                 tag.Pseudo = t.val; tag.TagType |= TagType.Pseudoed;
             }
             else
             {
                 tag.Name = t.val; tag.TagType |= TagType.Named;
             }
 
             while (la.kind == 9 || la.kind == 10 || la.kind == 11)
             {
                 cls = false; id = false; pseudo = false;
                 if (la.kind == 9)
                 {
                     Get();
                     cls = true;
                 }
                 else if (la.kind == 10)
                 {
                     Get();
                     id = true;
                 }
                 else
                 {
                     Get();
                     pseudo = true;
                 }
                 if (la.kind == 1)
                 {
                     Get();
                 }
                 else if (la.kind == 12)
                 {
                     Get();
                 }
                 else SynErr(35);
                 if (cls)
                 {
                     tag.Class = t.val; tag.TagType |= TagType.Classed;
                 }
                 else if (id)
                 {
                     tag.Id = t.val; tag.TagType |= TagType.IDed;
                 }
                 else if (pseudo)
                 {
                     tag.Pseudo = t.val; tag.TagType |= TagType.Pseudoed;
                 }
 
             }
         }
 
         void PropertyValue(out PropertyValue p)
         {
             p = new PropertyValue();
             if (la.kind == 4 || la.kind == 14)
             {
                 if (la.kind == 14)
                 {
                     Get();
                 }
                 p.Value = t.val;
                 Expect(4);
                 if (p.Value != null) { p.Value += t.val; } else { p.Value = t.val; }
                 while (la.kind == 3)
                 {
                     Get();
                 }
                 if (StartOf(4))
                 {
                     if (StartOf(5))
                     {
                         Unit();
                         p.Type = ValType.Unit;
                         p.Unit = (Unit)Enum.Parse(typeof(Unit), t.val.ToUpper());
 
                     }
                     else
                     {
                         Get();
                         p.Type = ValType.Percent;
                     }
                 }
             }
             else if (la.kind == 16)
             {
                 Get();
                 p.Value = ""; p.Type = ValType.Url;
                 while (StartOf(6))
                 {
                     Get();
                     p.Value += t.val;
                 }
                 Expect(17);
             }
             else if (la.kind == 1)
             {
                 Get();
                 p.Value = t.val;
                 p.Type = ValType.String;
 
             }
             else if (la.kind == 10)
             {
                 Get();
                 if (la.kind == 4)
                 {
                     Get();
                     p.Value = t.val;
                 }
                 else if (la.kind == 1)
                 {
                     Get();
                     p.Value = t.val;
                 }
                 else SynErr(36);
                 while (la.kind == 1 || la.kind == 4)
                 {
                     if (la.kind == 4)
                     {
                         Get();
                         p.Value += t.val;
                     }
                     else
                     {
                         Get();
                         p.Value += t.val;
                     }
                 }
                 p.Type = ValType.Hex;
             }
             else SynErr(37);
         }
 
         void Unit()
         {
             switch (la.kind)
             {
                 case 18
                     {
                         Get();
                         break;
                     }
                 case 19
                     {
                         Get();
                         break;
                     }
                 case 20
                     {
                         Get();
                         break;
                     }
                 case 21
                     {
                         Get();
                         break;
                     }
                 case 22
                     {
                         Get();
                         break;
                     }
                 case 23
                     {
                         Get();
                         break;
                     }
                 case 24
                     {
                         Get();
                         break;
                     }
                 case 25
                     {
                         Get();
                         break;
                     }
                 case 26
                     {
                         Get();
                         break;
                     }
                 case 27
                     {
                         Get();
                         break;
                     }
                 case 28
                     {
                         Get();
                         break;
                     }
                 case 29
                 case 30
                     {
                         if (la.kind == 29)
                         {
                             Get();
                         }
                         Expect(30);
                         break;
                     }
                 case 31
                 case 32
                     {
                         if (la.kind == 31)
                         {
                             Get();
                         }
                         Expect(32);
                         break;
                     }
                 default
             }
         }
 
 
 
         public void Parse()
         {
             la = new Token();
             la.val = "";
             Get();
             CSSDoc();
 
             Expect(0);
         }
 
         bool[,] set = {
         public Parser(Scanner scanner)
         {
             this.scanner = scanner;
             errors = new Errors();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\Parser.cs" startline="40" endline="45"><![CDATA[
 
         void SynErr(int n)
         {
             if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n);
             errDist = 0;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\Parser.cs" startline="46" endline="51"><![CDATA[
 
         public void SemErr(string msg)
         {
             if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg);
             errDist = 0;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\Parser.cs" startline="52" endline="63"><![CDATA[
 
         void Get()
         {
             for (; ; )
             {
                 t = la;
                 la = scanner.Scan();
                 if (la.kind <= maxT) { ++errDist; break; }
 
                 la = t;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\Parser.cs" startline="64" endline="68"><![CDATA[
 
         void Expect(int n)
         {
             if (la.kind == n) Get(); else { SynErr(n); }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\Parser.cs" startline="69" endline="73"><![CDATA[
 
         bool StartOf(int s)
         {
             return set[s, la.kind];
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\Parser.cs" startline="74" endline="83"><![CDATA[
 
         void ExpectWeak(int n, int follow)
         {
             if (la.kind == n) Get();
             else
             {
                 SynErr(n);
                 while (!StartOf(follow)) Get();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\Parser.cs" startline="84" endline="101"><![CDATA[
 
 
         bool WeakSeparator(int n, int syFol, int repFol)
         {
             int kind = la.kind;
             if (kind == n) { Get(); return true; }
             else if (StartOf(repFol)) { return false; }
             else
             {
                 SynErr(n);
                 while (!(set[syFol, kind] || set[repFol, kind] || set[0, kind]))
                 {
                     Get();
                     kind = la.kind;
                 }
                 while (!(set[syFol, kind] || set[repFol, kind] || set[0, kind]))
                 {
                     Get();
                     kind = la.kind;
                 }
                 return StartOf(syFol);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\Parser.cs" startline="102" endline="160"><![CDATA[
 
 
         void CSSDoc()
         {
             CSSDocument = new CSS();
             Selector sel = null;
             Tag tag = null;
 
             while (la.kind == 3)
             {
                 Get();
             }
             while (la.kind == 3)
             {
                 Get();
             }
             while (StartOf(1))
             {
                 SubTags(out tag);
                 sel = new Selector();
                 CSSDocument.Selectors.Add(sel);
                 if (tag != null) { sel.Tags.Add(tag); }
 
                 while (la.kind == 3)
                 {
                     Get();
                 }
                 while (la.kind == 3)
                 {
                     Get();
                 }
                 while (la.kind == 6)
                 {
                     Get();
                     tag = null;
                     while (la.kind == 3)
                     {
                         Get();
                     }
                     while (la.kind == 3)
                     {
                         Get();
                     }
                     SubTags(out tag);
                     if (tag != null) { sel.Tags.Add(tag); }
                 }
                 while (la.kind == 6)
                 {
                     Get();
                     tag = null;
                     while (la.kind == 3)
                     {
                         Get();
                     }
                     SubTags(out tag);
                     if (tag != null) { sel.Tags.Add(tag); }
                 }
                 Expect(7);
                 while (la.kind == 1 || la.kind == 3)
                 {
                     if (la.val.Equals(";")) { break; }
                     Property p = null;
 
                     while (la.kind == 3)
                     {
                         Get();
                     }
                     while (la.kind == 3)
                     {
                         Get();
                     }
                     if (la.val.Equals("}")) { break; }
                     PropertyDecl(out p);
                     sel.Properties.Add(p); p = null;
                 }
                 while (la.kind == 1 || la.kind == 3)
                 {
                     if (la.val.Equals(";")) { break; }
                     Property p = null;
 
                     while (la.kind == 3)
                     {
                         Get();
                     }
                     if (la.val.Equals("}")) { break; }
                     PropertyDecl(out p);
                     sel.Properties.Add(p); p = null;
                 }
                 while (la.kind == 3)
                 {
                     Get();
                 }
                 while (la.kind == 3)
                 {
                     Get();
                 }
                 Expect(8);
                 while (la.kind == 3)
                 {
                     Get();
                 }
                 while (la.kind == 3)
                 {
                     Get();
                 }
             }
             while (StartOf(1))
             {
                 SubTags(out tag);
                 sel = new Selector();
                 CSSDocument.Selectors.Add(sel);
                 if (tag != null) { sel.Tags.Add(tag); }
 
                 while (la.kind == 3)
                 {
                     Get();
                 }
                 while (la.kind == 6)
                 {
                     Get();
                     tag = null;
                     while (la.kind == 3)
                     {
                         Get();
                     }
                     SubTags(out tag);
                     if (tag != null) { sel.Tags.Add(tag); }
                 }
                 Expect(7);
                 while (la.kind == 1 || la.kind == 3)
                 {
                     if (la.val.Equals(";")) { break; }
                     Property p = null;
 
                     while (la.kind == 3)
                     {
                         Get();
                     }
                     if (la.val.Equals("}")) { break; }
                     PropertyDecl(out p);
                     sel.Properties.Add(p); p = null;
                 }
                 while (la.kind == 3)
                 {
                     Get();
                 }
                 Expect(8);
                 while (la.kind == 3)
                 {
                     Get();
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\Parser.cs" startline="161" endline="187"><![CDATA[
 
         void SubTags(out Tag tag)
         {
             tag = null;
             Tag sub = null;
             Tag tmp = null;
 
             SelectorName(out tag);
             tmp = tag;
             while (la.kind == 3)
             {
                 Get();
                 while (la.kind == 3)
                 {
                     Get();
                 }
                 while (la.kind == 3)
                 {
                     Get();
                 }
                 if (la.val.Equals("{")) { return; }
                 SelectorName(out sub);
                 tmp.SubTags.Add(sub);
                 tmp = sub;
 
             }
             while (la.kind == 3)
             {
                 Get();
                 while (la.kind == 3)
                 {
                     Get();
                 }
                 if (la.val.Equals("{")) { return; }
                 SelectorName(out sub);
                 tmp.SubTags.Add(sub);
                 tmp = sub;
 
             }
             while (la.kind == 3)
             {
                 Get();
             }
             while (la.kind == 3)
             {
                 Get();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\Parser.cs" startline="188" endline="218"><![CDATA[
 
         void PropertyDecl(out Property p)
         {
             p = new Property();
             Expect(1);
             p.Attribute = t.val;
             while (la.kind == 3)
             {
                 Get();
             }
             while (la.kind == 3)
             {
                 Get();
             }
             Expect(11);
             while (StartOf(2))
             {
                 PropertyValue pv = null;
                 while (la.kind == 3)
                 {
                     Get();
                 }
                 while (la.kind == 3)
                 {
                     Get();
                 }
                 PropertyValue(out pv);
                 if (pv != null) { p.Values.Add(pv); }
                 while (la.kind == 3)
                 {
                     Get();
                 }
                 while (la.kind == 3)
                 {
                     Get();
                 }
                 if (la.kind == 6)
                 {
                     Get();
                 }
             }
             while (StartOf(2))
             {
                 PropertyValue pv = null;
                 while (la.kind == 3)
                 {
                     Get();
                 }
                 PropertyValue(out pv);
                 if (pv != null) { p.Values.Add(pv); }
                 while (la.kind == 3)
                 {
                     Get();
                 }
                 if (la.kind == 6)
                 {
                     Get();
                 }
             }
             ExpectWeak(13, 3);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\Parser.cs" startline="219" endline="312"><![CDATA[
 
         void SelectorName(out Tag tag)
         {
             tag = new Tag();
             bool cls = false;
             bool id = false;
             bool pseudo = false;
 
             if (la.kind == 9 || la.kind == 10 || la.kind == 11)
             {
                 if (la.kind == 9)
                 {
                     Get();
                     cls = true;
                 }
                 else if (la.kind == 10)
                 {
                     Get();
                     id = true;
                 }
                 else
                 {
                     Get();
                     pseudo = true;
                 }
             }
             if (la.kind == 1)
             {
                 Get();
             }
             else if (la.kind == 12)
             {
                 Get();
             }
             else SynErr(34);
             if (cls)
             {
                 tag.Class = t.val; tag.TagType |= TagType.Classed;
             }
             else if (id)
             {
                 tag.Id = t.val; tag.TagType |= TagType.IDed;
             }
             else if (pseudo)
             {
                 tag.Pseudo = t.val; tag.TagType |= TagType.Pseudoed;
             }
             else
             {
                 tag.Name = t.val; tag.TagType |= TagType.Named;
             }
 
             while (la.kind == 9 || la.kind == 10 || la.kind == 11)
             {
                 cls = false; id = false; pseudo = false;
                 if (la.kind == 9)
                 {
                     Get();
                     cls = true;
                 }
                 else if (la.kind == 10)
                 {
                     Get();
                     id = true;
                 }
                 else
                 {
                     Get();
                     pseudo = true;
                 }
                 if (la.kind == 1)
                 {
                     Get();
                 }
                 else if (la.kind == 12)
                 {
                     Get();
                 }
                 else SynErr(35);
                 if (cls)
                 {
                     tag.Class = t.val; tag.TagType |= TagType.Classed;
                 }
                 else if (id)
                 {
                     tag.Id = t.val; tag.TagType |= TagType.IDed;
                 }
                 else if (pseudo)
                 {
                     tag.Pseudo = t.val; tag.TagType |= TagType.Pseudoed;
                 }
 
             }
             while (la.kind == 9 || la.kind == 10 || la.kind == 11)
             {
                 cls = false; id = false; pseudo = false;
                 if (la.kind == 9)
                 {
                     Get();
                     cls = true;
                 }
                 else if (la.kind == 10)
                 {
                     Get();
                     id = true;
                 }
                 else
                 {
                     Get();
                     pseudo = true;
                 }
                 if (la.kind == 1)
                 {
                     Get();
                 }
                 else if (la.kind == 12)
                 {
                     Get();
                 }
                 else SynErr(35);
                 if (cls)
                 {
                     tag.Class = t.val; tag.TagType |= TagType.Classed;
                 }
                 else if (id)
                 {
                     tag.Id = t.val; tag.TagType |= TagType.IDed;
                 }
                 else if (pseudo)
                 {
                     tag.Pseudo = t.val; tag.TagType |= TagType.Pseudoed;
                 }
 
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\Parser.cs" startline="313" endline="394"><![CDATA[
 
         void PropertyValue(out PropertyValue p)
         {
             p = new PropertyValue();
             if (la.kind == 4 || la.kind == 14)
             {
                 if (la.kind == 14)
                 {
                     Get();
                 }
                 p.Value = t.val;
                 Expect(4);
                 if (p.Value != null) { p.Value += t.val; } else { p.Value = t.val; }
                 while (la.kind == 3)
                 {
                     Get();
                 }
                 while (la.kind == 3)
                 {
                     Get();
                 }
                 if (StartOf(4))
                 {
                     if (StartOf(5))
                     {
                         Unit();
                         p.Type = ValType.Unit;
                         p.Unit = (Unit)Enum.Parse(typeof(Unit), t.val.ToUpper());
 
                     }
                     else
                     {
                         Get();
                         p.Type = ValType.Percent;
                     }
                 }
             }
             else if (la.kind == 16)
             {
                 Get();
                 p.Value = ""; p.Type = ValType.Url;
                 while (StartOf(6))
                 {
                     Get();
                     p.Value += t.val;
                 }
                 while (StartOf(6))
                 {
                     Get();
                     p.Value += t.val;
                 }
                 Expect(17);
             }
             else if (la.kind == 1)
             {
                 Get();
                 p.Value = t.val;
                 p.Type = ValType.String;
 
             }
             else if (la.kind == 10)
             {
                 Get();
                 if (la.kind == 4)
                 {
                     Get();
                     p.Value = t.val;
                 }
                 else if (la.kind == 1)
                 {
                     Get();
                     p.Value = t.val;
                 }
                 else SynErr(36);
                 while (la.kind == 1 || la.kind == 4)
                 {
                     if (la.kind == 4)
                     {
                         Get();
                         p.Value += t.val;
                     }
                     else
                     {
                         Get();
                         p.Value += t.val;
                     }
                 }
                 while (la.kind == 1 || la.kind == 4)
                 {
                     if (la.kind == 4)
                     {
                         Get();
                         p.Value += t.val;
                     }
                     else
                     {
                         Get();
                         p.Value += t.val;
                     }
                 }
                 p.Type = ValType.Hex;
             }
             else SynErr(37);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\Parser.cs" startline="395" endline="477"><![CDATA[
 
         void Unit()
         {
             switch (la.kind)
             {
                 case 18
                     {
                         Get();
                         break;
                     }
                 case 19
                     {
                         Get();
                         break;
                     }
                 case 20
                     {
                         Get();
                         break;
                     }
                 case 21
                     {
                         Get();
                         break;
                     }
                 case 22
                     {
                         Get();
                         break;
                     }
                 case 23
                     {
                         Get();
                         break;
                     }
                 case 24
                     {
                         Get();
                         break;
                     }
                 case 25
                     {
                         Get();
                         break;
                     }
                 case 26
                     {
                         Get();
                         break;
                     }
                 case 27
                     {
                         Get();
                         break;
                     }
                 case 28
                     {
                         Get();
                         break;
                     }
                 case 29
                 case 30
                     {
                         if (la.kind == 29)
                         {
                             Get();
                         }
                         Expect(30);
                         break;
                     }
                 case 31
                 case 32
                     {
                         if (la.kind == 31)
                         {
                             Get();
                         }
                         Expect(32);
                         break;
                     }
                 default
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\Parser.cs" startline="478" endline="489"><![CDATA[
 
 
 
         public void Parse()
         {
             la = new Token();
             la.val = "";
             Get();
             CSSDoc();
 
             Expect(0);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\Parser.cs" startline="490" endline="559"><![CDATA[
 
         bool[,] set = {
 		{T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,T,x,x, x,x,x,x, x,T,T,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,T,x,T, T,x,x,x, x,x,T,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{T,T,x,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,x,x},
 		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,x,x},
 		{x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,x,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,x}
 
 	};
     } // end Parser
 
 
     public class Errors
     {
         public int count = 0;                                    // number of errors detected
         public System.IO.TextWriter errorStream = Console.Out;   // error messages go to this stream
         public string errMsgFormat = "-- line {0} col {1}
 
         public void SynErr(int line, int col, int n)
         {
             string s;
             switch (n)
             {
                 case 0
                 case 1
                 case 2
                 case 3
                 case 4
                 case 5
                 case 6
                 case 7
                 case 8
                 case 9
                 case 10
                 case 11
                 case 12
                 case 13
                 case 14
                 case 15
                 case 16
                 case 17
                 case 18
                 case 19
                 case 20
                 case 21
                 case 22
                 case 23
                 case 24
                 case 25
                 case 26
                 case 27
                 case 28
                 case 29
                 case 30
                 case 31
                 case 32
                 case 33
                 case 34
                 case 35
                 case 36
                 case 37
                 case 38
 
                 default
             }
             errorStream.WriteLine(errMsgFormat, line, col, s);
             count++;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\Parser.cs" startline="560" endline="565"><![CDATA[
 
         public void SemErr(int line, int col, string s)
         {
             errorStream.WriteLine(errMsgFormat, line, col, s);
             count++;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\Parser.cs" startline="566" endline="571"><![CDATA[
 
         public void SemErr(string s)
         {
             errorStream.WriteLine(s);
             count++;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\Parser.cs" startline="572" endline="576"><![CDATA[
 
         public void Warning(int line, int col, string s)
         {
             errorStream.WriteLine(errMsgFormat, line, col, s);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\Parser.cs" startline="577" endline="581"><![CDATA[
 
         public void Warning(string s)
         {
             errorStream.WriteLine(s);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\Parser.cs" startline="506" endline="508"><![CDATA[
         public int count = 0;                                    // number of errors detected
         public System.IO.TextWriter errorStream = Console.Out;   // error messages go to this stream
         public string errMsgFormat = "-- line {0} col {1}
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\Parser.cs" startline="509" endline="587"><![CDATA[
 
         public void SynErr(int line, int col, int n)
         {
             string s;
             switch (n)
             {
                 case 0
                 case 1
                 case 2
                 case 3
                 case 4
                 case 5
                 case 6
                 case 7
                 case 8
                 case 9
                 case 10
                 case 11
                 case 12
                 case 13
                 case 14
                 case 15
                 case 16
                 case 17
                 case 18
                 case 19
                 case 20
                 case 21
                 case 22
                 case 23
                 case 24
                 case 25
                 case 26
                 case 27
                 case 28
                 case 29
                 case 30
                 case 31
                 case 32
                 case 33
                 case 34
                 case 35
                 case 36
                 case 37
                 case 38
 
                 default
             }
             errorStream.WriteLine(errMsgFormat, line, col, s);
             count++;
         }
 
         public void SemErr(int line, int col, string s)
         {
             errorStream.WriteLine(errMsgFormat, line, col, s);
             count++;
         }
 
         public void SemErr(string s)
         {
             errorStream.WriteLine(s);
             count++;
         }
 
         public void Warning(int line, int col, string s)
         {
             errorStream.WriteLine(errMsgFormat, line, col, s);
         }
 
         public void Warning(string s)
         {
             errorStream.WriteLine(s);
         }
     } // Errors
 
 
     public class FatalError 
     {
         public FatalError(string m) 
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\Parser.cs" startline="31" endline="37"><![CDATA[
         {
             if (disposing && (components != null))
             {
                 components.Dispose();
             }
             base.Dispose(disposing);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\Parser.cs" startline="38" endline="632"><![CDATA[
 
         #region Component Designer generated code
 
         /// <summary> 
         /// Required method for Designer support - do not modify 
         /// the contents of this method with the code editor.
         /// </summary>
         private void InitializeComponent()
         {
             this.components = new System.ComponentModel.Container();
             System.Windows.Forms.ListViewItem listViewItem1 = new System.Windows.Forms.ListViewItem("General", 0);
             System.Windows.Forms.ListViewItem listViewItem2 = new System.Windows.Forms.ListViewItem("Editor", 2);
             System.Windows.Forms.ListViewItem listViewItem3 = new System.Windows.Forms.ListViewItem("Highlighting", 1);
             System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(Options));
             this.splitContainer1 = new System.Windows.Forms.SplitContainer();
             this.lstMain = new System.Windows.Forms.ListView();
             this.columnHeader1 = new System.Windows.Forms.ColumnHeader();
             this.Editor = new System.Windows.Forms.Panel();
             this.label9 = new System.Windows.Forms.Label();
             this.textEditorControl1 = new ICSharpCode.TextEditor.TextEditorControl();
             this.btnFont = new System.Windows.Forms.Button();
             this.label8 = new System.Windows.Forms.Label();
             this.label7 = new System.Windows.Forms.Label();
             this.cmbBracketStyle = new System.Windows.Forms.ComboBox();
             this.cmbIndentStyle = new System.Windows.Forms.ComboBox();
             this.label6 = new System.Windows.Forms.Label();
             this.label5 = new System.Windows.Forms.Label();
             this.nudVRuler = new System.Windows.Forms.NumericUpDown();
             this.nudTabIndent = new System.Windows.Forms.NumericUpDown();
             this.ckbAutoInsertBracket = new System.Windows.Forms.CheckBox();
             this.ckbHighlightCurrentLine = new System.Windows.Forms.CheckBox();
             this.ckbAllowCaretBeyondEol = new System.Windows.Forms.CheckBox();
             this.ckbUseAntiAlias = new System.Windows.Forms.CheckBox();
             this.ckbConvertTabs = new System.Windows.Forms.CheckBox();
             this.ckbEnableCodeFolding = new System.Windows.Forms.CheckBox();
             this.ckbShowVRuler = new System.Windows.Forms.CheckBox();
             this.ckbShowHRuler = new System.Windows.Forms.CheckBox();
             this.ckbShowLineNumbes = new System.Windows.Forms.CheckBox();
             this.ckbShowMatchingBracket = new System.Windows.Forms.CheckBox();
             this.ckbShowTabs = new System.Windows.Forms.CheckBox();
             this.ckbShowSpaces = new System.Windows.Forms.CheckBox();
             this.ckbShowInvalidLines = new System.Windows.Forms.CheckBox();
             this.ckbShowEol = new System.Windows.Forms.CheckBox();
             this.label4 = new System.Windows.Forms.Label();
             this.General = new System.Windows.Forms.Panel();
             this.groupBox2 = new System.Windows.Forms.GroupBox();
             this.ckbSaveOnExt = new System.Windows.Forms.CheckBox();
             this.groupBox1 = new System.Windows.Forms.GroupBox();
             this.nudRecentFile = new System.Windows.Forms.NumericUpDown();
             this.label3 = new System.Windows.Forms.Label();
             this.nudRecentProject = new System.Windows.Forms.NumericUpDown();
             this.label2 = new System.Windows.Forms.Label();
             this.label1 = new System.Windows.Forms.Label();
             this.btnOK = new System.Windows.Forms.Button();
             this.btnApply = new System.Windows.Forms.Button();
             this.btnCancel = new System.Windows.Forms.Button();
             this.fontDialog1 = new System.Windows.Forms.FontDialog();
             this.imgMain = new System.Windows.Forms.ImageList(this.components);
             this.splitContainer1.Panel1.SuspendLayout();
             this.splitContainer1.Panel2.SuspendLayout();
             this.splitContainer1.SuspendLayout();
             this.Editor.SuspendLayout();
             ((System.ComponentModel.ISupportInitialize)(this.nudVRuler)).BeginInit();
             ((System.ComponentModel.ISupportInitialize)(this.nudTabIndent)).BeginInit();
             this.General.SuspendLayout();
             this.groupBox2.SuspendLayout();
             this.groupBox1.SuspendLayout();
             ((System.ComponentModel.ISupportInitialize)(this.nudRecentFile)).BeginInit();
             ((System.ComponentModel.ISupportInitialize)(this.nudRecentProject)).BeginInit();
             this.SuspendLayout();
             // 
             // splitContainer1
             // 
             this.splitContainer1.Dock = System.Windows.Forms.DockStyle.Top;
             this.splitContainer1.Location = new System.Drawing.Point(0, 0);
             this.splitContainer1.Name = "splitContainer1";
             // 
             // splitContainer1.Panel1
             // 
             this.splitContainer1.Panel1.Controls.Add(this.lstMain);
             // 
             // splitContainer1.Panel2
             // 
             this.splitContainer1.Size = new System.Drawing.Size(635, 315);
             this.splitContainer1.SplitterDistance = 181;
             this.splitContainer1.TabIndex = 0;
             // 
             // lstMain
             // 
             this.lstMain.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
             this.columnHeader1});
             this.lstMain.Dock = System.Windows.Forms.DockStyle.Fill;
             this.lstMain.FullRowSelect = true;
             this.lstMain.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.None;
             listViewItem1.ToolTipText = "General";
             listViewItem2.ToolTipText = "Editor";
             listViewItem3.ToolTipText = "Highlighting";
             this.lstMain.Items.AddRange(new System.Windows.Forms.ListViewItem[] {
             listViewItem1,
             listViewItem2,
             listViewItem3});
             this.lstMain.Location = new System.Drawing.Point(0, 0);
             this.lstMain.MultiSelect = false;
             this.lstMain.Name = "lstMain";
             this.lstMain.Size = new System.Drawing.Size(181, 315);
             this.lstMain.SmallImageList = this.imgMain;
             this.lstMain.TabIndex = 0;
             this.lstMain.UseCompatibleStateImageBehavior = false;
             this.lstMain.View = System.Windows.Forms.View.Details;
             this.lstMain.SelectedIndexChanged += new System.EventHandler(this.lstMain_SelectedIndexChanged);
             // 
             // columnHeader1
             // 
             this.columnHeader1.Width = 173;
             // 
             // Editor
             // 
             this.Editor.Controls.Add(this.label9);
             this.Editor.Controls.Add(this.textEditorControl1);
             this.Editor.Controls.Add(this.btnFont);
             this.Editor.Controls.Add(this.label8);
             this.Editor.Controls.Add(this.label7);
             this.Editor.Controls.Add(this.cmbBracketStyle);
             this.Editor.Controls.Add(this.cmbIndentStyle);
             this.Editor.Controls.Add(this.label6);
             this.Editor.Controls.Add(this.label5);
             this.Editor.Controls.Add(this.nudVRuler);
             this.Editor.Controls.Add(this.nudTabIndent);
             this.Editor.Controls.Add(this.ckbAutoInsertBracket);
             this.Editor.Controls.Add(this.ckbHighlightCurrentLine);
             this.Editor.Controls.Add(this.ckbAllowCaretBeyondEol);
             this.Editor.Controls.Add(this.ckbUseAntiAlias);
             this.Editor.Controls.Add(this.ckbConvertTabs);
             this.Editor.Controls.Add(this.ckbEnableCodeFolding);
             this.Editor.Controls.Add(this.ckbShowVRuler);
             this.Editor.Controls.Add(this.ckbShowHRuler);
             this.Editor.Controls.Add(this.ckbShowLineNumbes);
             this.Editor.Controls.Add(this.ckbShowMatchingBracket);
             this.Editor.Controls.Add(this.ckbShowTabs);
             this.Editor.Controls.Add(this.ckbShowSpaces);
             this.Editor.Controls.Add(this.ckbShowInvalidLines);
             this.Editor.Controls.Add(this.ckbShowEol);
             this.Editor.Controls.Add(this.label4);
             this.Editor.Location = new System.Drawing.Point(2, 0);
             this.Editor.Name = "Editor";
             this.Editor.Size = new System.Drawing.Size(436, 312);
             this.Editor.TabIndex = 0;
             // 
             // label9
             // 
             this.label9.AutoSize = true;
             this.label9.Location = new System.Drawing.Point(187, 172);
             this.label9.Name = "label9";
             this.label9.Size = new System.Drawing.Size(48, 13);
             this.label9.TabIndex = 25;
             this.label9.Text = "Preview
             // 
             // textEditorControl1
             // 
             this.textEditorControl1.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
             this.textEditorControl1.Location = new System.Drawing.Point(190, 188);
             this.textEditorControl1.Name = "textEditorControl1";
             this.textEditorControl1.ShowEOLMarkers = true;
             this.textEditorControl1.ShowSpaces = true;
             this.textEditorControl1.ShowTabs = true;
             this.textEditorControl1.ShowVRuler = true;
             this.textEditorControl1.Size = new System.Drawing.Size(232, 115);
             this.textEditorControl1.TabIndex = 24;
             // 
             // btnFont
             // 
             this.btnFont.Location = new System.Drawing.Point(347, 29);
             this.btnFont.Name = "btnFont";
             this.btnFont.Size = new System.Drawing.Size(75, 23);
             this.btnFont.TabIndex = 23;
             this.btnFont.Text = "Font...";
             this.btnFont.UseVisualStyleBackColor = true;
             this.btnFont.Click += new System.EventHandler(this.btnFont_Click);
             // 
             // label8
             // 
             this.label8.AutoSize = true;
             this.label8.Location = new System.Drawing.Point(270, 126);
             this.label8.Name = "label8";
             this.label8.Size = new System.Drawing.Size(63, 13);
             this.label8.TabIndex = 22;
             this.label8.Text = "Indent Style";
             // 
             // label7
             // 
             this.label7.AutoSize = true;
             this.label7.Location = new System.Drawing.Point(270, 147);
             this.label7.Name = "label7";
             this.label7.Size = new System.Drawing.Size(117, 13);
             this.label7.TabIndex = 21;
             this.label7.Text = "Bracket Matching Style";
             // 
             // cmbBracketStyle
             // 
             this.cmbBracketStyle.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
             this.cmbBracketStyle.FormattingEnabled = true;
             this.cmbBracketStyle.Items.AddRange(new object[] {
             "Before",
             "After"});
             this.cmbBracketStyle.Location = new System.Drawing.Point(190, 144);
             this.cmbBracketStyle.Name = "cmbBracketStyle";
             this.cmbBracketStyle.Size = new System.Drawing.Size(74, 21);
             this.cmbBracketStyle.TabIndex = 20;
             this.cmbBracketStyle.SelectedIndexChanged += new System.EventHandler(this.cmbBracketStyle_SelectedIndexChanged);
             // 
             // cmbIndentStyle
             // 
             this.cmbIndentStyle.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
             this.cmbIndentStyle.FormattingEnabled = true;
             this.cmbIndentStyle.Items.AddRange(new object[] {
             "Auto",
             "None",
             "Smart"});
             this.cmbIndentStyle.Location = new System.Drawing.Point(190, 121);
             this.cmbIndentStyle.Name = "cmbIndentStyle";
             this.cmbIndentStyle.Size = new System.Drawing.Size(74, 21);
             this.cmbIndentStyle.TabIndex = 19;
             this.cmbIndentStyle.SelectedIndexChanged += new System.EventHandler(this.cmbIndentStyle_SelectedIndexChanged);
             // 
             // label6
             // 
             this.label6.AutoSize = true;
             this.label6.Location = new System.Drawing.Point(270, 103);
             this.label6.Name = "label6";
             this.label6.Size = new System.Drawing.Size(108, 13);
             this.label6.TabIndex = 18;
             this.label6.Text = "Vertical Ruler Column";
             // 
             // label5
             // 
             this.label5.AutoSize = true;
             this.label5.Location = new System.Drawing.Point(270, 80);
             this.label5.Name = "label5";
             this.label5.Size = new System.Drawing.Size(59, 13);
             this.label5.TabIndex = 17;
             this.label5.Text = "Tab Indent";
             // 
             // nudVRuler
             // 
             this.nudVRuler.Location = new System.Drawing.Point(190, 99);
             this.nudVRuler.Name = "nudVRuler";
             this.nudVRuler.Size = new System.Drawing.Size(74, 20);
             this.nudVRuler.TabIndex = 16;
             this.nudVRuler.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
             this.nudVRuler.ValueChanged += new System.EventHandler(this.nudVRuler_ValueChanged);
             // 
             // nudTabIndent
             // 
             this.nudTabIndent.Location = new System.Drawing.Point(190, 76);
             this.nudTabIndent.Name = "nudTabIndent";
             this.nudTabIndent.Size = new System.Drawing.Size(74, 20);
             this.nudTabIndent.TabIndex = 15;
             this.nudTabIndent.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
             this.nudTabIndent.ValueChanged += new System.EventHandler(this.nudTabIndent_ValueChanged);
             // 
             // ckbAutoInsertBracket
             // 
             this.ckbAutoInsertBracket.AutoSize = true;
             this.ckbAutoInsertBracket.Location = new System.Drawing.Point(190, 55);
             this.ckbAutoInsertBracket.Name = "ckbAutoInsertBracket";
             this.ckbAutoInsertBracket.Size = new System.Drawing.Size(120, 17);
             this.ckbAutoInsertBracket.TabIndex = 14;
             this.ckbAutoInsertBracket.Text = "Auto- Insert Bracket";
             this.ckbAutoInsertBracket.UseVisualStyleBackColor = true;
             this.ckbAutoInsertBracket.CheckedChanged += new System.EventHandler(this.ckbAutoInsertBracket_CheckedChanged);
             // 
             // ckbHighlightCurrentLine
             // 
             this.ckbHighlightCurrentLine.AutoSize = true;
             this.ckbHighlightCurrentLine.Location = new System.Drawing.Point(190, 33);
             this.ckbHighlightCurrentLine.Name = "ckbHighlightCurrentLine";
             this.ckbHighlightCurrentLine.Size = new System.Drawing.Size(127, 17);
             this.ckbHighlightCurrentLine.TabIndex = 13;
             this.ckbHighlightCurrentLine.Text = "Highlight Current Line";
             this.ckbHighlightCurrentLine.UseVisualStyleBackColor = true;
             this.ckbHighlightCurrentLine.CheckedChanged += new System.EventHandler(this.ckbHighlightCurrentLine_CheckedChanged);
             // 
             // ckbAllowCaretBeyondEol
             // 
             this.ckbAllowCaretBeyondEol.AutoSize = true;
             this.ckbAllowCaretBeyondEol.Location = new System.Drawing.Point(7, 286);
             this.ckbAllowCaretBeyondEol.Name = "ckbAllowCaretBeyondEol";
             this.ckbAllowCaretBeyondEol.Size = new System.Drawing.Size(142, 17);
             this.ckbAllowCaretBeyondEol.TabIndex = 12;
             this.ckbAllowCaretBeyondEol.Text = "Allow Caret Beyond EOL";
             this.ckbAllowCaretBeyondEol.UseVisualStyleBackColor = true;
             this.ckbAllowCaretBeyondEol.CheckedChanged += new System.EventHandler(this.ckbAllowCaretBeyondEol_CheckedChanged);
             // 
             // ckbUseAntiAlias
             // 
             this.ckbUseAntiAlias.AutoSize = true;
             this.ckbUseAntiAlias.Location = new System.Drawing.Point(7, 263);
             this.ckbUseAntiAlias.Name = "ckbUseAntiAlias";
             this.ckbUseAntiAlias.Size = new System.Drawing.Size(112, 17);
             this.ckbUseAntiAlias.TabIndex = 11;
             this.ckbUseAntiAlias.Text = "Use AntiAlias Font";
             this.ckbUseAntiAlias.UseVisualStyleBackColor = true;
             this.ckbUseAntiAlias.CheckedChanged += new System.EventHandler(this.ckbUseAntiAlias_CheckedChanged);
             // 
             // ckbConvertTabs
             // 
             this.ckbConvertTabs.AutoSize = true;
             this.ckbConvertTabs.Location = new System.Drawing.Point(7, 240);
             this.ckbConvertTabs.Name = "ckbConvertTabs";
             this.ckbConvertTabs.Size = new System.Drawing.Size(141, 17);
             this.ckbConvertTabs.TabIndex = 10;
             this.ckbConvertTabs.Text = "Convert Tabs to Spaces";
             this.ckbConvertTabs.UseVisualStyleBackColor = true;
             this.ckbConvertTabs.CheckedChanged += new System.EventHandler(this.ckbConvertTabs_CheckedChanged);
             // 
             // ckbEnableCodeFolding
             // 
             this.ckbEnableCodeFolding.AutoSize = true;
             this.ckbEnableCodeFolding.Location = new System.Drawing.Point(7, 217);
             this.ckbEnableCodeFolding.Name = "ckbEnableCodeFolding";
             this.ckbEnableCodeFolding.Size = new System.Drawing.Size(124, 17);
             this.ckbEnableCodeFolding.TabIndex = 9;
             this.ckbEnableCodeFolding.Text = "Enable Code Folding";
             this.ckbEnableCodeFolding.UseVisualStyleBackColor = true;
             this.ckbEnableCodeFolding.CheckedChanged += new System.EventHandler(this.ckbEnableCodeFolding_CheckedChanged);
             // 
             // ckbShowVRuler
             // 
             this.ckbShowVRuler.AutoSize = true;
             this.ckbShowVRuler.Location = new System.Drawing.Point(7, 194);
             this.ckbShowVRuler.Name = "ckbShowVRuler";
             this.ckbShowVRuler.Size = new System.Drawing.Size(119, 17);
             this.ckbShowVRuler.TabIndex = 8;
             this.ckbShowVRuler.Text = "Show Vertical Ruler";
             this.ckbShowVRuler.UseVisualStyleBackColor = true;
             this.ckbShowVRuler.CheckedChanged += new System.EventHandler(this.ckbShowVRuler_CheckedChanged);
             // 
             // ckbShowHRuler
             // 
             this.ckbShowHRuler.AutoSize = true;
             this.ckbShowHRuler.Location = new System.Drawing.Point(7, 171);
             this.ckbShowHRuler.Name = "ckbShowHRuler";
             this.ckbShowHRuler.Size = new System.Drawing.Size(131, 17);
             this.ckbShowHRuler.TabIndex = 7;
             this.ckbShowHRuler.Text = "Show Horizontal Ruler";
             this.ckbShowHRuler.UseVisualStyleBackColor = true;
             this.ckbShowHRuler.CheckedChanged += new System.EventHandler(this.ckbShowHRuler_CheckedChanged);
             // 
             // ckbShowLineNumbes
             // 
             this.ckbShowLineNumbes.AutoSize = true;
             this.ckbShowLineNumbes.Location = new System.Drawing.Point(7, 148);
             this.ckbShowLineNumbes.Name = "ckbShowLineNumbes";
             this.ckbShowLineNumbes.Size = new System.Drawing.Size(121, 17);
             this.ckbShowLineNumbes.TabIndex = 6;
             this.ckbShowLineNumbes.Text = "Show Line Numbers";
             this.ckbShowLineNumbes.UseVisualStyleBackColor = true;
             this.ckbShowLineNumbes.CheckedChanged += new System.EventHandler(this.ckbShowLineNumbes_CheckedChanged);
             // 
             // ckbShowMatchingBracket
             // 
             this.ckbShowMatchingBracket.AutoSize = true;
             this.ckbShowMatchingBracket.Location = new System.Drawing.Point(7, 125);
             this.ckbShowMatchingBracket.Name = "ckbShowMatchingBracket";
             this.ckbShowMatchingBracket.Size = new System.Drawing.Size(145, 17);
             this.ckbShowMatchingBracket.TabIndex = 5;
             this.ckbShowMatchingBracket.Text = "Show Matching Brackets";
             this.ckbShowMatchingBracket.UseVisualStyleBackColor = true;
             this.ckbShowMatchingBracket.CheckedChanged += new System.EventHandler(this.ckbShowMatchingBracket_CheckedChanged);
             // 
             // ckbShowTabs
             // 
             this.ckbShowTabs.AutoSize = true;
             this.ckbShowTabs.Location = new System.Drawing.Point(7, 102);
             this.ckbShowTabs.Name = "ckbShowTabs";
             this.ckbShowTabs.Size = new System.Drawing.Size(116, 17);
             this.ckbShowTabs.TabIndex = 4;
             this.ckbShowTabs.Text = "Show Tab Markers";
             this.ckbShowTabs.UseVisualStyleBackColor = true;
             this.ckbShowTabs.CheckedChanged += new System.EventHandler(this.ckbShowTabs_CheckedChanged);
             // 
             // ckbShowSpaces
             // 
             this.ckbShowSpaces.AutoSize = true;
             this.ckbShowSpaces.Location = new System.Drawing.Point(7, 79);
             this.ckbShowSpaces.Name = "ckbShowSpaces";
             this.ckbShowSpaces.Size = new System.Drawing.Size(128, 17);
             this.ckbShowSpaces.TabIndex = 3;
             this.ckbShowSpaces.Text = "Show Space Markers";
             this.ckbShowSpaces.UseVisualStyleBackColor = true;
             this.ckbShowSpaces.CheckedChanged += new System.EventHandler(this.ckbShowSpaces_CheckedChanged);
             // 
             // ckbShowInvalidLines
             // 
             this.ckbShowInvalidLines.AutoSize = true;
             this.ckbShowInvalidLines.Location = new System.Drawing.Point(7, 56);
             this.ckbShowInvalidLines.Name = "ckbShowInvalidLines";
             this.ckbShowInvalidLines.Size = new System.Drawing.Size(149, 17);
             this.ckbShowInvalidLines.TabIndex = 2;
             this.ckbShowInvalidLines.Text = "Show Empty Line Markers";
             this.ckbShowInvalidLines.UseVisualStyleBackColor = true;
             this.ckbShowInvalidLines.CheckedChanged += new System.EventHandler(this.ckbShowInvalidLines_CheckedChanged);
             // 
             // ckbShowEol
             // 
             this.ckbShowEol.AutoSize = true;
             this.ckbShowEol.Location = new System.Drawing.Point(7, 33);
             this.ckbShowEol.Name = "ckbShowEol";
             this.ckbShowEol.Size = new System.Drawing.Size(151, 17);
             this.ckbShowEol.TabIndex = 1;
             this.ckbShowEol.Text = "Show End of Line Markers";
             this.ckbShowEol.UseVisualStyleBackColor = true;
             this.ckbShowEol.CheckedChanged += new System.EventHandler(this.ckbShowEol_CheckedChanged);
             // 
             // label4
             // 
             this.label4.AutoSize = true;
             this.label4.Font = new System.Drawing.Font("Microsoft Sans Serif", 14.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
             this.label4.Location = new System.Drawing.Point(3, 3);
             this.label4.Name = "label4";
             this.label4.Size = new System.Drawing.Size(143, 24);
             this.label4.TabIndex = 0;
             this.label4.Text = "Editor Options";
             // 
             // General
             // 
             this.General.Controls.Add(this.groupBox2);
             this.General.Controls.Add(this.groupBox1);
             this.General.Controls.Add(this.label1);
             this.General.Location = new System.Drawing.Point(18, 12);
             this.General.Name = "General";
             this.General.Size = new System.Drawing.Size(378, 261);
             this.General.TabIndex = 0;
             // 
             // groupBox2
             // 
             this.groupBox2.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                         | System.Windows.Forms.AnchorStyles.Right)));
             this.groupBox2.Controls.Add(this.ckbSaveOnExt);
             this.groupBox2.Location = new System.Drawing.Point(7, 30);
             this.groupBox2.Name = "groupBox2";
             this.groupBox2.Size = new System.Drawing.Size(368, 87);
             this.groupBox2.TabIndex = 8;
             this.groupBox2.TabStop = false;
             this.groupBox2.Text = "Layout";
             // 
             // ckbSaveOnExt
             // 
             this.ckbSaveOnExt.AutoSize = true;
             this.ckbSaveOnExt.Location = new System.Drawing.Point(6, 28);
             this.ckbSaveOnExt.Name = "ckbSaveOnExt";
             this.ckbSaveOnExt.Size = new System.Drawing.Size(121, 17);
             this.ckbSaveOnExt.TabIndex = 0;
             this.ckbSaveOnExt.Text = "Save Layout on Exit";
             this.ckbSaveOnExt.UseVisualStyleBackColor = true;
             // 
             // groupBox1
             // 
             this.groupBox1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                         | System.Windows.Forms.AnchorStyles.Right)));
             this.groupBox1.Controls.Add(this.nudRecentFile);
             this.groupBox1.Controls.Add(this.label3);
             this.groupBox1.Controls.Add(this.nudRecentProject);
             this.groupBox1.Controls.Add(this.label2);
             this.groupBox1.Location = new System.Drawing.Point(7, 123);
             this.groupBox1.Name = "groupBox1";
             this.groupBox1.Size = new System.Drawing.Size(368, 100);
             this.groupBox1.TabIndex = 7;
             this.groupBox1.TabStop = false;
             this.groupBox1.Text = "Recent Files";
             // 
             // nudRecentFile
             // 
             this.nudRecentFile.Location = new System.Drawing.Point(6, 30);
             this.nudRecentFile.Name = "nudRecentFile";
             this.nudRecentFile.Size = new System.Drawing.Size(72, 20);
             this.nudRecentFile.TabIndex = 3;
             this.nudRecentFile.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
             // 
             // label3
             // 
             this.label3.AutoSize = true;
             this.label3.Location = new System.Drawing.Point(84, 58);
             this.label3.Name = "label3";
             this.label3.Size = new System.Drawing.Size(112, 13);
             this.label3.TabIndex = 6;
             this.label3.Text = "Recent Project Coung";
             // 
             // nudRecentProject
             // 
             this.nudRecentProject.Location = new System.Drawing.Point(6, 56);
             this.nudRecentProject.Name = "nudRecentProject";
             this.nudRecentProject.Size = new System.Drawing.Size(72, 20);
             this.nudRecentProject.TabIndex = 4;
             this.nudRecentProject.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
             // 
             // label2
             // 
             this.label2.AutoSize = true;
             this.label2.Location = new System.Drawing.Point(84, 32);
             this.label2.Name = "label2";
             this.label2.Size = new System.Drawing.Size(92, 13);
             this.label2.TabIndex = 5;
             this.label2.Text = "Recent File Count";
             // 
             // label1
             // 
             this.label1.AutoSize = true;
             this.label1.Font = new System.Drawing.Font("Microsoft Sans Serif", 14.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
             this.label1.Location = new System.Drawing.Point(3, 3);
             this.label1.Name = "label1";
             this.label1.Size = new System.Drawing.Size(162, 24);
             this.label1.TabIndex = 1;
             this.label1.Text = "General Options";
             // 
             // btnOK
             // 
             this.btnOK.Location = new System.Drawing.Point(386, 321);
             this.btnOK.Name = "btnOK";
             this.btnOK.Size = new System.Drawing.Size(75, 23);
             this.btnOK.TabIndex = 1;
             this.btnOK.Text = "Ok";
             this.btnOK.UseVisualStyleBackColor = true;
             this.btnOK.Click += new System.EventHandler(this.btnOK_Click);
             // 
             // btnApply
             // 
             this.btnApply.Location = new System.Drawing.Point(467, 321);
             this.btnApply.Name = "btnApply";
             this.btnApply.Size = new System.Drawing.Size(75, 23);
             this.btnApply.TabIndex = 2;
             this.btnApply.Text = "Apply";
             this.btnApply.UseVisualStyleBackColor = true;
             this.btnApply.Click += new System.EventHandler(this.btnApply_Click);
             // 
             // btnCancel
             // 
             this.btnCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
             this.btnCancel.Location = new System.Drawing.Point(548, 321);
             this.btnCancel.Name = "btnCancel";
             this.btnCancel.Size = new System.Drawing.Size(75, 23);
             this.btnCancel.TabIndex = 3;
             this.btnCancel.Text = "Cancel";
             this.btnCancel.UseVisualStyleBackColor = true;
             this.btnCancel.Click += new System.EventHandler(this.btnCancel_Click);
             // 
             // fontDialog1
             // 
             this.fontDialog1.ShowEffects = false;
             // 
             // imgMain
             // 
             this.imgMain.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject("imgMain.ImageStream")));
             this.imgMain.TransparentColor = System.Drawing.Color.Transparent;
             this.imgMain.Images.SetKeyName(0, "OptionsHS.png");
             this.imgMain.Images.SetKeyName(1, "DisplayInColorHS.png");
             this.imgMain.Images.SetKeyName(2, "ShowRulelinesHS.png");
             // 
             // Options
             // 
             this.AcceptButton = this.btnOK;
             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.CancelButton = this.btnCancel;
             this.ClientSize = new System.Drawing.Size(635, 347);
             this.Controls.Add(this.btnCancel);
             this.Controls.Add(this.btnApply);
             this.Controls.Add(this.btnOK);
             this.Controls.Add(this.splitContainer1);
             this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
             this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
             this.MaximizeBox = false;
             this.MinimizeBox = false;
             this.Name = "Options";
             this.ShowInTaskbar = false;
             this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
             this.Text = "Options";
             this.splitContainer1.Panel1.ResumeLayout(false);
             this.splitContainer1.Panel2.ResumeLayout(false);
             this.splitContainer1.ResumeLayout(false);
             this.Editor.ResumeLayout(false);
             this.Editor.PerformLayout();
             ((System.ComponentModel.ISupportInitialize)(this.nudVRuler)).EndInit();
             ((System.ComponentModel.ISupportInitialize)(this.nudTabIndent)).EndInit();
             this.General.ResumeLayout(false);
             this.General.PerformLayout();
             this.groupBox2.ResumeLayout(false);
             this.groupBox2.PerformLayout();
             this.groupBox1.ResumeLayout(false);
             this.groupBox1.PerformLayout();
             ((System.ComponentModel.ISupportInitialize)(this.nudRecentFile)).EndInit();
             ((System.ComponentModel.ISupportInitialize)(this.nudRecentProject)).EndInit();
             this.ResumeLayout(false);
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="24" endline="207"><![CDATA[
         private System.ComponentModel.IContainer components = null;
         public Options(MainForm main)
         {
             InitializeComponent();
             this.m_MainForm = main;
             this.m_OptionPanels = new ArrayList();
             this.m_OptionPanels.Add(this.General);
             this.m_OptionPanels.Add(this.Editor);
 
             XmlDocument xDoc = new XmlDocument();
             xDoc.Load(this.m_MainForm.ConfigFile);
 
             XmlNodeList nodes = xDoc.GetElementsByTagName("SaveOnExit");
             if (nodes.Count > 0)
             {
                 this.ckbSaveOnExt.Checked = Convert.ToBoolean(nodes[0].InnerText);
             }
 
             nodes = xDoc.GetElementsByTagName("RecentFileCount");
             if (nodes.Count > 0)
             {
                 this.nudRecentFile.Value = Convert.ToInt32(nodes[0].InnerText);
             }
 
             nodes = xDoc.GetElementsByTagName("RecentProjectCount");
             if (nodes.Count > 0)
             {
                 this.nudRecentProject.Value = Convert.ToInt32(nodes[0].InnerText);
             }
 
             nodes = xDoc.GetElementsByTagName("Editor");
             if(nodes.Count > 0)
             {
                 foreach (XmlNode node in nodes[0].ChildNodes)
                 {
                     switch (node.Name.ToLower())
                     {
                         case "showeol"
                             this.ckbShowEol.Checked = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showinvalidlines"
                             this.ckbShowInvalidLines.Checked = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showspaces"
                             this.ckbShowSpaces.Checked = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showtabs"
                             this.ckbShowTabs.Checked = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showmatchbracket"
                             this.ckbShowMatchingBracket.Checked = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showlinenumbers"
                             this.ckbShowLineNumbes.Checked = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showhruler"
                             this.ckbShowHRuler.Checked = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showvruler"
                             this.ckbShowVRuler.Checked = Convert.ToBoolean(node.InnerText);
                             break;
                         case "enablecodefolding"
                             this.ckbEnableCodeFolding.Checked = Convert.ToBoolean(node.InnerText);
                             break;
                         case "converttabs"
                             this.ckbConvertTabs.Checked = Convert.ToBoolean(node.InnerText);
                             break;
                         case "useantialias"
                             this.ckbUseAntiAlias.Checked = Convert.ToBoolean(node.InnerText);
                             break;
                         case "allowcaretbeyondeol"
                             this.ckbAllowCaretBeyondEol.Checked = Convert.ToBoolean(node.InnerText);
                             break;
                         case "highlightcurrentline"
                             this.ckbHighlightCurrentLine.Checked= Convert.ToBoolean(node.InnerText);
                             break;
                         case "autoinsertbracket"
                             this.ckbAutoInsertBracket.Checked = Convert.ToBoolean(node.InnerText);
                             break;
                         case "tabindent"
                             this.nudTabIndent.Value = Convert.ToInt32(node.InnerText);
                             break;
                         case "verticalrulercol"
                             this.nudVRuler.Value = Convert.ToInt32(node.InnerText);
                             break;
                         case "indentstyle"
                             this.cmbIndentStyle.Text = node.InnerText;
                             break;
                         case "bracketmatchingstyle"
                             this.cmbBracketStyle.Text = node.InnerText;
                             break;
                         case "font"
                             string[] font = node.InnerText.Split(';');
                             Font f = new Font(font[0], Convert.ToSingle(font[1]));
                             this.fontDialog1.Font = f;
                             this.textEditorControl1.Font = f;
                             break;
                     }
                 }
                 foreach (XmlNode node in nodes[0].ChildNodes)
                 {
                     switch (node.Name.ToLower())
                     {
                         case "showeol"
                             this.ckbShowEol.Checked = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showinvalidlines"
                             this.ckbShowInvalidLines.Checked = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showspaces"
                             this.ckbShowSpaces.Checked = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showtabs"
                             this.ckbShowTabs.Checked = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showmatchbracket"
                             this.ckbShowMatchingBracket.Checked = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showlinenumbers"
                             this.ckbShowLineNumbes.Checked = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showhruler"
                             this.ckbShowHRuler.Checked = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showvruler"
                             this.ckbShowVRuler.Checked = Convert.ToBoolean(node.InnerText);
                             break;
                         case "enablecodefolding"
                             this.ckbEnableCodeFolding.Checked = Convert.ToBoolean(node.InnerText);
                             break;
                         case "converttabs"
                             this.ckbConvertTabs.Checked = Convert.ToBoolean(node.InnerText);
                             break;
                         case "useantialias"
                             this.ckbUseAntiAlias.Checked = Convert.ToBoolean(node.InnerText);
                             break;
                         case "allowcaretbeyondeol"
                             this.ckbAllowCaretBeyondEol.Checked = Convert.ToBoolean(node.InnerText);
                             break;
                         case "highlightcurrentline"
                             this.ckbHighlightCurrentLine.Checked= Convert.ToBoolean(node.InnerText);
                             break;
                         case "autoinsertbracket"
                             this.ckbAutoInsertBracket.Checked = Convert.ToBoolean(node.InnerText);
                             break;
                         case "tabindent"
                             this.nudTabIndent.Value = Convert.ToInt32(node.InnerText);
                             break;
                         case "verticalrulercol"
                             this.nudVRuler.Value = Convert.ToInt32(node.InnerText);
                             break;
                         case "indentstyle"
                             this.cmbIndentStyle.Text = node.InnerText;
                             break;
                         case "bracketmatchingstyle"
                             this.cmbBracketStyle.Text = node.InnerText;
                             break;
                         case "font"
                             string[] font = node.InnerText.Split(';');
                             Font f = new Font(font[0], Convert.ToSingle(font[1]));
                             this.fontDialog1.Font = f;
                             this.textEditorControl1.Font = f;
                             break;
                     }
                 }
             }
 
             this.textEditorControl1.SetHighlighting("Java");
             this.textEditorControl1.Text = "public class Foo\r\n" +
                                             "{\r\n" +
                                             "	public int[] X = new int[]{1, 3, 5\r\n" +
                                             "		7, 9, 11};\r\n" +
                                             "\r\n" +
                                             "	public void foo(boolean a, int x,\r\n" +
                                             "	                int y, int z)\r\n" +
                                             "	{\r\n" +
                                             "		label1
                                             "		do\r\n" +
                                             "		{\r\n" +
                                             "			try\r\n" +
                                             "			{\r\n" +
                                             "				if (x > 0)\r\n" +
                                             "				{\r\n" +
                                             "					int someVariable = a ?\r\n" +
                                             "						x 
                                             "						y;\r\n" +
                                             "				}\r\n" +
                                             "				else if (x < 0)\r\n" +
                                             "				{\r\n" +
                                             "					int someVariable = (y +\r\n" +
                                             "						z\r\n" +
                                             "					);\r\n" +
                                             "					someVariable = x =\r\n" +
                                             "						x +\r\n" +
                                             "							y;\r\n" +
                                             "				}\r\n" +
                                             "				else\r\n" +
                                             "				{\r\n" +
                                             "					label2
                                             "					for (int i = 0;\r\n" +
                                             "					     i < 5;\r\n" +
                                             "					     i++)\r\n" +
                                             "						doSomething(i);\r\n" +
                                             "				}\r\n" +
                                             "				switch (a)\r\n" +
                                             "				{\r\n" +
                                             "					case 0
                                             "						doCase0()\r\n;" +
                                             "						break;\r\n" +
                                             "					default
                                             "						doDefault();\r\n" +
                                             "				}\r\n" +
                                             "			}\r\n" +
                                             "			catch (Exception e)\r\n" +
                                             "			{\r\n" +
                                             "				processException(e.getMessage(),\r\n" +
                                             "					x + y, z, a);\r\n" +
                                             "			\r\n}" +
                                             "			finally\r\n" +
                                             "			{\r\n" +
                                             "				processFinally();\r\n" +
                                             "			}\r\n" +
                                             "		}\r\n" +
                                             "		while (true);\r\n" +
                                             "\r\n" +
                                             "		if (2 < 3) return;\r\n" +
                                             "		if (3 < 4)\r\n" +
                                             "			return;\r\n" +
                                             "		do x++ while (x < 10000);\r\n" +
                                             "		while (x < 50000) x++;\r\n" +
                                             "		for (int i = 0; i < 5; i++) System.out.println(i);\r\n" +
                                             "	}\r\n" +
                                             "}";
             this.UpdateEditor();
             this.lstMain.Items[0].Selected = true;
             this.m_EditorChanged = false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="208" endline="225"><![CDATA[
 
         #endregion
 
         /// <summary>
         /// Adds an Option panel...
         /// </summary>
         /// <param name="panel">Panel to Add</param>
         public void AddOptionPanel(Control panel, Image image)
         {
             this.m_OptionPanels.Add(panel);
             ListViewItem lvi = new ListViewItem(panel.Name);
             if (image != null)
             {
                 int index = this.imgMain.Images.Add(image, Color.Transparent);
                 lvi.ImageIndex = index;
             }
             this.lstMain.Items.Add(lvi);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="226" endline="248"><![CDATA[
 
         /// <summary>
         /// Displays the selected option's panel
         /// </summary>
         /// <param name="sender">Options Dialog Options ListView</param>
         /// <param name="e">Events</param>
         private void lstMain_SelectedIndexChanged(object sender, EventArgs e)
         {
             if (this.lstMain.SelectedItems.Count == 1)
             {
                 for (int a = 0; a < this.m_OptionPanels.Count; a++)
                 {
                     Control ctrl = (Control)this.m_OptionPanels[a];
                     if (ctrl.Name == lstMain.SelectedItems[0].Text)
                     {
                         this.splitContainer1.Panel2.Controls.Clear();
                         ctrl.Dock = DockStyle.Fill;
                         this.splitContainer1.Panel2.Controls.Add(ctrl);
                         break;
                     }
                 }
                 for (int a = 0; a < this.m_OptionPanels.Count; a++)
                 {
                     Control ctrl = (Control)this.m_OptionPanels[a];
                     if (ctrl.Name == lstMain.SelectedItems[0].Text)
                     {
                         this.splitContainer1.Panel2.Controls.Clear();
                         ctrl.Dock = DockStyle.Fill;
                         this.splitContainer1.Panel2.Controls.Add(ctrl);
                         break;
                     }
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="249" endline="258"><![CDATA[
 
         /// <summary>
         /// Occurs when Cancel Button is clicked. Closes the Options window
         /// </summary>
         /// <param name="sender">Options Dialog Cancel Button</param>
         /// <param name="e">Events</param>
         private void btnCancel_Click(object sender, EventArgs e)
         {
             this.Close();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="259" endline="269"><![CDATA[
 
         /// <summary>
         /// Occurs when OK Button is clicked. Saves all selected options and closes the window
         /// </summary>
         /// <param name="sender">Options dialog OK Button</param>
         /// <param name="e">Events</param>
         private void btnOK_Click(object sender, EventArgs e)
         {
             this.btnApply_Click(sender, e);
             this.Close();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="270" endline="380"><![CDATA[
 
         /// <summary>
         /// Occurs when the Apply button is clicked. It applies all the selected options to the application
         /// </summary>
         /// <param name="sender">Options Dialog Apply Button</param>
         /// <param name="e">Events</param>
         private void btnApply_Click(object sender, EventArgs e)
         {
             this.Cursor = Cursors.WaitCursor;
             this.m_MainForm.Trace("Applying General Options");
             XmlDocument xDoc = new XmlDocument();
             xDoc.Load(this.m_MainForm.ConfigFile);
 
             XmlNodeList nodes = xDoc.GetElementsByTagName("SaveOnExit");
             if (nodes.Count > 0)
             {
                 nodes[0].InnerText = this.ckbSaveOnExt.Checked.ToString();
             }
 
             nodes = xDoc.GetElementsByTagName("RecentFileCount");
             if (nodes.Count > 0)
             {
                 nodes[0].InnerText = this.nudRecentFile.Value.ToString();
             }
 
             nodes = xDoc.GetElementsByTagName("RecentProjectCount");
             if (nodes.Count > 0)
             {
                 nodes[0].InnerText = this.nudRecentProject.Value.ToString();
             }
 
             if (this.m_EditorChanged)
             {
                 this.m_MainForm.Trace("Applying Editor Options");
                 nodes = xDoc.GetElementsByTagName("Editor");
                 if (nodes.Count > 0)
                 {
                     foreach (XmlNode node in nodes[0].ChildNodes)
                     {
                         switch (node.Name.ToLower())
                         {
                             case "showeol"
                                 node.InnerText = this.ckbShowEol.Checked.ToString();
                                 break;
                             case "showinvalidlines"
                                 node.InnerText = this.ckbShowInvalidLines.Checked.ToString();
                                 break;
                             case "showspaces"
                                 node.InnerText = this.ckbShowSpaces.Checked.ToString();
                                 break;
                             case "showtabs"
                                 node.InnerText = this.ckbShowTabs.Checked.ToString();
                                 break;
                             case "showmatchbracket"
                                 node.InnerText = this.ckbShowMatchingBracket.Checked.ToString();
                                 break;
                             case "showlinenumbers"
                                 node.InnerText = this.ckbShowLineNumbes.Checked.ToString();
                                 break;
                             case "showhruler"
                                 node.InnerText = this.ckbShowHRuler.Checked.ToString();
                                 break;
                             case "showvruler"
                                 node.InnerText = this.ckbShowVRuler.Checked.ToString();
                                 break;
                             case "enablecodefolding"
                                 node.InnerText = this.ckbEnableCodeFolding.Checked.ToString();
                                 break;
                             case "converttabs"
                                 node.InnerText = this.ckbConvertTabs.Checked.ToString();
                                 break;
                             case "useantialias"
                                 node.InnerText = this.ckbUseAntiAlias.Checked.ToString();
                                 break;
                             case "allowcaretbeyondeol"
                                 node.InnerText = this.ckbAllowCaretBeyondEol.Checked.ToString();
                                 break;
                             case "highlightcurrentline"
                                 node.InnerText = this.ckbHighlightCurrentLine.Checked.ToString();
                                 break;
                             case "autoinsertbracket"
                                 node.InnerText = this.ckbAutoInsertBracket.Checked.ToString();
                                 break;
                             case "tabindent"
                                 node.InnerText = this.nudTabIndent.Value.ToString();
                                 break;
                             case "verticalrulercol"
                                 node.InnerText = this.nudVRuler.Value.ToString();
                                 break;
                             case "indentstyle"
                                 node.InnerText = this.cmbIndentStyle.Text.ToString();
                                 break;
                             case "bracketmatchingstyle"
                                 node.InnerText = this.cmbBracketStyle.Text.ToString();
                                 break;
                             case "font"
                                 string font = this.textEditorControl1.Font.FontFamily.Name + ";" + textEditorControl1.Font.Size.ToString();
                                 node.InnerText = font;
                                 break;
                         }
                     }
                     foreach (XmlNode node in nodes[0].ChildNodes)
                     {
                         switch (node.Name.ToLower())
                         {
                             case "showeol"
                                 node.InnerText = this.ckbShowEol.Checked.ToString();
                                 break;
                             case "showinvalidlines"
                                 node.InnerText = this.ckbShowInvalidLines.Checked.ToString();
                                 break;
                             case "showspaces"
                                 node.InnerText = this.ckbShowSpaces.Checked.ToString();
                                 break;
                             case "showtabs"
                                 node.InnerText = this.ckbShowTabs.Checked.ToString();
                                 break;
                             case "showmatchbracket"
                                 node.InnerText = this.ckbShowMatchingBracket.Checked.ToString();
                                 break;
                             case "showlinenumbers"
                                 node.InnerText = this.ckbShowLineNumbes.Checked.ToString();
                                 break;
                             case "showhruler"
                                 node.InnerText = this.ckbShowHRuler.Checked.ToString();
                                 break;
                             case "showvruler"
                                 node.InnerText = this.ckbShowVRuler.Checked.ToString();
                                 break;
                             case "enablecodefolding"
                                 node.InnerText = this.ckbEnableCodeFolding.Checked.ToString();
                                 break;
                             case "converttabs"
                                 node.InnerText = this.ckbConvertTabs.Checked.ToString();
                                 break;
                             case "useantialias"
                                 node.InnerText = this.ckbUseAntiAlias.Checked.ToString();
                                 break;
                             case "allowcaretbeyondeol"
                                 node.InnerText = this.ckbAllowCaretBeyondEol.Checked.ToString();
                                 break;
                             case "highlightcurrentline"
                                 node.InnerText = this.ckbHighlightCurrentLine.Checked.ToString();
                                 break;
                             case "autoinsertbracket"
                                 node.InnerText = this.ckbAutoInsertBracket.Checked.ToString();
                                 break;
                             case "tabindent"
                                 node.InnerText = this.nudTabIndent.Value.ToString();
                                 break;
                             case "verticalrulercol"
                                 node.InnerText = this.nudVRuler.Value.ToString();
                                 break;
                             case "indentstyle"
                                 node.InnerText = this.cmbIndentStyle.Text.ToString();
                                 break;
                             case "bracketmatchingstyle"
                                 node.InnerText = this.cmbBracketStyle.Text.ToString();
                                 break;
                             case "font"
                                 string font = this.textEditorControl1.Font.FontFamily.Name + ";" + textEditorControl1.Font.Size.ToString();
                                 node.InnerText = font;
                                 break;
                         }
                     }
                 }
             }
 
             xDoc.Save(this.m_MainForm.ConfigFile);
 
             this.m_MainForm.Trace("Applying All Options");
             this.m_MainForm.LoadConfigFile(true);
             this.Cursor = Cursors.Default;
             this.m_MainForm.Trace("");
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="381" endline="396"><![CDATA[
 
         /// <summary>
         /// Occurs when Font button of Editor Options Tab is clicked
         /// Displays Font Dialog and sets Font of the text editor
         /// </summary>
         /// <param name="sender">Editor Options Tab Font Button</param>
         /// <param name="e">Events</param>
         private void btnFont_Click(object sender, EventArgs e)
         {
             this.fontDialog1.Font = this.textEditorControl1.Font;
             if (this.fontDialog1.ShowDialog() == DialogResult.OK)
             {
                 this.textEditorControl1.Font = this.fontDialog1.Font;
                 this.m_EditorChanged = true;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="397" endline="447"><![CDATA[
 
         /// <summary>
         /// Updates  the text editor with all changes made in the options tab
         /// </summary>
         private void UpdateEditor()
         {
             this.textEditorControl1.ShowEOLMarkers = this.ckbShowEol.Checked;
             this.textEditorControl1.ShowInvalidLines = this.ckbShowInvalidLines.Checked;
             this.textEditorControl1.ShowSpaces = this.ckbShowSpaces.Checked;
             this.textEditorControl1.ShowTabs = this.ckbShowTabs.Checked;
             this.textEditorControl1.ShowMatchingBracket = this.ckbShowMatchingBracket.Checked;
             this.textEditorControl1.ShowLineNumbers = this.ckbShowLineNumbes.Checked;
             this.textEditorControl1.ShowHRuler = this.ckbShowHRuler.Checked;
             this.textEditorControl1.ShowVRuler = this.ckbShowVRuler.Checked;
             this.textEditorControl1.EnableFolding = this.ckbEnableCodeFolding.Checked;
             this.textEditorControl1.ConvertTabsToSpaces = this.ckbConvertTabs.Checked;
             this.textEditorControl1.UseAntiAliasFont = this.ckbUseAntiAlias.Checked; // #develop 2
             /* // #develop 3
             if (this.ckbUseAntiAlias.Checked)
             {
                 this.textEditorControl1.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAliasGridFit;
             }*/
             this.textEditorControl1.AllowCaretBeyondEOL = this.ckbAllowCaretBeyondEol.Checked;
             this.textEditorControl1.TextEditorProperties.AutoInsertCurlyBracket = this.ckbAutoInsertBracket.Checked;
             this.textEditorControl1.TabIndent = Convert.ToInt32(this.nudTabIndent.Value);
             this.textEditorControl1.VRulerRow = Convert.ToInt32(this.nudVRuler.Value);
 
             this.textEditorControl1.LineViewerStyle = (this.ckbHighlightCurrentLine.Checked) ? LineViewerStyle.FullRow 
             switch (this.cmbBracketStyle.Text.ToLower())
             {
                 case "before"
                     this.textEditorControl1.BracketMatchingStyle = BracketMatchingStyle.Before;
                     break;
                 case "after"
                     this.textEditorControl1.BracketMatchingStyle = BracketMatchingStyle.After;
                     break;
             }
             switch (this.cmbIndentStyle.Text.ToLower())
             {
                 case "auto"
                     this.textEditorControl1.IndentStyle = IndentStyle.Auto;
                     break;
                 case "none"
                     this.textEditorControl1.IndentStyle = IndentStyle.None;
                     break;
                 case "smart"
                     this.textEditorControl1.IndentStyle = IndentStyle.Smart;
                     break;
             }
             this.m_EditorChanged = true;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="448" endline="452"><![CDATA[
 
         private void ckbShowEol_CheckedChanged(object sender, EventArgs e)
         {
             this.UpdateEditor();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="453" endline="457"><![CDATA[
 
         private void ckbShowInvalidLines_CheckedChanged(object sender, EventArgs e)
         {
             this.UpdateEditor();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="458" endline="462"><![CDATA[
 
         private void ckbShowSpaces_CheckedChanged(object sender, EventArgs e)
         {
             this.UpdateEditor();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="463" endline="467"><![CDATA[
 
         private void ckbShowTabs_CheckedChanged(object sender, EventArgs e)
         {
             this.UpdateEditor();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="468" endline="472"><![CDATA[
 
         private void ckbShowMatchingBracket_CheckedChanged(object sender, EventArgs e)
         {
             this.UpdateEditor();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="473" endline="477"><![CDATA[
 
         private void ckbShowLineNumbes_CheckedChanged(object sender, EventArgs e)
         {
             this.UpdateEditor();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="478" endline="482"><![CDATA[
 
         private void ckbShowHRuler_CheckedChanged(object sender, EventArgs e)
         {
             this.UpdateEditor();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="483" endline="487"><![CDATA[
 
         private void ckbShowVRuler_CheckedChanged(object sender, EventArgs e)
         {
             this.UpdateEditor();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="488" endline="492"><![CDATA[
 
         private void ckbEnableCodeFolding_CheckedChanged(object sender, EventArgs e)
         {
             this.UpdateEditor();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="493" endline="497"><![CDATA[
 
         private void ckbConvertTabs_CheckedChanged(object sender, EventArgs e)
         {
             this.UpdateEditor();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="498" endline="502"><![CDATA[
 
         private void ckbUseAntiAlias_CheckedChanged(object sender, EventArgs e)
         {
             this.UpdateEditor();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="503" endline="507"><![CDATA[
 
         private void ckbAllowCaretBeyondEol_CheckedChanged(object sender, EventArgs e)
         {
             this.UpdateEditor();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="508" endline="512"><![CDATA[
 
         private void ckbHighlightCurrentLine_CheckedChanged(object sender, EventArgs e)
         {
             this.UpdateEditor();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="513" endline="517"><![CDATA[
 
         private void ckbAutoInsertBracket_CheckedChanged(object sender, EventArgs e)
         {
             this.UpdateEditor();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="518" endline="522"><![CDATA[
 
         private void nudTabIndent_ValueChanged(object sender, EventArgs e)
         {
             this.UpdateEditor();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="523" endline="527"><![CDATA[
 
         private void nudVRuler_ValueChanged(object sender, EventArgs e)
         {
             this.UpdateEditor();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="528" endline="532"><![CDATA[
 
         private void cmbIndentStyle_SelectedIndexChanged(object sender, EventArgs e)
         {
             this.UpdateEditor();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="533" endline="537"><![CDATA[
 
         private void cmbBracketStyle_SelectedIndexChanged(object sender, EventArgs e)
         {
             this.UpdateEditor();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="28" endline="31"><![CDATA[
         {
             if (errDist >= minErrDist) Errors.SynErr(n, t.line, t.col);
             errDist = 0;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="32" endline="37"><![CDATA[
 
         public static void SemErr(int n)
         {
             if (errDist >= minErrDist) Errors.SemErr(n, token.line, token.col);
             errDist = 0;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="38" endline="53"><![CDATA[
 
         static void Get()
         {
             for (; ; )
             {
                 token = t;
                 t = Scanner.Scan();
                 if (t.kind <= maxT) { errDist++; return; }
                 if (t.kind == 40)
                 {
                     Tab.SetDDT(t.val);
                 }
 
                 t = token;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="54" endline="58"><![CDATA[
 
         static void Expect(int n)
         {
             if (t.kind == n) Get(); else Error(n);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="59" endline="63"><![CDATA[
 
         static bool StartOf(int s)
         {
             return set[s, t.kind];
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="64" endline="73"><![CDATA[
 
         static void ExpectWeak(int n, int follow)
         {
             if (t.kind == n) Get();
             else
             {
                 Error(n);
                 while (!StartOf(follow)) Get();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="74" endline="90"><![CDATA[
 
         static bool WeakSeparator(int n, int syFol, int repFol)
         {
             bool[] s = new bool[maxT + 1];
             if (t.kind == n) { Get(); return true; }
             else if (StartOf(repFol)) return false;
             else
             {
                 for (int i = 0; i <= maxT; i++)
                 {
                     s[i] = set[syFol, i] || set[repFol, i] || set[0, i];
                 }
                 for (int i = 0; i <= maxT; i++)
                 {
                     s[i] = set[syFol, i] || set[repFol, i] || set[0, i];
                 }
                 Error(n);
                 while (!s[t.kind]) Get();
                 return StartOf(syFol);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="91" endline="194"><![CDATA[
 
         static void Coco()
         {
             Symbol sym; Graph g;
             if (t.kind == 37)
             {
                 UsingDecl(out ParserGen.usingPos);
             }
             Expect(6);
             int gramLine = token.line;
             genScanner = true;
             bool ok = true;
             Tab.ignored = null;
             Expect(1);
             string gramName = token.val;
             int beg = t.pos;
             while (StartOf(1))
             {
                 Get();
             }
             while (StartOf(1))
             {
                 Get();
             }
             Tab.semDeclPos = new Position(beg, t.pos - beg, 0);
             while (StartOf(2))
             {
                 Declaration();
             }
             while (StartOf(2))
             {
                 Declaration();
             }
             while (!(t.kind == 0 || t.kind == 7)) { Error(40); Get(); }
             Expect(7);
             if (genScanner) DFA.MakeDeterministic();
             Graph.DeleteNodes();
             while (t.kind == 1)
             {
                 Get();
                 sym = Symbol.Find(token.val);
                 bool undef = sym == null;
                 if (undef)
                 {
                     sym = new Symbol(Node.nt, token.val, token.line);
                 }
                 else
                 {
                     if (sym.typ == Node.nt)
                     {
                         if (sym.graph != null) SemErr(7);
                     }
                     else SemErr(8);
                     sym.line = token.line;
                 }
                 bool noAttrs = sym.attrPos == null; sym.attrPos = null;
 
                 if (t.kind == 23)
                 {
                     AttrDecl(sym);
                 }
                 if (!undef)
                     if (noAttrs != (sym.attrPos == null)) SemErr(5);
 
                 if (t.kind == 35)
                 {
                     SemText(out sym.semPos);
                 }
                 ExpectWeak(8, 3);
                 Expression(out g);
                 sym.graph = g.l;
                 Graph.Finish(g);
                 ExpectWeak(9, 4);
             }
             while (t.kind == 1)
             {
                 Get();
                 sym = Symbol.Find(token.val);
                 bool undef = sym == null;
                 if (undef)
                 {
                     sym = new Symbol(Node.nt, token.val, token.line);
                 }
                 else
                 {
                     if (sym.typ == Node.nt)
                     {
                         if (sym.graph != null) SemErr(7);
                     }
                     else SemErr(8);
                     sym.line = token.line;
                 }
                 bool noAttrs = sym.attrPos == null; sym.attrPos = null;
 
                 if (t.kind == 23)
                 {
                     AttrDecl(sym);
                 }
                 if (!undef)
                     if (noAttrs != (sym.attrPos == null)) SemErr(5);
 
                 if (t.kind == 35)
                 {
                     SemText(out sym.semPos);
                 }
                 ExpectWeak(8, 3);
                 Expression(out g);
                 sym.graph = g.l;
                 Graph.Finish(g);
                 ExpectWeak(9, 4);
             }
             Expect(10);
             Expect(1);
             if (gramName != token.val) SemErr(17);
             Tab.gramSy = Symbol.Find(gramName);
             if (Tab.gramSy == null) SemErr(11);
             else
             {
                 sym = Tab.gramSy;
                 if (sym.attrPos != null) SemErr(12);
             }
             Tab.noSym = new Symbol(Node.t, "???", 0); // noSym gets highest number
             Tab.SetupAnys();
             Tab.RenumberPragmas();
             if (Tab.ddt[2]) Node.PrintNodes();
             if (Errors.count == 0)
             {
                 Console.WriteLine("checking");
                 Tab.CompSymbolSets();
                 ok = ok && Tab.GrammarOk();
 
                 if (Tab.ddt[7]) Tab.XRef();
                 if (ok)
                 {
                     Console.Write("parser");
                     ParserGen.WriteParser();
                     if (genScanner)
                     {
                         Console.Write(" + scanner");
                         DFA.WriteScanner();
                         if (Tab.ddt[0]) DFA.PrintStates();
                     }
                     Console.WriteLine(" generated");
                     if (Tab.ddt[8]) ParserGen.WriteStatistics();
                 }
             }
             if (Tab.ddt[6]) Tab.PrintSymbolTable();
             Expect(9);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="195" endline="217"><![CDATA[
 
         static void UsingDecl(out Position pos)
         {
             Expect(37);
             int beg = token.pos;
             while (StartOf(5))
             {
                 Get();
             }
             while (StartOf(5))
             {
                 Get();
             }
             Expect(38);
             int end = token.pos;
             while (t.kind == 37)
             {
                 Get();
                 while (StartOf(5))
                 {
                     Get();
                 }
                 while (StartOf(5))
                 {
                     Get();
                 }
                 Expect(38);
                 end = token.pos;
             }
             while (t.kind == 37)
             {
                 Get();
                 while (StartOf(5))
                 {
                     Get();
                 }
                 Expect(38);
                 end = token.pos;
             }
             pos = new Position(beg, end - beg + 1, 0);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="218" endline="273"><![CDATA[
 
         static void Declaration()
         {
             Graph g1, g2; bool nested = false;
             if (t.kind == 11)
             {
                 Get();
                 while (t.kind == 1)
                 {
                     SetDecl();
                 }
                 while (t.kind == 1)
                 {
                     SetDecl();
                 }
             }
             else if (t.kind == 12)
             {
                 Get();
                 while (t.kind == 1 || t.kind == 3 || t.kind == 5)
                 {
                     TokenDecl(Node.t);
                 }
                 while (t.kind == 1 || t.kind == 3 || t.kind == 5)
                 {
                     TokenDecl(Node.t);
                 }
             }
             else if (t.kind == 13)
             {
                 Get();
                 while (t.kind == 1 || t.kind == 3 || t.kind == 5)
                 {
                     TokenDecl(Node.pr);
                 }
                 while (t.kind == 1 || t.kind == 3 || t.kind == 5)
                 {
                     TokenDecl(Node.pr);
                 }
             }
             else if (t.kind == 14)
             {
                 Get();
                 Expect(15);
                 TokenExpr(out g1);
                 Expect(16);
                 TokenExpr(out g2);
                 if (t.kind == 17)
                 {
                     Get();
                     nested = true;
                 }
                 else if (StartOf(6))
                 {
                     nested = false;
                 }
                 else Error(41);
                 new Comment(g1.l, g2.l, nested);
             }
             else if (t.kind == 18)
             {
                 Get();
                 Set(out Tab.ignored);
                 Tab.ignored[' '] = true; /* ' ' is always ignored */
                 if (Tab.ignored[0]) SemErr(9);
             }
             else Error(42);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="274" endline="293"><![CDATA[
 
         static void AttrDecl(Symbol sym)
         {
             Expect(23);
             int beg = t.pos; int col = t.col;
             while (StartOf(7))
             {
                 if (StartOf(8))
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                     SemErr(18);
                 }
             }
             while (StartOf(7))
             {
                 if (StartOf(8))
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                     SemErr(18);
                 }
             }
             Expect(24);
             sym.attrPos = new Position(beg, token.pos - beg, col);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="294" endline="318"><![CDATA[
 
         static void SemText(out Position pos)
         {
             Expect(35);
             int beg = t.pos; int col = t.col;
             while (StartOf(9))
             {
                 if (StartOf(10))
                 {
                     Get();
                 }
                 else if (t.kind == 4)
                 {
                     Get();
                     SemErr(18);
                 }
                 else
                 {
                     Get();
                     SemErr(19);
                 }
             }
             while (StartOf(9))
             {
                 if (StartOf(10))
                 {
                     Get();
                 }
                 else if (t.kind == 4)
                 {
                     Get();
                     SemErr(18);
                 }
                 else
                 {
                     Get();
                     SemErr(19);
                 }
             }
             Expect(36);
             pos = new Position(beg, token.pos - beg, col);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="319" endline="331"><![CDATA[
 
         static void Expression(out Graph g)
         {
             Graph g2;
             Term(out g);
             bool first = true;
             while (WeakSeparator(25, 11, 12))
             {
                 Term(out g2);
                 if (first) { Graph.MakeFirstAlt(g); first = false; }
                 Graph.MakeAlternative(g, g2);
             }
             while (WeakSeparator(25, 11, 12))
             {
                 Term(out g2);
                 if (first) { Graph.MakeFirstAlt(g); first = false; }
                 Graph.MakeAlternative(g, g2);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="332" endline="345"><![CDATA[
 
         static void SetDecl()
         {
             BitArray s;
             Expect(1);
             string name = token.val;
             CharClass c = CharClass.Find(name);
             if (c != null) SemErr(7);
             Expect(8);
             Set(out s);
             if (Sets.Elements(s) == 0) SemErr(1);
             c = new CharClass(name, s);
             Expect(9);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="346" endline="379"><![CDATA[
 
         static void TokenDecl(int typ)
         {
             string name; int kind; Symbol sym; Graph g;
             Sym(out name, out kind);
             sym = Symbol.Find(name);
             if (sym != null) SemErr(7);
             else
             {
                 sym = new Symbol(typ, name, token.line);
                 sym.tokenKind = Symbol.classToken;
             }
             while (!(StartOf(13))) { Error(43); Get(); }
             if (t.kind == 8)
             {
                 Get();
                 TokenExpr(out g);
                 Expect(9);
                 if (kind != id) SemErr(13);
                 Graph.Finish(g);
                 DFA.ConvertToStates(g.l, sym);
             }
             else if (StartOf(14))
             {
                 if (kind == id) genScanner = false;
                 else DFA.MatchLiteral(sym);
             }
             else Error(44);
             if (t.kind == 35)
             {
                 SemText(out sym.semPos);
                 if (typ == Node.t) SemErr(14);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="380" endline="392"><![CDATA[
 
         static void TokenExpr(out Graph g)
         {
             Graph g2;
             TokenTerm(out g);
             bool first = true;
             while (WeakSeparator(25, 15, 16))
             {
                 TokenTerm(out g2);
                 if (first) { Graph.MakeFirstAlt(g); first = false; }
                 Graph.MakeAlternative(g, g2);
             }
             while (WeakSeparator(25, 15, 16))
             {
                 TokenTerm(out g2);
                 if (first) { Graph.MakeFirstAlt(g); first = false; }
                 Graph.MakeAlternative(g, g2);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="393" endline="413"><![CDATA[
 
         static void Set(out BitArray s)
         {
             BitArray s2;
             SimSet(out s);
             while (t.kind == 19 || t.kind == 20)
             {
                 if (t.kind == 19)
                 {
                     Get();
                     SimSet(out s2);
                     s.Or(s2);
                 }
                 else
                 {
                     Get();
                     SimSet(out s2);
                     Sets.Subtract(s, s2);
                 }
             }
             while (t.kind == 19 || t.kind == 20)
             {
                 if (t.kind == 19)
                 {
                     Get();
                     SimSet(out s2);
                     s.Or(s2);
                 }
                 else
                 {
                     Get();
                     SimSet(out s2);
                     Sets.Subtract(s, s2);
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="414" endline="450"><![CDATA[
 
         static void SimSet(out BitArray s)
         {
             int n1, n2;
             s = new BitArray(CharClass.charSetSize);
             if (t.kind == 1)
             {
                 Get();
                 CharClass c = CharClass.Find(token.val);
                 if (c == null) SemErr(15); else s.Or(c.set);
             }
             else if (t.kind == 3)
             {
                 Get();
                 string name = token.val;
                 name = DFA.Unescape(name.Substring(1, name.Length - 2));
                 foreach (char ch in name) s[ch] = true;
             }
             else if (t.kind == 5)
             {
                 Char(out n1);
                 s[n1] = true;
                 if (t.kind == 21)
                 {
                     Get();
                     Char(out n2);
                     for (int i = n1; i <= n2; i++) s[i] = true;
                 }
             }
             else if (t.kind == 22)
             {
                 Get();
                 s = new BitArray(CharClass.charSetSize, true);
                 s[0] = false;
             }
             else Error(45);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="451" endline="461"><![CDATA[
 
         static void Char(out int n)
         {
             Expect(5);
             string name = token.val;
             name = DFA.Unescape(name.Substring(1, name.Length - 2));
             int max = CharClass.charSetSize;
             if (name.Length != 1 || name[0] > max - 1) SemErr(2);
             n = name[0] % max;
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="462" endline="486"><![CDATA[
 
         static void Sym(out string name, out int kind)
         {
             name = "???"; kind = id;
             if (t.kind == 1)
             {
                 Get();
                 kind = id; name = token.val;
             }
             else if (t.kind == 3 || t.kind == 5)
             {
                 if (t.kind == 3)
                 {
                     Get();
                     name = token.val;
                 }
                 else
                 {
                     Get();
                     name = "\"" + token.val.Substring(1, token.val.Length - 2) + "\"";
                 }
                 kind = str;
             }
             else Error(46);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="487" endline="506"><![CDATA[
 
         static void Term(out Graph g)
         {
             Graph g2;
             g = new Graph();
             if (StartOf(17))
             {
                 Factor(out g);
                 while (StartOf(17))
                 {
                     Factor(out g2);
                     Graph.MakeSequence(g, g2);
                 }
                 while (StartOf(17))
                 {
                     Factor(out g2);
                     Graph.MakeSequence(g, g2);
                 }
             }
             else if (StartOf(18))
             {
                 g = new Graph(new Node(Node.eps, null, 0));
             }
             else Error(47);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="507" endline="610"><![CDATA[
 
         static void Factor(out Graph g)
         {
             string name;
             int kind;
             Position pos;
             bool weak = false;
             g = null;
             switch (t.kind)
             {
                 case 1
                 case 3
                 case 5
                 case 26
                     {
                         if (t.kind == 26)
                         {
                             Get();
                             weak = true;
                         }
                         Sym(out name, out kind);
                         Symbol sym = Symbol.Find(name);
                         bool undef = sym == null;
                         if (undef)
                         {
                             if (kind == id)
                                 sym = new Symbol(Node.nt, name, 0); // forward nt
                             else if (genScanner)
                             {
                                 sym = new Symbol(Node.t, name, token.line);
                                 DFA.MatchLiteral(sym);
                             }
                             else
                             { // undefined string in production
                                 SemErr(6); sym = Tab.eofSy; // dummy
                             }
                         }
                         int typ = sym.typ;
                         if (typ != Node.t && typ != Node.nt) SemErr(4);
                         if (weak)
                             if (typ == Node.t) typ = Node.wt; else SemErr(23);
                         Node p = new Node(typ, sym, token.line);
                         g = new Graph(p);
 
                         if (t.kind == 23)
                         {
                             Attribs(p);
                             if (kind != id) SemErr(3);
                         }
                         if (undef)
                             sym.attrPos = p.pos; // dummy
                         else if ((p.pos == null) != (sym.attrPos == null))
                             SemErr(5);
 
                         break;
                     }
                 case 27
                     {
                         Get();
                         Expression(out g);
                         Expect(28);
                         break;
                     }
                 case 29
                     {
                         Get();
                         Expression(out g);
                         Expect(30);
                         Graph.MakeOption(g);
                         break;
                     }
                 case 31
                     {
                         Get();
                         Expression(out g);
                         Expect(32);
                         Graph.MakeIteration(g);
                         break;
                     }
                 case 35
                     {
                         SemText(out pos);
                         Node p = new Node(Node.sem, null, 0);
                         p.pos = pos;
                         g = new Graph(p);
                         break;
                     }
                 case 22
                     {
                         Get();
                         Node p = new Node(Node.any, null, 0); // p.set is set in Tab.SetupAnys
                         g = new Graph(p);
                         break;
                     }
                 case 33
                     {
                         Get();
                         Node p = new Node(Node.sync, null, 0);
                         g = new Graph(p);
                         break;
                     }
                 default
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="611" endline="630"><![CDATA[
 
         static void Attribs(Node p)
         {
             Expect(23);
             int beg = t.pos; int col = t.col;
             while (StartOf(7))
             {
                 if (StartOf(8))
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                     SemErr(18);
                 }
             }
             while (StartOf(7))
             {
                 if (StartOf(8))
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                     SemErr(18);
                 }
             }
             Expect(24);
             p.pos = new Position(beg, token.pos - beg, col);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="631" endline="649"><![CDATA[
 
         static void TokenTerm(out Graph g)
         {
             Graph g2;
             TokenFactor(out g);
             while (StartOf(15))
             {
                 TokenFactor(out g2);
                 Graph.MakeSequence(g, g2);
             }
             while (StartOf(15))
             {
                 TokenFactor(out g2);
                 Graph.MakeSequence(g, g2);
             }
             if (t.kind == 34)
             {
                 Get();
                 Expect(27);
                 TokenExpr(out g2);
                 Graph.SetContextTrans(g2.l); Graph.MakeSequence(g, g2);
                 Expect(28);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="650" endline="693"><![CDATA[
 
         static void TokenFactor(out Graph g)
         {
             string name; int kind;
             g = new Graph();
             if (t.kind == 1 || t.kind == 3 || t.kind == 5)
             {
                 Sym(out name, out kind);
                 if (kind == id)
                 {
                     CharClass c = CharClass.Find(name);
                     if (c == null)
                     {
                         SemErr(15);
                         c = new CharClass(name, new BitArray(CharClass.charSetSize));
                     }
                     Node p = new Node(Node.clas, null, 0); p.val = c.n;
                     g = new Graph(p);
                 }
                 else g = Graph.StrToGraph(name); // str
 
             }
             else if (t.kind == 27)
             {
                 Get();
                 TokenExpr(out g);
                 Expect(28);
             }
             else if (t.kind == 29)
             {
                 Get();
                 TokenExpr(out g);
                 Expect(30);
                 Graph.MakeOption(g);
             }
             else if (t.kind == 31)
             {
                 Get();
                 TokenExpr(out g);
                 Expect(32);
                 Graph.MakeIteration(g);
             }
             else Error(49);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="694" endline="704"><![CDATA[
 
 
 
         public static void Parse()
         {
             Errors.SynErr = new ErrorProc(SynErr);
             t = new Token();
             Get();
             Coco();
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="705" endline="767"><![CDATA[
 
         static void SynErr(int n, int line, int col)
         {
             Errors.count++;
             Console.Write("-- line {0} col {1}
             string s;
             switch (n)
             {
                 case 0
                 case 1
                 case 2
                 case 3
                 case 4
                 case 5
                 case 6
                 case 7
                 case 8
                 case 9
                 case 10
                 case 11
                 case 12
                 case 13
                 case 14
                 case 15
                 case 16
                 case 17
                 case 18
                 case 19
                 case 20
                 case 21
                 case 22
                 case 23
                 case 24
                 case 25
                 case 26
                 case 27
                 case 28
                 case 29
                 case 30
                 case 31
                 case 32
                 case 33
                 case 34
                 case 35
                 case 36
                 case 37
                 case 38
                 case 39
                 case 40
                 case 41
                 case 42
                 case 43
                 case 44
                 case 45
                 case 46
                 case 47
                 case 48
                 case 49
 
                 default
             }
             Console.WriteLine(s);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="17" endline="769"><![CDATA[
         static int errDist = minErrDist;
 
         const int id = 0;
         const int str = 1;
 
         static bool genScanner;
 
         /*-------------------------------------------------------------------------*/
 
 
         static void Error(int n)
         {
             if (errDist >= minErrDist) Errors.SynErr(n, t.line, t.col);
             errDist = 0;
         }
 
         public static void SemErr(int n)
         {
             if (errDist >= minErrDist) Errors.SemErr(n, token.line, token.col);
             errDist = 0;
         }
 
         static void Get()
         {
             for (; ; )
             {
                 token = t;
                 t = Scanner.Scan();
                 if (t.kind <= maxT) { errDist++; return; }
                 if (t.kind == 40)
                 {
                     Tab.SetDDT(t.val);
                 }
 
                 t = token;
             }
         }
 
         static void Expect(int n)
         {
             if (t.kind == n) Get(); else Error(n);
         }
 
         static bool StartOf(int s)
         {
             return set[s, t.kind];
         }
 
         static void ExpectWeak(int n, int follow)
         {
             if (t.kind == n) Get();
             else
             {
                 Error(n);
                 while (!StartOf(follow)) Get();
             }
         }
 
         static bool WeakSeparator(int n, int syFol, int repFol)
         {
             bool[] s = new bool[maxT + 1];
             if (t.kind == n) { Get(); return true; }
             else if (StartOf(repFol)) return false;
             else
             {
                 for (int i = 0; i <= maxT; i++)
                 {
                     s[i] = set[syFol, i] || set[repFol, i] || set[0, i];
                 }
                 Error(n);
                 while (!s[t.kind]) Get();
                 return StartOf(syFol);
             }
         }
 
         static void Coco()
         {
             Symbol sym; Graph g;
             if (t.kind == 37)
             {
                 UsingDecl(out ParserGen.usingPos);
             }
             Expect(6);
             int gramLine = token.line;
             genScanner = true;
             bool ok = true;
             Tab.ignored = null;
             Expect(1);
             string gramName = token.val;
             int beg = t.pos;
             while (StartOf(1))
             {
                 Get();
             }
             Tab.semDeclPos = new Position(beg, t.pos - beg, 0);
             while (StartOf(2))
             {
                 Declaration();
             }
             while (!(t.kind == 0 || t.kind == 7)) { Error(40); Get(); }
             Expect(7);
             if (genScanner) DFA.MakeDeterministic();
             Graph.DeleteNodes();
             while (t.kind == 1)
             {
                 Get();
                 sym = Symbol.Find(token.val);
                 bool undef = sym == null;
                 if (undef)
                 {
                     sym = new Symbol(Node.nt, token.val, token.line);
                 }
                 else
                 {
                     if (sym.typ == Node.nt)
                     {
                         if (sym.graph != null) SemErr(7);
                     }
                     else SemErr(8);
                     sym.line = token.line;
                 }
                 bool noAttrs = sym.attrPos == null; sym.attrPos = null;
 
                 if (t.kind == 23)
                 {
                     AttrDecl(sym);
                 }
                 if (!undef)
                     if (noAttrs != (sym.attrPos == null)) SemErr(5);
 
                 if (t.kind == 35)
                 {
                     SemText(out sym.semPos);
                 }
                 ExpectWeak(8, 3);
                 Expression(out g);
                 sym.graph = g.l;
                 Graph.Finish(g);
                 ExpectWeak(9, 4);
             }
             Expect(10);
             Expect(1);
             if (gramName != token.val) SemErr(17);
             Tab.gramSy = Symbol.Find(gramName);
             if (Tab.gramSy == null) SemErr(11);
             else
             {
                 sym = Tab.gramSy;
                 if (sym.attrPos != null) SemErr(12);
             }
             Tab.noSym = new Symbol(Node.t, "???", 0); // noSym gets highest number
             Tab.SetupAnys();
             Tab.RenumberPragmas();
             if (Tab.ddt[2]) Node.PrintNodes();
             if (Errors.count == 0)
             {
                 Console.WriteLine("checking");
                 Tab.CompSymbolSets();
                 ok = ok && Tab.GrammarOk();
 
                 if (Tab.ddt[7]) Tab.XRef();
                 if (ok)
                 {
                     Console.Write("parser");
                     ParserGen.WriteParser();
                     if (genScanner)
                     {
                         Console.Write(" + scanner");
                         DFA.WriteScanner();
                         if (Tab.ddt[0]) DFA.PrintStates();
                     }
                     Console.WriteLine(" generated");
                     if (Tab.ddt[8]) ParserGen.WriteStatistics();
                 }
             }
             if (Tab.ddt[6]) Tab.PrintSymbolTable();
             Expect(9);
         }
 
         static void UsingDecl(out Position pos)
         {
             Expect(37);
             int beg = token.pos;
             while (StartOf(5))
             {
                 Get();
             }
             Expect(38);
             int end = token.pos;
             while (t.kind == 37)
             {
                 Get();
                 while (StartOf(5))
                 {
                     Get();
                 }
                 Expect(38);
                 end = token.pos;
             }
             pos = new Position(beg, end - beg + 1, 0);
         }
 
         static void Declaration()
         {
             Graph g1, g2; bool nested = false;
             if (t.kind == 11)
             {
                 Get();
                 while (t.kind == 1)
                 {
                     SetDecl();
                 }
             }
             else if (t.kind == 12)
             {
                 Get();
                 while (t.kind == 1 || t.kind == 3 || t.kind == 5)
                 {
                     TokenDecl(Node.t);
                 }
             }
             else if (t.kind == 13)
             {
                 Get();
                 while (t.kind == 1 || t.kind == 3 || t.kind == 5)
                 {
                     TokenDecl(Node.pr);
                 }
             }
             else if (t.kind == 14)
             {
                 Get();
                 Expect(15);
                 TokenExpr(out g1);
                 Expect(16);
                 TokenExpr(out g2);
                 if (t.kind == 17)
                 {
                     Get();
                     nested = true;
                 }
                 else if (StartOf(6))
                 {
                     nested = false;
                 }
                 else Error(41);
                 new Comment(g1.l, g2.l, nested);
             }
             else if (t.kind == 18)
             {
                 Get();
                 Set(out Tab.ignored);
                 Tab.ignored[' '] = true; /* ' ' is always ignored */
                 if (Tab.ignored[0]) SemErr(9);
             }
             else Error(42);
         }
 
         static void AttrDecl(Symbol sym)
         {
             Expect(23);
             int beg = t.pos; int col = t.col;
             while (StartOf(7))
             {
                 if (StartOf(8))
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                     SemErr(18);
                 }
             }
             Expect(24);
             sym.attrPos = new Position(beg, token.pos - beg, col);
         }
 
         static void SemText(out Position pos)
         {
             Expect(35);
             int beg = t.pos; int col = t.col;
             while (StartOf(9))
             {
                 if (StartOf(10))
                 {
                     Get();
                 }
                 else if (t.kind == 4)
                 {
                     Get();
                     SemErr(18);
                 }
                 else
                 {
                     Get();
                     SemErr(19);
                 }
             }
             Expect(36);
             pos = new Position(beg, token.pos - beg, col);
         }
 
         static void Expression(out Graph g)
         {
             Graph g2;
             Term(out g);
             bool first = true;
             while (WeakSeparator(25, 11, 12))
             {
                 Term(out g2);
                 if (first) { Graph.MakeFirstAlt(g); first = false; }
                 Graph.MakeAlternative(g, g2);
             }
         }
 
         static void SetDecl()
         {
             BitArray s;
             Expect(1);
             string name = token.val;
             CharClass c = CharClass.Find(name);
             if (c != null) SemErr(7);
             Expect(8);
             Set(out s);
             if (Sets.Elements(s) == 0) SemErr(1);
             c = new CharClass(name, s);
             Expect(9);
         }
 
         static void TokenDecl(int typ)
         {
             string name; int kind; Symbol sym; Graph g;
             Sym(out name, out kind);
             sym = Symbol.Find(name);
             if (sym != null) SemErr(7);
             else
             {
                 sym = new Symbol(typ, name, token.line);
                 sym.tokenKind = Symbol.classToken;
             }
             while (!(StartOf(13))) { Error(43); Get(); }
             if (t.kind == 8)
             {
                 Get();
                 TokenExpr(out g);
                 Expect(9);
                 if (kind != id) SemErr(13);
                 Graph.Finish(g);
                 DFA.ConvertToStates(g.l, sym);
             }
             else if (StartOf(14))
             {
                 if (kind == id) genScanner = false;
                 else DFA.MatchLiteral(sym);
             }
             else Error(44);
             if (t.kind == 35)
             {
                 SemText(out sym.semPos);
                 if (typ == Node.t) SemErr(14);
             }
         }
 
         static void TokenExpr(out Graph g)
         {
             Graph g2;
             TokenTerm(out g);
             bool first = true;
             while (WeakSeparator(25, 15, 16))
             {
                 TokenTerm(out g2);
                 if (first) { Graph.MakeFirstAlt(g); first = false; }
                 Graph.MakeAlternative(g, g2);
             }
         }
 
         static void Set(out BitArray s)
         {
             BitArray s2;
             SimSet(out s);
             while (t.kind == 19 || t.kind == 20)
             {
                 if (t.kind == 19)
                 {
                     Get();
                     SimSet(out s2);
                     s.Or(s2);
                 }
                 else
                 {
                     Get();
                     SimSet(out s2);
                     Sets.Subtract(s, s2);
                 }
             }
         }
 
         static void SimSet(out BitArray s)
         {
             int n1, n2;
             s = new BitArray(CharClass.charSetSize);
             if (t.kind == 1)
             {
                 Get();
                 CharClass c = CharClass.Find(token.val);
                 if (c == null) SemErr(15); else s.Or(c.set);
             }
             else if (t.kind == 3)
             {
                 Get();
                 string name = token.val;
                 name = DFA.Unescape(name.Substring(1, name.Length - 2));
                 foreach (char ch in name) s[ch] = true;
             }
             else if (t.kind == 5)
             {
                 Char(out n1);
                 s[n1] = true;
                 if (t.kind == 21)
                 {
                     Get();
                     Char(out n2);
                     for (int i = n1; i <= n2; i++) s[i] = true;
                 }
             }
             else if (t.kind == 22)
             {
                 Get();
                 s = new BitArray(CharClass.charSetSize, true);
                 s[0] = false;
             }
             else Error(45);
         }
 
         static void Char(out int n)
         {
             Expect(5);
             string name = token.val;
             name = DFA.Unescape(name.Substring(1, name.Length - 2));
             int max = CharClass.charSetSize;
             if (name.Length != 1 || name[0] > max - 1) SemErr(2);
             n = name[0] % max;
 
         }
 
         static void Sym(out string name, out int kind)
         {
             name = "???"; kind = id;
             if (t.kind == 1)
             {
                 Get();
                 kind = id; name = token.val;
             }
             else if (t.kind == 3 || t.kind == 5)
             {
                 if (t.kind == 3)
                 {
                     Get();
                     name = token.val;
                 }
                 else
                 {
                     Get();
                     name = "\"" + token.val.Substring(1, token.val.Length - 2) + "\"";
                 }
                 kind = str;
             }
             else Error(46);
         }
 
         static void Term(out Graph g)
         {
             Graph g2;
             g = new Graph();
             if (StartOf(17))
             {
                 Factor(out g);
                 while (StartOf(17))
                 {
                     Factor(out g2);
                     Graph.MakeSequence(g, g2);
                 }
             }
             else if (StartOf(18))
             {
                 g = new Graph(new Node(Node.eps, null, 0));
             }
             else Error(47);
         }
 
         static void Factor(out Graph g)
         {
             string name;
             int kind;
             Position pos;
             bool weak = false;
             g = null;
             switch (t.kind)
             {
                 case 1
                 case 3
                 case 5
                 case 26
                     {
                         if (t.kind == 26)
                         {
                             Get();
                             weak = true;
                         }
                         Sym(out name, out kind);
                         Symbol sym = Symbol.Find(name);
                         bool undef = sym == null;
                         if (undef)
                         {
                             if (kind == id)
                                 sym = new Symbol(Node.nt, name, 0); // forward nt
                             else if (genScanner)
                             {
                                 sym = new Symbol(Node.t, name, token.line);
                                 DFA.MatchLiteral(sym);
                             }
                             else
                             { // undefined string in production
                                 SemErr(6); sym = Tab.eofSy; // dummy
                             }
                         }
                         int typ = sym.typ;
                         if (typ != Node.t && typ != Node.nt) SemErr(4);
                         if (weak)
                             if (typ == Node.t) typ = Node.wt; else SemErr(23);
                         Node p = new Node(typ, sym, token.line);
                         g = new Graph(p);
 
                         if (t.kind == 23)
                         {
                             Attribs(p);
                             if (kind != id) SemErr(3);
                         }
                         if (undef)
                             sym.attrPos = p.pos; // dummy
                         else if ((p.pos == null) != (sym.attrPos == null))
                             SemErr(5);
 
                         break;
                     }
                 case 27
                     {
                         Get();
                         Expression(out g);
                         Expect(28);
                         break;
                     }
                 case 29
                     {
                         Get();
                         Expression(out g);
                         Expect(30);
                         Graph.MakeOption(g);
                         break;
                     }
                 case 31
                     {
                         Get();
                         Expression(out g);
                         Expect(32);
                         Graph.MakeIteration(g);
                         break;
                     }
                 case 35
                     {
                         SemText(out pos);
                         Node p = new Node(Node.sem, null, 0);
                         p.pos = pos;
                         g = new Graph(p);
                         break;
                     }
                 case 22
                     {
                         Get();
                         Node p = new Node(Node.any, null, 0); // p.set is set in Tab.SetupAnys
                         g = new Graph(p);
                         break;
                     }
                 case 33
                     {
                         Get();
                         Node p = new Node(Node.sync, null, 0);
                         g = new Graph(p);
                         break;
                     }
                 default
             }
         }
 
         static void Attribs(Node p)
         {
             Expect(23);
             int beg = t.pos; int col = t.col;
             while (StartOf(7))
             {
                 if (StartOf(8))
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                     SemErr(18);
                 }
             }
             Expect(24);
             p.pos = new Position(beg, token.pos - beg, col);
         }
 
         static void TokenTerm(out Graph g)
         {
             Graph g2;
             TokenFactor(out g);
             while (StartOf(15))
             {
                 TokenFactor(out g2);
                 Graph.MakeSequence(g, g2);
             }
             if (t.kind == 34)
             {
                 Get();
                 Expect(27);
                 TokenExpr(out g2);
                 Graph.SetContextTrans(g2.l); Graph.MakeSequence(g, g2);
                 Expect(28);
             }
         }
 
         static void TokenFactor(out Graph g)
         {
             string name; int kind;
             g = new Graph();
             if (t.kind == 1 || t.kind == 3 || t.kind == 5)
             {
                 Sym(out name, out kind);
                 if (kind == id)
                 {
                     CharClass c = CharClass.Find(name);
                     if (c == null)
                     {
                         SemErr(15);
                         c = new CharClass(name, new BitArray(CharClass.charSetSize));
                     }
                     Node p = new Node(Node.clas, null, 0); p.val = c.n;
                     g = new Graph(p);
                 }
                 else g = Graph.StrToGraph(name); // str
 
             }
             else if (t.kind == 27)
             {
                 Get();
                 TokenExpr(out g);
                 Expect(28);
             }
             else if (t.kind == 29)
             {
                 Get();
                 TokenExpr(out g);
                 Expect(30);
                 Graph.MakeOption(g);
             }
             else if (t.kind == 31)
             {
                 Get();
                 TokenExpr(out g);
                 Expect(32);
                 Graph.MakeIteration(g);
             }
             else Error(49);
         }
 
 
 
         public static void Parse()
         {
             Errors.SynErr = new ErrorProc(SynErr);
             t = new Token();
             Get();
             Coco();
 
         }
 
         static void SynErr(int n, int line, int col)
         {
             Errors.count++;
             Console.Write("-- line {0} col {1}
             string s;
             switch (n)
             {
                 case 0
                 case 1
                 case 2
                 case 3
                 case 4
                 case 5
                 case 6
                 case 7
                 case 8
                 case 9
                 case 10
                 case 11
                 case 12
                 case 13
                 case 14
                 case 15
                 case 16
                 case 17
                 case 18
                 case 19
                 case 20
                 case 21
                 case 22
                 case 23
                 case 24
                 case 25
                 case 26
                 case 27
                 case 28
                 case 29
                 case 30
                 case 31
                 case 32
                 case 33
                 case 34
                 case 35
                 case 36
                 case 37
                 case 38
                 case 39
                 case 40
                 case 41
                 case 42
                 case 43
                 case 44
                 case 45
                 case 46
                 case 47
                 case 48
                 case 49
 
                 default
             }
             Console.WriteLine(s);
         }
 
         static bool[,] set = {
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="31" endline="37"><![CDATA[
         {
             if (disposing && (components != null))
             {
                 components.Dispose();
             }
             base.Dispose(disposing);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Options.cs" startline="38" endline="81"><![CDATA[
 
         #region Windows Form Designer generated code
 
         /// <summary>
         /// Required method for Designer support - do not modify
         /// the contents of this method with the code editor.
         /// </summary>
         private void InitializeComponent()
         {
             System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(SplashScreen));
             this._btnClose = new Peter.VistaButton();
             this.SuspendLayout();
             // 
             // _btnClose
             // 
             this._btnClose.BackColor = System.Drawing.Color.Transparent;
             this._btnClose.BaseColor = System.Drawing.Color.Transparent;
             this._btnClose.ButtonColor = System.Drawing.Color.Silver;
             this._btnClose.ButtonText = "Close";
             this._btnClose.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
             this._btnClose.ForeColor = System.Drawing.Color.Black;
             this._btnClose.Location = new System.Drawing.Point(441, 287);
             this._btnClose.Name = "_btnClose";
             this._btnClose.Size = new System.Drawing.Size(100, 32);
             this._btnClose.TabIndex = 1;
             this._btnClose.Click += new System.EventHandler(this._btnClose_Click);
             // 
             // SplashScreen
             // 
             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("$this.BackgroundImage")));
             this.ClientSize = new System.Drawing.Size(570, 350);
             this.Controls.Add(this._btnClose);
             this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None;
             this.Name = "SplashScreen";
             this.ShowInTaskbar = false;
             this.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide;
             this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
             this.Text = "SplashScreen";
             this.TopMost = true;
             this.ResumeLayout(false);
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\SplashScreen.cs" startline="24" endline="32"><![CDATA[
         private System.ComponentModel.IContainer components = null;
         public SplashScreen(bool closeButton)
         {
             InitializeComponent();
             this._btnClose.Visible = closeButton;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\SplashScreen.cs" startline="33" endline="42"><![CDATA[
 
         /// <summary>
         /// Closes the Splash Screen
         /// </summary>
         /// <param name="sender">SplashScreen close button</param>
         /// <param name="e">Events</param>
         private void _btnClose_Click (object sender, EventArgs e)
         {
             this.Close();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="13" endline="16"><![CDATA[
         public Position(int beg, int len, int col)
         {
             this.beg = beg; this.len = len; this.col = col;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="17" endline="60"><![CDATA[
     }
 
 
     //---------------------------------------------------------------------
     // Symbols
     //---------------------------------------------------------------------
 
     public class Symbol 
     {
         public static ArrayList terminals = new ArrayList();
         public static ArrayList pragmas = new ArrayList();
         public static ArrayList nonterminals = new ArrayList();
 
         public const int classToken = 0;		// token kinds
         public const int litToken = 1;
         public const int classLitToken = 2;
 
         public int n;					// symbol number
         public int typ;				// t, nt, pr, unknown
         public string name;				// symbol name
         public Node graph;      // nt
         public int tokenKind;	// t
         public bool deletable;	// nt
         public bool firstReady;	// nt
         public BitArray first;			// nt
         public BitArray follow;			// nt
         public BitArray nts;				// nt
         public int line;				// source text line number of item in this node
         public Position attrPos;		// nt
         public Position semPos;			// pr
         // nt
 
         public Symbol(int typ, string name, int line)
         {
             if (name.Length == 2 && name[0] == '"') { Parser.SemErr(29); name = "???"; }
             if (name.IndexOf(' ') >= 0) Parser.SemErr(24);
             this.typ = typ; this.name = name; this.line = line;
             switch (typ)
             {
                 case Node.t
                 case Node.pr
                 case Node.nt
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="61" endline="69"><![CDATA[
 
         public static Symbol Find(string name)
         {
             foreach (Symbol s in terminals)
                 if (s.name == name) return s;
             foreach (Symbol s in terminals)
                 if (s.name == name) return s;
             foreach (Symbol s in nonterminals)
                 if (s.name == name) return s;
             foreach (Symbol s in nonterminals)
                 if (s.name == name) return s;
             return null;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="70" endline="74"><![CDATA[
 
         public int CompareTo(object x)
         {
             return name.CompareTo(((Symbol)x).name);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="26" endline="28"><![CDATA[
         public static ArrayList terminals = new ArrayList();
         public static ArrayList pragmas = new ArrayList();
         public static ArrayList nonterminals = new ArrayList();
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="29" endline="129"><![CDATA[
 
         public const int classToken = 0;		// token kinds
         public const int litToken = 1;
         public const int classLitToken = 2;
 
         public int n;					// symbol number
         public int typ;				// t, nt, pr, unknown
         public string name;				// symbol name
         public Node graph;      // nt
         public int tokenKind;	// t
         public bool deletable;	// nt
         public bool firstReady;	// nt
         public BitArray first;			// nt
         public BitArray follow;			// nt
         public BitArray nts;				// nt
         public int line;				// source text line number of item in this node
         public Position attrPos;		// nt
         public Position semPos;			// pr
         // nt
 
         public Symbol(int typ, string name, int line)
         {
             if (name.Length == 2 && name[0] == '"') { Parser.SemErr(29); name = "???"; }
             if (name.IndexOf(' ') >= 0) Parser.SemErr(24);
             this.typ = typ; this.name = name; this.line = line;
             switch (typ)
             {
                 case Node.t
                 case Node.pr
                 case Node.nt
             }
         }
 
         public static Symbol Find(string name)
         {
             foreach (Symbol s in terminals)
                 if (s.name == name) return s;
             foreach (Symbol s in nonterminals)
                 if (s.name == name) return s;
             return null;
         }
 
         public int CompareTo(object x)
         {
             return name.CompareTo(((Symbol)x).name);
         }
 
     }
 
 
     //---------------------------------------------------------------------
     // Syntax graph (class Node, class Graph)
     //---------------------------------------------------------------------
 
     public class Node
     {
         public static ArrayList nodes = new ArrayList();
         public static string[] nTyp =
 		{" ", "t   ", "pr  ", "nt  ", "clas", "chr ", "wt  ", "any ", "eps ", 
 		"sync", "sem ", "alt ", "iter", "opt "};
 
         public const int t = 1;						// node kinds
         public const int pr = 2;
         public const int nt = 3;
         public const int clas = 4;
         public const int chr = 5;
         public const int wt = 6;
         public const int any = 7;
         public const int eps = 8;
         public const int sync = 9;
         public const int sem = 10;
         public const int alt = 11;
         public const int iter = 12;
         public const int opt = 13;
 
         public const int normalTrans = 0;		// transition codes
         public const int contextTrans = 1;
 
         public int n;			// node number
         public int typ;		// t, nt, wt, chr, clas, any, eps, sem, sync, alt, iter, opt
         public Node next;		// to successor node
         public Node down;		// alt
         public Node sub;		// alt, iter, opt
         public bool up;			// true
         public Symbol sym;		// nt, t, wt
         public int val;		// chr
         // clas
         public int code;		// chr, clas
         public BitArray set;		// any, sync
         public Position pos;		// nt, t, wt
         // sem
         public int line;		// source text line number of item in this node
         public State state;	// DFA state corresponding to this node
         // (only used in DFA.ConvertToStates)
 
         public Node(int typ, Symbol sym, int line)
         {
             this.typ = typ; this.sym = sym; this.line = line;
             n = nodes.Count;
             nodes.Add(this);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="130" endline="135"><![CDATA[
 
         public Node(int typ, Node sub)
             
         {
             this.sub = sub;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="136" endline="141"><![CDATA[
 
         public Node(int typ, int val, int line)
             
         {
             this.val = val;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="142" endline="146"><![CDATA[
 
         public static bool DelGraph(Node p)
         {
             return p == null || DelNode(p) && DelGraph(p.next);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="147" endline="151"><![CDATA[
 
         public static bool DelAlt(Node p)
         {
             return p == null || DelNode(p) && (p.up || DelAlt(p.next));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="152" endline="158"><![CDATA[
 
         public static bool DelNode(Node p)
         {
             if (p.typ == nt) return p.sym.deletable;
             else if (p.typ == alt) return DelAlt(p.sub) || p.down != null && DelAlt(p.down);
             else return p.typ == eps || p.typ == iter || p.typ == opt || p.typ == sem || p.typ == sync;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="159" endline="167"><![CDATA[
 
         //----------------- for printing ----------------------
 
         static int Ptr(Node p, bool up)
         {
             if (p == null) return 0;
             else if (up) return -p.n;
             else return p.n;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="168" endline="172"><![CDATA[
 
         static string Pos(Position pos)
         {
             if (pos == null) return "     "; else return String.Format("{0,5}", pos.beg);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="173" endline="177"><![CDATA[
 
         public static string Name(string name)
         {
             return (name + "           ").Substring(0, 12);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="178" endline="223"><![CDATA[
 
         public static void PrintNodes()
         {
             TextWriter w = Tab.trace;
             w.WriteLine("Graph nodes
             w.WriteLine("----------------------------------------------------");
             w.WriteLine("   n typ  name          next  down   sub   pos  line");
             w.WriteLine("                               val  code");
             w.WriteLine("----------------------------------------------------");
             foreach (Node p in nodes)
             {
                 w.Write("{0,4} {1} ", p.n, nTyp[p.typ]);
                 if (p.sym != null)
                     w.Write("{0,12} ", Name(p.sym.name));
                 else if (p.typ == Node.clas)
                 {
                     CharClass c = (CharClass)CharClass.classes[p.val];
                     w.Write("{0,12} ", Name(c.name));
                 }
                 else w.Write("             ");
                 w.Write("{0,5} ", Ptr(p.next, p.up));
                 switch (p.typ)
                 {
                     case t
                     case nt
                     case wt
                         w.Write("             {0,5}", Pos(p.pos)); break;
                     case chr
                         w.Write("{0,5} {1,5}       ", p.val, p.code); break;
                     case clas
                         w.Write("      {0,5}       ", p.code); break;
                     case alt
                     case iter
                     case opt
                         w.Write("{0,5} {1,5}       ", Ptr(p.down, false), Ptr(p.sub, false)); break;
                     case sem
                         w.Write("             {0,5}", Pos(p.pos)); break;
                     case eps
                     case any
                     case sync
                         w.Write("                  "); break;
                 }
                 w.WriteLine("{0,5}", p.line);
             }
             foreach (Node p in nodes)
             {
                 w.Write("{0,4} {1} ", p.n, nTyp[p.typ]);
                 if (p.sym != null)
                     w.Write("{0,12} ", Name(p.sym.name));
                 else if (p.typ == Node.clas)
                 {
                     CharClass c = (CharClass)CharClass.classes[p.val];
                     w.Write("{0,12} ", Name(c.name));
                 }
                 else w.Write("             ");
                 w.Write("{0,5} ", Ptr(p.next, p.up));
                 switch (p.typ)
                 {
                     case t
                     case nt
                     case wt
                         w.Write("             {0,5}", Pos(p.pos)); break;
                     case chr
                         w.Write("{0,5} {1,5}       ", p.val, p.code); break;
                     case clas
                         w.Write("      {0,5}       ", p.code); break;
                     case alt
                     case iter
                     case opt
                         w.Write("{0,5} {1,5}       ", Ptr(p.down, false), Ptr(p.sub, false)); break;
                     case sem
                         w.Write("             {0,5}", Pos(p.pos)); break;
                     case eps
                     case any
                     case sync
                         w.Write("                  "); break;
                 }
                 w.WriteLine("{0,5}", p.line);
             }
             w.WriteLine();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="85" endline="86"><![CDATA[
         public static ArrayList nodes = new ArrayList();
         public static string[] nTyp =
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="87" endline="238"><![CDATA[
 		{" ", "t   ", "pr  ", "nt  ", "clas", "chr ", "wt  ", "any ", "eps ", 
 		"sync", "sem ", "alt ", "iter", "opt "};
 
         public const int t = 1;						// node kinds
         public const int pr = 2;
         public const int nt = 3;
         public const int clas = 4;
         public const int chr = 5;
         public const int wt = 6;
         public const int any = 7;
         public const int eps = 8;
         public const int sync = 9;
         public const int sem = 10;
         public const int alt = 11;
         public const int iter = 12;
         public const int opt = 13;
 
         public const int normalTrans = 0;		// transition codes
         public const int contextTrans = 1;
 
         public int n;			// node number
         public int typ;		// t, nt, wt, chr, clas, any, eps, sem, sync, alt, iter, opt
         public Node next;		// to successor node
         public Node down;		// alt
         public Node sub;		// alt, iter, opt
         public bool up;			// true
         public Symbol sym;		// nt, t, wt
         public int val;		// chr
         // clas
         public int code;		// chr, clas
         public BitArray set;		// any, sync
         public Position pos;		// nt, t, wt
         // sem
         public int line;		// source text line number of item in this node
         public State state;	// DFA state corresponding to this node
         // (only used in DFA.ConvertToStates)
 
         public Node(int typ, Symbol sym, int line)
         {
             this.typ = typ; this.sym = sym; this.line = line;
             n = nodes.Count;
             nodes.Add(this);
         }
 
         public Node(int typ, Node sub)
             
         {
             this.sub = sub;
         }
 
         public Node(int typ, int val, int line)
             
         {
             this.val = val;
         }
 
         public static bool DelGraph(Node p)
         {
             return p == null || DelNode(p) && DelGraph(p.next);
         }
 
         public static bool DelAlt(Node p)
         {
             return p == null || DelNode(p) && (p.up || DelAlt(p.next));
         }
 
         public static bool DelNode(Node p)
         {
             if (p.typ == nt) return p.sym.deletable;
             else if (p.typ == alt) return DelAlt(p.sub) || p.down != null && DelAlt(p.down);
             else return p.typ == eps || p.typ == iter || p.typ == opt || p.typ == sem || p.typ == sync;
         }
 
         //----------------- for printing ----------------------
 
         static int Ptr(Node p, bool up)
         {
             if (p == null) return 0;
             else if (up) return -p.n;
             else return p.n;
         }
 
         static string Pos(Position pos)
         {
             if (pos == null) return "     "; else return String.Format("{0,5}", pos.beg);
         }
 
         public static string Name(string name)
         {
             return (name + "           ").Substring(0, 12);
         }
 
         public static void PrintNodes()
         {
             TextWriter w = Tab.trace;
             w.WriteLine("Graph nodes
             w.WriteLine("----------------------------------------------------");
             w.WriteLine("   n typ  name          next  down   sub   pos  line");
             w.WriteLine("                               val  code");
             w.WriteLine("----------------------------------------------------");
             foreach (Node p in nodes)
             {
                 w.Write("{0,4} {1} ", p.n, nTyp[p.typ]);
                 if (p.sym != null)
                     w.Write("{0,12} ", Name(p.sym.name));
                 else if (p.typ == Node.clas)
                 {
                     CharClass c = (CharClass)CharClass.classes[p.val];
                     w.Write("{0,12} ", Name(c.name));
                 }
                 else w.Write("             ");
                 w.Write("{0,5} ", Ptr(p.next, p.up));
                 switch (p.typ)
                 {
                     case t
                     case nt
                     case wt
                         w.Write("             {0,5}", Pos(p.pos)); break;
                     case chr
                         w.Write("{0,5} {1,5}       ", p.val, p.code); break;
                     case clas
                         w.Write("      {0,5}       ", p.code); break;
                     case alt
                     case iter
                     case opt
                         w.Write("{0,5} {1,5}       ", Ptr(p.down, false), Ptr(p.sub, false)); break;
                     case sem
                         w.Write("             {0,5}", Pos(p.pos)); break;
                     case eps
                     case any
                     case sync
                         w.Write("                  "); break;
                 }
                 w.WriteLine("{0,5}", p.line);
             }
             w.WriteLine();
         }
 
     }
 
 
     public class Graph
     {
         static Node dummyNode = new Node(Node.eps, null, 0);
 
         public Node l;	// left end of graph = head
         public Node r;	// right end of graph = list of nodes to be linked to successor graph
 
         public Graph()
         {
             l = null; r = null;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="239" endline="243"><![CDATA[
 
         public Graph(Node left, Node right)
         {
             l = left; r = right;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="244" endline="248"><![CDATA[
 
         public Graph(Node p)
         {
             l = p; r = p;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="249" endline="255"><![CDATA[
 
         public static void MakeFirstAlt(Graph g)
         {
             g.l = new Node(Node.alt, g.l);
             g.l.next = g.r;
             g.r = g.l;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="256" endline="264"><![CDATA[
 
         public static void MakeAlternative(Graph g1, Graph g2)
         {
             g2.l = new Node(Node.alt, g2.l);
             Node p = g1.l; while (p.down != null) p = p.down;
             p.down = g2.l;
             p = g1.r; while (p.next != null) p = p.next;
             p.next = g2.r;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="265" endline="275"><![CDATA[
 
         public static void MakeSequence(Graph g1, Graph g2)
         {
             Node p = g1.r.next; g1.r.next = g2.l; // link head node
             while (p != null)
             {  // link substructure
                 Node q = p.next; p.next = g2.l; p.up = true;
                 p = q;
             }
             while (p != null)
             {  // link substructure
                 Node q = p.next; p.next = g2.l; p.up = true;
                 p = q;
             }
             g1.r = g2.r;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="276" endline="287"><![CDATA[
 
         public static void MakeIteration(Graph g)
         {
             g.l = new Node(Node.iter, g.l);
             Node p = g.r;
             g.r = g.l;
             while (p != null)
             {
                 Node q = p.next; p.next = g.l; p.up = true;
                 p = q;
             }
             while (p != null)
             {
                 Node q = p.next; p.next = g.l; p.up = true;
                 p = q;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="288" endline="294"><![CDATA[
 
         public static void MakeOption(Graph g)
         {
             g.l = new Node(Node.opt, g.l);
             g.l.next = g.r;
             g.r = g.l;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="295" endline="303"><![CDATA[
 
         public static void Finish(Graph g)
         {
             Node p = g.r;
             while (p != null)
             {
                 Node q = p.next; p.next = null; p = q;
             }
             while (p != null)
             {
                 Node q = p.next; p.next = null; p = q;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="304" endline="325"><![CDATA[
 
         public static void SetContextTrans(Node p)
         { // set transition code in the graph rooted at p
             DFA.hasCtxMoves = true;
             while (p != null)
             {
                 if (p.typ == Node.chr || p.typ == Node.clas)
                 {
                     p.code = Node.contextTrans;
                 }
                 else if (p.typ == Node.opt || p.typ == Node.iter)
                 {
                     SetContextTrans(p.sub);
                 }
                 else if (p.typ == Node.alt)
                 {
                     SetContextTrans(p.sub); SetContextTrans(p.down);
                 }
                 if (p.up) break;
                 p = p.next;
             }
             while (p != null)
             {
                 if (p.typ == Node.chr || p.typ == Node.clas)
                 {
                     p.code = Node.contextTrans;
                 }
                 else if (p.typ == Node.opt || p.typ == Node.iter)
                 {
                     SetContextTrans(p.sub);
                 }
                 else if (p.typ == Node.alt)
                 {
                     SetContextTrans(p.sub); SetContextTrans(p.down);
                 }
                 if (p.up) break;
                 p = p.next;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="326" endline="331"><![CDATA[
 
         public static void DeleteNodes()
         {
             Node.nodes = new ArrayList();
             dummyNode = new Node(Node.eps, null, 0);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="332" endline="347"><![CDATA[
 
         public static Graph StrToGraph(string str)
         {
             string s = DFA.Unescape(str.Substring(1, str.Length - 2));
             if (s.IndexOf('\0') >= 0) Parser.SemErr(27);
             if (s.Length == 0) Parser.SemErr(29);
             Graph g = new Graph();
             g.r = dummyNode;
             for (int i = 0; i < s.Length; i++)
             {
                 Node p = new Node(Node.chr, (int)s[i], 0);
                 g.r.next = p; g.r = p;
             }
             for (int i = 0; i < s.Length; i++)
             {
                 Node p = new Node(Node.chr, (int)s[i], 0);
                 g.r.next = p; g.r = p;
             }
             g.l = dummyNode.next; dummyNode.next = null;
             return g;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="230" endline="230"><![CDATA[
         static Node dummyNode = new Node(Node.eps, null, 0);
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="231" endline="365"><![CDATA[
 
         public Node l;	// left end of graph = head
         public Node r;	// right end of graph = list of nodes to be linked to successor graph
 
         public Graph()
         {
             l = null; r = null;
         }
 
         public Graph(Node left, Node right)
         {
             l = left; r = right;
         }
 
         public Graph(Node p)
         {
             l = p; r = p;
         }
 
         public static void MakeFirstAlt(Graph g)
         {
             g.l = new Node(Node.alt, g.l);
             g.l.next = g.r;
             g.r = g.l;
         }
 
         public static void MakeAlternative(Graph g1, Graph g2)
         {
             g2.l = new Node(Node.alt, g2.l);
             Node p = g1.l; while (p.down != null) p = p.down;
             p.down = g2.l;
             p = g1.r; while (p.next != null) p = p.next;
             p.next = g2.r;
         }
 
         public static void MakeSequence(Graph g1, Graph g2)
         {
             Node p = g1.r.next; g1.r.next = g2.l; // link head node
             while (p != null)
             {  // link substructure
                 Node q = p.next; p.next = g2.l; p.up = true;
                 p = q;
             }
             g1.r = g2.r;
         }
 
         public static void MakeIteration(Graph g)
         {
             g.l = new Node(Node.iter, g.l);
             Node p = g.r;
             g.r = g.l;
             while (p != null)
             {
                 Node q = p.next; p.next = g.l; p.up = true;
                 p = q;
             }
         }
 
         public static void MakeOption(Graph g)
         {
             g.l = new Node(Node.opt, g.l);
             g.l.next = g.r;
             g.r = g.l;
         }
 
         public static void Finish(Graph g)
         {
             Node p = g.r;
             while (p != null)
             {
                 Node q = p.next; p.next = null; p = q;
             }
         }
 
         public static void SetContextTrans(Node p)
         { // set transition code in the graph rooted at p
             DFA.hasCtxMoves = true;
             while (p != null)
             {
                 if (p.typ == Node.chr || p.typ == Node.clas)
                 {
                     p.code = Node.contextTrans;
                 }
                 else if (p.typ == Node.opt || p.typ == Node.iter)
                 {
                     SetContextTrans(p.sub);
                 }
                 else if (p.typ == Node.alt)
                 {
                     SetContextTrans(p.sub); SetContextTrans(p.down);
                 }
                 if (p.up) break;
                 p = p.next;
             }
         }
 
         public static void DeleteNodes()
         {
             Node.nodes = new ArrayList();
             dummyNode = new Node(Node.eps, null, 0);
         }
 
         public static Graph StrToGraph(string str)
         {
             string s = DFA.Unescape(str.Substring(1, str.Length - 2));
             if (s.IndexOf('\0') >= 0) Parser.SemErr(27);
             if (s.Length == 0) Parser.SemErr(29);
             Graph g = new Graph();
             g.r = dummyNode;
             for (int i = 0; i < s.Length; i++)
             {
                 Node p = new Node(Node.chr, (int)s[i], 0);
                 g.r.next = p; g.r = p;
             }
             g.l = dummyNode.next; dummyNode.next = null;
             return g;
         }
 
     }
 
 
     //----------------------------------------------------------------
     // Bit sets 
     //----------------------------------------------------------------
 
     public class Sets
     {
 
         public static int First(BitArray s)
         {
             int max = s.Count;
             for (int i = 0; i < max; i++)
                 if (s[i]) return i;
             for (int i = 0; i < max; i++)
                 if (s[i]) return i;
             return -1;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="366" endline="374"><![CDATA[
 
         public static int Elements(BitArray s)
         {
             int max = s.Count;
             int n = 0;
             for (int i = 0; i < max; i++)
                 if (s[i]) n++;
             for (int i = 0; i < max; i++)
                 if (s[i]) n++;
             return n;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="375" endline="382"><![CDATA[
 
         public static bool Equals(BitArray a, BitArray b)
         {
             int max = a.Count;
             for (int i = 0; i < max; i++)
                 if (a[i] != b[i]) return false;
             for (int i = 0; i < max; i++)
                 if (a[i] != b[i]) return false;
             return true;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="383" endline="390"><![CDATA[
 
         public static bool Includes(BitArray a, BitArray b)
         {	// a > b ?
             int max = a.Count;
             for (int i = 0; i < max; i++)
                 if (b[i] && !a[i]) return false;
             for (int i = 0; i < max; i++)
                 if (b[i] && !a[i]) return false;
             return true;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="391" endline="398"><![CDATA[
 
         public static bool Intersect(BitArray a, BitArray b)
         { // a * b != {}
             int max = a.Count;
             for (int i = 0; i < max; i++)
                 if (a[i] && b[i]) return true;
             for (int i = 0; i < max; i++)
                 if (a[i] && b[i]) return true;
             return false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="399" endline="404"><![CDATA[
 
         public static void Subtract(BitArray a, BitArray b)
         { // a = a - b
             BitArray c = (BitArray)b.Clone();
             a.And(c.Not());
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="405" endline="426"><![CDATA[
 
         public static void PrintSet(TextWriter w, BitArray s, int indent)
         {
             int col, len;
             col = indent;
             foreach (Symbol sym in Symbol.terminals)
             {
                 if (s[sym.n])
                 {
                     len = sym.name.Length;
                     if (col + len + 1 > 80)
                     {
                         w.WriteLine();
                         for (col = 1; col < indent; col++) w.Write(" ");
                     }
                     w.Write("{0} ", sym.name);
                     col += len + 1;
                 }
             }
             foreach (Symbol sym in Symbol.terminals)
             {
                 if (s[sym.n])
                 {
                     len = sym.name.Length;
                     if (col + len + 1 > 80)
                     {
                         w.WriteLine();
                         for (col = 1; col < indent; col++) w.Write(" ");
                     }
                     w.Write("{0} ", sym.name);
                     col += len + 1;
                 }
             }
             if (col == indent) w.Write("-- empty set --");
             w.WriteLine();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="427" endline="451"><![CDATA[
 
     }
 
 
     //---------------------------------------------------------------------
     // Character class management
     //---------------------------------------------------------------------
 
     public class CharClass
     {
         public static ArrayList classes = new ArrayList();
         public static int dummyName = 'A';
 
         public const int charSetSize = 256;  // must be a multiple of 16
 
         public int n;       	// class number
         public string name;		// class name
         public BitArray set;	// set representing the class
 
         public CharClass(string name, BitArray s)
         {
             if (name == "#") name = "#" + (char)dummyName++;
             this.n = classes.Count; this.name = name; this.set = s;
             classes.Add(this);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="452" endline="458"><![CDATA[
 
         public static CharClass Find(string name)
         {
             foreach (CharClass c in classes)
                 if (c.name == name) return c;
             foreach (CharClass c in classes)
                 if (c.name == name) return c;
             return null;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="459" endline="465"><![CDATA[
 
         public static CharClass Find(BitArray s)
         {
             foreach (CharClass c in classes)
                 if (Sets.Equals(s, c.set)) return c;
             foreach (CharClass c in classes)
                 if (Sets.Equals(s, c.set)) return c;
             return null;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="466" endline="470"><![CDATA[
 
         public static BitArray Set(int i)
         {
             return ((CharClass)classes[i]).set;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="471" endline="476"><![CDATA[
 
         static string Ch(int ch)
         {
             if (ch < ' ' || ch >= 127 || ch == '\'' || ch == '\\') return ch.ToString();
             else return String.Format("'{0}'", (char)ch);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="477" endline="489"><![CDATA[
 
         static void WriteCharSet(TextWriter w, BitArray s)
         {
             int i = 0, len = s.Count;
             while (i < len)
             {
                 while (i < len && !s[i]) i++;
                 if (i == len) break;
                 int j = i;
                 while (i < len && s[i]) i++;
                 if (j < i - 1) w.Write("{0}..{1} ", Ch(j), Ch(i - 1)); else w.Write("{0} ", Ch(j));
             }
             while (i < len)
             {
                 while (i < len && !s[i]) i++;
                 if (i == len) break;
                 int j = i;
                 while (i < len && s[i]) i++;
                 if (j < i - 1) w.Write("{0}..{1} ", Ch(j), Ch(i - 1)); else w.Write("{0} ", Ch(j));
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="490" endline="500"><![CDATA[
 
         public static void WriteClasses(TextWriter w)
         {
             foreach (CharClass c in classes)
             {
                 w.Write("{0,-10}
                 WriteCharSet(w, c.set);
                 w.WriteLine();
             }
             foreach (CharClass c in classes)
             {
                 w.Write("{0,-10}
                 WriteCharSet(w, c.set);
                 w.WriteLine();
             }
             w.WriteLine();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="437" endline="438"><![CDATA[
         public static ArrayList classes = new ArrayList();
         public static int dummyName = 'A';
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="527" endline="563"><![CDATA[
         {
             BitArray fs = new BitArray(Symbol.terminals.Count);
             while (p != null && !mark[p.n])
             {
                 mark[p.n] = true;
                 switch (p.typ)
                 {
                     case Node.nt
                         {
                             if (p.sym.firstReady) fs.Or(p.sym.first);
                             else fs.Or(First0(p.sym.graph, mark));
                             break;
                         }
                     case Node.t
                     case Node.wt
                         {
                             fs[p.sym.n] = true; break;
                         }
                     case Node.any
                         {
                             fs.Or(p.set); break;
                         }
                     case Node.alt
                     case Node.iter
                     case Node.opt
                         {
                             fs.Or(First0(p.sub, mark));
                             if (p.typ == Node.alt)
                                 fs.Or(First0(p.down, mark));
                             break;
                         }
                 }
                 if (!Node.DelNode(p)) break;
                 p = p.next;
             }
             while (p != null && !mark[p.n])
             {
                 mark[p.n] = true;
                 switch (p.typ)
                 {
                     case Node.nt
                         {
                             if (p.sym.firstReady) fs.Or(p.sym.first);
                             else fs.Or(First0(p.sym.graph, mark));
                             break;
                         }
                     case Node.t
                     case Node.wt
                         {
                             fs[p.sym.n] = true; break;
                         }
                     case Node.any
                         {
                             fs.Or(p.set); break;
                         }
                     case Node.alt
                     case Node.iter
                     case Node.opt
                         {
                             fs.Or(First0(p.sub, mark));
                             if (p.typ == Node.alt)
                                 fs.Or(First0(p.down, mark));
                             break;
                         }
                 }
                 if (!Node.DelNode(p)) break;
                 p = p.next;
             }
             return fs;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="564" endline="576"><![CDATA[
 
         public static BitArray First(Node p)
         {
             BitArray fs = First0(p, new BitArray(Node.nodes.Count));
             if (ddt[3])
             {
                 trace.WriteLine();
                 if (p != null) trace.WriteLine("First
                 else trace.WriteLine("First
                 Sets.PrintSet(trace, fs, 0);
             }
             return fs;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="577" endline="590"><![CDATA[
 
         static void CompFirstSets()
         {
             foreach (Symbol sym in Symbol.nonterminals)
             {
                 sym.first = new BitArray(Symbol.terminals.Count);
                 sym.firstReady = false;
             }
             foreach (Symbol sym in Symbol.nonterminals)
             {
                 sym.first = new BitArray(Symbol.terminals.Count);
                 sym.firstReady = false;
             }
             foreach (Symbol sym in Symbol.nonterminals)
             {
                 sym.first = First(sym.graph);
                 sym.firstReady = true;
             }
             foreach (Symbol sym in Symbol.nonterminals)
             {
                 sym.first = First(sym.graph);
                 sym.firstReady = true;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="591" endline="614"><![CDATA[
 
         static void CompFollow(Node p)
         {
             while (p != null && !visited[p.n])
             {
                 visited[p.n] = true;
                 if (p.typ == Node.nt)
                 {
                     BitArray s = First(p.next);
                     p.sym.follow.Or(s);
                     if (Node.DelGraph(p.next))
                         p.sym.nts[curSy.n] = true;
                 }
                 else if (p.typ == Node.opt || p.typ == Node.iter)
                 {
                     CompFollow(p.sub);
                 }
                 else if (p.typ == Node.alt)
                 {
                     CompFollow(p.sub); CompFollow(p.down);
                 }
                 p = p.next;
             }
             while (p != null && !visited[p.n])
             {
                 visited[p.n] = true;
                 if (p.typ == Node.nt)
                 {
                     BitArray s = First(p.next);
                     p.sym.follow.Or(s);
                     if (Node.DelGraph(p.next))
                         p.sym.nts[curSy.n] = true;
                 }
                 else if (p.typ == Node.opt || p.typ == Node.iter)
                 {
                     CompFollow(p.sub);
                 }
                 else if (p.typ == Node.alt)
                 {
                     CompFollow(p.sub); CompFollow(p.down);
                 }
                 p = p.next;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="615" endline="631"><![CDATA[
 
         static void Complete(Symbol sym)
         {
             if (!visited[sym.n])
             {
                 visited[sym.n] = true;
                 foreach (Symbol s in Symbol.nonterminals)
                 {
                     if (sym.nts[s.n])
                     {
                         Complete(s);
                         sym.follow.Or(s.follow);
                         if (sym == curSy) sym.nts[s.n] = false;
                     }
                 }
                 foreach (Symbol s in Symbol.nonterminals)
                 {
                     if (sym.nts[s.n])
                     {
                         Complete(s);
                         sym.follow.Or(s.follow);
                         if (sym == curSy) sym.nts[s.n] = false;
                     }
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="632" endline="652"><![CDATA[
 
         static void CompFollowSets()
         {
             foreach (Symbol sym in Symbol.nonterminals)
             {
                 sym.follow = new BitArray(Symbol.terminals.Count);
                 sym.nts = new BitArray(Symbol.nonterminals.Count);
             }
             foreach (Symbol sym in Symbol.nonterminals)
             {
                 sym.follow = new BitArray(Symbol.terminals.Count);
                 sym.nts = new BitArray(Symbol.nonterminals.Count);
             }
             visited = new BitArray(Node.nodes.Count);
             foreach (Symbol sym in Symbol.nonterminals)
             { // get direct successors of nonterminals
                 curSy = sym;
                 CompFollow(sym.graph);
             }
             foreach (Symbol sym in Symbol.nonterminals)
             { // get direct successors of nonterminals
                 curSy = sym;
                 CompFollow(sym.graph);
             }
             foreach (Symbol sym in Symbol.nonterminals)
             { // add indirect successors to followers
                 visited = new BitArray(Symbol.nonterminals.Count);
                 curSy = sym;
                 Complete(sym);
             }
             foreach (Symbol sym in Symbol.nonterminals)
             { // add indirect successors to followers
                 visited = new BitArray(Symbol.nonterminals.Count);
                 curSy = sym;
                 Complete(sym);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="653" endline="667"><![CDATA[
 
         static Node LeadingAny(Node p)
         {
             if (p == null) return null;
             Node a = null;
             if (p.typ == Node.any) a = p;
             else if (p.typ == Node.alt)
             {
                 a = LeadingAny(p.sub);
                 if (a == null) a = LeadingAny(p.down);
             }
             else if (p.typ == Node.opt || p.typ == Node.iter) a = LeadingAny(p.sub);
             else if (Node.DelNode(p) && !p.up) a = LeadingAny(p.next);
             return a;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="668" endline="698"><![CDATA[
 
         static void FindAS(Node p)
         { // find ANY sets
             Node a;
             while (p != null)
             {
                 if (p.typ == Node.opt || p.typ == Node.iter)
                 {
                     FindAS(p.sub);
                     a = LeadingAny(p.sub);
                     if (a != null) Sets.Subtract(a.set, First(p.next));
                 }
                 else if (p.typ == Node.alt)
                 {
                     BitArray s1 = new BitArray(Symbol.terminals.Count);
                     Node q = p;
                     while (q != null)
                     {
                         FindAS(q.sub);
                         a = LeadingAny(q.sub);
                         if (a != null)
                             Sets.Subtract(a.set, First(q.down).Or(s1));
                         else
                             s1.Or(First(q.sub));
                         q = q.down;
                     }
                     while (q != null)
                     {
                         FindAS(q.sub);
                         a = LeadingAny(q.sub);
                         if (a != null)
                             Sets.Subtract(a.set, First(q.down).Or(s1));
                         else
                             s1.Or(First(q.sub));
                         q = q.down;
                     }
                 }
                 if (p.up) break;
                 p = p.next;
             }
             while (p != null)
             {
                 if (p.typ == Node.opt || p.typ == Node.iter)
                 {
                     FindAS(p.sub);
                     a = LeadingAny(p.sub);
                     if (a != null) Sets.Subtract(a.set, First(p.next));
                 }
                 else if (p.typ == Node.alt)
                 {
                     BitArray s1 = new BitArray(Symbol.terminals.Count);
                     Node q = p;
                     while (q != null)
                     {
                         FindAS(q.sub);
                         a = LeadingAny(q.sub);
                         if (a != null)
                             Sets.Subtract(a.set, First(q.down).Or(s1));
                         else
                             s1.Or(First(q.sub));
                         q = q.down;
                     }
                 }
                 if (p.up) break;
                 p = p.next;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="699" endline="703"><![CDATA[
 
         static void CompAnySets()
         {
             foreach (Symbol sym in Symbol.nonterminals) FindAS(sym.graph);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="704" endline="710"><![CDATA[
 
         public static BitArray Expected(Node p, Symbol curSy)
         {
             BitArray s = First(p);
             if (Node.DelGraph(p)) s.Or(curSy.follow);
             return s;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="711" endline="732"><![CDATA[
 
         static void CompSync(Node p)
         {
             while (p != null && !visited[p.n])
             {
                 visited[p.n] = true;
                 if (p.typ == Node.sync)
                 {
                     BitArray s = Expected(p.next, curSy);
                     s[eofSy.n] = true;
                     allSyncSets.Or(s);
                     p.set = s;
                 }
                 else if (p.typ == Node.alt)
                 {
                     CompSync(p.sub); CompSync(p.down);
                 }
                 else if (p.typ == Node.opt || p.typ == Node.iter)
                     CompSync(p.sub);
                 p = p.next;
             }
             while (p != null && !visited[p.n])
             {
                 visited[p.n] = true;
                 if (p.typ == Node.sync)
                 {
                     BitArray s = Expected(p.next, curSy);
                     s[eofSy.n] = true;
                     allSyncSets.Or(s);
                     p.set = s;
                 }
                 else if (p.typ == Node.alt)
                 {
                     CompSync(p.sub); CompSync(p.down);
                 }
                 else if (p.typ == Node.opt || p.typ == Node.iter)
                     CompSync(p.sub);
                 p = p.next;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="733" endline="744"><![CDATA[
 
         static void CompSyncSets()
         {
             allSyncSets = new BitArray(Symbol.terminals.Count);
             allSyncSets[eofSy.n] = true;
             visited = new BitArray(Node.nodes.Count);
             foreach (Symbol sym in Symbol.nonterminals)
             {
                 curSy = sym;
                 CompSync(curSy.graph);
             }
             foreach (Symbol sym in Symbol.nonterminals)
             {
                 curSy = sym;
                 CompSync(curSy.graph);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="745" endline="754"><![CDATA[
 
         public static void SetupAnys()
         {
             foreach (Node p in Node.nodes)
                 if (p.typ == Node.any)
                 {
                     p.set = new BitArray(Symbol.terminals.Count, true);
                     p.set[eofSy.n] = false;
                 }
             foreach (Node p in Node.nodes)
                 if (p.typ == Node.any)
                 {
                     p.set = new BitArray(Symbol.terminals.Count, true);
                     p.set[eofSy.n] = false;
                 }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="755" endline="770"><![CDATA[
 
         public static void CompDeletableSymbols()
         {
             bool changed;
             do
             {
                 changed = false;
                 foreach (Symbol sym in Symbol.nonterminals)
                     if (!sym.deletable && sym.graph != null && Node.DelGraph(sym.graph))
                     {
                         sym.deletable = true; changed = true;
                     }
                 foreach (Symbol sym in Symbol.nonterminals)
                     if (!sym.deletable && sym.graph != null && Node.DelGraph(sym.graph))
                     {
                         sym.deletable = true; changed = true;
                     }
             } while (changed);
             foreach (Symbol sym in Symbol.nonterminals)
                 if (sym.deletable) Console.WriteLine("  {0} deletable", sym.name);
             foreach (Symbol sym in Symbol.nonterminals)
                 if (sym.deletable) Console.WriteLine("  {0} deletable", sym.name);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="771" endline="776"><![CDATA[
 
         public static void RenumberPragmas()
         {
             int n = Symbol.terminals.Count;
             foreach (Symbol sym in Symbol.pragmas) sym.n = n++;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="777" endline="810"><![CDATA[
 
         public static void CompSymbolSets()
         {
             CompDeletableSymbols();
             CompFirstSets();
             CompFollowSets();
             CompAnySets();
             CompSyncSets();
             if (ddt[1])
             {
                 trace.WriteLine();
                 trace.WriteLine("First & follow symbols
                 trace.WriteLine("----------------------"); trace.WriteLine();
                 foreach (Symbol sym in Symbol.nonterminals)
                 {
                     trace.WriteLine(sym.name);
                     trace.Write("first
                     trace.Write("follow
                     trace.WriteLine();
                 }
                 foreach (Symbol sym in Symbol.nonterminals)
                 {
                     trace.WriteLine(sym.name);
                     trace.Write("first
                     trace.Write("follow
                     trace.WriteLine();
                 }
             }
             if (ddt[4])
             {
                 trace.WriteLine();
                 trace.WriteLine("ANY and SYNC sets
                 trace.WriteLine("-----------------");
                 foreach (Node p in Node.nodes)
                     if (p.typ == Node.any || p.typ == Node.sync)
                     {
                         trace.Write("{0,4} {1,4}
                         Sets.PrintSet(trace, p.set, 11);
                     }
                 foreach (Node p in Node.nodes)
                     if (p.typ == Node.any || p.typ == Node.sync)
                     {
                         trace.Write("{0,4} {1,4}
                         Sets.PrintSet(trace, p.set, 11);
                     }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="811" endline="824"><![CDATA[
 
         //---------------------------------------------------------------------
         //  Grammar checks
         //---------------------------------------------------------------------
 
         public static bool GrammarOk()
         {
             bool ok = NtsComplete()
                 && AllNtReached()
                 && NoCircularProductions()
                 && AllNtToTerm();
             if (ok) CheckLL1();
             return ok;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="825" endline="854"><![CDATA[
 
         //--------------- check for circular productions ----------------------
 
         class CNode
         {	// node of list for finding circular productions
             public Symbol left, right;
 
             public CNode(Symbol l, Symbol r)
             {
                 left = l; right = r;
             }
         }
 
         static void GetSingles(Node p, ArrayList singles)
         {
             if (p == null) return;  // end of graph
             if (p.typ == Node.nt)
             {
                 if (p.up || Node.DelGraph(p.next)) singles.Add(p.sym);
             }
             else if (p.typ == Node.alt || p.typ == Node.iter || p.typ == Node.opt)
             {
                 if (p.up || Node.DelGraph(p.next))
                 {
                     GetSingles(p.sub, singles);
                     if (p.typ == Node.alt) GetSingles(p.down, singles);
                 }
             }
             if (!p.up && Node.DelNode(p)) GetSingles(p.next, singles);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="855" endline="891"><![CDATA[
 
         public static bool NoCircularProductions()
         {
             bool ok, changed, onLeftSide, onRightSide;
             ArrayList list = new ArrayList();
             foreach (Symbol sym in Symbol.nonterminals)
             {
                 ArrayList singles = new ArrayList();
                 GetSingles(sym.graph, singles); // get nonterminals s such that sym-->s
                 foreach (Symbol s in singles) list.Add(new CNode(sym, s));
             }
             foreach (Symbol sym in Symbol.nonterminals)
             {
                 ArrayList singles = new ArrayList();
                 GetSingles(sym.graph, singles); // get nonterminals s such that sym-->s
                 foreach (Symbol s in singles) list.Add(new CNode(sym, s));
             }
             do
             {
                 changed = false;
                 for (int i = 0; i < list.Count; i++)
                 {
                     CNode n = (CNode)list[i];
                     onLeftSide = false; onRightSide = false;
                     foreach (CNode m in list)
                     {
                         if (n.left == m.right) onRightSide = true;
                         if (n.right == m.left) onLeftSide = true;
                     }
                     foreach (CNode m in list)
                     {
                         if (n.left == m.right) onRightSide = true;
                         if (n.right == m.left) onLeftSide = true;
                     }
                     if (!onLeftSide || !onRightSide)
                     {
                         list.Remove(n); i--; changed = true;
                     }
                 }
                 for (int i = 0; i < list.Count; i++)
                 {
                     CNode n = (CNode)list[i];
                     onLeftSide = false; onRightSide = false;
                     foreach (CNode m in list)
                     {
                         if (n.left == m.right) onRightSide = true;
                         if (n.right == m.left) onLeftSide = true;
                     }
                     if (!onLeftSide || !onRightSide)
                     {
                         list.Remove(n); i--; changed = true;
                     }
                 }
             } while (changed);
             ok = true;
             foreach (CNode n in list)
             {
                 ok = false; Errors.count++;
                 Console.WriteLine("  {0} --> {1}", n.left.name, n.right.name);
             }
             foreach (CNode n in list)
             {
                 ok = false; Errors.count++;
                 Console.WriteLine("  {0} --> {1}", n.left.name, n.right.name);
             }
             return ok;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="892" endline="905"><![CDATA[
 
         //--------------- check for LL(1) errors ----------------------
 
         static void LL1Error(int cond, Symbol sym)
         {
             Console.Write("  LL1 warning in {0}
             if (sym != null) Console.Write("{0} is ", sym.name);
             switch (cond)
             {
                 case 1
                 case 2
                 case 3
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="906" endline="913"><![CDATA[
 
         static void CheckOverlap(BitArray s1, BitArray s2, int cond)
         {
             foreach (Symbol sym in Symbol.terminals)
             {
                 if (s1[sym.n] && s2[sym.n]) LL1Error(cond, sym);
             }
             foreach (Symbol sym in Symbol.terminals)
             {
                 if (s1[sym.n] && s2[sym.n]) LL1Error(cond, sym);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="914" endline="948"><![CDATA[
 
         static void CheckAlts(Node p)
         {
             BitArray s1, s2;
             while (p != null)
             {
                 if (p.typ == Node.alt)
                 {
                     Node q = p;
                     s1 = new BitArray(Symbol.terminals.Count);
                     while (q != null)
                     { // for all alternatives
                         s2 = Expected(q.sub, curSy);
                         CheckOverlap(s1, s2, 1);
                         s1.Or(s2);
                         CheckAlts(q.sub);
                         q = q.down;
                     }
                     while (q != null)
                     { // for all alternatives
                         s2 = Expected(q.sub, curSy);
                         CheckOverlap(s1, s2, 1);
                         s1.Or(s2);
                         CheckAlts(q.sub);
                         q = q.down;
                     }
                 }
                 else if (p.typ == Node.opt || p.typ == Node.iter)
                 {
                     s1 = Expected(p.sub, curSy);
                     s2 = Expected(p.next, curSy);
                     CheckOverlap(s1, s2, 2);
                     CheckAlts(p.sub);
                 }
                 else if (p.typ == Node.any)
                 {
                     if (Sets.Elements(p.set) == 0) LL1Error(3, null);
                     // e.g. {ANY} ANY or [ANY] ANY
                 }
                 if (p.up) break;
                 p = p.next;
             }
             while (p != null)
             {
                 if (p.typ == Node.alt)
                 {
                     Node q = p;
                     s1 = new BitArray(Symbol.terminals.Count);
                     while (q != null)
                     { // for all alternatives
                         s2 = Expected(q.sub, curSy);
                         CheckOverlap(s1, s2, 1);
                         s1.Or(s2);
                         CheckAlts(q.sub);
                         q = q.down;
                     }
                 }
                 else if (p.typ == Node.opt || p.typ == Node.iter)
                 {
                     s1 = Expected(p.sub, curSy);
                     s2 = Expected(p.next, curSy);
                     CheckOverlap(s1, s2, 2);
                     CheckAlts(p.sub);
                 }
                 else if (p.typ == Node.any)
                 {
                     if (Sets.Elements(p.set) == 0) LL1Error(3, null);
                     // e.g. {ANY} ANY or [ANY] ANY
                 }
                 if (p.up) break;
                 p = p.next;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="949" endline="957"><![CDATA[
 
         public static void CheckLL1()
         {
             foreach (Symbol sym in Symbol.nonterminals)
             {
                 curSy = sym;
                 CheckAlts(curSy.graph);
             }
             foreach (Symbol sym in Symbol.nonterminals)
             {
                 curSy = sym;
                 CheckAlts(curSy.graph);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="958" endline="973"><![CDATA[
 
         //------------- check if every nts has a production --------------------
 
         public static bool NtsComplete()
         {
             bool complete = true;
             foreach (Symbol sym in Symbol.nonterminals)
             {
                 if (sym.graph == null)
                 {
                     complete = false; Errors.count++;
                     Console.WriteLine("  No production for {0}", sym.name);
                 }
             }
             foreach (Symbol sym in Symbol.nonterminals)
             {
                 if (sym.graph == null)
                 {
                     complete = false; Errors.count++;
                     Console.WriteLine("  No production for {0}", sym.name);
                 }
             }
             return complete;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="974" endline="994"><![CDATA[
 
         //-------------- check if every nts can be reached  -----------------
 
         static void MarkReachedNts(Node p)
         {
             while (p != null)
             {
                 if (p.typ == Node.nt && !visited[p.sym.n])
                 { // new nt reached
                     visited[p.sym.n] = true;
                     MarkReachedNts(p.sym.graph);
                 }
                 else if (p.typ == Node.alt || p.typ == Node.iter || p.typ == Node.opt)
                 {
                     MarkReachedNts(p.sub);
                     if (p.typ == Node.alt) MarkReachedNts(p.down);
                 }
                 if (p.up) break;
                 p = p.next;
             }
             while (p != null)
             {
                 if (p.typ == Node.nt && !visited[p.sym.n])
                 { // new nt reached
                     visited[p.sym.n] = true;
                     MarkReachedNts(p.sym.graph);
                 }
                 else if (p.typ == Node.alt || p.typ == Node.iter || p.typ == Node.opt)
                 {
                     MarkReachedNts(p.sub);
                     if (p.typ == Node.alt) MarkReachedNts(p.down);
                 }
                 if (p.up) break;
                 p = p.next;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="995" endline="1011"><![CDATA[
 
         public static bool AllNtReached()
         {
             bool ok = true;
             visited = new BitArray(Symbol.nonterminals.Count);
             visited[gramSy.n] = true;
             MarkReachedNts(gramSy.graph);
             foreach (Symbol sym in Symbol.nonterminals)
             {
                 if (!visited[sym.n])
                 {
                     ok = false; Errors.count++;
                     Console.WriteLine("  {0} cannot be reached", sym.name);
                 }
             }
             foreach (Symbol sym in Symbol.nonterminals)
             {
                 if (!visited[sym.n])
                 {
                     ok = false; Errors.count++;
                     Console.WriteLine("  {0} cannot be reached", sym.name);
                 }
             }
             return ok;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="1012" endline="1026"><![CDATA[
 
         //--------- check if every nts can be derived to terminals  ------------
 
         static bool IsTerm(Node p, BitArray mark)
         { // true if graph can be derived to terminals
             while (p != null)
             {
                 if (p.typ == Node.nt && !mark[p.sym.n]) return false;
                 if (p.typ == Node.alt && !IsTerm(p.sub, mark)
                 && (p.down == null || !IsTerm(p.down, mark))) return false;
                 if (p.up) break;
                 p = p.next;
             }
             while (p != null)
             {
                 if (p.typ == Node.nt && !mark[p.sym.n]) return false;
                 if (p.typ == Node.alt && !IsTerm(p.sub, mark)
                 && (p.down == null || !IsTerm(p.down, mark))) return false;
                 if (p.up) break;
                 p = p.next;
             }
             return true;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="1027" endline="1049"><![CDATA[
 
         public static bool AllNtToTerm()
         {
             bool changed, ok = true;
             BitArray mark = new BitArray(Symbol.nonterminals.Count);
             // a nonterminal is marked if it can be derived to terminal symbols
             do
             {
                 changed = false;
                 foreach (Symbol sym in Symbol.nonterminals)
                     if (!mark[sym.n] && IsTerm(sym.graph, mark))
                     {
                         mark[sym.n] = true; changed = true;
                     }
                 foreach (Symbol sym in Symbol.nonterminals)
                     if (!mark[sym.n] && IsTerm(sym.graph, mark))
                     {
                         mark[sym.n] = true; changed = true;
                     }
             } while (changed);
             foreach (Symbol sym in Symbol.nonterminals)
                 if (!mark[sym.n])
                 {
                     ok = false; Errors.count++;
                     Console.WriteLine("  {0} cannot be derived to terminals", sym.name);
                 }
             foreach (Symbol sym in Symbol.nonterminals)
                 if (!mark[sym.n])
                 {
                     ok = false; Errors.count++;
                     Console.WriteLine("  {0} cannot be derived to terminals", sym.name);
                 }
             return ok;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="1050" endline="1058"><![CDATA[
 
         /*---------------------------------------------------------------------
           Utility functions
         ---------------------------------------------------------------------*/
 
         static int Num(Node p)
         {
             if (p == null) return 0; else return p.n;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="1059" endline="1072"><![CDATA[
 
         static void PrintSym(Symbol sym)
         {
             trace.Write("{0,3} {1,-14} {2}", sym.n, Node.Name(sym.name), Node.nTyp[sym.typ]);
             if (sym.attrPos == null) trace.Write(" false "); else trace.Write(" true  ");
             if (sym.typ == Node.nt)
             {
                 trace.Write("{0,5}", Num(sym.graph));
                 if (sym.deletable) trace.Write(" true  "); else trace.Write(" false ");
             }
             else
                 trace.Write("            ");
             trace.WriteLine("{0,5}", sym.line);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="1073" endline="1083"><![CDATA[
 
         public static void PrintSymbolTable()
         {
             trace.WriteLine("Symbol Table
             trace.WriteLine("------------"); trace.WriteLine();
             trace.WriteLine(" nr name          typ  hasAt graph  del   line");
             foreach (Symbol sym in Symbol.terminals) PrintSym(sym);
             foreach (Symbol sym in Symbol.pragmas) PrintSym(sym);
             foreach (Symbol sym in Symbol.nonterminals) PrintSym(sym);
             trace.WriteLine();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="1084" endline="1126"><![CDATA[
 
         public static void XRef()
         {
             SortedList tab = new SortedList();
             // collect lines where symbols have been defined
             foreach (Symbol sym in Symbol.nonterminals)
             {
                 ArrayList list = (ArrayList)tab[sym];
                 if (list == null) { list = new ArrayList(); tab[sym] = list; }
                 list.Add(-sym.line);
             }
             foreach (Symbol sym in Symbol.nonterminals)
             {
                 ArrayList list = (ArrayList)tab[sym];
                 if (list == null) { list = new ArrayList(); tab[sym] = list; }
                 list.Add(-sym.line);
             }
             // collect lines where symbols have been referenced
             foreach (Node n in Node.nodes)
             {
                 if (n.typ == Node.t || n.typ == Node.wt || n.typ == Node.nt)
                 {
                     ArrayList list = (ArrayList)tab[n.sym];
                     if (list == null) { list = new ArrayList(); tab[n.sym] = list; }
                     list.Add(n.line);
                 }
             }
             foreach (Node n in Node.nodes)
             {
                 if (n.typ == Node.t || n.typ == Node.wt || n.typ == Node.nt)
                 {
                     ArrayList list = (ArrayList)tab[n.sym];
                     if (list == null) { list = new ArrayList(); tab[n.sym] = list; }
                     list.Add(n.line);
                 }
             }
             // print cross reference list
             trace.WriteLine();
             trace.WriteLine("Cross reference list
             trace.WriteLine("--------------------"); trace.WriteLine();
             foreach (Symbol sym in tab.Keys)
             {
                 trace.Write("  {0,-12}", Node.Name(sym.name));
                 ArrayList list = (ArrayList)tab[sym];
                 int col = 14;
                 foreach (int line in list)
                 {
                     if (col + 5 > 80)
                     {
                         trace.WriteLine();
                         for (col = 1; col <= 14; col++) trace.Write(" ");
                     }
                     trace.Write("{0,5}", line); col += 5;
                 }
                 foreach (int line in list)
                 {
                     if (col + 5 > 80)
                     {
                         trace.WriteLine();
                         for (col = 1; col <= 14; col++) trace.Write(" ");
                     }
                     trace.Write("{0,5}", line); col += 5;
                 }
                 trace.WriteLine();
             }
             foreach (Symbol sym in tab.Keys)
             {
                 trace.Write("  {0,-12}", Node.Name(sym.name));
                 ArrayList list = (ArrayList)tab[sym];
                 int col = 14;
                 foreach (int line in list)
                 {
                     if (col + 5 > 80)
                     {
                         trace.WriteLine();
                         for (col = 1; col <= 14; col++) trace.Write(" ");
                     }
                     trace.Write("{0,5}", line); col += 5;
                 }
                 trace.WriteLine();
             }
             trace.WriteLine(); trace.WriteLine();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="1127" endline="1147"><![CDATA[
 
         public static void SetDDT(string s)
         {
             s = s.ToUpper();
             foreach (char ch in s)
             {
                 if ('0' <= ch && ch <= '9') ddt[ch - '0'] = true;
                 else switch (ch)
                     {
                         case 'A'
                         case 'F'
                         case 'G'
                         case 'I'
                         case 'J'
                         case 'P'
                         case 'S'
                         case 'X'
                         default
                     }
             }
             foreach (char ch in s)
             {
                 if ('0' <= ch && ch <= '9') ddt[ch - '0'] = true;
                 else switch (ch)
                     {
                         case 'A'
                         case 'F'
                         case 'G'
                         case 'I'
                         case 'J'
                         case 'P'
                         case 'S'
                         case 'X'
                         default
                     }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="1148" endline="1153"><![CDATA[
 
         public static void Init(TextWriter w)
         {
             trace = w;
             eofSy = new Symbol(Node.t, "EOF", 0);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="512" endline="512"><![CDATA[
         public static bool[] ddt = new bool[10];	// debug and test switches
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="106" endline="108"><![CDATA[
         {
             return (DiffText(TextA, TextB, false, false, false));
         } // DiffText
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="109" endline="139"><![CDATA[
 
 
         /// <summary>
         /// Find the difference in 2 text documents, comparing by textlines.
         /// The algorithm itself is comparing 2 arrays of numbers so when comparing 2 text documents
         /// each line is converted into a (hash) number. This hash-value is computed by storing all
         /// textlines into a common hashtable so i can find dublicates in there, and generating a 
         /// new number each time a new textline is inserted.
         /// </summary>
         /// <param name="TextA">A-version of the text (usualy the old one)</param>
         /// <param name="TextB">B-version of the text (usualy the new one)</param>
         /// <param name="trimSpace">When set to true, all leading and trailing whitespace characters are stripped out before the comparation is done.</param>
         /// <param name="ignoreSpace">When set to true, all whitespace characters are converted to a single space character before the comparation is done.</param>
         /// <param name="ignoreCase">When set to true, all characters are converted to their lowercase equivivalence before the comparation is done.</param>
         /// <returns>Returns a array of Items that describe the differences.</returns>
         public static Item[] DiffText (string TextA, string TextB, bool trimSpace, bool ignoreSpace, bool ignoreCase)
         {
             // prepare the input-text and convert to comparable numbers.
             Hashtable h = new Hashtable(TextA.Length + TextB.Length);
 
             // The A-Version of the data (original data) to be compared.
             DiffData DataA = new DiffData(DiffCodes(TextA, h, trimSpace, ignoreSpace, ignoreCase));
 
             // The B-Version of the data (modified data) to be compared.
             DiffData DataB = new DiffData(DiffCodes(TextB, h, trimSpace, ignoreSpace, ignoreCase));
 
             h = null; // free up hashtable memory (maybe)
 
             LCS(DataA, 0, DataA.Length, DataB, 0, DataB.Length);
             return CreateDiffs(DataA, DataB);
         } // DiffText
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="140" endline="158"><![CDATA[
 
 
         /// <summary>
         /// Find the difference in 2 arrays of integers.
         /// </summary>
         /// <param name="ArrayA">A-version of the numbers (usualy the old one)</param>
         /// <param name="ArrayB">B-version of the numbers (usualy the new one)</param>
         /// <returns>Returns a array of Items that describe the differences.</returns>
         public static Item[] DiffInt (int[] ArrayA, int[] ArrayB)
         {
             // The A-Version of the data (original data) to be compared.
             DiffData DataA = new DiffData(ArrayA);
 
             // The B-Version of the data (modified data) to be compared.
             DiffData DataB = new DiffData(ArrayB);
 
             LCS(DataA, 0, DataA.Length, DataB, 0, DataB.Length);
             return CreateDiffs(DataA, DataB);
         } // Diff
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="159" endline="211"><![CDATA[
 
 
         /// <summary>
         /// This function converts all textlines of the text into unique numbers for every unique textline
         /// so further work can work only with simple numbers.
         /// </summary>
         /// <param name="aText">the input text</param>
         /// <param name="h">This extern initialized hashtable is used for storing all ever used textlines.</param>
         /// <param name="trimSpace">ignore leading and trailing space characters</param>
         /// <returns>a array of integers.</returns>
         private static int[] DiffCodes (string aText, Hashtable h, bool trimSpace, bool ignoreSpace, bool ignoreCase)
         {
             // get all codes of the text
             string[] Lines;
             int[] Codes;
             int lastUsedCode = h.Count;
             object aCode;
             string s;
 
             // strip off all cr, only use lf as textline separator.
             aText = aText.Replace("\r", "");
             Lines = aText.Split('\n');
 
             Codes = new int[Lines.Length];
 
             for (int i = 0; i < Lines.Length; ++i)
             {
                 s = Lines[i];
                 if (trimSpace)
                     s = s.Trim();
 
                 if (ignoreSpace)
                 {
                     s = Regex.Replace(s, "\\s+", " ");            // TODO
                 }
 
                 if (ignoreCase)
                     s = s.ToLower();
 
                 aCode = h[s];
                 if (aCode == null)
                 {
                     lastUsedCode++;
                     h[s] = lastUsedCode;
                     Codes[i] = lastUsedCode;
                 }
                 else
                 {
                     Codes[i] = (int)aCode;
                 } // if
             } // for
             for (int i = 0; i < Lines.Length; ++i)
             {
                 s = Lines[i];
                 if (trimSpace)
                     s = s.Trim();
 
                 if (ignoreSpace)
                 {
                     s = Regex.Replace(s, "\\s+", " ");            // TODO
                 }
 
                 if (ignoreCase)
                     s = s.ToLower();
 
                 aCode = h[s];
                 if (aCode == null)
                 {
                     lastUsedCode++;
                     h[s] = lastUsedCode;
                     Codes[i] = lastUsedCode;
                 }
                 else
                 {
                     Codes[i] = (int)aCode;
                 } // if
             } // for
             return (Codes);
         } // DiffCodes
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="212" endline="341"><![CDATA[
 
 
         /// <summary>
         /// This is the algorithm to find the Shortest Middle Snake (SMS).
         /// </summary>
         /// <param name="DataA">sequence A</param>
         /// <param name="LowerA">lower bound of the actual range in DataA</param>
         /// <param name="UpperA">upper bound of the actual range in DataA (exclusive)</param>
         /// <param name="DataB">sequence B</param>
         /// <param name="LowerB">lower bound of the actual range in DataB</param>
         /// <param name="UpperB">upper bound of the actual range in DataB (exclusive)</param>
         /// <returns>a MiddleSnakeData record containing x,y and u,v</returns>
         private static SMSRD SMS (DiffData DataA, int LowerA, int UpperA, DiffData DataB, int LowerB, int UpperB)
         {
             SMSRD ret;
             int MAX = DataA.Length + DataB.Length + 1;
 
             int DownK = LowerA - LowerB; // the k-line to start the forward search
             int UpK = UpperA - UpperB; // the k-line to start the reverse search
 
             int Delta = (UpperA - LowerA) - (UpperB - LowerB);
             bool oddDelta = (Delta & 1) != 0;
 
             /// vector for the (0,0) to (x,y) search
             int[] DownVector = new int[2 * MAX + 2];
 
             /// vector for the (u,v) to (N,M) search
             int[] UpVector = new int[2 * MAX + 2];
 
             // The vectors in the publication accepts negative indexes. the vectors implemented here are 0-based
             // and are access using a specific offset
             int DownOffset = MAX - DownK;
             int UpOffset = MAX - UpK;
 
             int MaxD = ((UpperA - LowerA + UpperB - LowerB) / 2) + 1;
 
             // Debug.Write(2, "SMS", String.Format("Search the box
 
             // init vectors
             DownVector[DownOffset + DownK + 1] = LowerA;
             UpVector[UpOffset + UpK - 1] = UpperA;
 
             for (int D = 0; D <= MaxD; D++)
             {
 
                 // Extend the forward path.
                 for (int k = DownK - D; k <= DownK + D; k += 2)
                 {
                     // Debug.Write(0, "SMS", "extend forward path " + k.ToString());
 
                     // find the only or better starting point
                     int x, y;
                     if (k == DownK - D)
                     {
                         x = DownVector[DownOffset + k + 1]; // down
                     }
                     else
                     {
                         x = DownVector[DownOffset + k - 1] + 1; // a step to the right
                         if ((k < DownK + D) && (DownVector[DownOffset + k + 1] >= x))
                             x = DownVector[DownOffset + k + 1]; // down
                     }
                     y = x - k;
 
                     // find the end of the furthest reaching forward D-path in diagonal k.
                     while ((x < UpperA) && (y < UpperB) && (DataA.data[x] == DataB.data[y]))
                     {
                         x++; y++;
                     }
                     while ((x < UpperA) && (y < UpperB) && (DataA.data[x] == DataB.data[y]))
                     {
                         x++; y++;
                     }
                     DownVector[DownOffset + k] = x;
 
                     // overlap ?
                     if (oddDelta && (UpK - D < k) && (k < UpK + D))
                     {
                         if (UpVector[UpOffset + k] <= DownVector[DownOffset + k])
                         {
                             ret.x = DownVector[DownOffset + k];
                             ret.y = DownVector[DownOffset + k] - k;
                             // ret.u = UpVector[UpOffset + k];      // 2002.09.20
                             // ret.v = UpVector[UpOffset + k] - k;
                             return (ret);
                         } // if
                     } // if
 
                 } // for k
                 for (int k = DownK - D; k <= DownK + D; k += 2)
                 {
                     // Debug.Write(0, "SMS", "extend forward path " + k.ToString());
 
                     // find the only or better starting point
                     int x, y;
                     if (k == DownK - D)
                     {
                         x = DownVector[DownOffset + k + 1]; // down
                     }
                     else
                     {
                         x = DownVector[DownOffset + k - 1] + 1; // a step to the right
                         if ((k < DownK + D) && (DownVector[DownOffset + k + 1] >= x))
                             x = DownVector[DownOffset + k + 1]; // down
                     }
                     y = x - k;
 
                     // find the end of the furthest reaching forward D-path in diagonal k.
                     while ((x < UpperA) && (y < UpperB) && (DataA.data[x] == DataB.data[y]))
                     {
                         x++; y++;
                     }
                     DownVector[DownOffset + k] = x;
 
                     // overlap ?
                     if (oddDelta && (UpK - D < k) && (k < UpK + D))
                     {
                         if (UpVector[UpOffset + k] <= DownVector[DownOffset + k])
                         {
                             ret.x = DownVector[DownOffset + k];
                             ret.y = DownVector[DownOffset + k] - k;
                             // ret.u = UpVector[UpOffset + k];      // 2002.09.20
                             // ret.v = UpVector[UpOffset + k] - k;
                             return (ret);
                         } // if
                     } // if
 
                 } // for k
 
                 // Extend the reverse path.
                 for (int k = UpK - D; k <= UpK + D; k += 2)
                 {
                     // Debug.Write(0, "SMS", "extend reverse path " + k.ToString());
 
                     // find the only or better starting point
                     int x, y;
                     if (k == UpK + D)
                     {
                         x = UpVector[UpOffset + k - 1]; // up
                     }
                     else
                     {
                         x = UpVector[UpOffset + k + 1] - 1; // left
                         if ((k > UpK - D) && (UpVector[UpOffset + k - 1] < x))
                             x = UpVector[UpOffset + k - 1]; // up
                     } // if
                     y = x - k;
 
                     while ((x > LowerA) && (y > LowerB) && (DataA.data[x - 1] == DataB.data[y - 1]))
                     {
                         x--; y--; // diagonal
                     }
                     while ((x > LowerA) && (y > LowerB) && (DataA.data[x - 1] == DataB.data[y - 1]))
                     {
                         x--; y--; // diagonal
                     }
                     UpVector[UpOffset + k] = x;
 
                     // overlap ?
                     if (!oddDelta && (DownK - D <= k) && (k <= DownK + D))
                     {
                         if (UpVector[UpOffset + k] <= DownVector[DownOffset + k])
                         {
                             ret.x = DownVector[DownOffset + k];
                             ret.y = DownVector[DownOffset + k] - k;
                             // ret.u = UpVector[UpOffset + k];     // 2002.09.20
                             // ret.v = UpVector[UpOffset + k] - k;
                             return (ret);
                         } // if
                     } // if
 
                 } // for k
                 for (int k = UpK - D; k <= UpK + D; k += 2)
                 {
                     // Debug.Write(0, "SMS", "extend reverse path " + k.ToString());
 
                     // find the only or better starting point
                     int x, y;
                     if (k == UpK + D)
                     {
                         x = UpVector[UpOffset + k - 1]; // up
                     }
                     else
                     {
                         x = UpVector[UpOffset + k + 1] - 1; // left
                         if ((k > UpK - D) && (UpVector[UpOffset + k - 1] < x))
                             x = UpVector[UpOffset + k - 1]; // up
                     } // if
                     y = x - k;
 
                     while ((x > LowerA) && (y > LowerB) && (DataA.data[x - 1] == DataB.data[y - 1]))
                     {
                         x--; y--; // diagonal
                     }
                     UpVector[UpOffset + k] = x;
 
                     // overlap ?
                     if (!oddDelta && (DownK - D <= k) && (k <= DownK + D))
                     {
                         if (UpVector[UpOffset + k] <= DownVector[DownOffset + k])
                         {
                             ret.x = DownVector[DownOffset + k];
                             ret.y = DownVector[DownOffset + k] - k;
                             // ret.u = UpVector[UpOffset + k];     // 2002.09.20
                             // ret.v = UpVector[UpOffset + k] - k;
                             return (ret);
                         } // if
                     } // if
 
                 } // for k
 
             } // for D
             for (int D = 0; D <= MaxD; D++)
             {
 
                 // Extend the forward path.
                 for (int k = DownK - D; k <= DownK + D; k += 2)
                 {
                     // Debug.Write(0, "SMS", "extend forward path " + k.ToString());
 
                     // find the only or better starting point
                     int x, y;
                     if (k == DownK - D)
                     {
                         x = DownVector[DownOffset + k + 1]; // down
                     }
                     else
                     {
                         x = DownVector[DownOffset + k - 1] + 1; // a step to the right
                         if ((k < DownK + D) && (DownVector[DownOffset + k + 1] >= x))
                             x = DownVector[DownOffset + k + 1]; // down
                     }
                     y = x - k;
 
                     // find the end of the furthest reaching forward D-path in diagonal k.
                     while ((x < UpperA) && (y < UpperB) && (DataA.data[x] == DataB.data[y]))
                     {
                         x++; y++;
                     }
                     DownVector[DownOffset + k] = x;
 
                     // overlap ?
                     if (oddDelta && (UpK - D < k) && (k < UpK + D))
                     {
                         if (UpVector[UpOffset + k] <= DownVector[DownOffset + k])
                         {
                             ret.x = DownVector[DownOffset + k];
                             ret.y = DownVector[DownOffset + k] - k;
                             // ret.u = UpVector[UpOffset + k];      // 2002.09.20
                             // ret.v = UpVector[UpOffset + k] - k;
                             return (ret);
                         } // if
                     } // if
 
                 } // for k
 
                 // Extend the reverse path.
                 for (int k = UpK - D; k <= UpK + D; k += 2)
                 {
                     // Debug.Write(0, "SMS", "extend reverse path " + k.ToString());
 
                     // find the only or better starting point
                     int x, y;
                     if (k == UpK + D)
                     {
                         x = UpVector[UpOffset + k - 1]; // up
                     }
                     else
                     {
                         x = UpVector[UpOffset + k + 1] - 1; // left
                         if ((k > UpK - D) && (UpVector[UpOffset + k - 1] < x))
                             x = UpVector[UpOffset + k - 1]; // up
                     } // if
                     y = x - k;
 
                     while ((x > LowerA) && (y > LowerB) && (DataA.data[x - 1] == DataB.data[y - 1]))
                     {
                         x--; y--; // diagonal
                     }
                     UpVector[UpOffset + k] = x;
 
                     // overlap ?
                     if (!oddDelta && (DownK - D <= k) && (k <= DownK + D))
                     {
                         if (UpVector[UpOffset + k] <= DownVector[DownOffset + k])
                         {
                             ret.x = DownVector[DownOffset + k];
                             ret.y = DownVector[DownOffset + k] - k;
                             // ret.u = UpVector[UpOffset + k];     // 2002.09.20
                             // ret.v = UpVector[UpOffset + k] - k;
                             return (ret);
                         } // if
                     } // if
 
                 } // for k
 
             } // for D
 
             throw new ApplicationException("the algorithm should never come here.");
         } // SMS
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="342" endline="396"><![CDATA[
 
 
         /// <summary>
         /// This is the divide-and-conquer implementation of the longes common-subsequence (LCS) 
         /// algorithm.
         /// The published algorithm passes recursively parts of the A and B sequences.
         /// To avoid copying these arrays the lower and upper bounds are passed while the sequences stay constant.
         /// </summary>
         /// <param name="DataA">sequence A</param>
         /// <param name="LowerA">lower bound of the actual range in DataA</param>
         /// <param name="UpperA">upper bound of the actual range in DataA (exclusive)</param>
         /// <param name="DataB">sequence B</param>
         /// <param name="LowerB">lower bound of the actual range in DataB</param>
         /// <param name="UpperB">upper bound of the actual range in DataB (exclusive)</param>
         private static void LCS (DiffData DataA, int LowerA, int UpperA, DiffData DataB, int LowerB, int UpperB)
         {
             // Debug.Write(2, "LCS", String.Format("Analyse the box
 
             // Fast walkthrough equal lines at the start
             while (LowerA < UpperA && LowerB < UpperB && DataA.data[LowerA] == DataB.data[LowerB])
             {
                 LowerA++; LowerB++;
             }
             while (LowerA < UpperA && LowerB < UpperB && DataA.data[LowerA] == DataB.data[LowerB])
             {
                 LowerA++; LowerB++;
             }
 
             // Fast walkthrough equal lines at the end
             while (LowerA < UpperA && LowerB < UpperB && DataA.data[UpperA - 1] == DataB.data[UpperB - 1])
             {
                 --UpperA; --UpperB;
             }
             while (LowerA < UpperA && LowerB < UpperB && DataA.data[UpperA - 1] == DataB.data[UpperB - 1])
             {
                 --UpperA; --UpperB;
             }
 
             if (LowerA == UpperA)
             {
                 // mark as inserted lines.
                 while (LowerB < UpperB)
                     DataB.modified[LowerB++] = true;
                 while (LowerB < UpperB)
                     DataB.modified[LowerB++] = true;
 
             }
             else if (LowerB == UpperB)
             {
                 // mark as deleted lines.
                 while (LowerA < UpperA)
                     DataA.modified[LowerA++] = true;
                 while (LowerA < UpperA)
                     DataA.modified[LowerA++] = true;
 
             }
             else
             {
                 // Find the middle snakea and length of an optimal path for A and B
                 SMSRD smsrd = SMS(DataA, LowerA, UpperA, DataB, LowerB, UpperB);
                 // Debug.Write(2, "MiddleSnakeData", String.Format("{0},{1}", smsrd.x, smsrd.y));
 
                 // The path is from LowerX to (x,y) and (x,y) ot UpperX
                 LCS(DataA, LowerA, smsrd.x, DataB, LowerB, smsrd.y);
                 LCS(DataA, smsrd.x, UpperA, DataB, smsrd.y, UpperB);  // 2002.09.20
             }
         } // LCS()
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="397" endline="455"><![CDATA[
 
 
         /// <summary>Scan the tables of which lines are inserted and deleted,
         /// producing an edit script in forward order.  
         /// </summary>
         /// dynamic array
         private static Item[] CreateDiffs (DiffData DataA, DiffData DataB)
         {
             ArrayList a = new ArrayList();
             Item aItem;
             Item[] result;
 
             int StartA, StartB;
             int LineA, LineB;
 
             LineA = 0;
             LineB = 0;
             while (LineA < DataA.Length || LineB < DataB.Length)
             {
                 if ((LineA < DataA.Length) && (!DataA.modified[LineA])
                   && (LineB < DataB.Length) && (!DataB.modified[LineB]))
                 {
                     // equal lines
                     LineA++;
                     LineB++;
 
                 }
                 else
                 {
                     // maybe deleted and/or inserted lines
                     StartA = LineA;
                     StartB = LineB;
 
                     while (LineA < DataA.Length && (LineB >= DataB.Length || DataA.modified[LineA]))
                         // while (LineA < DataA.Length && DataA.modified[LineA])
                         LineA++;
                     while (LineA < DataA.Length && (LineB >= DataB.Length || DataA.modified[LineA]))
                         // while (LineA < DataA.Length && DataA.modified[LineA])
                         LineA++;
 
                     while (LineB < DataB.Length && (LineA >= DataA.Length || DataB.modified[LineB]))
                         // while (LineB < DataB.Length && DataB.modified[LineB])
                         LineB++;
                     while (LineB < DataB.Length && (LineA >= DataA.Length || DataB.modified[LineB]))
                         // while (LineB < DataB.Length && DataB.modified[LineB])
                         LineB++;
 
                     if ((StartA < LineA) || (StartB < LineB))
                     {
                         // store a new difference-item
                         aItem = new Item();
                         aItem.StartA = StartA;
                         aItem.StartB = StartB;
                         aItem.deletedA = LineA - StartA;
                         aItem.insertedB = LineB - StartB;
                         a.Add(aItem);
                     } // if
                 } // if
             } // while
             while (LineA < DataA.Length || LineB < DataB.Length)
             {
                 if ((LineA < DataA.Length) && (!DataA.modified[LineA])
                   && (LineB < DataB.Length) && (!DataB.modified[LineB]))
                 {
                     // equal lines
                     LineA++;
                     LineB++;
 
                 }
                 else
                 {
                     // maybe deleted and/or inserted lines
                     StartA = LineA;
                     StartB = LineB;
 
                     while (LineA < DataA.Length && (LineB >= DataB.Length || DataA.modified[LineA]))
                         // while (LineA < DataA.Length && DataA.modified[LineA])
                         LineA++;
 
                     while (LineB < DataB.Length && (LineA >= DataA.Length || DataB.modified[LineB]))
                         // while (LineB < DataB.Length && DataB.modified[LineB])
                         LineB++;
 
                     if ((StartA < LineA) || (StartB < LineB))
                     {
                         // store a new difference-item
                         aItem = new Item();
                         aItem.StartA = StartA;
                         aItem.StartB = StartB;
                         aItem.deletedA = LineA - StartA;
                         aItem.insertedB = LineB - StartB;
                         a.Add(aItem);
                     } // if
                 } // if
             } // while
 
             result = new Item[a.Count];
             a.CopyTo(result);
 
             return (result);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\Tab.cs" startline="456" endline="485"><![CDATA[
 
     } // class Diff
 
     /// <summary>Data on one input file being compared.  
     /// </summary>
     internal class DiffData
     {
         /// <summary>Number of elements (lines).</summary>
         internal int Length;
 
         /// <summary>Buffer of numbers that will be compared.</summary>
         internal int[] data;
 
         /// <summary>
         /// Array of booleans that flag for modified data.
         /// This is the result of the diff.
         /// This means deletedA in the first Data or inserted in the second Data.
         /// </summary>
         internal bool[] modified;
 
         /// <summary>
         /// Initialize the Diff-Data buffer.
         /// </summary>
         /// <param name="data">reference to the buffer</param>
         internal DiffData (int[] initData)
         {
             data = initData;
             Length = initData.Length;
             modified = new bool[Length + 2];
         } // DiffData
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="32" endline="51"><![CDATA[
         private System.ComponentModel.Container components = null;
 
         /// <summary>
         /// Initialize the component with it's
         /// default settings.
         /// </summary>
         public VistaButton ()
         {
             InitializeComponent();
 
             this.SetStyle(ControlStyles.AllPaintingInWmPaint, true);
             this.SetStyle(ControlStyles.DoubleBuffer, true);
             this.SetStyle(ControlStyles.ResizeRedraw, true);
             this.SetStyle(ControlStyles.Selectable, true);
             this.SetStyle(ControlStyles.SupportsTransparentBackColor, true);
             this.SetStyle(ControlStyles.UserPaint, true);
             this.BackColor = Color.Transparent;
             mFadeIn.Interval = 30;
             mFadeOut.Interval = 30;
         }
 
         /// <summary>
         /// Release resources used by the control.
         /// </summary>
         protected override void Dispose (bool disposing)
         {
             if (disposing)
             {
                 if (components != null)
                 {
                     components.Dispose();
                 }
             }
             base.Dispose(disposing);
         }
 
         #region -  Component Designer generated code  -
 
         private void InitializeComponent ()
         {
             // 
             // VistaButton
             // 
             this.Name = "VistaButton";
             this.Size = new System.Drawing.Size(100, 32);
             this.Paint += new System.Windows.Forms.PaintEventHandler(this.VistaButton_Paint);
             this.KeyUp += new System.Windows.Forms.KeyEventHandler(this.VistaButton_KeyUp);
             this.KeyDown += new System.Windows.Forms.KeyEventHandler(this.VistaButton_KeyDown);
             this.MouseEnter += new System.EventHandler(this.VistaButton_MouseEnter);
             this.MouseLeave += new System.EventHandler(this.VistaButton_MouseLeave);
             this.MouseUp += new MouseEventHandler(VistaButton_MouseUp);
             this.MouseDown += new System.Windows.Forms.MouseEventHandler(this.VistaButton_MouseDown);
             //this.GotFocus += new EventHandler(VistaButton_MouseEnter);
             //this.LostFocus += new EventHandler(VistaButton_MouseLeave);
             this.mFadeIn.Tick += new EventHandler(mFadeIn_Tick);
             this.mFadeOut.Tick += new EventHandler(mFadeOut_Tick);
             this.Resize += new EventHandler(VistaButton_Resize);
         }
 
         #endregion
 
         #endregion
 
         #region -  Enums  -
 
         /// <summary>
         /// A private enumeration that determines 
         /// the mouse state in relation to the 
         /// current instance of the control.
         /// </summary>
         enum State { None, Hover, Pressed };
 
         /// <summary>
         /// A public enumeration that determines whether
         /// the button background is painted when the 
         /// mouse is not inside the ClientArea.
         /// </summary>
         public enum Style
         {
             /// <summary>
             /// Draw the button as normal
             /// </summary>
             Default,
             /// <summary>
             /// Only draw the background on mouse over.
             /// </summary>
             Flat
         };
 
         #endregion
 
         #region -  Properties  -
 
         #region -  Private Variables  -
 
         private bool calledbykey = false;
         private State mButtonState = State.None;
         private Timer mFadeIn = new Timer();
         private Timer mFadeOut = new Timer();
         private int mGlowAlpha = 0;
 
         #endregion
 
         #region -  Text  -
 
         private string mText;
         /// <summary>
         /// The text that is displayed on the button.
         /// </summary>
         [Category("Text"),
          Description("The text that is displayed on the button.")]
         public string ButtonText
         {
             get { return mText; }
             set { mText = value; this.Invalidate(); }
         }
 
         private Color mForeColor = Color.White;
         /// <summary>
         /// The color with which the text is drawn.
         /// </summary>
         [Category("Text"),
          Browsable(true),
          DefaultValue(typeof(Color), "White"),
          Description("The color with which the text is drawn.")]
         public override Color ForeColor
         {
             get { return mForeColor; }
             set { mForeColor = value; this.Invalidate(); }
         }
 
         private ContentAlignment mTextAlign = ContentAlignment.MiddleCenter;
         /// <summary>
         /// The alignment of the button text
         /// that is displayed on the control.
         /// </summary>
         [Category("Text"),
          DefaultValue(typeof(ContentAlignment), "MiddleCenter"),
          Description("The alignment of the button text " +
                      "that is displayed on the control.")]
         public ContentAlignment TextAlign
         {
             get { return mTextAlign; }
             set { mTextAlign = value; this.Invalidate(); }
         }
 
         #endregion
 
         #region -  Image  -
 
         private Image mImage;
         /// <summary>
         /// The image displayed on the button that 
         /// is used to help the user identify
         /// it's function if the text is ambiguous.
         /// </summary>
         [Category("Image"),
          DefaultValue(null),
          Description("The image displayed on the button that " +
                      "is used to help the user identify" +
                      "it's function if the text is ambiguous.")]
         public Image Image
         {
             get { return mImage; }
             set { mImage = value; this.Invalidate(); }
         }
 
         private ContentAlignment mImageAlign = ContentAlignment.MiddleLeft;
         /// <summary>
         /// The alignment of the image 
         /// in relation to the button.
         /// </summary>
         [Category("Image"),
          DefaultValue(typeof(ContentAlignment), "MiddleLeft"),
          Description("The alignment of the image " +
                      "in relation to the button.")]
         public ContentAlignment ImageAlign
         {
             get { return mImageAlign; }
             set { mImageAlign = value; this.Invalidate(); }
         }
 
         private Size mImageSize = new Size(24, 24);
         /// <summary>
         /// The size of the image to be displayed on the
         /// button. This property defaults to 24x24.
         /// </summary>
         [Category("Image"),
          DefaultValue(typeof(Size), "24, 24"),
          Description("The size of the image to be displayed on the" +
                      "button. This property defaults to 24x24.")]
         public Size ImageSize
         {
             get { return mImageSize; }
             set { mImageSize = value; this.Invalidate(); }
         }
 
         #endregion
 
         #region -  Appearance  -
 
         private Style mButtonStyle = Style.Default;
         /// <summary>
         /// Sets whether the button background is drawn 
         /// while the mouse is outside of the client area.
         /// </summary>
         [Category("Appearance"),
          DefaultValue(typeof(Style), "Default"),
          Description("Sets whether the button background is drawn " +
                      "while the mouse is outside of the client area.")]
         public Style ButtonStyle
         {
             get { return mButtonStyle; }
             set { mButtonStyle = value; this.Invalidate(); }
         }
 
         private int mCornerRadius = 8;
         /// <summary>
         /// The radius for the button corners. The 
         /// greater this value is, the more 'smooth' 
         /// the corners are. This property should
         ///  not be greater than half of the 
         ///  controls height.
         /// </summary>
         [Category("Appearance"),
          DefaultValue(8),
          Description("The radius for the button corners. The " +
                      "greater this value is, the more 'smooth' " +
                      "the corners are. This property should " +
                      "not be greater than half of the " +
                      "controls height.")]
         public int CornerRadius
         {
             get { return mCornerRadius; }
             set { mCornerRadius = value; this.Invalidate(); }
         }
 
         private Color mHighlightColor = Color.White;
         /// <summary>
         /// The colour of the highlight on the top of the button.
         /// </summary>
         [Category("Appearance"),
          DefaultValue(typeof(Color), "White"),
          Description("The colour of the highlight on the top of the button.")]
         public Color HighlightColor
         {
             get { return mHighlightColor; }
             set { mHighlightColor = value; this.Invalidate(); }
         }
 
         private Color mButtonColor = Color.Black;
         /// <summary>
         /// The bottom color of the button that 
         /// will be drawn over the base color.
         /// </summary>
         [Category("Appearance"),
          DefaultValue(typeof(Color), "Black"),
          Description("The bottom color of the button that " +
                      "will be drawn over the base color.")]
         public Color ButtonColor
         {
             get { return mButtonColor; }
             set { mButtonColor = value; this.Invalidate(); }
         }
 
         private Color mGlowColor = Color.FromArgb(141, 189, 255);
         /// <summary>
         /// The colour that the button glows when
         /// the mouse is inside the client area.
         /// </summary>
         [Category("Appearance"),
          DefaultValue(typeof(Color), "141,189,255"),
          Description("The colour that the button glows when " +
                      "the mouse is inside the client area.")]
         public Color GlowColor
         {
             get { return mGlowColor; }
             set { mGlowColor = value; this.Invalidate(); }
         }
 
         private Image mBackImage;
         /// <summary>
         /// The background image for the button, 
         /// this image is drawn over the base 
         /// color of the button.
         /// </summary>
         [Category("Appearance"),
          DefaultValue(null),
          Description("The background image for the button, " +
                      "this image is drawn over the base " +
                      "color of the button.")]
         public Image BackImage
         {
             get { return mBackImage; }
             set { mBackImage = value; this.Invalidate(); }
         }
 
         private Color mBaseColor = Color.Black;
         public VistaButton ()
         {
             InitializeComponent();
 
             this.SetStyle(ControlStyles.AllPaintingInWmPaint, true);
             this.SetStyle(ControlStyles.DoubleBuffer, true);
             this.SetStyle(ControlStyles.ResizeRedraw, true);
             this.SetStyle(ControlStyles.Selectable, true);
             this.SetStyle(ControlStyles.SupportsTransparentBackColor, true);
             this.SetStyle(ControlStyles.UserPaint, true);
             this.BackColor = Color.Transparent;
             mFadeIn.Interval = 30;
             mFadeOut.Interval = 30;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="52" endline="66"><![CDATA[
 
         /// <summary>
         /// Release resources used by the control.
         /// </summary>
         protected override void Dispose (bool disposing)
         {
             if (disposing)
             {
                 if (components != null)
                 {
                     components.Dispose();
                 }
             }
             base.Dispose(disposing);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="67" endline="89"><![CDATA[
 
         #region -  Component Designer generated code  -
 
         private void InitializeComponent ()
         {
             // 
             // VistaButton
             // 
             this.Name = "VistaButton";
             this.Size = new System.Drawing.Size(100, 32);
             this.Paint += new System.Windows.Forms.PaintEventHandler(this.VistaButton_Paint);
             this.KeyUp += new System.Windows.Forms.KeyEventHandler(this.VistaButton_KeyUp);
             this.KeyDown += new System.Windows.Forms.KeyEventHandler(this.VistaButton_KeyDown);
             this.MouseEnter += new System.EventHandler(this.VistaButton_MouseEnter);
             this.MouseLeave += new System.EventHandler(this.VistaButton_MouseLeave);
             this.MouseUp += new MouseEventHandler(VistaButton_MouseUp);
             this.MouseDown += new System.Windows.Forms.MouseEventHandler(this.VistaButton_MouseDown);
             //this.GotFocus += new EventHandler(VistaButton_MouseEnter);
             //this.LostFocus += new EventHandler(VistaButton_MouseLeave);
             this.mFadeIn.Tick += new EventHandler(mFadeIn_Tick);
             this.mFadeOut.Tick += new EventHandler(mFadeOut_Tick);
             this.Resize += new EventHandler(VistaButton_Resize);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="90" endline="145"><![CDATA[
 
         #endregion
 
         #endregion
 
         #region -  Enums  -
 
         /// <summary>
         /// A private enumeration that determines 
         /// the mouse state in relation to the 
         /// current instance of the control.
         /// </summary>
         enum State { None, Hover, Pressed };
 
         /// <summary>
         /// A public enumeration that determines whether
         /// the button background is painted when the 
         /// mouse is not inside the ClientArea.
         /// </summary>
         public enum Style
         {
             /// <summary>
             /// Draw the button as normal
             /// </summary>
             Default,
             /// <summary>
             /// Only draw the background on mouse over.
             /// </summary>
             Flat
         };
 
         #endregion
 
         #region -  Properties  -
 
         #region -  Private Variables  -
 
         private bool calledbykey = false;
         private State mButtonState = State.None;
         private Timer mFadeIn = new Timer();
         private Timer mFadeOut = new Timer();
         private int mGlowAlpha = 0;
 
         #endregion
 
         #region -  Text  -
 
         private string mText;
         /// <summary>
         /// The text that is displayed on the button.
         /// </summary>
         [Category("Text"),
          Description("The text that is displayed on the button.")]
         public string ButtonText
         {
             get { return mText; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="146" endline="146"><![CDATA[
             set { mText = value; this.Invalidate(); }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="147" endline="159"><![CDATA[
         }
 
         private Color mForeColor = Color.White;
         /// <summary>
         /// The color with which the text is drawn.
         /// </summary>
         [Category("Text"),
          Browsable(true),
          DefaultValue(typeof(Color), "White"),
          Description("The color with which the text is drawn.")]
         public override Color ForeColor
         {
             get { return mForeColor; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="160" endline="160"><![CDATA[
             set { mForeColor = value; this.Invalidate(); }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="161" endline="174"><![CDATA[
         }
 
         private ContentAlignment mTextAlign = ContentAlignment.MiddleCenter;
         /// <summary>
         /// The alignment of the button text
         /// that is displayed on the control.
         /// </summary>
         [Category("Text"),
          DefaultValue(typeof(ContentAlignment), "MiddleCenter"),
          Description("The alignment of the button text " +
                      "that is displayed on the control.")]
         public ContentAlignment TextAlign
         {
             get { return mTextAlign; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="175" endline="175"><![CDATA[
             set { mTextAlign = value; this.Invalidate(); }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="176" endline="195"><![CDATA[
         }
 
         #endregion
 
         #region -  Image  -
 
         private Image mImage;
         /// <summary>
         /// The image displayed on the button that 
         /// is used to help the user identify
         /// it's function if the text is ambiguous.
         /// </summary>
         [Category("Image"),
          DefaultValue(null),
          Description("The image displayed on the button that " +
                      "is used to help the user identify" +
                      "it's function if the text is ambiguous.")]
         public Image Image
         {
             get { return mImage; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="196" endline="196"><![CDATA[
             set { mImage = value; this.Invalidate(); }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="197" endline="210"><![CDATA[
         }
 
         private ContentAlignment mImageAlign = ContentAlignment.MiddleLeft;
         /// <summary>
         /// The alignment of the image 
         /// in relation to the button.
         /// </summary>
         [Category("Image"),
          DefaultValue(typeof(ContentAlignment), "MiddleLeft"),
          Description("The alignment of the image " +
                      "in relation to the button.")]
         public ContentAlignment ImageAlign
         {
             get { return mImageAlign; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="211" endline="211"><![CDATA[
             set { mImageAlign = value; this.Invalidate(); }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="212" endline="225"><![CDATA[
         }
 
         private Size mImageSize = new Size(24, 24);
         /// <summary>
         /// The size of the image to be displayed on the
         /// button. This property defaults to 24x24.
         /// </summary>
         [Category("Image"),
          DefaultValue(typeof(Size), "24, 24"),
          Description("The size of the image to be displayed on the" +
                      "button. This property defaults to 24x24.")]
         public Size ImageSize
         {
             get { return mImageSize; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="226" endline="226"><![CDATA[
             set { mImageSize = value; this.Invalidate(); }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="227" endline="244"><![CDATA[
         }
 
         #endregion
 
         #region -  Appearance  -
 
         private Style mButtonStyle = Style.Default;
         /// <summary>
         /// Sets whether the button background is drawn 
         /// while the mouse is outside of the client area.
         /// </summary>
         [Category("Appearance"),
          DefaultValue(typeof(Style), "Default"),
          Description("Sets whether the button background is drawn " +
                      "while the mouse is outside of the client area.")]
         public Style ButtonStyle
         {
             get { return mButtonStyle; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="245" endline="245"><![CDATA[
             set { mButtonStyle = value; this.Invalidate(); }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="246" endline="265"><![CDATA[
         }
 
         private int mCornerRadius = 8;
         /// <summary>
         /// The radius for the button corners. The 
         /// greater this value is, the more 'smooth' 
         /// the corners are. This property should
         ///  not be greater than half of the 
         ///  controls height.
         /// </summary>
         [Category("Appearance"),
          DefaultValue(8),
          Description("The radius for the button corners. The " +
                      "greater this value is, the more 'smooth' " +
                      "the corners are. This property should " +
                      "not be greater than half of the " +
                      "controls height.")]
         public int CornerRadius
         {
             get { return mCornerRadius; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="266" endline="266"><![CDATA[
             set { mCornerRadius = value; this.Invalidate(); }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="267" endline="278"><![CDATA[
         }
 
         private Color mHighlightColor = Color.White;
         /// <summary>
         /// The colour of the highlight on the top of the button.
         /// </summary>
         [Category("Appearance"),
          DefaultValue(typeof(Color), "White"),
          Description("The colour of the highlight on the top of the button.")]
         public Color HighlightColor
         {
             get { return mHighlightColor; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="279" endline="279"><![CDATA[
             set { mHighlightColor = value; this.Invalidate(); }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="280" endline="293"><![CDATA[
         }
 
         private Color mButtonColor = Color.Black;
         /// <summary>
         /// The bottom color of the button that 
         /// will be drawn over the base color.
         /// </summary>
         [Category("Appearance"),
          DefaultValue(typeof(Color), "Black"),
          Description("The bottom color of the button that " +
                      "will be drawn over the base color.")]
         public Color ButtonColor
         {
             get { return mButtonColor; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="294" endline="294"><![CDATA[
             set { mButtonColor = value; this.Invalidate(); }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="295" endline="308"><![CDATA[
         }
 
         private Color mGlowColor = Color.FromArgb(141, 189, 255);
         /// <summary>
         /// The colour that the button glows when
         /// the mouse is inside the client area.
         /// </summary>
         [Category("Appearance"),
          DefaultValue(typeof(Color), "141,189,255"),
          Description("The colour that the button glows when " +
                      "the mouse is inside the client area.")]
         public Color GlowColor
         {
             get { return mGlowColor; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="309" endline="309"><![CDATA[
             set { mGlowColor = value; this.Invalidate(); }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="310" endline="325"><![CDATA[
         }
 
         private Image mBackImage;
         /// <summary>
         /// The background image for the button, 
         /// this image is drawn over the base 
         /// color of the button.
         /// </summary>
         [Category("Appearance"),
          DefaultValue(null),
          Description("The background image for the button, " +
                      "this image is drawn over the base " +
                      "color of the button.")]
         public Image BackImage
         {
             get { return mBackImage; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="326" endline="326"><![CDATA[
             set { mBackImage = value; this.Invalidate(); }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="327" endline="342"><![CDATA[
         }
 
         private Color mBaseColor = Color.Black;
         /// <summary>
         /// The backing color that the rest of 
         /// the button is drawn. For a glassier 
         /// effect set this property to Transparent.
         /// </summary>
         [Category("Appearance"),
          DefaultValue(typeof(Color), "Black"),
          Description("The backing color that the rest of" +
                      "the button is drawn. For a glassier " +
                      "effect set this property to Transparent.")]
         public Color BaseColor
         {
             get { return mBaseColor; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="343" endline="343"><![CDATA[
             set { mBaseColor = value; this.Invalidate(); }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="344" endline="365"><![CDATA[
         }
 
         #endregion
 
         #endregion
 
         #region -  Functions  -
 
         private GraphicsPath RoundRect (RectangleF r, float r1, float r2, float r3, float r4)
         {
             float x = r.X, y = r.Y, w = r.Width, h = r.Height;
             GraphicsPath rr = new GraphicsPath();
             rr.AddBezier(x, y + r1, x, y, x + r1, y, x + r1, y);
             rr.AddLine(x + r1, y, x + w - r2, y);
             rr.AddBezier(x + w - r2, y, x + w, y, x + w, y + r2, x + w, y + r2);
             rr.AddLine(x + w, y + r2, x + w, y + h - r3);
             rr.AddBezier(x + w, y + h - r3, x + w, y + h, x + w - r3, y + h, x + w - r3, y + h);
             rr.AddLine(x + w - r3, y + h, x + r4, y + h);
             rr.AddBezier(x + r4, y + h, x, y + h, x, y + h - r4, x, y + h - r4);
             rr.AddLine(x, y + h - r4, x, y + r1);
             return rr;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="366" endline="390"><![CDATA[
 
 
 
         #endregion
 
         #region -  Drawing  -
 
         /// <summary>
         /// Draws the outer border for the control
         /// using the ButtonColor property.
         /// </summary>
         /// <param name="g">The graphics object used in the paint event.</param>
         private void DrawOuterStroke (Graphics g)
         {
             if (this.ButtonStyle == Style.Flat && this.mButtonState == State.None) { return; }
             Rectangle r = this.ClientRectangle;
             r.Width -= 1; r.Height -= 1;
             using (GraphicsPath rr = RoundRect(r, CornerRadius, CornerRadius, CornerRadius, CornerRadius))
             {
                 using (Pen p = new Pen(this.ButtonColor))
                 {
                     g.DrawPath(p, rr);
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="391" endline="410"><![CDATA[
 
         /// <summary>
         /// Draws the inner border for the control
         /// using the HighlightColor property.
         /// </summary>
         /// <param name="g">The graphics object used in the paint event.</param>
         private void DrawInnerStroke (Graphics g)
         {
             if (this.ButtonStyle == Style.Flat && this.mButtonState == State.None) { return; }
             Rectangle r = this.ClientRectangle;
             r.X++; r.Y++;
             r.Width -= 3; r.Height -= 3;
             using (GraphicsPath rr = RoundRect(r, CornerRadius, CornerRadius, CornerRadius, CornerRadius))
             {
                 using (Pen p = new Pen(this.HighlightColor))
                 {
                     g.DrawPath(p, rr);
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="411" endline="442"><![CDATA[
 
         /// <summary>
         /// Draws the background for the control
         /// using the background image and the 
         /// BaseColor.
         /// </summary>
         /// <param name="g">The graphics object used in the paint event.</param>
         private void DrawBackground (Graphics g)
         {
             if (this.ButtonStyle == Style.Flat && this.mButtonState == State.None) { return; }
             int alpha = (mButtonState == State.Pressed) ? 204 
             Rectangle r = this.ClientRectangle;
             r.Width--; r.Height--;
             using (GraphicsPath rr = RoundRect(r, CornerRadius, CornerRadius, CornerRadius, CornerRadius))
             {
                 using (SolidBrush sb = new SolidBrush(this.BaseColor))
                 {
                     g.FillPath(sb, rr);
                 }
                 SetClip(g);
                 if (this.BackImage != null)
                 {
                     g.DrawImage(this.BackImage, new Rectangle((this.Width / 2) - (this.BackImage.Width / 2),
                         (this.Height / 2) - (this.BackImage.Height / 2), this.BackImage.Width, this.BackImage.Height));
                 }
                 g.ResetClip();
                 using (SolidBrush sb = new SolidBrush(Color.FromArgb(alpha, this.ButtonColor)))
                 {
                     g.FillPath(sb, rr);
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="443" endline="464"><![CDATA[
 
         /// <summary>
         /// Draws the Highlight over the top of the
         /// control using the HightlightColor.
         /// </summary>
         /// <param name="g">The graphics object used in the paint event.</param>
         private void DrawHighlight (Graphics g)
         {
             if (this.ButtonStyle == Style.Flat && this.mButtonState == State.None) { return; }
             int alpha = (mButtonState == State.Pressed) ? 60 
             Rectangle rect = new Rectangle(0, 0, this.Width, this.Height / 2);
             using (GraphicsPath r = RoundRect(rect, CornerRadius, CornerRadius, 0, 0))
             {
                 using (LinearGradientBrush lg = new LinearGradientBrush(r.GetBounds(),
                                             Color.FromArgb(alpha, this.HighlightColor),
                                             Color.FromArgb(alpha / 3, this.HighlightColor),
                                             LinearGradientMode.Vertical))
                 {
                     g.FillPath(lg, r);
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="465" endline="487"><![CDATA[
 
         /// <summary>
         /// Draws the glow for the button when the
         /// mouse is inside the client area using
         /// the GlowColor property.
         /// </summary>
         /// <param name="g">The graphics object used in the paint event.</param>
         private void DrawGlow (Graphics g)
         {
             if (this.mButtonState == State.Pressed) { return; }
             SetClip(g);
             using (GraphicsPath glow = new GraphicsPath())
             {
                 glow.AddEllipse(-5, this.Height / 2 - 10, this.Width + 11, this.Height + 11);
                 using (PathGradientBrush gl = new PathGradientBrush(glow))
                 {
                     gl.CenterColor = Color.FromArgb(mGlowAlpha, this.GlowColor);
                     gl.SurroundColors = new Color[] { Color.FromArgb(0, this.GlowColor) };
                     g.FillPath(gl, glow);
                 }
             }
             g.ResetClip();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="488" endline="498"><![CDATA[
 
         /// <summary>
         /// Draws the text for the button.
         /// </summary>
         /// <param name="g">The graphics object used in the paint event.</param>
         private void DrawText (Graphics g)
         {
             StringFormat sf = Common.StringFormatAlignment(this.TextAlign);
             Rectangle r = new Rectangle(8, 8, this.Width - 17, this.Height - 17);
             g.DrawString(this.ButtonText, this.Font, new SolidBrush(this.ForeColor), r, sf);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="499" endline="536"><![CDATA[
 
         /// <summary>
         /// Draws the image for the button
         /// </summary>
         /// <param name="g">The graphics object used in the paint event.</param>
         private void DrawImage (Graphics g)
         {
             if (this.Image == null) { return; }
             Rectangle r = new Rectangle(8, 8, this.ImageSize.Width, this.ImageSize.Height);
             switch (this.ImageAlign)
             {
                 case ContentAlignment.TopCenter
                     r = new Rectangle(this.Width / 2 - this.ImageSize.Width / 2, 8, this.ImageSize.Width, this.ImageSize.Height);
                     break;
                 case ContentAlignment.TopRight
                     r = new Rectangle(this.Width - 8 - this.ImageSize.Width, 8, this.ImageSize.Width, this.ImageSize.Height);
                     break;
                 case ContentAlignment.MiddleLeft
                     r = new Rectangle(8, this.Height / 2 - this.ImageSize.Height / 2, this.ImageSize.Width, this.ImageSize.Height);
                     break;
                 case ContentAlignment.MiddleCenter
                     r = new Rectangle(this.Width / 2 - this.ImageSize.Width / 2, this.Height / 2 - this.ImageSize.Height / 2, this.ImageSize.Width, this.ImageSize.Height);
                     break;
                 case ContentAlignment.MiddleRight
                     r = new Rectangle(this.Width - 8 - this.ImageSize.Width, this.Height / 2 - this.ImageSize.Height / 2, this.ImageSize.Width, this.ImageSize.Height);
                     break;
                 case ContentAlignment.BottomLeft
                     r = new Rectangle(8, this.Height - 8 - this.ImageSize.Height, this.ImageSize.Width, this.ImageSize.Height);
                     break;
                 case ContentAlignment.BottomCenter
                     r = new Rectangle(this.Width / 2 - this.ImageSize.Width / 2, this.Height - 8 - this.ImageSize.Height, this.ImageSize.Width, this.ImageSize.Height);
                     break;
                 case ContentAlignment.BottomRight
                     r = new Rectangle(this.Width - 8 - this.ImageSize.Width, this.Height - 8 - this.ImageSize.Height, this.ImageSize.Width, this.ImageSize.Height);
                     break;
             }
             g.DrawImage(this.Image, r);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="537" endline="546"><![CDATA[
 
         private void SetClip (Graphics g)
         {
             Rectangle r = this.ClientRectangle;
             r.X++; r.Y++; r.Width -= 3; r.Height -= 3;
             using (GraphicsPath rr = RoundRect(r, CornerRadius, CornerRadius, CornerRadius, CornerRadius))
             {
                 g.SetClip(rr);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="547" endline="563"><![CDATA[
 
         #endregion
 
         #region -  Private Subs  -
 
         private void VistaButton_Paint (object sender, PaintEventArgs e)
         {
             e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;
             e.Graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
             DrawBackground(e.Graphics);
             DrawHighlight(e.Graphics);
             DrawImage(e.Graphics);
             DrawGlow(e.Graphics);
             DrawOuterStroke(e.Graphics);
             DrawInnerStroke(e.Graphics);
             DrawText(e.Graphics);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="564" endline="574"><![CDATA[
 
         private void VistaButton_Resize (object sender, EventArgs e)
         {
             Rectangle r = this.ClientRectangle;
             r.X -= 1; r.Y -= 1;
             r.Width += 2; r.Height += 2;
             using (GraphicsPath rr = RoundRect(r, CornerRadius, CornerRadius, CornerRadius, CornerRadius))
             {
                 this.Region = new Region(rr);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="575" endline="583"><![CDATA[
 
         #region -  Mouse and Keyboard Events  -
 
         private void VistaButton_MouseEnter (object sender, EventArgs e)
         {
             mButtonState = State.Hover;
             mFadeOut.Stop();
             mFadeIn.Start();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="584" endline="590"><![CDATA[
         private void VistaButton_MouseLeave (object sender, EventArgs e)
         {
             mButtonState = State.None;
             if (this.mButtonStyle == Style.Flat) { mGlowAlpha = 0; }
             mFadeIn.Stop();
             mFadeOut.Start();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="591" endline="602"><![CDATA[
 
         private void VistaButton_MouseDown (object sender, MouseEventArgs e)
         {
             if (e.Button == MouseButtons.Left)
             {
                 mButtonState = State.Pressed;
                 if (this.mButtonStyle != Style.Flat) { mGlowAlpha = 255; }
                 mFadeIn.Stop();
                 mFadeOut.Stop();
                 this.Invalidate();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="603" endline="617"><![CDATA[
 
         private void mFadeIn_Tick (object sender, EventArgs e)
         {
             if (this.ButtonStyle == Style.Flat) { mGlowAlpha = 0; }
             if (mGlowAlpha + 30 >= 255)
             {
                 mGlowAlpha = 255;
                 mFadeIn.Stop();
             }
             else
             {
                 mGlowAlpha += 30;
             }
             this.Invalidate();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="618" endline="632"><![CDATA[
 
         private void mFadeOut_Tick (object sender, EventArgs e)
         {
             if (this.ButtonStyle == Style.Flat) { mGlowAlpha = 0; }
             if (mGlowAlpha - 30 <= 0)
             {
                 mGlowAlpha = 0;
                 mFadeOut.Stop();
             }
             else
             {
                 mGlowAlpha -= 30;
             }
             this.Invalidate();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="633" endline="641"><![CDATA[
 
         private void VistaButton_KeyDown (object sender, KeyEventArgs e)
         {
             if (e.KeyCode == Keys.Space)
             {
                 MouseEventArgs m = new MouseEventArgs(MouseButtons.Left, 0, 0, 0, 0);
                 VistaButton_MouseDown(sender, m);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="642" endline="651"><![CDATA[
 
         private void VistaButton_KeyUp (object sender, KeyEventArgs e)
         {
             if (e.KeyCode == Keys.Space)
             {
                 MouseEventArgs m = new MouseEventArgs(MouseButtons.Left, 0, 0, 0, 0);
                 calledbykey = true;
                 VistaButton_MouseUp(sender, m);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Controls\VistaButton.cs" startline="652" endline="663"><![CDATA[
 
         private void VistaButton_MouseUp (object sender, MouseEventArgs e)
         {
             if (e.Button == MouseButtons.Left)
             {
                 mButtonState = State.Hover;
                 mFadeIn.Stop();
                 mFadeOut.Stop();
                 this.Invalidate();
                 if (calledbykey == true) { this.OnClick(EventArgs.Empty); calledbykey = false; }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="41" endline="44"><![CDATA[
         public cShellContextMenu()
         {
             this.CreateHandle(new CreateParams());
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="45" endline="52"><![CDATA[
         #endregion
 
         #region Destructor
         /// <summary>Ensure all resources get released</summary>
         ~cShellContextMenu()
         {
             ReleaseAll();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="53" endline="93"><![CDATA[
         #endregion
 
         #region GetContextMenuInterfaces()
         /// <summary>Gets the interfaces to the context menu</summary>
         /// <param name="oParentFolder">Parent folder</param>
         /// <param name="arrPIDLs">PIDLs</param>
         /// <returns>true if it got the interfaces, otherwise false</returns>
         private bool GetContextMenuInterfaces(IShellFolder oParentFolder, IntPtr[] arrPIDLs, out IntPtr ctxMenuPtr)
         {
             int nResult = oParentFolder.GetUIObjectOf(
                 IntPtr.Zero,
                 (uint)arrPIDLs.Length,
                 arrPIDLs,
                 ref IID_IContextMenu,
                 IntPtr.Zero,
                 out ctxMenuPtr);
 
             if (S_OK == nResult)
             {
                 _oContextMenu = (IContextMenu)Marshal.GetTypedObjectForIUnknown(ctxMenuPtr, typeof(IContextMenu));
 
                 /*IntPtr pUnknownContextMenu2 = IntPtr.Zero;
                 if (S_OK == Marshal.QueryInterface(pUnknownContextMenu, ref IID_IContextMenu2, out pUnknownContextMenu2))
                 {
                     _oContextMenu2 = (IContextMenu2)Marshal.GetTypedObjectForIUnknown(pUnknownContextMenu2, typeof(IContextMenu2));
                 }
                 IntPtr pUnknownContextMenu3 = IntPtr.Zero;
                 if (S_OK == Marshal.QueryInterface(pUnknownContextMenu, ref IID_IContextMenu3, out pUnknownContextMenu3))
                 {
                     _oContextMenu3 = (IContextMenu3)Marshal.GetTypedObjectForIUnknown(pUnknownContextMenu3, typeof(IContextMenu3));
                 }*/
 
                 return true;
             }
             else
             {
                 ctxMenuPtr = IntPtr.Zero;
                 _oContextMenu = null;
                 return false;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="94" endline="158"><![CDATA[
         #endregion
 
         #region Override
 
         /// <summary>
         /// This method receives WindowMessages. It will make the "Open With" and "Send To" work 
         /// by calling HandleMenuMsg and HandleMenuMsg2. It will also call the OnContextMenuMouseHover 
         /// method of Browser when hovering over a ContextMenu item.
         /// </summary>
         /// <param name="m">the Message of the Browser's WndProc</param>
         /// <returns>true if the message has been handled, false otherwise</returns>
         protected override void WndProc(ref Message m)
         {
             #region IContextMenu
 
             if (_oContextMenu != null &&
                 m.Msg == (int)WM.MENUSELECT &&
                 ((int)ShellHelper.HiWord(m.WParam) & (int)MFT.SEPARATOR) == 0 &&
                 ((int)ShellHelper.HiWord(m.WParam) & (int)MFT.POPUP) == 0)
             {
                 string info = string.Empty;
 
                 if (ShellHelper.LoWord(m.WParam) == (int)CMD_CUSTOM.ExpandCollapse)
                     info = "Expands or collapses the current selected item";
                 else
                 {
                     info = "";/* ContextMenuHelper.GetCommandString(
                          _oContextMenu,
                          ShellHelper.LoWord(m.WParam) - CMD_FIRST,
                          false);*/
                 }
 
                 //br.OnContextMenuMouseHover(new ContextMenuMouseHoverEventArgs(info.ToString()));
             }
 
             #endregion
 
             #region IContextMenu2
 
             if (_oContextMenu2 != null &&
                 (m.Msg == (int)WM.INITMENUPOPUP ||
                  m.Msg == (int)WM.MEASUREITEM ||
                  m.Msg == (int)WM.DRAWITEM))
             {
                 if (_oContextMenu2.HandleMenuMsg(
                     (uint)m.Msg, m.WParam, m.LParam) == S_OK)
                     return;
             }
 
             #endregion
 
             #region IContextMenu3
 
             if (_oContextMenu3 != null &&
                 m.Msg == (int)WM.MENUCHAR)
             {
                 if (_oContextMenu3.HandleMenuMsg2(
                     (uint)m.Msg, m.WParam, m.LParam, IntPtr.Zero) == S_OK)
                     return;
             }
 
             #endregion
 
             base.WndProc(ref m);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="159" endline="178"><![CDATA[
 
         #endregion
 
         #region InvokeCommand
         private void InvokeCommand(IContextMenu oContextMenu, uint nCmd, string strFolder, Point pointInvoke)
         {
             CMINVOKECOMMANDINFOEX invoke = new CMINVOKECOMMANDINFOEX();
             invoke.cbSize = cbInvokeCommand;
             invoke.lpVerb = (IntPtr)(nCmd - CMD_FIRST);
             invoke.lpDirectory = strFolder;
             invoke.lpVerbW = (IntPtr)(nCmd - CMD_FIRST);
             invoke.lpDirectoryW = strFolder;
             invoke.fMask = CMIC.UNICODE | CMIC.PTINVOKE |
                 ((Control.ModifierKeys & Keys.Control) != 0 ? CMIC.CONTROL_DOWN 
                 ((Control.ModifierKeys & Keys.Shift) != 0 ? CMIC.SHIFT_DOWN 
             invoke.ptInvoke = new POINT(pointInvoke.X, pointInvoke.Y);
             invoke.nShow = SW.SHOWNORMAL;
 
             oContextMenu.InvokeCommand(ref invoke);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="179" endline="217"><![CDATA[
         #endregion
 
         #region ReleaseAll()
         /// <summary>
         /// Release all allocated interfaces, PIDLs 
         /// </summary>
         private void ReleaseAll()
         {
             if (null != _oContextMenu)
             {
                 Marshal.ReleaseComObject(_oContextMenu);
                 _oContextMenu = null;
             }
             if (null != _oContextMenu2)
             {
                 Marshal.ReleaseComObject(_oContextMenu2);
                 _oContextMenu2 = null;
             }
             if (null != _oContextMenu3)
             {
                 Marshal.ReleaseComObject(_oContextMenu3);
                 _oContextMenu3 = null;
             }
             if (null != _oDesktopFolder)
             {
                 Marshal.ReleaseComObject(_oDesktopFolder);
                 _oDesktopFolder = null;
             }
             if (null != _oParentFolder)
             {
                 Marshal.ReleaseComObject(_oParentFolder);
                 _oParentFolder = null;
             }
             if (null != _arrPIDLs)
             {
                 FreePIDLs(_arrPIDLs);
                 _arrPIDLs = null;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="218" endline="241"><![CDATA[
         #endregion
 
         #region GetDesktopFolder()
         /// <summary>
         /// Gets the desktop folder
         /// </summary>
         /// <returns>IShellFolder for desktop folder</returns>
         private IShellFolder GetDesktopFolder()
         {
             IntPtr pUnkownDesktopFolder = IntPtr.Zero;
 
             if (null == _oDesktopFolder)
             {
                 // Get desktop IShellFolder
                 int nResult = SHGetDesktopFolder(out pUnkownDesktopFolder);
                 if (S_OK != nResult)
                 {
                     throw new ShellContextMenuException("Failed to get the desktop shell folder");
                 }
                 _oDesktopFolder = (IShellFolder)Marshal.GetTypedObjectForIUnknown(pUnkownDesktopFolder, typeof(IShellFolder));
             }
 
             return _oDesktopFolder;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="242" endline="292"><![CDATA[
         #endregion
 
         #region GetParentFolder()
         /// <summary>
         /// Gets the parent folder
         /// </summary>
         /// <param name="folderName">Folder path</param>
         /// <returns>IShellFolder for the folder (relative from the desktop)</returns>
         private IShellFolder GetParentFolder(string folderName)
         {
             if (null == _oParentFolder)
             {
                 IShellFolder oDesktopFolder = GetDesktopFolder();
                 if (null == oDesktopFolder)
                 {
                     return null;
                 }
 
                 // Get the PIDL for the folder file is in
                 IntPtr pPIDL = IntPtr.Zero;
                 uint pchEaten = 0;
                 SFGAO pdwAttributes = 0;
                 int nResult = oDesktopFolder.ParseDisplayName(IntPtr.Zero, IntPtr.Zero, folderName, ref pchEaten, out pPIDL, ref pdwAttributes);
                 if (S_OK != nResult)
                 {
                     return null;
                 }
 
                 IntPtr pStrRet = Marshal.AllocCoTaskMem(MAX_PATH * 2 + 4);
                 Marshal.WriteInt32(pStrRet, 0, 0);
                 nResult = _oDesktopFolder.GetDisplayNameOf(pPIDL, SHGNO.FORPARSING, pStrRet);
                 StringBuilder strFolder = new StringBuilder(MAX_PATH);
                 StrRetToBuf(pStrRet, pPIDL, strFolder, MAX_PATH);
                 Marshal.FreeCoTaskMem(pStrRet);
                 pStrRet = IntPtr.Zero;
                 _strParentFolder = strFolder.ToString();
 
                 // Get the IShellFolder for folder
                 IntPtr pUnknownParentFolder = IntPtr.Zero;
                 nResult = oDesktopFolder.BindToObject(pPIDL, IntPtr.Zero, ref IID_IShellFolder, out pUnknownParentFolder);
                 // Free the PIDL first
                 Marshal.FreeCoTaskMem(pPIDL);
                 if (S_OK != nResult)
                 {
                     return null;
                 }
                 _oParentFolder = (IShellFolder)Marshal.GetTypedObjectForIUnknown(pUnknownParentFolder, typeof(IShellFolder));
             }
 
             return _oParentFolder;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="293" endline="333"><![CDATA[
         #endregion
 
         #region GetPIDLs()
         /// <summary>
         /// Get the PIDLs
         /// </summary>
         /// <param name="arrFI">Array of FileInfo</param>
         /// <returns>Array of PIDLs</returns>
         protected IntPtr[] GetPIDLs(FileInfo[] arrFI)
         {
             if (null == arrFI || 0 == arrFI.Length)
             {
                 return null;
             }
 
             IShellFolder oParentFolder = GetParentFolder(arrFI[0].DirectoryName);
             if (null == oParentFolder)
             {
                 return null;
             }
 
             IntPtr[] arrPIDLs = new IntPtr[arrFI.Length];
             int n = 0;
             foreach (FileInfo fi in arrFI)
             {
                 // Get the file relative to folder
                 uint pchEaten = 0;
                 SFGAO pdwAttributes = 0;
                 IntPtr pPIDL = IntPtr.Zero;
                 int nResult = oParentFolder.ParseDisplayName(IntPtr.Zero, IntPtr.Zero, fi.Name, ref pchEaten, out pPIDL, ref pdwAttributes);
                 if (S_OK != nResult)
                 {
                     FreePIDLs(arrPIDLs);
                     return null;
                 }
                 arrPIDLs[n] = pPIDL;
                 n++;
             }
             foreach (FileInfo fi in arrFI)
             {
                 // Get the file relative to folder
                 uint pchEaten = 0;
                 SFGAO pdwAttributes = 0;
                 IntPtr pPIDL = IntPtr.Zero;
                 int nResult = oParentFolder.ParseDisplayName(IntPtr.Zero, IntPtr.Zero, fi.Name, ref pchEaten, out pPIDL, ref pdwAttributes);
                 if (S_OK != nResult)
                 {
                     FreePIDLs(arrPIDLs);
                     return null;
                 }
                 arrPIDLs[n] = pPIDL;
                 n++;
             }
 
             return arrPIDLs;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="334" endline="372"><![CDATA[
 
         /// <summary>
         /// Get the PIDLs
         /// </summary>
         /// <param name="arrFI">Array of DirectoryInfo</param>
         /// <returns>Array of PIDLs</returns>
         protected IntPtr[] GetPIDLs(DirectoryInfo[] arrFI)
         {
             if (null == arrFI || 0 == arrFI.Length)
             {
                 return null;
             }
 
             IShellFolder oParentFolder = GetParentFolder(arrFI[0].Parent.FullName);
             if (null == oParentFolder)
             {
                 return null;
             }
 
             IntPtr[] arrPIDLs = new IntPtr[arrFI.Length];
             int n = 0;
             foreach (DirectoryInfo fi in arrFI)
             {
                 // Get the file relative to folder
                 uint pchEaten = 0;
                 SFGAO pdwAttributes = 0;
                 IntPtr pPIDL = IntPtr.Zero;
                 int nResult = oParentFolder.ParseDisplayName(IntPtr.Zero, IntPtr.Zero, fi.Name, ref pchEaten, out pPIDL, ref pdwAttributes);
                 if (S_OK != nResult)
                 {
                     FreePIDLs(arrPIDLs);
                     return null;
                 }
                 arrPIDLs[n] = pPIDL;
                 n++;
             }
             foreach (DirectoryInfo fi in arrFI)
             {
                 // Get the file relative to folder
                 uint pchEaten = 0;
                 SFGAO pdwAttributes = 0;
                 IntPtr pPIDL = IntPtr.Zero;
                 int nResult = oParentFolder.ParseDisplayName(IntPtr.Zero, IntPtr.Zero, fi.Name, ref pchEaten, out pPIDL, ref pdwAttributes);
                 if (S_OK != nResult)
                 {
                     FreePIDLs(arrPIDLs);
                     return null;
                 }
                 arrPIDLs[n] = pPIDL;
                 n++;
             }
 
             return arrPIDLs;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="373" endline="393"><![CDATA[
         #endregion
 
         #region FreePIDLs()
         /// <summary>
         /// Free the PIDLs
         /// </summary>
         /// <param name="arrPIDLs">Array of PIDLs (IntPtr)</param>
         protected void FreePIDLs(IntPtr[] arrPIDLs)
         {
             if (null != arrPIDLs)
             {
                 for (int n = 0; n < arrPIDLs.Length; n++)
                 {
                     if (arrPIDLs[n] != IntPtr.Zero)
                     {
                         Marshal.FreeCoTaskMem(arrPIDLs[n]);
                         arrPIDLs[n] = IntPtr.Zero;
                     }
                 }
                 for (int n = 0; n < arrPIDLs.Length; n++)
                 {
                     if (arrPIDLs[n] != IntPtr.Zero)
                     {
                         Marshal.FreeCoTaskMem(arrPIDLs[n]);
                         arrPIDLs[n] = IntPtr.Zero;
                     }
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="394" endline="451"><![CDATA[
         #endregion
 
         #region InvokeContextMenuDefault
         private void InvokeContextMenuDefault(FileInfo[] arrFI)
         {
             // Release all resources first.
             ReleaseAll();
 
             IntPtr pMenu = IntPtr.Zero,
                 iContextMenuPtr = IntPtr.Zero;
 
             try
             {
                 _arrPIDLs = GetPIDLs(arrFI);
                 if (null == _arrPIDLs)
                 {
                     ReleaseAll();
                     return;
                 }
 
                 if (false == GetContextMenuInterfaces(_oParentFolder, _arrPIDLs, out iContextMenuPtr))
                 {
                     ReleaseAll();
                     return;
                 }
 
                 pMenu = CreatePopupMenu();
 
                 int nResult = _oContextMenu.QueryContextMenu(
                     pMenu,
                     0,
                     CMD_FIRST,
                     CMD_LAST,
                     CMF.DEFAULTONLY |
                     ((Control.ModifierKeys & Keys.Shift) != 0 ? CMF.EXTENDEDVERBS 
 
                 uint nDefaultCmd = (uint)GetMenuDefaultItem(pMenu, false, 0);
                 if (nDefaultCmd >= CMD_FIRST)
                 {
                     InvokeCommand(_oContextMenu, nDefaultCmd, arrFI[0].DirectoryName, Control.MousePosition);
                 }
 
                 DestroyMenu(pMenu);
                 pMenu = IntPtr.Zero;
             }
             catch
             {
                 throw;
             }
             finally
             {
                 if (pMenu != IntPtr.Zero)
                 {
                     DestroyMenu(pMenu);
                 }
                 ReleaseAll();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="452" endline="467"><![CDATA[
         #endregion
 
         #region ShowContextMenu()
 
         /// <summary>
         /// Shows the context menu
         /// </summary>
         /// <param name="files">FileInfos (should all be in same directory)</param>
         /// <param name="pointScreen">Where to show the menu</param>
         public void ShowContextMenu(FileInfo[] files, Point pointScreen)
         {
             // Release all resources first.
             ReleaseAll();
             _arrPIDLs = GetPIDLs(files);
             this.ShowContextMenu(pointScreen);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="468" endline="480"><![CDATA[
 
         /// <summary>
         /// Shows the context menu
         /// </summary>
         /// <param name="dirs">DirectoryInfos (should all be in same directory)</param>
         /// <param name="pointScreen">Where to show the menu</param>
         public void ShowContextMenu(DirectoryInfo[] dirs, Point pointScreen)
         {
             // Release all resources first.
             ReleaseAll();
             _arrPIDLs = GetPIDLs(dirs);
             this.ShowContextMenu(pointScreen);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="481" endline="565"><![CDATA[
 
         /// <summary>
         /// Shows the context menu
         /// </summary>
         /// <param name="arrFI">FileInfos (should all be in same directory)</param>
         /// <param name="pointScreen">Where to show the menu</param>
         private void ShowContextMenu(Point pointScreen)
         {
             IntPtr pMenu = IntPtr.Zero,
                 iContextMenuPtr = IntPtr.Zero,
                 iContextMenuPtr2 = IntPtr.Zero,
                 iContextMenuPtr3 = IntPtr.Zero;
 
             try
             {
                 if (null == _arrPIDLs)
                 {
                     ReleaseAll();
                     return;
                 }
 
                 if (false == GetContextMenuInterfaces(_oParentFolder, _arrPIDLs, out iContextMenuPtr))
                 {
                     ReleaseAll();
                     return;
                 }
 
                 pMenu = CreatePopupMenu();
 
                 int nResult = _oContextMenu.QueryContextMenu(
                     pMenu,
                     0,
                     CMD_FIRST,
                     CMD_LAST,
                     CMF.EXPLORE |
                     CMF.NORMAL |
                     ((Control.ModifierKeys & Keys.Shift) != 0 ? CMF.EXTENDEDVERBS 
 
                 Marshal.QueryInterface(iContextMenuPtr, ref IID_IContextMenu2, out iContextMenuPtr2);
                 Marshal.QueryInterface(iContextMenuPtr, ref IID_IContextMenu3, out iContextMenuPtr3);
 
                 _oContextMenu2 = (IContextMenu2)Marshal.GetTypedObjectForIUnknown(iContextMenuPtr2, typeof(IContextMenu2));
                 _oContextMenu3 = (IContextMenu3)Marshal.GetTypedObjectForIUnknown(iContextMenuPtr3, typeof(IContextMenu3));
 
                 //hook.Install();
 
                 uint nSelected = TrackPopupMenuEx(
                     pMenu,
                     TPM.RETURNCMD,
                     pointScreen.X,
                     pointScreen.Y,
                     this.Handle,
                     IntPtr.Zero);
 
                 DestroyMenu(pMenu);
                 pMenu = IntPtr.Zero;
 
                 if (nSelected != 0)
                 {
                     InvokeCommand(_oContextMenu, nSelected, _strParentFolder, pointScreen);
                 }
             }
             catch
             {
                 throw;
             }
             finally
             {
                 if (pMenu != IntPtr.Zero)
                 {
                     DestroyMenu(pMenu);
                 }
 
                 if (iContextMenuPtr != IntPtr.Zero)
                     Marshal.Release(iContextMenuPtr);
 
                 if (iContextMenuPtr2 != IntPtr.Zero)
                     Marshal.Release(iContextMenuPtr2);
 
                 if (iContextMenuPtr3 != IntPtr.Zero)
                     Marshal.Release(iContextMenuPtr3);
 
                 ReleaseAll();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="566" endline="625"><![CDATA[
         #endregion
 
         #region Local variabled
         private IContextMenu _oContextMenu;
         private IContextMenu2 _oContextMenu2;
         private IContextMenu3 _oContextMenu3;
         private IShellFolder _oDesktopFolder;
         private IShellFolder _oParentFolder;
         private IntPtr[] _arrPIDLs;
         private string _strParentFolder;
         #endregion
 
         #region Variables and Constants
 
         private const int MAX_PATH = 260;
         private const uint CMD_FIRST = 1;
         private const uint CMD_LAST = 30000;
 
         private const int S_OK = 0;
         private const int S_FALSE = 1;
 
         private static int cbMenuItemInfo = Marshal.SizeOf(typeof(MENUITEMINFO));
         private static int cbInvokeCommand = Marshal.SizeOf(typeof(CMINVOKECOMMANDINFOEX));
 
         #endregion
 
         #region DLL Import
 
         // Retrieves the IShellFolder interface for the desktop folder, which is the root of the Shell's namespace.
         [DllImport("shell32.dll")]
         private static extern Int32 SHGetDesktopFolder(out IntPtr ppshf);
 
         // Takes a STRRET structure returned by IShellFolder
         [DllImport("shlwapi.dll", EntryPoint = "StrRetToBuf", ExactSpelling = false, CharSet = CharSet.Auto, SetLastError = true)]
         private static extern Int32 StrRetToBuf(IntPtr pstr, IntPtr pidl, StringBuilder pszBuf, int cchBuf);
 
         // The TrackPopupMenuEx function displays a shortcut menu at the specified location and tracks the selection of items on the shortcut menu. The shortcut menu can appear anywhere on the screen.
         [DllImport("user32.dll", ExactSpelling = true, CharSet = CharSet.Auto)]
         private static extern uint TrackPopupMenuEx(IntPtr hmenu, TPM flags, int x, int y, IntPtr hwnd, IntPtr lptpm);
 
         // The CreatePopupMenu function creates a drop-down menu, submenu, or shortcut menu. The menu is initially empty. You can insert or append menu items by using the InsertMenuItem function. You can also use the InsertMenu function to insert menu items and the AppendMenu function to append menu items.
         [DllImport("user32", SetLastError = true, CharSet = CharSet.Auto)]
         private static extern IntPtr CreatePopupMenu();
 
         // The DestroyMenu function destroys the specified menu and frees any memory that the menu occupies.
         [DllImport("user32", SetLastError = true, CharSet = CharSet.Auto)]
         private static extern bool DestroyMenu(IntPtr hMenu);
 
         // Determines the default menu item on the specified menu
         [DllImport("user32", SetLastError = true, CharSet = CharSet.Auto)]
         private static extern int GetMenuDefaultItem(IntPtr hMenu, bool fByPos, uint gmdiFlags);
 
         #endregion
 
         #region Shell GUIDs
 
         private static Guid IID_IShellFolder = new Guid("{000214E6-0000-0000-C000-000000000046}");
         private static Guid IID_IContextMenu = new Guid("{000214e4-0000-0000-c000-000000000046}");
         private static Guid IID_IContextMenu2 = new Guid("{000214f4-0000-0000-c000-000000000046}");
         private static Guid IID_IContextMenu3 = new Guid("{bcfce0a0-ec17-11d0-8d10-00a0c90f2719}");
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="626" endline="1417"><![CDATA[
 
         #endregion
 
         #region Structs
 
         [StructLayout(LayoutKind.Sequential)]
         private struct CWPSTRUCT
         {
             public IntPtr lparam;
             public IntPtr wparam;
             public int message;
             public IntPtr hwnd;
         }
 
         // Contains extended information about a shortcut menu command
         [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
         private struct CMINVOKECOMMANDINFOEX
         {
             public int cbSize;
             public CMIC fMask;
             public IntPtr hwnd;
             public IntPtr lpVerb;
             [MarshalAs(UnmanagedType.LPStr)]
             public string lpParameters;
             [MarshalAs(UnmanagedType.LPStr)]
             public string lpDirectory;
             public SW nShow;
             public int dwHotKey;
             public IntPtr hIcon;
             [MarshalAs(UnmanagedType.LPStr)]
             public string lpTitle;
             public IntPtr lpVerbW;
             [MarshalAs(UnmanagedType.LPWStr)]
             public string lpParametersW;
             [MarshalAs(UnmanagedType.LPWStr)]
             public string lpDirectoryW;
             [MarshalAs(UnmanagedType.LPWStr)]
             public string lpTitleW;
             public POINT ptInvoke;
         }
 
         // Contains information about a menu item
         [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
         private struct MENUITEMINFO
         {
             public MENUITEMINFO(string text)
             {
                 cbSize = cbMenuItemInfo;
                 dwTypeData = text;
                 cch = text.Length;
                 fMask = 0;
                 fType = 0;
                 fState = 0;
                 wID = 0;
                 hSubMenu = IntPtr.Zero;
                 hbmpChecked = IntPtr.Zero;
                 hbmpUnchecked = IntPtr.Zero;
                 dwItemData = IntPtr.Zero;
                 hbmpItem = IntPtr.Zero;
             }
 
             public int cbSize;
             public MIIM fMask;
             public MFT fType;
             public MFS fState;
             public uint wID;
             public IntPtr hSubMenu;
             public IntPtr hbmpChecked;
             public IntPtr hbmpUnchecked;
             public IntPtr dwItemData;
             [MarshalAs(UnmanagedType.LPTStr)]
             public string dwTypeData;
             public int cch;
             public IntPtr hbmpItem;
         }
 
         // A generalized global memory handle used for data transfer operations by the 
         // IAdviseSink, IDataObject, and IOleCache interfaces
         [StructLayout(LayoutKind.Sequential)]
         private struct STGMEDIUM
         {
             public TYMED tymed;
             public IntPtr hBitmap;
             public IntPtr hMetaFilePict;
             public IntPtr hEnhMetaFile;
             public IntPtr hGlobal;
             public IntPtr lpszFileName;
             public IntPtr pstm;
             public IntPtr pstg;
             public IntPtr pUnkForRelease;
         }
 
         // Defines the x- and y-coordinates of a point
         [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
         private struct POINT
         {
             public POINT(int x, int y)
             {
                 this.x = x;
                 this.y = y;
             }
 
             public int x;
             public int y;
         }
 
         #endregion
 
         #region Enums
 
         // Defines the values used with the IShellFolder
         // methods to specify the type of file or folder names used by those methods
         [Flags]
         private enum SHGNO
         {
             NORMAL = 0x0000,
             INFOLDER = 0x0001,
             FOREDITING = 0x1000,
             FORADDRESSBAR = 0x4000,
             FORPARSING = 0x8000
         }
 
         // The attributes that the caller is requesting, when calling IShellFolder
         [Flags]
         private enum SFGAO 
         {
             BROWSABLE = 0x8000000,
             CANCOPY = 1,
             CANDELETE = 0x20,
             CANLINK = 4,
             CANMONIKER = 0x400000,
             CANMOVE = 2,
             CANRENAME = 0x10,
             CAPABILITYMASK = 0x177,
             COMPRESSED = 0x4000000,
             CONTENTSMASK = 0x80000000,
             DISPLAYATTRMASK = 0xfc000,
             DROPTARGET = 0x100,
             ENCRYPTED = 0x2000,
             FILESYSANCESTOR = 0x10000000,
             FILESYSTEM = 0x40000000,
             FOLDER = 0x20000000,
             GHOSTED = 0x8000,
             HASPROPSHEET = 0x40,
             HASSTORAGE = 0x400000,
             HASSUBFOLDER = 0x80000000,
             HIDDEN = 0x80000,
             ISSLOW = 0x4000,
             LINK = 0x10000,
             NEWCONTENT = 0x200000,
             NONENUMERATED = 0x100000,
             READONLY = 0x40000,
             REMOVABLE = 0x2000000,
             SHARE = 0x20000,
             STORAGE = 8,
             STORAGEANCESTOR = 0x800000,
             STORAGECAPMASK = 0x70c50008,
             STREAM = 0x400000,
             VALIDATE = 0x1000000
         }
 
         // Determines the type of items included in an enumeration. 
         // These values are used with the IShellFolder
         [Flags]
         private enum SHCONTF
         {
             FOLDERS = 0x0020,
             NONFOLDERS = 0x0040,
             INCLUDEHIDDEN = 0x0080,
             INIT_ON_FIRST_NEXT = 0x0100,
             NETPRINTERSRCH = 0x0200,
             SHAREABLE = 0x0400,
             STORAGE = 0x0800,
         }
 
         // Specifies how the shortcut menu can be changed when calling IContextMenu
         [Flags]
         private enum CMF 
         {
             NORMAL = 0x00000000,
             DEFAULTONLY = 0x00000001,
             VERBSONLY = 0x00000002,
             EXPLORE = 0x00000004,
             NOVERBS = 0x00000008,
             CANRENAME = 0x00000010,
             NODEFAULT = 0x00000020,
             INCLUDESTATIC = 0x00000040,
             EXTENDEDVERBS = 0x00000100,
             RESERVED = 0xffff0000
         }
 
         // Flags specifying the information to return when calling IContextMenu
         [Flags]
         private enum GCS 
         {
             VERBA = 0,
             HELPTEXTA = 1,
             VALIDATEA = 2,
             VERBW = 4,
             HELPTEXTW = 5,
             VALIDATEW = 6
         }
 
         // Specifies how TrackPopupMenuEx positions the shortcut menu horizontally
         [Flags]
         private enum TPM 
         {
             LEFTBUTTON = 0x0000,
             RIGHTBUTTON = 0x0002,
             LEFTALIGN = 0x0000,
             CENTERALIGN = 0x0004,
             RIGHTALIGN = 0x0008,
             TOPALIGN = 0x0000,
             VCENTERALIGN = 0x0010,
             BOTTOMALIGN = 0x0020,
             HORIZONTAL = 0x0000,
             VERTICAL = 0x0040,
             NONOTIFY = 0x0080,
             RETURNCMD = 0x0100,
             RECURSE = 0x0001,
             HORPOSANIMATION = 0x0400,
             HORNEGANIMATION = 0x0800,
             VERPOSANIMATION = 0x1000,
             VERNEGANIMATION = 0x2000,
             NOANIMATION = 0x4000,
             LAYOUTRTL = 0x8000
         }
 
         // The cmd for a custom added menu item
         private enum CMD_CUSTOM
         {
             ExpandCollapse = (int)CMD_LAST + 1
         }
 
         // Flags used with the CMINVOKECOMMANDINFOEX structure
         [Flags]
         private enum CMIC 
         {
             HOTKEY = 0x00000020,
             ICON = 0x00000010,
             FLAG_NO_UI = 0x00000400,
             UNICODE = 0x00004000,
             NO_CONSOLE = 0x00008000,
             ASYNCOK = 0x00100000,
             NOZONECHECKS = 0x00800000,
             SHIFT_DOWN = 0x10000000,
             CONTROL_DOWN = 0x40000000,
             FLAG_LOG_USAGE = 0x04000000,
             PTINVOKE = 0x20000000
         }
 
         // Specifies how the window is to be shown
         [Flags]
         private enum SW
         {
             HIDE = 0,
             SHOWNORMAL = 1,
             NORMAL = 1,
             SHOWMINIMIZED = 2,
             SHOWMAXIMIZED = 3,
             MAXIMIZE = 3,
             SHOWNOACTIVATE = 4,
             SHOW = 5,
             MINIMIZE = 6,
             SHOWMINNOACTIVE = 7,
             SHOWNA = 8,
             RESTORE = 9,
             SHOWDEFAULT = 10,
         }
 
         // Window message flags
         [Flags]
         private enum WM 
         {
             ACTIVATE = 0x6,
             ACTIVATEAPP = 0x1C,
             AFXFIRST = 0x360,
             AFXLAST = 0x37F,
             APP = 0x8000,
             ASKCBFORMATNAME = 0x30C,
             CANCELJOURNAL = 0x4B,
             CANCELMODE = 0x1F,
             CAPTURECHANGED = 0x215,
             CHANGECBCHAIN = 0x30D,
             CHAR = 0x102,
             CHARTOITEM = 0x2F,
             CHILDACTIVATE = 0x22,
             CLEAR = 0x303,
             CLOSE = 0x10,
             COMMAND = 0x111,
             COMPACTING = 0x41,
             COMPAREITEM = 0x39,
             CONTEXTMENU = 0x7B,
             COPY = 0x301,
             COPYDATA = 0x4A,
             CREATE = 0x1,
             CTLCOLORBTN = 0x135,
             CTLCOLORDLG = 0x136,
             CTLCOLOREDIT = 0x133,
             CTLCOLORLISTBOX = 0x134,
             CTLCOLORMSGBOX = 0x132,
             CTLCOLORSCROLLBAR = 0x137,
             CTLCOLORSTATIC = 0x138,
             CUT = 0x300,
             DEADCHAR = 0x103,
             DELETEITEM = 0x2D,
             DESTROY = 0x2,
             DESTROYCLIPBOARD = 0x307,
             DEVICECHANGE = 0x219,
             DEVMODECHANGE = 0x1B,
             DISPLAYCHANGE = 0x7E,
             DRAWCLIPBOARD = 0x308,
             DRAWITEM = 0x2B,
             DROPFILES = 0x233,
             ENABLE = 0xA,
             ENDSESSION = 0x16,
             ENTERIDLE = 0x121,
             ENTERMENULOOP = 0x211,
             ENTERSIZEMOVE = 0x231,
             ERASEBKGND = 0x14,
             EXITMENULOOP = 0x212,
             EXITSIZEMOVE = 0x232,
             FONTCHANGE = 0x1D,
             GETDLGCODE = 0x87,
             GETFONT = 0x31,
             GETHOTKEY = 0x33,
             GETICON = 0x7F,
             GETMINMAXINFO = 0x24,
             GETOBJECT = 0x3D,
             GETSYSMENU = 0x313,
             GETTEXT = 0xD,
             GETTEXTLENGTH = 0xE,
             HANDHELDFIRST = 0x358,
             HANDHELDLAST = 0x35F,
             HELP = 0x53,
             HOTKEY = 0x312,
             HSCROLL = 0x114,
             HSCROLLCLIPBOARD = 0x30E,
             ICONERASEBKGND = 0x27,
             IME_CHAR = 0x286,
             IME_COMPOSITION = 0x10F,
             IME_COMPOSITIONFULL = 0x284,
             IME_CONTROL = 0x283,
             IME_ENDCOMPOSITION = 0x10E,
             IME_KEYDOWN = 0x290,
             IME_KEYLAST = 0x10F,
             IME_KEYUP = 0x291,
             IME_NOTIFY = 0x282,
             IME_REQUEST = 0x288,
             IME_SELECT = 0x285,
             IME_SETCONTEXT = 0x281,
             IME_STARTCOMPOSITION = 0x10D,
             INITDIALOG = 0x110,
             INITMENU = 0x116,
             INITMENUPOPUP = 0x117,
             INPUTLANGCHANGE = 0x51,
             INPUTLANGCHANGEREQUEST = 0x50,
             KEYDOWN = 0x100,
             KEYFIRST = 0x100,
             KEYLAST = 0x108,
             KEYUP = 0x101,
             KILLFOCUS = 0x8,
             LBUTTONDBLCLK = 0x203,
             LBUTTONDOWN = 0x201,
             LBUTTONUP = 0x202,
             LVM_GETEDITCONTROL = 0x1018,
             LVM_SETIMAGELIST = 0x1003,
             MBUTTONDBLCLK = 0x209,
             MBUTTONDOWN = 0x207,
             MBUTTONUP = 0x208,
             MDIACTIVATE = 0x222,
             MDICASCADE = 0x227,
             MDICREATE = 0x220,
             MDIDESTROY = 0x221,
             MDIGETACTIVE = 0x229,
             MDIICONARRANGE = 0x228,
             MDIMAXIMIZE = 0x225,
             MDINEXT = 0x224,
             MDIREFRESHMENU = 0x234,
             MDIRESTORE = 0x223,
             MDISETMENU = 0x230,
             MDITILE = 0x226,
             MEASUREITEM = 0x2C,
             MENUCHAR = 0x120,
             MENUCOMMAND = 0x126,
             MENUDRAG = 0x123,
             MENUGETOBJECT = 0x124,
             MENURBUTTONUP = 0x122,
             MENUSELECT = 0x11F,
             MOUSEACTIVATE = 0x21,
             MOUSEFIRST = 0x200,
             MOUSEHOVER = 0x2A1,
             MOUSELAST = 0x20A,
             MOUSELEAVE = 0x2A3,
             MOUSEMOVE = 0x200,
             MOUSEWHEEL = 0x20A,
             MOVE = 0x3,
             MOVING = 0x216,
             NCACTIVATE = 0x86,
             NCCALCSIZE = 0x83,
             NCCREATE = 0x81,
             NCDESTROY = 0x82,
             NCHITTEST = 0x84,
             NCLBUTTONDBLCLK = 0xA3,
             NCLBUTTONDOWN = 0xA1,
             NCLBUTTONUP = 0xA2,
             NCMBUTTONDBLCLK = 0xA9,
             NCMBUTTONDOWN = 0xA7,
             NCMBUTTONUP = 0xA8,
             NCMOUSEHOVER = 0x2A0,
             NCMOUSELEAVE = 0x2A2,
             NCMOUSEMOVE = 0xA0,
             NCPAINT = 0x85,
             NCRBUTTONDBLCLK = 0xA6,
             NCRBUTTONDOWN = 0xA4,
             NCRBUTTONUP = 0xA5,
             NEXTDLGCTL = 0x28,
             NEXTMENU = 0x213,
             NOTIFY = 0x4E,
             NOTIFYFORMAT = 0x55,
             NULL = 0x0,
             PAINT = 0xF,
             PAINTCLIPBOARD = 0x309,
             PAINTICON = 0x26,
             PALETTECHANGED = 0x311,
             PALETTEISCHANGING = 0x310,
             PARENTNOTIFY = 0x210,
             PASTE = 0x302,
             PENWINFIRST = 0x380,
             PENWINLAST = 0x38F,
             POWER = 0x48,
             PRINT = 0x317,
             PRINTCLIENT = 0x318,
             QUERYDRAGICON = 0x37,
             QUERYENDSESSION = 0x11,
             QUERYNEWPALETTE = 0x30F,
             QUERYOPEN = 0x13,
             QUEUESYNC = 0x23,
             QUIT = 0x12,
             RBUTTONDBLCLK = 0x206,
             RBUTTONDOWN = 0x204,
             RBUTTONUP = 0x205,
             RENDERALLFORMATS = 0x306,
             RENDERFORMAT = 0x305,
             SETCURSOR = 0x20,
             SETFOCUS = 0x7,
             SETFONT = 0x30,
             SETHOTKEY = 0x32,
             SETICON = 0x80,
             SETMARGINS = 0xD3,
             SETREDRAW = 0xB,
             SETTEXT = 0xC,
             SETTINGCHANGE = 0x1A,
             SHOWWINDOW = 0x18,
             SIZE = 0x5,
             SIZECLIPBOARD = 0x30B,
             SIZING = 0x214,
             SPOOLERSTATUS = 0x2A,
             STYLECHANGED = 0x7D,
             STYLECHANGING = 0x7C,
             SYNCPAINT = 0x88,
             SYSCHAR = 0x106,
             SYSCOLORCHANGE = 0x15,
             SYSCOMMAND = 0x112,
             SYSDEADCHAR = 0x107,
             SYSKEYDOWN = 0x104,
             SYSKEYUP = 0x105,
             TCARD = 0x52,
             TIMECHANGE = 0x1E,
             TIMER = 0x113,
             TVM_GETEDITCONTROL = 0x110F,
             TVM_SETIMAGELIST = 0x1109,
             UNDO = 0x304,
             UNINITMENUPOPUP = 0x125,
             USER = 0x400,
             USERCHANGED = 0x54,
             VKEYTOITEM = 0x2E,
             VSCROLL = 0x115,
             VSCROLLCLIPBOARD = 0x30A,
             WINDOWPOSCHANGED = 0x47,
             WINDOWPOSCHANGING = 0x46,
             WININICHANGE = 0x1A,
             SH_NOTIFY = 0x0401
         }
 
         // Specifies the content of the new menu item
         [Flags]
         private enum MFT 
         {
             GRAYED = 0x00000003,
             DISABLED = 0x00000003,
             CHECKED = 0x00000008,
             SEPARATOR = 0x00000800,
             RADIOCHECK = 0x00000200,
             BITMAP = 0x00000004,
             OWNERDRAW = 0x00000100,
             MENUBARBREAK = 0x00000020,
             MENUBREAK = 0x00000040,
             RIGHTORDER = 0x00002000,
             BYCOMMAND = 0x00000000,
             BYPOSITION = 0x00000400,
             POPUP = 0x00000010
         }
 
         // Specifies the state of the new menu item
         [Flags]
         private enum MFS 
         {
             GRAYED = 0x00000003,
             DISABLED = 0x00000003,
             CHECKED = 0x00000008,
             HILITE = 0x00000080,
             ENABLED = 0x00000000,
             UNCHECKED = 0x00000000,
             UNHILITE = 0x00000000,
             DEFAULT = 0x00001000
         }
 
         // Specifies the content of the new menu item
         [Flags]
         private enum MIIM 
         {
             BITMAP = 0x80,
             CHECKMARKS = 0x08,
             DATA = 0x20,
             FTYPE = 0x100,
             ID = 0x02,
             STATE = 0x01,
             STRING = 0x40,
             SUBMENU = 0x04,
             TYPE = 0x10
         }
 
         // Indicates the type of storage medium being used in a data transfer
         [Flags]
         private enum TYMED
         {
             ENHMF = 0x40,
             FILE = 2,
             GDI = 0x10,
             HGLOBAL = 1,
             ISTORAGE = 8,
             ISTREAM = 4,
             MFPICT = 0x20,
             NULL = 0
         }
 
         #endregion
 
         #region IShellFolder
         [ComImport]
         [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
         [Guid("000214E6-0000-0000-C000-000000000046")]
         private interface IShellFolder
         {
             // Translates a file object's or folder's display name into an item identifier list.
             // Return value
             [PreserveSig]
             Int32 ParseDisplayName(
                 IntPtr hwnd,
                 IntPtr pbc,
                 [MarshalAs(UnmanagedType.LPWStr)] 
             string pszDisplayName,
                 ref uint pchEaten,
                 out IntPtr ppidl,
                 ref SFGAO pdwAttributes);
 
             // Allows a client to determine the contents of a folder by creating an item
             // identifier enumeration object and returning its IEnumIDList interface.
             // Return value
             [PreserveSig]
             Int32 EnumObjects(
                 IntPtr hwnd,
                 SHCONTF grfFlags,
                 out IntPtr enumIDList);
 
             // Retrieves an IShellFolder object for a subfolder.
             // Return value
             [PreserveSig]
             Int32 BindToObject(
                 IntPtr pidl,
                 IntPtr pbc,
                 ref Guid riid,
                 out IntPtr ppv);
 
             // Requests a pointer to an object's storage interface. 
             // Return value
             [PreserveSig]
             Int32 BindToStorage(
                 IntPtr pidl,
                 IntPtr pbc,
                 ref Guid riid,
                 out IntPtr ppv);
 
             // Determines the relative order of two file objects or folders, given their
             // item identifier lists. Return value
             // CODE field of the HRESULT contains one of the following values (the code
             // can be retrived using the helper function GetHResultCode)
             // negative return value indicates that the first item should precede
             // the second (pidl1 < pidl2). 
 
             // Positive A positive return value indicates that the first item should
             // follow the second (pidl1 > pidl2).  Zero A return value of zero
             // indicates that the two items are the same (pidl1 = pidl2). 
             [PreserveSig]
             Int32 CompareIDs(
                 IntPtr lParam,
                 IntPtr pidl1,
                 IntPtr pidl2);
 
             // Requests an object that can be used to obtain information from or interact
             // with a folder object.
             // Return value
             [PreserveSig]
             Int32 CreateViewObject(
                 IntPtr hwndOwner,
                 Guid riid,
                 out IntPtr ppv);
 
             // Retrieves the attributes of one or more file objects or subfolders. 
             // Return value
             [PreserveSig]
             Int32 GetAttributesOf(
                 uint cidl,
                 [MarshalAs(UnmanagedType.LPArray)]
             IntPtr[] apidl,
                 ref SFGAO rgfInOut);
 
             // Retrieves an OLE interface that can be used to carry out actions on the
             // specified file objects or folders.
             // Return value
             [PreserveSig]
             Int32 GetUIObjectOf(
                 IntPtr hwndOwner,
                 uint cidl,
                 [MarshalAs(UnmanagedType.LPArray)]
             IntPtr[] apidl,
                 ref Guid riid,
                 IntPtr rgfReserved,
                 out IntPtr ppv);
 
             // Retrieves the display name for the specified file object or subfolder. 
             // Return value
             [PreserveSig()]
             Int32 GetDisplayNameOf(
                 IntPtr pidl,
                 SHGNO uFlags,
                 IntPtr lpName);
 
             // Sets the display name of a file object or subfolder, changing the item
             // identifier in the process.
             // Return value
             [PreserveSig]
             Int32 SetNameOf(
                 IntPtr hwnd,
                 IntPtr pidl,
                 [MarshalAs(UnmanagedType.LPWStr)] 
             string pszName,
                 SHGNO uFlags,
                 out IntPtr ppidlOut);
         }
         #endregion
 
         #region IContextMenu
         [ComImport()]
         [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
         [GuidAttribute("000214e4-0000-0000-c000-000000000046")]
         private interface IContextMenu
         {
             // Adds commands to a shortcut menu
             [PreserveSig()]
             Int32 QueryContextMenu(
                 IntPtr hmenu,
                 uint iMenu,
                 uint idCmdFirst,
                 uint idCmdLast,
                 CMF uFlags);
 
             // Carries out the command associated with a shortcut menu item
             [PreserveSig()]
             Int32 InvokeCommand(
                 ref CMINVOKECOMMANDINFOEX info);
 
             // Retrieves information about a shortcut menu command, 
             // including the help string and the language-independent, 
             // or canonical, name for the command
             [PreserveSig()]
             Int32 GetCommandString(
                 uint idcmd,
                 GCS uflags,
                 uint reserved,
                 [MarshalAs(UnmanagedType.LPArray)]
             byte[] commandstring,
                 int cch);
         }
 
         [ComImport, Guid("000214f4-0000-0000-c000-000000000046")]
         [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
         private interface IContextMenu2
         {
             // Adds commands to a shortcut menu
             [PreserveSig()]
             Int32 QueryContextMenu(
                 IntPtr hmenu,
                 uint iMenu,
                 uint idCmdFirst,
                 uint idCmdLast,
                 CMF uFlags);
 
             // Carries out the command associated with a shortcut menu item
             [PreserveSig()]
             Int32 InvokeCommand(
                 ref CMINVOKECOMMANDINFOEX info);
 
             // Retrieves information about a shortcut menu command, 
             // including the help string and the language-independent, 
             // or canonical, name for the command
             [PreserveSig()]
             Int32 GetCommandString(
                 uint idcmd,
                 GCS uflags,
                 uint reserved,
                 [MarshalAs(UnmanagedType.LPWStr)]
             StringBuilder commandstring,
                 int cch);
 
             // Allows client objects of the IContextMenu interface to 
             // handle messages associated with owner-drawn menu items
             [PreserveSig]
             Int32 HandleMenuMsg(
                 uint uMsg,
                 IntPtr wParam,
                 IntPtr lParam);
         }
 
         [ComImport, Guid("bcfce0a0-ec17-11d0-8d10-00a0c90f2719")]
         [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
         private interface IContextMenu3
         {
             // Adds commands to a shortcut menu
             [PreserveSig()]
             Int32 QueryContextMenu(
                 IntPtr hmenu,
                 uint iMenu,
                 uint idCmdFirst,
                 uint idCmdLast,
                 CMF uFlags);
 
             // Carries out the command associated with a shortcut menu item
             [PreserveSig()]
             Int32 InvokeCommand(
                 ref CMINVOKECOMMANDINFOEX info);
 
             // Retrieves information about a shortcut menu command, 
             // including the help string and the language-independent, 
             // or canonical, name for the command
             [PreserveSig()]
             Int32 GetCommandString(
                 uint idcmd,
                 GCS uflags,
                 uint reserved,
                 [MarshalAs(UnmanagedType.LPWStr)]
             StringBuilder commandstring,
                 int cch);
 
             // Allows client objects of the IContextMenu interface to 
             // handle messages associated with owner-drawn menu items
             [PreserveSig]
             Int32 HandleMenuMsg(
                 uint uMsg,
                 IntPtr wParam,
                 IntPtr lParam);
 
             // Allows client objects of the IContextMenu3 interface to 
             // handle messages associated with owner-drawn menu items
             [PreserveSig]
             Int32 HandleMenuMsg2(
                 uint uMsg,
                 IntPtr wParam,
                 IntPtr lParam,
                 IntPtr plResult);
         }
         #endregion
     }
 
     #region ShellContextMenuException
     public class ShellContextMenuException 
     {
         /// <summary>Default contructor</summary>
         public ShellContextMenuException()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="1418" endline="1424"><![CDATA[
 
         /// <summary>Constructor with message</summary>
         /// <param name="message">Message</param>
         public ShellContextMenuException(string message)
             
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="1425" endline="1486"><![CDATA[
     }
     #endregion
 
     #region Class HookEventArgs
     public class HookEventArgs 
     {
         public int HookCode;	// Hook code
         public IntPtr wParam;	// WPARAM argument
         public IntPtr lParam;	// LPARAM argument
     }
     #endregion
 
     #region Enum HookType
     // Hook Types
     public enum HookType 
     {
         WH_JOURNALRECORD = 0,
         WH_JOURNALPLAYBACK = 1,
         WH_KEYBOARD = 2,
         WH_GETMESSAGE = 3,
         WH_CALLWNDPROC = 4,
         WH_CBT = 5,
         WH_SYSMSGFILTER = 6,
         WH_MOUSE = 7,
         WH_HARDWARE = 8,
         WH_DEBUG = 9,
         WH_SHELL = 10,
         WH_FOREGROUNDIDLE = 11,
         WH_CALLWNDPROCRET = 12,
         WH_KEYBOARD_LL = 13,
         WH_MOUSE_LL = 14
     }
     #endregion
 
     #region Class LocalWindowsHook
     public class LocalWindowsHook
     {
         // ************************************************************************
         // Filter function delegate
         public delegate int HookProc(int code, IntPtr wParam, IntPtr lParam);
         // ************************************************************************
 
         // ************************************************************************
         // Internal properties
         protected IntPtr m_hhook = IntPtr.Zero;
         protected HookProc m_filterFunc = null;
         protected HookType m_hookType;
         // ************************************************************************
 
         // ************************************************************************
         // Event delegate
         public delegate void HookEventHandler(object sender, HookEventArgs e);
         // ************************************************************************
 
         // ************************************************************************
         // Event
         public event HookEventHandler HookInvoked;
         protected void OnHookInvoked(HookEventArgs e)
         {
             if (HookInvoked != null)
                 HookInvoked(this, e);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="1469" endline="1495"><![CDATA[
         protected IntPtr m_hhook = IntPtr.Zero;
         protected HookProc m_filterFunc = null;
         protected HookType m_hookType;
         // ************************************************************************
 
         // ************************************************************************
         // Event delegate
         public delegate void HookEventHandler(object sender, HookEventArgs e);
         // ************************************************************************
 
         // ************************************************************************
         // Event
         public event HookEventHandler HookInvoked;
         protected void OnHookInvoked(HookEventArgs e)
         {
             if (HookInvoked != null)
                 HookInvoked(this, e);
         }
         // ************************************************************************
 
         // ************************************************************************
         // Class constructor(s)
         public LocalWindowsHook(HookType hook)
         {
             m_hookType = hook;
             m_filterFunc = new HookProc(this.CoreHookProc);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="1469" endline="1500"><![CDATA[
         protected IntPtr m_hhook = IntPtr.Zero;
         protected HookProc m_filterFunc = null;
         protected HookType m_hookType;
         // ************************************************************************
 
         // ************************************************************************
         // Event delegate
         public delegate void HookEventHandler(object sender, HookEventArgs e);
         // ************************************************************************
 
         // ************************************************************************
         // Event
         public event HookEventHandler HookInvoked;
         protected void OnHookInvoked(HookEventArgs e)
         {
             if (HookInvoked != null)
                 HookInvoked(this, e);
         }
         // ************************************************************************
 
         // ************************************************************************
         // Class constructor(s)
         public LocalWindowsHook(HookType hook)
         {
             m_hookType = hook;
             m_filterFunc = new HookProc(this.CoreHookProc);
         }
         public LocalWindowsHook(HookType hook, HookProc func)
         {
             m_hookType = hook;
             m_filterFunc = func;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="1501" endline="1519"><![CDATA[
         // ************************************************************************
 
         // ************************************************************************
         // Default filter function
         protected int CoreHookProc(int code, IntPtr wParam, IntPtr lParam)
         {
             if (code < 0)
                 return CallNextHookEx(m_hhook, code, wParam, lParam);
 
             // Let clients determine what to do
             HookEventArgs e = new HookEventArgs();
             e.HookCode = code;
             e.wParam = wParam;
             e.lParam = lParam;
             OnHookInvoked(e);
 
             // Yield to the next hook in the chain
             return CallNextHookEx(m_hhook, code, wParam, lParam);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="1520" endline="1548"><![CDATA[
         // ************************************************************************
 
         // ************************************************************************
         // Install the hook
         public void Install()
         {
             /*
              * Warning	51	'System.AppDomain.GetCurrentThreadId()' is obsolete
              * 'AppDomain.GetCurrentThreadId has been deprecated because it does
              * not provide a stable Id when managed threads are running on fibers
              * (aka lightweight threads). To get a stable identifier for a managed
              * thread, use the ManagedThreadId property on Thread.
              * http
              */
 
             /*
             m_hhook = SetWindowsHookEx(
                 m_hookType,
                 m_filterFunc,
                 IntPtr.Zero,
                 (int)AppDomain.GetCurrentThreadId());
              */
 
             m_hhook = SetWindowsHookEx(
                 m_hookType,
                 m_filterFunc,
                 IntPtr.Zero,
                 Thread.CurrentThread.ManagedThreadId);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="1549" endline="1556"><![CDATA[
         // ************************************************************************
 
         // ************************************************************************
         // Uninstall the hook
         public void Uninstall()
         {
             UnhookWindowsHookEx(m_hhook);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="1557" endline="1603"><![CDATA[
         // ************************************************************************
 
 
         #region Win32 Imports
         // ************************************************************************
         // Win32
         [DllImport("user32.dll")]
         protected static extern IntPtr SetWindowsHookEx(HookType code,
             HookProc func,
             IntPtr hInstance,
             int threadID);
         // ************************************************************************
 
         // ************************************************************************
         // Win32
         [DllImport("user32.dll")]
         protected static extern int UnhookWindowsHookEx(IntPtr hhook);
         // ************************************************************************
 
         // ************************************************************************
         // Win32
         [DllImport("user32.dll")]
         protected static extern int CallNextHookEx(IntPtr hhook,
             int code, IntPtr wParam, IntPtr lParam);
         // ************************************************************************
         #endregion
     }
     #endregion
 
     #region ShellHelper
 
     internal static class ShellHelper
     {
         #region Low/High Word
 
         /// <summary>
         /// Retrieves the High Word of a WParam of a WindowMessage
         /// </summary>
         /// <param name="ptr">The pointer to the WParam</param>
         /// <returns>The unsigned integer for the High Word</returns>
         public static uint HiWord(IntPtr ptr)
         {
             if (((uint)ptr & 0x80000000) == 0x80000000)
                 return ((uint)ptr >> 16);
             else
                 return ((uint)ptr >> 16) & 0xffff;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="1604" endline="1613"><![CDATA[
 
         /// <summary>
         /// Retrieves the Low Word of a WParam of a WindowMessage
         /// </summary>
         /// <param name="ptr">The pointer to the WParam</param>
         /// <returns>The unsigned integer for the Low Word</returns>
         public static uint LoWord(IntPtr ptr)
         {
             return (uint)ptr & 0xffff;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cShellContextMenu.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="24" endline="60"><![CDATA[
         private System.ComponentModel.IContainer components = null;
         public ProjectManager(MainForm main)
         {
             InitializeComponent();
 
             this.m_MainForm = main;
             this.m_ctxRoot = new ContextMenuStrip();
             ToolStripMenuItem tsmiBuild = new ToolStripMenuItem("Build");
             tsmiBuild.Click += new EventHandler(Build);
             ToolStripMenuItem tsmiRmvProject = new ToolStripMenuItem("Remove Project");
             tsmiRmvProject.Click += new EventHandler(RemoveProject);
 
             this.m_ctxRoot.Items.Add(tsmiBuild);
             this.m_ctxRoot.Items.Add(tsmiRmvProject);
 
             this.TabText = "Projects";
             this.m_delTrace = new TraceDelegate(this.m_MainForm.Trace);
             this.treeMain.BeforeExpand += new TreeViewCancelEventHandler(treeMain_BeforeExpand);
             this.treeMain.DoubleClick += new EventHandler(treeMain_DoubleClick);
             this.treeMain.AfterSelect += new TreeViewEventHandler(treeMain_AfterSelect);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="61" endline="125"><![CDATA[
 
         #endregion
 
         #region -= Build =-
 
         void Build(object sender, EventArgs e)
         {
             string script = "";
             string workingDir = "";
             string proj = this.treeMain.SelectedNode.Tag.ToString();
 
             XmlDocument xDoc = new XmlDocument();
             xDoc.Load(proj);
 
             // Working Dir...
             XmlNodeList nodes = xDoc.GetElementsByTagName("WorkingDir");
             if (nodes.Count == 1)
             {
                 workingDir = nodes[0].InnerText;
             }
             if (string.IsNullOrEmpty(workingDir))
             {
                 workingDir = Application.StartupPath;
             }
             
             // Build Script...
             nodes = xDoc.GetElementsByTagName("BuildScript");
             if (nodes.Count == 1)
             {
                 script = nodes[0].InnerText;
             }
             
             // Pre-Build/Post-Build Files...
             string preBuild = "", postBuild = System.Environment.NewLine;
             nodes = xDoc.GetElementsByTagName("BuildFile");
             foreach (XmlNode node in nodes)
             {
                 bool bpreBuild = false;
                 string file = "";
                 foreach (XmlNode cNode in node.ChildNodes)
                 {
                     if (cNode.Name.ToLower() == "file")
                     {
                         file = cNode.InnerText;
                     }
 
                     if (cNode.Name.ToLower() == "prebuild")
                     {
                         bpreBuild = Convert.ToBoolean(cNode.InnerText);
                     }
                 }
                 foreach (XmlNode cNode in node.ChildNodes)
                 {
                     if (cNode.Name.ToLower() == "file")
                     {
                         file = cNode.InnerText;
                     }
 
                     if (cNode.Name.ToLower() == "prebuild")
                     {
                         bpreBuild = Convert.ToBoolean(cNode.InnerText);
                     }
                 }
 
                 if (bpreBuild)
                 {
                     preBuild += file + System.Environment.NewLine;
                 }
                 else
                 {
                     postBuild += file + System.Environment.NewLine;
                 }
             }
             foreach (XmlNode node in nodes)
             {
                 bool bpreBuild = false;
                 string file = "";
                 foreach (XmlNode cNode in node.ChildNodes)
                 {
                     if (cNode.Name.ToLower() == "file")
                     {
                         file = cNode.InnerText;
                     }
 
                     if (cNode.Name.ToLower() == "prebuild")
                     {
                         bpreBuild = Convert.ToBoolean(cNode.InnerText);
                     }
                 }
 
                 if (bpreBuild)
                 {
                     preBuild += file + System.Environment.NewLine;
                 }
                 else
                 {
                     postBuild += file + System.Environment.NewLine;
                 }
             }
 
             script = preBuild + script + postBuild;
             this.m_MainForm.RunScript(script, workingDir);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="126" endline="159"><![CDATA[
 
         #endregion
 
         #region -= Tree Selection =-
 
         void treeMain_AfterSelect(object sender, TreeViewEventArgs e)
         {
             if (this.treeMain.SelectedNode != null)
             {
                 this.tsbDelete.Enabled = true;
                 if (this.treeMain.SelectedNode.Parent == null)
                 {
                     this.tsbAddFile.Enabled = this.tsbAddFolder.Enabled =
                         this.tsbProperties.Enabled = this.tsbRefresh.Enabled = true;
                     this.tsbOpenDir.Enabled = false;
                 }
                 else if (this.treeMain.SelectedNode.Nodes.Count == 0)
                 {
                     this.tsbProperties.Enabled = this.tsbAddFolder.Enabled = this.tsbRefresh.Enabled =
                         this.tsbAddFile.Enabled = false;
                     this.tsbOpenDir.Enabled = true;
                 }
                 else
                 {
                     this.tsbRefresh.Enabled = this.tsbOpenDir.Enabled = true;
                     this.tsbProperties.Enabled = this.tsbAddFolder.Enabled = this.tsbAddFile.Enabled = false;
                 }
             }
             else
             {
                 this.tsbAddFile.Enabled = this.tsbAddFolder.Enabled = this.tsbDelete.Enabled =
                     this.tsbProperties.Enabled = this.tsbRefresh.Enabled = this.tsbOpenDir.Enabled = false;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="160" endline="178"><![CDATA[
 
         void treeMain_DoubleClick(object sender, EventArgs e)
         {
             if (this.treeMain.SelectedNode != null)
             {
                 if (this.treeMain.SelectedNode.Nodes.Count == 0)
                 {
                     TreeNode n = this.treeMain.SelectedNode.Parent;
                     while (n.Parent != null)
                     {
                         n = n.Parent;
                     }
                     while (n.Parent != null)
                     {
                         n = n.Parent;
                     }
                     cProjectInfo pInfo = (cProjectInfo)n.Tag;
                     string file = this.treeMain.SelectedNode.Tag.ToString();
                     this.m_Host.CreateEditor(file, Path.GetFileName(file));
                     this.m_MainForm.GetEditor(file).Project = pInfo.Path;
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="179" endline="189"><![CDATA[
 
         void treeMain_BeforeExpand(object sender, TreeViewCancelEventArgs e)
         {
             if (e.Node.Tag.ToString().ToLower() != "vfolder")
             {
                 if (!this.treeMain.Nodes.Contains(e.Node))
                 {
                     this.GetDirContent(e.Node);
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="190" endline="230"><![CDATA[
 
         #endregion
 
         #region -= Get Directory Content =-
 
         private void GetDirContent(TreeNode node)
         {
             node.Nodes.Clear();
             DirectoryInfo dirInfo = new DirectoryInfo(node.Tag.ToString());
             if (dirInfo.Exists)
             {
                 DirectoryInfo[] dirs = dirInfo.GetDirectories();
                 Array.Sort(dirs, new cDirectorySorter());
                 foreach (DirectoryInfo dir in dirs)
                 {
                     TreeNode tNode = new TreeNode();
                     tNode.Tag = dir.FullName;
                     string folder = dir.FullName.Substring(dir.FullName.LastIndexOf('\\') + 1);
                     tNode.Text = tNode.Name = folder;
                     tNode.Nodes.Add("");
 
                     node.Nodes.Add(tNode);
                 }
                 foreach (DirectoryInfo dir in dirs)
                 {
                     TreeNode tNode = new TreeNode();
                     tNode.Tag = dir.FullName;
                     string folder = dir.FullName.Substring(dir.FullName.LastIndexOf('\\') + 1);
                     tNode.Text = tNode.Name = folder;
                     tNode.Nodes.Add("");
 
                     node.Nodes.Add(tNode);
                 }
 
                 FileInfo[] files = dirInfo.GetFiles();
                 Array.Sort(files, new cFileSorter());
                 foreach (FileInfo file in files)
                 {
                     TreeNode tNode = new TreeNode();
                     tNode.Tag = file.FullName;
                     tNode.Text = tNode.Name = Path.GetFileName(file.FullName);
                     this.GetNodeImage(tNode);
 
                     node.Nodes.Add(tNode);
                 }
                 foreach (FileInfo file in files)
                 {
                     TreeNode tNode = new TreeNode();
                     tNode.Tag = file.FullName;
                     tNode.Text = tNode.Name = Path.GetFileName(file.FullName);
                     this.GetNodeImage(tNode);
 
                     node.Nodes.Add(tNode);
                 }
             }
             else
             {
                 MessageBox.Show("Directory Not Found.", "Peter", MessageBoxButtons.OK, MessageBoxIcon.Error);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="231" endline="368"><![CDATA[
 
         #endregion
 
         #region -= Load File =-
 
         /// <summary>
         /// Loads the given project...
         /// </summary>
         /// <param name="filePath"></param>
         /// <returns></returns>
         public string LoadFile(string filePath)
         {
             // Check to see if the project is open...
             foreach (TreeNode rN in this.treeMain.Nodes)
             {
                 if (rN.Tag.ToString() == filePath)
                 {
                     // The project is already open, leave...
                     return null;
                 }
             }
             foreach (TreeNode rN in this.treeMain.Nodes)
             {
                 if (rN.Tag.ToString() == filePath)
                 {
                     // The project is already open, leave...
                     return null;
                 }
             }
 
             // Does the file Exist???
             if (File.Exists(filePath))
             {
                 cProjectInfo pInfo = new cProjectInfo();
 
                 // Load project file...
                 XmlDocument xDoc = new XmlDocument();
                 xDoc.Load(filePath);
 
                 // Get Project Name...
                 XmlNodeList nodes = xDoc.GetElementsByTagName("name");
                 if (nodes.Count < 1)
                 {
                     // No name, get out of here...
                     return null;
                 }
                 string proj = nodes[0].InnerText;
 
                 // Set up Root Node...
                 TreeNode root = new TreeNode(proj);
                 root.Name = proj;
                 root.ImageIndex = root.SelectedImageIndex = 1;
                 root.ContextMenuStrip = this.m_ctxRoot;
 
                 // Get Project Type...
                 nodes = xDoc.GetElementsByTagName("type");
                 if (nodes.Count > 0)
                 {
                     pInfo.Type = nodes[0].InnerText;
                     if (string.IsNullOrEmpty(pInfo.Type)) pInfo.Type = "None";
                 }
                 else { pInfo.Type = "None"; }
 
                 // Set up Project Info...
                 pInfo.Name = proj;
                 pInfo.Path = filePath;
                 root.Tag = pInfo;
 
                 // List of folders and files...
                 ArrayList folders = new ArrayList();
                 ArrayList files = new ArrayList();
 
                 // Get Folders...
                 nodes = xDoc.GetElementsByTagName("folder");
                 foreach (XmlNode node in nodes)
                 {
                     GetFolder(root, node);
                     folders.Add(node.InnerText);
                 }
                 foreach (XmlNode node in nodes)
                 {
                     GetFolder(root, node);
                     folders.Add(node.InnerText);
                 }
 
                 // Get Files...
                 nodes = xDoc.GetElementsByTagName("file");
                 foreach (XmlNode node in nodes)
                 {
                     GetFile(root, node);
                     files.Add(node.InnerText);
                 }
                 foreach (XmlNode node in nodes)
                 {
                     GetFile(root, node);
                     files.Add(node.InnerText);
                 }
 
                 // Add Project to TreeView...
                 this.treeMain.Nodes.Add(root);
                 this.treeMain.SelectedNode = root;
 
                 // Parse Project...
                 if (!pInfo.Equals("None"))
                 {
                     ArrayList fileList = new ArrayList();
                     string[] filters = new string[1];
                     filters[0] = "*.*";
                     switch (pInfo.Type.ToLower())
                     {
                         case "c project"
                             filters = new string[2];
                             filters[0] = "*.c";
                             filters[1] = "*.h";
                             break;
                     }
 
                     foreach (string folder in folders)
                     {
                         DirectoryInfo di = new DirectoryInfo(folder);
                         foreach (string filter in filters)
                         {
                             FileInfo[] dirFiles = di.GetFiles(filter, SearchOption.AllDirectories);
                             foreach (FileInfo fi in dirFiles)
                             {
                                 fileList.Add(fi);
                             }
                             foreach (FileInfo fi in dirFiles)
                             {
                                 fileList.Add(fi);
                             }
                         }
                         foreach (string filter in filters)
                         {
                             FileInfo[] dirFiles = di.GetFiles(filter, SearchOption.AllDirectories);
                             foreach (FileInfo fi in dirFiles)
                             {
                                 fileList.Add(fi);
                             }
                         }
                     }
                     foreach (string folder in folders)
                     {
                         DirectoryInfo di = new DirectoryInfo(folder);
                         foreach (string filter in filters)
                         {
                             FileInfo[] dirFiles = di.GetFiles(filter, SearchOption.AllDirectories);
                             foreach (FileInfo fi in dirFiles)
                             {
                                 fileList.Add(fi);
                             }
                         }
                     }
                     foreach (string file in files)
                     {
                         switch (pInfo.Type.ToLower())
                         {
                             case "c project"
                                 foreach (string filter in filters)
                                 {
                                     if (filter.Equals("*" + Path.GetExtension(file)))
                                     {
                                         fileList.Add(new FileInfo(file));
                                     }
                                 }
                                 foreach (string filter in filters)
                                 {
                                     if (filter.Equals("*" + Path.GetExtension(file)))
                                     {
                                         fileList.Add(new FileInfo(file));
                                     }
                                 }
                                 break;
                         }
                     }
                     foreach (string file in files)
                     {
                         switch (pInfo.Type.ToLower())
                         {
                             case "c project"
                                 foreach (string filter in filters)
                                 {
                                     if (filter.Equals("*" + Path.GetExtension(file)))
                                     {
                                         fileList.Add(new FileInfo(file));
                                     }
                                 }
                                 break;
                         }
                     }
 
                     StartParsing del = new StartParsing(ParseProject);
                     del.BeginInvoke(fileList, pInfo, new AsyncCallback(CallBack), null);
                 }
 
                 return proj;
             }
             else
             {
                 return null;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="369" endline="377"><![CDATA[
 
         #endregion
 
         public void CallBack (IAsyncResult ar)
         {
             StartParsing del = (StartParsing)((AsyncResult)ar).AsyncDelegate;
             Console.WriteLine("--- Done Parsing ---");
             del.EndInvoke(ar);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="378" endline="394"><![CDATA[
 
         public void ParseProject (ArrayList fileList, cProjectInfo pInfo)
         {
             //cProjectInfo pInfo = (cProjectInfo)projNode.Tag;
             pInfo.Data = new TreeNode("root");
 
             switch(pInfo.Type.ToLower())
             {
                 case "c project"
                     foreach (FileInfo fi in fileList)
                     {
                         ParseCFile(pInfo.Data, fi);
                     }
                     foreach (FileInfo fi in fileList)
                     {
                         ParseCFile(pInfo.Data, fi);
                     }
                     break;
             }
             this.m_delTrace.BeginInvoke(pInfo.Name + " Project Data Complete.", null, null);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="395" endline="448"><![CDATA[
 
         private  void ParseCFile (TreeNode data, FileInfo fi)
         {
             this.m_delTrace.BeginInvoke("Gathering Project Data for file
             TreeNode file = new TreeNode(fi.FullName);
             file.Name = fi.FullName;
 
             TreeNode prototypes = new TreeNode("prototypes");
             prototypes.Name = "prototypes";
 
             TreeNode variables = new TreeNode("variables");
             variables.Name = "variables";
 
             TreeNode defines = new TreeNode("defines");
             defines.Name = "defines";
 
             Peter.CParser.Scanner scanner = new Peter.CParser.Scanner(fi.FullName);
             Peter.CParser.Parser parser = new Peter.CParser.Parser(scanner);
             parser.Parse();
             foreach (TokenMatch tm in parser.CodeInfo.Defines)
             {
                 TreeNode node = new TreeNode(tm.Value);
                 node.Name = tm.Value;
                 node.Tag = tm.Position;
                 defines.Nodes.Add(node);
             }
             foreach (TokenMatch tm in parser.CodeInfo.Defines)
             {
                 TreeNode node = new TreeNode(tm.Value);
                 node.Name = tm.Value;
                 node.Tag = tm.Position;
                 defines.Nodes.Add(node);
             }
             foreach (TokenMatch tm in parser.CodeInfo.Prototypes)
             {
                 TreeNode node = new TreeNode(tm.Value);
                 node.Name = tm.Value;
                 node.Tag = tm.Position;
                 prototypes.Nodes.Add(node);
             }
             foreach (TokenMatch tm in parser.CodeInfo.Prototypes)
             {
                 TreeNode node = new TreeNode(tm.Value);
                 node.Name = tm.Value;
                 node.Tag = tm.Position;
                 prototypes.Nodes.Add(node);
             }
             foreach (TokenMatch tm in parser.CodeInfo.Functions)
             {
                 TreeNode node = new TreeNode(tm.Value);
                 node.Name = tm.Value;
                 node.Tag = tm.Position;
                 prototypes.Nodes.Add(node);
             }
             foreach (TokenMatch tm in parser.CodeInfo.Functions)
             {
                 TreeNode node = new TreeNode(tm.Value);
                 node.Name = tm.Value;
                 node.Tag = tm.Position;
                 prototypes.Nodes.Add(node);
             }
             foreach (TokenMatch tm in parser.CodeInfo.GlobalVariables)
             {
                 TreeNode node = new TreeNode(tm.Value);
                 node.Name = tm.Value;
                 node.Tag = tm.Position;
                 variables.Nodes.Add(node);
             }
             foreach (TokenMatch tm in parser.CodeInfo.GlobalVariables)
             {
                 TreeNode node = new TreeNode(tm.Value);
                 node.Name = tm.Value;
                 node.Tag = tm.Position;
                 variables.Nodes.Add(node);
             }
 
             if (defines.Nodes.Count > 0) file.Nodes.Add(defines);
             if (prototypes.Nodes.Count > 0) file.Nodes.Add(prototypes);
             if (variables.Nodes.Count > 0) file.Nodes.Add(variables);
 
             if (file.Nodes.Count > 0) data.Nodes.Add(file);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="449" endline="474"><![CDATA[
 
         public string LookUp (string word, string project)
         {
             string rtn = "<ul>";
             TreeNode pData = this.GetProjectData(project);
             if (pData != null)
             {
                 foreach (TreeNode fileNode in pData.Nodes)
                 {
                     foreach (TreeNode dataNode in fileNode.Nodes)
                     {
                         foreach (TreeNode infoNode in dataNode.Nodes)
                         {
                             if (infoNode.Text.Contains(word))
                             {
                                 rtn += "<li><b><a href=\"" + fileNode.Text + "\" TITLE=\"" + fileNode.Text + "\" offset=\"" + 
                                     infoNode.Tag.ToString() + "\">" + Path.GetFileName(fileNode.Text);
                                 rtn += "</a></b><ul><li>" + infoNode.Text + "</li></ul></li>";
                             }
                         }
                         foreach (TreeNode infoNode in dataNode.Nodes)
                         {
                             if (infoNode.Text.Contains(word))
                             {
                                 rtn += "<li><b><a href=\"" + fileNode.Text + "\" TITLE=\"" + fileNode.Text + "\" offset=\"" + 
                                     infoNode.Tag.ToString() + "\">" + Path.GetFileName(fileNode.Text);
                                 rtn += "</a></b><ul><li>" + infoNode.Text + "</li></ul></li>";
                             }
                         }
                     }
                     foreach (TreeNode dataNode in fileNode.Nodes)
                     {
                         foreach (TreeNode infoNode in dataNode.Nodes)
                         {
                             if (infoNode.Text.Contains(word))
                             {
                                 rtn += "<li><b><a href=\"" + fileNode.Text + "\" TITLE=\"" + fileNode.Text + "\" offset=\"" + 
                                     infoNode.Tag.ToString() + "\">" + Path.GetFileName(fileNode.Text);
                                 rtn += "</a></b><ul><li>" + infoNode.Text + "</li></ul></li>";
                             }
                         }
                     }
                 }
                 foreach (TreeNode fileNode in pData.Nodes)
                 {
                     foreach (TreeNode dataNode in fileNode.Nodes)
                     {
                         foreach (TreeNode infoNode in dataNode.Nodes)
                         {
                             if (infoNode.Text.Contains(word))
                             {
                                 rtn += "<li><b><a href=\"" + fileNode.Text + "\" TITLE=\"" + fileNode.Text + "\" offset=\"" + 
                                     infoNode.Tag.ToString() + "\">" + Path.GetFileName(fileNode.Text);
                                 rtn += "</a></b><ul><li>" + infoNode.Text + "</li></ul></li>";
                             }
                         }
                     }
                 }
             }
             rtn += "</ul>";
             return rtn;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="475" endline="488"><![CDATA[
 
         private TreeNode GetProjectData (string project)
         {
             foreach (TreeNode node in this.treeMain.Nodes)
             {
                 cProjectInfo pInfo = (cProjectInfo)node.Tag;
                 if (pInfo.Path.Equals(project))
                 {
                     return pInfo.Data;
                 }
             }
             foreach (TreeNode node in this.treeMain.Nodes)
             {
                 cProjectInfo pInfo = (cProjectInfo)node.Tag;
                 if (pInfo.Path.Equals(project))
                 {
                     return pInfo.Data;
                 }
             }
 
             return null;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="489" endline="512"><![CDATA[
 
         public string CheckFileInProject (string filePath)
         {
             try
             {
                 foreach (TreeNode node in this.treeMain.Nodes)
                 {
                     cProjectInfo pInfo = (cProjectInfo)node.Tag;
                     if (pInfo.Data != null)
                     {
                         foreach (TreeNode n in pInfo.Data.Nodes["files"].Nodes)
                         {
                             if (n.Text.ToLower().Equals(n.Text.ToLower()))
                             {
                                 return pInfo.Path;
                             }
                         }
                         foreach (TreeNode n in pInfo.Data.Nodes["files"].Nodes)
                         {
                             if (n.Text.ToLower().Equals(n.Text.ToLower()))
                             {
                                 return pInfo.Path;
                             }
                         }
                     }
                 }
                 foreach (TreeNode node in this.treeMain.Nodes)
                 {
                     cProjectInfo pInfo = (cProjectInfo)node.Tag;
                     if (pInfo.Data != null)
                     {
                         foreach (TreeNode n in pInfo.Data.Nodes["files"].Nodes)
                         {
                             if (n.Text.ToLower().Equals(n.Text.ToLower()))
                             {
                                 return pInfo.Path;
                             }
                         }
                     }
                 }
             }
             catch (Exception ex) { Console.WriteLine(ex.Message); }
 
             return null;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="513" endline="527"><![CDATA[
 
         #region -= Get Info =-
 
         private void GetFile(TreeNode root, XmlNode node)
         {
 
             TreeNode tNode = new TreeNode();
             string file = node.InnerText;
             tNode.Tag = file;
             file = Path.GetFileName(file);
             tNode.Text = tNode.Name = file;
             this.GetNodeImage(tNode);
 
             root.Nodes.Add(tNode);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="528" endline="539"><![CDATA[
 
         private static void GetFolder(TreeNode root, XmlNode node)
         {
             TreeNode tNode = new TreeNode();
             string folder = node.InnerText;
             tNode.Tag = folder;
             folder = folder.Substring(folder.LastIndexOf('\\') + 1);
             tNode.Text = tNode.Name = folder;
             tNode.Nodes.Add("");
 
             root.Nodes.Add(tNode);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="540" endline="547"><![CDATA[
 
         private void GetNodeImage(TreeNode node)
         {
             Image image = Common.GetFileIcon(node.Tag.ToString(), false).ToBitmap();
             int index = this.imgMain.Images.Add(image, Color.Transparent);
 
             node.SelectedImageIndex = node.ImageIndex = index;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="548" endline="555"><![CDATA[
 
         #endregion
 
         #region IPeterPluginTab Members
 
         public void Save()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="556" endline="559"><![CDATA[
 
         public void SaveAs(string filePath)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="560" endline="563"><![CDATA[
 
         public void Cut()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="564" endline="567"><![CDATA[
 
         public void Copy()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="568" endline="571"><![CDATA[
 
         public void Paste()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="572" endline="575"><![CDATA[
 
         public void Undo()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="576" endline="579"><![CDATA[
 
         public void Redo()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="580" endline="583"><![CDATA[
 
         public void Print()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="584" endline="587"><![CDATA[
 
         public void Duplicate()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="588" endline="626"><![CDATA[
 
         public void Delete()
         {
             if (this.treeMain.SelectedNode.Parent == null)
             {
                 // Delete Project...
                 if (MessageBox.Show("This will permanently delete the project '" + this.treeMain.SelectedNode.Text + "'.\nAre you OK with that?",
                     "Peter", MessageBoxButtons.YesNo, MessageBoxIcon.Information) == DialogResult.Yes)
                 {
                     if(File.Exists(this.treeMain.SelectedNode.Tag.ToString()))
                     {
                         File.Delete(this.treeMain.SelectedNode.Tag.ToString());
                         return;
                     }
                 }
                 return;
             }
 
             TreeNode root = this.treeMain.SelectedNode;
             while(root.Parent != null)
             {
                 root = root.Parent;
             }
             while(root.Parent != null)
             {
                 root = root.Parent;
             }
             XmlDocument xDoc = new XmlDocument();
             xDoc.Load(root.Tag.ToString());
             foreach (XmlNode node in xDoc.FirstChild.ChildNodes)
             {
                 if (node.InnerText == this.treeMain.SelectedNode.Tag.ToString())
                 {
                     xDoc.FirstChild.RemoveChild(node);
 
                     this.treeMain.SelectedNode.Parent.Nodes.Remove(this.treeMain.SelectedNode);
                     return;
                 }
             }
             foreach (XmlNode node in xDoc.FirstChild.ChildNodes)
             {
                 if (node.InnerText == this.treeMain.SelectedNode.Tag.ToString())
                 {
                     xDoc.FirstChild.RemoveChild(node);
 
                     this.treeMain.SelectedNode.Parent.Nodes.Remove(this.treeMain.SelectedNode);
                     return;
                 }
             }
 
             MessageBox.Show("Unable to remove the specified file/folder.", "Peter", 
                 MessageBoxButtons.OK, MessageBoxIcon.Information);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="627" endline="630"><![CDATA[
 
         public void SelectAll()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="631" endline="636"><![CDATA[
 
         public bool CloseTab()
         {
             this.Close();
             return true;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="637" endline="640"><![CDATA[
 
         public IPeterPluginHost Host
         {
             get {  return this.m_Host; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="641" endline="642"><![CDATA[
 
             set { this.m_Host = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="643" endline="647"><![CDATA[
         }
 
         public string FileName
         {
             get { return ""; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="648" endline="660"><![CDATA[
         }
 
         public string Selection
         {
             get 
             {
                 if (this.treeMain.SelectedNode != null)
                 {
                     return this.treeMain.SelectedNode.Tag.ToString();
                 }
 
                 return "";
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="661" endline="665"><![CDATA[
         }
 
         public bool AbleToUndo
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="666" endline="670"><![CDATA[
         }
 
         public bool AbleToRedo
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="671" endline="675"><![CDATA[
         }
 
         public bool AbleToPaste
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="676" endline="680"><![CDATA[
         }
 
         public bool AbleToCut
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="681" endline="685"><![CDATA[
         }
 
         public bool AbleToCopy
         {
             get { return true; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="686" endline="690"><![CDATA[
         }
 
         public bool AbleToSelectAll
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="691" endline="695"><![CDATA[
         }
 
         public bool AbleToSave
         {
             get { return true; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="696" endline="700"><![CDATA[
         }
 
         public bool AbleToDelete
         {
             get { return true; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="701" endline="705"><![CDATA[
         }
 
         public bool NeedsSaving
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="706" endline="710"><![CDATA[
         }
 
         public void MarkAll(System.Text.RegularExpressions.Regex reg)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="711" endline="715"><![CDATA[
 
         public bool FindNext(System.Text.RegularExpressions.Regex reg, bool searchUp)
         {
             return false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="716" endline="719"><![CDATA[
 
         public void ReplaceNext(System.Text.RegularExpressions.Regex reg, string replaceWith, bool searchUp)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="720" endline="723"><![CDATA[
 
         public void ReplaceAll(System.Text.RegularExpressions.Regex reg, string replaceWith)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="724" endline="727"><![CDATA[
 
         public void SelectWord(int line, int offset, int wordLeng)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="728" endline="738"><![CDATA[
 
         #endregion
 
         #region -= Tool Bar =-
 
         private void tsbProperties_Click(object sender, EventArgs e)
         {
             Project prj = new Project();
             prj.SetProjectFile(this.treeMain.SelectedNode.Tag.ToString());
             prj.ShowDialog();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="739" endline="768"><![CDATA[
 
         private void tsbAddFolder_Click(object sender, EventArgs e)
         {
             if (this.fbdMain.ShowDialog() == DialogResult.OK)
             {
                 string path = this.fbdMain.SelectedPath;
                 string proj = this.treeMain.SelectedNode.Tag.ToString();
 
                 foreach (TreeNode node in this.treeMain.SelectedNode.Nodes)
                 {
                     if (node.Tag.ToString() == path)
                     {
                         return;
                     }
                 }
                 foreach (TreeNode node in this.treeMain.SelectedNode.Nodes)
                 {
                     if (node.Tag.ToString() == path)
                     {
                         return;
                     }
                 }
 
                 XmlDocument xDoc = new XmlDocument();
                 xDoc.Load(proj);
                 XmlNode addNode = xDoc.CreateNode(XmlNodeType.Element, "folder", null);
                 addNode.InnerText = path;
                 xDoc.FirstChild.AppendChild(addNode);
                 xDoc.Save(proj);
 
                 TreeNode newFolder = new TreeNode(path.Substring(path.LastIndexOf('\\') + 1));
                 newFolder.Name = newFolder.Text;
                 newFolder.Tag = path;
                 newFolder.Nodes.Add("");
                 this.treeMain.SelectedNode.Nodes.Add(newFolder);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="769" endline="799"><![CDATA[
 
         private void tsbAddFile_Click(object sender, EventArgs e)
         {
             if (this.ofdMain.ShowDialog() == DialogResult.OK)
             {
                 string proj = this.treeMain.SelectedNode.Tag.ToString();
                 XmlDocument xDoc = new XmlDocument();
                 xDoc.Load(proj);
 
                 foreach (string file in this.ofdMain.FileNames)
                 {
                     foreach (TreeNode node in this.treeMain.SelectedNode.Nodes)
                     {
                         if (node.Tag.ToString() == file)
                         {
                             return;
                         }
                     }
                     foreach (TreeNode node in this.treeMain.SelectedNode.Nodes)
                     {
                         if (node.Tag.ToString() == file)
                         {
                             return;
                         }
                     }
                     XmlNode addNode = xDoc.CreateNode(XmlNodeType.Element, "file", null);
                     addNode.InnerText = file;
                     xDoc.FirstChild.AppendChild(addNode);
 
                     TreeNode newFile = new TreeNode(Path.GetFileName(file));
                     newFile.Name = newFile.Text;
                     newFile.Tag = file;
                     this.GetNodeImage(newFile);
                     this.treeMain.SelectedNode.Nodes.Add(newFile);
                 }
                 foreach (string file in this.ofdMain.FileNames)
                 {
                     foreach (TreeNode node in this.treeMain.SelectedNode.Nodes)
                     {
                         if (node.Tag.ToString() == file)
                         {
                             return;
                         }
                     }
                     XmlNode addNode = xDoc.CreateNode(XmlNodeType.Element, "file", null);
                     addNode.InnerText = file;
                     xDoc.FirstChild.AppendChild(addNode);
 
                     TreeNode newFile = new TreeNode(Path.GetFileName(file));
                     newFile.Name = newFile.Text;
                     newFile.Tag = file;
                     this.GetNodeImage(newFile);
                     this.treeMain.SelectedNode.Nodes.Add(newFile);
                 }
                 xDoc.Save(proj);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="800" endline="818"><![CDATA[
 
         private void tsbRefresh_Click(object sender, EventArgs e)
         {
             if (this.treeMain.SelectedNode.Parent == null)
             {
                 // Refresh the whole project...
                 foreach (TreeNode node in this.treeMain.SelectedNode.Nodes)
                 {
                     node.Collapse();
                     node.Expand();
                 }
                 foreach (TreeNode node in this.treeMain.SelectedNode.Nodes)
                 {
                     node.Collapse();
                     node.Expand();
                 }
             }
             else
             {
                 // Refresh Folder...
                 this.treeMain.SelectedNode.Collapse();
                 this.treeMain.SelectedNode.Expand();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="819" endline="823"><![CDATA[
 
         private void tsbDelete_Click(object sender, EventArgs e)
         {
             this.Delete();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="824" endline="842"><![CDATA[
 
         private void tsbOpenDir_Click(object sender, EventArgs e)
         {
             if (this.treeMain.SelectedNode != null)
             {
                 if (this.treeMain.SelectedNode.Tag != null)
                 {
                     if (this.treeMain.SelectedNode.Nodes.Count == 0)
                     {
                         System.Diagnostics.Process.Start("explorer.exe",
                             Path.GetDirectoryName(this.treeMain.SelectedNode.Tag.ToString()));
                     }
                     else
                     {
                         System.Diagnostics.Process.Start("explorer.exe", this.treeMain.SelectedNode.Tag.ToString());
                     }
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="843" endline="853"><![CDATA[
 
         #endregion
 
         #region -= Misc =-
 
         /// <summary>
         /// Gets or Sets the Context Menu used for the Root nodes...
         /// </summary>
         public ContextMenuStrip RootContextMenu
         {
             get { return this.m_ctxRoot; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="854" endline="855"><![CDATA[
 
             set { this.m_ctxRoot = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="856" endline="868"><![CDATA[
         }
 
         protected override string GetPersistString ()
         {
             string projs = "";
             foreach (TreeNode node in this.treeMain.Nodes)
             {
                 cProjectInfo pInfo = (cProjectInfo)node.Tag;
                 projs += pInfo.Path + ";";
             }
             foreach (TreeNode node in this.treeMain.Nodes)
             {
                 cProjectInfo pInfo = (cProjectInfo)node.Tag;
                 projs += pInfo.Path + ";";
             }
 
             return this.GetType().ToString() + "|" + projs.TrimEnd(new char[] { ';' });
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="869" endline="887"><![CDATA[
 
         void RemoveProject (object sender, EventArgs e)
         {
             try
             {
                 cProjectInfo pInfo = (cProjectInfo)this.treeMain.SelectedNode.Tag;
                 if (pInfo.Data != null)
                 {
                     pInfo.Data.Nodes.Clear();
                 }
                 GC.Collect();
                 this.treeMain.SelectedNode.Tag = null;
                 this.treeMain.Nodes.Remove(this.treeMain.SelectedNode);
             }
             catch (Exception ex)
             {
                 Console.WriteLine(ex.Message);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="31" endline="37"><![CDATA[
         {
             if (disposing && (components != null))
             {
                 components.Dispose();
             }
             base.Dispose(disposing);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="38" endline="207"><![CDATA[
 
         #region Component Designer generated code
 
         /// <summary> 
         /// Required method for Designer support - do not modify 
         /// the contents of this method with the code editor.
         /// </summary>
         private void InitializeComponent()
         {
             this.components = new System.ComponentModel.Container();
             System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ProjectManager));
             this.treeMain = new System.Windows.Forms.TreeView();
             this.imgMain = new System.Windows.Forms.ImageList(this.components);
             this.tsMain = new System.Windows.Forms.ToolStrip();
             this.tsbProperties = new System.Windows.Forms.ToolStripButton();
             this.toolStripSeparator1 = new System.Windows.Forms.ToolStripSeparator();
             this.tsbRefresh = new System.Windows.Forms.ToolStripButton();
             this.tsbAddFolder = new System.Windows.Forms.ToolStripButton();
             this.tsbAddFile = new System.Windows.Forms.ToolStripButton();
             this.toolStripSeparator2 = new System.Windows.Forms.ToolStripSeparator();
             this.tsbDelete = new System.Windows.Forms.ToolStripButton();
             this.fbdMain = new System.Windows.Forms.FolderBrowserDialog();
             this.ofdMain = new System.Windows.Forms.OpenFileDialog();
             this.toolStripSeparator3 = new System.Windows.Forms.ToolStripSeparator();
             this.tsbOpenDir = new System.Windows.Forms.ToolStripButton();
             this.tsMain.SuspendLayout();
             this.SuspendLayout();
             // 
             // treeMain
             // 
             this.treeMain.Dock = System.Windows.Forms.DockStyle.Fill;
             this.treeMain.ImageIndex = 0;
             this.treeMain.ImageList = this.imgMain;
             this.treeMain.Location = new System.Drawing.Point(0, 25);
             this.treeMain.Name = "treeMain";
             this.treeMain.SelectedImageIndex = 0;
             this.treeMain.Size = new System.Drawing.Size(223, 362);
             this.treeMain.TabIndex = 0;
             // 
             // imgMain
             // 
             this.imgMain.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject("imgMain.ImageStream")));
             this.imgMain.TransparentColor = System.Drawing.Color.Transparent;
             this.imgMain.Images.SetKeyName(0, "Folder.png");
             this.imgMain.Images.SetKeyName(1, "gridHam.png");
             // 
             // tsMain
             // 
             this.tsMain.GripStyle = System.Windows.Forms.ToolStripGripStyle.Hidden;
             this.tsMain.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.tsbProperties,
             this.toolStripSeparator1,
             this.tsbRefresh,
             this.tsbAddFolder,
             this.tsbAddFile,
             this.toolStripSeparator2,
             this.tsbDelete,
             this.toolStripSeparator3,
             this.tsbOpenDir});
             this.tsMain.Location = new System.Drawing.Point(0, 0);
             this.tsMain.Name = "tsMain";
             this.tsMain.Size = new System.Drawing.Size(223, 25);
             this.tsMain.TabIndex = 1;
             this.tsMain.Text = "toolStrip1";
             // 
             // tsbProperties
             // 
             this.tsbProperties.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
             this.tsbProperties.Enabled = false;
             this.tsbProperties.Image = ((System.Drawing.Image)(resources.GetObject("tsbProperties.Image")));
             this.tsbProperties.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.tsbProperties.Name = "tsbProperties";
             this.tsbProperties.Size = new System.Drawing.Size(23, 22);
             this.tsbProperties.Text = "Properties";
             this.tsbProperties.Click += new System.EventHandler(this.tsbProperties_Click);
             // 
             // toolStripSeparator1
             // 
             this.toolStripSeparator1.Name = "toolStripSeparator1";
             this.toolStripSeparator1.Size = new System.Drawing.Size(6, 25);
             // 
             // tsbRefresh
             // 
             this.tsbRefresh.Alignment = System.Windows.Forms.ToolStripItemAlignment.Right;
             this.tsbRefresh.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
             this.tsbRefresh.Enabled = false;
             this.tsbRefresh.Image = ((System.Drawing.Image)(resources.GetObject("tsbRefresh.Image")));
             this.tsbRefresh.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.tsbRefresh.Name = "tsbRefresh";
             this.tsbRefresh.Size = new System.Drawing.Size(23, 22);
             this.tsbRefresh.Text = "Refresh";
             this.tsbRefresh.Click += new System.EventHandler(this.tsbRefresh_Click);
             // 
             // tsbAddFolder
             // 
             this.tsbAddFolder.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
             this.tsbAddFolder.Enabled = false;
             this.tsbAddFolder.Image = ((System.Drawing.Image)(resources.GetObject("tsbAddFolder.Image")));
             this.tsbAddFolder.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.tsbAddFolder.Name = "tsbAddFolder";
             this.tsbAddFolder.Size = new System.Drawing.Size(23, 22);
             this.tsbAddFolder.Text = "Add Folder";
             this.tsbAddFolder.Click += new System.EventHandler(this.tsbAddFolder_Click);
             // 
             // tsbAddFile
             // 
             this.tsbAddFile.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
             this.tsbAddFile.Enabled = false;
             this.tsbAddFile.Image = ((System.Drawing.Image)(resources.GetObject("tsbAddFile.Image")));
             this.tsbAddFile.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.tsbAddFile.Name = "tsbAddFile";
             this.tsbAddFile.Size = new System.Drawing.Size(23, 22);
             this.tsbAddFile.Text = "Add File";
             this.tsbAddFile.Click += new System.EventHandler(this.tsbAddFile_Click);
             // 
             // toolStripSeparator2
             // 
             this.toolStripSeparator2.Name = "toolStripSeparator2";
             this.toolStripSeparator2.Size = new System.Drawing.Size(6, 25);
             // 
             // tsbDelete
             // 
             this.tsbDelete.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
             this.tsbDelete.Enabled = false;
             this.tsbDelete.Image = ((System.Drawing.Image)(resources.GetObject("tsbDelete.Image")));
             this.tsbDelete.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.tsbDelete.Name = "tsbDelete";
             this.tsbDelete.Size = new System.Drawing.Size(23, 22);
             this.tsbDelete.Text = "Delete";
             this.tsbDelete.Click += new System.EventHandler(this.tsbDelete_Click);
             // 
             // ofdMain
             // 
             this.ofdMain.Multiselect = true;
             // 
             // toolStripSeparator3
             // 
             this.toolStripSeparator3.Alignment = System.Windows.Forms.ToolStripItemAlignment.Right;
             this.toolStripSeparator3.Name = "toolStripSeparator3";
             this.toolStripSeparator3.Size = new System.Drawing.Size(6, 25);
             // 
             // tsbOpenDir
             // 
             this.tsbOpenDir.Alignment = System.Windows.Forms.ToolStripItemAlignment.Right;
             this.tsbOpenDir.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
             this.tsbOpenDir.Image = ((System.Drawing.Image)(resources.GetObject("tsbOpenDir.Image")));
             this.tsbOpenDir.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.tsbOpenDir.Name = "tsbOpenDir";
             this.tsbOpenDir.Size = new System.Drawing.Size(23, 22);
             this.tsbOpenDir.Text = "Open Directory";
             this.tsbOpenDir.Click += new System.EventHandler(this.tsbOpenDir_Click);
             // 
             // ProjectManager
             // 
             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.ClientSize = new System.Drawing.Size(223, 387);
             this.Controls.Add(this.treeMain);
             this.Controls.Add(this.tsMain);
             this.DockAreas = ((WeifenLuo.WinFormsUI.Docking.DockAreas)(((((WeifenLuo.WinFormsUI.Docking.DockAreas.Float | WeifenLuo.WinFormsUI.Docking.DockAreas.DockLeft)
                         | WeifenLuo.WinFormsUI.Docking.DockAreas.DockRight)
                         | WeifenLuo.WinFormsUI.Docking.DockAreas.DockTop)
                         | WeifenLuo.WinFormsUI.Docking.DockAreas.DockBottom)));
             this.Name = "ProjectManager";
             this.tsMain.ResumeLayout(false);
             this.tsMain.PerformLayout();
             this.ResumeLayout(false);
             this.PerformLayout();
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="31" endline="37"><![CDATA[
         {
             if (disposing && (components != null))
             {
                 components.Dispose();
             }
             base.Dispose(disposing);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ProjectManager.cs" startline="38" endline="456"><![CDATA[
 
         #region Windows Form Designer generated code
 
         /// <summary>
         /// Required method for Designer support - do not modify
         /// the contents of this method with the code editor.
         /// </summary>
         private void InitializeComponent()
         {
             this.components = new System.ComponentModel.Container();
             System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(Project));
             this.tabControl1 = new System.Windows.Forms.TabControl();
             this.tabPage1 = new System.Windows.Forms.TabPage();
             this.groupBox2 = new System.Windows.Forms.GroupBox();
             this.label3 = new System.Windows.Forms.Label();
             this.txtExcludeFilterFile = new System.Windows.Forms.TextBox();
             this.btnRemoveFile = new System.Windows.Forms.Button();
             this.btnAddFile = new System.Windows.Forms.Button();
             this.lstFiles = new System.Windows.Forms.ListBox();
             this.groupBox1 = new System.Windows.Forms.GroupBox();
             this.label4 = new System.Windows.Forms.Label();
             this.txtExcludeFilterFolder = new System.Windows.Forms.TextBox();
             this.btnRemoveFolder = new System.Windows.Forms.Button();
             this.btnAddFolder = new System.Windows.Forms.Button();
             this.lstFolders = new System.Windows.Forms.ListBox();
             this.label1 = new System.Windows.Forms.Label();
             this.txtProjectName = new System.Windows.Forms.TextBox();
             this.tabPage2 = new System.Windows.Forms.TabPage();
             this.clbBuildFiles = new System.Windows.Forms.CheckedListBox();
             this.btnMoveBuildFileDown = new System.Windows.Forms.Button();
             this.btnMoveBuildFileUp = new System.Windows.Forms.Button();
             this.label8 = new System.Windows.Forms.Label();
             this.btnAddBuildfile = new System.Windows.Forms.Button();
             this.label7 = new System.Windows.Forms.Label();
             this.richTextBox1 = new System.Windows.Forms.RichTextBox();
             this.btnBrowseDir = new System.Windows.Forms.Button();
             this.label6 = new System.Windows.Forms.Label();
             this.txtWorkingDir = new System.Windows.Forms.TextBox();
             this.folderBrowserDialog1 = new System.Windows.Forms.FolderBrowserDialog();
             this.openFileDialog1 = new System.Windows.Forms.OpenFileDialog();
             this.saveFileDialog1 = new System.Windows.Forms.SaveFileDialog();
             this.btnCancel = new System.Windows.Forms.Button();
             this.btnOK = new System.Windows.Forms.Button();
             this.toolTip1 = new System.Windows.Forms.ToolTip(this.components);
             this.label9 = new System.Windows.Forms.Label();
             this.label2 = new System.Windows.Forms.Label();
             this.cmbType = new System.Windows.Forms.ComboBox();
             this.tabControl1.SuspendLayout();
             this.tabPage1.SuspendLayout();
             this.groupBox2.SuspendLayout();
             this.groupBox1.SuspendLayout();
             this.tabPage2.SuspendLayout();
             this.SuspendLayout();
             // 
             // tabControl1
             // 
             this.tabControl1.Controls.Add(this.tabPage1);
             this.tabControl1.Controls.Add(this.tabPage2);
             this.tabControl1.Dock = System.Windows.Forms.DockStyle.Top;
             this.tabControl1.Location = new System.Drawing.Point(0, 0);
             this.tabControl1.Name = "tabControl1";
             this.tabControl1.SelectedIndex = 0;
             this.tabControl1.Size = new System.Drawing.Size(352, 439);
             this.tabControl1.TabIndex = 0;
             // 
             // tabPage1
             // 
             this.tabPage1.Controls.Add(this.cmbType);
             this.tabPage1.Controls.Add(this.label2);
             this.tabPage1.Controls.Add(this.groupBox2);
             this.tabPage1.Controls.Add(this.groupBox1);
             this.tabPage1.Controls.Add(this.label1);
             this.tabPage1.Controls.Add(this.txtProjectName);
             this.tabPage1.Location = new System.Drawing.Point(4, 22);
             this.tabPage1.Name = "tabPage1";
             this.tabPage1.Padding = new System.Windows.Forms.Padding(3);
             this.tabPage1.Size = new System.Drawing.Size(344, 413);
             this.tabPage1.TabIndex = 0;
             this.tabPage1.Text = "Project Settings";
             this.tabPage1.UseVisualStyleBackColor = true;
             // 
             // groupBox2
             // 
             this.groupBox2.Controls.Add(this.label3);
             this.groupBox2.Controls.Add(this.txtExcludeFilterFile);
             this.groupBox2.Controls.Add(this.btnRemoveFile);
             this.groupBox2.Controls.Add(this.btnAddFile);
             this.groupBox2.Controls.Add(this.lstFiles);
             this.groupBox2.Location = new System.Drawing.Point(8, 227);
             this.groupBox2.Name = "groupBox2";
             this.groupBox2.Size = new System.Drawing.Size(328, 181);
             this.groupBox2.TabIndex = 7;
             this.groupBox2.TabStop = false;
             this.groupBox2.Text = "Files";
             // 
             // label3
             // 
             this.label3.AutoSize = true;
             this.label3.Location = new System.Drawing.Point(219, 74);
             this.label3.Name = "label3";
             this.label3.Size = new System.Drawing.Size(70, 13);
             this.label3.TabIndex = 9;
             this.label3.Text = "Exclude Filter";
             // 
             // txtExcludeFilterFile
             // 
             this.txtExcludeFilterFile.Location = new System.Drawing.Point(222, 90);
             this.txtExcludeFilterFile.Name = "txtExcludeFilterFile";
             this.txtExcludeFilterFile.Size = new System.Drawing.Size(100, 20);
             this.txtExcludeFilterFile.TabIndex = 6;
             // 
             // btnRemoveFile
             // 
             this.btnRemoveFile.Location = new System.Drawing.Point(222, 48);
             this.btnRemoveFile.Name = "btnRemoveFile";
             this.btnRemoveFile.Size = new System.Drawing.Size(100, 23);
             this.btnRemoveFile.TabIndex = 5;
             this.btnRemoveFile.Text = "Remove";
             this.btnRemoveFile.UseVisualStyleBackColor = true;
             this.btnRemoveFile.Click += new System.EventHandler(this.btnRemoveFile_Click);
             // 
             // btnAddFile
             // 
             this.btnAddFile.Location = new System.Drawing.Point(222, 19);
             this.btnAddFile.Name = "btnAddFile";
             this.btnAddFile.Size = new System.Drawing.Size(100, 23);
             this.btnAddFile.TabIndex = 4;
             this.btnAddFile.Text = "Add";
             this.btnAddFile.UseVisualStyleBackColor = true;
             this.btnAddFile.Click += new System.EventHandler(this.btnAddFile_Click);
             // 
             // lstFiles
             // 
             this.lstFiles.FormattingEnabled = true;
             this.lstFiles.Location = new System.Drawing.Point(6, 19);
             this.lstFiles.Name = "lstFiles";
             this.lstFiles.Size = new System.Drawing.Size(207, 147);
             this.lstFiles.TabIndex = 3;
             // 
             // groupBox1
             // 
             this.groupBox1.Controls.Add(this.label4);
             this.groupBox1.Controls.Add(this.txtExcludeFilterFolder);
             this.groupBox1.Controls.Add(this.btnRemoveFolder);
             this.groupBox1.Controls.Add(this.btnAddFolder);
             this.groupBox1.Controls.Add(this.lstFolders);
             this.groupBox1.Location = new System.Drawing.Point(8, 57);
             this.groupBox1.Name = "groupBox1";
             this.groupBox1.Size = new System.Drawing.Size(328, 164);
             this.groupBox1.TabIndex = 6;
             this.groupBox1.TabStop = false;
             this.groupBox1.Text = "Folders";
             // 
             // label4
             // 
             this.label4.AutoSize = true;
             this.label4.Location = new System.Drawing.Point(219, 74);
             this.label4.Name = "label4";
             this.label4.Size = new System.Drawing.Size(70, 13);
             this.label4.TabIndex = 15;
             this.label4.Text = "Exclude Filter";
             // 
             // txtExcludeFilterFolder
             // 
             this.txtExcludeFilterFolder.Location = new System.Drawing.Point(222, 90);
             this.txtExcludeFilterFolder.Name = "txtExcludeFilterFolder";
             this.txtExcludeFilterFolder.Size = new System.Drawing.Size(100, 20);
             this.txtExcludeFilterFolder.TabIndex = 12;
             // 
             // btnRemoveFolder
             // 
             this.btnRemoveFolder.Location = new System.Drawing.Point(222, 48);
             this.btnRemoveFolder.Name = "btnRemoveFolder";
             this.btnRemoveFolder.Size = new System.Drawing.Size(100, 23);
             this.btnRemoveFolder.TabIndex = 11;
             this.btnRemoveFolder.Text = "Remove";
             this.btnRemoveFolder.UseVisualStyleBackColor = true;
             this.btnRemoveFolder.Click += new System.EventHandler(this.btnRemoveFolder_Click);
             // 
             // btnAddFolder
             // 
             this.btnAddFolder.Location = new System.Drawing.Point(222, 19);
             this.btnAddFolder.Name = "btnAddFolder";
             this.btnAddFolder.Size = new System.Drawing.Size(100, 23);
             this.btnAddFolder.TabIndex = 10;
             this.btnAddFolder.Text = "Add";
             this.btnAddFolder.UseVisualStyleBackColor = true;
             this.btnAddFolder.Click += new System.EventHandler(this.btnAddFolder_Click);
             // 
             // lstFolders
             // 
             this.lstFolders.FormattingEnabled = true;
             this.lstFolders.Location = new System.Drawing.Point(6, 19);
             this.lstFolders.Name = "lstFolders";
             this.lstFolders.Size = new System.Drawing.Size(207, 134);
             this.lstFolders.TabIndex = 2;
             // 
             // label1
             // 
             this.label1.AutoSize = true;
             this.label1.Location = new System.Drawing.Point(8, 11);
             this.label1.Name = "label1";
             this.label1.Size = new System.Drawing.Size(74, 13);
             this.label1.TabIndex = 1;
             this.label1.Text = "Project Name
             // 
             // txtProjectName
             // 
             this.txtProjectName.Location = new System.Drawing.Point(88, 8);
             this.txtProjectName.Name = "txtProjectName";
             this.txtProjectName.Size = new System.Drawing.Size(248, 20);
             this.txtProjectName.TabIndex = 0;
             // 
             // tabPage2
             // 
             this.tabPage2.Controls.Add(this.label9);
             this.tabPage2.Controls.Add(this.clbBuildFiles);
             this.tabPage2.Controls.Add(this.btnMoveBuildFileDown);
             this.tabPage2.Controls.Add(this.btnMoveBuildFileUp);
             this.tabPage2.Controls.Add(this.label8);
             this.tabPage2.Controls.Add(this.btnAddBuildfile);
             this.tabPage2.Controls.Add(this.label7);
             this.tabPage2.Controls.Add(this.richTextBox1);
             this.tabPage2.Controls.Add(this.btnBrowseDir);
             this.tabPage2.Controls.Add(this.label6);
             this.tabPage2.Controls.Add(this.txtWorkingDir);
             this.tabPage2.Location = new System.Drawing.Point(4, 22);
             this.tabPage2.Name = "tabPage2";
             this.tabPage2.Padding = new System.Windows.Forms.Padding(3);
             this.tabPage2.Size = new System.Drawing.Size(344, 413);
             this.tabPage2.TabIndex = 1;
             this.tabPage2.Text = "Build Settings";
             this.tabPage2.UseVisualStyleBackColor = true;
             // 
             // clbBuildFiles
             // 
             this.clbBuildFiles.FormattingEnabled = true;
             this.clbBuildFiles.Location = new System.Drawing.Point(8, 309);
             this.clbBuildFiles.Name = "clbBuildFiles";
             this.clbBuildFiles.Size = new System.Drawing.Size(296, 79);
             this.clbBuildFiles.TabIndex = 12;
             this.toolTip1.SetToolTip(this.clbBuildFiles, "Checked Items will Run Before Build, Unchecked Items will Run After Build");
             // 
             // btnMoveBuildFileDown
             // 
             this.btnMoveBuildFileDown.Image = ((System.Drawing.Image)(resources.GetObject("btnMoveBuildFileDown.Image")));
             this.btnMoveBuildFileDown.Location = new System.Drawing.Point(311, 367);
             this.btnMoveBuildFileDown.Name = "btnMoveBuildFileDown";
             this.btnMoveBuildFileDown.Size = new System.Drawing.Size(25, 23);
             this.btnMoveBuildFileDown.TabIndex = 11;
             this.toolTip1.SetToolTip(this.btnMoveBuildFileDown, "Move Selected File Down");
             this.btnMoveBuildFileDown.UseVisualStyleBackColor = true;
             this.btnMoveBuildFileDown.Click += new System.EventHandler(this.btnMoveBuildFileDown_Click);
             // 
             // btnMoveBuildFileUp
             // 
             this.btnMoveBuildFileUp.Image = ((System.Drawing.Image)(resources.GetObject("btnMoveBuildFileUp.Image")));
             this.btnMoveBuildFileUp.Location = new System.Drawing.Point(311, 338);
             this.btnMoveBuildFileUp.Name = "btnMoveBuildFileUp";
             this.btnMoveBuildFileUp.Size = new System.Drawing.Size(25, 23);
             this.btnMoveBuildFileUp.TabIndex = 10;
             this.toolTip1.SetToolTip(this.btnMoveBuildFileUp, "Move Selected File Up");
             this.btnMoveBuildFileUp.UseVisualStyleBackColor = true;
             this.btnMoveBuildFileUp.Click += new System.EventHandler(this.btnMoveBuildFileUp_Click);
             // 
             // label8
             // 
             this.label8.AutoSize = true;
             this.label8.Location = new System.Drawing.Point(8, 293);
             this.label8.Name = "label8";
             this.label8.Size = new System.Drawing.Size(106, 13);
             this.label8.TabIndex = 9;
             this.label8.Text = "Additional Build Files
             // 
             // btnAddBuildfile
             // 
             this.btnAddBuildfile.Image = ((System.Drawing.Image)(resources.GetObject("btnAddBuildfile.Image")));
             this.btnAddBuildfile.Location = new System.Drawing.Point(311, 309);
             this.btnAddBuildfile.Name = "btnAddBuildfile";
             this.btnAddBuildfile.Size = new System.Drawing.Size(25, 23);
             this.btnAddBuildfile.TabIndex = 7;
             this.toolTip1.SetToolTip(this.btnAddBuildfile, "Add File");
             this.btnAddBuildfile.UseVisualStyleBackColor = true;
             this.btnAddBuildfile.Click += new System.EventHandler(this.btnAddBuildfile_Click);
             // 
             // label7
             // 
             this.label7.AutoSize = true;
             this.label7.Location = new System.Drawing.Point(8, 45);
             this.label7.Name = "label7";
             this.label7.Size = new System.Drawing.Size(63, 13);
             this.label7.TabIndex = 6;
             this.label7.Text = "Build Script
             // 
             // richTextBox1
             // 
             this.richTextBox1.Location = new System.Drawing.Point(9, 61);
             this.richTextBox1.Name = "richTextBox1";
             this.richTextBox1.Size = new System.Drawing.Size(327, 229);
             this.richTextBox1.TabIndex = 3;
             this.richTextBox1.Text = "";
             // 
             // btnBrowseDir
             // 
             this.btnBrowseDir.Location = new System.Drawing.Point(311, 19);
             this.btnBrowseDir.Name = "btnBrowseDir";
             this.btnBrowseDir.Size = new System.Drawing.Size(25, 23);
             this.btnBrowseDir.TabIndex = 2;
             this.btnBrowseDir.Text = "...";
             this.btnBrowseDir.UseVisualStyleBackColor = true;
             this.btnBrowseDir.Click += new System.EventHandler(this.btnBrowseDir_Click);
             // 
             // label6
             // 
             this.label6.AutoSize = true;
             this.label6.Location = new System.Drawing.Point(6, 6);
             this.label6.Name = "label6";
             this.label6.Size = new System.Drawing.Size(95, 13);
             this.label6.TabIndex = 1;
             this.label6.Text = "Working Directory
             // 
             // txtWorkingDir
             // 
             this.txtWorkingDir.Location = new System.Drawing.Point(9, 22);
             this.txtWorkingDir.Name = "txtWorkingDir";
             this.txtWorkingDir.Size = new System.Drawing.Size(296, 20);
             this.txtWorkingDir.TabIndex = 0;
             // 
             // openFileDialog1
             // 
             this.openFileDialog1.FileName = "openFileDialog1";
             this.openFileDialog1.Multiselect = true;
             // 
             // saveFileDialog1
             // 
             this.saveFileDialog1.DefaultExt = "pproj";
             this.saveFileDialog1.Filter = "Peter Project (*.pproj)|*.pproj";
             // 
             // btnCancel
             // 
             this.btnCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
             this.btnCancel.Location = new System.Drawing.Point(268, 445);
             this.btnCancel.Name = "btnCancel";
             this.btnCancel.Size = new System.Drawing.Size(75, 23);
             this.btnCancel.TabIndex = 11;
             this.btnCancel.Text = "Cancel";
             this.btnCancel.UseVisualStyleBackColor = true;
             // 
             // btnOK
             // 
             this.btnOK.Location = new System.Drawing.Point(187, 445);
             this.btnOK.Name = "btnOK";
             this.btnOK.Size = new System.Drawing.Size(75, 23);
             this.btnOK.TabIndex = 10;
             this.btnOK.Text = "Ok";
             this.btnOK.UseVisualStyleBackColor = true;
             this.btnOK.Click += new System.EventHandler(this.btnOK_Click);
             // 
             // label9
             // 
             this.label9.AutoSize = true;
             this.label9.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Italic, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
             this.label9.Location = new System.Drawing.Point(5, 391);
             this.label9.Name = "label9";
             this.label9.Size = new System.Drawing.Size(317, 13);
             this.label9.TabIndex = 13;
             this.label9.Text = "(Checked Items Run Before Build Script/Un-Checked After Script)";
             // 
             // label2
             // 
             this.label2.AutoSize = true;
             this.label2.Location = new System.Drawing.Point(8, 37);
             this.label2.Name = "label2";
             this.label2.Size = new System.Drawing.Size(70, 13);
             this.label2.TabIndex = 8;
             this.label2.Text = "Project Type
             // 
             // cmbType
             // 
             this.cmbType.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
             this.cmbType.FormattingEnabled = true;
             this.cmbType.Items.AddRange(new object[] {
             "None",
             "C Project",
             "C++ Project",
             "C# Project",
             "Java Project"});
             this.cmbType.Location = new System.Drawing.Point(88, 34);
             this.cmbType.Name = "cmbType";
             this.cmbType.Size = new System.Drawing.Size(248, 21);
             this.cmbType.TabIndex = 9;
             this.toolTip1.SetToolTip(this.cmbType, "The type of project, so Peter knows how to parse your source code.");
             // 
             // Project
             // 
             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.ClientSize = new System.Drawing.Size(352, 476);
             this.Controls.Add(this.btnCancel);
             this.Controls.Add(this.btnOK);
             this.Controls.Add(this.tabControl1);
             this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedToolWindow;
             this.Name = "Project";
             this.ShowInTaskbar = false;
             this.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide;
             this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
             this.Text = "Project";
             this.tabControl1.ResumeLayout(false);
             this.tabPage1.ResumeLayout(false);
             this.tabPage1.PerformLayout();
             this.groupBox2.ResumeLayout(false);
             this.groupBox2.PerformLayout();
             this.groupBox1.ResumeLayout(false);
             this.groupBox1.PerformLayout();
             this.tabPage2.ResumeLayout(false);
             this.tabPage2.PerformLayout();
             this.ResumeLayout(false);
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="24" endline="35"><![CDATA[
         private System.ComponentModel.IContainer components = null;
         public Project()
         {
             InitializeComponent();
 
             this.m_ProjectFile = null;
             this.cmbType.SelectedIndex = 0;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="36" endline="121"><![CDATA[
 
         /// <summary>
         /// Sets project properties from project file
         /// </summary>
         /// <param name="filePath">The full path to the project file</param>
         public void SetProjectFile(string filePath)
         {
             try
             {
                 this.m_ProjectFile = filePath;
                 XmlDocument xDoc = new XmlDocument();
                 xDoc.Load(filePath);
                 XmlNodeList nodes = xDoc.GetElementsByTagName("name");
                 if (nodes.Count > 0)
                 {
                     this.txtProjectName.Text = nodes[0].InnerText;
                 }
 
                 nodes = xDoc.GetElementsByTagName("type");
                 if (nodes.Count > 0)
                 {
                     this.cmbType.SelectedItem = nodes[0].InnerText;
                 }
 
                 nodes = xDoc.GetElementsByTagName("folder");
                 foreach (XmlNode node in nodes)
                 {
                     this.lstFolders.Items.Add(node.InnerText);
                 }
                 foreach (XmlNode node in nodes)
                 {
                     this.lstFolders.Items.Add(node.InnerText);
                 }
 
                 nodes = xDoc.GetElementsByTagName("file");
                 foreach (XmlNode node in nodes)
                 {
                     this.lstFiles.Items.Add(node.InnerText);
                 }
                 foreach (XmlNode node in nodes)
                 {
                     this.lstFiles.Items.Add(node.InnerText);
                 }
 
                 nodes = xDoc.GetElementsByTagName("WorkingDir");
                 if (nodes.Count > 0)
                 {
                     this.txtWorkingDir.Text = nodes[0].InnerText;
                 }
 
                 nodes = xDoc.GetElementsByTagName("BuildScript");
                 if (nodes.Count > 0)
                 {
                     this.richTextBox1.Text = nodes[0].InnerText;
                 }
 
                 nodes = xDoc.GetElementsByTagName("ExcludeFolderFilter");
                 if (nodes.Count > 0)
                 {
                     this.txtExcludeFilterFolder.Text = nodes[0].InnerText;
                 }
 
                 nodes = xDoc.GetElementsByTagName("ExcludeFileFilter");
                 if (nodes.Count > 0)
                 {
                     this.txtExcludeFilterFile.Text = nodes[0].InnerText;
                 }
 
                 nodes = xDoc.GetElementsByTagName("BuildFile");
                 foreach (XmlNode node in nodes)
                 {
                     string file = "";
                     bool check = false;
 
                     foreach (XmlNode cNode in node.ChildNodes)
                     {
                         if (cNode.Name.ToLower() == "file")
                         {
                             file = cNode.InnerText;
                         }
                         if (cNode.Name.ToLower() == "prebuild")
                         {
                             check = Convert.ToBoolean(cNode.InnerText);
                         }
                     }
                     foreach (XmlNode cNode in node.ChildNodes)
                     {
                         if (cNode.Name.ToLower() == "file")
                         {
                             file = cNode.InnerText;
                         }
                         if (cNode.Name.ToLower() == "prebuild")
                         {
                             check = Convert.ToBoolean(cNode.InnerText);
                         }
                     }
 
                     this.clbBuildFiles.Items.Add(file, check);
                 }
                 foreach (XmlNode node in nodes)
                 {
                     string file = "";
                     bool check = false;
 
                     foreach (XmlNode cNode in node.ChildNodes)
                     {
                         if (cNode.Name.ToLower() == "file")
                         {
                             file = cNode.InnerText;
                         }
                         if (cNode.Name.ToLower() == "prebuild")
                         {
                             check = Convert.ToBoolean(cNode.InnerText);
                         }
                     }
 
                     this.clbBuildFiles.Items.Add(file, check);
                 }
             }
             catch (Exception ex)
             {
                 Console.WriteLine(ex.Message);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="122" endline="128"><![CDATA[
 
         /// <summary>
         /// Gets the location of the project...
         /// </summary>
         public string ProjectFile
         {
             get { return this.m_ProjectFile; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="129" endline="142"><![CDATA[
         }
 
         /// <summary>
         /// Adds a folder to the project
         /// </summary>
         /// <param name="sender">Project dialog Folder Add button</param>
         /// <param name="e">Events</param>
         private void btnAddFolder_Click(object sender, EventArgs e)
         {
             if (this.folderBrowserDialog1.ShowDialog() == DialogResult.OK)
             {
                 this.lstFolders.Items.Add(this.folderBrowserDialog1.SelectedPath);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="143" endline="155"><![CDATA[
 
         /// <summary>
         /// Removes a folder from the project
         /// </summary>
         /// <param name="sender">Project dialog Folder Remove button</param>
         /// <param name="e">Events</param>
         private void btnRemoveFolder_Click(object sender, EventArgs e)
         {
             if (this.lstFolders.SelectedIndex >= 0)
             {
                 this.lstFolders.Items.Remove(this.lstFolders.SelectedItem);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="156" endline="171"><![CDATA[
 
         /// <summary>
         /// Adds a file to the project
         /// </summary>
         /// <param name="sender">Project dialog File Add button</param>
         /// <param name="e">Events</param>
         private void btnAddFile_Click(object sender, EventArgs e)
         {
             if (this.openFileDialog1.ShowDialog() == DialogResult.OK)
             {
                 foreach (string file in this.openFileDialog1.FileNames)
                 {
                     this.lstFiles.Items.Add(file);
                 }
                 foreach (string file in this.openFileDialog1.FileNames)
                 {
                     this.lstFiles.Items.Add(file);
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="172" endline="184"><![CDATA[
 
         /// <summary>
         /// Removes a file from the project
         /// </summary>
         /// <param name="sender">Project dialog File Remove button</param>
         /// <param name="e">Events</param>
         private void btnRemoveFile_Click(object sender, EventArgs e)
         {
             if (this.lstFiles.SelectedIndex >= 0)
             {
                 this.lstFiles.Items.Remove(this.lstFiles.SelectedItem);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="185" endline="219"><![CDATA[
 
         /// <summary>
         /// Saves the project information to the specified file
         /// </summary>
         /// <param name="sender">Project dialog OK button</param>
         /// <param name="e">Events</param>
         private void btnOK_Click(object sender, EventArgs e)
         {
             if (string.IsNullOrEmpty(this.txtProjectName.Text.Trim()))
             {
                 MessageBox.Show("Please enter a Project Name.", "Peter", MessageBoxButtons.OK, MessageBoxIcon.Error);
             }
             else
             {
                 if (string.IsNullOrEmpty(this.m_ProjectFile))
                 {
                     if (this.saveFileDialog1.ShowDialog() == DialogResult.OK)
                     {
                         this.WriteXML(this.saveFileDialog1.FileName);
                         this.m_ProjectFile = this.saveFileDialog1.FileName;
                         this.Hide();
                     }
                 }
                 else
                 {
                     if (File.Exists(this.m_ProjectFile))
                     {
                         File.Delete(this.m_ProjectFile);
                     }
 
                     this.WriteXML(this.m_ProjectFile);
                     this.Close();
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="220" endline="299"><![CDATA[
 
         /// <summary>
         /// Writes the project information using xml to the specified file name
         /// </summary>
         /// <param name="fileName">The name of the file to write to</param>
         private void WriteXML(string fileName)
         {
             XmlTextWriter writer = new XmlTextWriter(fileName, Encoding.Unicode);
             try
             {
                 writer.Indentation = 4;
                 writer.Formatting = Formatting.Indented;
                 writer.WriteStartElement("PeterProject");
 
                 // Project Name...
                 writer.WriteStartElement("name");
                 writer.WriteValue(this.txtProjectName.Text);
                 writer.WriteEndElement();
 
                 // Project Type...
                 writer.WriteStartElement("type");
                 writer.WriteValue(this.cmbType.SelectedItem.ToString());
                 writer.WriteEndElement();
 
                 // Folders...
                 for (int a = 0; a < this.lstFolders.Items.Count; a++)
                 {
                     writer.WriteStartElement("folder");
                     writer.WriteValue(this.lstFolders.Items[a].ToString());
                     writer.WriteEndElement();
                 }
                 for (int a = 0; a < this.lstFolders.Items.Count; a++)
                 {
                     writer.WriteStartElement("folder");
                     writer.WriteValue(this.lstFolders.Items[a].ToString());
                     writer.WriteEndElement();
                 }
 
                 // Files...
                 for (int a = 0; a < this.lstFiles.Items.Count; a++)
                 {
                     writer.WriteStartElement("file");
                     writer.WriteValue(this.lstFiles.Items[a].ToString());
                     writer.WriteEndElement();
                 }
                 for (int a = 0; a < this.lstFiles.Items.Count; a++)
                 {
                     writer.WriteStartElement("file");
                     writer.WriteValue(this.lstFiles.Items[a].ToString());
                     writer.WriteEndElement();
                 }
 
                 // Filter Settings...
                 writer.WriteStartElement("ExcludeFolderFilter");
                 writer.WriteValue(this.txtExcludeFilterFolder.Text);
                 writer.WriteEndElement();
                 writer.WriteStartElement("ExcludeFileFilter");
                 writer.WriteValue(this.txtExcludeFilterFile.Text);
                 writer.WriteEndElement();
 
                 // Build Settings...
                 writer.WriteStartElement("BuildSettings");
                 // Working Directory...
                 writer.WriteStartElement("WorkingDir");
                 writer.WriteValue(this.txtWorkingDir.Text.Trim());
                 writer.WriteEndElement();
                 // Build Script..
                 writer.WriteStartElement("BuildScript");
                 writer.WriteValue(this.richTextBox1.Text);
                 writer.WriteEndElement();
                 // Build Files..
                 for (int a = 0; a < this.clbBuildFiles.Items.Count; a++)
                 {
                     writer.WriteStartElement("BuildFile");
                     writer.WriteStartElement("PreBuild");
                     writer.WriteValue(this.clbBuildFiles.GetItemChecked(a).ToString());
                     writer.WriteEndElement();
                     writer.WriteStartElement("file");
                     writer.WriteValue(this.clbBuildFiles.Items[a].ToString());
                     writer.WriteEndElement();
                     writer.WriteEndElement();
                 }
                 for (int a = 0; a < this.clbBuildFiles.Items.Count; a++)
                 {
                     writer.WriteStartElement("BuildFile");
                     writer.WriteStartElement("PreBuild");
                     writer.WriteValue(this.clbBuildFiles.GetItemChecked(a).ToString());
                     writer.WriteEndElement();
                     writer.WriteStartElement("file");
                     writer.WriteValue(this.clbBuildFiles.Items[a].ToString());
                     writer.WriteEndElement();
                     writer.WriteEndElement();
                 }
                 writer.WriteEndElement();
 
                 writer.WriteEndElement();
             }
             finally
             {
                 writer.Flush();
                 writer.Close();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="300" endline="312"><![CDATA[
 
         /// <summary>
         /// Opens a file dialog to set the working directory
         /// </summary>
         /// <param name="sender">Project Dialog Build Settings browse button</param>
         /// <param name="e">Events</param>
         private void btnBrowseDir_Click(object sender, EventArgs e)
         {
             if (this.folderBrowserDialog1.ShowDialog() == DialogResult.OK)
             {
                 this.txtWorkingDir.Text = this.folderBrowserDialog1.SelectedPath;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="313" endline="331"><![CDATA[
 
         /// <summary>
         /// Moves the selected build file up
         /// </summary>
         /// <param name="sender">Project Dialog Build Settings move build file up button</param>
         /// <param name="e">Events</param>
         private void btnMoveBuildFileUp_Click(object sender, EventArgs e)
         {
             if (this.clbBuildFiles.SelectedIndex == 0)
             {
                 return;
             }
 
             int index = this.clbBuildFiles.SelectedIndex;
             object item = this.clbBuildFiles.Items[index];
             this.clbBuildFiles.Items.Remove(item);
             this.clbBuildFiles.Items.Insert(index - 1, item);
             this.clbBuildFiles.SelectedIndex = index - 1;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="332" endline="350"><![CDATA[
 
         /// <summary>
         /// Moves the selected build file down
         /// </summary>
         /// <param name="sender">Project Dialog Build Settings move build file down button</param>
         /// <param name="e">Events</param>
         private void btnMoveBuildFileDown_Click(object sender, EventArgs e)
         {
             if (this.clbBuildFiles.SelectedIndex == this.clbBuildFiles.Items.Count - 1)
             {
                 return;
             }
 
             int index = this.clbBuildFiles.SelectedIndex;
             object item = this.clbBuildFiles.Items[index];
             this.clbBuildFiles.Items.Remove(item);
             this.clbBuildFiles.Items.Insert(index + 1, item);
             this.clbBuildFiles.SelectedIndex = index + 1;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="351" endline="366"><![CDATA[
 
         /// <summary>
         /// Adds a build file to the project
         /// </summary>
         /// <param name="sender">Project Dialog Build Settings add build file button</param>
         /// <param name="e">Events</param>
         private void btnAddBuildfile_Click(object sender, EventArgs e)
         {
             if (this.openFileDialog1.ShowDialog() == DialogResult.OK)
             {
                 foreach (string file in this.openFileDialog1.FileNames)
                 {
                     this.clbBuildFiles.Items.Add(file);
                 }
                 foreach (string file in this.openFileDialog1.FileNames)
                 {
                     this.clbBuildFiles.Items.Add(file);
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="60" endline="80"><![CDATA[
         {
             IntPtr hWnd = IntPtr.Zero;
             Process process = Process.GetCurrentProcess();
             Process[] processes = Process.GetProcessesByName(process.ProcessName);
             foreach (Process _process in processes)
             {
                 // Get the first instance that is not this instance, has the
                 // same process name and was started from the same file name
                 // and location. Also check that the process has a valid
                 // window handle in this session to filter out other user's
                 // processes.
                 if (_process.Id != process.Id &&
                     _process.MainModule.FileName == process.MainModule.FileName &&
                     _process.MainWindowHandle != IntPtr.Zero)
                 {
                     hWnd = _process.MainWindowHandle;
                     break;
                 }
             }
             foreach (Process _process in processes)
             {
                 // Get the first instance that is not this instance, has the
                 // same process name and was started from the same file name
                 // and location. Also check that the process has a valid
                 // window handle in this session to filter out other user's
                 // processes.
                 if (_process.Id != process.Id &&
                     _process.MainModule.FileName == process.MainModule.FileName &&
                     _process.MainWindowHandle != IntPtr.Zero)
                 {
                     hWnd = _process.MainWindowHandle;
                     break;
                 }
             }
             return hWnd;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="81" endline="115"><![CDATA[
 
         /// <summary>
         /// SwitchToCurrentInstance
         /// </summary>
         private static void SwitchToCurrentInstance(List<string> args)
         {
             IntPtr hWnd = GetCurrentInstanceWindowHandle();
             if (hWnd != IntPtr.Zero)
             {
                 // Send arguments...
                 if (args.Count > 0)
                 {
                     string data = "";
                     foreach (string arg in args)
                     {
                         data += arg + "|";
                     }
                     foreach (string arg in args)
                     {
                         data += arg + "|";
                     }
                     CopyDataStruct str = new CopyDataStruct(data);
                     IntPtr pnt = Marshal.AllocHGlobal(Marshal.SizeOf(str));
                     Marshal.StructureToPtr(str, pnt, false);
                     SendMessage(hWnd, WM_COPYDATA, IntPtr.Zero, pnt);
                 }
 
                 // Restore window if minimised. Do not restore if already in
                 // normal or maximised window state, since we don't want to
                 // change the current state of the window.
                 if (IsIconic(hWnd) != 0)
                 {
                     ShowWindow(hWnd, SW_RESTORE);
                 }
 
                 // Set foreground window.
                 SetForegroundWindow(hWnd);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="116" endline="133"><![CDATA[
 
         /// <summary>
         /// check if given exe alread running or not
         /// </summary>
         /// <returns>returns true if already running</returns>
         private static bool IsAlreadyRunning()
         {
             string strLoc = Assembly.GetExecutingAssembly().Location;
             FileSystemInfo fileInfo = new FileInfo(strLoc);
             string sExeName = fileInfo.Name;
             bool bCreatedNew;
 
             mutex = new Mutex(true, "Global\\" + sExeName, out bCreatedNew);
             if (bCreatedNew)
                 mutex.ReleaseMutex();
 
             return !bCreatedNew;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="134" endline="154"><![CDATA[
 
         /// <summary>
         /// The main entry point for the application.
         /// </summary>
         [STAThread]
         static void Main(string[] args)
         {
             List<string> argList = new List<string>();
             argList.AddRange(args);
 
             if (IsAlreadyRunning() && args.Length > 0)
             {
                 SwitchToCurrentInstance(argList);
             }
             else
             {
                 Application.EnableVisualStyles();
                 Application.SetCompatibleTextRenderingDefault(false);
                 Application.Run(new MainForm(argList));
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="155" endline="162"><![CDATA[
 
         static void myReceive(string[] args)
         {
             for (int i = 0; i < args.Length; i++)
             {
                 Console.WriteLine("MSG " + i.ToString() + "
             }
             for (int i = 0; i < args.Length; i++)
             {
                 Console.WriteLine("MSG " + i.ToString() + "
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="163" endline="176"><![CDATA[
     }
 
     public struct CopyDataStruct
     {
         public int dwData;
         public int cbData;
         public string lpData;
 
         public CopyDataStruct(string data)
         {
             this.lpData = data + "\0";
             this.cbData = data.Length;
             this.dwData = 0;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="20" endline="20"><![CDATA[
             get { return tagtype; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="21" endline="21"><![CDATA[
             set { tagtype = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="22" endline="28"><![CDATA[
         }
 
         /// <summary></summary>
         public bool IsIDSelector
         {
             //get { return (int)(this.tagtype & TagType.IDed) > 0; }
             get { return id != null; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="29" endline="34"><![CDATA[
         }
 
         /// <summary></summary>
         public bool HasName
         {
             get { return name != null; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="35" endline="40"><![CDATA[
         }
 
         /// <summary></summary>
         public bool HasClass
         {
             get { return cls != null; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="41" endline="46"><![CDATA[
         }
 
         /// <summary></summary>
         public bool HasPseudoClass
         {
             get { return pseudo != null; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="47" endline="52"><![CDATA[
         }
 
         /// <summary></summary>
         public string Name
         {
             get { return name; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="53" endline="53"><![CDATA[
             set { name = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="54" endline="59"><![CDATA[
         }
 
         /// <summary></summary>
         public string Class
         {
             get { return cls; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="60" endline="60"><![CDATA[
             set { cls = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="61" endline="66"><![CDATA[
         }
 
         /// <summary></summary>
         public string Pseudo
         {
             get { return pseudo; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="67" endline="67"><![CDATA[
             set { pseudo = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="68" endline="73"><![CDATA[
         }
 
         /// <summary></summary>
         public string Id
         {
             get { return id; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="74" endline="74"><![CDATA[
             set { id = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="75" endline="80"><![CDATA[
         }
 
         /// <summary></summary>
         public List<Tag> SubTags
         {
             get { return subtags; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="81" endline="81"><![CDATA[
             set { subtags = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="82" endline="96"><![CDATA[
         }
 
         /// <summary></summary>
         /// <returns></returns>
         public override string ToString()
         {
             System.Text.StringBuilder txt = new System.Text.StringBuilder(ToShortString());
 
             foreach (Tag t in subtags)
             {
                 txt.Append(" ");
                 txt.Append(t.ToString());
             }
             foreach (Tag t in subtags)
             {
                 txt.Append(" ");
                 txt.Append(t.ToString());
             }
             return txt.ToString();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="97" endline="123"><![CDATA[
 
         /// <summary></summary>
         /// <returns></returns>
         public string ToShortString()
         {
             System.Text.StringBuilder txt = new System.Text.StringBuilder();
             if (HasName)
             {
                 txt.Append(name);
             }
             if (HasClass)
             {
                 txt.Append(".");
                 txt.Append(cls);
             }
             if (IsIDSelector)
             {
                 txt.Append("#");
                 txt.Append(id);
             }
             if (HasPseudoClass)
             {
                 txt.Append("
                 txt.Append(pseudo);
             }
             return txt.ToString();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="15" endline="15"><![CDATA[
         private List<Tag> subtags = new List<Tag>();
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="31" endline="37"><![CDATA[
         {
             if (disposing && (components != null))
             {
                 components.Dispose();
             }
             base.Dispose(disposing);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Project.cs" startline="38" endline="80"><![CDATA[
 
         #region Windows Form Designer generated code
 
         /// <summary>
         /// Required method for Designer support - do not modify
         /// the contents of this method with the code editor.
         /// </summary>
         private void InitializeComponent()
         {
             this.components = new System.ComponentModel.Container();
             this.treeMain = new System.Windows.Forms.TreeView();
             this.imgMain = new System.Windows.Forms.ImageList(this.components);
             this.SuspendLayout();
             // 
             // treeMain
             // 
             this.treeMain.Dock = System.Windows.Forms.DockStyle.Fill;
             this.treeMain.ImageIndex = 0;
             this.treeMain.ImageList = this.imgMain;
             this.treeMain.Location = new System.Drawing.Point(0, 0);
             this.treeMain.Name = "treeMain";
             this.treeMain.SelectedImageIndex = 0;
             this.treeMain.Size = new System.Drawing.Size(292, 273);
             this.treeMain.TabIndex = 0;
             // 
             // imgMain
             // 
             this.imgMain.ColorDepth = System.Windows.Forms.ColorDepth.Depth8Bit;
             this.imgMain.ImageSize = new System.Drawing.Size(16, 16);
             this.imgMain.TransparentColor = System.Drawing.Color.Transparent;
             // 
             // FindResults
             // 
             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.ClientSize = new System.Drawing.Size(292, 273);
             this.Controls.Add(this.treeMain);
             this.Name = "FindResults";
             this.TabText = "FindResults";
             this.Text = "FindResults";
             this.ResumeLayout(false);
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="24" endline="35"><![CDATA[
         private System.ComponentModel.IContainer components = null;
         public FindResults()
         {
             InitializeComponent(); 
             System.Resources.ResourceManager mngr = new System.Resources.ResourceManager("Peter.InternalImages", this.GetType().Assembly);
             this.imgMain.Images.Add("Next", (Image)mngr.GetObject("Next"));
             this.TabText = "Find Results";
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="36" endline="42"><![CDATA[
 
         /// <summary>
         /// Gets or Sets the Tree View...
         /// </summary>
         public TreeView Tree
         {
             get { return this.treeMain; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="43" endline="44"><![CDATA[
 
             set { this.treeMain = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="45" endline="52"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets the Image List...
         /// </summary>
         public ImageList Images
         {
             get { return this.imgMain; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="53" endline="54"><![CDATA[
 
             set { this.imgMain = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="55" endline="66"><![CDATA[
         }
 
         /// <summary>
         /// Overrides the Close Action...
         /// </summary>
         /// <param name="e">Cancel Events.</param>
         protected override void OnClosing(CancelEventArgs e)
         {
             e.Cancel = true;
             this.Hide();
             base.OnClosing(e);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="67" endline="72"><![CDATA[
 
         #region IPeterPluginTab Members
 
         public void Save()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="73" endline="76"><![CDATA[
 
         public void SaveAs(string filePath)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="77" endline="80"><![CDATA[
 
         public void Cut()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="81" endline="88"><![CDATA[
 
         public void Copy()
         {
             if (this.treeMain.SelectedNode != null)
             {
                 Clipboard.SetText(this.treeMain.SelectedNode.Text);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="89" endline="92"><![CDATA[
 
         public void Paste()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="93" endline="96"><![CDATA[
 
         public void Undo()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="97" endline="100"><![CDATA[
 
         public void Redo()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="101" endline="104"><![CDATA[
 
         public void Print()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="105" endline="108"><![CDATA[
 
         public void Duplicate()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="109" endline="123"><![CDATA[
 
         public void Delete()
         {
             if (this.treeMain.SelectedNode != null)
             {
                 if (this.treeMain.SelectedNode.Parent == null)
                 {
                     this.treeMain.Nodes.Remove(this.treeMain.SelectedNode);
                 }
                 else
                 {
                     this.treeMain.SelectedNode.Parent.Nodes.Remove(this.treeMain.SelectedNode);
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="124" endline="127"><![CDATA[
 
         public void SelectAll()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="128" endline="133"><![CDATA[
 
         public bool CloseTab()
         {
             this.Hide();
             return true;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="134" endline="137"><![CDATA[
 
         public void MarkAll(System.Text.RegularExpressions.Regex reg)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="138" endline="142"><![CDATA[
 
         public bool FindNext(System.Text.RegularExpressions.Regex reg, bool searchUp)
         {
             return false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="143" endline="146"><![CDATA[
 
         public void ReplaceNext(System.Text.RegularExpressions.Regex reg, string replaceWith, bool searchUp)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="147" endline="150"><![CDATA[
 
         public void ReplaceAll(System.Text.RegularExpressions.Regex reg, string replaceWith)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="151" endline="154"><![CDATA[
 
         public void SelectWord(int line, int offset, int wordLeng)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="155" endline="158"><![CDATA[
 
         public IPeterPluginHost Host
         {
             get { return this.m_Host; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="159" endline="160"><![CDATA[
 
             set { this.m_Host = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="161" endline="165"><![CDATA[
         }
 
         public string FileName
         {
             get { return ""; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="166" endline="170"><![CDATA[
         }
 
         public string Selection
         {
             get { return ""; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="171" endline="175"><![CDATA[
         }
 
         public bool AbleToUndo
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="176" endline="180"><![CDATA[
         }
 
         public bool AbleToRedo
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="181" endline="185"><![CDATA[
         }
 
         public bool AbleToPaste
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="186" endline="190"><![CDATA[
         }
 
         public bool AbleToCut
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="191" endline="195"><![CDATA[
         }
 
         public bool AbleToCopy
         {
             get { return true; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="196" endline="200"><![CDATA[
         }
 
         public bool AbleToSelectAll
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="201" endline="205"><![CDATA[
         }
 
         public bool AbleToSave
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="206" endline="210"><![CDATA[
         }
 
         public bool AbleToDelete
         {
             get { return true; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="211" endline="215"><![CDATA[
         }
 
         public bool NeedsSaving
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FindResults.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="49" endline="83"><![CDATA[
         public Editor(string tabTitle, MainForm main)
         {
             // Set up the Parent Tab...
             this.TabText = tabTitle;
             this.m_FindPos = -1;
             this.m_MainForm = main;
             this.m_ToolTip = new cHtmlToolTip(this);
             this.m_Project = "";
             this.m_AutoComplete = new GListBox();
 
             // Set up the Editor...
             this.m_Editor = new TextEditorControl();
             this.m_Editor.Dock = System.Windows.Forms.DockStyle.Fill;
 
             // Add the Editor...
             this.Controls.Add(this.m_Editor);
             this.m_Changed = false;
 
             // Delegates...
             this.m_LoadFile = new LoadFileDelegate(this.DelReLoad);
             this.m_CloseDel = new CloseDelegate(this.DelClose);
 
             // Drag N Drop...
             this.m_Editor.ActiveTextAreaControl.TextArea.AllowDrop = true;
             this.m_Editor.ActiveTextAreaControl.TextArea.DragEnter += new System.Windows.Forms.DragEventHandler(TextArea_DragEnter);
             this.m_Editor.ActiveTextAreaControl.TextArea.DragDrop += new System.Windows.Forms.DragEventHandler(TextArea_DragDrop);
             this.m_Editor.ActiveTextAreaControl.TextArea.MouseDown += new MouseEventHandler(TextArea_MouseDown);
             this.m_Editor.ActiveTextAreaControl.Caret.PositionChanged += new EventHandler(Caret_Change);
             this.m_Editor.ActiveTextAreaControl.Caret.CaretModeChanged += new EventHandler(Caret_CaretModeChanged);
             this.m_Editor.ActiveTextAreaControl.TextArea.LostFocus += new EventHandler(TextArea_LostFocus);
             this.m_Editor.ActiveTextAreaControl.TextArea.KeyDown += new System.Windows.Forms.KeyEventHandler(TextArea_KeyDown);
             this.m_Editor.Document.DocumentChanged += new DocumentEventHandler(Document_DocumentChanged);
             this.m_Editor.Document.UndoStack.ActionRedone += new EventHandler(UndoStack_ActionRedone);
             this.m_Editor.Document.UndoStack.ActionUndone += new EventHandler(UndoStack_ActionRedone);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="84" endline="124"><![CDATA[
 
         #endregion
 
         #region -= Key Press =-
    
         void TextArea_KeyDown (object sender, KeyEventArgs e)
         {
             /* Auto Complete...
             if (this.Controls.Contains(this.m_AutoComplete))
             {
                 switch (e.KeyCode)
                 {
                     case Keys.Enter
                     case Keys.Space
                     case Keys.Oemcomma
                     case Keys.OemMinus
                     case Keys.OemOpenBrackets
                     case Keys.OemPeriod
                     case Keys.Oemplus
                     case Keys.OemSemicolon
                         this.Controls.Remove(this.m_AutoComplete);
                         break;
                 }
             }
             /*if (e.KeyCode == Keys.OemPeriod)
             {
                 this.Controls.Add(this.m_AutoComplete);
                 this.m_AutoComplete.Location = new Point(this.m_Editor.ActiveTextAreaControl.Caret.ScreenPosition.X, 
                     this.m_Editor.ActiveTextAreaControl.Caret.ScreenPosition.Y + this.m_Editor.Font.Height);
                 this.m_AutoComplete.Size = new Size(100, 100);
                 this.m_AutoComplete.BringToFront();
                 this.m_AutoComplete.Show();
             }
             else
             {
                 if (this.Controls.Contains(this.m_AutoComplete))
                 {
                     this.Controls.Remove(this.m_AutoComplete);
                 }
             }*/
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="125" endline="133"><![CDATA[
 
         #endregion
 
         #region -= Caret =-
 
         void Caret_CaretModeChanged(object sender, EventArgs e)
         {
             this.UpdateCaretPos();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="134" endline="138"><![CDATA[
 
         void Caret_Change(object sender, EventArgs e)
         {
             this.UpdateCaretPos();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="139" endline="144"><![CDATA[
 
         public void UpdateCaretPos()
         {
             this.m_MainForm.UpdateCaretPos(this.m_Editor.ActiveTextAreaControl.Caret.Offset, this.m_Editor.ActiveTextAreaControl.Caret.Line + 1,
                 this.m_Editor.ActiveTextAreaControl.Caret.Column + 1, this.m_Editor.ActiveTextAreaControl.Caret.CaretMode.ToString());
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="145" endline="227"><![CDATA[
 
         #endregion
 
         #region -= Mouse Down =-
 
         void TextArea_MouseDown(object sender, MouseEventArgs e)
         {
             if (this.m_ToolTip.Visible) this.m_ToolTip.Hide();
             if (e.Button == MouseButtons.Left)
             {
                 if (Control.ModifierKeys == Keys.Control || Control.ModifierKeys == Keys.Alt)
                 {
                     int pos = this.m_Editor.ActiveTextAreaControl.Caret.Offset;
                     int before = pos;
                     int after = pos;
                     while (CheckStop(this.m_Editor.Document.TextContent[before]))
                     {
                         before--;
                     }
                     while (CheckStop(this.m_Editor.Document.TextContent[before]))
                     {
                         before--;
                     }
                     before++;
                     while (CheckStop(this.m_Editor.Document.TextContent[after]))
                     {
                         after++;
                     }
                     while (CheckStop(this.m_Editor.Document.TextContent[after]))
                     {
                         after++;
                     }
 
                     if (after > before)
                     {
                         if (Control.ModifierKeys == Keys.Control)
                         {
                             this.m_Editor.ActiveTextAreaControl.SelectionManager.SetSelection(
                                 this.m_Editor.Document.OffsetToPosition(before), this.m_Editor.Document.OffsetToPosition(after));
                         }
                         else if (Control.ModifierKeys == Keys.Alt)
                         {
                             #region -= Look Up Word =-
 
                             string text = this.m_Editor.Document.TextContent.Substring(before, after - before);
                             string html = "<table><tr><th colspan=\"2\">" + text + "</th></tr><tr>";
                             int count = 0;
                             if (!string.IsNullOrEmpty(this.m_Project))
                             {
                                 string lookup = this.m_MainForm.LookUpProject(text, this.m_Project);
                                 if (!lookup.Equals("<ul></ul>"))
                                 {
                                     count++;
                                 }
                                 html += "<tr><td colspan=\"2\">" + lookup + "</td></tr>";
                             }
                             Regex reg = new Regex(text);
                             MatchCollection mc = reg.Matches(this.m_Editor.Document.TextContent);
                             if (mc.Count > 1)
                             {
                                 ArrayList lines = new ArrayList();
                                 html += "<tr><td colspan=\"2\">References in Document
                                 foreach (Match m in mc)
                                 {
                                     int lineNum = this.m_Editor.Document.GetLineNumberForOffset(m.Index);
                                     if (lineNum != this.m_Editor.ActiveTextAreaControl.Caret.Line && !lines.Contains(lineNum))
                                     {
                                         lines.Add(lineNum);
                                         lineNum++;
                                         count++;
                                         LineSegment line = this.m_Editor.Document.GetLineSegmentForOffset(m.Index);
 
                                         html += "<tr><td valign=\"top\" align=\"right\"><a href=\"\">" + lineNum.ToString() + "</a></td><td>" + 
                                             this.m_Editor.Document.TextContent.Substring(line.Offset, line.TotalLength) + "</td></tr>";
                                     }
                                 }
                                 foreach (Match m in mc)
                                 {
                                     int lineNum = this.m_Editor.Document.GetLineNumberForOffset(m.Index);
                                     if (lineNum != this.m_Editor.ActiveTextAreaControl.Caret.Line && !lines.Contains(lineNum))
                                     {
                                         lines.Add(lineNum);
                                         lineNum++;
                                         count++;
                                         LineSegment line = this.m_Editor.Document.GetLineSegmentForOffset(m.Index);
 
                                         html += "<tr><td valign=\"top\" align=\"right\"><a href=\"\">" + lineNum.ToString() + "</a></td><td>" + 
                                             this.m_Editor.Document.TextContent.Substring(line.Offset, line.TotalLength) + "</td></tr>";
                                     }
                                 }
                                 html += "</table>";
                             }
                             if (count > 0)
                             {
                                 this.m_ToolTip.HTML = html;
                                 this.m_ToolTip.Location = MousePosition;
                                 this.m_ToolTip.Show();
                             }
 
                             #endregion
                         }
                     }
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="228" endline="276"><![CDATA[
 
         #endregion
 
         #region -= Check Stop =-
 
         private bool CheckStop(char val)
         {
             switch (val)
             {
                 case '('
                 case ')'
                 case ' '
                 case '-'
                 case '+'
                 case '='
                 case '*'
                 case '&'
                 case '^'
                 case '%'
                 case '$'
                 case '#'
                 case '@'
                 case '!'
                 case '{'
                 case '}'
                 case '['
                 case ']'
                 case '|'
                 case '\\'
                 case ';'
                 case '\''
                 case '
                 case '\"'
                 case ','
                 case '.'
                 case '<'
                 case '>'
                 case '/'
                 case '?'
                 case '`'
                 case '~'
                 case '\t'
                 case '\r'
                 case '\n'
                     return false;
                 default
                     return true;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="277" endline="285"><![CDATA[
 
         #endregion
 
         #region -= Misc =-
 
         void UndoStack_ActionRedone(object sender, EventArgs e)
         {
             this.m_Editor.ActiveTextAreaControl.TextArea.Invalidate();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="286" endline="294"><![CDATA[
 
         /// <summary>
         /// Sets the Context Menu for the Editor
         /// </summary>
         /// <param name="ctx">Context Menu to use.</param>
         public void SetContextMenuStrip(ContextMenuStrip ctx)
         {
             this.m_Editor.ActiveTextAreaControl.TextArea.ContextMenuStrip = ctx;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="295" endline="301"><![CDATA[
 
         public void Print()
         {
             PrintPreviewDialog dlg = new PrintPreviewDialog();
             dlg.Document = this.m_Editor.PrintDocument;
             dlg.ShowDialog();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="302" endline="312"><![CDATA[
 
         public void ScrollTo(int offset)
         {
             if (offset > this.m_Editor.Document.TextLength)
             {
                 return;
             }
             int line = this.m_Editor.Document.GetLineNumberForOffset(offset);
             this.m_Editor.ActiveTextAreaControl.Caret.Position = this.m_Editor.Document.OffsetToPosition(offset);
             this.m_Editor.ActiveTextAreaControl.ScrollTo(line);//.CenterViewOn(line, 0);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="313" endline="317"><![CDATA[
 
         void TextArea_LostFocus (object sender, EventArgs e)
         {
             if (this.m_ToolTip.Visible) this.m_ToolTip.Hide();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="318" endline="324"><![CDATA[
 
         /// <summary>
         /// Gets or Sets the Project related to the file...
         /// </summary>
         public string Project
         {
             get { return this.m_Project; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="325" endline="326"><![CDATA[
 
             set { this.m_Project = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="327" endline="355"><![CDATA[
         }
 
         #endregion
 
         #region -= File Watcher =-
 
         /// <summary>
         /// Sets up the file watcher...
         /// </summary>
         public void SetupFileWatcher()
         {
             // Remove Events...
             if (this.m_FSW != null)
             {
                 this.m_FSW.Changed -= new FileSystemEventHandler(m_FSW_Changed);
                 this.m_FSW.Deleted -= new FileSystemEventHandler(m_FSW_Deleted);
                 this.m_FSW.Renamed -= new RenamedEventHandler(m_FSW_Renamed);
             }
 
             // Create new FileWatcher...
             this.m_FSW = new FileSystemWatcher(Path.GetDirectoryName(this.m_Editor.FileName), Path.GetFileName(this.m_Editor.FileName));
             this.m_FSW.EnableRaisingEvents = true;
             this.m_FSW.IncludeSubdirectories = false;
 
             // Add Events...
             this.m_FSW.Changed += new FileSystemEventHandler(m_FSW_Changed);
             this.m_FSW.Deleted += new FileSystemEventHandler(m_FSW_Deleted);
             this.m_FSW.Renamed += new RenamedEventHandler(m_FSW_Renamed);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="356" endline="365"><![CDATA[
 
         /// <summary>
         /// Occurs when the file is Renamed...
         /// </summary>
         /// <param name="sender">FileSystemWatcher</param>
         /// <param name="e">Events</param>
         void m_FSW_Renamed(object sender, RenamedEventArgs e)
         {
             this.Invoke(this.m_LoadFile, new object[] { e.FullPath });
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="366" endline="375"><![CDATA[
 
         /// <summary>
         /// Occurs when the file is Changed...
         /// </summary>
         /// <param name="sender">FileSystemWatcher</param>
         /// <param name="e">Events</param>
         void m_FSW_Changed (object sender, FileSystemEventArgs e)
         {
             this.Invoke(this.m_LoadFile, new object[] { e.FullPath });
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="376" endline="385"><![CDATA[
 
         /// <summary>
         /// Occurs when the file is deleted...
         /// </summary>
         /// <param name="sender">FileSystemWatcher</param>
         /// <param name="e">Events</param>
         void m_FSW_Deleted(object sender, FileSystemEventArgs e)
         {
             this.Invoke(this.m_CloseDel);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="386" endline="398"><![CDATA[
 
         /// <summary>
         /// Close Delegate Method...
         /// </summary>
         private void DelClose ()
         {
             if (MessageBox.Show(this.m_MainForm, this.m_Editor.FileName + " has been deleted. Do you want to close this file's tab?",
                 "Peter", MessageBoxButtons.YesNo, MessageBoxIcon.Information) == DialogResult.Yes)
             {
                 this.m_Changed = false;
                 this.CloseTab();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="399" endline="411"><![CDATA[
 
         /// <summary>
         /// Reload File Delegate...
         /// </summary>
         /// <param name="file">Path to File.</param>
         private void DelReLoad (string file)
         {
             if (MessageBox.Show(this.m_MainForm, this.m_Editor.FileName + " has changed. Do you want to reload the file?",
                 "Peter", MessageBoxButtons.YesNo, MessageBoxIcon.Information) == DialogResult.Yes)
             {
                 this.LoadFile(file);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="412" endline="424"><![CDATA[
 
         #endregion
 
         #region -= Book Marks =-
 
         /// <summary>
         /// Toggles a mark at the current line...
         /// </summary>
         public void ToggleMark()
         {
             this.m_Editor.Document.BookmarkManager.ToggleMarkAt(this.m_Editor.ActiveTextAreaControl.Caret.Line);
             this.m_Editor.ActiveTextAreaControl.Invalidate(true);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="425" endline="433"><![CDATA[
 
         /// <summary>
         /// Removes all the Marks from the Edior...
         /// </summary>
         public void RemoveAllMarks()
         {
             this.m_Editor.Document.BookmarkManager.Clear();
             this.m_Editor.ActiveTextAreaControl.Invalidate(true);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="434" endline="446"><![CDATA[
 
         /// <summary>
         /// Goes to the next(true) or previous(false) mark...
         /// </summary>
         /// <param name="forward">True(next) or Previous(false)</param>
         public void GotoMark(bool forward)
         {
             Bookmark b = (forward) ?
                 this.m_Editor.Document.BookmarkManager.GetNextMark(this.m_Editor.ActiveTextAreaControl.Caret.Line) 
                 this.m_Editor.Document.BookmarkManager.GetPrevMark(this.m_Editor.ActiveTextAreaControl.Caret.Line);
             this.m_Editor.ActiveTextAreaControl.CenterViewOn(b.LineNumber, 0);
             this.m_Editor.ActiveTextAreaControl.Caret.Line = b.LineNumber;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="447" endline="502"><![CDATA[
 
         #endregion
 
         #region -= Setup Editor =-
 
         /// <summary>
         /// Sets up the Editor...
         /// </summary>
         /// <param name="node">XmlNode that holds the Configuration.</param>
         public void SetupEditor(Common.EditorConfig config)
         {
             this.m_Editor.ShowEOLMarkers = config.ShowEOL;
             this.m_Editor.ShowInvalidLines = config.ShowInvalidLines;
             this.m_Editor.ShowSpaces = config.ShowSpaces;
             this.m_Editor.ShowTabs = config.ShowTabs;
             this.m_Editor.ShowMatchingBracket = config.ShowMatchingBracket;
             this.m_Editor.ShowLineNumbers = config.ShowLineNumbers;
             this.m_Editor.ShowHRuler = config.ShowHRuler;
             this.m_Editor.ShowVRuler = config.ShowVRuler;
             this.m_Editor.EnableFolding = config.EnableCodeFolding;
 
             this.m_Editor.Font = config.EditorFont;
             this.m_Editor.ConvertTabsToSpaces = config.ConvertTabs;
             this.m_Editor.TabIndent = config.TabIndent;
             this.m_Editor.VRulerRow = config.VerticalRulerCol;
             this.m_Editor.UseAntiAliasFont = config.UseAntiAlias; // #develop 2
             /* // #develop 3
             if (config.UseAntiAlias)
             {
                 this.m_Editor.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAliasGridFit;
             }*/
             this.m_Editor.AllowCaretBeyondEOL = config.AllowCaretBeyondEOL;
             this.m_Editor.TextEditorProperties.AutoInsertCurlyBracket = config.AutoInsertBracket;
             this.m_Editor.LineViewerStyle = (config.HighlightCurrentLine) ? LineViewerStyle.FullRow 
             switch (config.BracketMatchingStyle.ToLower())
             {
                 case "before"
                     this.m_Editor.BracketMatchingStyle = BracketMatchingStyle.Before;
                     break;
                 case "after"
                     this.m_Editor.BracketMatchingStyle = BracketMatchingStyle.After;
                     break;
             }
             switch (config.IndentStyle.ToLower())
             {
                 case "auto"
                     this.m_Editor.IndentStyle = IndentStyle.Auto;
                     break;
                 case "none"
                     this.m_Editor.IndentStyle = IndentStyle.None;
                     break;
                 case "smart"
                     this.m_Editor.IndentStyle = IndentStyle.Smart;
                     break;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="503" endline="519"><![CDATA[
 
         #endregion
 
         #region -= Drag N Drop =-
 
         /// <summary>
         /// Enables files to be dropped in the dock window...
         /// </summary>
         /// <param name="sender">Text Area</param>
         /// <param name="e">Events</param>
         private void TextArea_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop, false) == true)
             {
                 e.Effect = DragDropEffects.All;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="520" endline="534"><![CDATA[
 
         /// <summary>
         /// Grabs the files dropped in the Editor...
         /// </summary>
         /// <param name="sender">Text Area</param>
         /// <param name="e">Events</param>
         private void TextArea_DragDrop(object sender, DragEventArgs e)
         {
             string[] files = (string[])e.Data.GetData(DataFormats.FileDrop);
             foreach (string file in files)
             {
                 this.m_Host.CreateEditor(file, Path.GetFileName(file), this.Host.GetFileIcon(file, false), this);
             }
             foreach (string file in files)
             {
                 this.m_Host.CreateEditor(file, Path.GetFileName(file), this.Host.GetFileIcon(file, false), this);
             }
             this.m_MainForm.Focus();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="535" endline="553"><![CDATA[
 
         #endregion
 
         #region -= Document Changed =-
 
         /// <summary>
         /// Occurs when the document changes...
         /// </summary>
         /// <param name="sender">Document</param>
         /// <param name="e">DocumentEvents</param>
         private void Document_DocumentChanged(object sender, DocumentEventArgs e)
         {
             if (!this.m_Changed)
             {
                 this.TabText = "*" + this.TabText;
                 this.m_Changed = true;
                 this.m_MainForm.UpdateTitleBar();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="554" endline="564"><![CDATA[
 
         #endregion
 
         #region -= Highlighting =-
 
         /// <summary>
         /// Gets or Sets the Highligthing for the Editor...
         /// </summary>
         public string Highlighting
         {
             get { return this.m_Editor.Document.HighlightingStrategy.Name; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="565" endline="569"><![CDATA[
 
             set
             {
                 this.m_Editor.Document.HighlightingStrategy = HighlightingManager.Manager.FindHighlighter(value);
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="570" endline="585"><![CDATA[
         }
 
         #endregion
 
         #region -= Set/Get Text =-
 
         /// <summary>
         /// Sets the Text of the Editor...
         /// </summary>
         /// <param name="text">Text for the Editor</param>
         public void SetText(string text)
         {
             this.m_Editor.Document.TextContent = text;
             this.m_Changed = false;
             this.RemoveChangeStar();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="586" endline="594"><![CDATA[
 
         /// <summary>
         /// Sets the Text of the Editor...
         /// </summary>
         /// <param name="text">Text for the Editor</param>
         public void SetTextChanged(string text)
         {
             this.m_Editor.Document.TextContent = text;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="595" endline="603"><![CDATA[
 
         /// <summary>
         /// Gets the Text of the Editor...
         /// </summary>
         /// <returns>Text in the Editor</returns>
         public string GetText()
         {
             return this.m_Editor.Document.TextContent;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="604" endline="626"><![CDATA[
 
         #endregion
 
         #region -= Get Persist String =-
 
         /// <summary>
         /// Overrides the Persist String for the Docking Control...
         /// </summary>
         /// <returns>Newly Formed Persist String.</returns>
         protected override string GetPersistString()
         {
             this.RemoveChangeStar();
 
             if (this.FileName == null)
             {
                 return this.GetType().ToString() + "|" + this.TabText + "|none|" + this.m_Editor.Document.TextContent;
             }
             else
             {
                 return this.GetType().ToString() + "|" + this.TabText + "|" + this.FileName + "|" + 
                     this.m_Editor.ActiveTextAreaControl.Caret.Offset.ToString() + "|" + this.m_Project;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="627" endline="666"><![CDATA[
 
         #endregion
 
         #region IPeterPluginTab Members
 
         /// <summary>
         /// Closes this Editor...
         /// </summary>
         public bool CloseTab()
         {
             if (this.m_Changed)
             {
                 string file = (this.FileName == null) ? this.TabText 
                 switch (MessageBox.Show(this.m_MainForm, "Do you want to Save " + file + "?", "Peter",
                     MessageBoxButtons.YesNoCancel, MessageBoxIcon.Question))
                 {
                     case DialogResult.Yes
                         if (this.FileName == null)
                         {
                             this.m_Host.SaveAs(this);
                         }
                         else
                         {
                             this.Save();
                         }
                         break;
                     case DialogResult.No
                         this.m_Changed = false;
                         break;
                     case DialogResult.Cancel
                         return false;
                 }
             }
             if(this.m_FSW != null)
                 this.m_FSW.EnableRaisingEvents = false;
             this.Close();
             this.m_MainForm.UpdateCaretPos(0, 0, 0, null);
             this.Dispose(true);
             return true;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="667" endline="674"><![CDATA[
 
         /// <summary>
         /// Saves the Current Document...
         /// </summary>
         public void Save()
         {
             this.SaveAs(this.m_Editor.FileName);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="675" endline="728"><![CDATA[
 
         /// <summary>
         /// Saves the Document As...
         /// </summary>
         /// <param name="filePath">Path to File to Save As.</param>
         public void SaveAs(string filePath)
         {
             if(this.m_FSW != null)
                 this.m_FSW.EnableRaisingEvents = false;
 
             if (string.IsNullOrEmpty(Path.GetExtension(filePath)))
                 filePath += ".txt";
 
             FileInfo f = new FileInfo(filePath);
             if (f.Exists && f.IsReadOnly)
             {
                 if (MessageBox.Show(this.m_MainForm, "The File \"" + filePath + "\" is Read Only.\nDo you want to save under a different file name?",
                     "Peter", MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.Yes)
                 {
                     this.m_Host.SaveAs(this);
                     return;
                 }
                 else
                 {
                     return;
                 }
             }
             
             this.ToolTipText = filePath;
             this.TabText = Path.GetFileName(filePath);
             this.Icon = this.m_Host.GetFileIcon(filePath, false);
             this.m_Editor.SaveFile(filePath);
             bool reload = false;
             if (string.IsNullOrEmpty(this.m_Editor.FileName))
             {
                 reload = true;
             }
             else
             {
                 if (Path.GetExtension(filePath) != Path.GetExtension(this.m_Editor.FileName))
                 {
                     reload = true;
                 }
             }
 
             if (reload)
             {
                 this.m_Editor.Document.HighlightingStrategy = HighlightingManager.Manager.FindHighlighterForFile(filePath);
             }
             this.m_Changed = false;
             this.RemoveChangeStar();
 
             this.SetupFileWatcher();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="729" endline="736"><![CDATA[
 
         /// <summary>
         /// Clipboard Cut Action...
         /// </summary>
         public void Cut()
         {
             this.m_Editor.ActiveTextAreaControl.TextArea.ClipboardHandler.Cut(null, null);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="737" endline="744"><![CDATA[
 
         /// <summary>
         /// Clipboard Copy Action...
         /// </summary>
         public void Copy()
         {
             this.m_Editor.ActiveTextAreaControl.TextArea.ClipboardHandler.Copy(null, null);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="745" endline="752"><![CDATA[
 
         /// <summary>
         /// Clipboard Paste Action...
         /// </summary>
         public void Paste()
         {
             this.m_Editor.ActiveTextAreaControl.TextArea.ClipboardHandler.Paste(null, null);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="753" endline="760"><![CDATA[
 
         /// <summary>
         /// Edit Undo Action...
         /// </summary>
         public void Undo()
         {
             this.m_Editor.Document.UndoStack.Undo();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="761" endline="768"><![CDATA[
 
         /// <summary>
         /// Edit Redo Action...
         /// </summary>
         public void Redo()
         {
             this.m_Editor.Document.UndoStack.Redo();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="769" endline="776"><![CDATA[
 
         /// <summary>
         /// Clipboard Delete Action...
         /// </summary>
         public void Delete()
         {
             this.m_Editor.ActiveTextAreaControl.TextArea.ClipboardHandler.Delete(null, null);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="777" endline="788"><![CDATA[
 
         public void Duplicate()
         {
             if (this.m_Editor.ActiveTextAreaControl.SelectionManager.HasSomethingSelected)
             {
                 string selection = this.m_Editor.ActiveTextAreaControl.SelectionManager.SelectedText;
                 int pos = this.m_Editor.ActiveTextAreaControl.SelectionManager.SelectionCollection[0].EndOffset;
                 this.m_Editor.Document.Insert(pos, selection);
 
                 this.m_Editor.ActiveTextAreaControl.TextArea.Invalidate();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="789" endline="796"><![CDATA[
 
         /// <summary>
         /// Selects All the Text of the Document...
         /// </summary>
         public void SelectAll()
         {
             this.m_Editor.ActiveTextAreaControl.TextArea.ClipboardHandler.SelectAll(null, null);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="797" endline="828"><![CDATA[
 
         /// <summary>
         /// Loads the Given File...
         /// </summary>
         /// <param name="filePath">Path to File.</param>
         public void LoadFile(string filePath)
         {
             FileInfo f = new FileInfo(filePath);
             this.TabText = f.Name;
             this.ToolTipText = filePath;
             this.m_Editor.LoadFile(filePath, true, true);
             this.m_Changed = false;
             this.RemoveChangeStar();
 
             if (string.IsNullOrEmpty(f.Extension))
             {
                 this.m_Editor.Document.HighlightingStrategy = HighlightingManager.Manager.FindHighlighter("HTML");
             }
             if (f.IsReadOnly)
             {
                 this.m_Editor.Document.ReadOnly = true;
                 Bitmap b = this.Icon.ToBitmap();
                 using(Graphics g = Graphics.FromImage(b))
                 {
                     Image img = this.m_MainForm.GetInternalImage("_lock");
                     g.DrawImage(img, new Point(0, 0));
                     this.Icon = Icon.FromHandle(b.GetHicon());
                 }
             }
             this.SetupFileWatcher();
             this.m_Editor.ActiveTextAreaControl.TextArea.Focus();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="829" endline="844"><![CDATA[
 
         /// <summary>
         /// Marks all of the Occurances of the given Pattern...
         /// </summary>
         /// <param name="reg">Pattern to Mark.</param>
         public void MarkAll(Regex reg)
         {
             MatchCollection mc = reg.Matches(this.m_Editor.Document.TextContent);
             foreach (Match m in mc)
             {
                 int line = this.m_Editor.Document.GetLineNumberForOffset(m.Index);
                 this.m_Editor.Document.BookmarkManager.AddMark(new Bookmark(this.m_Editor.Document, line));
             }
             foreach (Match m in mc)
             {
                 int line = this.m_Editor.Document.GetLineNumberForOffset(m.Index);
                 this.m_Editor.Document.BookmarkManager.AddMark(new Bookmark(this.m_Editor.Document, line));
             }
             this.m_Editor.ActiveTextAreaControl.Invalidate(true);
             this.m_Editor.ActiveTextAreaControl.TextArea.Focus();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="845" endline="898"><![CDATA[
 
         /// <summary>
         /// Finds the Next Occurance of the given Pattern...
         /// </summary>
         /// <param name="reg">Pattern to Find.</param>
         public bool FindNext(Regex reg, bool searchUp)
         {
             this.m_Host.Trace("Searching for " + reg.ToString());
             Match m = null;
             if (searchUp)
             {
                 MatchCollection mc = reg.Matches(this.m_Editor.Document.TextContent.Substring(0, this.m_Editor.ActiveTextAreaControl.Caret.Offset));
                 if (mc.Count > 0)
                 {
                     m = mc[mc.Count - 1];
                     HighlightMatch(m, searchUp);
                 }
                 else
                 {
                     mc = reg.Matches(this.m_Editor.Document.TextContent);
                     if (mc.Count > 0)
                     {
                         m = mc[mc.Count - 1];
                         HighlightMatch(m, searchUp);
                     }
                     else
                     {
                         CouldNotFind(reg);
                         return false;
                     }
                 }
             }
             else
             {
                 m = reg.Match(this.m_Editor.Document.TextContent, this.m_Editor.ActiveTextAreaControl.Caret.Offset);
                 if (!m.Success)
                 {
                     m = reg.Match(this.m_Editor.Document.TextContent);
                 }
 
                 if (m.Success)
                 {
                     HighlightMatch(m, searchUp);
                 }
                 else
                 {
                     CouldNotFind(reg);
                     return false;
                 }
                 this.m_Editor.ActiveTextAreaControl.TextArea.Focus();
             }
 
             return true;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="899" endline="906"><![CDATA[
 
         private void CouldNotFind(Regex reg)
         {
 
             this.m_FindPos = -1;
             MessageBox.Show(this.m_MainForm, "No Occurrences of '" + reg.ToString() + "' found.", "Peter", MessageBoxButtons.OK, MessageBoxIcon.Information);
             this.m_Host.Trace("");
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="907" endline="922"><![CDATA[
 
         private void HighlightMatch(Match m, bool searchUp)
         {
             this.m_Editor.ActiveTextAreaControl.SelectionManager.SetSelection(
                 this.m_Editor.Document.OffsetToPosition(m.Index), this.m_Editor.Document.OffsetToPosition(m.Index + m.Length));
             if (searchUp)
             {
                 this.m_Editor.ActiveTextAreaControl.Caret.Position = this.m_Editor.Document.OffsetToPosition(m.Index);
             }
             else
             {
                 this.m_Editor.ActiveTextAreaControl.Caret.Position = this.m_Editor.Document.OffsetToPosition(m.Index + m.Length);
             }
             this.m_Host.Trace("");
             this.m_FindPos = m.Index;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="923" endline="939"><![CDATA[
 
         /// <summary>
         /// Replaces the Next Occurance of the Given Pattern...
         /// </summary>
         /// <param name="reg">Pattern to Replace.</param>
         public void ReplaceNext(Regex reg, string replaceWith, bool searchUp)
         {
             this.FindNext(reg, searchUp);
             if (this.m_FindPos != -1)
             {
                 this.m_Editor.ActiveTextAreaControl.Caret.Position = this.m_Editor.Document.OffsetToPosition(this.m_FindPos);
                 string replaced = reg.Replace(this.m_Editor.Document.TextContent, replaceWith, 1, this.m_FindPos);
                 this.m_Editor.Document.Replace(0, this.m_Editor.Document.TextLength, replaced);
                 this.m_Editor.ActiveTextAreaControl.TextArea.Focus();
             }
             this.m_Editor.ActiveTextAreaControl.TextArea.Focus();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="940" endline="957"><![CDATA[
 
         /// <summary>
         /// Replaces all Occurances of the Given Pattern...
         /// </summary>
         /// <param name="reg">Pattern to Replace.</param>
         public void ReplaceAll(Regex reg, string replaceWith)
         {
             string replaced = reg.Replace(this.m_Editor.Document.TextContent, replaceWith);
             if (replaced != this.m_Editor.Document.TextContent)
             {
                 this.m_Editor.Document.Replace(0, this.m_Editor.Document.TextLength, replaced);
             }
             else
             {
                 this.m_Host.Trace("No Occurrences of '" + reg.ToString() + "' found in " + this.TabText + ".");
             }
             this.m_Editor.ActiveTextAreaControl.TextArea.Focus();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="958" endline="973"><![CDATA[
 
         /// <summary>
         /// Selects the word at the given offset...
         /// </summary>
         /// <param name="line">Line Word is on.</param>
         /// <param name="offset">Offset Word is at.</param>
         /// <param name="wordLeng">Length of Word.</param>
         public void SelectWord(int line, int offset, int wordLen)
         {
             this.m_Editor.ActiveTextAreaControl.ScrollTo(line);
             this.m_Editor.ActiveTextAreaControl.Caret.Line = line;
             this.m_Editor.ActiveTextAreaControl.SelectionManager.SetSelection(
                 this.m_Editor.Document.OffsetToPosition(this.m_Editor.ActiveTextAreaControl.Caret.Offset + offset),
                 this.m_Editor.Document.OffsetToPosition(this.m_Editor.ActiveTextAreaControl.Caret.Offset + offset + wordLen));
             this.m_Editor.ActiveTextAreaControl.TextArea.Focus();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="974" endline="984"><![CDATA[
 
         /// <summary>
         /// Removes the * at the front of a changed document...
         /// </summary>
         private void RemoveChangeStar()
         {
             if (this.TabText.IndexOf('*') == 0)
             {
                 this.TabText = this.TabText.Substring(1);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="985" endline="991"><![CDATA[
 
         /// <summary>
         /// Sets the Host Control...
         /// </summary>
         public IPeterPluginHost Host 
         {
             get { return this.m_Host; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="992" endline="993"><![CDATA[
 
             set { this.m_Host = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="994" endline="1001"><![CDATA[
         }
 
         /// <summary>
         /// Gets the File Name of the Document...
         /// </summary>
         public string FileName
         {
             get { return this.m_Editor.FileName; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="1002" endline="1019"><![CDATA[
         }
 
         /// <summary>
         /// Gets the Selected Text...
         /// </summary>
         public string Selection
         {
             get
             {
                 if (this.m_Editor.ActiveTextAreaControl.SelectionManager.HasSomethingSelected)
                 {
                     return this.m_Editor.ActiveTextAreaControl.SelectionManager.SelectedText;
                 }
                 else
                 {
                     return "";
                 }
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="1020" endline="1027"><![CDATA[
         }
 
         /// <summary>
         /// Gets if we are able to do an Undo Action...
         /// </summary>
         public bool AbleToUndo
         {
             get { return this.m_Editor.EnableUndo; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="1028" endline="1035"><![CDATA[
         }
 
         /// <summary>
         /// Gets if we are able to do a Redo Action...
         /// </summary>
         public bool AbleToRedo
         {
             get { return this.m_Editor.EnableRedo; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="1036" endline="1043"><![CDATA[
         }
 
         /// <summary>
         /// Gets if the Editor needs to be Saved...
         /// </summary>
         public bool NeedsSaving
         {
             get { return this.m_Changed; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="1044" endline="1051"><![CDATA[
         }
 
         /// <summary>
         /// Gets if this Control can Paste...
         /// </summary>
         public bool AbleToPaste
         {
             get { return true; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="1052" endline="1059"><![CDATA[
         }
 
         /// <summary>
         /// Gets if this Control can Cut...
         /// </summary>
         public bool AbleToCut
         {
             get { return true; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="1060" endline="1067"><![CDATA[
         }
 
         /// <summary>
         /// Gets if this Control can Cut...
         /// </summary>
         public bool AbleToCopy
         {
             get { return true; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="1068" endline="1075"><![CDATA[
         }
 
         /// <summary>
         /// Gets if this Control can Select All...
         /// </summary>
         public bool AbleToSelectAll
         {
             get { return true; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="1076" endline="1083"><![CDATA[
         }
 
         /// <summary>
         /// Gets if this Control can Save...
         /// </summary>
         public bool AbleToSave
         {
             get { return true; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="1084" endline="1091"><![CDATA[
         }
 
         /// <summary>
         /// Gets if this Control can Delete...
         /// </summary>
         public bool AbleToDelete
         {
             get { return true; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="1092" endline="1119"><![CDATA[
         }
 
         #endregion
 
         #region IHtmlInterface Members
 
         public void LinkClick(HtmlElement activeElement)
         {
             int line = 0;
             if (Int32.TryParse(activeElement.InnerText, out line))
             {
                 --line;
                 LineSegment lineSeg = this.m_Editor.Document.GetLineSegment(line);
                 this.m_Editor.ActiveTextAreaControl.Caret.Position = this.m_Editor.Document.OffsetToPosition(lineSeg.Offset);
                 this.m_Editor.ActiveTextAreaControl.CenterViewOn(line, 0);
             }
             else
             {
                 string file = activeElement.GetAttribute("href");
                 file = System.Web.HttpUtility.UrlDecode(file);
                 file = file.Substring(8);
                 file = file.Replace('/', '\\');
                 string offset = activeElement.GetAttribute("offset");
                 this.m_Host.CreateEditor(file, Path.GetFileName(file), this.Host.GetFileIcon(file, false), this);
                 this.m_MainForm.GetEditor(file).ScrollTo(Convert.ToInt32(offset));
                 this.m_MainForm.GetEditor(file).Project = this.m_Project;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\Editor.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="68" endline="68"><![CDATA[
             get { return this.m_CodeInfo; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="69" endline="216"><![CDATA[
         }
 
         public class Modifier
         {
             public static int _public = 0x0001;
             public static int _private = 0x0002;
             public static int _protected = 0x0004;
             public static int _static = 0x0008;
             public static int _final = 0x0010;
             public static int _synchronized = 0x0020;
             public static int _volatile = 0x0040;
             public static int _transient = 0x0080;
             public static int _native = 0x0100;
             public static int _abstract = 0x0400;
             public static int _strictfp = 0x0800;
 
             /* sets of modifiers that can be attached to certain program elements    *
              * e.g., "constants" marks all modifiers that may be used with constants */
             public static int
               none = 0x0000,
               access = _public | _protected | _private,    // 0x0007
               classes = access | _abstract | _static | _final | _strictfp,    // 0x0c1f
               fields = access | _static | _final | _transient | _volatile,  // 0x00df
               methods = access | _abstract | _static | _final | _synchronized | _native | _strictfp, // 0x0d3f
               constructors = access, // 0x0007
               interfaces = access | _abstract | _static | _strictfp, // 0x0c0f
               constants = _public | _static | _final, // 0x0019
               all = 0x0dff;
         }
 
         public class Modifiers
         {
             private long cur = 0L;
             private Parser parser;
 
             public Modifiers(Parser parser)
             {
                 this.parser = parser;
             }
 
             public void add(long m)
             {
                 if ((cur & m) == 0) cur |= m;
                 else parser.error("repeated modifier");
             }
 
             public void check(long allowed)
             {
                 long wrong = cur & (allowed ^ Modifier.all);
                 if (wrong != Modifier.none)
                     parser.error("modifier(s) " + toString(wrong) + "not allowed here");
                 else
                     checkAccess();
             }
 
             private void checkAccess()
             {
                 long access = cur & Modifier.access;
                 if (access != Modifier.none && access != Modifier._public &&
                     access != Modifier._protected && access != Modifier._private)
                     parser.error("illegal combination of modifiers
             }
 
             private String toString(long m)
             {
                 String s = "";
                 if ((m & Modifier._public) != 0) s += "public ";
                 if ((m & Modifier._private) != 0) s += "private ";
                 if ((m & Modifier._protected) != 0) s += "protected ";
                 if ((m & Modifier._static) != 0) s += "static ";
                 if ((m & Modifier._final) != 0) s += "final ";
                 if ((m & Modifier._synchronized) != 0) s += "synchronized ";
                 if ((m & Modifier._volatile) != 0) s += "volatile ";
                 if ((m & Modifier._transient) != 0) s += "transient ";
                 if ((m & Modifier._native) != 0) s += "native ";
                 if ((m & Modifier._abstract) != 0) s += "abstract ";
                 if ((m & Modifier._strictfp) != 0) s += "strictfp ";
                 return s;
             }
         }
 
         /*-------------------- expression handling ----------------------------------*/
 
         public class ExprKind
         {
             public static int NONE = 0;
             public static int CONDEXPR = 17;
             public static int APPLY = 25;
             public static int NEWCLASS = 26;
             public static int NEWARRAY = 27;
             public static int PARENS = 28;
             public static int ASSIGN = 29;
             public static int TYPECAST = 30;
             public static int TYPETEST = 31;
             public static int SELECT = 33;
             public static int IDENT = 34;
             public static int LITERAL = 35;
             public static int POS = 41;
             public static int NEG = 42;
             public static int NOT = 43;
             public static int COMPL = 44;
             public static int PREINC = 45;
             public static int PREDEC = 46;
             public static int POSTINC = 47;
             public static int POSTDEC = 48;
             public static int BINARY = 50;
         }
 
         class ExprInfo
         {
             private int kind = ExprKind.NONE;
             private Parser parser;
 
             public ExprInfo(Parser parser)
             {
                 this.parser = parser;
             }
 
             public int getKind()
             {
                 return kind;
             }
 
             public void setKind(int k)
             {
                 kind = k;
             }
 
             public void checkExprStat()
             {
                 if (kind != ExprKind.APPLY && kind != ExprKind.NEWCLASS &&
                      kind != ExprKind.ASSIGN && kind != ExprKind.PREINC &&
                      kind != ExprKind.PREDEC && kind != ExprKind.POSTINC &&
                      kind != ExprKind.POSTDEC)
                     parser.error("not a statement" + " (" + kind + ")");
             }
         }
 
         /*---------------------------- token sets -----------------------------------*/
 
         static int maxTerminals = 160;  // set size
 
         static BitArray newSet(int[] values)
         {
             BitArray s = new BitArray(maxTerminals);
             for (int i = 0; i < values.Length; i++) s.Set(values[i], true);
             return s;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="217" endline="222"><![CDATA[
 
         static BitArray or(BitArray s1, BitArray s2)
         {
             s1.Or(s2);
             return s1;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="223" endline="242"><![CDATA[
 
         static int[] typeKWarr = {_byte, _short, _char, _int, _long, _float, _double, 
                           _bool};
         static int[] castFollowerArr = {_ident, _new, _super, _this, _void, _intLit,
                                 _floatLit, _charLit, _stringLit, _true, _false,
                                 _null, _lpar, _not, _tilde};
         static int[] prefixArr = { _inc, _dec, _not, _tilde, _plus, _minus };
 
         static BitArray
           typeKW = newSet(typeKWarr),
           castFollower = or(newSet(castFollowerArr), typeKW),
           prefix = newSet(prefixArr);
 
         /*---------------------------- auxiliary methods ----------------------------*/
 
         public void error(String s)
         {
             if (errDist >= minErrDist) errors.SemErr(la.line, la.col, s);
             errDist = 0;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="243" endline="261"><![CDATA[
 
         // "(" BasicType {"[""]"} ")"
         bool isSimpleTypeCast()
         {
             // assert
             scanner.ResetPeek();
             Token pt1 = scanner.Peek();
 
             if (typeKW.Get(pt1.kind))
             {
                 Token pt = scanner.Peek();
                 pt = skipDims(pt);
                 if (pt != null)
                 {
                     return pt.kind == _rpar;
                 }
             }
             return false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="262" endline="280"><![CDATA[
 
         // "(" Qualident {"[" "]"} ")" castFollower
         bool guessTypeCast()
         {
             // assert
             scanner.ResetPeek();
             Token pt = scanner.Peek();
             pt = rdQualident(pt);
             if (pt != null)
             {
                 pt = skipDims(pt);
                 if (pt != null)
                 {
                     Token pt1 = scanner.Peek();
                     return pt.kind == _rpar && castFollower.Get(pt1.kind);
                 }
             }
             return false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="281" endline="293"><![CDATA[
 
         // "[" "]"
         Token skipDims(Token pt)
         {
             if (pt.kind != _lbrack) return pt;
             do
             {
                 pt = scanner.Peek();
                 if (pt.kind != _rbrack) return null;
                 pt = scanner.Peek();
             } while (pt.kind == _lbrack);
             return pt;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="294" endline="316"><![CDATA[
 
         /* Checks whether the next sequence of tokens is a qualident *
          * and returns the qualident string                          *
          * !!! Proceeds from current peek position !!!               */
         Token rdQualident(Token pt)
         {
             String qualident = "";
 
             if (pt.kind == _ident)
             {
                 qualident = pt.val;
                 pt = scanner.Peek();
                 while (pt.kind == _dot)
                 {
                     pt = scanner.Peek();
                     if (pt.kind != _ident) return null;
                     qualident += "." + pt.val;
                     pt = scanner.Peek();
                 }
                 while (pt.kind == _dot)
                 {
                     pt = scanner.Peek();
                     if (pt.kind != _ident) return null;
                     qualident += "." + pt.val;
                     pt = scanner.Peek();
                 }
                 return pt;
             }
             else return null;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="317" endline="325"><![CDATA[
 
         // Return the n-th token after the current lookahead token
         Token peek(int n)
         {
             scanner.ResetPeek();
             Token x = la;
             while (n > 0) { x = scanner.Peek(); n--; }
             return x;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="326" endline="338"><![CDATA[
 
         /*-----------------------------------------------------------------*
          * Resolver routines to resolve LL(1) conflicts
          * These routines return a bool value that indicates            *
          * whether the alternative at hand shall be choosen or not.        *
          * They are used in IF ( ... ) expressions.                        *       
          *-----------------------------------------------------------------*/
 
         // ',' (no '}')
         bool commaAndNoRBrace()
         {
             return (la.kind == _comma && peek(1).kind != _rbrace);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="339" endline="344"><![CDATA[
 
         // '.' ident
         bool dotAndIdent()
         {
             return la.kind == _dot && peek(1).kind == _ident;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="345" endline="350"><![CDATA[
 
         // ident '('
         bool identAndLPar()
         {
             return la.kind == _ident && peek(1).kind == _lpar;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="351" endline="356"><![CDATA[
 
         // ident '
         bool isLabel()
         {
             return la.kind == _ident && peek(1).kind == _colon;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="357" endline="362"><![CDATA[
 
         // '[' (no ']')
         bool nonEmptyBracket()
         {
             return (la.kind == _lbrack && peek(1).kind != _rbrack);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="363" endline="368"><![CDATA[
 
         // '['']'
         bool emptyBracket()
         {
             return (la.kind == _lbrack && peek(1).kind == _rbrack);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="369" endline="395"><![CDATA[
 
         // final or Type ident
         bool isLocalVarDecl(bool finalIsSuccess)
         {
             Token pt = la;
             scanner.ResetPeek();
 
             if (la.kind == _final)
                 if (finalIsSuccess) return true;
                 else pt = scanner.Peek();
 
             // basicType | ident
             if (typeKW.Get(pt.kind))
                 pt = scanner.Peek();
             else
                 pt = rdQualident(pt);
 
             if (pt != null)
             {
                 pt = skipDims(pt);
                 if (pt != null)
                 {
                     return pt.kind == _ident;
                 }
             }
             return false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="396" endline="402"><![CDATA[
 
         bool isTypeCast()
         {
             if (la.kind != _lpar) return false;
             if (isSimpleTypeCast()) return true;
             return guessTypeCast();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="403" endline="415"><![CDATA[
 
         // '.' ("super" '.' | "class" | "this") | '(' | '['']'
         bool isIdentSuffix()
         {
             if (la.kind == _dot)
             {
                 scanner.ResetPeek();
                 Token pt = scanner.Peek();
                 if (pt.kind == _super) return scanner.Peek().kind == _dot;
                 return (pt.kind == _class || pt.kind == _this);
             }
             return (la.kind == _lpar || emptyBracket());
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="59" endline="425"><![CDATA[
         int errDist = minErrDist;
         private string m_Current = "";
         private JavaCodeInfo m_CodeInfo = new JavaCodeInfo();
 
         /// <summary>
         /// Gets the Info about the Code...
         /// </summary>
         public JavaCodeInfo CodeInfo
         {
             get { return this.m_CodeInfo; }
         }
 
         public class Modifier
         {
             public static int _public = 0x0001;
             public static int _private = 0x0002;
             public static int _protected = 0x0004;
             public static int _static = 0x0008;
             public static int _final = 0x0010;
             public static int _synchronized = 0x0020;
             public static int _volatile = 0x0040;
             public static int _transient = 0x0080;
             public static int _native = 0x0100;
             public static int _abstract = 0x0400;
             public static int _strictfp = 0x0800;
 
             /* sets of modifiers that can be attached to certain program elements    *
              * e.g., "constants" marks all modifiers that may be used with constants */
             public static int
               none = 0x0000,
               access = _public | _protected | _private,    // 0x0007
               classes = access | _abstract | _static | _final | _strictfp,    // 0x0c1f
               fields = access | _static | _final | _transient | _volatile,  // 0x00df
               methods = access | _abstract | _static | _final | _synchronized | _native | _strictfp, // 0x0d3f
               constructors = access, // 0x0007
               interfaces = access | _abstract | _static | _strictfp, // 0x0c0f
               constants = _public | _static | _final, // 0x0019
               all = 0x0dff;
         }
 
         public class Modifiers
         {
             private long cur = 0L;
             private Parser parser;
 
             public Modifiers(Parser parser)
             {
                 this.parser = parser;
             }
 
             public void add(long m)
             {
                 if ((cur & m) == 0) cur |= m;
                 else parser.error("repeated modifier");
             }
 
             public void check(long allowed)
             {
                 long wrong = cur & (allowed ^ Modifier.all);
                 if (wrong != Modifier.none)
                     parser.error("modifier(s) " + toString(wrong) + "not allowed here");
                 else
                     checkAccess();
             }
 
             private void checkAccess()
             {
                 long access = cur & Modifier.access;
                 if (access != Modifier.none && access != Modifier._public &&
                     access != Modifier._protected && access != Modifier._private)
                     parser.error("illegal combination of modifiers
             }
 
             private String toString(long m)
             {
                 String s = "";
                 if ((m & Modifier._public) != 0) s += "public ";
                 if ((m & Modifier._private) != 0) s += "private ";
                 if ((m & Modifier._protected) != 0) s += "protected ";
                 if ((m & Modifier._static) != 0) s += "static ";
                 if ((m & Modifier._final) != 0) s += "final ";
                 if ((m & Modifier._synchronized) != 0) s += "synchronized ";
                 if ((m & Modifier._volatile) != 0) s += "volatile ";
                 if ((m & Modifier._transient) != 0) s += "transient ";
                 if ((m & Modifier._native) != 0) s += "native ";
                 if ((m & Modifier._abstract) != 0) s += "abstract ";
                 if ((m & Modifier._strictfp) != 0) s += "strictfp ";
                 return s;
             }
         }
 
         /*-------------------- expression handling ----------------------------------*/
 
         public class ExprKind
         {
             public static int NONE = 0;
             public static int CONDEXPR = 17;
             public static int APPLY = 25;
             public static int NEWCLASS = 26;
             public static int NEWARRAY = 27;
             public static int PARENS = 28;
             public static int ASSIGN = 29;
             public static int TYPECAST = 30;
             public static int TYPETEST = 31;
             public static int SELECT = 33;
             public static int IDENT = 34;
             public static int LITERAL = 35;
             public static int POS = 41;
             public static int NEG = 42;
             public static int NOT = 43;
             public static int COMPL = 44;
             public static int PREINC = 45;
             public static int PREDEC = 46;
             public static int POSTINC = 47;
             public static int POSTDEC = 48;
             public static int BINARY = 50;
         }
 
         class ExprInfo
         {
             private int kind = ExprKind.NONE;
             private Parser parser;
 
             public ExprInfo(Parser parser)
             {
                 this.parser = parser;
             }
 
             public int getKind()
             {
                 return kind;
             }
 
             public void setKind(int k)
             {
                 kind = k;
             }
 
             public void checkExprStat()
             {
                 if (kind != ExprKind.APPLY && kind != ExprKind.NEWCLASS &&
                      kind != ExprKind.ASSIGN && kind != ExprKind.PREINC &&
                      kind != ExprKind.PREDEC && kind != ExprKind.POSTINC &&
                      kind != ExprKind.POSTDEC)
                     parser.error("not a statement" + " (" + kind + ")");
             }
         }
 
         /*---------------------------- token sets -----------------------------------*/
 
         static int maxTerminals = 160;  // set size
 
         static BitArray newSet(int[] values)
         {
             BitArray s = new BitArray(maxTerminals);
             for (int i = 0; i < values.Length; i++) s.Set(values[i], true);
             return s;
         }
 
         static BitArray or(BitArray s1, BitArray s2)
         {
             s1.Or(s2);
             return s1;
         }
 
         static int[] typeKWarr = {_byte, _short, _char, _int, _long, _float, _double, 
                           _bool};
         static int[] castFollowerArr = {_ident, _new, _super, _this, _void, _intLit,
                                 _floatLit, _charLit, _stringLit, _true, _false,
                                 _null, _lpar, _not, _tilde};
         static int[] prefixArr = { _inc, _dec, _not, _tilde, _plus, _minus };
 
         static BitArray
           typeKW = newSet(typeKWarr),
           castFollower = or(newSet(castFollowerArr), typeKW),
           prefix = newSet(prefixArr);
 
         /*---------------------------- auxiliary methods ----------------------------*/
 
         public void error(String s)
         {
             if (errDist >= minErrDist) errors.SemErr(la.line, la.col, s);
             errDist = 0;
         }
 
         // "(" BasicType {"[""]"} ")"
         bool isSimpleTypeCast()
         {
             // assert
             scanner.ResetPeek();
             Token pt1 = scanner.Peek();
 
             if (typeKW.Get(pt1.kind))
             {
                 Token pt = scanner.Peek();
                 pt = skipDims(pt);
                 if (pt != null)
                 {
                     return pt.kind == _rpar;
                 }
             }
             return false;
         }
 
         // "(" Qualident {"[" "]"} ")" castFollower
         bool guessTypeCast()
         {
             // assert
             scanner.ResetPeek();
             Token pt = scanner.Peek();
             pt = rdQualident(pt);
             if (pt != null)
             {
                 pt = skipDims(pt);
                 if (pt != null)
                 {
                     Token pt1 = scanner.Peek();
                     return pt.kind == _rpar && castFollower.Get(pt1.kind);
                 }
             }
             return false;
         }
 
         // "[" "]"
         Token skipDims(Token pt)
         {
             if (pt.kind != _lbrack) return pt;
             do
             {
                 pt = scanner.Peek();
                 if (pt.kind != _rbrack) return null;
                 pt = scanner.Peek();
             } while (pt.kind == _lbrack);
             return pt;
         }
 
         /* Checks whether the next sequence of tokens is a qualident *
          * and returns the qualident string                          *
          * !!! Proceeds from current peek position !!!               */
         Token rdQualident(Token pt)
         {
             String qualident = "";
 
             if (pt.kind == _ident)
             {
                 qualident = pt.val;
                 pt = scanner.Peek();
                 while (pt.kind == _dot)
                 {
                     pt = scanner.Peek();
                     if (pt.kind != _ident) return null;
                     qualident += "." + pt.val;
                     pt = scanner.Peek();
                 }
                 return pt;
             }
             else return null;
         }
 
         // Return the n-th token after the current lookahead token
         Token peek(int n)
         {
             scanner.ResetPeek();
             Token x = la;
             while (n > 0) { x = scanner.Peek(); n--; }
             return x;
         }
 
         /*-----------------------------------------------------------------*
          * Resolver routines to resolve LL(1) conflicts
          * These routines return a bool value that indicates            *
          * whether the alternative at hand shall be choosen or not.        *
          * They are used in IF ( ... ) expressions.                        *       
          *-----------------------------------------------------------------*/
 
         // ',' (no '}')
         bool commaAndNoRBrace()
         {
             return (la.kind == _comma && peek(1).kind != _rbrace);
         }
 
         // '.' ident
         bool dotAndIdent()
         {
             return la.kind == _dot && peek(1).kind == _ident;
         }
 
         // ident '('
         bool identAndLPar()
         {
             return la.kind == _ident && peek(1).kind == _lpar;
         }
 
         // ident '
         bool isLabel()
         {
             return la.kind == _ident && peek(1).kind == _colon;
         }
 
         // '[' (no ']')
         bool nonEmptyBracket()
         {
             return (la.kind == _lbrack && peek(1).kind != _rbrack);
         }
 
         // '['']'
         bool emptyBracket()
         {
             return (la.kind == _lbrack && peek(1).kind == _rbrack);
         }
 
         // final or Type ident
         bool isLocalVarDecl(bool finalIsSuccess)
         {
             Token pt = la;
             scanner.ResetPeek();
 
             if (la.kind == _final)
                 if (finalIsSuccess) return true;
                 else pt = scanner.Peek();
 
             // basicType | ident
             if (typeKW.Get(pt.kind))
                 pt = scanner.Peek();
             else
                 pt = rdQualident(pt);
 
             if (pt != null)
             {
                 pt = skipDims(pt);
                 if (pt != null)
                 {
                     return pt.kind == _ident;
                 }
             }
             return false;
         }
 
         bool isTypeCast()
         {
             if (la.kind != _lpar) return false;
             if (isSimpleTypeCast()) return true;
             return guessTypeCast();
         }
 
         // '.' ("super" '.' | "class" | "this") | '(' | '['']'
         bool isIdentSuffix()
         {
             if (la.kind == _dot)
             {
                 scanner.ResetPeek();
                 Token pt = scanner.Peek();
                 if (pt.kind == _super) return scanner.Peek().kind == _dot;
                 return (pt.kind == _class || pt.kind == _this);
             }
             return (la.kind == _lpar || emptyBracket());
         }
 
         /*-------------------------------------------------------------------------*/
 
 
 
         public Parser(Scanner scanner)
         {
             this.scanner = scanner;
             errors = new Errors();
         }
 
         void SynErr(int n)
         {
             if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n);
             errDist = 0;
         }
 
         public void SemErr(string msg)
         {
             if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg);
             errDist = 0;
         }
 
         void Get()
         {
             for (; ; )
             {
                 t = la;
                 la = scanner.Scan();
                 if (la.kind <= maxT) { ++errDist; break; }
 
                 la = t;
             }
         }
 
         void Expect(int n)
         {
             if (la.kind == n) Get(); else { SynErr(n); }
         }
 
         bool StartOf(int s)
         {
             return set[s, la.kind];
         }
 
         void ExpectWeak(int n, int follow)
         {
             if (la.kind == n) Get();
             else
             {
                 SynErr(n);
                 while (!StartOf(follow)) Get();
             }
         }
 
 
         bool WeakSeparator(int n, int syFol, int repFol)
         {
             int kind = la.kind;
             if (kind == n) { Get(); return true; }
             else if (StartOf(repFol)) { return false; }
             else
             {
                 SynErr(n);
                 while (!(set[syFol, kind] || set[repFol, kind] || set[0, kind]))
                 {
                     Get();
                     kind = la.kind;
                 }
                 return StartOf(syFol);
             }
         }
 
 
         void CompilationUnit()
         {
             if (la.kind == 39)
             {
                 Get();
                 Qualident();
                 Expect(40);
             }
             while (la.kind == 41)
             {
                 ImportDeclaration();
             }
             while (StartOf(1))
             {
                 TypeDeclaration();
             }
             if (la.kind != _EOF) error("'class' or 'interface' expected");
         }
 
         void Qualident()
         {
             Expect(1);
             while (la.kind == 27)
             {
                 Get();
                 Expect(1);
             }
         }
 
         void ImportDeclaration()
         {
             Expect(41);
             TokenMatch tm = new TokenMatch(la.val, la.pos);
             this.m_Current = la.val;
             Expect(1);
             QualifiedImport();
             Expect(40);
             tm.Value = this.m_Current;
             this.m_CodeInfo.Imports.Add(tm);
         }
 
         void TypeDeclaration()
         {
             if (StartOf(2))
             {
                 ClassOrInterfaceDeclaration();
             }
             else if (la.kind == 40)
             {
                 Get();
             }
             else SynErr(102);
         }
 
         void QualifiedImport()
         {
             Expect(27);
             this.m_Current += "." + la.val;
             if (la.kind == 1)
             {
                 Get();
                 if (la.kind == 27)
                 {
                     QualifiedImport();
                 }
             }
             else if (la.kind == 42)
             {
                 Get();
             }
             else SynErr(103);
         }
 
         void ClassOrInterfaceDeclaration()
         {
             Modifiers m = new Modifiers(this);
             while (StartOf(3))
             {
                 ClassModifier(m);
             }
             if (la.kind == 9)
             {
                 ClassDeclaration(m);
             }
             else if (la.kind == 56)
             {
                 InterfaceDeclaration(m);
             }
             else SynErr(104);
         }
 
         void ClassModifier(Modifiers m)
         {
             switch (la.kind)
             {
                 case 43
                     {
                         Get();
                         m.add(Modifier._public);
                         break;
                     }
                 case 44
                     {
                         Get();
                         m.add(Modifier._protected);
                         break;
                     }
                 case 45
                     {
                         Get();
                         m.add(Modifier._private);
                         break;
                     }
                 case 46
                     {
                         Get();
                         m.add(Modifier._abstract);
                         break;
                     }
                 case 19
                     {
                         Get();
                         m.add(Modifier._static);
                         break;
                     }
                 case 12
                     {
                         Get();
                         m.add(Modifier._final);
                         break;
                     }
                 case 47
                     {
                         Get();
                         m.add(Modifier._strictfp);
                         break;
                     }
                 default
             }
         }
 
         void ClassDeclaration(Modifiers m)
         {
             m.check(Modifier.classes);
             Expect(9);
             Expect(1);
             if (la.kind == 53)
             {
                 Get();
                 Type();
             }
             if (la.kind == 54)
             {
                 Get();
                 TypeList();
             }
             ClassBody();
         }
 
         void InterfaceDeclaration(Modifiers m)
         {
             m.check(Modifier.interfaces);
             Expect(56);
             Expect(1);
             if (la.kind == 53)
             {
                 Get();
                 TypeList();
             }
             InterfaceBody();
         }
 
         void Modifier2(Modifiers m)
         {
             if (la.kind == 19)
             {
                 Get();
                 m.add(Modifier._static);
             }
             else if (StartOf(4))
             {
                 Modifier1(m);
             }
             else SynErr(106);
         }
 
         void Modifier1(Modifiers m)
         {
             switch (la.kind)
             {
                 case 43
                     {
                         Get();
                         m.add(Modifier._public);
                         break;
                     }
                 case 44
                     {
                         Get();
                         m.add(Modifier._protected);
                         break;
                     }
                 case 45
                     {
                         Get();
                         m.add(Modifier._private);
                         break;
                     }
                 case 46
                     {
                         Get();
                         m.add(Modifier._abstract);
                         break;
                     }
                 case 12
                     {
                         Get();
                         m.add(Modifier._final);
                         break;
                     }
                 case 48
                     {
                         Get();
                         m.add(Modifier._native);
                         break;
                     }
                 case 49
                     {
                         Get();
                         m.add(Modifier._synchronized);
                         break;
                     }
                 case 50
                     {
                         Get();
                         m.add(Modifier._transient);
                         break;
                     }
                 case 51
                     {
                         Get();
                         m.add(Modifier._volatile);
                         break;
                     }
                 case 47
                     {
                         Get();
                         m.add(Modifier._strictfp);
                         break;
                     }
                 default
             }
         }
 
         void Type()
         {
             if (la.kind == 1)
             {
                 Qualident();
             }
             else if (StartOf(5))
             {
                 BasicType();
             }
             else SynErr(108);
             BracketsOpt();
         }
 
         void BasicType()
         {
             switch (la.kind)
             {
                 case 7
                     {
                         Get();
                         break;
                     }
                 case 18
                     {
                         Get();
                         break;
                     }
                 case 8
                     {
                         Get();
                         break;
                     }
                 case 14
                     {
                         Get();
                         break;
                     }
                 case 15
                     {
                         Get();
                         break;
                     }
                 case 13
                     {
                         Get();
                         break;
                     }
                 case 10
                     {
                         Get();
                         break;
                     }
                 case 6
                     {
                         Get();
                         break;
                     }
                 default
             }
         }
 
         void BracketsOpt()
         {
             while (la.kind == 30)
             {
                 Get();
                 Expect(36);
             }
         }
 
         void TypeList()
         {
             Type();
             while (la.kind == 25)
             {
                 Get();
                 Type();
             }
         }
 
         void FormalParameter()
         {
             if (la.kind == 12)
             {
                 Get();
             }
             if (!this.m_Current.Equals("("))
             {
                 this.m_Current += ", ";
             }
             this.m_Current += la.val;
             Type();
             VariableDeclaratorId();
         }
 
         void VariableDeclaratorId()
         {
             Expect(1);
             BracketsOpt();
         }
 
         void QualidentList()
         {
             Qualident();
             while (la.kind == 25)
             {
                 Get();
                 Qualident();
             }
         }
 
         void VariableDeclarator()
         {
             Expect(1);
             VariableDeclaratorRest();
         }
 
         void VariableDeclaratorRest()
         {
             BracketsOpt();
             if (la.kind == 52)
             {
                 Get();
                 VariableInitializer();
             }
         }
 
         void VariableInitializer()
         {
             ExprInfo dummy = new ExprInfo(this);
             if (la.kind == 29)
             {
                 ArrayInitializer();
             }
             else if (StartOf(6))
             {
                 Expression(dummy);
             }
             else SynErr(110);
         }
 
         void ArrayInitializer()
         {
             Expect(29);
             if (StartOf(7))
             {
                 VariableInitializer();
                 while (commaAndNoRBrace())
                 {
                     Expect(25);
                     VariableInitializer();
                 }
             }
             if (la.kind == 25)
             {
                 Get();
             }
             Expect(35);
         }
 
         void Expression(ExprInfo info)
         {
             Expression1(info);
             while (StartOf(8))
             {
                 ExprInfo dummy = new ExprInfo(this);
                 info.setKind(ExprKind.ASSIGN);
                 AssignmentOperator();
                 Expression1(dummy);
             }
         }
 
         void ClassBody()
         {
             Expect(29);
             while (StartOf(9))
             {
                 ClassBodyDeclaration();
             }
             Expect(35);
         }
 
         void ClassBodyDeclaration()
         {
             if (la.kind == 40)
             {
                 Get();
             }
             else if (StartOf(10))
             {
                 Modifiers m = new Modifiers(this);
                 if (la.kind == 19)
                 {
                     Get();
                     m.add(Modifier._static);
                 }
                 if (la.kind == 29)
                 {
                     Block();
                 }
                 else if (StartOf(11))
                 {
                     if (StartOf(4))
                     {
                         Modifier1(m);
                         while (StartOf(12))
                         {
                             Modifier2(m);
                         }
                     }
                     MemberDecl(m);
                 }
                 else SynErr(111);
             }
             else SynErr(112);
         }
 
         void Block()
         {
             Expect(29);
             while (StartOf(13))
             {
                 BlockStatement();
             }
             Expect(35);
         }
 
         void MemberDecl(Modifiers m)
         {
             string dataType = la.val;
             TokenMatch tm = new TokenMatch();
             if (identAndLPar())
             {
                 tm.Position = la.pos;
                 tm.Value = la.val;
                 this.m_Current = "(";
                 Expect(1);
                 ConstructorDeclaratorRest(m);
                 if (!this.m_Current.Equals("()"))
                 {
                     this.m_Current += ")";
                 }
                 tm.Value += this.m_Current;
                 this.m_CodeInfo.Constructors.Add(tm);
             }
             else if (StartOf(14))
             {
                 this.m_Current = "";
                 tm.Position = la.pos;
                 MethodOrFieldDecl(m);
                 tm.Value = this.m_Current + "
                 this.m_CodeInfo.Fields.Add(tm);
             }
             else if (la.kind == 23)
             {
                 m.check(Modifier.methods);
                 Get();
                 tm.Position = la.pos;
                 tm.Value = la.val;
                 this.m_Current = "(";
                 Expect(1);
                 VoidMethodDeclaratorRest();
                 if (this.m_Current.Equals("()"))
                 {
                     this.m_Current += "
                 }
                 else
                 {
                     this.m_Current += ")" + "
                 }
                 tm.Value += this.m_Current;
                 this.m_CodeInfo.Methods.Add(tm);
             }
             else if (la.kind == 9)
             {
                 ClassDeclaration(m);
             }
             else if (la.kind == 56)
             {
                 InterfaceDeclaration(m);
             }
             else SynErr(113);
         }
 
         void ConstructorDeclaratorRest(Modifiers m)
         {
             m.check(Modifier.constructors);
             FormalParameters();
             if (la.kind == 55)
             {
                 Get();
                 QualidentList();
             }
             Block();
         }
 
         void MethodOrFieldDecl(Modifiers m)
         {
             Type();
             string gen = "";
             if (la.kind == 92)
             {
                 gen = la.val;
                 Get();
                 gen += la.val;
                 Get();
                 gen += la.val;
                 Get();
             }
             this.m_Current += la.val + gen;
             Expect(1);
             MethodOrFieldRest(m);
         }
 
         void VoidMethodDeclaratorRest()
         {
             FormalParameters();
             if (la.kind == 55)
             {
                 Get();
                 QualidentList();
             }
             if (la.kind == 29)
             {
                 Block();
             }
             else if (la.kind == 40)
             {
                 Get();
             }
             else SynErr(114);
         }
 
         void MethodOrFieldRest(Modifiers m)
         {
             if (StartOf(15))
             {
                 m.check(Modifier.fields);
                 VariableDeclaratorsRest();
                 Expect(40);
             }
             else if (la.kind == 31)
             {
                 m.check(Modifier.methods);
                 MethodDeclaratorRest();
             }
             else SynErr(115);
         }
 
         void VariableDeclaratorsRest()
         {
             VariableDeclaratorRest();
             while (la.kind == 25)
             {
                 Get();
                 VariableDeclarator();
             }
         }
 
         void MethodDeclaratorRest()
         {
             FormalParameters();
             BracketsOpt();
             if (la.kind == 55)
             {
                 Get();
                 QualidentList();
             }
             if (la.kind == 29)
             {
                 Block();
             }
             else if (la.kind == 40)
             {
                 Get();
             }
             else SynErr(116);
         }
 
         void FormalParameters()
         {
             Expect(31);
             if (StartOf(16))
             {
                 FormalParameter();
                 while (la.kind == 25)
                 {
                     Get();
                     FormalParameter();
                 }
             }
             Expect(37);
         }
 
         void InterfaceBody()
         {
             Expect(29);
             while (StartOf(17))
             {
                 InterfaceBodyDeclaration();
             }
             Expect(35);
         }
 
         void InterfaceBodyDeclaration()
         {
             Modifiers m = new Modifiers(this);
             if (la.kind == 40)
             {
                 Get();
             }
             else if (StartOf(18))
             {
                 while (StartOf(12))
                 {
                     Modifier2(m);
                 }
                 InterfaceMemberDecl(m);
             }
             else SynErr(117);
         }
 
         void InterfaceMemberDecl(Modifiers m)
         {
             if (StartOf(14))
             {
                 InterfaceMethodOrFieldDecl(m);
             }
             else if (la.kind == 23)
             {
                 m.check(Modifier.interfaces);
                 Get();
                 Expect(1);
                 VoidInterfaceMethodDeclaratorRest();
             }
             else if (la.kind == 9)
             {
                 ClassDeclaration(m);
             }
             else if (la.kind == 56)
             {
                 InterfaceDeclaration(m);
             }
             else SynErr(118);
         }
 
         void InterfaceMethodOrFieldDecl(Modifiers m)
         {
             Type();
             Expect(1);
             InterfaceMethodOrFieldRest(m);
         }
 
         void VoidInterfaceMethodDeclaratorRest()
         {
             FormalParameters();
             if (la.kind == 55)
             {
                 Get();
                 QualidentList();
             }
             Expect(40);
         }
 
         void InterfaceMethodOrFieldRest(Modifiers m)
         {
             if (la.kind == 30 || la.kind == 52)
             {
                 m.check(Modifier.constants);
                 ConstantDeclaratorsRest();
                 Expect(40);
             }
             else if (la.kind == 31)
             {
                 m.check(Modifier.interfaces);
                 InterfaceMethodDeclaratorRest();
             }
             else SynErr(119);
         }
 
         void ConstantDeclaratorsRest()
         {
             ConstantDeclaratorRest();
             while (la.kind == 25)
             {
                 Get();
                 ConstantDeclarator();
             }
         }
 
         void InterfaceMethodDeclaratorRest()
         {
             FormalParameters();
             BracketsOpt();
             if (la.kind == 55)
             {
                 Get();
                 QualidentList();
             }
             Expect(40);
         }
 
         void ConstantDeclaratorRest()
         {
             BracketsOpt();
             Expect(52);
             VariableInitializer();
         }
 
         void ConstantDeclarator()
         {
             Expect(1);
             ConstantDeclaratorRest();
         }
 
         void Statement()
         {
             ExprInfo dummy = new ExprInfo(this);
             if (la.kind == 29)
             {
                 Block();
             }
             else if (la.kind == 57)
             {
                 Get();
                 ParExpression();
                 Statement();
                 if (la.kind == 58)
                 {
                     Get();
                     Statement();
                 }
             }
             else if (la.kind == 59)
             {
                 Get();
                 Expect(31);
                 if (StartOf(19))
                 {
                     ForInit();
                 }
                 Expect(40);
                 if (StartOf(6))
                 {
                     Expression(dummy);
                 }
                 Expect(40);
                 if (StartOf(6))
                 {
                     ForUpdate();
                 }
                 Expect(37);
                 Statement();
             }
             else if (la.kind == 60)
             {
                 Get();
                 ParExpression();
                 Statement();
             }
             else if (la.kind == 61)
             {
                 Get();
                 Statement();
                 Expect(60);
                 ParExpression();
                 Expect(40);
             }
             else if (la.kind == 62)
             {
                 Get();
                 Block();
                 if (la.kind == 69)
                 {
                     Catches();
                     if (la.kind == 63)
                     {
                         Get();
                         Block();
                     }
                 }
                 else if (la.kind == 63)
                 {
                     Get();
                     Block();
                 }
                 else SynErr(120);
             }
             else if (la.kind == 64)
             {
                 Get();
                 ParExpression();
                 Expect(29);
                 SwitchBlockStatementGroups();
                 Expect(35);
             }
             else if (la.kind == 49)
             {
                 Get();
                 ParExpression();
                 Block();
             }
             else if (la.kind == 65)
             {
                 Get();
                 if (StartOf(6))
                 {
                     Expression(dummy);
                 }
                 Expect(40);
             }
             else if (la.kind == 66)
             {
                 Get();
                 Expression(dummy);
                 Expect(40);
             }
             else if (la.kind == 67)
             {
                 Get();
                 if (la.kind == 1)
                 {
                     Get();
                 }
                 Expect(40);
             }
             else if (la.kind == 68)
             {
                 Get();
                 if (la.kind == 1)
                 {
                     Get();
                 }
                 Expect(40);
             }
             else if (la.kind == 40)
             {
                 Get();
             }
             else if (isLabel())
             {
                 Expect(1);
                 Expect(24);
                 Statement();
             }
             else if (StartOf(6))
             {
                 StatementExpression();
                 Expect(40);
             }
             else SynErr(121);
         }
 
         void ParExpression()
         {
             ExprInfo dummy = new ExprInfo(this);
             Expect(31);
             Expression(dummy);
             Expect(37);
         }
 
         void ForInit()
         {
             if (isLocalVarDecl(true))
             {
                 LocalVariableDeclaration();
             }
             else if (StartOf(6))
             {
                 StatementExpression();
                 MoreStatementExpressions();
             }
             else SynErr(122);
         }
 
         void ForUpdate()
         {
             StatementExpression();
             MoreStatementExpressions();
         }
 
         void Catches()
         {
             CatchClause();
             while (la.kind == 69)
             {
                 CatchClause();
             }
         }
 
         void SwitchBlockStatementGroups()
         {
             while (la.kind == 70 || la.kind == 71)
             {
                 SwitchBlockStatementGroup();
             }
         }
 
         void StatementExpression()
         {
             ExprInfo info = new ExprInfo(this);
             Expression(info);
             info.checkExprStat();
         }
 
         void BlockStatement()
         {
             if (isLocalVarDecl(false))
             {
                 LocalVariableDeclaration();
                 Expect(40);
             }
             else if (StartOf(2))
             {
                 ClassOrInterfaceDeclaration();
             }
             else if (StartOf(20))
             {
                 Statement();
             }
             else SynErr(123);
         }
 
         void LocalVariableDeclaration()
         {
             if (la.kind == 12)
             {
                 Get();
             }
             Type();
             VariableDeclarators();
         }
 
         void VariableDeclarators()
         {
             VariableDeclarator();
             while (la.kind == 25)
             {
                 Get();
                 VariableDeclarator();
             }
         }
 
         void MoreStatementExpressions()
         {
             while (la.kind == 25)
             {
                 Get();
                 StatementExpression();
             }
         }
 
         void CatchClause()
         {
             Expect(69);
             Expect(31);
             FormalParameter();
             Expect(37);
             Block();
         }
 
         void SwitchBlockStatementGroup()
         {
             SwitchLabel();
             while (StartOf(13))
             {
                 BlockStatement();
             }
         }
 
         void SwitchLabel()
         {
             if (la.kind == 70)
             {
                 ExprInfo dummy = new ExprInfo(this);
                 Get();
                 Expression(dummy);
                 Expect(24);
             }
             else if (la.kind == 71)
             {
                 Get();
                 Expect(24);
             }
             else SynErr(124);
         }
 
         void Expression1(ExprInfo info)
         {
             Expression2(info);
             if (la.kind == 72)
             {
                 info.setKind(ExprKind.CONDEXPR);
                 ConditionalExpr();
             }
         }
 
         void AssignmentOperator()
         {
             switch (la.kind)
             {
                 case 52
                     {
                         Get();
                         break;
                     }
                 case 74
                     {
                         Get();
                         break;
                     }
                 case 75
                     {
                         Get();
                         break;
                     }
                 case 76
                     {
                         Get();
                         break;
                     }
                 case 77
                     {
                         Get();
                         break;
                     }
                 case 78
                     {
                         Get();
                         break;
                     }
                 case 79
                     {
                         Get();
                         break;
                     }
                 case 80
                     {
                         Get();
                         break;
                     }
                 case 81
                     {
                         Get();
                         break;
                     }
                 case 82
                     {
                         Get();
                         break;
                     }
                 case 83
                     {
                         Get();
                         break;
                     }
                 case 84
                     {
                         Get();
                         break;
                     }
                 default
             }
         }
 
         void Expression2(ExprInfo info)
         {
             Expression3(info);
             if (StartOf(21))
             {
                 Expression2Rest(info);
             }
         }
 
         void ConditionalExpr()
         {
             ExprInfo dummy = new ExprInfo(this);
             Expect(72);
             Expression(dummy);
             Expect(24);
             Expression1(dummy);
         }
 
         void Expression3(ExprInfo info)
         {
             int pre = ExprKind.NONE;
             while (prefix.Get(la.kind) || isTypeCast())
             {
                 if (StartOf(22))
                 {
                     PrefixOp(info);
                     if (pre == ExprKind.NONE) pre = info.getKind();
                 }
                 else if (la.kind == 31)
                 {
                     Get();
                     Type();
                     Expect(37);
                     info.setKind(ExprKind.TYPECAST);
                 }
                 else SynErr(126);
             }
             Primary(info);
             while (la.kind == 27 || la.kind == 30)
             {
                 Selector(info);
             }
             while (la.kind == 26 || la.kind == 28)
             {
                 PostfixOp(info);
             }
             if (pre != ExprKind.NONE) info.setKind(pre);
         }
 
         void Expression2Rest(ExprInfo info)
         {
             ExprInfo dummy = new ExprInfo(this);
             if (StartOf(23))
             {
                 Infixop();
                 Expression3(dummy);
                 while (StartOf(23))
                 {
                     Infixop();
                     Expression3(dummy);
                 }
                 info.setKind(ExprKind.BINARY);
             }
             else if (la.kind == 73)
             {
                 Get();
                 Type();
                 info.setKind(ExprKind.TYPETEST);
             }
             else SynErr(127);
         }
 
         void Infixop()
         {
             switch (la.kind)
             {
                 case 85
                     {
                         Get();
                         break;
                     }
                 case 86
                     {
                         Get();
                         break;
                     }
                 case 87
                     {
                         Get();
                         break;
                     }
                 case 88
                     {
                         Get();
                         break;
                     }
                 case 89
                     {
                         Get();
                         break;
                     }
                 case 90
                     {
                         Get();
                         break;
                     }
                 case 91
                     {
                         Get();
                         break;
                     }
                 case 92
                     {
                         Get();
                         break;
                     }
                 case 93
                     {
                         Get();
                         break;
                     }
                 case 94
                     {
                         Get();
                         break;
                     }
                 case 95
                     {
                         Get();
                         break;
                     }
                 case 96
                     {
                         Get();
                         break;
                     }
                 case 97
                     {
                         Get();
                         break;
                     }
                 case 98
                     {
                         Get();
                         break;
                     }
                 case 34
                     {
                         Get();
                         break;
                     }
                 case 32
                     {
                         Get();
                         break;
                     }
                 case 42
                     {
                         Get();
                         break;
                     }
                 case 99
                     {
                         Get();
                         break;
                     }
                 case 100
                     {
                         Get();
                         break;
                     }
                 default
             }
         }
 
         void PrefixOp(ExprInfo info)
         {
             switch (la.kind)
             {
                 case 28
                     {
                         Get();
                         info.setKind(ExprKind.PREINC);
                         break;
                     }
                 case 26
                     {
                         Get();
                         info.setKind(ExprKind.PREDEC);
                         break;
                     }
                 case 33
                     {
                         Get();
                         info.setKind(ExprKind.NOT);
                         break;
                     }
                 case 38
                     {
                         Get();
                         info.setKind(ExprKind.COMPL);
                         break;
                     }
                 case 34
                     {
                         Get();
                         info.setKind(ExprKind.POS);
                         break;
                     }
                 case 32
                     {
                         Get();
                         info.setKind(ExprKind.NEG);
                         break;
                     }
                 default
             }
         }
 
         void Primary(ExprInfo info)
         {
             switch (la.kind)
             {
                 case 31
                     {
                         Get();
                         Expression(info);
                         Expect(37);
                         info.setKind(ExprKind.PARENS);
                         break;
                     }
                 case 21
                     {
                         Get();
                         info.setKind(ExprKind.IDENT);
                         ArgumentsOpt(info);
                         break;
                     }
                 case 20
                     {
                         Get();
                         SuperSuffix(info);
                         break;
                     }
                 case 2
                 case 3
                 case 4
                 case 5
                 case 11
                 case 17
                 case 22
                     {
                         Literal();
                         info.setKind(ExprKind.LITERAL);
                         break;
                     }
                 case 16
                     {
                         Get();
                         Creator(info);
                         break;
                     }
                 case 1
                     {
                         Get();
                         while (dotAndIdent())
                         {
                             Expect(27);
                             Expect(1);
                         }
                         info.setKind(ExprKind.IDENT);
                         if (isIdentSuffix())
                         {
                             IdentifierSuffix(info);
                         }
                         break;
                     }
                 case 6
                 case 7
                 case 8
                 case 10
                 case 13
                 case 14
                 case 15
                 case 18
                     {
                         BasicType();
                         BracketsOpt();
                         Expect(27);
                         Expect(9);
                         info.setKind(ExprKind.SELECT);
                         break;
                     }
                 case 23
                     {
                         Get();
                         Expect(27);
                         Expect(9);
                         info.setKind(ExprKind.SELECT);
                         break;
                     }
                 default
             }
         }
 
         void Selector(ExprInfo info)
         {
             ExprInfo dummy = new ExprInfo(this);
             if (la.kind == 27)
             {
                 Get();
                 if (la.kind == 1)
                 {
                     Get();
                     ArgumentsOpt(info);
                 }
                 else if (la.kind == 20)
                 {
                     Get();
                     Arguments();
                 }
                 else if (la.kind == 16)
                 {
                     Get();
                     InnerCreator();
                 }
                 else SynErr(131);
             }
             else if (la.kind == 30)
             {
                 Get();
                 Expression(dummy);
                 Expect(36);
             }
             else SynErr(132);
         }
 
         void PostfixOp(ExprInfo info)
         {
             if (la.kind == 28)
             {
                 Get();
                 info.setKind(ExprKind.POSTINC);
             }
             else if (la.kind == 26)
             {
                 Get();
                 info.setKind(ExprKind.POSTDEC);
             }
             else SynErr(133);
         }
 
         void ArgumentsOpt(ExprInfo info)
         {
             if (la.kind == 31)
             {
                 info.setKind(ExprKind.APPLY);
                 Arguments();
             }
         }
 
         void SuperSuffix(ExprInfo info)
         {
             if (la.kind == 31)
             {
                 Arguments();
                 info.setKind(ExprKind.APPLY);
             }
             else if (la.kind == 27)
             {
                 Get();
                 Expect(1);
                 info.setKind(ExprKind.IDENT);
                 ArgumentsOpt(info);
             }
             else SynErr(134);
         }
 
         void Literal()
         {
             switch (la.kind)
             {
                 case 2
                     {
                         Get();
                         break;
                     }
                 case 3
                     {
                         Get();
                         break;
                     }
                 case 4
                     {
                         Get();
                         break;
                     }
                 case 5
                     {
                         Get();
                         break;
                     }
                 case 22
                     {
                         Get();
                         break;
                     }
                 case 11
                     {
                         Get();
                         break;
                     }
                 case 17
                     {
                         Get();
                         break;
                     }
                 default
             }
         }
 
         void Creator(ExprInfo info)
         {
             if (StartOf(5))
             {
                 BasicType();
                 ArrayCreatorRest();
                 info.setKind(ExprKind.NEWARRAY);
             }
             else if (la.kind == 1)
             {
                 Qualident();
                 if (la.kind == 30)
                 {
                     ArrayCreatorRest();
                     info.setKind(ExprKind.NEWARRAY);
                 }
                 else if (la.kind == 31)
                 {
                     ClassCreatorRest();
                     info.setKind(ExprKind.NEWCLASS);
                 }
                 else SynErr(136);
             }
             else SynErr(137);
         }
 
         void IdentifierSuffix(ExprInfo info)
         {
             if (la.kind == 30)
             {
                 Get();
                 Expect(36);
                 BracketsOpt();
                 Expect(27);
                 Expect(9);
                 info.setKind(ExprKind.SELECT);
             }
             else if (la.kind == 31)
             {
                 Arguments();
                 info.setKind(ExprKind.APPLY);
             }
             else if (la.kind == 27)
             {
                 Get();
                 if (la.kind == 9)
                 {
                     Get();
                 }
                 else if (la.kind == 21)
                 {
                     Get();
                 }
                 else if (la.kind == 20)
                 {
                     Get();
                     Expect(27);
                     Expect(1);
                     ArgumentsOpt(info);
                 }
                 else SynErr(138);
             }
             else SynErr(139);
         }
 
         void Arguments()
         {
             ExprInfo dummy = new ExprInfo(this);
             Expect(31);
             if (StartOf(6))
             {
                 Expression(dummy);
                 while (la.kind == 25)
                 {
                     Get();
                     Expression(dummy);
                 }
             }
             Expect(37);
         }
 
         void ArrayCreatorRest()
         {
             ExprInfo dummy = new ExprInfo(this);
             Expect(30);
             if (la.kind == 36)
             {
                 Get();
                 BracketsOpt();
                 ArrayInitializer();
             }
             else if (StartOf(6))
             {
                 Expression(dummy);
                 Expect(36);
                 while (nonEmptyBracket())
                 {
                     Expect(30);
                     Expression(dummy);
                     Expect(36);
                 }
                 while (emptyBracket())
                 {
                     Expect(30);
                     Expect(36);
                 }
             }
             else SynErr(140);
         }
 
         void ClassCreatorRest()
         {
             Arguments();
             if (la.kind == 29)
             {
                 ClassBody();
             }
         }
 
         void InnerCreator()
         {
             Expect(1);
             ClassCreatorRest();
         }
 
 
 
         public void Parse()
         {
             la = new Token();
             la.val = "";
             Get();
             CompilationUnit();
 
             Expect(0);
         }
 
         bool[,] set = {
         public Parser(Scanner scanner)
         {
             this.scanner = scanner;
             errors = new Errors();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="426" endline="431"><![CDATA[
 
         void SynErr(int n)
         {
             if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n);
             errDist = 0;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="432" endline="437"><![CDATA[
 
         public void SemErr(string msg)
         {
             if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg);
             errDist = 0;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="438" endline="449"><![CDATA[
 
         void Get()
         {
             for (; ; )
             {
                 t = la;
                 la = scanner.Scan();
                 if (la.kind <= maxT) { ++errDist; break; }
 
                 la = t;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="450" endline="454"><![CDATA[
 
         void Expect(int n)
         {
             if (la.kind == n) Get(); else { SynErr(n); }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="455" endline="459"><![CDATA[
 
         bool StartOf(int s)
         {
             return set[s, la.kind];
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="460" endline="469"><![CDATA[
 
         void ExpectWeak(int n, int follow)
         {
             if (la.kind == n) Get();
             else
             {
                 SynErr(n);
                 while (!StartOf(follow)) Get();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="470" endline="487"><![CDATA[
 
 
         bool WeakSeparator(int n, int syFol, int repFol)
         {
             int kind = la.kind;
             if (kind == n) { Get(); return true; }
             else if (StartOf(repFol)) { return false; }
             else
             {
                 SynErr(n);
                 while (!(set[syFol, kind] || set[repFol, kind] || set[0, kind]))
                 {
                     Get();
                     kind = la.kind;
                 }
                 while (!(set[syFol, kind] || set[repFol, kind] || set[0, kind]))
                 {
                     Get();
                     kind = la.kind;
                 }
                 return StartOf(syFol);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="488" endline="507"><![CDATA[
 
 
         void CompilationUnit()
         {
             if (la.kind == 39)
             {
                 Get();
                 Qualident();
                 Expect(40);
             }
             while (la.kind == 41)
             {
                 ImportDeclaration();
             }
             while (la.kind == 41)
             {
                 ImportDeclaration();
             }
             while (StartOf(1))
             {
                 TypeDeclaration();
             }
             while (StartOf(1))
             {
                 TypeDeclaration();
             }
             if (la.kind != _EOF) error("'class' or 'interface' expected");
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="508" endline="517"><![CDATA[
 
         void Qualident()
         {
             Expect(1);
             while (la.kind == 27)
             {
                 Get();
                 Expect(1);
             }
             while (la.kind == 27)
             {
                 Get();
                 Expect(1);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="518" endline="529"><![CDATA[
 
         void ImportDeclaration()
         {
             Expect(41);
             TokenMatch tm = new TokenMatch(la.val, la.pos);
             this.m_Current = la.val;
             Expect(1);
             QualifiedImport();
             Expect(40);
             tm.Value = this.m_Current;
             this.m_CodeInfo.Imports.Add(tm);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="530" endline="542"><![CDATA[
 
         void TypeDeclaration()
         {
             if (StartOf(2))
             {
                 ClassOrInterfaceDeclaration();
             }
             else if (la.kind == 40)
             {
                 Get();
             }
             else SynErr(102);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="543" endline="561"><![CDATA[
 
         void QualifiedImport()
         {
             Expect(27);
             this.m_Current += "." + la.val;
             if (la.kind == 1)
             {
                 Get();
                 if (la.kind == 27)
                 {
                     QualifiedImport();
                 }
             }
             else if (la.kind == 42)
             {
                 Get();
             }
             else SynErr(103);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="562" endline="579"><![CDATA[
 
         void ClassOrInterfaceDeclaration()
         {
             Modifiers m = new Modifiers(this);
             while (StartOf(3))
             {
                 ClassModifier(m);
             }
             while (StartOf(3))
             {
                 ClassModifier(m);
             }
             if (la.kind == 9)
             {
                 ClassDeclaration(m);
             }
             else if (la.kind == 56)
             {
                 InterfaceDeclaration(m);
             }
             else SynErr(104);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="580" endline="629"><![CDATA[
 
         void ClassModifier(Modifiers m)
         {
             switch (la.kind)
             {
                 case 43
                     {
                         Get();
                         m.add(Modifier._public);
                         break;
                     }
                 case 44
                     {
                         Get();
                         m.add(Modifier._protected);
                         break;
                     }
                 case 45
                     {
                         Get();
                         m.add(Modifier._private);
                         break;
                     }
                 case 46
                     {
                         Get();
                         m.add(Modifier._abstract);
                         break;
                     }
                 case 19
                     {
                         Get();
                         m.add(Modifier._static);
                         break;
                     }
                 case 12
                     {
                         Get();
                         m.add(Modifier._final);
                         break;
                     }
                 case 47
                     {
                         Get();
                         m.add(Modifier._strictfp);
                         break;
                     }
                 default
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="630" endline="647"><![CDATA[
 
         void ClassDeclaration(Modifiers m)
         {
             m.check(Modifier.classes);
             Expect(9);
             Expect(1);
             if (la.kind == 53)
             {
                 Get();
                 Type();
             }
             if (la.kind == 54)
             {
                 Get();
                 TypeList();
             }
             ClassBody();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="648" endline="660"><![CDATA[
 
         void InterfaceDeclaration(Modifiers m)
         {
             m.check(Modifier.interfaces);
             Expect(56);
             Expect(1);
             if (la.kind == 53)
             {
                 Get();
                 TypeList();
             }
             InterfaceBody();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="661" endline="674"><![CDATA[
 
         void Modifier2(Modifiers m)
         {
             if (la.kind == 19)
             {
                 Get();
                 m.add(Modifier._static);
             }
             else if (StartOf(4))
             {
                 Modifier1(m);
             }
             else SynErr(106);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="675" endline="742"><![CDATA[
 
         void Modifier1(Modifiers m)
         {
             switch (la.kind)
             {
                 case 43
                     {
                         Get();
                         m.add(Modifier._public);
                         break;
                     }
                 case 44
                     {
                         Get();
                         m.add(Modifier._protected);
                         break;
                     }
                 case 45
                     {
                         Get();
                         m.add(Modifier._private);
                         break;
                     }
                 case 46
                     {
                         Get();
                         m.add(Modifier._abstract);
                         break;
                     }
                 case 12
                     {
                         Get();
                         m.add(Modifier._final);
                         break;
                     }
                 case 48
                     {
                         Get();
                         m.add(Modifier._native);
                         break;
                     }
                 case 49
                     {
                         Get();
                         m.add(Modifier._synchronized);
                         break;
                     }
                 case 50
                     {
                         Get();
                         m.add(Modifier._transient);
                         break;
                     }
                 case 51
                     {
                         Get();
                         m.add(Modifier._volatile);
                         break;
                     }
                 case 47
                     {
                         Get();
                         m.add(Modifier._strictfp);
                         break;
                     }
                 default
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="743" endline="756"><![CDATA[
 
         void Type()
         {
             if (la.kind == 1)
             {
                 Qualident();
             }
             else if (StartOf(5))
             {
                 BasicType();
             }
             else SynErr(108);
             BracketsOpt();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="757" endline="804"><![CDATA[
 
         void BasicType()
         {
             switch (la.kind)
             {
                 case 7
                     {
                         Get();
                         break;
                     }
                 case 18
                     {
                         Get();
                         break;
                     }
                 case 8
                     {
                         Get();
                         break;
                     }
                 case 14
                     {
                         Get();
                         break;
                     }
                 case 15
                     {
                         Get();
                         break;
                     }
                 case 13
                     {
                         Get();
                         break;
                     }
                 case 10
                     {
                         Get();
                         break;
                     }
                 case 6
                     {
                         Get();
                         break;
                     }
                 default
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="805" endline="813"><![CDATA[
 
         void BracketsOpt()
         {
             while (la.kind == 30)
             {
                 Get();
                 Expect(36);
             }
             while (la.kind == 30)
             {
                 Get();
                 Expect(36);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="814" endline="823"><![CDATA[
 
         void TypeList()
         {
             Type();
             while (la.kind == 25)
             {
                 Get();
                 Type();
             }
             while (la.kind == 25)
             {
                 Get();
                 Type();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="824" endline="838"><![CDATA[
 
         void FormalParameter()
         {
             if (la.kind == 12)
             {
                 Get();
             }
             if (!this.m_Current.Equals("("))
             {
                 this.m_Current += ", ";
             }
             this.m_Current += la.val;
             Type();
             VariableDeclaratorId();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="839" endline="844"><![CDATA[
 
         void VariableDeclaratorId()
         {
             Expect(1);
             BracketsOpt();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="845" endline="854"><![CDATA[
 
         void QualidentList()
         {
             Qualident();
             while (la.kind == 25)
             {
                 Get();
                 Qualident();
             }
             while (la.kind == 25)
             {
                 Get();
                 Qualident();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="855" endline="860"><![CDATA[
 
         void VariableDeclarator()
         {
             Expect(1);
             VariableDeclaratorRest();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="861" endline="870"><![CDATA[
 
         void VariableDeclaratorRest()
         {
             BracketsOpt();
             if (la.kind == 52)
             {
                 Get();
                 VariableInitializer();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="871" endline="884"><![CDATA[
 
         void VariableInitializer()
         {
             ExprInfo dummy = new ExprInfo(this);
             if (la.kind == 29)
             {
                 ArrayInitializer();
             }
             else if (StartOf(6))
             {
                 Expression(dummy);
             }
             else SynErr(110);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="885" endline="903"><![CDATA[
 
         void ArrayInitializer()
         {
             Expect(29);
             if (StartOf(7))
             {
                 VariableInitializer();
                 while (commaAndNoRBrace())
                 {
                     Expect(25);
                     VariableInitializer();
                 }
                 while (commaAndNoRBrace())
                 {
                     Expect(25);
                     VariableInitializer();
                 }
             }
             if (la.kind == 25)
             {
                 Get();
             }
             Expect(35);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="904" endline="915"><![CDATA[
 
         void Expression(ExprInfo info)
         {
             Expression1(info);
             while (StartOf(8))
             {
                 ExprInfo dummy = new ExprInfo(this);
                 info.setKind(ExprKind.ASSIGN);
                 AssignmentOperator();
                 Expression1(dummy);
             }
             while (StartOf(8))
             {
                 ExprInfo dummy = new ExprInfo(this);
                 info.setKind(ExprKind.ASSIGN);
                 AssignmentOperator();
                 Expression1(dummy);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="916" endline="925"><![CDATA[
 
         void ClassBody()
         {
             Expect(29);
             while (StartOf(9))
             {
                 ClassBodyDeclaration();
             }
             while (StartOf(9))
             {
                 ClassBodyDeclaration();
             }
             Expect(35);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="926" endline="960"><![CDATA[
 
         void ClassBodyDeclaration()
         {
             if (la.kind == 40)
             {
                 Get();
             }
             else if (StartOf(10))
             {
                 Modifiers m = new Modifiers(this);
                 if (la.kind == 19)
                 {
                     Get();
                     m.add(Modifier._static);
                 }
                 if (la.kind == 29)
                 {
                     Block();
                 }
                 else if (StartOf(11))
                 {
                     if (StartOf(4))
                     {
                         Modifier1(m);
                         while (StartOf(12))
                         {
                             Modifier2(m);
                         }
                         while (StartOf(12))
                         {
                             Modifier2(m);
                         }
                     }
                     MemberDecl(m);
                 }
                 else SynErr(111);
             }
             else SynErr(112);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="961" endline="970"><![CDATA[
 
         void Block()
         {
             Expect(29);
             while (StartOf(13))
             {
                 BlockStatement();
             }
             while (StartOf(13))
             {
                 BlockStatement();
             }
             Expect(35);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="971" endline="1027"><![CDATA[
 
         void MemberDecl(Modifiers m)
         {
             string dataType = la.val;
             TokenMatch tm = new TokenMatch();
             if (identAndLPar())
             {
                 tm.Position = la.pos;
                 tm.Value = la.val;
                 this.m_Current = "(";
                 Expect(1);
                 ConstructorDeclaratorRest(m);
                 if (!this.m_Current.Equals("()"))
                 {
                     this.m_Current += ")";
                 }
                 tm.Value += this.m_Current;
                 this.m_CodeInfo.Constructors.Add(tm);
             }
             else if (StartOf(14))
             {
                 this.m_Current = "";
                 tm.Position = la.pos;
                 MethodOrFieldDecl(m);
                 tm.Value = this.m_Current + "
                 this.m_CodeInfo.Fields.Add(tm);
             }
             else if (la.kind == 23)
             {
                 m.check(Modifier.methods);
                 Get();
                 tm.Position = la.pos;
                 tm.Value = la.val;
                 this.m_Current = "(";
                 Expect(1);
                 VoidMethodDeclaratorRest();
                 if (this.m_Current.Equals("()"))
                 {
                     this.m_Current += "
                 }
                 else
                 {
                     this.m_Current += ")" + "
                 }
                 tm.Value += this.m_Current;
                 this.m_CodeInfo.Methods.Add(tm);
             }
             else if (la.kind == 9)
             {
                 ClassDeclaration(m);
             }
             else if (la.kind == 56)
             {
                 InterfaceDeclaration(m);
             }
             else SynErr(113);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1028" endline="1039"><![CDATA[
 
         void ConstructorDeclaratorRest(Modifiers m)
         {
             m.check(Modifier.constructors);
             FormalParameters();
             if (la.kind == 55)
             {
                 Get();
                 QualidentList();
             }
             Block();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1040" endline="1057"><![CDATA[
 
         void MethodOrFieldDecl(Modifiers m)
         {
             Type();
             string gen = "";
             if (la.kind == 92)
             {
                 gen = la.val;
                 Get();
                 gen += la.val;
                 Get();
                 gen += la.val;
                 Get();
             }
             this.m_Current += la.val + gen;
             Expect(1);
             MethodOrFieldRest(m);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1058" endline="1076"><![CDATA[
 
         void VoidMethodDeclaratorRest()
         {
             FormalParameters();
             if (la.kind == 55)
             {
                 Get();
                 QualidentList();
             }
             if (la.kind == 29)
             {
                 Block();
             }
             else if (la.kind == 40)
             {
                 Get();
             }
             else SynErr(114);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1077" endline="1092"><![CDATA[
 
         void MethodOrFieldRest(Modifiers m)
         {
             if (StartOf(15))
             {
                 m.check(Modifier.fields);
                 VariableDeclaratorsRest();
                 Expect(40);
             }
             else if (la.kind == 31)
             {
                 m.check(Modifier.methods);
                 MethodDeclaratorRest();
             }
             else SynErr(115);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1093" endline="1102"><![CDATA[
 
         void VariableDeclaratorsRest()
         {
             VariableDeclaratorRest();
             while (la.kind == 25)
             {
                 Get();
                 VariableDeclarator();
             }
             while (la.kind == 25)
             {
                 Get();
                 VariableDeclarator();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1103" endline="1122"><![CDATA[
 
         void MethodDeclaratorRest()
         {
             FormalParameters();
             BracketsOpt();
             if (la.kind == 55)
             {
                 Get();
                 QualidentList();
             }
             if (la.kind == 29)
             {
                 Block();
             }
             else if (la.kind == 40)
             {
                 Get();
             }
             else SynErr(116);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1123" endline="1137"><![CDATA[
 
         void FormalParameters()
         {
             Expect(31);
             if (StartOf(16))
             {
                 FormalParameter();
                 while (la.kind == 25)
                 {
                     Get();
                     FormalParameter();
                 }
                 while (la.kind == 25)
                 {
                     Get();
                     FormalParameter();
                 }
             }
             Expect(37);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1138" endline="1147"><![CDATA[
 
         void InterfaceBody()
         {
             Expect(29);
             while (StartOf(17))
             {
                 InterfaceBodyDeclaration();
             }
             while (StartOf(17))
             {
                 InterfaceBodyDeclaration();
             }
             Expect(35);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1148" endline="1165"><![CDATA[
 
         void InterfaceBodyDeclaration()
         {
             Modifiers m = new Modifiers(this);
             if (la.kind == 40)
             {
                 Get();
             }
             else if (StartOf(18))
             {
                 while (StartOf(12))
                 {
                     Modifier2(m);
                 }
                 while (StartOf(12))
                 {
                     Modifier2(m);
                 }
                 InterfaceMemberDecl(m);
             }
             else SynErr(117);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1166" endline="1189"><![CDATA[
 
         void InterfaceMemberDecl(Modifiers m)
         {
             if (StartOf(14))
             {
                 InterfaceMethodOrFieldDecl(m);
             }
             else if (la.kind == 23)
             {
                 m.check(Modifier.interfaces);
                 Get();
                 Expect(1);
                 VoidInterfaceMethodDeclaratorRest();
             }
             else if (la.kind == 9)
             {
                 ClassDeclaration(m);
             }
             else if (la.kind == 56)
             {
                 InterfaceDeclaration(m);
             }
             else SynErr(118);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1190" endline="1196"><![CDATA[
 
         void InterfaceMethodOrFieldDecl(Modifiers m)
         {
             Type();
             Expect(1);
             InterfaceMethodOrFieldRest(m);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1197" endline="1207"><![CDATA[
 
         void VoidInterfaceMethodDeclaratorRest()
         {
             FormalParameters();
             if (la.kind == 55)
             {
                 Get();
                 QualidentList();
             }
             Expect(40);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1208" endline="1223"><![CDATA[
 
         void InterfaceMethodOrFieldRest(Modifiers m)
         {
             if (la.kind == 30 || la.kind == 52)
             {
                 m.check(Modifier.constants);
                 ConstantDeclaratorsRest();
                 Expect(40);
             }
             else if (la.kind == 31)
             {
                 m.check(Modifier.interfaces);
                 InterfaceMethodDeclaratorRest();
             }
             else SynErr(119);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1224" endline="1233"><![CDATA[
 
         void ConstantDeclaratorsRest()
         {
             ConstantDeclaratorRest();
             while (la.kind == 25)
             {
                 Get();
                 ConstantDeclarator();
             }
             while (la.kind == 25)
             {
                 Get();
                 ConstantDeclarator();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1234" endline="1245"><![CDATA[
 
         void InterfaceMethodDeclaratorRest()
         {
             FormalParameters();
             BracketsOpt();
             if (la.kind == 55)
             {
                 Get();
                 QualidentList();
             }
             Expect(40);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1246" endline="1252"><![CDATA[
 
         void ConstantDeclaratorRest()
         {
             BracketsOpt();
             Expect(52);
             VariableInitializer();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1253" endline="1258"><![CDATA[
 
         void ConstantDeclarator()
         {
             Expect(1);
             ConstantDeclaratorRest();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1259" endline="1396"><![CDATA[
 
         void Statement()
         {
             ExprInfo dummy = new ExprInfo(this);
             if (la.kind == 29)
             {
                 Block();
             }
             else if (la.kind == 57)
             {
                 Get();
                 ParExpression();
                 Statement();
                 if (la.kind == 58)
                 {
                     Get();
                     Statement();
                 }
             }
             else if (la.kind == 59)
             {
                 Get();
                 Expect(31);
                 if (StartOf(19))
                 {
                     ForInit();
                 }
                 Expect(40);
                 if (StartOf(6))
                 {
                     Expression(dummy);
                 }
                 Expect(40);
                 if (StartOf(6))
                 {
                     ForUpdate();
                 }
                 Expect(37);
                 Statement();
             }
             else if (la.kind == 60)
             {
                 Get();
                 ParExpression();
                 Statement();
             }
             else if (la.kind == 61)
             {
                 Get();
                 Statement();
                 Expect(60);
                 ParExpression();
                 Expect(40);
             }
             else if (la.kind == 62)
             {
                 Get();
                 Block();
                 if (la.kind == 69)
                 {
                     Catches();
                     if (la.kind == 63)
                     {
                         Get();
                         Block();
                     }
                 }
                 else if (la.kind == 63)
                 {
                     Get();
                     Block();
                 }
                 else SynErr(120);
             }
             else if (la.kind == 64)
             {
                 Get();
                 ParExpression();
                 Expect(29);
                 SwitchBlockStatementGroups();
                 Expect(35);
             }
             else if (la.kind == 49)
             {
                 Get();
                 ParExpression();
                 Block();
             }
             else if (la.kind == 65)
             {
                 Get();
                 if (StartOf(6))
                 {
                     Expression(dummy);
                 }
                 Expect(40);
             }
             else if (la.kind == 66)
             {
                 Get();
                 Expression(dummy);
                 Expect(40);
             }
             else if (la.kind == 67)
             {
                 Get();
                 if (la.kind == 1)
                 {
                     Get();
                 }
                 Expect(40);
             }
             else if (la.kind == 68)
             {
                 Get();
                 if (la.kind == 1)
                 {
                     Get();
                 }
                 Expect(40);
             }
             else if (la.kind == 40)
             {
                 Get();
             }
             else if (isLabel())
             {
                 Expect(1);
                 Expect(24);
                 Statement();
             }
             else if (StartOf(6))
             {
                 StatementExpression();
                 Expect(40);
             }
             else SynErr(121);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1397" endline="1404"><![CDATA[
 
         void ParExpression()
         {
             ExprInfo dummy = new ExprInfo(this);
             Expect(31);
             Expression(dummy);
             Expect(37);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1405" endline="1418"><![CDATA[
 
         void ForInit()
         {
             if (isLocalVarDecl(true))
             {
                 LocalVariableDeclaration();
             }
             else if (StartOf(6))
             {
                 StatementExpression();
                 MoreStatementExpressions();
             }
             else SynErr(122);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1419" endline="1424"><![CDATA[
 
         void ForUpdate()
         {
             StatementExpression();
             MoreStatementExpressions();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1425" endline="1433"><![CDATA[
 
         void Catches()
         {
             CatchClause();
             while (la.kind == 69)
             {
                 CatchClause();
             }
             while (la.kind == 69)
             {
                 CatchClause();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1434" endline="1441"><![CDATA[
 
         void SwitchBlockStatementGroups()
         {
             while (la.kind == 70 || la.kind == 71)
             {
                 SwitchBlockStatementGroup();
             }
             while (la.kind == 70 || la.kind == 71)
             {
                 SwitchBlockStatementGroup();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1442" endline="1448"><![CDATA[
 
         void StatementExpression()
         {
             ExprInfo info = new ExprInfo(this);
             Expression(info);
             info.checkExprStat();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1449" endline="1466"><![CDATA[
 
         void BlockStatement()
         {
             if (isLocalVarDecl(false))
             {
                 LocalVariableDeclaration();
                 Expect(40);
             }
             else if (StartOf(2))
             {
                 ClassOrInterfaceDeclaration();
             }
             else if (StartOf(20))
             {
                 Statement();
             }
             else SynErr(123);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1467" endline="1476"><![CDATA[
 
         void LocalVariableDeclaration()
         {
             if (la.kind == 12)
             {
                 Get();
             }
             Type();
             VariableDeclarators();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1477" endline="1486"><![CDATA[
 
         void VariableDeclarators()
         {
             VariableDeclarator();
             while (la.kind == 25)
             {
                 Get();
                 VariableDeclarator();
             }
             while (la.kind == 25)
             {
                 Get();
                 VariableDeclarator();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1487" endline="1495"><![CDATA[
 
         void MoreStatementExpressions()
         {
             while (la.kind == 25)
             {
                 Get();
                 StatementExpression();
             }
             while (la.kind == 25)
             {
                 Get();
                 StatementExpression();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1496" endline="1504"><![CDATA[
 
         void CatchClause()
         {
             Expect(69);
             Expect(31);
             FormalParameter();
             Expect(37);
             Block();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1505" endline="1513"><![CDATA[
 
         void SwitchBlockStatementGroup()
         {
             SwitchLabel();
             while (StartOf(13))
             {
                 BlockStatement();
             }
             while (StartOf(13))
             {
                 BlockStatement();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1514" endline="1530"><![CDATA[
 
         void SwitchLabel()
         {
             if (la.kind == 70)
             {
                 ExprInfo dummy = new ExprInfo(this);
                 Get();
                 Expression(dummy);
                 Expect(24);
             }
             else if (la.kind == 71)
             {
                 Get();
                 Expect(24);
             }
             else SynErr(124);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1531" endline="1540"><![CDATA[
 
         void Expression1(ExprInfo info)
         {
             Expression2(info);
             if (la.kind == 72)
             {
                 info.setKind(ExprKind.CONDEXPR);
                 ConditionalExpr();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1541" endline="1608"><![CDATA[
 
         void AssignmentOperator()
         {
             switch (la.kind)
             {
                 case 52
                     {
                         Get();
                         break;
                     }
                 case 74
                     {
                         Get();
                         break;
                     }
                 case 75
                     {
                         Get();
                         break;
                     }
                 case 76
                     {
                         Get();
                         break;
                     }
                 case 77
                     {
                         Get();
                         break;
                     }
                 case 78
                     {
                         Get();
                         break;
                     }
                 case 79
                     {
                         Get();
                         break;
                     }
                 case 80
                     {
                         Get();
                         break;
                     }
                 case 81
                     {
                         Get();
                         break;
                     }
                 case 82
                     {
                         Get();
                         break;
                     }
                 case 83
                     {
                         Get();
                         break;
                     }
                 case 84
                     {
                         Get();
                         break;
                     }
                 default
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1609" endline="1617"><![CDATA[
 
         void Expression2(ExprInfo info)
         {
             Expression3(info);
             if (StartOf(21))
             {
                 Expression2Rest(info);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1618" endline="1626"><![CDATA[
 
         void ConditionalExpr()
         {
             ExprInfo dummy = new ExprInfo(this);
             Expect(72);
             Expression(dummy);
             Expect(24);
             Expression1(dummy);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1627" endline="1657"><![CDATA[
 
         void Expression3(ExprInfo info)
         {
             int pre = ExprKind.NONE;
             while (prefix.Get(la.kind) || isTypeCast())
             {
                 if (StartOf(22))
                 {
                     PrefixOp(info);
                     if (pre == ExprKind.NONE) pre = info.getKind();
                 }
                 else if (la.kind == 31)
                 {
                     Get();
                     Type();
                     Expect(37);
                     info.setKind(ExprKind.TYPECAST);
                 }
                 else SynErr(126);
             }
             while (prefix.Get(la.kind) || isTypeCast())
             {
                 if (StartOf(22))
                 {
                     PrefixOp(info);
                     if (pre == ExprKind.NONE) pre = info.getKind();
                 }
                 else if (la.kind == 31)
                 {
                     Get();
                     Type();
                     Expect(37);
                     info.setKind(ExprKind.TYPECAST);
                 }
                 else SynErr(126);
             }
             Primary(info);
             while (la.kind == 27 || la.kind == 30)
             {
                 Selector(info);
             }
             while (la.kind == 27 || la.kind == 30)
             {
                 Selector(info);
             }
             while (la.kind == 26 || la.kind == 28)
             {
                 PostfixOp(info);
             }
             while (la.kind == 26 || la.kind == 28)
             {
                 PostfixOp(info);
             }
             if (pre != ExprKind.NONE) info.setKind(pre);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1658" endline="1680"><![CDATA[
 
         void Expression2Rest(ExprInfo info)
         {
             ExprInfo dummy = new ExprInfo(this);
             if (StartOf(23))
             {
                 Infixop();
                 Expression3(dummy);
                 while (StartOf(23))
                 {
                     Infixop();
                     Expression3(dummy);
                 }
                 while (StartOf(23))
                 {
                     Infixop();
                     Expression3(dummy);
                 }
                 info.setKind(ExprKind.BINARY);
             }
             else if (la.kind == 73)
             {
                 Get();
                 Type();
                 info.setKind(ExprKind.TYPETEST);
             }
             else SynErr(127);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1681" endline="1783"><![CDATA[
 
         void Infixop()
         {
             switch (la.kind)
             {
                 case 85
                     {
                         Get();
                         break;
                     }
                 case 86
                     {
                         Get();
                         break;
                     }
                 case 87
                     {
                         Get();
                         break;
                     }
                 case 88
                     {
                         Get();
                         break;
                     }
                 case 89
                     {
                         Get();
                         break;
                     }
                 case 90
                     {
                         Get();
                         break;
                     }
                 case 91
                     {
                         Get();
                         break;
                     }
                 case 92
                     {
                         Get();
                         break;
                     }
                 case 93
                     {
                         Get();
                         break;
                     }
                 case 94
                     {
                         Get();
                         break;
                     }
                 case 95
                     {
                         Get();
                         break;
                     }
                 case 96
                     {
                         Get();
                         break;
                     }
                 case 97
                     {
                         Get();
                         break;
                     }
                 case 98
                     {
                         Get();
                         break;
                     }
                 case 34
                     {
                         Get();
                         break;
                     }
                 case 32
                     {
                         Get();
                         break;
                     }
                 case 42
                     {
                         Get();
                         break;
                     }
                 case 99
                     {
                         Get();
                         break;
                     }
                 case 100
                     {
                         Get();
                         break;
                     }
                 default
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1784" endline="1827"><![CDATA[
 
         void PrefixOp(ExprInfo info)
         {
             switch (la.kind)
             {
                 case 28
                     {
                         Get();
                         info.setKind(ExprKind.PREINC);
                         break;
                     }
                 case 26
                     {
                         Get();
                         info.setKind(ExprKind.PREDEC);
                         break;
                     }
                 case 33
                     {
                         Get();
                         info.setKind(ExprKind.NOT);
                         break;
                     }
                 case 38
                     {
                         Get();
                         info.setKind(ExprKind.COMPL);
                         break;
                     }
                 case 34
                     {
                         Get();
                         info.setKind(ExprKind.POS);
                         break;
                     }
                 case 32
                     {
                         Get();
                         info.setKind(ExprKind.NEG);
                         break;
                     }
                 default
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1828" endline="1913"><![CDATA[
 
         void Primary(ExprInfo info)
         {
             switch (la.kind)
             {
                 case 31
                     {
                         Get();
                         Expression(info);
                         Expect(37);
                         info.setKind(ExprKind.PARENS);
                         break;
                     }
                 case 21
                     {
                         Get();
                         info.setKind(ExprKind.IDENT);
                         ArgumentsOpt(info);
                         break;
                     }
                 case 20
                     {
                         Get();
                         SuperSuffix(info);
                         break;
                     }
                 case 2
                 case 3
                 case 4
                 case 5
                 case 11
                 case 17
                 case 22
                     {
                         Literal();
                         info.setKind(ExprKind.LITERAL);
                         break;
                     }
                 case 16
                     {
                         Get();
                         Creator(info);
                         break;
                     }
                 case 1
                     {
                         Get();
                         while (dotAndIdent())
                         {
                             Expect(27);
                             Expect(1);
                         }
                         while (dotAndIdent())
                         {
                             Expect(27);
                             Expect(1);
                         }
                         info.setKind(ExprKind.IDENT);
                         if (isIdentSuffix())
                         {
                             IdentifierSuffix(info);
                         }
                         break;
                     }
                 case 6
                 case 7
                 case 8
                 case 10
                 case 13
                 case 14
                 case 15
                 case 18
                     {
                         BasicType();
                         BracketsOpt();
                         Expect(27);
                         Expect(9);
                         info.setKind(ExprKind.SELECT);
                         break;
                     }
                 case 23
                     {
                         Get();
                         Expect(27);
                         Expect(9);
                         info.setKind(ExprKind.SELECT);
                         break;
                     }
                 default
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1914" endline="1945"><![CDATA[
 
         void Selector(ExprInfo info)
         {
             ExprInfo dummy = new ExprInfo(this);
             if (la.kind == 27)
             {
                 Get();
                 if (la.kind == 1)
                 {
                     Get();
                     ArgumentsOpt(info);
                 }
                 else if (la.kind == 20)
                 {
                     Get();
                     Arguments();
                 }
                 else if (la.kind == 16)
                 {
                     Get();
                     InnerCreator();
                 }
                 else SynErr(131);
             }
             else if (la.kind == 30)
             {
                 Get();
                 Expression(dummy);
                 Expect(36);
             }
             else SynErr(132);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1946" endline="1960"><![CDATA[
 
         void PostfixOp(ExprInfo info)
         {
             if (la.kind == 28)
             {
                 Get();
                 info.setKind(ExprKind.POSTINC);
             }
             else if (la.kind == 26)
             {
                 Get();
                 info.setKind(ExprKind.POSTDEC);
             }
             else SynErr(133);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1961" endline="1969"><![CDATA[
 
         void ArgumentsOpt(ExprInfo info)
         {
             if (la.kind == 31)
             {
                 info.setKind(ExprKind.APPLY);
                 Arguments();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1970" endline="1986"><![CDATA[
 
         void SuperSuffix(ExprInfo info)
         {
             if (la.kind == 31)
             {
                 Arguments();
                 info.setKind(ExprKind.APPLY);
             }
             else if (la.kind == 27)
             {
                 Get();
                 Expect(1);
                 info.setKind(ExprKind.IDENT);
                 ArgumentsOpt(info);
             }
             else SynErr(134);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="1987" endline="2029"><![CDATA[
 
         void Literal()
         {
             switch (la.kind)
             {
                 case 2
                     {
                         Get();
                         break;
                     }
                 case 3
                     {
                         Get();
                         break;
                     }
                 case 4
                     {
                         Get();
                         break;
                     }
                 case 5
                     {
                         Get();
                         break;
                     }
                 case 22
                     {
                         Get();
                         break;
                     }
                 case 11
                     {
                         Get();
                         break;
                     }
                 case 17
                     {
                         Get();
                         break;
                     }
                 default
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="2030" endline="2055"><![CDATA[
 
         void Creator(ExprInfo info)
         {
             if (StartOf(5))
             {
                 BasicType();
                 ArrayCreatorRest();
                 info.setKind(ExprKind.NEWARRAY);
             }
             else if (la.kind == 1)
             {
                 Qualident();
                 if (la.kind == 30)
                 {
                     ArrayCreatorRest();
                     info.setKind(ExprKind.NEWARRAY);
                 }
                 else if (la.kind == 31)
                 {
                     ClassCreatorRest();
                     info.setKind(ExprKind.NEWCLASS);
                 }
                 else SynErr(136);
             }
             else SynErr(137);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="2056" endline="2094"><![CDATA[
 
         void IdentifierSuffix(ExprInfo info)
         {
             if (la.kind == 30)
             {
                 Get();
                 Expect(36);
                 BracketsOpt();
                 Expect(27);
                 Expect(9);
                 info.setKind(ExprKind.SELECT);
             }
             else if (la.kind == 31)
             {
                 Arguments();
                 info.setKind(ExprKind.APPLY);
             }
             else if (la.kind == 27)
             {
                 Get();
                 if (la.kind == 9)
                 {
                     Get();
                 }
                 else if (la.kind == 21)
                 {
                     Get();
                 }
                 else if (la.kind == 20)
                 {
                     Get();
                     Expect(27);
                     Expect(1);
                     ArgumentsOpt(info);
                 }
                 else SynErr(138);
             }
             else SynErr(139);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="2095" endline="2110"><![CDATA[
 
         void Arguments()
         {
             ExprInfo dummy = new ExprInfo(this);
             Expect(31);
             if (StartOf(6))
             {
                 Expression(dummy);
                 while (la.kind == 25)
                 {
                     Get();
                     Expression(dummy);
                 }
                 while (la.kind == 25)
                 {
                     Get();
                     Expression(dummy);
                 }
             }
             Expect(37);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="2111" endline="2139"><![CDATA[
 
         void ArrayCreatorRest()
         {
             ExprInfo dummy = new ExprInfo(this);
             Expect(30);
             if (la.kind == 36)
             {
                 Get();
                 BracketsOpt();
                 ArrayInitializer();
             }
             else if (StartOf(6))
             {
                 Expression(dummy);
                 Expect(36);
                 while (nonEmptyBracket())
                 {
                     Expect(30);
                     Expression(dummy);
                     Expect(36);
                 }
                 while (nonEmptyBracket())
                 {
                     Expect(30);
                     Expression(dummy);
                     Expect(36);
                 }
                 while (emptyBracket())
                 {
                     Expect(30);
                     Expect(36);
                 }
                 while (emptyBracket())
                 {
                     Expect(30);
                     Expect(36);
                 }
             }
             else SynErr(140);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="2140" endline="2148"><![CDATA[
 
         void ClassCreatorRest()
         {
             Arguments();
             if (la.kind == 29)
             {
                 ClassBody();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="2149" endline="2154"><![CDATA[
 
         void InnerCreator()
         {
             Expect(1);
             ClassCreatorRest();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="2155" endline="2166"><![CDATA[
 
 
 
         public void Parse()
         {
             la = new Token();
             la.val = "";
             Get();
             CompilationUnit();
 
             Expect(0);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="209" endline="234"><![CDATA[
         static int maxTerminals = 160;  // set size
 
         static BitArray newSet(int[] values)
         {
             BitArray s = new BitArray(maxTerminals);
             for (int i = 0; i < values.Length; i++) s.Set(values[i], true);
             return s;
         }
 
         static BitArray or(BitArray s1, BitArray s2)
         {
             s1.Or(s2);
             return s1;
         }
 
         static int[] typeKWarr = {_byte, _short, _char, _int, _long, _float, _double, 
                           _bool};
         static int[] castFollowerArr = {_ident, _new, _super, _this, _void, _intLit,
                                 _floatLit, _charLit, _stringLit, _true, _false,
                                 _null, _lpar, _not, _tilde};
         static int[] prefixArr = { _inc, _dec, _not, _tilde, _plus, _minus };
 
         static BitArray
           typeKW = newSet(typeKWarr),
           castFollower = or(newSet(castFollowerArr), typeKW),
           prefix = newSet(prefixArr);
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="235" endline="2355"><![CDATA[
 
         /*---------------------------- auxiliary methods ----------------------------*/
 
         public void error(String s)
         {
             if (errDist >= minErrDist) errors.SemErr(la.line, la.col, s);
             errDist = 0;
         }
 
         // "(" BasicType {"[""]"} ")"
         bool isSimpleTypeCast()
         {
             // assert
             scanner.ResetPeek();
             Token pt1 = scanner.Peek();
 
             if (typeKW.Get(pt1.kind))
             {
                 Token pt = scanner.Peek();
                 pt = skipDims(pt);
                 if (pt != null)
                 {
                     return pt.kind == _rpar;
                 }
             }
             return false;
         }
 
         // "(" Qualident {"[" "]"} ")" castFollower
         bool guessTypeCast()
         {
             // assert
             scanner.ResetPeek();
             Token pt = scanner.Peek();
             pt = rdQualident(pt);
             if (pt != null)
             {
                 pt = skipDims(pt);
                 if (pt != null)
                 {
                     Token pt1 = scanner.Peek();
                     return pt.kind == _rpar && castFollower.Get(pt1.kind);
                 }
             }
             return false;
         }
 
         // "[" "]"
         Token skipDims(Token pt)
         {
             if (pt.kind != _lbrack) return pt;
             do
             {
                 pt = scanner.Peek();
                 if (pt.kind != _rbrack) return null;
                 pt = scanner.Peek();
             } while (pt.kind == _lbrack);
             return pt;
         }
 
         /* Checks whether the next sequence of tokens is a qualident *
          * and returns the qualident string                          *
          * !!! Proceeds from current peek position !!!               */
         Token rdQualident(Token pt)
         {
             String qualident = "";
 
             if (pt.kind == _ident)
             {
                 qualident = pt.val;
                 pt = scanner.Peek();
                 while (pt.kind == _dot)
                 {
                     pt = scanner.Peek();
                     if (pt.kind != _ident) return null;
                     qualident += "." + pt.val;
                     pt = scanner.Peek();
                 }
                 return pt;
             }
             else return null;
         }
 
         // Return the n-th token after the current lookahead token
         Token peek(int n)
         {
             scanner.ResetPeek();
             Token x = la;
             while (n > 0) { x = scanner.Peek(); n--; }
             return x;
         }
 
         /*-----------------------------------------------------------------*
          * Resolver routines to resolve LL(1) conflicts
          * These routines return a bool value that indicates            *
          * whether the alternative at hand shall be choosen or not.        *
          * They are used in IF ( ... ) expressions.                        *       
          *-----------------------------------------------------------------*/
 
         // ',' (no '}')
         bool commaAndNoRBrace()
         {
             return (la.kind == _comma && peek(1).kind != _rbrace);
         }
 
         // '.' ident
         bool dotAndIdent()
         {
             return la.kind == _dot && peek(1).kind == _ident;
         }
 
         // ident '('
         bool identAndLPar()
         {
             return la.kind == _ident && peek(1).kind == _lpar;
         }
 
         // ident '
         bool isLabel()
         {
             return la.kind == _ident && peek(1).kind == _colon;
         }
 
         // '[' (no ']')
         bool nonEmptyBracket()
         {
             return (la.kind == _lbrack && peek(1).kind != _rbrack);
         }
 
         // '['']'
         bool emptyBracket()
         {
             return (la.kind == _lbrack && peek(1).kind == _rbrack);
         }
 
         // final or Type ident
         bool isLocalVarDecl(bool finalIsSuccess)
         {
             Token pt = la;
             scanner.ResetPeek();
 
             if (la.kind == _final)
                 if (finalIsSuccess) return true;
                 else pt = scanner.Peek();
 
             // basicType | ident
             if (typeKW.Get(pt.kind))
                 pt = scanner.Peek();
             else
                 pt = rdQualident(pt);
 
             if (pt != null)
             {
                 pt = skipDims(pt);
                 if (pt != null)
                 {
                     return pt.kind == _ident;
                 }
             }
             return false;
         }
 
         bool isTypeCast()
         {
             if (la.kind != _lpar) return false;
             if (isSimpleTypeCast()) return true;
             return guessTypeCast();
         }
 
         // '.' ("super" '.' | "class" | "this") | '(' | '['']'
         bool isIdentSuffix()
         {
             if (la.kind == _dot)
             {
                 scanner.ResetPeek();
                 Token pt = scanner.Peek();
                 if (pt.kind == _super) return scanner.Peek().kind == _dot;
                 return (pt.kind == _class || pt.kind == _this);
             }
             return (la.kind == _lpar || emptyBracket());
         }
 
         /*-------------------------------------------------------------------------*/
 
 
 
         public Parser(Scanner scanner)
         {
             this.scanner = scanner;
             errors = new Errors();
         }
 
         void SynErr(int n)
         {
             if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n);
             errDist = 0;
         }
 
         public void SemErr(string msg)
         {
             if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg);
             errDist = 0;
         }
 
         void Get()
         {
             for (; ; )
             {
                 t = la;
                 la = scanner.Scan();
                 if (la.kind <= maxT) { ++errDist; break; }
 
                 la = t;
             }
         }
 
         void Expect(int n)
         {
             if (la.kind == n) Get(); else { SynErr(n); }
         }
 
         bool StartOf(int s)
         {
             return set[s, la.kind];
         }
 
         void ExpectWeak(int n, int follow)
         {
             if (la.kind == n) Get();
             else
             {
                 SynErr(n);
                 while (!StartOf(follow)) Get();
             }
         }
 
 
         bool WeakSeparator(int n, int syFol, int repFol)
         {
             int kind = la.kind;
             if (kind == n) { Get(); return true; }
             else if (StartOf(repFol)) { return false; }
             else
             {
                 SynErr(n);
                 while (!(set[syFol, kind] || set[repFol, kind] || set[0, kind]))
                 {
                     Get();
                     kind = la.kind;
                 }
                 return StartOf(syFol);
             }
         }
 
 
         void CompilationUnit()
         {
             if (la.kind == 39)
             {
                 Get();
                 Qualident();
                 Expect(40);
             }
             while (la.kind == 41)
             {
                 ImportDeclaration();
             }
             while (StartOf(1))
             {
                 TypeDeclaration();
             }
             if (la.kind != _EOF) error("'class' or 'interface' expected");
         }
 
         void Qualident()
         {
             Expect(1);
             while (la.kind == 27)
             {
                 Get();
                 Expect(1);
             }
         }
 
         void ImportDeclaration()
         {
             Expect(41);
             TokenMatch tm = new TokenMatch(la.val, la.pos);
             this.m_Current = la.val;
             Expect(1);
             QualifiedImport();
             Expect(40);
             tm.Value = this.m_Current;
             this.m_CodeInfo.Imports.Add(tm);
         }
 
         void TypeDeclaration()
         {
             if (StartOf(2))
             {
                 ClassOrInterfaceDeclaration();
             }
             else if (la.kind == 40)
             {
                 Get();
             }
             else SynErr(102);
         }
 
         void QualifiedImport()
         {
             Expect(27);
             this.m_Current += "." + la.val;
             if (la.kind == 1)
             {
                 Get();
                 if (la.kind == 27)
                 {
                     QualifiedImport();
                 }
             }
             else if (la.kind == 42)
             {
                 Get();
             }
             else SynErr(103);
         }
 
         void ClassOrInterfaceDeclaration()
         {
             Modifiers m = new Modifiers(this);
             while (StartOf(3))
             {
                 ClassModifier(m);
             }
             if (la.kind == 9)
             {
                 ClassDeclaration(m);
             }
             else if (la.kind == 56)
             {
                 InterfaceDeclaration(m);
             }
             else SynErr(104);
         }
 
         void ClassModifier(Modifiers m)
         {
             switch (la.kind)
             {
                 case 43
                     {
                         Get();
                         m.add(Modifier._public);
                         break;
                     }
                 case 44
                     {
                         Get();
                         m.add(Modifier._protected);
                         break;
                     }
                 case 45
                     {
                         Get();
                         m.add(Modifier._private);
                         break;
                     }
                 case 46
                     {
                         Get();
                         m.add(Modifier._abstract);
                         break;
                     }
                 case 19
                     {
                         Get();
                         m.add(Modifier._static);
                         break;
                     }
                 case 12
                     {
                         Get();
                         m.add(Modifier._final);
                         break;
                     }
                 case 47
                     {
                         Get();
                         m.add(Modifier._strictfp);
                         break;
                     }
                 default
             }
         }
 
         void ClassDeclaration(Modifiers m)
         {
             m.check(Modifier.classes);
             Expect(9);
             Expect(1);
             if (la.kind == 53)
             {
                 Get();
                 Type();
             }
             if (la.kind == 54)
             {
                 Get();
                 TypeList();
             }
             ClassBody();
         }
 
         void InterfaceDeclaration(Modifiers m)
         {
             m.check(Modifier.interfaces);
             Expect(56);
             Expect(1);
             if (la.kind == 53)
             {
                 Get();
                 TypeList();
             }
             InterfaceBody();
         }
 
         void Modifier2(Modifiers m)
         {
             if (la.kind == 19)
             {
                 Get();
                 m.add(Modifier._static);
             }
             else if (StartOf(4))
             {
                 Modifier1(m);
             }
             else SynErr(106);
         }
 
         void Modifier1(Modifiers m)
         {
             switch (la.kind)
             {
                 case 43
                     {
                         Get();
                         m.add(Modifier._public);
                         break;
                     }
                 case 44
                     {
                         Get();
                         m.add(Modifier._protected);
                         break;
                     }
                 case 45
                     {
                         Get();
                         m.add(Modifier._private);
                         break;
                     }
                 case 46
                     {
                         Get();
                         m.add(Modifier._abstract);
                         break;
                     }
                 case 12
                     {
                         Get();
                         m.add(Modifier._final);
                         break;
                     }
                 case 48
                     {
                         Get();
                         m.add(Modifier._native);
                         break;
                     }
                 case 49
                     {
                         Get();
                         m.add(Modifier._synchronized);
                         break;
                     }
                 case 50
                     {
                         Get();
                         m.add(Modifier._transient);
                         break;
                     }
                 case 51
                     {
                         Get();
                         m.add(Modifier._volatile);
                         break;
                     }
                 case 47
                     {
                         Get();
                         m.add(Modifier._strictfp);
                         break;
                     }
                 default
             }
         }
 
         void Type()
         {
             if (la.kind == 1)
             {
                 Qualident();
             }
             else if (StartOf(5))
             {
                 BasicType();
             }
             else SynErr(108);
             BracketsOpt();
         }
 
         void BasicType()
         {
             switch (la.kind)
             {
                 case 7
                     {
                         Get();
                         break;
                     }
                 case 18
                     {
                         Get();
                         break;
                     }
                 case 8
                     {
                         Get();
                         break;
                     }
                 case 14
                     {
                         Get();
                         break;
                     }
                 case 15
                     {
                         Get();
                         break;
                     }
                 case 13
                     {
                         Get();
                         break;
                     }
                 case 10
                     {
                         Get();
                         break;
                     }
                 case 6
                     {
                         Get();
                         break;
                     }
                 default
             }
         }
 
         void BracketsOpt()
         {
             while (la.kind == 30)
             {
                 Get();
                 Expect(36);
             }
         }
 
         void TypeList()
         {
             Type();
             while (la.kind == 25)
             {
                 Get();
                 Type();
             }
         }
 
         void FormalParameter()
         {
             if (la.kind == 12)
             {
                 Get();
             }
             if (!this.m_Current.Equals("("))
             {
                 this.m_Current += ", ";
             }
             this.m_Current += la.val;
             Type();
             VariableDeclaratorId();
         }
 
         void VariableDeclaratorId()
         {
             Expect(1);
             BracketsOpt();
         }
 
         void QualidentList()
         {
             Qualident();
             while (la.kind == 25)
             {
                 Get();
                 Qualident();
             }
         }
 
         void VariableDeclarator()
         {
             Expect(1);
             VariableDeclaratorRest();
         }
 
         void VariableDeclaratorRest()
         {
             BracketsOpt();
             if (la.kind == 52)
             {
                 Get();
                 VariableInitializer();
             }
         }
 
         void VariableInitializer()
         {
             ExprInfo dummy = new ExprInfo(this);
             if (la.kind == 29)
             {
                 ArrayInitializer();
             }
             else if (StartOf(6))
             {
                 Expression(dummy);
             }
             else SynErr(110);
         }
 
         void ArrayInitializer()
         {
             Expect(29);
             if (StartOf(7))
             {
                 VariableInitializer();
                 while (commaAndNoRBrace())
                 {
                     Expect(25);
                     VariableInitializer();
                 }
             }
             if (la.kind == 25)
             {
                 Get();
             }
             Expect(35);
         }
 
         void Expression(ExprInfo info)
         {
             Expression1(info);
             while (StartOf(8))
             {
                 ExprInfo dummy = new ExprInfo(this);
                 info.setKind(ExprKind.ASSIGN);
                 AssignmentOperator();
                 Expression1(dummy);
             }
         }
 
         void ClassBody()
         {
             Expect(29);
             while (StartOf(9))
             {
                 ClassBodyDeclaration();
             }
             Expect(35);
         }
 
         void ClassBodyDeclaration()
         {
             if (la.kind == 40)
             {
                 Get();
             }
             else if (StartOf(10))
             {
                 Modifiers m = new Modifiers(this);
                 if (la.kind == 19)
                 {
                     Get();
                     m.add(Modifier._static);
                 }
                 if (la.kind == 29)
                 {
                     Block();
                 }
                 else if (StartOf(11))
                 {
                     if (StartOf(4))
                     {
                         Modifier1(m);
                         while (StartOf(12))
                         {
                             Modifier2(m);
                         }
                     }
                     MemberDecl(m);
                 }
                 else SynErr(111);
             }
             else SynErr(112);
         }
 
         void Block()
         {
             Expect(29);
             while (StartOf(13))
             {
                 BlockStatement();
             }
             Expect(35);
         }
 
         void MemberDecl(Modifiers m)
         {
             string dataType = la.val;
             TokenMatch tm = new TokenMatch();
             if (identAndLPar())
             {
                 tm.Position = la.pos;
                 tm.Value = la.val;
                 this.m_Current = "(";
                 Expect(1);
                 ConstructorDeclaratorRest(m);
                 if (!this.m_Current.Equals("()"))
                 {
                     this.m_Current += ")";
                 }
                 tm.Value += this.m_Current;
                 this.m_CodeInfo.Constructors.Add(tm);
             }
             else if (StartOf(14))
             {
                 this.m_Current = "";
                 tm.Position = la.pos;
                 MethodOrFieldDecl(m);
                 tm.Value = this.m_Current + "
                 this.m_CodeInfo.Fields.Add(tm);
             }
             else if (la.kind == 23)
             {
                 m.check(Modifier.methods);
                 Get();
                 tm.Position = la.pos;
                 tm.Value = la.val;
                 this.m_Current = "(";
                 Expect(1);
                 VoidMethodDeclaratorRest();
                 if (this.m_Current.Equals("()"))
                 {
                     this.m_Current += "
                 }
                 else
                 {
                     this.m_Current += ")" + "
                 }
                 tm.Value += this.m_Current;
                 this.m_CodeInfo.Methods.Add(tm);
             }
             else if (la.kind == 9)
             {
                 ClassDeclaration(m);
             }
             else if (la.kind == 56)
             {
                 InterfaceDeclaration(m);
             }
             else SynErr(113);
         }
 
         void ConstructorDeclaratorRest(Modifiers m)
         {
             m.check(Modifier.constructors);
             FormalParameters();
             if (la.kind == 55)
             {
                 Get();
                 QualidentList();
             }
             Block();
         }
 
         void MethodOrFieldDecl(Modifiers m)
         {
             Type();
             string gen = "";
             if (la.kind == 92)
             {
                 gen = la.val;
                 Get();
                 gen += la.val;
                 Get();
                 gen += la.val;
                 Get();
             }
             this.m_Current += la.val + gen;
             Expect(1);
             MethodOrFieldRest(m);
         }
 
         void VoidMethodDeclaratorRest()
         {
             FormalParameters();
             if (la.kind == 55)
             {
                 Get();
                 QualidentList();
             }
             if (la.kind == 29)
             {
                 Block();
             }
             else if (la.kind == 40)
             {
                 Get();
             }
             else SynErr(114);
         }
 
         void MethodOrFieldRest(Modifiers m)
         {
             if (StartOf(15))
             {
                 m.check(Modifier.fields);
                 VariableDeclaratorsRest();
                 Expect(40);
             }
             else if (la.kind == 31)
             {
                 m.check(Modifier.methods);
                 MethodDeclaratorRest();
             }
             else SynErr(115);
         }
 
         void VariableDeclaratorsRest()
         {
             VariableDeclaratorRest();
             while (la.kind == 25)
             {
                 Get();
                 VariableDeclarator();
             }
         }
 
         void MethodDeclaratorRest()
         {
             FormalParameters();
             BracketsOpt();
             if (la.kind == 55)
             {
                 Get();
                 QualidentList();
             }
             if (la.kind == 29)
             {
                 Block();
             }
             else if (la.kind == 40)
             {
                 Get();
             }
             else SynErr(116);
         }
 
         void FormalParameters()
         {
             Expect(31);
             if (StartOf(16))
             {
                 FormalParameter();
                 while (la.kind == 25)
                 {
                     Get();
                     FormalParameter();
                 }
             }
             Expect(37);
         }
 
         void InterfaceBody()
         {
             Expect(29);
             while (StartOf(17))
             {
                 InterfaceBodyDeclaration();
             }
             Expect(35);
         }
 
         void InterfaceBodyDeclaration()
         {
             Modifiers m = new Modifiers(this);
             if (la.kind == 40)
             {
                 Get();
             }
             else if (StartOf(18))
             {
                 while (StartOf(12))
                 {
                     Modifier2(m);
                 }
                 InterfaceMemberDecl(m);
             }
             else SynErr(117);
         }
 
         void InterfaceMemberDecl(Modifiers m)
         {
             if (StartOf(14))
             {
                 InterfaceMethodOrFieldDecl(m);
             }
             else if (la.kind == 23)
             {
                 m.check(Modifier.interfaces);
                 Get();
                 Expect(1);
                 VoidInterfaceMethodDeclaratorRest();
             }
             else if (la.kind == 9)
             {
                 ClassDeclaration(m);
             }
             else if (la.kind == 56)
             {
                 InterfaceDeclaration(m);
             }
             else SynErr(118);
         }
 
         void InterfaceMethodOrFieldDecl(Modifiers m)
         {
             Type();
             Expect(1);
             InterfaceMethodOrFieldRest(m);
         }
 
         void VoidInterfaceMethodDeclaratorRest()
         {
             FormalParameters();
             if (la.kind == 55)
             {
                 Get();
                 QualidentList();
             }
             Expect(40);
         }
 
         void InterfaceMethodOrFieldRest(Modifiers m)
         {
             if (la.kind == 30 || la.kind == 52)
             {
                 m.check(Modifier.constants);
                 ConstantDeclaratorsRest();
                 Expect(40);
             }
             else if (la.kind == 31)
             {
                 m.check(Modifier.interfaces);
                 InterfaceMethodDeclaratorRest();
             }
             else SynErr(119);
         }
 
         void ConstantDeclaratorsRest()
         {
             ConstantDeclaratorRest();
             while (la.kind == 25)
             {
                 Get();
                 ConstantDeclarator();
             }
         }
 
         void InterfaceMethodDeclaratorRest()
         {
             FormalParameters();
             BracketsOpt();
             if (la.kind == 55)
             {
                 Get();
                 QualidentList();
             }
             Expect(40);
         }
 
         void ConstantDeclaratorRest()
         {
             BracketsOpt();
             Expect(52);
             VariableInitializer();
         }
 
         void ConstantDeclarator()
         {
             Expect(1);
             ConstantDeclaratorRest();
         }
 
         void Statement()
         {
             ExprInfo dummy = new ExprInfo(this);
             if (la.kind == 29)
             {
                 Block();
             }
             else if (la.kind == 57)
             {
                 Get();
                 ParExpression();
                 Statement();
                 if (la.kind == 58)
                 {
                     Get();
                     Statement();
                 }
             }
             else if (la.kind == 59)
             {
                 Get();
                 Expect(31);
                 if (StartOf(19))
                 {
                     ForInit();
                 }
                 Expect(40);
                 if (StartOf(6))
                 {
                     Expression(dummy);
                 }
                 Expect(40);
                 if (StartOf(6))
                 {
                     ForUpdate();
                 }
                 Expect(37);
                 Statement();
             }
             else if (la.kind == 60)
             {
                 Get();
                 ParExpression();
                 Statement();
             }
             else if (la.kind == 61)
             {
                 Get();
                 Statement();
                 Expect(60);
                 ParExpression();
                 Expect(40);
             }
             else if (la.kind == 62)
             {
                 Get();
                 Block();
                 if (la.kind == 69)
                 {
                     Catches();
                     if (la.kind == 63)
                     {
                         Get();
                         Block();
                     }
                 }
                 else if (la.kind == 63)
                 {
                     Get();
                     Block();
                 }
                 else SynErr(120);
             }
             else if (la.kind == 64)
             {
                 Get();
                 ParExpression();
                 Expect(29);
                 SwitchBlockStatementGroups();
                 Expect(35);
             }
             else if (la.kind == 49)
             {
                 Get();
                 ParExpression();
                 Block();
             }
             else if (la.kind == 65)
             {
                 Get();
                 if (StartOf(6))
                 {
                     Expression(dummy);
                 }
                 Expect(40);
             }
             else if (la.kind == 66)
             {
                 Get();
                 Expression(dummy);
                 Expect(40);
             }
             else if (la.kind == 67)
             {
                 Get();
                 if (la.kind == 1)
                 {
                     Get();
                 }
                 Expect(40);
             }
             else if (la.kind == 68)
             {
                 Get();
                 if (la.kind == 1)
                 {
                     Get();
                 }
                 Expect(40);
             }
             else if (la.kind == 40)
             {
                 Get();
             }
             else if (isLabel())
             {
                 Expect(1);
                 Expect(24);
                 Statement();
             }
             else if (StartOf(6))
             {
                 StatementExpression();
                 Expect(40);
             }
             else SynErr(121);
         }
 
         void ParExpression()
         {
             ExprInfo dummy = new ExprInfo(this);
             Expect(31);
             Expression(dummy);
             Expect(37);
         }
 
         void ForInit()
         {
             if (isLocalVarDecl(true))
             {
                 LocalVariableDeclaration();
             }
             else if (StartOf(6))
             {
                 StatementExpression();
                 MoreStatementExpressions();
             }
             else SynErr(122);
         }
 
         void ForUpdate()
         {
             StatementExpression();
             MoreStatementExpressions();
         }
 
         void Catches()
         {
             CatchClause();
             while (la.kind == 69)
             {
                 CatchClause();
             }
         }
 
         void SwitchBlockStatementGroups()
         {
             while (la.kind == 70 || la.kind == 71)
             {
                 SwitchBlockStatementGroup();
             }
         }
 
         void StatementExpression()
         {
             ExprInfo info = new ExprInfo(this);
             Expression(info);
             info.checkExprStat();
         }
 
         void BlockStatement()
         {
             if (isLocalVarDecl(false))
             {
                 LocalVariableDeclaration();
                 Expect(40);
             }
             else if (StartOf(2))
             {
                 ClassOrInterfaceDeclaration();
             }
             else if (StartOf(20))
             {
                 Statement();
             }
             else SynErr(123);
         }
 
         void LocalVariableDeclaration()
         {
             if (la.kind == 12)
             {
                 Get();
             }
             Type();
             VariableDeclarators();
         }
 
         void VariableDeclarators()
         {
             VariableDeclarator();
             while (la.kind == 25)
             {
                 Get();
                 VariableDeclarator();
             }
         }
 
         void MoreStatementExpressions()
         {
             while (la.kind == 25)
             {
                 Get();
                 StatementExpression();
             }
         }
 
         void CatchClause()
         {
             Expect(69);
             Expect(31);
             FormalParameter();
             Expect(37);
             Block();
         }
 
         void SwitchBlockStatementGroup()
         {
             SwitchLabel();
             while (StartOf(13))
             {
                 BlockStatement();
             }
         }
 
         void SwitchLabel()
         {
             if (la.kind == 70)
             {
                 ExprInfo dummy = new ExprInfo(this);
                 Get();
                 Expression(dummy);
                 Expect(24);
             }
             else if (la.kind == 71)
             {
                 Get();
                 Expect(24);
             }
             else SynErr(124);
         }
 
         void Expression1(ExprInfo info)
         {
             Expression2(info);
             if (la.kind == 72)
             {
                 info.setKind(ExprKind.CONDEXPR);
                 ConditionalExpr();
             }
         }
 
         void AssignmentOperator()
         {
             switch (la.kind)
             {
                 case 52
                     {
                         Get();
                         break;
                     }
                 case 74
                     {
                         Get();
                         break;
                     }
                 case 75
                     {
                         Get();
                         break;
                     }
                 case 76
                     {
                         Get();
                         break;
                     }
                 case 77
                     {
                         Get();
                         break;
                     }
                 case 78
                     {
                         Get();
                         break;
                     }
                 case 79
                     {
                         Get();
                         break;
                     }
                 case 80
                     {
                         Get();
                         break;
                     }
                 case 81
                     {
                         Get();
                         break;
                     }
                 case 82
                     {
                         Get();
                         break;
                     }
                 case 83
                     {
                         Get();
                         break;
                     }
                 case 84
                     {
                         Get();
                         break;
                     }
                 default
             }
         }
 
         void Expression2(ExprInfo info)
         {
             Expression3(info);
             if (StartOf(21))
             {
                 Expression2Rest(info);
             }
         }
 
         void ConditionalExpr()
         {
             ExprInfo dummy = new ExprInfo(this);
             Expect(72);
             Expression(dummy);
             Expect(24);
             Expression1(dummy);
         }
 
         void Expression3(ExprInfo info)
         {
             int pre = ExprKind.NONE;
             while (prefix.Get(la.kind) || isTypeCast())
             {
                 if (StartOf(22))
                 {
                     PrefixOp(info);
                     if (pre == ExprKind.NONE) pre = info.getKind();
                 }
                 else if (la.kind == 31)
                 {
                     Get();
                     Type();
                     Expect(37);
                     info.setKind(ExprKind.TYPECAST);
                 }
                 else SynErr(126);
             }
             Primary(info);
             while (la.kind == 27 || la.kind == 30)
             {
                 Selector(info);
             }
             while (la.kind == 26 || la.kind == 28)
             {
                 PostfixOp(info);
             }
             if (pre != ExprKind.NONE) info.setKind(pre);
         }
 
         void Expression2Rest(ExprInfo info)
         {
             ExprInfo dummy = new ExprInfo(this);
             if (StartOf(23))
             {
                 Infixop();
                 Expression3(dummy);
                 while (StartOf(23))
                 {
                     Infixop();
                     Expression3(dummy);
                 }
                 info.setKind(ExprKind.BINARY);
             }
             else if (la.kind == 73)
             {
                 Get();
                 Type();
                 info.setKind(ExprKind.TYPETEST);
             }
             else SynErr(127);
         }
 
         void Infixop()
         {
             switch (la.kind)
             {
                 case 85
                     {
                         Get();
                         break;
                     }
                 case 86
                     {
                         Get();
                         break;
                     }
                 case 87
                     {
                         Get();
                         break;
                     }
                 case 88
                     {
                         Get();
                         break;
                     }
                 case 89
                     {
                         Get();
                         break;
                     }
                 case 90
                     {
                         Get();
                         break;
                     }
                 case 91
                     {
                         Get();
                         break;
                     }
                 case 92
                     {
                         Get();
                         break;
                     }
                 case 93
                     {
                         Get();
                         break;
                     }
                 case 94
                     {
                         Get();
                         break;
                     }
                 case 95
                     {
                         Get();
                         break;
                     }
                 case 96
                     {
                         Get();
                         break;
                     }
                 case 97
                     {
                         Get();
                         break;
                     }
                 case 98
                     {
                         Get();
                         break;
                     }
                 case 34
                     {
                         Get();
                         break;
                     }
                 case 32
                     {
                         Get();
                         break;
                     }
                 case 42
                     {
                         Get();
                         break;
                     }
                 case 99
                     {
                         Get();
                         break;
                     }
                 case 100
                     {
                         Get();
                         break;
                     }
                 default
             }
         }
 
         void PrefixOp(ExprInfo info)
         {
             switch (la.kind)
             {
                 case 28
                     {
                         Get();
                         info.setKind(ExprKind.PREINC);
                         break;
                     }
                 case 26
                     {
                         Get();
                         info.setKind(ExprKind.PREDEC);
                         break;
                     }
                 case 33
                     {
                         Get();
                         info.setKind(ExprKind.NOT);
                         break;
                     }
                 case 38
                     {
                         Get();
                         info.setKind(ExprKind.COMPL);
                         break;
                     }
                 case 34
                     {
                         Get();
                         info.setKind(ExprKind.POS);
                         break;
                     }
                 case 32
                     {
                         Get();
                         info.setKind(ExprKind.NEG);
                         break;
                     }
                 default
             }
         }
 
         void Primary(ExprInfo info)
         {
             switch (la.kind)
             {
                 case 31
                     {
                         Get();
                         Expression(info);
                         Expect(37);
                         info.setKind(ExprKind.PARENS);
                         break;
                     }
                 case 21
                     {
                         Get();
                         info.setKind(ExprKind.IDENT);
                         ArgumentsOpt(info);
                         break;
                     }
                 case 20
                     {
                         Get();
                         SuperSuffix(info);
                         break;
                     }
                 case 2
                 case 3
                 case 4
                 case 5
                 case 11
                 case 17
                 case 22
                     {
                         Literal();
                         info.setKind(ExprKind.LITERAL);
                         break;
                     }
                 case 16
                     {
                         Get();
                         Creator(info);
                         break;
                     }
                 case 1
                     {
                         Get();
                         while (dotAndIdent())
                         {
                             Expect(27);
                             Expect(1);
                         }
                         info.setKind(ExprKind.IDENT);
                         if (isIdentSuffix())
                         {
                             IdentifierSuffix(info);
                         }
                         break;
                     }
                 case 6
                 case 7
                 case 8
                 case 10
                 case 13
                 case 14
                 case 15
                 case 18
                     {
                         BasicType();
                         BracketsOpt();
                         Expect(27);
                         Expect(9);
                         info.setKind(ExprKind.SELECT);
                         break;
                     }
                 case 23
                     {
                         Get();
                         Expect(27);
                         Expect(9);
                         info.setKind(ExprKind.SELECT);
                         break;
                     }
                 default
             }
         }
 
         void Selector(ExprInfo info)
         {
             ExprInfo dummy = new ExprInfo(this);
             if (la.kind == 27)
             {
                 Get();
                 if (la.kind == 1)
                 {
                     Get();
                     ArgumentsOpt(info);
                 }
                 else if (la.kind == 20)
                 {
                     Get();
                     Arguments();
                 }
                 else if (la.kind == 16)
                 {
                     Get();
                     InnerCreator();
                 }
                 else SynErr(131);
             }
             else if (la.kind == 30)
             {
                 Get();
                 Expression(dummy);
                 Expect(36);
             }
             else SynErr(132);
         }
 
         void PostfixOp(ExprInfo info)
         {
             if (la.kind == 28)
             {
                 Get();
                 info.setKind(ExprKind.POSTINC);
             }
             else if (la.kind == 26)
             {
                 Get();
                 info.setKind(ExprKind.POSTDEC);
             }
             else SynErr(133);
         }
 
         void ArgumentsOpt(ExprInfo info)
         {
             if (la.kind == 31)
             {
                 info.setKind(ExprKind.APPLY);
                 Arguments();
             }
         }
 
         void SuperSuffix(ExprInfo info)
         {
             if (la.kind == 31)
             {
                 Arguments();
                 info.setKind(ExprKind.APPLY);
             }
             else if (la.kind == 27)
             {
                 Get();
                 Expect(1);
                 info.setKind(ExprKind.IDENT);
                 ArgumentsOpt(info);
             }
             else SynErr(134);
         }
 
         void Literal()
         {
             switch (la.kind)
             {
                 case 2
                     {
                         Get();
                         break;
                     }
                 case 3
                     {
                         Get();
                         break;
                     }
                 case 4
                     {
                         Get();
                         break;
                     }
                 case 5
                     {
                         Get();
                         break;
                     }
                 case 22
                     {
                         Get();
                         break;
                     }
                 case 11
                     {
                         Get();
                         break;
                     }
                 case 17
                     {
                         Get();
                         break;
                     }
                 default
             }
         }
 
         void Creator(ExprInfo info)
         {
             if (StartOf(5))
             {
                 BasicType();
                 ArrayCreatorRest();
                 info.setKind(ExprKind.NEWARRAY);
             }
             else if (la.kind == 1)
             {
                 Qualident();
                 if (la.kind == 30)
                 {
                     ArrayCreatorRest();
                     info.setKind(ExprKind.NEWARRAY);
                 }
                 else if (la.kind == 31)
                 {
                     ClassCreatorRest();
                     info.setKind(ExprKind.NEWCLASS);
                 }
                 else SynErr(136);
             }
             else SynErr(137);
         }
 
         void IdentifierSuffix(ExprInfo info)
         {
             if (la.kind == 30)
             {
                 Get();
                 Expect(36);
                 BracketsOpt();
                 Expect(27);
                 Expect(9);
                 info.setKind(ExprKind.SELECT);
             }
             else if (la.kind == 31)
             {
                 Arguments();
                 info.setKind(ExprKind.APPLY);
             }
             else if (la.kind == 27)
             {
                 Get();
                 if (la.kind == 9)
                 {
                     Get();
                 }
                 else if (la.kind == 21)
                 {
                     Get();
                 }
                 else if (la.kind == 20)
                 {
                     Get();
                     Expect(27);
                     Expect(1);
                     ArgumentsOpt(info);
                 }
                 else SynErr(138);
             }
             else SynErr(139);
         }
 
         void Arguments()
         {
             ExprInfo dummy = new ExprInfo(this);
             Expect(31);
             if (StartOf(6))
             {
                 Expression(dummy);
                 while (la.kind == 25)
                 {
                     Get();
                     Expression(dummy);
                 }
             }
             Expect(37);
         }
 
         void ArrayCreatorRest()
         {
             ExprInfo dummy = new ExprInfo(this);
             Expect(30);
             if (la.kind == 36)
             {
                 Get();
                 BracketsOpt();
                 ArrayInitializer();
             }
             else if (StartOf(6))
             {
                 Expression(dummy);
                 Expect(36);
                 while (nonEmptyBracket())
                 {
                     Expect(30);
                     Expression(dummy);
                     Expect(36);
                 }
                 while (emptyBracket())
                 {
                     Expect(30);
                     Expect(36);
                 }
             }
             else SynErr(140);
         }
 
         void ClassCreatorRest()
         {
             Arguments();
             if (la.kind == 29)
             {
                 ClassBody();
             }
         }
 
         void InnerCreator()
         {
             Expect(1);
             ClassCreatorRest();
         }
 
 
 
         public void Parse()
         {
             la = new Token();
             la.val = "";
             Get();
             CompilationUnit();
 
             Expect(0);
         }
 
         bool[,] set = {
 		{T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,x,x,x, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,T, T,T,T,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,x,x,x, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,T,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,T,T, T,T,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,x,x,x, x,x,T,T, T,x,T,x, x,T,T,T, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,T,T,T, T,T,T,T, T,x,T,T, x,T,T,T, T,T,T,x, T,T,T,T, x,x,T,x, T,x,x,T, T,T,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,T,T,T, T,T,T,T, T,x,T,T, x,T,T,T, T,T,T,x, T,T,T,T, x,x,T,x, T,T,x,T, T,T,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,T,T,T, T,T,T,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,T,x,x, x,x,T,T, T,T,T,x, T,T,T,T, x,x,T,T, x,x,x,T, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, T,x,x,T, T,T,T,T, T,T,T,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,T,x,x, x,x,T,T, T,T,T,x, T,T,T,T, x,x,T,T, x,x,x,T, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,T,T, T,T,T,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,T,x,x, x,x,T,T, T,T,T,x, T,T,T,T, x,x,T,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,T,T, T,T,T,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,T,T, T,T,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, x,x,T,x, T,T,x,T, T,T,T,x, x,x,T,x, T,x,x,T, T,T,T,T, x,T,x,x, x,x,x,x, T,T,x,T, T,T,T,x, T,T,T,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,T,x,x, x,x,T,T, T,x,T,x, x,T,T,T, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,T,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,T,x,x, x,x,T,T, T,x,T,x, T,T,T,T, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,T,x,x, x,x,T,T, T,T,T,x, T,T,T,T, x,x,T,T, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,T, T,T,T,T, T,T,T,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,T,x,x, x,x,T,T, T,T,T,x, T,T,T,T, x,x,T,T, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,T,T,T, T,T,T,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,T,T,T, T,T,T,T, T,x,T,T, T,T,T,T, T,T,T,x, T,T,T,T, x,x,T,x, T,x,x,T, T,T,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,T,T,T, T,T,T,T, T,x,T,T, x,T,T,T, T,T,T,x, T,T,T,T, x,x,T,x, T,T,x,T, T,T,T,x, x,x,T,x, T,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,T,x,T, T,T,T,x, T,T,T,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,x,x},
 		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, T,x,x,x, T,T,T,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,x,x}
 
 	};
     } // end Parser
 
 
     public class Errors
     {
         public int count = 0;                                    // number of errors detected
         public System.IO.TextWriter errorStream = Console.Out;   // error messages go to this stream
         public string errMsgFormat = "-- line {0} col {1}
 
         public void SynErr(int line, int col, int n)
         {
             string s;
             switch (n)
             {
                 case 0
                 case 1
                 case 2
                 case 3
                 case 4
                 case 5
                 case 6
                 case 7
                 case 8
                 case 9
                 case 10
                 case 11
                 case 12
                 case 13
                 case 14
                 case 15
                 case 16
                 case 17
                 case 18
                 case 19
                 case 20
                 case 21
                 case 22
                 case 23
                 case 24
                 case 25
                 case 26
                 case 27
                 case 28
                 case 29
                 case 30
                 case 31
                 case 32
                 case 33
                 case 34
                 case 35
                 case 36
                 case 37
                 case 38
                 case 39
                 case 40
                 case 41
                 case 42
                 case 43
                 case 44
                 case 45
                 case 46
                 case 47
                 case 48
                 case 49
                 case 50
                 case 51
                 case 52
                 case 53
                 case 54
                 case 55
                 case 56
                 case 57
                 case 58
                 case 59
                 case 60
                 case 61
                 case 62
                 case 63
                 case 64
                 case 65
                 case 66
                 case 67
                 case 68
                 case 69
                 case 70
                 case 71
                 case 72
                 case 73
                 case 74
                 case 75
                 case 76
                 case 77
                 case 78
                 case 79
                 case 80
                 case 81
                 case 82
                 case 83
                 case 84
                 case 85
                 case 86
                 case 87
                 case 88
                 case 89
                 case 90
                 case 91
                 case 92
                 case 93
                 case 94
                 case 95
                 case 96
                 case 97
                 case 98
                 case 99
                 case 100
                 case 101
                 case 102
                 case 103
                 case 104
                 case 105
                 case 106
                 case 107
                 case 108
                 case 109
                 case 110
                 case 111
                 case 112
                 case 113
                 case 114
                 case 115
                 case 116
                 case 117
                 case 118
                 case 119
                 case 120
                 case 121
                 case 122
                 case 123
                 case 124
                 case 125
                 case 126
                 case 127
                 case 128
                 case 129
                 case 130
                 case 131
                 case 132
                 case 133
                 case 134
                 case 135
                 case 136
                 case 137
                 case 138
                 case 139
                 case 140
 
                 default
             }
             errorStream.WriteLine(errMsgFormat, line, col, s);
             count++;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="2356" endline="2361"><![CDATA[
 
         public void SemErr(int line, int col, string s)
         {
             errorStream.WriteLine(errMsgFormat, line, col, s);
             count++;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="2362" endline="2367"><![CDATA[
 
         public void SemErr(string s)
         {
             errorStream.WriteLine(s);
             count++;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="2368" endline="2372"><![CDATA[
 
         public void Warning(int line, int col, string s)
         {
             errorStream.WriteLine(errMsgFormat, line, col, s);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="2373" endline="2377"><![CDATA[
 
         public void Warning(string s)
         {
             errorStream.WriteLine(s);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="2200" endline="2202"><![CDATA[
         public int count = 0;                                    // number of errors detected
         public System.IO.TextWriter errorStream = Console.Out;   // error messages go to this stream
         public string errMsgFormat = "-- line {0} col {1}
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="2203" endline="2383"><![CDATA[
 
         public void SynErr(int line, int col, int n)
         {
             string s;
             switch (n)
             {
                 case 0
                 case 1
                 case 2
                 case 3
                 case 4
                 case 5
                 case 6
                 case 7
                 case 8
                 case 9
                 case 10
                 case 11
                 case 12
                 case 13
                 case 14
                 case 15
                 case 16
                 case 17
                 case 18
                 case 19
                 case 20
                 case 21
                 case 22
                 case 23
                 case 24
                 case 25
                 case 26
                 case 27
                 case 28
                 case 29
                 case 30
                 case 31
                 case 32
                 case 33
                 case 34
                 case 35
                 case 36
                 case 37
                 case 38
                 case 39
                 case 40
                 case 41
                 case 42
                 case 43
                 case 44
                 case 45
                 case 46
                 case 47
                 case 48
                 case 49
                 case 50
                 case 51
                 case 52
                 case 53
                 case 54
                 case 55
                 case 56
                 case 57
                 case 58
                 case 59
                 case 60
                 case 61
                 case 62
                 case 63
                 case 64
                 case 65
                 case 66
                 case 67
                 case 68
                 case 69
                 case 70
                 case 71
                 case 72
                 case 73
                 case 74
                 case 75
                 case 76
                 case 77
                 case 78
                 case 79
                 case 80
                 case 81
                 case 82
                 case 83
                 case 84
                 case 85
                 case 86
                 case 87
                 case 88
                 case 89
                 case 90
                 case 91
                 case 92
                 case 93
                 case 94
                 case 95
                 case 96
                 case 97
                 case 98
                 case 99
                 case 100
                 case 101
                 case 102
                 case 103
                 case 104
                 case 105
                 case 106
                 case 107
                 case 108
                 case 109
                 case 110
                 case 111
                 case 112
                 case 113
                 case 114
                 case 115
                 case 116
                 case 117
                 case 118
                 case 119
                 case 120
                 case 121
                 case 122
                 case 123
                 case 124
                 case 125
                 case 126
                 case 127
                 case 128
                 case 129
                 case 130
                 case 131
                 case 132
                 case 133
                 case 134
                 case 135
                 case 136
                 case 137
                 case 138
                 case 139
                 case 140
 
                 default
             }
             errorStream.WriteLine(errMsgFormat, line, col, s);
             count++;
         }
 
         public void SemErr(int line, int col, string s)
         {
             errorStream.WriteLine(errMsgFormat, line, col, s);
             count++;
         }
 
         public void SemErr(string s)
         {
             errorStream.WriteLine(s);
             count++;
         }
 
         public void Warning(int line, int col, string s)
         {
             errorStream.WriteLine(errMsgFormat, line, col, s);
         }
 
         public void Warning(string s)
         {
             errorStream.WriteLine(s);
         }
     } // Errors
 
 
     public class FatalError 
     {
         public FatalError(string m) 
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="18" endline="18"><![CDATA[
             get { return this.type; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="19" endline="19"><![CDATA[
             set { this.type = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="20" endline="25"><![CDATA[
         }
 
         /// <summary></summary>
         public Unit Unit
         {
             get { return this.unit; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="26" endline="26"><![CDATA[
             set { this.unit = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="27" endline="32"><![CDATA[
         }
 
         /// <summary></summary>
         public string Value
         {
             get { return this.value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="33" endline="33"><![CDATA[
             set { this.value = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="34" endline="49"><![CDATA[
         }
 
         /// <summary></summary>
         /// <returns></returns>
         public override string ToString()
         {
             System.Text.StringBuilder txt = new System.Text.StringBuilder(value);
             if (type == ValType.Unit)
             {
                 txt.Append(unit.ToString());
             }
             txt.Append(" [");
             txt.Append(type.ToString());
             txt.Append("]");
             return txt.ToString();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="50" endline="84"><![CDATA[
 
         public bool IsColor
         {
             get
             {
                 if (type == ValType.Hex && (value.Length == 6 || (value.Length == 7 && value.StartsWith("#"))))
                 {
                     bool hex = true;
                     foreach (char c in value)
                     {
                         if (!char.IsDigit(c) && c != '#'
                             && c != 'a' && c != 'A'
                             && c != 'b' && c != 'B'
                             && c != 'c' && c != 'C'
                             && c != 'd' && c != 'D'
                             && c != 'e' && c != 'E'
                             && c != 'f' && c != 'F'
                         )
                         {
                             return false;
                         }
                     }
                     foreach (char c in value)
                     {
                         if (!char.IsDigit(c) && c != '#'
                             && c != 'a' && c != 'A'
                             && c != 'b' && c != 'B'
                             && c != 'c' && c != 'C'
                             && c != 'd' && c != 'D'
                             && c != 'e' && c != 'E'
                             && c != 'f' && c != 'F'
                         )
                         {
                             return false;
                         }
                     }
                     return hex;
                 }
                 else if (type == ValType.String)
                 {
                     try
                     {
                         KnownColor kc = (KnownColor)Enum.Parse(typeof(KnownColor), value, true);
                         return true;
                     }
                     catch { }
                 }
                 return false;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="85" endline="115"><![CDATA[
         }
 
         public Color ToColor()
         {
             string hex = "000000";
             if (type == ValType.Hex)
             {
                 if (value.Length == 7 && value.StartsWith("#"))
                 {
                     hex = value.Substring(1);
                 }
                 else if (value.Length == 6)
                 {
                     hex = value;
                 }
             }
             else
             {
                 try
                 {
                     KnownColor kc = (KnownColor)Enum.Parse(typeof(KnownColor), value, true);
                     Color c = Color.FromKnownColor(kc);
                     return c;
                 }
                 catch { }
             }
             int r = DeHex(hex.Substring(0, 2));
             int g = DeHex(hex.Substring(2, 2));
             int b = DeHex(hex.Substring(4));
             return Color.FromArgb(r, g, b);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="116" endline="150"><![CDATA[
         private int DeHex(string input)
         {
             int val;
             int result = 0;
             for (int i = 0; i < input.Length; i++)
             {
                 string chunk = input.Substring(i, 1).ToUpper();
                 switch (chunk)
                 {
                     case "A"
                         val = 10; break;
                     case "B"
                         val = 11; break;
                     case "C"
                         val = 12; break;
                     case "D"
                         val = 13; break;
                     case "E"
                         val = 14; break;
                     case "F"
                         val = 15; break;
                     default
                         val = int.Parse(chunk); break;
                 }
                 if (i == 0)
                 {
                     result += val * 16;
                 }
                 else
                 {
                     result += val;
                 }
             }
             for (int i = 0; i < input.Length; i++)
             {
                 string chunk = input.Substring(i, 1).ToUpper();
                 switch (chunk)
                 {
                     case "A"
                         val = 10; break;
                     case "B"
                         val = 11; break;
                     case "C"
                         val = 12; break;
                     case "D"
                         val = 13; break;
                     case "E"
                         val = 14; break;
                     case "F"
                         val = 15; break;
                     default
                         val = int.Parse(chunk); break;
                 }
                 if (i == 0)
                 {
                     result += val * 16;
                 }
                 else
                 {
                     result += val;
                 }
             }
             return result;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\JavaParser\Parser.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\CSCodeInfo.cs" startline="14" endline="17"><![CDATA[
         {
             this.Value = val;
             this.Position = pos;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\CSCodeInfo.cs" startline="18" endline="37"><![CDATA[
     }
 
     public class CSCodeInfo
     {
         private ArrayList m_Usings;
         private ArrayList m_NameSpaces;
         private ArrayList m_Fields;
         private ArrayList m_Methods;
         private ArrayList m_Properties;
         private ArrayList m_Constructors;
 
         public CSCodeInfo()
         {
             this.m_Usings = new ArrayList();
             this.m_NameSpaces = new ArrayList();
             this.m_Fields = new ArrayList();
             this.m_Methods = new ArrayList();
             this.m_Properties = new ArrayList();
             this.m_Constructors = new ArrayList();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\CSCodeInfo.cs" startline="38" endline="44"><![CDATA[
 
         /// <summary>
         /// Gets or Sets the List of 'using ...' in the code...
         /// </summary>
         public ArrayList Usings
         {
             get { return this.m_Usings; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\CSCodeInfo.cs" startline="45" endline="46"><![CDATA[
 
             set { this.m_Usings = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\CSCodeInfo.cs" startline="47" endline="54"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets the List of 'namespace ...' in the code...
         /// </summary>
         public ArrayList NameSpaces
         {
             get { return this.m_NameSpaces; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\CSCodeInfo.cs" startline="55" endline="56"><![CDATA[
 
             set { this.m_NameSpaces = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\CSCodeInfo.cs" startline="57" endline="64"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets the List of Fields in the code...
         /// </summary>
         public ArrayList Fields
         {
             get { return this.m_Fields; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\CSCodeInfo.cs" startline="65" endline="66"><![CDATA[
 
             set { this.m_Fields = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\CSCodeInfo.cs" startline="67" endline="74"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets the List of Methods in the code...
         /// </summary>
         public ArrayList Methods
         {
             get { return this.m_Methods; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\CSCodeInfo.cs" startline="75" endline="76"><![CDATA[
 
             set { this.m_Methods = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\CSCodeInfo.cs" startline="77" endline="84"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets the List of Properties in the code...
         /// </summary>
         public ArrayList Properties
         {
             get { return this.m_Properties; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\CSCodeInfo.cs" startline="85" endline="86"><![CDATA[
 
             set { this.m_Properties = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\CSCodeInfo.cs" startline="87" endline="94"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets the List of Constructors in the code...
         /// </summary>
         public ArrayList Constructors
         {
             get { return this.m_Constructors; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\CSCodeInfo.cs" startline="95" endline="96"><![CDATA[
 
             set { this.m_Constructors = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="31" endline="33"><![CDATA[
         [global
         internal InternalImages() {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="34" endline="46"><![CDATA[
         
         /// <summary>
         ///   Returns the cached ResourceManager instance used by this class.
         /// </summary>
         [global
         internal static global
             get {
                 if (object.ReferenceEquals(resourceMan, null)) {
                     global
                     resourceMan = temp;
                 }
                 return resourceMan;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="47" endline="57"><![CDATA[
         }
         
         /// <summary>
         ///   Overrides the current thread's CurrentUICulture property for all
         ///   resource lookups using this strongly typed resource class.
         /// </summary>
         [global
         internal static global
             get {
                 return resourceCulture;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="58" endline="60"><![CDATA[
             set {
                 resourceCulture = value;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="61" endline="67"><![CDATA[
         }
         
         internal static System.Drawing.Bitmap _lock {
             get {
                 object obj = ResourceManager.GetObject("_lock", resourceCulture);
                 return ((System.Drawing.Bitmap)(obj));
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="68" endline="74"><![CDATA[
         }
         
         internal static System.Drawing.Bitmap analyze {
             get {
                 object obj = ResourceManager.GetObject("analyze", resourceCulture);
                 return ((System.Drawing.Bitmap)(obj));
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="75" endline="81"><![CDATA[
         }
         
         internal static System.Drawing.Bitmap cmd {
             get {
                 object obj = ResourceManager.GetObject("cmd", resourceCulture);
                 return ((System.Drawing.Bitmap)(obj));
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="82" endline="88"><![CDATA[
         }
         
         internal static System.Drawing.Bitmap Code {
             get {
                 object obj = ResourceManager.GetObject("Code", resourceCulture);
                 return ((System.Drawing.Bitmap)(obj));
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="89" endline="95"><![CDATA[
         }
         
         internal static System.Drawing.Bitmap Diff {
             get {
                 object obj = ResourceManager.GetObject("Diff", resourceCulture);
                 return ((System.Drawing.Bitmap)(obj));
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="96" endline="102"><![CDATA[
         }
         
         internal static System.Drawing.Bitmap downarrow {
             get {
                 object obj = ResourceManager.GetObject("downarrow", resourceCulture);
                 return ((System.Drawing.Bitmap)(obj));
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="103" endline="109"><![CDATA[
         }
         
         internal static System.Drawing.Bitmap FEIcon {
             get {
                 object obj = ResourceManager.GetObject("FEIcon", resourceCulture);
                 return ((System.Drawing.Bitmap)(obj));
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="110" endline="116"><![CDATA[
         }
         
         internal static System.Drawing.Bitmap Find {
             get {
                 object obj = ResourceManager.GetObject("Find", resourceCulture);
                 return ((System.Drawing.Bitmap)(obj));
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="117" endline="123"><![CDATA[
         }
         
         internal static System.Drawing.Bitmap Next {
             get {
                 object obj = ResourceManager.GetObject("Next", resourceCulture);
                 return ((System.Drawing.Bitmap)(obj));
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="124" endline="130"><![CDATA[
         }
         
         internal static System.Drawing.Bitmap Project {
             get {
                 object obj = ResourceManager.GetObject("Project", resourceCulture);
                 return ((System.Drawing.Bitmap)(obj));
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="131" endline="137"><![CDATA[
         }
         
         internal static System.Drawing.Bitmap uparrow {
             get {
                 object obj = ResourceManager.GetObject("uparrow", resourceCulture);
                 return ((System.Drawing.Bitmap)(obj));
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="138" endline="144"><![CDATA[
         }
         
         internal static System.Drawing.Bitmap X {
             get {
                 object obj = ResourceManager.GetObject("X", resourceCulture);
                 return ((System.Drawing.Bitmap)(obj));
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="16" endline="101"><![CDATA[
         {
             Peter.CSParser.Scanner scanner = new Peter.CSParser.Scanner(fileName);
             Peter.CSParser.Parser parser = new Peter.CSParser.Parser(scanner);
             parser.Parse();
 
             // Using...
             TreeNode nUsing = new TreeNode("Usings");
             foreach (TokenMatch tm in parser.CodeInfo.Usings)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nUsing.Nodes.Add(n);
             }
             foreach (TokenMatch tm in parser.CodeInfo.Usings)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nUsing.Nodes.Add(n);
             }
             if (nUsing.Nodes.Count > 0)
             {
                 nodes.Add(nUsing);
             }
 
             // Constructors...
             TreeNode nConstruct = new TreeNode("Constructors");
             foreach (TokenMatch tm in parser.CodeInfo.Constructors)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nConstruct.Nodes.Add(n);
             }
             foreach (TokenMatch tm in parser.CodeInfo.Constructors)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nConstruct.Nodes.Add(n);
             }
             if (nConstruct.Nodes.Count > 0)
             {
                 nodes.Add(nConstruct);
                 nConstruct.Expand();
             }
 
             // Namespace...
             /*TreeNode nName = new TreeNode("namespaces");
             foreach (string s in parser.CodeInfo.NameSpaces)
             {
                 TreeNode n = new TreeNode(s);
                 nName.Nodes.Add(n);
             }
             if (nName.Nodes.Count > 0)
             {
                 this.m_Control.AddNode(nName);
             }*/
 
             // Fields...
             TreeNode nField = new TreeNode("Fields");
             foreach (TokenMatch tm in parser.CodeInfo.Fields)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nField.Nodes.Add(n);
             }
             foreach (TokenMatch tm in parser.CodeInfo.Fields)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nField.Nodes.Add(n);
             }
             if (nField.Nodes.Count > 0)
             {
                 nodes.Add(nField);
                 nField.Expand();
             }
 
             // Methods...
             TreeNode nMethod = new TreeNode("Methods");
             foreach (TokenMatch tm in parser.CodeInfo.Methods)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nMethod.Nodes.Add(n);
             }
             foreach (TokenMatch tm in parser.CodeInfo.Methods)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nMethod.Nodes.Add(n);
             }
             if (nMethod.Nodes.Count > 0)
             {
                 nodes.Add(nMethod);
                 nMethod.Expand();
             }
 
             // Properties...
             TreeNode nProps = new TreeNode("Properties");
             foreach (TokenMatch tm in parser.CodeInfo.Properties)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nProps.Nodes.Add(n);
             }
             foreach (TokenMatch tm in parser.CodeInfo.Properties)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nProps.Nodes.Add(n);
             }
             if (nProps.Nodes.Count > 0)
             {
                 nodes.Add(nProps);
                 nProps.Expand();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="29" endline="29"><![CDATA[
             get { return _myImageList; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="30" endline="30"><![CDATA[
             set { _myImageList = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="31" endline="39"><![CDATA[
         }
 
         ///<summary>Default constructor</summary>
         public GListBox ()
         {
             // Set owner draw mode
             this.DrawMode = DrawMode.OwnerDrawFixed;
             this.BorderStyle = BorderStyle.FixedSingle;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="40" endline="80"><![CDATA[
 
         protected override void OnDrawItem (System.Windows.Forms.DrawItemEventArgs e)
         {
             e.DrawBackground();
             e.DrawFocusRectangle();
             if (this.Items.Count > 0)
             {
                 GListBoxItem item;
                 Rectangle bounds = e.Bounds;
                 Size imageSize = _myImageList.ImageSize;
                 try
                 {
                     item = (GListBoxItem)Items[e.Index];
                     if (item.ImageIndex != -1)
                     {
                         ImageList.Draw(e.Graphics, bounds.Left, bounds.Top, item.ImageIndex);
                         e.Graphics.DrawString(item.Text, e.Font, new SolidBrush(e.ForeColor),
                             bounds.Left + imageSize.Width, bounds.Top);
                     }
                     else
                     {
                         e.Graphics.DrawString(item.Text, e.Font, new SolidBrush(e.ForeColor),
                             bounds.Left, bounds.Top);
                     }
                 }
                 catch
                 {
                     if (e.Index != -1)
                     {
                         e.Graphics.DrawString(Items[e.Index].ToString(), e.Font,
                             new SolidBrush(e.ForeColor), bounds.Left, bounds.Top);
                     }
                     else
                     {
                         e.Graphics.DrawString(Text, e.Font, new SolidBrush(e.ForeColor),
                             bounds.Left, bounds.Top);
                     }
                 }
             }
             base.OnDrawItem(e);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="81" endline="95"><![CDATA[
     }
 
     ///<summary>Represents an item in a GListBox that has text and associated graphic</summary>
     public class GListBoxItem
     {
         #region Member variables
         private string _myText;
         private int _myImageIndex;
         #endregion
 
         #region Properties
         ///<summary>Text for item</summary>
         public string Text
         {
             get { return _myText; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="96" endline="96"><![CDATA[
             set { _myText = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="97" endline="101"><![CDATA[
         }
         ///<summary>Identifier for item graphic</summary>
         public int ImageIndex
         {
             get { return _myImageIndex; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="102" endline="102"><![CDATA[
             set { _myImageIndex = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="103" endline="114"><![CDATA[
         }
         #endregion
 
         /// <summary>
         /// Constructor for item providing text and graphic </summary>
         /// <param name="text">string representing text for item</param>
         /// <param name="index">Identifier for item graphic</param>
         public GListBoxItem (string text, int index)
         {
             _myText = text;
             _myImageIndex = index;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="115" endline="117"><![CDATA[
         ///<summary>Constructor that provides text for item</summary>
         ///<param name="text">string representing text for item</param>
         public GListBoxItem (string text) 
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="118" endline="120"><![CDATA[
 
         ///<summary>Default constructor - empty text, no graphic</summary>
         public GListBoxItem () 
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\InternalImages.Designer.cs" startline="121" endline="132"><![CDATA[
 
         ///<summary>
         ///Returns a <see cref="T
         ///</summary>
         ///
         ///<returns>
         ///A <see cref="T
         ///</returns>
         public override string ToString ()
         {
             return _myText;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\Util.cs" startline="18" endline="20"><![CDATA[
         {
             identStr += "    ";
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\Util.cs" startline="21" endline="25"><![CDATA[
 
         public void Unident()
         {
             identStr = identStr.Substring(0, identStr.Length - 4);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\Util.cs" startline="26" endline="31"><![CDATA[
 
         public void OpenBlock()
         {
             Writeline("{");
             Ident();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\Util.cs" startline="32" endline="37"><![CDATA[
 
         public void CloseBlock()
         {
             Unident();
             Writeline("}" + Environment.NewLine);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\Util.cs" startline="38" endline="52"><![CDATA[
 
         public void Writeline(string line)
         {
             output.Write(identStr);
             output.WriteLine(line);
             if (linePush.Count != 0)
             {
                 foreach (string s in linePush)
                 {
                     output.Write(identStr);
                     output.WriteLine(s);
                 }
                 foreach (string s in linePush)
                 {
                     output.Write(identStr);
                     output.WriteLine(s);
                 }
                 linePush.Clear();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\Util.cs" startline="53" endline="57"><![CDATA[
 
         public void PushLine(string line)
         {
             linePush.Add(line);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\Util.cs" startline="58" endline="72"><![CDATA[
 
         public string ConvertModifier(string mod)
         {
             switch (mod)
             {
                 case "Overrides"
                     return "override ";
                 case "Shared"
                     return "static";
                 case "Friend"
                     return "internal";
                 default
                     return mod.ToLower() + " ";
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\Util.cs" startline="73" endline="99"><![CDATA[
 
         public string ConverteTipo(string tipo)
         {
             switch (tipo)
             {
                 case "Integer"
                     return "int";
                 case "String"
                     return "string";
                 case "Boolean"
                     return "bool";
                 case "Long"
                     return "long";
                 case "Single"
                     return "float";
                 case "Double"
                     return "double";
                 case "Short"
                     return "short";
                 case "Byte"
                     return "byte";
                 case "Char"
                     return "char";
                 default
                     return tipo;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\Util.cs" startline="100" endline="107"><![CDATA[
 
         public string ConverteString(string str)
         {
             if (str.IndexOf('\\') >= 0)
                 return "@" + str;
             else
                 return str;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\Util.cs" startline="108" endline="120"><![CDATA[
 
         public string ConverteLogicalOp(string str)
         {
             switch (str)
             {
                 case "="
                     return " == ";
                 case "<>"
                     return " != ";
                 default
                     return " " + str + " ";
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\Util.cs" startline="121" endline="128"><![CDATA[
 
         public string ConvertByX(string byx)
         {
             if (byx == "ByVal")
                 return "";
             else
                 return "ref ";
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\Util.cs" startline="11" endline="15"><![CDATA[
         string identStr = "";
 
         public TextWriter output;
 
         StringCollection linePush = new StringCollection();
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\Util.cs" startline="16" endline="16"><![CDATA[
             get { return tags; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\Util.cs" startline="17" endline="17"><![CDATA[
             set { tags = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\Util.cs" startline="18" endline="23"><![CDATA[
         }
 
         /// <summary></summary>
         public List<Property> Properties
         {
             get { return properties; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\Util.cs" startline="24" endline="24"><![CDATA[
             set { properties = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\Util.cs" startline="10" endline="11"><![CDATA[
         private List<Tag> tags = new List<Tag>();
         private List<Property> properties = new List<Property>();
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="28" endline="31"><![CDATA[
         public DataSourceRowComparer (IComparer baseComparer)
         {
             this.baseComparer = baseComparer;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="32" endline="40"><![CDATA[
 
         #region IComparer Members
 
         public int Compare (object x, object y)
         {
             DataSourceRow r1 = (DataSourceRow)x;
             DataSourceRow r2 = (DataSourceRow)y;
             return baseComparer.Compare(r1.BoundItem, r2.BoundItem);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="41" endline="61"><![CDATA[
 
         #endregion
     }
     #endregion DataSourceRowComparer - implementation of abstract comparer class
 
     #region DataSourceRow - abstract representation of a data item.
     /// <summary>
     /// The DataSourceRow is a wrapper row class around the real bound data. This row is an abstraction
     /// so different types of data can be encaptulated in this class, although for the OutlookGrid it will
     /// simply look as one type of data. 
     /// Note
     /// </summary>
     internal class DataSourceRow 
     {
         DataSourceManager manager;
         object boundItem;
         public DataSourceRow (DataSourceManager manager, object boundItem)
         {
             this.manager = manager;
             this.boundItem = boundItem;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="62" endline="73"><![CDATA[
 
         /// <summary>
         /// Gets an onject from the row
         /// </summary>
         /// <param name="index">The index of the object</param>
         /// <returns>The object at the specified index</returns>
         public object this[int index]
         {
             get
             {
                 return List[index];
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="74" endline="84"><![CDATA[
         }
 
         /// <summary>
         /// Gets the bound item
         /// </summary>
         public object BoundItem
         {
             get
             {
                 return boundItem;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="85" endline="95"><![CDATA[
         }
 
         /// <summary>
         /// Adds an element to the Row
         /// </summary>
         /// <param name="val">The element to be added</param>
         /// <returns>The position into which the new element was inserted. </returns>
         public int Add (object val)
         {
             return List.Add(val);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="96" endline="121"><![CDATA[
 
     }
     #endregion DataSourceRow - abstract representation of a data item.
 
     #region DataSourceManager - manages a bound datasource.
     /// <summary>
     /// the DataDourceManager class is a wrapper class around different types of datasources.
     /// in this case the DataSet, object list using reflection and the OutlooGridRow objects are supported
     /// by this class. Basically the DataDourceManager works like a facade that provides access in a uniform
     /// way to the datasource.
     /// Note
     /// </summary>
     internal class DataSourceManager
     {
         private object dataSource;
         private string dataMember;
 
         public ArrayList Columns;
         public ArrayList Rows;
 
         public DataSourceManager (object dataSource, string dataMember)
         {
             this.dataSource = dataSource;
             this.dataMember = dataMember;
             InitManager();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="122" endline="128"><![CDATA[
 
         /// <summary>
         /// datamember readonly for now
         /// </summary>
         public string DataMember
         {
             get { return dataMember; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="129" endline="136"><![CDATA[
         }
 
         /// <summary>
         /// datasource is readonly for now
         /// </summary>
         public object DataSource
         {
             get { return dataSource; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="137" endline="155"><![CDATA[
         }
 
         /// <summary>
         /// this function initializes the DataSourceManager's internal state.
         /// it will analyse the datasource taking the following source into account
         /// - DataSet
         /// - Object array (must implement IList)
         /// - OutlookGrid
         /// </summary>
 
         private void InitManager ()
         {
             if (dataSource is IListSource)
                 InitDataSet();
             if (dataSource is IList)
                 InitList();
             if (dataSource is OutlookGrid)
                 InitGrid();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="156" endline="174"><![CDATA[
 
         private void InitDataSet ()
         {
             Columns = new ArrayList();
             Rows = new ArrayList();
 
             DataTable table = ((DataSet)dataSource).Tables[this.dataMember];
             // use reflection to discover all properties of the object
             foreach (DataColumn c in table.Columns)
                 Columns.Add(c.ColumnName);
             foreach (DataColumn c in table.Columns)
                 Columns.Add(c.ColumnName);
 
             foreach (DataRow r in table.Rows)
             {
                 DataSourceRow row = new DataSourceRow(this, r);
                 for (int i = 0; i < Columns.Count; i++)
                     row.Add(r[i]);
                 for (int i = 0; i < Columns.Count; i++)
                     row.Add(r[i]);
                 Rows.Add(row);
             }
             foreach (DataRow r in table.Rows)
             {
                 DataSourceRow row = new DataSourceRow(this, r);
                 for (int i = 0; i < Columns.Count; i++)
                     row.Add(r[i]);
                 Rows.Add(row);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="175" endline="196"><![CDATA[
 
         private void InitGrid ()
         {
             Columns = new ArrayList();
             Rows = new ArrayList();
 
             OutlookGrid grid = (OutlookGrid)dataSource;
             // use reflection to discover all properties of the object
             foreach (DataGridViewColumn c in grid.Columns)
                 Columns.Add(c.Name);
             foreach (DataGridViewColumn c in grid.Columns)
                 Columns.Add(c.Name);
 
             foreach (OutlookGridRow r in grid.Rows)
             {
                 if (!r.IsGroupRow && !r.IsNewRow)
                 {
                     DataSourceRow row = new DataSourceRow(this, r);
                     for (int i = 0; i < Columns.Count; i++)
                         row.Add(r.Cells[i].Value);
                     for (int i = 0; i < Columns.Count; i++)
                         row.Add(r.Cells[i].Value);
                     Rows.Add(row);
                 }
             }
             foreach (OutlookGridRow r in grid.Rows)
             {
                 if (!r.IsGroupRow && !r.IsNewRow)
                 {
                     DataSourceRow row = new DataSourceRow(this, r);
                     for (int i = 0; i < Columns.Count; i++)
                         row.Add(r.Cells[i].Value);
                     Rows.Add(row);
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="197" endline="220"><![CDATA[
 
         private void InitList ()
         {
             Columns = new ArrayList();
             Rows = new ArrayList();
             IList list = (IList)dataSource;
 
             // use reflection to discover all properties of the object
             BindingFlags bf = BindingFlags.Instance | BindingFlags.Public | BindingFlags.GetProperty;
             PropertyInfo[] props = list[0].GetType().GetProperties();
             foreach (PropertyInfo pi in props)
                 Columns.Add(pi.Name);
             foreach (PropertyInfo pi in props)
                 Columns.Add(pi.Name);
 
             foreach (object obj in list)
             {
                 DataSourceRow row = new DataSourceRow(this, obj);
                 foreach (PropertyInfo pi in props)
                 {
                     object result = obj.GetType().InvokeMember(pi.Name, bf, null, obj, null);
                     row.Add(result);
                 }
                 foreach (PropertyInfo pi in props)
                 {
                     object result = obj.GetType().InvokeMember(pi.Name, bf, null, obj, null);
                     row.Add(result);
                 }
                 Rows.Add(row);
             }
             foreach (object obj in list)
             {
                 DataSourceRow row = new DataSourceRow(this, obj);
                 foreach (PropertyInfo pi in props)
                 {
                     object result = obj.GetType().InvokeMember(pi.Name, bf, null, obj, null);
                     row.Add(result);
                 }
                 Rows.Add(row);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="221" endline="225"><![CDATA[
 
         public void Sort (System.Collections.IComparer comparer)
         {
             Rows.Sort(new DataSourceRowComparer(comparer));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="39" endline="58"><![CDATA[
         public Buffer(Stream s, bool isUserStream)
         {
             stream = s; this.isUserStream = isUserStream;
 
             if (stream.CanSeek)
             {
                 fileLen = (int)stream.Length;
                 bufLen = Math.Min(fileLen, MAX_BUFFER_LENGTH);
                 bufStart = Int32.MaxValue; // nothing in the buffer so far
             }
             else
             {
                 fileLen = bufLen = bufStart = 0;
             }
 
             buf = new byte[(bufLen > 0) ? bufLen 
             if (fileLen > 0) Pos = 0; // setup buffer to position 0 (start)
             else bufPos = 0; // index 0 is already after the file, thus Pos = 0 is invalid
             if (bufLen == fileLen && stream.CanSeek) Close();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="59" endline="71"><![CDATA[
 
         protected Buffer(Buffer b)
         { // called in UTF8Buffer constructor
             buf = b.buf;
             bufStart = b.bufStart;
             bufLen = b.bufLen;
             fileLen = b.fileLen;
             bufPos = b.bufPos;
             stream = b.stream;
             // keep destructor from closing the stream
             b.stream = null;
             isUserStream = b.isUserStream;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="72" endline="73"><![CDATA[
 
         ~Buffer() { Close(); }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="74" endline="82"><![CDATA[
 
         protected void Close()
         {
             if (!isUserStream && stream != null)
             {
                 stream.Close();
                 stream = null;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="83" endline="103"><![CDATA[
 
         public virtual int Read()
         {
             if (bufPos < bufLen)
             {
                 return buf[bufPos++];
             }
             else if (Pos < fileLen)
             {
                 Pos = Pos; // shift buffer start to Pos
                 return buf[bufPos++];
             }
             else if (stream != null && !stream.CanSeek && ReadNextStreamChunk() > 0)
             {
                 return buf[bufPos++];
             }
             else
             {
                 return EOF;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="104" endline="111"><![CDATA[
 
         public int Peek()
         {
             int curPos = Pos;
             int ch = Read();
             Pos = curPos;
             return ch;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="112" endline="122"><![CDATA[
 
         public string GetString(int beg, int end)
         {
             int len = end - beg;
             char[] buf = new char[len];
             int oldPos = Pos;
             Pos = beg;
             for (int i = 0; i < len; i++) buf[i] = (char)Read();
             Pos = oldPos;
             return new String(buf);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="123" endline="126"><![CDATA[
 
         public int Pos
         {
             get { return bufPos + bufStart; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="127" endline="158"><![CDATA[
             set
             {
                 if (value >= fileLen && stream != null && !stream.CanSeek)
                 {
                     // Wanted position is after buffer and the stream
                     // is not seek-able e.g. network or console,
                     // thus we have to read the stream manually till
                     // the wanted position is in sight.
                     while (value >= fileLen && ReadNextStreamChunk() > 0) ;
                 }
 
                 if (value < 0 || value > fileLen)
                 {
                     throw new FatalError("buffer out of bounds access, position
                 }
 
                 if (value >= bufStart && value < bufStart + bufLen)
                 { // already in buffer
                     bufPos = value - bufStart;
                 }
                 else if (stream != null)
                 { // must be swapped in
                     stream.Seek(value, SeekOrigin.Begin);
                     bufLen = stream.Read(buf, 0, buf.Length);
                     bufStart = value; bufPos = 0;
                 }
                 else
                 {
                     // set the position to the end of the file, Pos will return fileLen.
                     bufPos = fileLen - bufStart;
                 }
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="159" endline="186"><![CDATA[
         }
 
         // Read the next chunk of bytes from the stream, increases the buffer
         // if needed and updates the fields fileLen and bufLen.
         // Returns the number of bytes read.
         private int ReadNextStreamChunk()
         {
             int free = buf.Length - bufLen;
             if (free == 0)
             {
                 // in the case of a growing input stream
                 // we can neither seek in the stream, nor can we
                 // foresee the maximum length, thus we must adapt
                 // the buffer size on demand.
                 byte[] newBuf = new byte[bufLen * 2];
                 Array.Copy(buf, newBuf, bufLen);
                 buf = newBuf;
                 free = bufLen;
             }
             int read = stream.Read(buf, bufLen, free);
             if (read > 0)
             {
                 fileLen = bufLen = (bufLen + read);
                 return read;
             }
             // end of stream reached
             return 0;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="187" endline="194"><![CDATA[
     }
 
     //-----------------------------------------------------------------------------------
     // UTF8Buffer
     //-----------------------------------------------------------------------------------
     public class UTF8Buffer 
     {
         public UTF8Buffer(Buffer b) 
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="195" endline="234"><![CDATA[
 
         public override int Read()
         {
             int ch;
             do
             {
                 ch = base.Read();
                 // until we find a uft8 start (0xxxxxxx or 11xxxxxx)
             } while ((ch >= 128) && ((ch & 0xC0) != 0xC0) && (ch != EOF));
             if (ch < 128 || ch == EOF)
             {
                 // nothing to do, first 127 chars are the same in ascii and utf8
                 // 0xxxxxxx or end of file character
             }
             else if ((ch & 0xF0) == 0xF0)
             {
                 // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
                 int c1 = ch & 0x07; ch = base.Read();
                 int c2 = ch & 0x3F; ch = base.Read();
                 int c3 = ch & 0x3F; ch = base.Read();
                 int c4 = ch & 0x3F;
                 ch = (((((c1 << 6) | c2) << 6) | c3) << 6) | c4;
             }
             else if ((ch & 0xE0) == 0xE0)
             {
                 // 1110xxxx 10xxxxxx 10xxxxxx
                 int c1 = ch & 0x0F; ch = base.Read();
                 int c2 = ch & 0x3F; ch = base.Read();
                 int c3 = ch & 0x3F;
                 ch = (((c1 << 6) | c2) << 6) | c3;
             }
             else if ((ch & 0xC0) == 0xC0)
             {
                 // 110xxxxx 10xxxxxx
                 int c1 = ch & 0x1F; ch = base.Read();
                 int c2 = ch & 0x3F;
                 ch = (c1 << 6) | c2;
             }
             return ch;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="235" endline="276"><![CDATA[
     }
 
     //-----------------------------------------------------------------------------------
     // Scanner
     //-----------------------------------------------------------------------------------
     public class Scanner
     {
         const char EOL = '\n';
         const int eofSym = 0; /* pdt */
         const int maxT = 101;
         const int noSym = 101;
 
 
         public Buffer buffer; // scanner buffer
 
         Token t;          // current token
         int ch;           // current input character
         int pos;          // byte position of current character
         int col;          // column number of current character
         int line;         // line number of current character
         int oldEols;      // EOLs that appeared in a comment;
         Dictionary<int, int> start; // maps first token character to start state
 
         Token tokens;     // list of tokens already peeked (first token is a dummy)
         Token pt;         // current peek token
 
         char[] tval = new char[128]; // text of current token
         int tlen;         // length of current token
 
         public Scanner(string fileName)
         {
             try
             {
                 Stream stream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
                 buffer = new Buffer(stream, false);
                 Init();
             }
             catch (IOException)
             {
                 throw new FatalError("Cannot open file " + fileName);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="261" endline="282"><![CDATA[
         char[] tval = new char[128]; // text of current token
         int tlen;         // length of current token
 
         public Scanner(string fileName)
         {
             try
             {
                 Stream stream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
                 buffer = new Buffer(stream, false);
                 Init();
             }
             catch (IOException)
             {
                 throw new FatalError("Cannot open file " + fileName);
             }
         }
 
         public Scanner(Stream s)
         {
             buffer = new Buffer(s, true);
             Init();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="283" endline="336"><![CDATA[
 
         void Init()
         {
             pos = -1; line = 1; col = 0;
             oldEols = 0;
             NextCh();
             if (ch == 0xEF)
             { // check optional byte order mark for UTF-8
                 NextCh(); int ch1 = ch;
                 NextCh(); int ch2 = ch;
                 if (ch1 != 0xBB || ch2 != 0xBF)
                 {
                     throw new FatalError(String.Format("illegal byte order mark
                 }
                 buffer = new UTF8Buffer(buffer); col = 0;
                 NextCh();
             }
             start = new Dictionary<int, int>(128);
             for (int i = 36; i <= 36; ++i) start[i] = 1;
             for (int i = 65; i <= 90; ++i) start[i] = 1;
             for (int i = 95; i <= 95; ++i) start[i] = 1;
             for (int i = 97; i <= 122; ++i) start[i] = 1;
             for (int i = 48; i <= 48; ++i) start[i] = 46;
             for (int i = 49; i <= 57; ++i) start[i] = 47;
             start[46] = 48;
             start[39] = 18;
             start[34] = 27;
             start[58] = 35;
             start[44] = 36;
             start[45] = 73;
             start[43] = 74;
             start[123] = 39;
             start[91] = 40;
             start[40] = 41;
             start[33] = 75;
             start[125] = 42;
             start[93] = 43;
             start[41] = 44;
             start[126] = 45;
             start[59] = 54;
             start[42] = 76;
             start[61] = 77;
             start[63] = 55;
             start[47] = 78;
             start[38] = 79;
             start[124] = 80;
             start[94] = 81;
             start[37] = 82;
             start[60] = 83;
             start[62] = 84;
             start[Buffer.EOF] = -1;
 
             pt = tokens = new Token();  // first token is a dummy
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="337" endline="351"><![CDATA[
 
         void NextCh()
         {
             if (oldEols > 0) { ch = EOL; oldEols--; }
             else
             {
                 pos = buffer.Pos;
                 ch = buffer.Read(); col++;
                 // replace isolated '\r' by '\n' in order to make
                 // eol handling uniform across Windows, Unix and Mac
                 if (ch == '\r' && buffer.Peek() != '\n') ch = EOL;
                 if (ch == EOL) { line++; col = 0; }
             }
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="352" endline="363"><![CDATA[
 
         void AddCh()
         {
             if (tlen >= tval.Length)
             {
                 char[] newBuf = new char[2 * tval.Length];
                 Array.Copy(tval, 0, newBuf, 0, tval.Length);
                 tval = newBuf;
             }
             tval[tlen++] = (char)ch;
             NextCh();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="364" endline="391"><![CDATA[
 
 
 
         bool Comment0()
         {
             int level = 1, pos0 = pos, line0 = line, col0 = col;
             NextCh();
             if (ch == '/')
             {
                 NextCh();
                 for (; ; )
                 {
                     if (ch == 10)
                     {
                         level--;
                         if (level == 0) { oldEols = line - line0; NextCh(); return true; }
                         NextCh();
                     }
                     else if (ch == Buffer.EOF) return false;
                     else NextCh();
                 }
             }
             else
             {
                 buffer.Pos = pos0; NextCh(); line = line0; col = col0;
             }
             return false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="392" endline="421"><![CDATA[
 
         bool Comment1()
         {
             int level = 1, pos0 = pos, line0 = line, col0 = col;
             NextCh();
             if (ch == '*')
             {
                 NextCh();
                 for (; ; )
                 {
                     if (ch == '*')
                     {
                         NextCh();
                         if (ch == '/')
                         {
                             level--;
                             if (level == 0) { oldEols = line - line0; NextCh(); return true; }
                             NextCh();
                         }
                     }
                     else if (ch == Buffer.EOF) return false;
                     else NextCh();
                 }
             }
             else
             {
                 buffer.Pos = pos0; NextCh(); line = line0; col = col0;
             }
             return false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="422" endline="479"><![CDATA[
 
 
         void CheckLiteral()
         {
             switch (t.val)
             {
                 case "boolean"
                 case "byte"
                 case "char"
                 case "class"
                 case "double"
                 case "false"
                 case "final"
                 case "float"
                 case "int"
                 case "long"
                 case "new"
                 case "null"
                 case "short"
                 case "static"
                 case "super"
                 case "this"
                 case "true"
                 case "void"
                 case "package"
                 case "import"
                 case "public"
                 case "protected"
                 case "private"
                 case "abstract"
                 case "strictfp"
                 case "native"
                 case "synchronized"
                 case "transient"
                 case "volatile"
                 case "extends"
                 case "implements"
                 case "throws"
                 case "interface"
                 case "if"
                 case "else"
                 case "for"
                 case "while"
                 case "do"
                 case "try"
                 case "finally"
                 case "switch"
                 case "return"
                 case "throw"
                 case "break"
                 case "continue"
                 case "catch"
                 case "case"
                 case "default"
                 case "instanceof"
                 default
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="480" endline="786"><![CDATA[
 
         Token NextToken()
         {
             while (ch == ' ' ||
                 ch >= 9 && ch <= 10 || ch == 13
             ) NextCh();
             while (ch == ' ' ||
                 ch >= 9 && ch <= 10 || ch == 13
             ) NextCh();
             if (ch == '/' && Comment0() || ch == '/' && Comment1()) return NextToken();
             t = new Token();
             t.pos = pos; t.col = col; t.line = line;
             int state;
             try { state = start[ch]; }
             catch (KeyNotFoundException) { state = 0; }
             tlen = 0; AddCh();
 
             switch (state)
             {
                 case -1
                 case 0
                 case 1
                     if (ch == '$' || ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'Z' || ch == '_' || ch >= 'a' && ch <= 'z') { AddCh(); goto case 1; }
                     else { t.kind = 1; t.val = new String(tval, 0, tlen); CheckLiteral(); return t; }
                 case 2
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 3; }
                     else { t.kind = noSym; break; }
                 case 3
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 3; }
                     else if (ch == 'L' || ch == 'l') { AddCh(); goto case 4; }
                     else { t.kind = 2; break; }
                 case 4
                     { t.kind = 2; break; }
                 case 5
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 5; }
                     else if (ch == 'D' || ch == 'F' || ch == 'd' || ch == 'f') { AddCh(); goto case 17; }
                     else if (ch == 'E' || ch == 'e') { AddCh(); goto case 6; }
                     else { t.kind = 3; break; }
                 case 6
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 8; }
                     else if (ch == '+' || ch == '-') { AddCh(); goto case 7; }
                     else { t.kind = noSym; break; }
                 case 7
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 8; }
                     else { t.kind = noSym; break; }
                 case 8
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 8; }
                     else if (ch == 'D' || ch == 'F' || ch == 'd' || ch == 'f') { AddCh(); goto case 17; }
                     else { t.kind = 3; break; }
                 case 9
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 9; }
                     else if (ch == '.') { AddCh(); goto case 10; }
                     else if (ch == 'E' || ch == 'e') { AddCh(); goto case 14; }
                     else if (ch == 'D' || ch == 'F' || ch == 'd' || ch == 'f') { AddCh(); goto case 17; }
                     else { t.kind = noSym; break; }
                 case 10
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 10; }
                     else if (ch == 'D' || ch == 'F' || ch == 'd' || ch == 'f') { AddCh(); goto case 17; }
                     else if (ch == 'E' || ch == 'e') { AddCh(); goto case 11; }
                     else { t.kind = 3; break; }
                 case 11
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 13; }
                     else if (ch == '+' || ch == '-') { AddCh(); goto case 12; }
                     else { t.kind = noSym; break; }
                 case 12
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 13; }
                     else { t.kind = noSym; break; }
                 case 13
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 13; }
                     else if (ch == 'D' || ch == 'F' || ch == 'd' || ch == 'f') { AddCh(); goto case 17; }
                     else { t.kind = 3; break; }
                 case 14
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 16; }
                     else if (ch == '+' || ch == '-') { AddCh(); goto case 15; }
                     else { t.kind = noSym; break; }
                 case 15
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 16; }
                     else { t.kind = noSym; break; }
                 case 16
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 16; }
                     else if (ch == 'D' || ch == 'F' || ch == 'd' || ch == 'f') { AddCh(); goto case 17; }
                     else { t.kind = 3; break; }
                 case 17
                     { t.kind = 3; break; }
                 case 18
                     if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= '&' || ch >= '(' && ch <= '[' || ch >= ']' && ch <= 65535) { AddCh(); goto case 19; }
                     else if (ch == 92) { AddCh(); goto case 20; }
                     else { t.kind = noSym; break; }
                 case 19
                     if (ch == 39) { AddCh(); goto case 26; }
                     else { t.kind = noSym; break; }
                 case 20
                     if (ch >= '0' && ch <= '3') { AddCh(); goto case 49; }
                     else if (ch >= '4' && ch <= '7') { AddCh(); goto case 25; }
                     else if (ch == '"' || ch == 39 || ch == 92 || ch == 'b' || ch == 'f' || ch == 'n' || ch == 'r' || ch == 't') { AddCh(); goto case 19; }
                     else if (ch == 'u') { AddCh(); goto case 21; }
                     else { t.kind = noSym; break; }
                 case 21
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 22; }
                     else if (ch == 'u') { AddCh(); goto case 21; }
                     else { t.kind = noSym; break; }
                 case 22
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 23; }
                     else { t.kind = noSym; break; }
                 case 23
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 24; }
                     else { t.kind = noSym; break; }
                 case 24
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 19; }
                     else { t.kind = noSym; break; }
                 case 25
                     if (ch >= '0' && ch <= '7') { AddCh(); goto case 19; }
                     else if (ch == 39) { AddCh(); goto case 26; }
                     else { t.kind = noSym; break; }
                 case 26
                     { t.kind = 4; break; }
                 case 27
                     if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= '!' || ch >= '#' && ch <= '[' || ch >= ']' && ch <= 65535) { AddCh(); goto case 27; }
                     else if (ch == '"') { AddCh(); goto case 34; }
                     else if (ch == 92) { AddCh(); goto case 28; }
                     else { t.kind = noSym; break; }
                 case 28
                     if (ch >= '0' && ch <= '3') { AddCh(); goto case 51; }
                     else if (ch >= '4' && ch <= '7') { AddCh(); goto case 33; }
                     else if (ch == '"' || ch == 39 || ch == 92 || ch == 'b' || ch == 'f' || ch == 'n' || ch == 'r' || ch == 't') { AddCh(); goto case 27; }
                     else if (ch == 'u') { AddCh(); goto case 29; }
                     else { t.kind = noSym; break; }
                 case 29
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 30; }
                     else if (ch == 'u') { AddCh(); goto case 29; }
                     else { t.kind = noSym; break; }
                 case 30
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 31; }
                     else { t.kind = noSym; break; }
                 case 31
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 32; }
                     else { t.kind = noSym; break; }
                 case 32
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 27; }
                     else { t.kind = noSym; break; }
                 case 33
                     if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= '!' || ch >= '#' && ch <= '[' || ch >= ']' && ch <= 65535) { AddCh(); goto case 27; }
                     else if (ch == '"') { AddCh(); goto case 34; }
                     else if (ch == 92) { AddCh(); goto case 28; }
                     else { t.kind = noSym; break; }
                 case 34
                     { t.kind = 5; break; }
                 case 35
                     { t.kind = 24; break; }
                 case 36
                     { t.kind = 25; break; }
                 case 37
                     { t.kind = 26; break; }
                 case 38
                     { t.kind = 28; break; }
                 case 39
                     { t.kind = 29; break; }
                 case 40
                     { t.kind = 30; break; }
                 case 41
                     { t.kind = 31; break; }
                 case 42
                     { t.kind = 35; break; }
                 case 43
                     { t.kind = 36; break; }
                 case 44
                     { t.kind = 37; break; }
                 case 45
                     { t.kind = 38; break; }
                 case 46
                     if (ch >= '0' && ch <= '7') { AddCh(); goto case 53; }
                     else if (ch >= '8' && ch <= '9') { AddCh(); goto case 9; }
                     else if (ch == 'L' || ch == 'l') { AddCh(); goto case 4; }
                     else if (ch == 'X' || ch == 'x') { AddCh(); goto case 2; }
                     else if (ch == '.') { AddCh(); goto case 10; }
                     else if (ch == 'E' || ch == 'e') { AddCh(); goto case 14; }
                     else if (ch == 'D' || ch == 'F' || ch == 'd' || ch == 'f') { AddCh(); goto case 17; }
                     else { t.kind = 2; break; }
                 case 47
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 47; }
                     else if (ch == 'L' || ch == 'l') { AddCh(); goto case 4; }
                     else if (ch == '.') { AddCh(); goto case 10; }
                     else if (ch == 'E' || ch == 'e') { AddCh(); goto case 14; }
                     else if (ch == 'D' || ch == 'F' || ch == 'd' || ch == 'f') { AddCh(); goto case 17; }
                     else { t.kind = 2; break; }
                 case 48
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 5; }
                     else { t.kind = 27; break; }
                 case 49
                     if (ch >= '0' && ch <= '7') { AddCh(); goto case 50; }
                     else if (ch == 39) { AddCh(); goto case 26; }
                     else { t.kind = noSym; break; }
                 case 50
                     if (ch >= '0' && ch <= '7') { AddCh(); goto case 19; }
                     else if (ch == 39) { AddCh(); goto case 26; }
                     else { t.kind = noSym; break; }
                 case 51
                     if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= '!' || ch >= '#' && ch <= '/' || ch >= '8' && ch <= '[' || ch >= ']' && ch <= 65535) { AddCh(); goto case 27; }
                     else if (ch >= '0' && ch <= '7') { AddCh(); goto case 52; }
                     else if (ch == '"') { AddCh(); goto case 34; }
                     else if (ch == 92) { AddCh(); goto case 28; }
                     else { t.kind = noSym; break; }
                 case 52
                     if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= '!' || ch >= '#' && ch <= '[' || ch >= ']' && ch <= 65535) { AddCh(); goto case 27; }
                     else if (ch == '"') { AddCh(); goto case 34; }
                     else if (ch == 92) { AddCh(); goto case 28; }
                     else { t.kind = noSym; break; }
                 case 53
                     if (ch >= '0' && ch <= '7') { AddCh(); goto case 53; }
                     else if (ch >= '8' && ch <= '9') { AddCh(); goto case 9; }
                     else if (ch == 'L' || ch == 'l') { AddCh(); goto case 4; }
                     else if (ch == '.') { AddCh(); goto case 10; }
                     else if (ch == 'E' || ch == 'e') { AddCh(); goto case 14; }
                     else if (ch == 'D' || ch == 'F' || ch == 'd' || ch == 'f') { AddCh(); goto case 17; }
                     else { t.kind = 2; break; }
                 case 54
                     { t.kind = 40; break; }
                 case 55
                     { t.kind = 72; break; }
                 case 56
                     { t.kind = 74; break; }
                 case 57
                     { t.kind = 75; break; }
                 case 58
                     { t.kind = 76; break; }
                 case 59
                     { t.kind = 77; break; }
                 case 60
                     { t.kind = 78; break; }
                 case 61
                     { t.kind = 79; break; }
                 case 62
                     { t.kind = 80; break; }
                 case 63
                     { t.kind = 81; break; }
                 case 64
                     { t.kind = 82; break; }
                 case 65
                     { t.kind = 83; break; }
                 case 66
                     { t.kind = 84; break; }
                 case 67
                     { t.kind = 85; break; }
                 case 68
                     { t.kind = 86; break; }
                 case 69
                     { t.kind = 90; break; }
                 case 70
                     { t.kind = 91; break; }
                 case 71
                     { t.kind = 94; break; }
                 case 72
                     { t.kind = 95; break; }
                 case 73
                     if (ch == '-') { AddCh(); goto case 37; }
                     else if (ch == '=') { AddCh(); goto case 57; }
                     else { t.kind = 32; break; }
                 case 74
                     if (ch == '+') { AddCh(); goto case 38; }
                     else if (ch == '=') { AddCh(); goto case 56; }
                     else { t.kind = 34; break; }
                 case 75
                     if (ch == '=') { AddCh(); goto case 70; }
                     else { t.kind = 33; break; }
                 case 76
                     if (ch == '=') { AddCh(); goto case 58; }
                     else { t.kind = 42; break; }
                 case 77
                     if (ch == '=') { AddCh(); goto case 69; }
                     else { t.kind = 52; break; }
                 case 78
                     if (ch == '=') { AddCh(); goto case 59; }
                     else { t.kind = 99; break; }
                 case 79
                     if (ch == '=') { AddCh(); goto case 60; }
                     else if (ch == '&') { AddCh(); goto case 68; }
                     else { t.kind = 89; break; }
                 case 80
                     if (ch == '=') { AddCh(); goto case 61; }
                     else if (ch == '|') { AddCh(); goto case 67; }
                     else { t.kind = 87; break; }
                 case 81
                     if (ch == '=') { AddCh(); goto case 62; }
                     else { t.kind = 88; break; }
                 case 82
                     if (ch == '=') { AddCh(); goto case 63; }
                     else { t.kind = 100; break; }
                 case 83
                     if (ch == '<') { AddCh(); goto case 85; }
                     else if (ch == '=') { AddCh(); goto case 71; }
                     else { t.kind = 92; break; }
                 case 84
                     if (ch == '>') { AddCh(); goto case 86; }
                     else if (ch == '=') { AddCh(); goto case 72; }
                     else { t.kind = 93; break; }
                 case 85
                     if (ch == '=') { AddCh(); goto case 64; }
                     else { t.kind = 96; break; }
                 case 86
                     if (ch == '=') { AddCh(); goto case 65; }
                     else if (ch == '>') { AddCh(); goto case 87; }
                     else { t.kind = 97; break; }
                 case 87
                     if (ch == '=') { AddCh(); goto case 66; }
                     else { t.kind = 98; break; }
 
             }
             t.val = new String(tval, 0, tlen);
             return t;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="787" endline="800"><![CDATA[
 
         // get the next token (possibly a token already seen during peeking)
         public Token Scan()
         {
             if (tokens.next == null)
             {
                 return NextToken();
             }
             else
             {
                 pt = tokens = tokens.next;
                 return tokens;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="801" endline="820"><![CDATA[
 
         // peek for the next token, ignore pragmas
         public Token Peek()
         {
             if (pt.next == null)
             {
                 do
                 {
                     pt = pt.next = NextToken();
                 } while (pt.kind > maxT); // skip pragmas
             }
             else
             {
                 do
                 {
                     pt = pt.next;
                 } while (pt.kind > maxT);
             }
             return pt;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="821" endline="823"><![CDATA[
 
         // make sure that peeking starts at the current scan position
         public void ResetPeek() { pt = tokens; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="31" endline="37"><![CDATA[
         {
             if (disposing && (components != null))
             {
                 components.Dispose();
             }
             base.Dispose(disposing);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\DataSourceManager.cs" startline="38" endline="160"><![CDATA[
 
         #region Component Designer generated code
 
         /// <summary> 
         /// Required method for Designer support - do not modify 
         /// the contents of this method with the code editor.
         /// </summary>
         private void InitializeComponent()
         {
         	this.components = new System.ComponentModel.Container();
         	System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ctrlFileExplorer));
         	this.treeMain = new System.Windows.Forms.TreeView();
         	this.imgMain = new System.Windows.Forms.ImageList(this.components);
         	this.toolStrip1 = new System.Windows.Forms.ToolStrip();
         	this.tsbNewFolder = new System.Windows.Forms.ToolStripButton();
         	this.toolStripSeparator1 = new System.Windows.Forms.ToolStripSeparator();
         	this.tsbNewFile = new System.Windows.Forms.ToolStripButton();
         	this.tsbRefresh = new System.Windows.Forms.ToolStripButton();
         	this.tsbAddFav = new System.Windows.Forms.ToolStripButton();
         	this.toolStrip1.SuspendLayout();
         	this.SuspendLayout();
         	// 
         	// treeMain
         	// 
         	this.treeMain.AllowDrop = true;
         	this.treeMain.Dock = System.Windows.Forms.DockStyle.Fill;
         	this.treeMain.ImageIndex = 6;
         	this.treeMain.ImageList = this.imgMain;
         	this.treeMain.Location = new System.Drawing.Point(0, 25);
         	this.treeMain.Name = "treeMain";
         	this.treeMain.SelectedImageIndex = 0;
         	this.treeMain.Size = new System.Drawing.Size(183, 659);
         	this.treeMain.TabIndex = 2;
         	// 
         	// imgMain
         	// 
         	this.imgMain.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject("imgMain.ImageStream")));
         	this.imgMain.TransparentColor = System.Drawing.Color.Transparent;
         	this.imgMain.Images.SetKeyName(0, "RemovableDrive.png");
         	this.imgMain.Images.SetKeyName(1, "CDRom.png");
         	this.imgMain.Images.SetKeyName(2, "Desktop.png");
         	this.imgMain.Images.SetKeyName(3, "Drive.png");
         	this.imgMain.Images.SetKeyName(4, "MyComputer.png");
         	this.imgMain.Images.SetKeyName(5, "NetworkDrive.png");
         	this.imgMain.Images.SetKeyName(6, "Folder.png");
         	this.imgMain.Images.SetKeyName(7, "NewDocumentHS.png");
         	this.imgMain.Images.SetKeyName(8, "AddFav.png");
         	// 
         	// toolStrip1
         	// 
         	this.toolStrip1.GripStyle = System.Windows.Forms.ToolStripGripStyle.Hidden;
         	this.toolStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
         	        	        	this.tsbNewFolder,
         	        	        	this.toolStripSeparator1,
         	        	        	this.tsbNewFile,
         	        	        	this.tsbRefresh,
         	        	        	this.tsbAddFav});
         	this.toolStrip1.Location = new System.Drawing.Point(0, 0);
         	this.toolStrip1.Name = "toolStrip1";
         	this.toolStrip1.Size = new System.Drawing.Size(183, 25);
         	this.toolStrip1.TabIndex = 3;
         	this.toolStrip1.Text = "toolStrip1";
         	// 
         	// tsbNewFolder
         	// 
         	this.tsbNewFolder.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
         	this.tsbNewFolder.Image = ((System.Drawing.Image)(resources.GetObject("tsbNewFolder.Image")));
         	this.tsbNewFolder.ImageTransparentColor = System.Drawing.Color.Magenta;
         	this.tsbNewFolder.Name = "tsbNewFolder";
         	this.tsbNewFolder.Size = new System.Drawing.Size(23, 22);
         	this.tsbNewFolder.Text = "New Folder";
         	this.tsbNewFolder.Click += new System.EventHandler(this.tsbNewFolder_Click);
         	// 
         	// toolStripSeparator1
         	// 
         	this.toolStripSeparator1.Name = "toolStripSeparator1";
         	this.toolStripSeparator1.Size = new System.Drawing.Size(6, 25);
         	// 
         	// tsbNewFile
         	// 
         	this.tsbNewFile.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
         	this.tsbNewFile.Image = ((System.Drawing.Image)(resources.GetObject("tsbNewFile.Image")));
         	this.tsbNewFile.ImageTransparentColor = System.Drawing.Color.Magenta;
         	this.tsbNewFile.Name = "tsbNewFile";
         	this.tsbNewFile.Size = new System.Drawing.Size(23, 22);
         	this.tsbNewFile.Text = "New File";
         	this.tsbNewFile.Click += new System.EventHandler(this.tsbNewFile_Click);
         	// 
         	// tsbRefresh
         	// 
         	this.tsbRefresh.Alignment = System.Windows.Forms.ToolStripItemAlignment.Right;
         	this.tsbRefresh.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
         	this.tsbRefresh.Image = ((System.Drawing.Image)(resources.GetObject("tsbRefresh.Image")));
         	this.tsbRefresh.ImageTransparentColor = System.Drawing.Color.Magenta;
         	this.tsbRefresh.Name = "tsbRefresh";
         	this.tsbRefresh.Size = new System.Drawing.Size(23, 22);
         	this.tsbRefresh.Text = "Refresh";
         	this.tsbRefresh.Click += new System.EventHandler(this.tsbRefresh_Click);
         	// 
         	// tsbAddFav
         	// 
         	this.tsbAddFav.Alignment = System.Windows.Forms.ToolStripItemAlignment.Right;
         	this.tsbAddFav.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
         	this.tsbAddFav.Image = ((System.Drawing.Image)(resources.GetObject("tsbAddFav.Image")));
         	this.tsbAddFav.ImageTransparentColor = System.Drawing.Color.Black;
         	this.tsbAddFav.Name = "tsbAddFav";
         	this.tsbAddFav.Size = new System.Drawing.Size(23, 22);
         	this.tsbAddFav.Text = "Add Favorite Folder";
         	this.tsbAddFav.Click += new System.EventHandler(this.tsbAddFav_Click);
         	// 
         	// ctrlFileExplorer
         	// 
         	this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
         	this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
         	this.ClientSize = new System.Drawing.Size(183, 684);
         	this.Controls.Add(this.treeMain);
         	this.Controls.Add(this.toolStrip1);
         	this.Name = "ctrlFileExplorer";
         	this.toolStrip1.ResumeLayout(false);
         	this.toolStrip1.PerformLayout();
         	this.ResumeLayout(false);
         	this.PerformLayout();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="24" endline="97"><![CDATA[
         private System.ComponentModel.IContainer components = null;
         public ctrlFileExplorer(PeterInterface.IPeterPluginHost host)
         {
             InitializeComponent();
             this.m_Host = host;
             this.TabText = "File Explorer";
             this.m_Expand = ExpandNode;
 
             TreeNode rootDesktop = new TreeNode("Desktop", 2, 2);
             this.treeMain.Nodes.Add(rootDesktop);
             rootDesktop.Name = "Desktop";
             rootDesktop.Nodes.Add("");
             TreeNode myComputer = new TreeNode("My Computer", 4, 4);
             myComputer.Name = "My Computer";
             this.treeMain.Nodes.Add(myComputer);
             foreach (DriveInfo drive in DriveInfo.GetDrives())
             {
                 TreeNode driveNode = new TreeNode(drive.Name);
                 driveNode.Name = drive.Name;
                 switch (drive.DriveType)
                 {
                     case DriveType.CDRom
                         driveNode.SelectedImageIndex = IMGCDRom;
                         driveNode.ImageIndex = IMGCDRom;
                         break;
                     case DriveType.Network
                         driveNode.SelectedImageIndex = IMGNetworkDrive;
                         driveNode.ImageIndex = IMGNetworkDrive;
                         break;
                     case DriveType.Removable
                         driveNode.SelectedImageIndex = IMGRemovableDrive;
                         driveNode.ImageIndex = IMGRemovableDrive;
                         break;
                     default
                         driveNode.SelectedImageIndex = IMGDrive;
                         driveNode.ImageIndex = IMGDrive;
                         break;
                 }
                 driveNode.Nodes.Add(string.Empty);
                 myComputer.Nodes.Add(driveNode);
             }
             foreach (DriveInfo drive in DriveInfo.GetDrives())
             {
                 TreeNode driveNode = new TreeNode(drive.Name);
                 driveNode.Name = drive.Name;
                 switch (drive.DriveType)
                 {
                     case DriveType.CDRom
                         driveNode.SelectedImageIndex = IMGCDRom;
                         driveNode.ImageIndex = IMGCDRom;
                         break;
                     case DriveType.Network
                         driveNode.SelectedImageIndex = IMGNetworkDrive;
                         driveNode.ImageIndex = IMGNetworkDrive;
                         break;
                     case DriveType.Removable
                         driveNode.SelectedImageIndex = IMGRemovableDrive;
                         driveNode.ImageIndex = IMGRemovableDrive;
                         break;
                     default
                         driveNode.SelectedImageIndex = IMGDrive;
                         driveNode.ImageIndex = IMGDrive;
                         break;
                 }
                 driveNode.Nodes.Add(string.Empty);
                 myComputer.Nodes.Add(driveNode);
             }
 
             this.treeMain.AfterLabelEdit += new NodeLabelEditEventHandler(treeMain_AfterLabelEdit);
             this.treeMain.BeforeExpand += new TreeViewCancelEventHandler(treeMain_BeforeExpand);
             this.treeMain.DoubleClick += new EventHandler(treeMain_DoubleClick);
             this.treeMain.MouseDown += new MouseEventHandler(treeMain_MouseDown);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="98" endline="126"><![CDATA[
 
         void treeMain_MouseDown(object sender, MouseEventArgs e)
         {
             try
             {
                 if (e.Button == MouseButtons.Right)
                 {
                     this.treeMain.SelectedNode = this.treeMain.GetNodeAt(e.X, e.Y);
                     if (this.treeMain.SelectedNode.Tag != null)
                     {
                         cShellContextMenu ctxMnu = new cShellContextMenu();
                         FileInfo[] arrFI = new FileInfo[1];
                         arrFI[0] = new FileInfo(this.treeMain.SelectedNode.Tag.ToString());
                         ctxMnu.ShowContextMenu(arrFI, this.PointToScreen(new Point(e.X, e.Y)));
                     }
                     else
                     {
                         cShellContextMenu ctxMnu = new cShellContextMenu();
                         DirectoryInfo[] dir = new DirectoryInfo[1];
                         dir[0] = new DirectoryInfo(GetFolderPath(this.treeMain.SelectedNode));
                         ctxMnu.ShowContextMenu(dir, this.PointToScreen(new Point(e.X, e.Y)));
                     }
                 }
             }
             catch (Exception ex)
             {
                 Console.WriteLine(ex.Message);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="127" endline="147"><![CDATA[
 
         private void treeMain_DoubleClick(object sender, EventArgs e)
         {
             if (this.treeMain.SelectedNode != null)
             {
                 if (this.treeMain.SelectedNode.Tag != null)
                 {
                     if (this.treeMain.SelectedNode.ImageIndex != -1)
                     {
                         this.m_Host.CreateEditor(this.treeMain.SelectedNode.Tag.ToString(),
                             Path.GetFileName(this.treeMain.SelectedNode.Tag.ToString()),
                             Icon.FromHandle(((Bitmap)this.imgMain.Images[this.treeMain.SelectedNode.ImageIndex]).GetHicon()));
                     }
                     else
                     {
                         this.m_Host.CreateEditor(this.treeMain.SelectedNode.Tag.ToString(),
                             Path.GetFileName(this.treeMain.SelectedNode.Tag.ToString()));
                     }
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="148" endline="158"><![CDATA[
 
         private void treeMain_BeforeExpand(object sender, TreeViewCancelEventArgs e)
         {
         	string txt = e.Node.Text;
         	MessageBox.Show(txt, "BeforeExpand ...");
 
             if (e.Node.Text != "My Computer")
             {
                 this.EnumerateDirectory(e.Node);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="159" endline="193"><![CDATA[
 
         private void EnumerateDirectory(TreeNode parentNode)
         {
             DirectoryInfo dirInfo;
             string path = GetFolderPath(parentNode);
             parentNode.Nodes.Clear();
 
             dirInfo = new DirectoryInfo(path);
             DirectoryInfo[] dirs = dirInfo.GetDirectories();
             Array.Sort(dirs, new cDirectorySorter());
             foreach (DirectoryInfo dirI in dirs)
             {
                 TreeNode node = new TreeNode(dirI.Name, 6, 6);
                 node.Name = dirI.Name;
                 node.Nodes.Add(string.Empty);
                 parentNode.Nodes.Add(node);
             }
             foreach (DirectoryInfo dirI in dirs)
             {
                 TreeNode node = new TreeNode(dirI.Name, 6, 6);
                 node.Name = dirI.Name;
                 node.Nodes.Add(string.Empty);
                 parentNode.Nodes.Add(node);
             }
 
             FileInfo[] files = dirInfo.GetFiles();
             Array.Sort(files, new cFileSorter());
             foreach (FileInfo file in files)
             {
                 TreeNode node = new TreeNode(file.Name, 6, 6);
                 node.Name = file.Name;
 
                 Icon fileIcon = this.m_Host.GetFileIcon(file.FullName, false);
                 this.imgMain.Images.Add(fileIcon);
 
                 int imgIndex = imgMain.Images.Count - 1;
                 node.Tag = file.FullName;
                 node.ImageIndex = imgIndex;
                 node.SelectedImageIndex = imgIndex;
                 parentNode.Nodes.Add(node);
             }
             foreach (FileInfo file in files)
             {
                 TreeNode node = new TreeNode(file.Name, 6, 6);
                 node.Name = file.Name;
 
                 Icon fileIcon = this.m_Host.GetFileIcon(file.FullName, false);
                 this.imgMain.Images.Add(fileIcon);
 
                 int imgIndex = imgMain.Images.Count - 1;
                 node.Tag = file.FullName;
                 node.ImageIndex = imgIndex;
                 node.SelectedImageIndex = imgIndex;
                 parentNode.Nodes.Add(node);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="194" endline="215"><![CDATA[
 
         private static string GetFolderPath(TreeNode parentNode)
         {
             string path = "";
             string[] pathSplit = parentNode.FullPath.Split(Path.DirectorySeparatorChar);
             if (pathSplit[0] == "Desktop")
             {
                 path = Environment.GetFolderPath(Environment.SpecialFolder.Desktop) + Path.DirectorySeparatorChar;
             }
             else
             {
                 for (int a = 1; a < pathSplit.Length; a++)
                 {
                     if (pathSplit[a].Trim() != string.Empty)
                     {
                         path += pathSplit[a] + Path.DirectorySeparatorChar;
                     }
                 }
                 for (int a = 1; a < pathSplit.Length; a++)
                 {
                     if (pathSplit[a].Trim() != string.Empty)
                     {
                         path += pathSplit[a] + Path.DirectorySeparatorChar;
                     }
                 }
 
             }
             return path;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="216" endline="235"><![CDATA[
 
         protected override string GetPersistString()
         {
             MemoryStream ms = new MemoryStream();
             XmlTextWriter writer = new XmlTextWriter(ms, Encoding.Unicode);
             writer.WriteStartDocument();
             writer.WriteStartElement("FileExplorer");
             this.WriteNodes(this.treeMain.Nodes, writer);
             writer.WriteEndElement();
             writer.Flush();
 
             ms.Position = 0;
             StreamReader sr = new StreamReader(ms);
             string text = sr.ReadToEnd();
             writer.Close();
             sr.Close();
 
 
             return this.GetType().ToString() + "|" + text;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="236" endline="256"><![CDATA[
 
         private void WriteNodes(TreeNodeCollection nodesCollection,
             XmlTextWriter textWriter)
         {
             for (int i = 0; i < nodesCollection.Count; i++)
             {
                 TreeNode node = nodesCollection[i];
                 if (node.IsExpanded)
                 {
                     textWriter.WriteStartElement("node");
                     textWriter.WriteAttributeString("text", node.Text);
                     if (node.Tag != null) textWriter.WriteAttributeString("tag", node.Tag.ToString());
 
                     if (node.Nodes.Count > 0)
                     {
                         WriteNodes(node.Nodes, textWriter);
                     }
                     textWriter.WriteEndElement();
                 }
             }
             for (int i = 0; i < nodesCollection.Count; i++)
             {
                 TreeNode node = nodesCollection[i];
                 if (node.IsExpanded)
                 {
                     textWriter.WriteStartElement("node");
                     textWriter.WriteAttributeString("text", node.Text);
                     if (node.Tag != null) textWriter.WriteAttributeString("tag", node.Tag.ToString());
 
                     if (node.Nodes.Count > 0)
                     {
                         WriteNodes(node.Nodes, textWriter);
                     }
                     textWriter.WriteEndElement();
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="257" endline="261"><![CDATA[
 
         public void LoadTree(string xml)
         {
             this.m_XML = xml;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="262" endline="271"><![CDATA[
 
         protected override void OnLoad(EventArgs e)
         {
             base.OnLoad(e);
             if (this.m_XML != null && this.m_XML.Trim() != string.Empty)
             {
                 Thread t = new Thread(new ParameterizedThreadStart(this.LoadTreeThread));
                 t.Start(m_XML);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="272" endline="291"><![CDATA[
 
         private void ExpandNode(string nodeName, string parent)
         {
             TreeNode[] nodes = this.treeMain.Nodes.Find(nodeName, true);
             foreach (TreeNode node in nodes)
             {
                 if (parent == string.Empty)
                 {
                     node.Expand();
                 }
                 else
                 {
                     if (node.Parent.Text == parent)
                     {
                         node.Expand();
                         break;
                     }
                 }
             }
             foreach (TreeNode node in nodes)
             {
                 if (parent == string.Empty)
                 {
                     node.Expand();
                 }
                 else
                 {
                     if (node.Parent.Text == parent)
                     {
                         node.Expand();
                         break;
                     }
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="292" endline="309"><![CDATA[
 
         private void LoadTreeThread(object oxml)
         {
             string xml = oxml.ToString();
             XmlDocument xDoc = new XmlDocument();
             xDoc.LoadXml(xml);
             XmlNodeList nodes = xDoc.GetElementsByTagName("node");
             foreach (XmlNode node in nodes)
             {
                 string name = node.Attributes["text"].Value;
                 XmlAttribute att = node.ParentNode.Attributes["text"];
                 string parName = (att == null) ? "" 
                 if (this.m_Expand != null)
                 {
                     this.Invoke(this.m_Expand, new object[] { name, parName });
                 }
             }
             foreach (XmlNode node in nodes)
             {
                 string name = node.Attributes["text"].Value;
                 XmlAttribute att = node.ParentNode.Attributes["text"];
                 string parName = (att == null) ? "" 
                 if (this.m_Expand != null)
                 {
                     this.Invoke(this.m_Expand, new object[] { name, parName });
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="310" endline="315"><![CDATA[
 
         #region IPeterPluginTab Members
 
         public void Save()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="316" endline="319"><![CDATA[
 
         public void SaveAs(string filePath)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="320" endline="323"><![CDATA[
 
         public void Cut()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="324" endline="334"><![CDATA[
 
         public void Copy()
         {
             if (this.treeMain.SelectedNode != null)
             {
                 if (this.treeMain.SelectedNode.Tag != null)
                 {
                     Clipboard.SetText(this.treeMain.SelectedNode.Tag.ToString());
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="335" endline="338"><![CDATA[
 
         public void Paste()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="339" endline="342"><![CDATA[
 
         public void Undo()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="343" endline="346"><![CDATA[
 
         public void Redo()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="347" endline="350"><![CDATA[
 
         public void Print()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="351" endline="354"><![CDATA[
 
         public void Delete()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="355" endline="358"><![CDATA[
 
         public void Duplicate()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="359" endline="362"><![CDATA[
 
         public void SelectAll()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="363" endline="368"><![CDATA[
 
         public bool CloseTab()
         {
             this.Close();
             return true;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="369" endline="372"><![CDATA[
 
         public void MarkAll(System.Text.RegularExpressions.Regex reg)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="373" endline="377"><![CDATA[
 
         public bool FindNext(System.Text.RegularExpressions.Regex reg, bool searchUp)
         {
             return false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="378" endline="381"><![CDATA[
 
         public void ReplaceNext(System.Text.RegularExpressions.Regex reg, string replaceWith, bool searchUp)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="382" endline="385"><![CDATA[
 
         public void ReplaceAll(System.Text.RegularExpressions.Regex reg, string replaceWith)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="386" endline="389"><![CDATA[
 
         public void SelectWord(int line, int offset, int wordLeng)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="390" endline="396"><![CDATA[
 
         public PeterInterface.IPeterPluginHost Host
         {
             get
             {
                 return this.m_Host;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="397" endline="400"><![CDATA[
             set
             {
                 this.m_Host = value;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="401" endline="405"><![CDATA[
         }
 
         public string FileName
         {
             get { return ""; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="406" endline="410"><![CDATA[
         }
 
         public string Selection
         {
             get { return ""; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="411" endline="415"><![CDATA[
         }
 
         public bool AbleToUndo
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="416" endline="420"><![CDATA[
         }
 
         public bool AbleToRedo
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="421" endline="425"><![CDATA[
         }
 
         public bool NeedsSaving
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="426" endline="430"><![CDATA[
         }
 
         public bool AbleToPaste
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="431" endline="435"><![CDATA[
         }
 
         public bool AbleToCut
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="436" endline="440"><![CDATA[
         }
 
         public bool AbleToCopy
         {
             get { return true; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="441" endline="445"><![CDATA[
         }
 
         public bool AbleToSelectAll
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="446" endline="450"><![CDATA[
         }
 
         public bool AbleToSave
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="451" endline="455"><![CDATA[
         }
 
         public bool AbleToDelete
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="456" endline="475"><![CDATA[
         }
 
         #endregion
 
         private void tsbRefresh_Click(object sender, EventArgs e)
         {
             if (this.treeMain.SelectedNode != null)
             {
                 if (this.treeMain.SelectedNode.Tag != null)
                 {
                     this.treeMain.SelectedNode.Parent.Collapse();
                     this.treeMain.SelectedNode.Parent.Expand();
                 }
                 else
                 {
                     this.treeMain.SelectedNode.Collapse();
                     this.treeMain.SelectedNode.Expand();
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="476" endline="481"><![CDATA[
 
         private void tsbNewFolder_Click(object sender, EventArgs e)
         {
             this.m_Folder = true;
             this.AddNode();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="482" endline="487"><![CDATA[
 
         private void tsbNewFile_Click(object sender, EventArgs e)
         {
             this.m_Folder = false;
             this.AddNode();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="488" endline="507"><![CDATA[
 
         private void AddNode()
         {
             this.treeMain.LabelEdit = true;
             if (this.treeMain.SelectedNode != null)
             {
                 TreeNode node = new TreeNode();
                 if (this.treeMain.SelectedNode.Tag != null)
                 {
                     this.treeMain.SelectedNode.Parent.Nodes.Add(node);
                 }
                 else
                 {
                     this.treeMain.SelectedNode.Nodes.Add(node);
                 }
                 node.Text = (this.m_Folder) ? "New Folder" 
                 node.SelectedImageIndex = node.ImageIndex = (this.m_Folder) ? IMGFolder 
                 node.BeginEdit();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="508" endline="563"><![CDATA[
 
         private void treeMain_AfterLabelEdit(object sender, NodeLabelEditEventArgs e)
         {
             try
             {
                 e.Node.EndEdit(true);
                 e.Node.Text = e.Label;
                 this.treeMain.LabelEdit = false;
                 string path = GetFolderPath(e.Node.Parent);
 
                 if (this.m_Folder)
                 {
                     string[] dirs = Directory.GetDirectories(path);
                     foreach (string dir in dirs)
                     {
                         if (dir.ToLower().Equals(e.Node.Text.ToLower()))
                         {
                             this.treeMain.LabelEdit = true;
                             MessageBox.Show(this, "A Folder with that name already Exists. Please choose a different name.",
                                 "Peter", MessageBoxButtons.OK, MessageBoxIcon.Error);
                             e.Node.BeginEdit();
                             return;
                         }
                     }
                     foreach (string dir in dirs)
                     {
                         if (dir.ToLower().Equals(e.Node.Text.ToLower()))
                         {
                             this.treeMain.LabelEdit = true;
                             MessageBox.Show(this, "A Folder with that name already Exists. Please choose a different name.",
                                 "Peter", MessageBoxButtons.OK, MessageBoxIcon.Error);
                             e.Node.BeginEdit();
                             return;
                         }
                     }
 
                     e.Node.SelectedImageIndex = e.Node.ImageIndex = IMGFolder;
                     Directory.CreateDirectory(path + Path.DirectorySeparatorChar + e.Label);
                 }
                 else
                 {
                     string[] files = Directory.GetFiles(path);
                     foreach (string file in files)
                     {
                         if (Path.GetFileName(file).ToLower().Equals(e.Node.Text.ToLower()))
                         {
                             this.treeMain.LabelEdit = true;
                             MessageBox.Show(this, "A File with that name already Exists. Please choose a different name.",
                                 "Peter", MessageBoxButtons.OK, MessageBoxIcon.Error);
                             e.Node.BeginEdit();
                             return;
                         }
                     }
                     foreach (string file in files)
                     {
                         if (Path.GetFileName(file).ToLower().Equals(e.Node.Text.ToLower()))
                         {
                             this.treeMain.LabelEdit = true;
                             MessageBox.Show(this, "A File with that name already Exists. Please choose a different name.",
                                 "Peter", MessageBoxButtons.OK, MessageBoxIcon.Error);
                             e.Node.BeginEdit();
                             return;
                         }
                     }
                     e.Node.Tag = path + e.Label;
                     FileStream f = File.Create(path + e.Label);
                     f.Close();
 
                     this.imgMain.Images.Add(this.m_Host.GetFileIcon(e.Node.Tag.ToString(), false));
                     e.Node.SelectedImageIndex = e.Node.ImageIndex = this.imgMain.Images.Count - 1;
                 }
                 this.treeMain.SelectedNode = e.Node;
             }
             catch (Exception ex)
             {
                 Console.WriteLine(ex.Message);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="564" endline="569"><![CDATA[
         
         void tsbAddFav_Click(object sender, EventArgs e)
         {
         	// Todo
         	MessageBox.Show("Not implemented yet ...", "Add Favorite Directory");
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="31" endline="37"><![CDATA[
         {
             if (disposing && (components != null))
             {
                 components.Dispose();
             }
             base.Dispose(disposing);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlFileExplorer.cs" startline="38" endline="161"><![CDATA[
 
         #region Component Designer generated code
 
         /// <summary> 
         /// Required method for Designer support - do not modify 
         /// the contents of this method with the code editor.
         /// </summary>
         private void InitializeComponent()
         {
             this.components = new System.ComponentModel.Container();
             System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ctrlCodeStructure));
             this.treeMain = new System.Windows.Forms.TreeView();
             this.imgCSS = new System.Windows.Forms.ImageList(this.components);
             this.toolStrip1 = new System.Windows.Forms.ToolStrip();
             this.tsbAlpha = new System.Windows.Forms.ToolStripButton();
             this.toolStripSeparator1 = new System.Windows.Forms.ToolStripSeparator();
             this.tsbExpandAll = new System.Windows.Forms.ToolStripButton();
             this.tsbCollapseAll = new System.Windows.Forms.ToolStripButton();
             this.toolStripSeparator2 = new System.Windows.Forms.ToolStripSeparator();
             this.tsbGotoCode = new System.Windows.Forms.ToolStripButton();
             this.toolStrip1.SuspendLayout();
             this.SuspendLayout();
             // 
             // treeMain
             // 
             this.treeMain.Dock = System.Windows.Forms.DockStyle.Fill;
             this.treeMain.Location = new System.Drawing.Point(0, 25);
             this.treeMain.Name = "treeMain";
             this.treeMain.Size = new System.Drawing.Size(287, 634);
             this.treeMain.TabIndex = 1;
             // 
             // imgCSS
             // 
             this.imgCSS.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject("imgCSS.ImageStream")));
             this.imgCSS.TransparentColor = System.Drawing.Color.Transparent;
             this.imgCSS.Images.SetKeyName(0, "Selector.ico");
             this.imgCSS.Images.SetKeyName(1, "Tag.ico");
             this.imgCSS.Images.SetKeyName(2, "Property.ico");
             this.imgCSS.Images.SetKeyName(3, "Value.ico");
             // 
             // toolStrip1
             // 
             this.toolStrip1.GripStyle = System.Windows.Forms.ToolStripGripStyle.Hidden;
             this.toolStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.tsbAlpha,
             this.toolStripSeparator1,
             this.tsbExpandAll,
             this.tsbCollapseAll,
             this.toolStripSeparator2,
             this.tsbGotoCode});
             this.toolStrip1.Location = new System.Drawing.Point(0, 0);
             this.toolStrip1.Name = "toolStrip1";
             this.toolStrip1.Size = new System.Drawing.Size(287, 25);
             this.toolStrip1.TabIndex = 2;
             this.toolStrip1.Text = "toolStrip1";
             // 
             // tsbAlpha
             // 
             this.tsbAlpha.Checked = true;
             this.tsbAlpha.CheckOnClick = true;
             this.tsbAlpha.CheckState = System.Windows.Forms.CheckState.Checked;
             this.tsbAlpha.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
             this.tsbAlpha.Image = ((System.Drawing.Image)(resources.GetObject("tsbAlpha.Image")));
             this.tsbAlpha.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.tsbAlpha.Name = "tsbAlpha";
             this.tsbAlpha.Size = new System.Drawing.Size(23, 22);
             this.tsbAlpha.Text = "Alphabetize";
             // 
             // toolStripSeparator1
             // 
             this.toolStripSeparator1.Name = "toolStripSeparator1";
             this.toolStripSeparator1.Size = new System.Drawing.Size(6, 25);
             // 
             // tsbExpandAll
             // 
             this.tsbExpandAll.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
             this.tsbExpandAll.Image = ((System.Drawing.Image)(resources.GetObject("tsbExpandAll.Image")));
             this.tsbExpandAll.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.tsbExpandAll.Name = "tsbExpandAll";
             this.tsbExpandAll.Size = new System.Drawing.Size(23, 22);
             this.tsbExpandAll.Text = "Expand All";
             this.tsbExpandAll.Click += new System.EventHandler(this.tsbExpandAll_Click);
             // 
             // tsbCollapseAll
             // 
             this.tsbCollapseAll.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
             this.tsbCollapseAll.Image = ((System.Drawing.Image)(resources.GetObject("tsbCollapseAll.Image")));
             this.tsbCollapseAll.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.tsbCollapseAll.Name = "tsbCollapseAll";
             this.tsbCollapseAll.Size = new System.Drawing.Size(23, 22);
             this.tsbCollapseAll.Text = "Collapse All";
             this.tsbCollapseAll.Click += new System.EventHandler(this.tsbCollapseAll_Click);
             // 
             // toolStripSeparator2
             // 
             this.toolStripSeparator2.Name = "toolStripSeparator2";
             this.toolStripSeparator2.Size = new System.Drawing.Size(6, 25);
             // 
             // tsbGotoCode
             // 
             this.tsbGotoCode.Checked = true;
             this.tsbGotoCode.CheckOnClick = true;
             this.tsbGotoCode.CheckState = System.Windows.Forms.CheckState.Checked;
             this.tsbGotoCode.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
             this.tsbGotoCode.Image = ((System.Drawing.Image)(resources.GetObject("tsbGotoCode.Image")));
             this.tsbGotoCode.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.tsbGotoCode.Name = "tsbGotoCode";
             this.tsbGotoCode.Size = new System.Drawing.Size(23, 22);
             this.tsbGotoCode.Text = "Jump to Source on Click";
             // 
             // ctrlCodeStructure
             // 
             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.ClientSize = new System.Drawing.Size(287, 659);
             this.Controls.Add(this.treeMain);
             this.Controls.Add(this.toolStrip1);
             this.Name = "ctrlCodeStructure";
             this.toolStrip1.ResumeLayout(false);
             this.toolStrip1.PerformLayout();
             this.ResumeLayout(false);
             this.PerformLayout();
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="24" endline="38"><![CDATA[
         private System.ComponentModel.IContainer components = null;
         public ctrlCodeStructure()
         {
             InitializeComponent();
             this.m_CanScroll = true;
             this.TabText = "Code Structure";
             this.treeMain.AfterSelect += new TreeViewEventHandler(treeMain_AfterSelect);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="39" endline="47"><![CDATA[
 
         #region -= Helpers =-
 
         /// <summary>
         /// Gets or Sets if we are able to scroll to the selected item...
         /// </summary>
         public bool CanScroll
         {
             get { return this.m_CanScroll; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="48" endline="49"><![CDATA[
 
             set { this.m_CanScroll = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="50" endline="93"><![CDATA[
         }
 
         /// <summary>
         /// After an item is selected, scroll to it...
         /// </summary>
         /// <param name="sender">TreeView</param>
         /// <param name="e">TreeViewEventArgs</param>
         void treeMain_AfterSelect(object sender, TreeViewEventArgs e)
         {
             if (this.tsbGotoCode.Checked)
             {
                 if (this.m_CanScroll)
                 {
                     if (e.Node.Parent != null)
                     {
                         if (e.Node.Tag != null)
                         {
                             int off = Convert.ToInt32(e.Node.Tag.ToString());
                             int index = e.Node.Text.IndexOf("
                             int temp = e.Node.Text.IndexOf("(");
                             if ((temp < index && temp > 0) || index == -1)
                             {
                                 index = temp;
                             }
                             temp = e.Node.Text.IndexOf(" ");
                             if ((temp < index && temp > 0) || index == -1)
                             {
                                 index = temp;
                             }
                             int pos;
                             if (index < 0)
                             {
                                 pos = off + e.Node.Text.Length;
                             }
                             else
                             {
                                 pos = off + index;
                             }
                             this.ScrollToOffset(off, pos);
                         }
                     }
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="94" endline="120"><![CDATA[
 
         /// <summary>
         /// Occurs when the active content is changed...
         /// </summary>
         /// <param name="content">New Content</param>
         public void ActiveContentChanged (IDockContent content)
         {
             DockContent d = (DockContent)content;
             TextEditorControl edit = null;
             foreach (Control c in d.Controls)
             {
                 if (c.GetType().ToString().Equals(typeof(TextEditorControl).ToString()))
                 {
                     edit = (TextEditorControl)c;
                     break;
                 }
             }
             foreach (Control c in d.Controls)
             {
                 if (c.GetType().ToString().Equals(typeof(TextEditorControl).ToString()))
                 {
                     edit = (TextEditorControl)c;
                     break;
                 }
             }
             if (edit != this.m_Editor)
             {
                 this.m_Editor = edit;
                 this.ParseCode();
             }
             if (this.ItemCount == 0 && this.m_Editor != null)
             {
                 this.ParseCode();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="121" endline="135"><![CDATA[
 
         /// <summary>
         /// Scrolls the active editor to the given offset...
         /// </summary>
         /// <param name="offset">offset to start at</param>
         /// <param name="pos">offset to end at</param>
         public void ScrollToOffset (int offset, int pos)
         {
             int line = this.m_Editor.Document.GetLineNumberForOffset(offset);
             this.m_Editor.ActiveTextAreaControl.Caret.Position = this.m_Editor.Document.OffsetToPosition(offset);
             this.m_Editor.ActiveTextAreaControl.SelectionManager.SetSelection(
                 this.m_Editor.Document.OffsetToPosition(offset), this.m_Editor.Document.OffsetToPosition(pos));
             this.m_Editor.ActiveTextAreaControl.CenterViewOn(line, 0);
             this.m_Editor.ActiveTextAreaControl.TextArea.Focus();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="136" endline="143"><![CDATA[
 
         /// <summary>
         /// Clears the list view's items and groups...
         /// </summary>
         public void Clear()
         {
             this.treeMain.Nodes.Clear();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="144" endline="152"><![CDATA[
 
         /// <summary>
         /// Adds a node to the tree...
         /// </summary>
         /// <param name="node">Node to Add</param>
         public void AddNode(TreeNode node)
         {
             this.treeMain.Nodes.Add(node);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="153" endline="159"><![CDATA[
 
         /// <summary>
         /// Gets the number of Items in the TreeView...
         /// </summary>
         public int ItemCount
         {
             get { return this.treeMain.Nodes.Count; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="160" endline="169"><![CDATA[
         }
 
         /// <summary>
         /// Gets the Nodes for the tree...
         /// </summary>
         /// <returns>TreeNodeCollection</returns>
         public TreeNodeCollection TreeNodes()
         {
             return this.treeMain.Nodes;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="170" endline="186"><![CDATA[
 
         /// <summary>
         /// Sets the image list of the tree...
         /// </summary>
         /// <param name="fileExt">Image list name to set...</param>
         public void SetImageList(string fileExt)
         {
             switch (fileExt)
             {
                 case ".css"
                     this.treeMain.ImageList = imgCSS;
                     break;
                 default
                     this.treeMain.ImageList = null;
                     break;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="187" endline="194"><![CDATA[
 
         #endregion
 
         #region IPeterPluginTab Members
 
         public void Save()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="195" endline="198"><![CDATA[
 
         public void SaveAs(string filePath)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="199" endline="202"><![CDATA[
 
         public void Cut()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="203" endline="206"><![CDATA[
 
         public void Copy()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="207" endline="210"><![CDATA[
 
         public void Paste()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="211" endline="214"><![CDATA[
 
         public void Undo()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="215" endline="218"><![CDATA[
 
         public void Redo()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="219" endline="222"><![CDATA[
 
         public void Delete()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="223" endline="226"><![CDATA[
 
         public void Duplicate()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="227" endline="230"><![CDATA[
 
         public void Print()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="231" endline="234"><![CDATA[
 
         public void SelectAll()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="235" endline="240"><![CDATA[
 
         public bool CloseTab()
         {
             this.Close();
             return true;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="241" endline="244"><![CDATA[
 
         public void MarkAll(System.Text.RegularExpressions.Regex reg)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="245" endline="249"><![CDATA[
 
         public bool FindNext(System.Text.RegularExpressions.Regex reg, bool searchUp)
         {
             return false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="250" endline="253"><![CDATA[
 
         public void ReplaceNext(System.Text.RegularExpressions.Regex reg, string replaceWith, bool searchUp)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="254" endline="257"><![CDATA[
 
         public void ReplaceAll(System.Text.RegularExpressions.Regex reg, string replaceWith)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="258" endline="261"><![CDATA[
 
         public void SelectWord(int line, int offset, int wordLeng)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="262" endline="265"><![CDATA[
 
         public IPeterPluginHost Host
         {
             get { return this.m_Host; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="266" endline="267"><![CDATA[
 
             set { this.m_Host = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="268" endline="272"><![CDATA[
         }
 
         public string FileName
         {
             get { return ""; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="273" endline="277"><![CDATA[
         }
 
         public string Selection
         {
             get { return ""; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="278" endline="282"><![CDATA[
         }
 
         public bool AbleToUndo
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="283" endline="287"><![CDATA[
         }
 
         public bool AbleToRedo
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="288" endline="292"><![CDATA[
         }
 
         public bool NeedsSaving
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="293" endline="297"><![CDATA[
         }
 
         public bool AbleToPaste
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="298" endline="302"><![CDATA[
         }
 
         public bool AbleToCut
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="303" endline="307"><![CDATA[
         }
 
         public bool AbleToCopy
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="308" endline="312"><![CDATA[
         }
 
         public bool AbleToSelectAll
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="313" endline="317"><![CDATA[
         }
 
         public bool AbleToSave
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="318" endline="322"><![CDATA[
         }
 
         public bool AbleToDelete
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="323" endline="335"><![CDATA[
         }
 
         #endregion
 
         #region -= Tool Bar =-
 
         private void tsbExpandAll_Click(object sender, EventArgs e)
         {
             for (int a = 0; a < this.treeMain.Nodes.Count; a++)
             {
                 this.treeMain.Nodes[a].ExpandAll();
             }
             for (int a = 0; a < this.treeMain.Nodes.Count; a++)
             {
                 this.treeMain.Nodes[a].ExpandAll();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="336" endline="343"><![CDATA[
 
         private void tsbCollapseAll_Click(object sender, EventArgs e)
         {
             for (int a = 0; a < this.treeMain.Nodes.Count; a++)
             {
                 this.treeMain.Nodes[a].Collapse();
             }
             for (int a = 0; a < this.treeMain.Nodes.Count; a++)
             {
                 this.treeMain.Nodes[a].Collapse();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="344" endline="393"><![CDATA[
 
         #endregion
 
         private void ParseCode ()
         {
             this.Clear();
 
             if (this.m_Editor != null)
             {
                 if (!string.IsNullOrEmpty(this.m_Editor.FileName))
                 {
                     string ext = Path.GetExtension(this.m_Editor.FileName).ToLower();
                     this.SetImageList(ext);
                     this.m_CanScroll = true;
 
                     switch (ext)
                     {
                         /*.manifest;.config;.addin;.wxs;.wxi;.wxl;.proj;
                          * .ilproj;.booproj;.build;.xfrm;.targets;
                          * .xpt;.xft;.map;.wsdl;.disco*/
                         case ".xml"
                         case ".xshd"
                         case ".csproj"
                         case ".vbproj"
                         case ".xaml"
                         case ".xsl"
                         case ".xslt"
                         case ".xsd"
                         case ".jpx"
                             this.m_CanScroll = false;
                             XmlParser.ParseToTree(this.m_Editor.FileName, this.TreeNodes());
                             break;
                         case ".cs"
                             CSParser.CSParser.ParseToTree(this.m_Editor.FileName, this.TreeNodes());
                             break;
                         case ".css"
                             this.m_CanScroll = false;
                             CSSParser.CSSParser.ParseToTree(this.m_Editor.FileName, this.TreeNodes());
                             break;
                         case ".java"
                             JavaParser.JavaParser.ParseToTree(this.m_Editor.FileName, this.TreeNodes());
                             break;
                         case ".c"
                         case ".h"
                             CParser.CParser.ParseToTree(this.m_Editor.FileName, this.TreeNodes());
                             break;
                     }
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="33" endline="51"><![CDATA[
         {
             cShell32.SHFILEINFO shfi = new cShell32.SHFILEINFO();
             uint flags = cShell32.SHGFI_ICON | cShell32.SHGFI_USEFILEATTRIBUTES;
 
             if (linkOverlay) flags += cShell32.SHGFI_LINKOVERLAY;
             flags += cShell32.SHGFI_SMALLICON; // include the small icon flag
 
             cShell32.SHGetFileInfo(name,
                                   cShell32.FILE_ATTRIBUTE_NORMAL,
                                   ref shfi,
                                   (uint)System.Runtime.InteropServices.Marshal.SizeOf(shfi),
                                   flags);
 
             // Copy (clone) the returned icon to a new object, thus allowing us 
             // to call DestroyIcon immediately
             Icon icon = (Icon)Icon.FromHandle(shfi.hIcon).Clone();
             User32.DestroyIcon(shfi.hIcon); // Cleanup
             return icon;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="52" endline="96"><![CDATA[
 
         ///<summary>Transforms an instance of ContentAlignment into a new instance of StringFormat</summary>
         ///<param name="textalign">Instance of ContentAlignment</param>
         ///<returns>StringFormat instance configured based on <paramref name="textalign" /></returns>
         public static StringFormat StringFormatAlignment (ContentAlignment textalign)
         {
             StringFormat sf = new StringFormat();
             switch (textalign)
             {
                 case ContentAlignment.TopLeft
                 case ContentAlignment.TopCenter
                 case ContentAlignment.TopRight
                     sf.LineAlignment = StringAlignment.Near;
                     break;
                 case ContentAlignment.MiddleLeft
                 case ContentAlignment.MiddleCenter
                 case ContentAlignment.MiddleRight
                     sf.LineAlignment = StringAlignment.Center;
                     break;
                 case ContentAlignment.BottomLeft
                 case ContentAlignment.BottomCenter
                 case ContentAlignment.BottomRight
                     sf.LineAlignment = StringAlignment.Far;
                     break;
             }
             switch (textalign)
             {
                 case ContentAlignment.TopLeft
                 case ContentAlignment.MiddleLeft
                 case ContentAlignment.BottomLeft
                     sf.Alignment = StringAlignment.Near;
                     break;
                 case ContentAlignment.TopCenter
                 case ContentAlignment.MiddleCenter
                 case ContentAlignment.BottomCenter
                     sf.Alignment = StringAlignment.Center;
                     break;
                 case ContentAlignment.TopRight
                 case ContentAlignment.MiddleRight
                 case ContentAlignment.BottomRight
                     sf.Alignment = StringAlignment.Far;
                     break;
             }
             return sf;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="97" endline="147"><![CDATA[
 
         /// <summary>
         /// Struct for the configuration settings for a editor...
         /// </summary>
         public struct EditorConfig
         {
             public bool ShowEOL;
             public bool ShowInvalidLines;
             public bool ShowSpaces;
             public bool ShowTabs;
             public bool ShowMatchingBracket;
             public bool ShowLineNumbers;
             public bool ShowVRuler;
             public bool ShowHRuler;
             public bool EnableCodeFolding;
             public bool ConvertTabs;
             public bool UseAntiAlias;
             public bool AllowCaretBeyondEOL;
             public bool HighlightCurrentLine;
             public bool AutoInsertBracket;
             public int TabIndent;
             public int VerticalRulerCol;
             public string IndentStyle;
             public string BracketMatchingStyle;
             public Font EditorFont;
         };
     }
 
     /*
         FileTypeRegistrar fileReg = new FileTypeRegistrar();
         { 
             fileReg.FullPath = Path_To_Executable; 
             fileReg.FileExtension = Extension_To_Register; 
             fileReg.ContentType = "application/" + Your_Description; 
             fileReg.IconIndex = Icon_Index_In_Application; 
             fileReg.IconPath = Path_To_Executable; 
             fileReg.ProperName = Name_Of_Executable; 
             fileReg.CreateType(); 
         } 
      */
 
     ///<summary>This class provides properties and helper methods to register a content type to an action in the registry.</summary>
     public class FileTypeRegistrar
     {
 
         #region "Properties & Property Variables"
         private string _ProperName;
         ///<summary>Proper name for file</summary>
         public string ProperName
         {
             get { return _ProperName; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="148" endline="148"><![CDATA[
             set { _ProperName = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="149" endline="155"><![CDATA[
         }
 
         private string _ContentType;
         ///<summary>Content type of file</summary>
         public string ContentType
         {
             get { return _ContentType; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="156" endline="156"><![CDATA[
             set { _ContentType = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="157" endline="163"><![CDATA[
         }
 
         private string _FullPath;
         ///<summary>Full path to file</summary>
         public string FullPath
         {
             get { return _FullPath; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="164" endline="164"><![CDATA[
             set { _FullPath = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="165" endline="171"><![CDATA[
         }
 
         private string _FileExtension;
         ///<summary>Extension for file</summary>
         public string FileExtension
         {
             get { return _FileExtension; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="172" endline="172"><![CDATA[
             set { _FileExtension = value.Replace(".", ""); }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="173" endline="179"><![CDATA[
         }
 
         private string _IconPath;
         ///<summary>Path to icon for content type</summary>
         public string IconPath
         {
             get { return _IconPath; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="180" endline="180"><![CDATA[
             set { _IconPath = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="181" endline="187"><![CDATA[
         }
 
         private int _IconIndex;
         ///<summary>Index of icon for content type</summary>
         public int IconIndex
         {
             get { return _IconIndex; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="188" endline="188"><![CDATA[
             set { _IconIndex = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="189" endline="220"><![CDATA[
         }
         #endregion
 
         #region "Public Methods"
         ///<summary>Create type assignment in <see cref="Microsoft.Win32.Registry">Registry</see> for FullPath</summary>
         public void CreateType()
         {
             string fileName = Path.GetFileNameWithoutExtension(FullPath);
             string Ext = "." + FileExtension.ToLower();
             RegistryKey extKey = Registry.ClassesRoot.CreateSubKey(Ext);
 
             extKey.SetValue("", fileName);
             extKey.SetValue("Content Type", ContentType);
             extKey.Close();
 
             RegistryKey mainKey = Registry.ClassesRoot.CreateSubKey(fileName);
             RegistryKey defIconKey = mainKey.CreateSubKey("DefaultIcon");
 
             defIconKey.SetValue("", IconPath + ", " + IconIndex);
             defIconKey.Close();
 
             RegistryKey shellKey = mainKey.CreateSubKey("shell");
             RegistryKey OpenKey = shellKey.CreateSubKey("Open");
             RegistryKey cmdKey = OpenKey.CreateSubKey("command");
 
             cmdKey.SetValue("", "\"" + FullPath + " %1\"");
             cmdKey.Close();
             OpenKey.Close();
             shellKey.Close();
             mainKey.Close();
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="221" endline="231"><![CDATA[
 
         ///<summary>Deletes the extension and filename from the <see cref="T
         public void DeleteType()
         {
             string fileName = Path.GetFileNameWithoutExtension(FullPath);
             string Ext = "." + FileExtension.ToLower();
 
             Registry.ClassesRoot.DeleteSubKey(Ext);
             Registry.ClassesRoot.DeleteSubKey(fileName);
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="39" endline="58"><![CDATA[
         public Buffer(Stream s, bool isUserStream)
         {
             stream = s; this.isUserStream = isUserStream;
 
             if (stream.CanSeek)
             {
                 fileLen = (int)stream.Length;
                 bufLen = Math.Min(fileLen, MAX_BUFFER_LENGTH);
                 bufStart = Int32.MaxValue; // nothing in the buffer so far
             }
             else
             {
                 fileLen = bufLen = bufStart = 0;
             }
 
             buf = new byte[(bufLen > 0) ? bufLen 
             if (fileLen > 0) Pos = 0; // setup buffer to position 0 (start)
             else bufPos = 0; // index 0 is already after the file, thus Pos = 0 is invalid
             if (bufLen == fileLen && stream.CanSeek) Close();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="59" endline="71"><![CDATA[
 
         protected Buffer(Buffer b)
         { // called in UTF8Buffer constructor
             buf = b.buf;
             bufStart = b.bufStart;
             bufLen = b.bufLen;
             fileLen = b.fileLen;
             bufPos = b.bufPos;
             stream = b.stream;
             // keep destructor from closing the stream
             b.stream = null;
             isUserStream = b.isUserStream;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="72" endline="73"><![CDATA[
 
         ~Buffer() { Close(); }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="74" endline="82"><![CDATA[
 
         protected void Close()
         {
             if (!isUserStream && stream != null)
             {
                 stream.Close();
                 stream = null;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="83" endline="103"><![CDATA[
 
         public virtual int Read()
         {
             if (bufPos < bufLen)
             {
                 return buf[bufPos++];
             }
             else if (Pos < fileLen)
             {
                 Pos = Pos; // shift buffer start to Pos
                 return buf[bufPos++];
             }
             else if (stream != null && !stream.CanSeek && ReadNextStreamChunk() > 0)
             {
                 return buf[bufPos++];
             }
             else
             {
                 return EOF;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="104" endline="111"><![CDATA[
 
         public int Peek()
         {
             int curPos = Pos;
             int ch = Read();
             Pos = curPos;
             return ch;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="112" endline="122"><![CDATA[
 
         public string GetString(int beg, int end)
         {
             int len = end - beg;
             char[] buf = new char[len];
             int oldPos = Pos;
             Pos = beg;
             for (int i = 0; i < len; i++) buf[i] = (char)Read();
             Pos = oldPos;
             return new String(buf);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="123" endline="126"><![CDATA[
 
         public int Pos
         {
             get { return bufPos + bufStart; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="127" endline="158"><![CDATA[
             set
             {
                 if (value >= fileLen && stream != null && !stream.CanSeek)
                 {
                     // Wanted position is after buffer and the stream
                     // is not seek-able e.g. network or console,
                     // thus we have to read the stream manually till
                     // the wanted position is in sight.
                     while (value >= fileLen && ReadNextStreamChunk() > 0) ;
                 }
 
                 if (value < 0 || value > fileLen)
                 {
                     throw new FatalError("buffer out of bounds access, position
                 }
 
                 if (value >= bufStart && value < bufStart + bufLen)
                 { // already in buffer
                     bufPos = value - bufStart;
                 }
                 else if (stream != null)
                 { // must be swapped in
                     stream.Seek(value, SeekOrigin.Begin);
                     bufLen = stream.Read(buf, 0, buf.Length);
                     bufStart = value; bufPos = 0;
                 }
                 else
                 {
                     // set the position to the end of the file, Pos will return fileLen.
                     bufPos = fileLen - bufStart;
                 }
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="159" endline="186"><![CDATA[
         }
 
         // Read the next chunk of bytes from the stream, increases the buffer
         // if needed and updates the fields fileLen and bufLen.
         // Returns the number of bytes read.
         private int ReadNextStreamChunk()
         {
             int free = buf.Length - bufLen;
             if (free == 0)
             {
                 // in the case of a growing input stream
                 // we can neither seek in the stream, nor can we
                 // foresee the maximum length, thus we must adapt
                 // the buffer size on demand.
                 byte[] newBuf = new byte[bufLen * 2];
                 Array.Copy(buf, newBuf, bufLen);
                 buf = newBuf;
                 free = bufLen;
             }
             int read = stream.Read(buf, bufLen, free);
             if (read > 0)
             {
                 fileLen = bufLen = (bufLen + read);
                 return read;
             }
             // end of stream reached
             return 0;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="187" endline="194"><![CDATA[
     }
 
     //-----------------------------------------------------------------------------------
     // UTF8Buffer
     //-----------------------------------------------------------------------------------
     public class UTF8Buffer 
     {
         public UTF8Buffer(Buffer b) 
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="195" endline="234"><![CDATA[
 
         public override int Read()
         {
             int ch;
             do
             {
                 ch = base.Read();
                 // until we find a uft8 start (0xxxxxxx or 11xxxxxx)
             } while ((ch >= 128) && ((ch & 0xC0) != 0xC0) && (ch != EOF));
             if (ch < 128 || ch == EOF)
             {
                 // nothing to do, first 127 chars are the same in ascii and utf8
                 // 0xxxxxxx or end of file character
             }
             else if ((ch & 0xF0) == 0xF0)
             {
                 // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
                 int c1 = ch & 0x07; ch = base.Read();
                 int c2 = ch & 0x3F; ch = base.Read();
                 int c3 = ch & 0x3F; ch = base.Read();
                 int c4 = ch & 0x3F;
                 ch = (((((c1 << 6) | c2) << 6) | c3) << 6) | c4;
             }
             else if ((ch & 0xE0) == 0xE0)
             {
                 // 1110xxxx 10xxxxxx 10xxxxxx
                 int c1 = ch & 0x0F; ch = base.Read();
                 int c2 = ch & 0x3F; ch = base.Read();
                 int c3 = ch & 0x3F;
                 ch = (((c1 << 6) | c2) << 6) | c3;
             }
             else if ((ch & 0xC0) == 0xC0)
             {
                 // 110xxxxx 10xxxxxx
                 int c1 = ch & 0x1F; ch = base.Read();
                 int c2 = ch & 0x3F;
                 ch = (c1 << 6) | c2;
             }
             return ch;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="235" endline="276"><![CDATA[
     }
 
     //-----------------------------------------------------------------------------------
     // Scanner
     //-----------------------------------------------------------------------------------
     public class Scanner
     {
         const char EOL = '\n';
         const int eofSym = 0; /* pdt */
         const int maxT = 80;
         const int noSym = 80;
 
 
         public Buffer buffer; // scanner buffer
 
         Token t;          // current token
         int ch;           // current input character
         int pos;          // byte position of current character
         int col;          // column number of current character
         int line;         // line number of current character
         int oldEols;      // EOLs that appeared in a comment;
         Dictionary<int, int> start; // maps first token character to start state
 
         Token tokens;     // list of tokens already peeked (first token is a dummy)
         Token pt;         // current peek token
 
         char[] tval = new char[128]; // text of current token
         int tlen;         // length of current token
 
         public Scanner(string fileName)
         {
             try
             {
                 Stream stream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
                 buffer = new Buffer(stream, false);
                 Init();
             }
             catch (IOException)
             {
                 throw new FatalError("Cannot open file " + fileName);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="261" endline="282"><![CDATA[
         char[] tval = new char[128]; // text of current token
         int tlen;         // length of current token
 
         public Scanner(string fileName)
         {
             try
             {
                 Stream stream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
                 buffer = new Buffer(stream, false);
                 Init();
             }
             catch (IOException)
             {
                 throw new FatalError("Cannot open file " + fileName);
             }
         }
 
         public Scanner(Stream s)
         {
             buffer = new Buffer(s, true);
             Init();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="283" endline="344"><![CDATA[
 
         void Init()
         {
             pos = -1; line = 1; col = 0;
             oldEols = 0;
             NextCh();
             if (ch == 0xEF)
             { // check optional byte order mark for UTF-8
                 NextCh(); int ch1 = ch;
                 NextCh(); int ch2 = ch;
                 if (ch1 != 0xBB || ch2 != 0xBF)
                 {
                     throw new FatalError(String.Format("illegal byte order mark
                 }
                 buffer = new UTF8Buffer(buffer); col = 0;
                 NextCh();
             }
             start = new Dictionary<int, int>(128);
             for (int i = 65; i <= 90; ++i) start[i] = 1;
             for (int i = 95; i <= 95; ++i) start[i] = 1;
             for (int i = 97; i <= 122; ++i) start[i] = 1;
             for (int i = 170; i <= 170; ++i) start[i] = 1;
             for (int i = 181; i <= 181; ++i) start[i] = 1;
             for (int i = 186; i <= 186; ++i) start[i] = 1;
             for (int i = 192; i <= 214; ++i) start[i] = 1;
             for (int i = 216; i <= 246; ++i) start[i] = 1;
             for (int i = 248; i <= 255; ++i) start[i] = 1;
             for (int i = 49; i <= 57; ++i) start[i] = 163;
             start[92] = 15;
             start[64] = 164;
             start[48] = 165;
             start[46] = 166;
             start[39] = 44;
             start[34] = 205;
             start[38] = 167;
             start[61] = 168;
             start[58] = 169;
             start[44] = 79;
             start[45] = 170;
             start[47] = 206;
             start[62] = 207;
             start[43] = 171;
             start[123] = 86;
             start[91] = 87;
             start[40] = 88;
             start[60] = 172;
             start[37] = 91;
             start[33] = 173;
             start[124] = 94;
             start[63] = 97;
             start[125] = 98;
             start[93] = 99;
             start[41] = 100;
             start[59] = 101;
             start[126] = 102;
             start[42] = 174;
             start[94] = 104;
             start[35] = 208;
             start[Buffer.EOF] = -1;
 
             pt = tokens = new Token();  // first token is a dummy
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="345" endline="359"><![CDATA[
 
         void NextCh()
         {
             if (oldEols > 0) { ch = EOL; oldEols--; }
             else
             {
                 pos = buffer.Pos;
                 ch = buffer.Read(); col++;
                 // replace isolated '\r' by '\n' in order to make
                 // eol handling uniform across Windows, Unix and Mac
                 if (ch == '\r' && buffer.Peek() != '\n') ch = EOL;
                 if (ch == EOL) { line++; col = 0; }
             }
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="360" endline="371"><![CDATA[
 
         void AddCh()
         {
             if (tlen >= tval.Length)
             {
                 char[] newBuf = new char[2 * tval.Length];
                 Array.Copy(tval, 0, newBuf, 0, tval.Length);
                 tval = newBuf;
             }
             tval[tlen++] = (char)ch;
             NextCh();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="372" endline="399"><![CDATA[
 
 
 
         bool Comment0()
         {
             int level = 1, pos0 = pos, line0 = line, col0 = col;
             NextCh();
             if (ch == '/')
             {
                 NextCh();
                 for (; ; )
                 {
                     if (ch == 10)
                     {
                         level--;
                         if (level == 0) { oldEols = line - line0; NextCh(); return true; }
                         NextCh();
                     }
                     else if (ch == Buffer.EOF) return false;
                     else NextCh();
                 }
             }
             else
             {
                 buffer.Pos = pos0; NextCh(); line = line0; col = col0;
             }
             return false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="400" endline="429"><![CDATA[
 
         bool Comment1()
         {
             int level = 1, pos0 = pos, line0 = line, col0 = col;
             NextCh();
             if (ch == '*')
             {
                 NextCh();
                 for (; ; )
                 {
                     if (ch == '*')
                     {
                         NextCh();
                         if (ch == '/')
                         {
                             level--;
                             if (level == 0) { oldEols = line - line0; NextCh(); return true; }
                             NextCh();
                         }
                     }
                     else if (ch == Buffer.EOF) return false;
                     else NextCh();
                 }
             }
             else
             {
                 buffer.Pos = pos0; NextCh(); line = line0; col = col0;
             }
             return false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="430" endline="472"><![CDATA[
 
 
         void CheckLiteral()
         {
             switch (t.val)
             {
                 case "auto"
                 case "break"
                 case "case"
                 case "catch"
                 case "char"
                 case "const"
                 case "continue"
                 case "default"
                 case "do"
                 case "double"
                 case "else"
                 case "enum"
                 case "extern"
                 case "float"
                 case "for"
                 case "goto"
                 case "if"
                 case "int"
                 case "long"
                 case "register"
                 case "return"
                 case "short"
                 case "signed"
                 case "sizeof"
                 case "static"
                 case "struct"
                 case "switch"
                 case "typedef"
                 case "union"
                 case "unsinged"
                 case "void"
                 case "volatile"
                 case "while"
                 case "unsigned"
                 default
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="473" endline="1182"><![CDATA[
 
         Token NextToken()
         {
             while (ch == ' ' ||
                 ch >= 9 && ch <= 10 || ch == 13
             ) NextCh();
             while (ch == ' ' ||
                 ch >= 9 && ch <= 10 || ch == 13
             ) NextCh();
             if (ch == '/' && Comment0() || ch == '/' && Comment1()) return NextToken();
             int apx = 0;
             t = new Token();
             t.pos = pos; t.col = col; t.line = line;
             int state;
             try { state = start[ch]; }
             catch (KeyNotFoundException) { state = 0; }
             tlen = 0; AddCh();
 
             switch (state)
             {
                 case -1
                 case 0
                 case 1
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'Z' || ch == '_' || ch >= 'a' && ch <= 'z' || ch == 160 || ch == 170 || ch == 181 || ch == 186 || ch >= 192 && ch <= 214 || ch >= 216 && ch <= 246 || ch >= 248 && ch <= 255) { AddCh(); goto case 1; }
                     else if (ch == 92) { AddCh(); goto case 2; }
                     else { t.kind = 1; t.val = new String(tval, 0, tlen); CheckLiteral(); return t; }
                 case 2
                     if (ch == 'u') { AddCh(); goto case 3; }
                     else if (ch == 'U') { AddCh(); goto case 7; }
                     else { t.kind = noSym; break; }
                 case 3
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 4; }
                     else { t.kind = noSym; break; }
                 case 4
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 5; }
                     else { t.kind = noSym; break; }
                 case 5
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 6; }
                     else { t.kind = noSym; break; }
                 case 6
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 1; }
                     else { t.kind = noSym; break; }
                 case 7
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 8; }
                     else { t.kind = noSym; break; }
                 case 8
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 9; }
                     else { t.kind = noSym; break; }
                 case 9
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 10; }
                     else { t.kind = noSym; break; }
                 case 10
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 11; }
                     else { t.kind = noSym; break; }
                 case 11
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 12; }
                     else { t.kind = noSym; break; }
                 case 12
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 13; }
                     else { t.kind = noSym; break; }
                 case 13
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 14; }
                     else { t.kind = noSym; break; }
                 case 14
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 1; }
                     else { t.kind = noSym; break; }
                 case 15
                     if (ch == 'u') { AddCh(); goto case 16; }
                     else if (ch == 'U') { AddCh(); goto case 20; }
                     else { t.kind = noSym; break; }
                 case 16
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 17; }
                     else { t.kind = noSym; break; }
                 case 17
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 18; }
                     else { t.kind = noSym; break; }
                 case 18
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 19; }
                     else { t.kind = noSym; break; }
                 case 19
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 1; }
                     else { t.kind = noSym; break; }
                 case 20
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 21; }
                     else { t.kind = noSym; break; }
                 case 21
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 22; }
                     else { t.kind = noSym; break; }
                 case 22
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 23; }
                     else { t.kind = noSym; break; }
                 case 23
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 24; }
                     else { t.kind = noSym; break; }
                 case 24
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 25; }
                     else { t.kind = noSym; break; }
                 case 25
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 26; }
                     else { t.kind = noSym; break; }
                 case 26
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 27; }
                     else { t.kind = noSym; break; }
                 case 27
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 1; }
                     else { t.kind = noSym; break; }
                 case 28
                     if (ch >= '0' && ch <= '9') { apx = 0; AddCh(); goto case 28; }
                     else if (ch == 'U') { apx = 0; AddCh(); goto case 176; }
                     else if (ch == 'u') { apx = 0; AddCh(); goto case 177; }
                     else if (ch == 'L') { apx = 0; AddCh(); goto case 178; }
                     else if (ch == 'l') { apx = 0; AddCh(); goto case 179; }
                     else
                     {
                         tlen -= apx;
                         buffer.Pos = t.pos; NextCh(); line = t.line; col = t.col;
                         for (int i = 0; i < tlen; i++) NextCh();
                         t.kind = 2; break;
                     }
                 case 29
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 30; }
                     else { t.kind = noSym; break; }
                 case 30
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 30; }
                     else if (ch == 'U') { AddCh(); goto case 180; }
                     else if (ch == 'u') { AddCh(); goto case 181; }
                     else if (ch == 'L') { AddCh(); goto case 182; }
                     else if (ch == 'l') { AddCh(); goto case 183; }
                     else { t.kind = 2; break; }
                 case 31
                     { t.kind = 2; break; }
                 case 32
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 32; }
                     else if (ch == 'D' || ch == 'F' || ch == 'M' || ch == 'd' || ch == 'f' || ch == 'm') { AddCh(); goto case 43; }
                     else if (ch == 'E' || ch == 'e') { AddCh(); goto case 33; }
                     else { t.kind = 3; break; }
                 case 33
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 35; }
                     else if (ch == '+' || ch == '-') { AddCh(); goto case 34; }
                     else { t.kind = noSym; break; }
                 case 34
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 35; }
                     else { t.kind = noSym; break; }
                 case 35
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 35; }
                     else if (ch == 'D' || ch == 'F' || ch == 'M' || ch == 'd' || ch == 'f' || ch == 'm') { AddCh(); goto case 43; }
                     else { t.kind = 3; break; }
                 case 36
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 36; }
                     else if (ch == 'D' || ch == 'F' || ch == 'M' || ch == 'd' || ch == 'f' || ch == 'm') { AddCh(); goto case 43; }
                     else if (ch == 'E' || ch == 'e') { AddCh(); goto case 37; }
                     else { t.kind = 3; break; }
                 case 37
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 39; }
                     else if (ch == '+' || ch == '-') { AddCh(); goto case 38; }
                     else { t.kind = noSym; break; }
                 case 38
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 39; }
                     else { t.kind = noSym; break; }
                 case 39
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 39; }
                     else if (ch == 'D' || ch == 'F' || ch == 'M' || ch == 'd' || ch == 'f' || ch == 'm') { AddCh(); goto case 43; }
                     else { t.kind = 3; break; }
                 case 40
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 42; }
                     else if (ch == '+' || ch == '-') { AddCh(); goto case 41; }
                     else { t.kind = noSym; break; }
                 case 41
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 42; }
                     else { t.kind = noSym; break; }
                 case 42
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 42; }
                     else if (ch == 'D' || ch == 'F' || ch == 'M' || ch == 'd' || ch == 'f' || ch == 'm') { AddCh(); goto case 43; }
                     else { t.kind = 3; break; }
                 case 43
                     { t.kind = 3; break; }
                 case 44
                     if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= '&' || ch >= '(' && ch <= '[' || ch >= ']' && ch <= 65535) { AddCh(); goto case 45; }
                     else if (ch == 92) { AddCh(); goto case 184; }
                     else { t.kind = noSym; break; }
                 case 45
                     if (ch == 39) { AddCh(); goto case 60; }
                     else { t.kind = noSym; break; }
                 case 46
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 47; }
                     else { t.kind = noSym; break; }
                 case 47
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 185; }
                     else if (ch == 39) { AddCh(); goto case 60; }
                     else { t.kind = noSym; break; }
                 case 48
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 49; }
                     else { t.kind = noSym; break; }
                 case 49
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 50; }
                     else { t.kind = noSym; break; }
                 case 50
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 51; }
                     else { t.kind = noSym; break; }
                 case 51
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 45; }
                     else { t.kind = noSym; break; }
                 case 52
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 53; }
                     else { t.kind = noSym; break; }
                 case 53
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 54; }
                     else { t.kind = noSym; break; }
                 case 54
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 55; }
                     else { t.kind = noSym; break; }
                 case 55
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 56; }
                     else { t.kind = noSym; break; }
                 case 56
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 57; }
                     else { t.kind = noSym; break; }
                 case 57
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 58; }
                     else { t.kind = noSym; break; }
                 case 58
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 59; }
                     else { t.kind = noSym; break; }
                 case 59
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 45; }
                     else { t.kind = noSym; break; }
                 case 60
                     { t.kind = 4; break; }
                 case 61
                     if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= '!' || ch >= '#' && ch <= '[' || ch >= ']' && ch <= 65535) { AddCh(); goto case 61; }
                     else if (ch == '"') { AddCh(); goto case 77; }
                     else if (ch == 92) { AddCh(); goto case 187; }
                     else { t.kind = noSym; break; }
                 case 62
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 63; }
                     else { t.kind = noSym; break; }
                 case 63
                     if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= '!' || ch >= '#' && ch <= '/' || ch >= '
                     else if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 188; }
                     else if (ch == '"') { AddCh(); goto case 77; }
                     else if (ch == 92) { AddCh(); goto case 187; }
                     else { t.kind = noSym; break; }
                 case 64
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 65; }
                     else { t.kind = noSym; break; }
                 case 65
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 66; }
                     else { t.kind = noSym; break; }
                 case 66
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 67; }
                     else { t.kind = noSym; break; }
                 case 67
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 61; }
                     else { t.kind = noSym; break; }
                 case 68
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 69; }
                     else { t.kind = noSym; break; }
                 case 69
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 70; }
                     else { t.kind = noSym; break; }
                 case 70
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 71; }
                     else { t.kind = noSym; break; }
                 case 71
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 72; }
                     else { t.kind = noSym; break; }
                 case 72
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 73; }
                     else { t.kind = noSym; break; }
                 case 73
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 74; }
                     else { t.kind = noSym; break; }
                 case 74
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 75; }
                     else { t.kind = noSym; break; }
                 case 75
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 61; }
                     else { t.kind = noSym; break; }
                 case 76
                     if (ch <= '!' || ch >= '#' && ch <= 65535) { AddCh(); goto case 76; }
                     else if (ch == '"') { AddCh(); goto case 190; }
                     else { t.kind = noSym; break; }
                 case 77
                     { t.kind = 5; break; }
                 case 78
                     { t.kind = 40; break; }
                 case 79
                     { t.kind = 43; break; }
                 case 80
                     { t.kind = 44; break; }
                 case 81
                     { t.kind = 45; break; }
                 case 82
                     { t.kind = 47; break; }
                 case 83
                     { t.kind = 48; break; }
                 case 84
                     { t.kind = 50; break; }
                 case 85
                     { t.kind = 51; break; }
                 case 86
                     { t.kind = 52; break; }
                 case 87
                     { t.kind = 53; break; }
                 case 88
                     { t.kind = 54; break; }
                 case 89
                     { t.kind = 55; break; }
                 case 90
                     { t.kind = 59; break; }
                 case 91
                     if (ch == '=') { AddCh(); goto case 92; }
                     else { t.kind = noSym; break; }
                 case 92
                     { t.kind = 60; break; }
                 case 93
                     { t.kind = 61; break; }
                 case 94
                     if (ch == '=') { AddCh(); goto case 95; }
                     else { t.kind = noSym; break; }
                 case 95
                     { t.kind = 63; break; }
                 case 96
                     { t.kind = 65; break; }
                 case 97
                     { t.kind = 66; break; }
                 case 98
                     { t.kind = 67; break; }
                 case 99
                     { t.kind = 68; break; }
                 case 100
                     { t.kind = 69; break; }
                 case 101
                     { t.kind = 70; break; }
                 case 102
                     { t.kind = 71; break; }
                 case 103
                     { t.kind = 73; break; }
                 case 104
                     if (ch == '=') { AddCh(); goto case 105; }
                     else { t.kind = noSym; break; }
                 case 105
                     { t.kind = 74; break; }
                 case 106
                     if (ch == 'e') { AddCh(); goto case 107; }
                     else { t.kind = noSym; break; }
                 case 107
                     if (ch == 'f') { AddCh(); goto case 108; }
                     else { t.kind = noSym; break; }
                 case 108
                     if (ch == 'i') { AddCh(); goto case 109; }
                     else { t.kind = noSym; break; }
                 case 109
                     if (ch == 'n') { AddCh(); goto case 110; }
                     else { t.kind = noSym; break; }
                 case 110
                     if (ch == 'e') { AddCh(); goto case 111; }
                     else { t.kind = noSym; break; }
                 case 111
                     if (ch == 10 || ch == 13) { AddCh(); goto case 112; }
                     else if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 65535) { AddCh(); goto case 111; }
                     else { t.kind = noSym; break; }
                 case 112
                     { t.kind = 81; break; }
                 case 113
                     if (ch == 'n') { AddCh(); goto case 114; }
                     else { t.kind = noSym; break; }
                 case 114
                     if (ch == 'd') { AddCh(); goto case 115; }
                     else { t.kind = noSym; break; }
                 case 115
                     if (ch == 'e') { AddCh(); goto case 116; }
                     else { t.kind = noSym; break; }
                 case 116
                     if (ch == 'f') { AddCh(); goto case 117; }
                     else { t.kind = noSym; break; }
                 case 117
                     if (ch == 10 || ch == 13) { AddCh(); goto case 118; }
                     else if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 65535) { AddCh(); goto case 117; }
                     else { t.kind = noSym; break; }
                 case 118
                     { t.kind = 82; break; }
                 case 119
                     if (ch == 'f') { AddCh(); goto case 120; }
                     else { t.kind = noSym; break; }
                 case 120
                     if (ch == 10 || ch == 13) { AddCh(); goto case 121; }
                     else if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 65535) { AddCh(); goto case 120; }
                     else { t.kind = noSym; break; }
                 case 121
                     { t.kind = 83; break; }
                 case 122
                     if (ch == 'f') { AddCh(); goto case 123; }
                     else { t.kind = noSym; break; }
                 case 123
                     if (ch == 10 || ch == 13) { AddCh(); goto case 124; }
                     else if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 65535) { AddCh(); goto case 123; }
                     else { t.kind = noSym; break; }
                 case 124
                     { t.kind = 84; break; }
                 case 125
                     if (ch == 'e') { AddCh(); goto case 126; }
                     else { t.kind = noSym; break; }
                 case 126
                     if (ch == 10 || ch == 13) { AddCh(); goto case 127; }
                     else if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 65535) { AddCh(); goto case 126; }
                     else { t.kind = noSym; break; }
                 case 127
                     { t.kind = 85; break; }
                 case 128
                     if (ch == 'f') { AddCh(); goto case 129; }
                     else { t.kind = noSym; break; }
                 case 129
                     if (ch == 10 || ch == 13) { AddCh(); goto case 130; }
                     else if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 65535) { AddCh(); goto case 129; }
                     else { t.kind = noSym; break; }
                 case 130
                     { t.kind = 86; break; }
                 case 131
                     if (ch == 'i') { AddCh(); goto case 132; }
                     else { t.kind = noSym; break; }
                 case 132
                     if (ch == 'n') { AddCh(); goto case 133; }
                     else { t.kind = noSym; break; }
                 case 133
                     if (ch == 'e') { AddCh(); goto case 134; }
                     else { t.kind = noSym; break; }
                 case 134
                     if (ch == 10 || ch == 13) { AddCh(); goto case 135; }
                     else if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 65535) { AddCh(); goto case 134; }
                     else { t.kind = noSym; break; }
                 case 135
                     { t.kind = 87; break; }
                 case 136
                     if (ch == 'r') { AddCh(); goto case 137; }
                     else { t.kind = noSym; break; }
                 case 137
                     if (ch == 'o') { AddCh(); goto case 138; }
                     else { t.kind = noSym; break; }
                 case 138
                     if (ch == 'r') { AddCh(); goto case 139; }
                     else { t.kind = noSym; break; }
                 case 139
                     if (ch == 10 || ch == 13) { AddCh(); goto case 140; }
                     else if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 65535) { AddCh(); goto case 139; }
                     else { t.kind = noSym; break; }
                 case 140
                     { t.kind = 88; break; }
                 case 141
                     if (ch == 'a') { AddCh(); goto case 142; }
                     else { t.kind = noSym; break; }
                 case 142
                     if (ch == 'r') { AddCh(); goto case 143; }
                     else { t.kind = noSym; break; }
                 case 143
                     if (ch == 'n') { AddCh(); goto case 144; }
                     else { t.kind = noSym; break; }
                 case 144
                     if (ch == 'i') { AddCh(); goto case 145; }
                     else { t.kind = noSym; break; }
                 case 145
                     if (ch == 'n') { AddCh(); goto case 146; }
                     else { t.kind = noSym; break; }
                 case 146
                     if (ch == 'g') { AddCh(); goto case 147; }
                     else { t.kind = noSym; break; }
                 case 147
                     if (ch == 10 || ch == 13) { AddCh(); goto case 148; }
                     else if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 65535) { AddCh(); goto case 147; }
                     else { t.kind = noSym; break; }
                 case 148
                     { t.kind = 89; break; }
                 case 149
                     if (ch == 'e') { AddCh(); goto case 150; }
                     else { t.kind = noSym; break; }
                 case 150
                     if (ch == 'g') { AddCh(); goto case 151; }
                     else { t.kind = noSym; break; }
                 case 151
                     if (ch == 'i') { AddCh(); goto case 152; }
                     else { t.kind = noSym; break; }
                 case 152
                     if (ch == 'o') { AddCh(); goto case 153; }
                     else { t.kind = noSym; break; }
                 case 153
                     if (ch == 'n') { AddCh(); goto case 154; }
                     else { t.kind = noSym; break; }
                 case 154
                     if (ch == 10 || ch == 13) { AddCh(); goto case 155; }
                     else if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 65535) { AddCh(); goto case 154; }
                     else { t.kind = noSym; break; }
                 case 155
                     { t.kind = 90; break; }
                 case 156
                     if (ch == 'e') { AddCh(); goto case 157; }
                     else { t.kind = noSym; break; }
                 case 157
                     if (ch == 'g') { AddCh(); goto case 158; }
                     else { t.kind = noSym; break; }
                 case 158
                     if (ch == 'i') { AddCh(); goto case 159; }
                     else { t.kind = noSym; break; }
                 case 159
                     if (ch == 'o') { AddCh(); goto case 160; }
                     else { t.kind = noSym; break; }
                 case 160
                     if (ch == 'n') { AddCh(); goto case 161; }
                     else { t.kind = noSym; break; }
                 case 161
                     if (ch == 10 || ch == 13) { AddCh(); goto case 162; }
                     else if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 65535) { AddCh(); goto case 161; }
                     else { t.kind = noSym; break; }
                 case 162
                     { t.kind = 91; break; }
                 case 163
                     if (ch >= '0' && ch <= '9') { apx = 0; AddCh(); goto case 163; }
                     else if (ch == 'U') { apx = 0; AddCh(); goto case 176; }
                     else if (ch == 'u') { apx = 0; AddCh(); goto case 177; }
                     else if (ch == 'L') { apx = 0; AddCh(); goto case 178; }
                     else if (ch == 'l') { apx = 0; AddCh(); goto case 179; }
                     else if (ch == '.') { apx++; AddCh(); goto case 191; }
                     else if (ch == 'E' || ch == 'e') { apx = 0; AddCh(); goto case 40; }
                     else if (ch == 'D' || ch == 'F' || ch == 'M' || ch == 'd' || ch == 'f' || ch == 'm') { apx = 0; AddCh(); goto case 43; }
                     else { t.kind = 2; break; }
                 case 164
                     if (ch >= 'A' && ch <= 'Z' || ch == '_' || ch >= 'a' && ch <= 'z' || ch == 170 || ch == 181 || ch == 186 || ch >= 192 && ch <= 214 || ch >= 216 && ch <= 246 || ch >= 248 && ch <= 255) { AddCh(); goto case 1; }
                     else if (ch == 92) { AddCh(); goto case 15; }
                     else if (ch == '"') { AddCh(); goto case 76; }
                     else { t.kind = noSym; break; }
                 case 165
                     if (ch >= '0' && ch <= '9') { apx = 0; AddCh(); goto case 163; }
                     else if (ch == 'U') { apx = 0; AddCh(); goto case 176; }
                     else if (ch == 'u') { apx = 0; AddCh(); goto case 177; }
                     else if (ch == 'L') { apx = 0; AddCh(); goto case 178; }
                     else if (ch == 'l') { apx = 0; AddCh(); goto case 179; }
                     else if (ch == '.') { apx++; AddCh(); goto case 191; }
                     else if (ch == 'X' || ch == 'x') { apx = 0; AddCh(); goto case 29; }
                     else if (ch == 'E' || ch == 'e') { apx = 0; AddCh(); goto case 40; }
                     else if (ch == 'D' || ch == 'F' || ch == 'M' || ch == 'd' || ch == 'f' || ch == 'm') { apx = 0; AddCh(); goto case 43; }
                     else { t.kind = 2; break; }
                 case 166
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 32; }
                     else { t.kind = 46; break; }
                 case 167
                     if (ch == '=') { AddCh(); goto case 78; }
                     else { t.kind = 39; break; }
                 case 168
                     if (ch == '=') { AddCh(); goto case 83; }
                     else { t.kind = 41; break; }
                 case 169
                     if (ch == '
                     else { t.kind = 42; break; }
                 case 170
                     if (ch == '-') { AddCh(); goto case 80; }
                     else if (ch == '=') { AddCh(); goto case 90; }
                     else { t.kind = 58; break; }
                 case 171
                     if (ch == '+') { AddCh(); goto case 85; }
                     else if (ch == '=') { AddCh(); goto case 96; }
                     else { t.kind = 64; break; }
                 case 172
                     if (ch == '<') { AddCh(); goto case 192; }
                     else { t.kind = 56; break; }
                 case 173
                     if (ch == '=') { AddCh(); goto case 93; }
                     else { t.kind = 62; break; }
                 case 174
                     if (ch == '=') { AddCh(); goto case 103; }
                     else { t.kind = 72; break; }
                 case 175
                     if (ch == 9 || ch >= 11 && ch <= 12 || ch == ' ') { AddCh(); goto case 175; }
                     else if (ch == 'd') { AddCh(); goto case 106; }
                     else if (ch == 'u') { AddCh(); goto case 113; }
                     else if (ch == 'i') { AddCh(); goto case 119; }
                     else if (ch == 'e') { AddCh(); goto case 193; }
                     else if (ch == 'l') { AddCh(); goto case 131; }
                     else if (ch == 'w') { AddCh(); goto case 141; }
                     else if (ch == 'r') { AddCh(); goto case 149; }
                     else { t.kind = noSym; break; }
                 case 176
                     if (ch == 'L' || ch == 'l') { AddCh(); goto case 31; }
                     else { t.kind = 2; break; }
                 case 177
                     if (ch == 'L' || ch == 'l') { AddCh(); goto case 31; }
                     else { t.kind = 2; break; }
                 case 178
                     if (ch == 'U' || ch == 'u') { AddCh(); goto case 31; }
                     else { t.kind = 2; break; }
                 case 179
                     if (ch == 'U' || ch == 'u') { AddCh(); goto case 31; }
                     else { t.kind = 2; break; }
                 case 180
                     if (ch == 'L' || ch == 'l') { AddCh(); goto case 31; }
                     else { t.kind = 2; break; }
                 case 181
                     if (ch == 'L' || ch == 'l') { AddCh(); goto case 31; }
                     else { t.kind = 2; break; }
                 case 182
                     if (ch == 'U' || ch == 'u') { AddCh(); goto case 31; }
                     else { t.kind = 2; break; }
                 case 183
                     if (ch == 'U' || ch == 'u') { AddCh(); goto case 31; }
                     else { t.kind = 2; break; }
                 case 184
                     if (ch == '"' || ch == 39 || ch == '0' || ch == 92 || ch >= 'a' && ch <= 'b' || ch == 'f' || ch == 'n' || ch == 'r' || ch == 't' || ch == 'v') { AddCh(); goto case 45; }
                     else if (ch == 'x') { AddCh(); goto case 46; }
                     else if (ch == 'u') { AddCh(); goto case 48; }
                     else if (ch == 'U') { AddCh(); goto case 52; }
                     else { t.kind = noSym; break; }
                 case 185
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 186; }
                     else if (ch == 39) { AddCh(); goto case 60; }
                     else { t.kind = noSym; break; }
                 case 186
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 45; }
                     else if (ch == 39) { AddCh(); goto case 60; }
                     else { t.kind = noSym; break; }
                 case 187
                     if (ch == '"' || ch == 39 || ch == '0' || ch == 92 || ch >= 'a' && ch <= 'b' || ch == 'f' || ch == 'n' || ch == 'r' || ch == 't' || ch == 'v') { AddCh(); goto case 61; }
                     else if (ch == 'x') { AddCh(); goto case 62; }
                     else if (ch == 'u') { AddCh(); goto case 64; }
                     else if (ch == 'U') { AddCh(); goto case 68; }
                     else { t.kind = noSym; break; }
                 case 188
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 189; }
                     else if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= '!' || ch >= '#' && ch <= '/' || ch >= '
                     else if (ch == '"') { AddCh(); goto case 77; }
                     else if (ch == 92) { AddCh(); goto case 187; }
                     else { t.kind = noSym; break; }
                 case 189
                     if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= '!' || ch >= '#' && ch <= '[' || ch >= ']' && ch <= 65535) { AddCh(); goto case 61; }
                     else if (ch == '"') { AddCh(); goto case 77; }
                     else if (ch == 92) { AddCh(); goto case 187; }
                     else { t.kind = noSym; break; }
                 case 190
                     if (ch == '"') { AddCh(); goto case 76; }
                     else { t.kind = 5; break; }
                 case 191
                     if (ch <= '/' || ch >= '
                     else if (ch >= '0' && ch <= '9') { apx = 0; AddCh(); goto case 36; }
                     else { t.kind = noSym; break; }
                 case 192
                     if (ch == '=') { AddCh(); goto case 89; }
                     else { t.kind = 57; break; }
                 case 193
                     if (ch == 'l') { AddCh(); goto case 194; }
                     else if (ch == 'n') { AddCh(); goto case 195; }
                     else if (ch == 'r') { AddCh(); goto case 136; }
                     else { t.kind = noSym; break; }
                 case 194
                     if (ch == 'i') { AddCh(); goto case 122; }
                     else if (ch == 's') { AddCh(); goto case 125; }
                     else { t.kind = noSym; break; }
                 case 195
                     if (ch == 'd') { AddCh(); goto case 196; }
                     else { t.kind = noSym; break; }
                 case 196
                     if (ch == 'i') { AddCh(); goto case 128; }
                     else if (ch == 'r') { AddCh(); goto case 156; }
                     else { t.kind = noSym; break; }
                 case 197
                     if (ch == 'c') { AddCh(); goto case 198; }
                     else { t.kind = noSym; break; }
                 case 198
                     if (ch == 'l') { AddCh(); goto case 199; }
                     else { t.kind = noSym; break; }
                 case 199
                     if (ch == 'u') { AddCh(); goto case 200; }
                     else { t.kind = noSym; break; }
                 case 200
                     if (ch == 'd') { AddCh(); goto case 201; }
                     else { t.kind = noSym; break; }
                 case 201
                     if (ch == 'e') { AddCh(); goto case 202; }
                     else { t.kind = noSym; break; }
                 case 202
                     { t.kind = 75; break; }
                 case 203
                     if (ch == '=') { AddCh(); goto case 204; }
                     else { t.kind = noSym; break; }
                 case 204
                     { t.kind = 79; break; }
                 case 205
                     if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= '!' || ch >= '#' && ch <= '[' || ch >= ']' && ch <= 65535) { AddCh(); goto case 61; }
                     else if (ch == '"') { AddCh(); goto case 77; }
                     else if (ch == 92) { AddCh(); goto case 187; }
                     else { t.kind = 76; break; }
                 case 206
                     if (ch == '=') { AddCh(); goto case 81; }
                     else { t.kind = 77; break; }
                 case 207
                     if (ch == '=') { AddCh(); goto case 84; }
                     else if (ch == '>') { AddCh(); goto case 203; }
                     else { t.kind = 49; break; }
                 case 208
                     if (ch == 9 || ch >= 11 && ch <= 12 || ch == ' ') { AddCh(); goto case 175; }
                     else if (ch == 'd') { AddCh(); goto case 106; }
                     else if (ch == 'u') { AddCh(); goto case 113; }
                     else if (ch == 'i') { AddCh(); goto case 209; }
                     else if (ch == 'e') { AddCh(); goto case 193; }
                     else if (ch == 'l') { AddCh(); goto case 131; }
                     else if (ch == 'w') { AddCh(); goto case 141; }
                     else if (ch == 'r') { AddCh(); goto case 149; }
                     else { t.kind = noSym; break; }
                 case 209
                     if (ch == 'f') { AddCh(); goto case 120; }
                     else if (ch == 'n') { AddCh(); goto case 197; }
                     else { t.kind = noSym; break; }
 
             }
             t.val = new String(tval, 0, tlen);
             return t;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="1183" endline="1196"><![CDATA[
 
         // get the next token (possibly a token already seen during peeking)
         public Token Scan()
         {
             if (tokens.next == null)
             {
                 return NextToken();
             }
             else
             {
                 pt = tokens = tokens.next;
                 return tokens;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="1197" endline="1216"><![CDATA[
 
         // peek for the next token, ignore pragmas
         public Token Peek()
         {
             if (pt.next == null)
             {
                 do
                 {
                     pt = pt.next = NextToken();
                 } while (pt.kind > maxT); // skip pragmas
             }
             else
             {
                 do
                 {
                     pt = pt.next;
                 } while (pt.kind > maxT);
             }
             return pt;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\ctrlCodeStructure.cs" startline="1217" endline="1219"><![CDATA[
 
         // make sure that peeking starts at the current scan position
         public void ResetPeek() { pt = tokens; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="20" endline="23"><![CDATA[
         public State()
         {
             nr = ++lastNr;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="24" endline="32"><![CDATA[
 
         public void AddAction(Action act)
         {
             Action lasta = null, a = firstAction;
             while (a != null && act.typ >= a.typ) { lasta = a; a = a.next; }
             // collecting classes at the beginning gives better performance
             act.next = a;
             if (a == firstAction) firstAction = act; else lasta.next = act;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="33" endline="40"><![CDATA[
 
         public void DetachAction(Action act)
         {
             Action lasta = null, a = firstAction;
             while (a != null && a != act) { lasta = a; a = a.next; }
             if (a != null)
                 if (a == firstAction) firstAction = a.next; else lasta.next = a.next;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="41" endline="53"><![CDATA[
 
         public Action TheAction(char ch)
         {
             BitArray s;
             for (Action a = firstAction; a != null; a = a.next)
                 if (a.typ == Node.chr && ch == a.sym) return a;
                 else if (a.typ == Node.clas)
                 {
                     s = CharClass.Set(a.sym);
                     if (s[ch]) return a;
                 }
             for (Action a = firstAction; a != null; a = a.next)
                 if (a.typ == Node.chr && ch == a.sym) return a;
                 else if (a.typ == Node.clas)
                 {
                     s = CharClass.Set(a.sym);
                     if (s[ch]) return a;
                 }
             return null;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="54" endline="68"><![CDATA[
 
         /// <summary>
         /// Copy actions of another state to this state
         /// </summary>
         /// <param name="s">The state to copy the actions from</param>
         public void MeltWith(State s)
         { 
             Action a;
             for (Action action = s.firstAction; action != null; action = action.next)
             {
                 a = new Action(action.typ, action.sym, action.tc);
                 a.AddTargets(action);
                 AddAction(a);
             }
             for (Action action = s.firstAction; action != null; action = action.next)
             {
                 a = new Action(action.typ, action.sym, action.tc);
                 a.AddTargets(action);
                 AddAction(a);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="69" endline="89"><![CDATA[
 
     }
 
     //-----------------------------------------------------------------------------
     //  Action
     //-----------------------------------------------------------------------------
     /// <summary>
     /// Action of the finite automaton
     /// </summary>
     public class Action
     {
         public int typ;					// type of action symbol
         public int sym;					// action symbol
         public int tc;					// transition code
         public Target target;		// states reached from this action
         public Action next;
 
         public Action(int typ, int sym, int tc)
         {
             this.typ = typ; this.sym = sym; this.tc = tc;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="90" endline="106"><![CDATA[
 
         /// <summary>
         /// Add a target to this.target
         /// </summary>
         /// <param name="t">The target to add</param>
         public void AddTarget(Target t)
         {
             Target last = null;
             Target p = target;
             while (p != null && t.state.nr >= p.state.nr)
             {
                 if (t.state == p.state) return;
                 last = p; p = p.next;
             }
             while (p != null && t.state.nr >= p.state.nr)
             {
                 if (t.state == p.state) return;
                 last = p; p = p.next;
             }
             t.next = p;
             if (p == target) target = t; else last.next = t;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="107" endline="120"><![CDATA[
 
         /// <summary>
         /// Add all targets from another action
         /// </summary>
         /// <param name="a">The Action whose targets need to be added</param>
         public void AddTargets(Action a)
         {
             for (Target p = a.target; p != null; p = p.next)
             {
                 Target t = new Target(p.state);
                 AddTarget(t);
             }
             for (Target p = a.target; p != null; p = p.next)
             {
                 Target t = new Target(p.state);
                 AddTarget(t);
             }
             if (a.tc == Node.contextTrans) tc = Node.contextTrans;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="121" endline="132"><![CDATA[
 
         public BitArray Symbols()
         {
             BitArray s;
             if (typ == Node.clas)
                 s = (BitArray)CharClass.Set(sym).Clone();
             else
             {
                 s = new BitArray(CharClass.charSetSize); s[sym] = true;
             }
             return s;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="133" endline="146"><![CDATA[
 
         public void ShiftWith(BitArray s)
         {
             if (Sets.Elements(s) == 1)
             {
                 typ = Node.chr; sym = Sets.First(s);
             }
             else
             {
                 CharClass c = CharClass.Find(s);
                 if (c == null) c = new CharClass("#", s); // class with dummy name
                 typ = Node.clas; sym = c.n;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="147" endline="180"><![CDATA[
 
         public void GetTargetStates(out BitArray targets, out Symbol endOf, out bool ctx)
         {
             // compute the set of target states
             targets = new BitArray(DFA.maxStates); endOf = null;
             ctx = false;
             for (Target t = target; t != null; t = t.next)
             {
                 int stateNr = t.state.nr;
                 if (stateNr <= DFA.lastSimState) targets[stateNr] = true;
                 else targets.Or(Melted.Set(stateNr));
                 if (t.state.endOf != null)
                     if (endOf == null || endOf == t.state.endOf)
                         endOf = t.state.endOf;
                     else
                     {
                         Console.WriteLine("Tokens {0} and {1} cannot be distinguished", endOf.name, t.state.endOf.name);
                         Errors.count++;
                     }
                 if (t.state.ctx)
                 {
                     ctx = true;
                     // The following check seems to be unnecessary. It reported an error
                     // if a symbol + context was the prefix of another symbol, e.g.
                     //   s1 = "a" "b" "c".
                     //   s2 = "a" CONTEXT("b").
                     // But this is ok.
                     // if (t.state.endOf != null) {
                     //   Console.WriteLine("Ambiguous context clause");
                     //	 Errors.count++;
                     // }
                 }
             }
             for (Target t = target; t != null; t = t.next)
             {
                 int stateNr = t.state.nr;
                 if (stateNr <= DFA.lastSimState) targets[stateNr] = true;
                 else targets.Or(Melted.Set(stateNr));
                 if (t.state.endOf != null)
                     if (endOf == null || endOf == t.state.endOf)
                         endOf = t.state.endOf;
                     else
                     {
                         Console.WriteLine("Tokens {0} and {1} cannot be distinguished", endOf.name, t.state.endOf.name);
                         Errors.count++;
                     }
                 if (t.state.ctx)
                 {
                     ctx = true;
                     // The following check seems to be unnecessary. It reported an error
                     // if a symbol + context was the prefix of another symbol, e.g.
                     //   s1 = "a" "b" "c".
                     //   s2 = "a" CONTEXT("b").
                     // But this is ok.
                     // if (t.state.endOf != null) {
                     //   Console.WriteLine("Ambiguous context clause");
                     //	 Errors.count++;
                     // }
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="181" endline="199"><![CDATA[
 
     }
 
     //-----------------------------------------------------------------------------
     //  Target
     //-----------------------------------------------------------------------------
 
     /// <summary>
     /// Set of states that are reached by an action
     /// </summary>
     public class Target
     {				
         public State state;				// target state
         public Target next;
 
         public Target(State s)
         {
             state = s;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="200" endline="220"><![CDATA[
     }
 
     //-----------------------------------------------------------------------------
     //  Melted
     //-----------------------------------------------------------------------------
 
     /// <summary>
     /// Information about melted states
     /// </summary>
     public class Melted
     {					
         public static Melted first;	// head of melted state list
         public BitArray set;				// set of old states
         public State state;					// new state
         public Melted next;
 
         public Melted(BitArray set, State state)
         {
             this.set = set; this.state = state;
             this.next = first; first = this;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="221" endline="230"><![CDATA[
 
         public static BitArray Set(int nr)
         {
             Melted m = first;
             while (m != null)
             {
                 if (m.state.nr == nr) return m.set; else m = m.next;
             }
             while (m != null)
             {
                 if (m.state.nr == nr) return m.set; else m = m.next;
             }
             throw new Exception("-- compiler error in Melted.Set");
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="231" endline="237"><![CDATA[
 
         public static Melted StateWithSet(BitArray s)
         {
             for (Melted m = first; m != null; m = m.next)
                 if (Sets.Equals(s, m.set)) return m;
             for (Melted m = first; m != null; m = m.next)
                 if (Sets.Equals(s, m.set)) return m;
             return null;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="238" endline="277"><![CDATA[
 
     }
 
     //-----------------------------------------------------------------------------
     //  Comment
     //-----------------------------------------------------------------------------
 
     /// <summary>
     /// Information about comment syntax
     /// </summary>
     public class Comment
     {
         public static Comment first;	// list of comments
         public string start;
         public string stop;
         public bool nested;
         public Comment next;
 
         static string Str(Node p)
         {
             StringBuilder s = new StringBuilder();
             while (p != null)
             {
                 if (p.typ == Node.chr)
                 {
                     s.Append((char)p.val);
                 }
                 else if (p.typ == Node.clas)
                 {
                     BitArray set = CharClass.Set(p.val);
                     if (Sets.Elements(set) != 1) Parser.SemErr(26);
                     s.Append((char)Sets.First(set));
                 }
                 else Parser.SemErr(22);
                 p = p.next;
             }
             while (p != null)
             {
                 if (p.typ == Node.chr)
                 {
                     s.Append((char)p.val);
                 }
                 else if (p.typ == Node.clas)
                 {
                     BitArray set = CharClass.Set(p.val);
                     if (Sets.Elements(set) != 1) Parser.SemErr(26);
                     s.Append((char)Sets.First(set));
                 }
                 else Parser.SemErr(22);
                 p = p.next;
             }
             if (s.Length == 0) { Parser.SemErr(25); s.Append('?'); }
             else if (s.Length > 2) Parser.SemErr(25);
             return s.ToString();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="278" endline="285"><![CDATA[
 
         public Comment(Node from, Node to, bool nested)
         {
             start = Str(from);
             stop = Str(to);
             this.nested = nested;
             this.next = first; first = this;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="286" endline="316"><![CDATA[
 
     }
 
     //-----------------------------------------------------------------------------
     //  DFA
     //-----------------------------------------------------------------------------
 
     public class DFA
     {
         public static int maxStates;
         public const int EOF = -1;
         public const char CR = '\r';
         public const char LF = '\n';
 
         public static State firstState;
         public static State lastState;		// last allocated state
         public static int lastSimState;		// last non melted state
         public static FileStream fram;		// scanner frame input
         public static StreamWriter gen;		// generated scanner file
         static TextWriter trace; 	// trace output file
         public static Symbol curSy;				// current token to be recognized (in FindTrans)
         public static Node curGraph;			// start of graph for current token (in FindTrans)
         public static bool dirtyDFA;			// DFA may become nondeterministic in MatchedDFA
         public static bool hasCtxMoves;		// DFA has context transitions
 
         //---------- Output primitives
         private static string Ch(char ch)
         {
             if (ch < ' ' || ch >= 127 || ch == '\'' || ch == '\\') return Convert.ToString((int)ch);
             else return String.Format("'{0}'", ch);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="317" endline="321"><![CDATA[
 
         private static string ChCond(char ch)
         {
             return String.Format("ch == {0}", Ch(ch));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="322" endline="360"><![CDATA[
 
         private static void PutRange(BitArray s)
         {
             int[] lo = new int[32];
             int[] hi = new int[32];
             // fill lo and hi
             int max = CharClass.charSetSize;
             int top = -1;
             int i = 0;
             while (i < max)
             {
                 if (s[i])
                 {
                     top++; lo[top] = i; i++;
                     while (i < max && s[i]) i++;
                     hi[top] = i - 1;
                 }
                 else i++;
             }
             while (i < max)
             {
                 if (s[i])
                 {
                     top++; lo[top] = i; i++;
                     while (i < max && s[i]) i++;
                     hi[top] = i - 1;
                 }
                 else i++;
             }
             // print ranges
             if (top == 1 && lo[0] == 0 && hi[1] == max - 1 && hi[0] + 2 == lo[1])
             {
                 BitArray s1 = new BitArray(max); s1[hi[0] + 1] = true;
                 gen.Write("!"); PutRange(s1);
             }
             else
             {
                 gen.Write("(");
                 for (i = 0; i <= top; i++)
                 {
                     if (hi[i] == lo[i]) gen.Write("ch == {0}", Ch((char)lo[i]));
                     else if (lo[i] == 0) gen.Write("ch <= {0}", Ch((char)hi[i]));
                     else if (hi[i] == max - 1) gen.Write("ch >= {0}", Ch((char)lo[i]));
                     else gen.Write("ch >= {0} && ch <= {1}", Ch((char)lo[i]), Ch((char)hi[i]));
                     if (i < top) gen.Write(" || ");
                 }
                 for (i = 0; i <= top; i++)
                 {
                     if (hi[i] == lo[i]) gen.Write("ch == {0}", Ch((char)lo[i]));
                     else if (lo[i] == 0) gen.Write("ch <= {0}", Ch((char)hi[i]));
                     else if (hi[i] == max - 1) gen.Write("ch >= {0}", Ch((char)lo[i]));
                     else gen.Write("ch >= {0} && ch <= {1}", Ch((char)lo[i]), Ch((char)hi[i]));
                     if (i < top) gen.Write(" || ");
                 }
                 gen.Write(")");
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="361" endline="375"><![CDATA[
 
         //---------- String handling
         static char Hex2Char(string s)
         {
             int val = 0;
             for (int i = 0; i < s.Length; i++)
             {
                 char ch = s[i];
                 if ('0' <= ch && ch <= '9') val = 16 * val + (ch - '0');
                 else if ('a' <= ch && ch <= 'f') val = 16 * val + (10 + ch - 'a');
                 else if ('A' <= ch && ch <= 'Z') val = 16 * val + (10 + ch - 'A');
                 else Parser.SemErr(28);
             }
             for (int i = 0; i < s.Length; i++)
             {
                 char ch = s[i];
                 if ('0' <= ch && ch <= '9') val = 16 * val + (ch - '0');
                 else if ('a' <= ch && ch <= 'f') val = 16 * val + (10 + ch - 'a');
                 else if ('A' <= ch && ch <= 'Z') val = 16 * val + (10 + ch - 'A');
                 else Parser.SemErr(28);
             }
             return (char)val;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="376" endline="382"><![CDATA[
 
         static string Char2Hex(char ch)
         {
             StringWriter w = new StringWriter();
             w.Write("\\u{0
             return w.ToString();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="383" endline="426"><![CDATA[
 
         public static string Unescape(string s)
         {
             /* replaces escape sequences in s by their Unicode values. */
             StringBuilder buf = new StringBuilder();
             int i = 0;
             while (i < s.Length)
             {
                 if (s[i] == '\\')
                 {
                     switch (s[i + 1])
                     {
                         case '\\'
                         case '\''
                         case '\"'
                         case 'r'
                         case 'n'
                         case 't'
                         case '0'
                         case 'a'
                         case 'b'
                         case 'f'
                         case 'v'
                         case 'u'
                         case 'x'
                             if (i + 6 <= s.Length)
                             {
                                 buf.Append(Hex2Char(s.Substring(i + 2, 4))); i += 6; break;
                             }
                             else
                             {
                                 Parser.SemErr(28); i = s.Length; break;
                             }
                         default
                     }
                 }
                 else
                 {
                     buf.Append(s[i]);
                     i++;
                 }
             }
             while (i < s.Length)
             {
                 if (s[i] == '\\')
                 {
                     switch (s[i + 1])
                     {
                         case '\\'
                         case '\''
                         case '\"'
                         case 'r'
                         case 'n'
                         case 't'
                         case '0'
                         case 'a'
                         case 'b'
                         case 'f'
                         case 'v'
                         case 'u'
                         case 'x'
                             if (i + 6 <= s.Length)
                             {
                                 buf.Append(Hex2Char(s.Substring(i + 2, 4))); i += 6; break;
                             }
                             else
                             {
                                 Parser.SemErr(28); i = s.Length; break;
                             }
                         default
                     }
                 }
                 else
                 {
                     buf.Append(s[i]);
                     i++;
                 }
             }
             return buf.ToString();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="427" endline="436"><![CDATA[
 
 
         //---------- State handling
         static State NewState()
         {
             State s = new State();
             if (firstState == null) firstState = s; else lastState.next = s;
             lastState = s;
             return s;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="437" endline="444"><![CDATA[
 
         static void NewTransition(State from, State to, int typ, int sym, int tc)
         {
             if (to == firstState) Parser.SemErr(21);
             Target t = new Target(to);
             Action a = new Action(typ, sym, tc); a.target = t;
             from.AddAction(a);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="445" endline="467"><![CDATA[
 
         static void CombineShifts()
         {
             State state;
             Action a, b, c;
             BitArray seta, setb;
             for (state = firstState; state != null; state = state.next)
             {
                 for (a = state.firstAction; a != null; a = a.next)
                 {
                     b = a.next;
                     while (b != null)
                         if (a.target.state == b.target.state && a.tc == b.tc)
                         {
                             seta = a.Symbols(); setb = b.Symbols();
                             seta.Or(setb);
                             a.ShiftWith(seta);
                             c = b; b = b.next; state.DetachAction(c);
                         }
                         else b = b.next;
                     while (b != null)
                         if (a.target.state == b.target.state && a.tc == b.tc)
                         {
                             seta = a.Symbols(); setb = b.Symbols();
                             seta.Or(setb);
                             a.ShiftWith(seta);
                             c = b; b = b.next; state.DetachAction(c);
                         }
                         else b = b.next;
                 }
                 for (a = state.firstAction; a != null; a = a.next)
                 {
                     b = a.next;
                     while (b != null)
                         if (a.target.state == b.target.state && a.tc == b.tc)
                         {
                             seta = a.Symbols(); setb = b.Symbols();
                             seta.Or(setb);
                             a.ShiftWith(seta);
                             c = b; b = b.next; state.DetachAction(c);
                         }
                         else b = b.next;
                 }
             }
             for (state = firstState; state != null; state = state.next)
             {
                 for (a = state.firstAction; a != null; a = a.next)
                 {
                     b = a.next;
                     while (b != null)
                         if (a.target.state == b.target.state && a.tc == b.tc)
                         {
                             seta = a.Symbols(); setb = b.Symbols();
                             seta.Or(setb);
                             a.ShiftWith(seta);
                             c = b; b = b.next; state.DetachAction(c);
                         }
                         else b = b.next;
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="468" endline="475"><![CDATA[
 
         static void FindUsedStates(State state, BitArray used)
         {
             if (used[state.nr]) return;
             used[state.nr] = true;
             for (Action a = state.firstAction; a != null; a = a.next)
                 FindUsedStates(a.target.state, used);
             for (Action a = state.firstAction; a != null; a = a.next)
                 FindUsedStates(a.target.state, used);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="476" endline="500"><![CDATA[
 
         static void DeleteRedundantStates()
         {
             State[] newState = new State[State.lastNr + 1];
             BitArray used = new BitArray(State.lastNr + 1);
             FindUsedStates(firstState, used);
             // combine equal final states
             for (State s1 = firstState.next; s1 != null; s1 = s1.next) // firstState cannot be final
                 if (used[s1.nr] && s1.endOf != null && s1.firstAction == null && !s1.ctx)
                     for (State s2 = s1.next; s2 != null; s2 = s2.next)
                         if (used[s2.nr] && s1.endOf == s2.endOf && s2.firstAction == null & !s2.ctx)
                         {
                             used[s2.nr] = false; newState[s2.nr] = s1;
                         }
                     for (State s2 = s1.next; s2 != null; s2 = s2.next)
             for (State s1 = firstState.next; s1 != null; s1 = s1.next) // firstState cannot be final
                 if (used[s1.nr] && s1.endOf != null && s1.firstAction == null && !s1.ctx)
                     for (State s2 = s1.next; s2 != null; s2 = s2.next)
                         if (used[s2.nr] && s1.endOf == s2.endOf && s2.firstAction == null & !s2.ctx)
                         {
                             used[s2.nr] = false; newState[s2.nr] = s1;
                         }
             for (State state = firstState; state != null; state = state.next)
                 if (used[state.nr])
                     for (Action a = state.firstAction; a != null; a = a.next)
                         if (!used[a.target.state.nr])
                             a.target.state = newState[a.target.state.nr];
                     for (Action a = state.firstAction; a != null; a = a.next)
             for (State state = firstState; state != null; state = state.next)
                 if (used[state.nr])
                     for (Action a = state.firstAction; a != null; a = a.next)
                         if (!used[a.target.state.nr])
                             a.target.state = newState[a.target.state.nr];
             // delete unused states
             lastState = firstState; State.lastNr = 0; // firstState has number 0
             for (State state = firstState.next; state != null; state = state.next)
                 if (used[state.nr]) { state.nr = ++State.lastNr; lastState = state; }
                 else lastState.next = state.next;
             for (State state = firstState.next; state != null; state = state.next)
                 if (used[state.nr]) { state.nr = ++State.lastNr; lastState = state; }
                 else lastState.next = state.next;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="501" endline="507"><![CDATA[
 
         static State TheState(Node p)
         {
             State state;
             if (p == null) { state = NewState(); state.endOf = curSy; return state; }
             else return p.state;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="508" endline="534"><![CDATA[
 
         static void Step(State from, Node p, BitArray stepped)
         {
             if (p == null) return;
             stepped[p.n] = true;
             switch (p.typ)
             {
                 case Node.clas
                 case Node.chr
                     {
                         NewTransition(from, TheState(p.next), p.typ, p.val, p.code);
                         break;
                     }
                 case Node.alt
                     {
                         Step(from, p.sub, stepped); Step(from, p.down, stepped);
                         break;
                     }
                 case Node.iter
                 case Node.opt
                     {
                         if (p.next != null && !stepped[p.next.n]) Step(from, p.next, stepped);
                         Step(from, p.sub, stepped);
                         break;
                     }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="535" endline="571"><![CDATA[
 
         static void NumberNodes(Node p, State state)
         {
             /* Assigns a state n.state to every node n. There will be a transition from
                n.state to n.next.state triggered by n.val. All nodes in an alternative
                chain are represented by the same state.
             */
             if (p == null) return;
             if (p.state != null) return; // already visited;
             if (state == null) state = NewState();
             p.state = state;
             if (Node.DelGraph(p)) state.endOf = curSy;
             switch (p.typ)
             {
                 case Node.clas
                 case Node.chr
                     {
                         NumberNodes(p.next, null);
                         break;
                     }
                 case Node.opt
                     {
                         NumberNodes(p.next, null); NumberNodes(p.sub, state);
                         break;
                     }
                 case Node.iter
                     {
                         NumberNodes(p.next, state); NumberNodes(p.sub, state);
                         break;
                     }
                 case Node.alt
                     {
                         NumberNodes(p.sub, state); NumberNodes(p.down, state);
                         break;
                     }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="572" endline="602"><![CDATA[
 
         static void FindTrans(Node p, bool start, BitArray marked)
         {
             if (p == null || marked[p.n]) return;
             marked[p.n] = true;
             if (start) Step(p.state, p, new BitArray(Node.nodes.Count)); // start of group of equally numbered nodes
             switch (p.typ)
             {
                 case Node.clas
                 case Node.chr
                     {
                         FindTrans(p.next, true, marked);
                         break;
                     }
                 case Node.opt
                     {
                         FindTrans(p.next, true, marked); FindTrans(p.sub, false, marked);
                         break;
                     }
                 case Node.iter
                     {
                         FindTrans(p.next, false, marked); FindTrans(p.sub, false, marked);
                         break;
                     }
                 case Node.alt
                     {
                         FindTrans(p.sub, false, marked); FindTrans(p.down, false, marked);
                         break;
                     }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="603" endline="610"><![CDATA[
 
         public static void ConvertToStates(Node p, Symbol sym)
         {
             curGraph = p; curSy = sym;
             if (Node.DelGraph(curGraph)) Parser.SemErr(20);
             NumberNodes(curGraph, firstState);
             FindTrans(curGraph, true, new BitArray(Node.nodes.Count));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="611" endline="640"><![CDATA[
 
         static Symbol MatchedDFA(string s, Symbol sym)
         {
             int i, len = s.Length;
             bool weakMatch = false;
             // s has no quotes
             State state = firstState;
             for (i = 0; i < len; i++)
             { // try to match s against existing DFA
                 Action a = state.TheAction(s[i]);
                 if (a == null) break;
                 if (a.typ == Node.clas) weakMatch = true;
                 state = a.target.state;
             }
             for (i = 0; i < len; i++)
             { // try to match s against existing DFA
                 Action a = state.TheAction(s[i]);
                 if (a == null) break;
                 if (a.typ == Node.clas) weakMatch = true;
                 state = a.target.state;
             }
             // don't execute the following block if s was totally consumed and the DFA is in a final state
             if (weakMatch && (i != len || state.endOf == null))
             {
                 state = firstState; i = 0;
                 dirtyDFA = true;
             }
             for (; i < len; i++)
             { // make new DFA for s[i..len-1]
                 State to = NewState();
                 NewTransition(state, to, Node.chr, s[i], Node.normalTrans);
                 state = to;
             }
             for (; i < len; i++)
             { // make new DFA for s[i..len-1]
                 State to = NewState();
                 NewTransition(state, to, Node.chr, s[i], Node.normalTrans);
                 state = to;
             }
             Symbol matchedSym = state.endOf;
             if (state.endOf == null) state.endOf = sym;
             return matchedSym;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="641" endline="654"><![CDATA[
 
         public static void MatchLiteral(Symbol sym)
         { // store string either as token or as literal
             string name = Unescape(sym.name.Substring(1, sym.name.Length - 2));
             if (name.IndexOf('\0') >= 0) Parser.SemErr(27);
             Symbol matchedSym = MatchedDFA(name, sym);
             if (matchedSym == null)
                 sym.tokenKind = Symbol.classToken;
             else
             {
                 matchedSym.tokenKind = Symbol.classLitToken;
                 sym.tokenKind = Symbol.litToken;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="655" endline="690"><![CDATA[
 
         static void SplitActions(State state, Action a, Action b)
         {
             Action c; BitArray seta, setb, setc;
             seta = a.Symbols(); setb = b.Symbols();
             if (Sets.Equals(seta, setb))
             {
                 a.AddTargets(b);
                 state.DetachAction(b);
             }
             else if (Sets.Includes(seta, setb))
             {
                 setc = (BitArray)seta.Clone(); Sets.Subtract(setc, setb);
                 b.AddTargets(a);
                 a.ShiftWith(setc);
             }
             else if (Sets.Includes(setb, seta))
             {
                 setc = (BitArray)setb.Clone(); Sets.Subtract(setc, seta);
                 a.AddTargets(b);
                 b.ShiftWith(setc);
             }
             else
             {
                 setc = (BitArray)seta.Clone(); setc.And(setb);
                 Sets.Subtract(seta, setc);
                 Sets.Subtract(setb, setc);
                 a.ShiftWith(seta);
                 b.ShiftWith(setb);
                 c = new Action(0, 0, Node.normalTrans);  // typ and sym are set in ShiftWith
                 c.AddTargets(a);
                 c.AddTargets(b);
                 c.ShiftWith(setc);
                 state.AddAction(c);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="691" endline="704"><![CDATA[
 
         private static bool Overlap(Action a, Action b)
         {
             BitArray seta, setb;
             if (a.typ == Node.chr)
                 if (b.typ == Node.chr) return a.sym == b.sym;
                 else { setb = CharClass.Set(b.sym); return setb[a.sym]; }
             else
             {
                 seta = CharClass.Set(a.sym);
                 if (b.typ == Node.chr) return seta[b.sym];
                 else { setb = CharClass.Set(b.sym); return Sets.Intersect(seta, setb); }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="705" endline="713"><![CDATA[
 
         static bool MakeUnique(State state)
         { // return true if actions were split
             bool changed = false;
             for (Action a = state.firstAction; a != null; a = a.next)
                 for (Action b = a.next; b != null; b = b.next)
                     if (Overlap(a, b)) { SplitActions(state, a, b); changed = true; }
                 for (Action b = a.next; b != null; b = b.next)
             for (Action a = state.firstAction; a != null; a = a.next)
                 for (Action b = a.next; b != null; b = b.next)
                     if (Overlap(a, b)) { SplitActions(state, a, b); changed = true; }
             return changed;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="714" endline="738"><![CDATA[
 
         static void MeltStates(State state)
         {
             bool changed, ctx;
             BitArray targets;
             Symbol endOf;
             for (Action action = state.firstAction; action != null; action = action.next)
             {
                 if (action.target.next != null)
                 {
                     action.GetTargetStates(out targets, out endOf, out ctx);
                     Melted melt = Melted.StateWithSet(targets);
                     if (melt == null)
                     {
                         State s = NewState(); s.endOf = endOf; s.ctx = ctx;
                         for (Target targ = action.target; targ != null; targ = targ.next)
                             s.MeltWith(targ.state);
                         for (Target targ = action.target; targ != null; targ = targ.next)
                             s.MeltWith(targ.state);
                         do { changed = MakeUnique(s); } while (changed);
                         melt = new Melted(targets, s);
                     }
                     action.target.next = null;
                     action.target.state = melt.state;
                 }
             }
             for (Action action = state.firstAction; action != null; action = action.next)
             {
                 if (action.target.next != null)
                 {
                     action.GetTargetStates(out targets, out endOf, out ctx);
                     Melted melt = Melted.StateWithSet(targets);
                     if (melt == null)
                     {
                         State s = NewState(); s.endOf = endOf; s.ctx = ctx;
                         for (Target targ = action.target; targ != null; targ = targ.next)
                             s.MeltWith(targ.state);
                         do { changed = MakeUnique(s); } while (changed);
                         melt = new Melted(targets, s);
                     }
                     action.target.next = null;
                     action.target.state = melt.state;
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="739" endline="745"><![CDATA[
 
         static void FindCtxStates()
         {
             for (State state = firstState; state != null; state = state.next)
                 for (Action a = state.firstAction; a != null; a = a.next)
                     if (a.tc == Node.contextTrans) a.target.state.ctx = true;
                 for (Action a = state.firstAction; a != null; a = a.next)
             for (State state = firstState; state != null; state = state.next)
                 for (Action a = state.firstAction; a != null; a = a.next)
                     if (a.tc == Node.contextTrans) a.target.state.ctx = true;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="746" endline="760"><![CDATA[
 
         public static void MakeDeterministic()
         {
             State state;
             bool changed;
             lastSimState = lastState.nr;
             maxStates = 2 * lastSimState; // heuristic for set size in Melted.set
             FindCtxStates();
             for (state = firstState; state != null; state = state.next)
                 do { changed = MakeUnique(state); } while (changed);
             for (state = firstState; state != null; state = state.next)
                 do { changed = MakeUnique(state); } while (changed);
             for (state = firstState; state != null; state = state.next)
                 MeltStates(state);
             for (state = firstState; state != null; state = state.next)
                 MeltStates(state);
             DeleteRedundantStates();
             CombineShifts();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="761" endline="784"><![CDATA[
 
         public static void PrintStates()
         {
             trace.WriteLine("\n---------- states ----------");
             for (State state = firstState; state != null; state = state.next)
             {
                 bool first = true;
                 if (state.endOf == null) trace.Write("               ");
                 else trace.Write("E({0,12})", Node.Name(state.endOf.name));
                 trace.Write("{0,3}
                 if (state.firstAction == null) trace.WriteLine();
                 for (Action action = state.firstAction; action != null; action = action.next)
                 {
                     if (first) { trace.Write(" "); first = false; } else trace.Write("                    ");
                     if (action.typ == Node.clas) trace.Write(((CharClass)CharClass.classes[action.sym]).name);
                     else trace.Write("{0, 3}", Ch((char)action.sym));
                     for (Target targ = action.target; targ != null; targ = targ.next)
                         trace.Write(" {0, 3}", targ.state.nr);
                     for (Target targ = action.target; targ != null; targ = targ.next)
                         trace.Write(" {0, 3}", targ.state.nr);
                     if (action.tc == Node.contextTrans) trace.WriteLine(" context"); else trace.WriteLine();
                 }
                 for (Action action = state.firstAction; action != null; action = action.next)
                 {
                     if (first) { trace.Write(" "); first = false; } else trace.Write("                    ");
                     if (action.typ == Node.clas) trace.Write(((CharClass)CharClass.classes[action.sym]).name);
                     else trace.Write("{0, 3}", Ch((char)action.sym));
                     for (Target targ = action.target; targ != null; targ = targ.next)
                         trace.Write(" {0, 3}", targ.state.nr);
                     if (action.tc == Node.contextTrans) trace.WriteLine(" context"); else trace.WriteLine();
                 }
             }
             for (State state = firstState; state != null; state = state.next)
             {
                 bool first = true;
                 if (state.endOf == null) trace.Write("               ");
                 else trace.Write("E({0,12})", Node.Name(state.endOf.name));
                 trace.Write("{0,3}
                 if (state.firstAction == null) trace.WriteLine();
                 for (Action action = state.firstAction; action != null; action = action.next)
                 {
                     if (first) { trace.Write(" "); first = false; } else trace.Write("                    ");
                     if (action.typ == Node.clas) trace.Write(((CharClass)CharClass.classes[action.sym]).name);
                     else trace.Write("{0, 3}", Ch((char)action.sym));
                     for (Target targ = action.target; targ != null; targ = targ.next)
                         trace.Write(" {0, 3}", targ.state.nr);
                     if (action.tc == Node.contextTrans) trace.WriteLine(" context"); else trace.WriteLine();
                 }
             }
             trace.WriteLine("\n---------- character classes ----------");
             CharClass.WriteClasses(trace);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="785" endline="827"><![CDATA[
 
         static void GenComBody(Comment com)
         {
             gen.WriteLine("\t\t\tfor(;;) {");
             gen.Write("\t\t\t\tif ({0}) ", ChCond(com.stop[0])); gen.WriteLine("{");
             if (com.stop.Length == 1)
             {
                 gen.WriteLine("\t\t\t\t\tlevel--;");
                 gen.WriteLine("\t\t\t\t\tif (level == 0) {");
                 gen.WriteLine("\t\t\t\t\t\twhile(line0 < line) {oldEols.Enqueue('\\r'); oldEols.Enqueue('\\n'); line0++;}");
                 gen.WriteLine("\t\t\t\t\t\tNextCh(); return true;");
                 gen.WriteLine("\t\t\t\t\t}");
                 gen.WriteLine("\t\t\t\t\tNextCh();");
             }
             else
             {
                 gen.WriteLine("\t\t\t\t\tNextCh();");
                 gen.Write("\t\t\t\t\tif ({0}) ", ChCond(com.stop[1])); gen.WriteLine("{");
                 gen.WriteLine("\t\t\t\t\t\tlevel--;");
                 gen.WriteLine("\t\t\t\t\t\tif (level == 0) {");
                 gen.WriteLine("\t\t\t\t\t\t\twhile(line0 < line) {oldEols.Enqueue('\\r'); oldEols.Enqueue('\\n'); line0++;}");
                 gen.WriteLine("\t\t\t\t\t\t\tNextCh(); return true;");
                 gen.WriteLine("\t\t\t\t\t\t}");
                 gen.WriteLine("\t\t\t\t\t\tNextCh();");
                 gen.WriteLine("\t\t\t\t\t}");
             }
             if (com.nested)
             {
                 gen.Write("\t\t\t\t}"); gen.Write(" else if ({0}) ", ChCond(com.start[0])); gen.WriteLine("{");
                 if (com.start.Length == 1)
                     gen.WriteLine("\t\t\t\t\tlevel++; NextCh();");
                 else
                 {
                     gen.WriteLine("\t\t\t\t\tNextCh();");
                     gen.Write("\t\t\t\t\tif ({0}) ", ChCond(com.start[1])); gen.WriteLine("{");
                     gen.WriteLine("\t\t\t\t\t\tlevel++; NextCh();");
                     gen.WriteLine("\t\t\t\t\t}");
                 }
             }
             gen.WriteLine("\t\t\t\t} else if (ch == EOF) return false;");
             gen.WriteLine("\t\t\t\telse NextCh();");
             gen.WriteLine("\t\t\t}");
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="828" endline="851"><![CDATA[
 
         static void GenComment(Comment com, int i)
         {
             gen.Write("\n\tstatic bool Comment{0}() ", i); gen.WriteLine("{");
             gen.WriteLine("\t\tint level = 1, line0 = line, lineStart0 = lineStart;");
             if (com.start.Length == 1)
             {
                 gen.WriteLine("\t\tNextCh();");
                 GenComBody(com);
             }
             else
             {
                 gen.WriteLine("\t\tNextCh();");
                 gen.Write("\t\tif ({0}) ", ChCond(com.start[1])); gen.WriteLine("{");
                 gen.WriteLine("\t\t\tNextCh();");
                 GenComBody(com);
                 gen.WriteLine("\t\t} else {");
                 gen.WriteLine("\t\t\tif (ch==CR) {line--; lineStart = lineStart0;}");
                 gen.WriteLine("\t\t\tpos = pos - 2; Buffer.Pos = pos+1; NextCh();");
                 gen.WriteLine("\t\t}");
                 gen.WriteLine("\t\treturn false;");
             }
             gen.WriteLine("\t}");
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="852" endline="875"><![CDATA[
 
         static void CopyFramePart(string stop)
         {
             char startCh = stop[0];
             int endOfStopString = stop.Length - 1;
             int ch = fram.ReadByte();
             while (ch != EOF)
                 if (ch == startCh)
                 {
                     int i = 0;
                     do
                     {
                         if (i == endOfStopString) return; // stop[0..i] found
                         ch = fram.ReadByte(); i++;
                     } while (ch == stop[i]);
                     // stop[0..i-1] found; continue with last read character
                     gen.Write(stop.Substring(0, i));
                 }
                 else
                 {
                     gen.Write((char)ch); ch = fram.ReadByte();
                 }
             while (ch != EOF)
                 if (ch == startCh)
                 {
                     int i = 0;
                     do
                     {
                         if (i == endOfStopString) return; // stop[0..i] found
                         ch = fram.ReadByte(); i++;
                     } while (ch == stop[i]);
                     // stop[0..i-1] found; continue with last read character
                     gen.Write(stop.Substring(0, i));
                 }
                 else
                 {
                     gen.Write((char)ch); ch = fram.ReadByte();
                 }
             Errors.Exception(" -- incomplete or corrupt scanner frame file");
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="876" endline="887"><![CDATA[
 
         static void GenLiterals()
         {
             foreach (Symbol sym in Symbol.terminals)
             {
                 if (sym.tokenKind == Symbol.litToken)
                 {
                     gen.WriteLine("\t\t\tcase {0}
                 }
             }
             foreach (Symbol sym in Symbol.terminals)
             {
                 if (sym.tokenKind == Symbol.litToken)
                 {
                     gen.WriteLine("\t\t\tcase {0}
                 }
             }
             gen.WriteLine("\t\t\tdefault
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="888" endline="938"><![CDATA[
 
         static void WriteState(State state)
         {
             Symbol endOf = state.endOf;
             gen.WriteLine("\t\t\tcase {0}
             bool ctxEnd = state.ctx;
             for (Action action = state.firstAction; action != null; action = action.next)
             {
                 if (action == state.firstAction) gen.Write("\t\t\t\tif (");
                 else gen.Write("\t\t\t\telse if (");
                 if (action.typ == Node.chr) gen.Write(ChCond((char)action.sym));
                 else PutRange(CharClass.Set(action.sym));
                 gen.Write(") {");
                 if (action.tc == Node.contextTrans)
                 {
                     gen.Write("apx++; "); ctxEnd = false;
                 }
                 else if (state.ctx)
                     gen.Write("apx = 0; ");
                 gen.Write("buf.Append(ch); NextCh(); goto case {0};", action.target.state.nr);
                 gen.WriteLine("}");
             }
             for (Action action = state.firstAction; action != null; action = action.next)
             {
                 if (action == state.firstAction) gen.Write("\t\t\t\tif (");
                 else gen.Write("\t\t\t\telse if (");
                 if (action.typ == Node.chr) gen.Write(ChCond((char)action.sym));
                 else PutRange(CharClass.Set(action.sym));
                 gen.Write(") {");
                 if (action.tc == Node.contextTrans)
                 {
                     gen.Write("apx++; "); ctxEnd = false;
                 }
                 else if (state.ctx)
                     gen.Write("apx = 0; ");
                 gen.Write("buf.Append(ch); NextCh(); goto case {0};", action.target.state.nr);
                 gen.WriteLine("}");
             }
             if (state.firstAction == null)
                 gen.Write("\t\t\t\t{");
             else
                 gen.Write("\t\t\t\telse {");
             if (ctxEnd)
             { // final context state
                 gen.WriteLine();
                 gen.WriteLine("\t\t\t\t\tbuf.Length = buf.Length - apx;");
                 gen.WriteLine("\t\t\t\t\tpos = pos - apx - 1; line = t.line;");
                 gen.WriteLine("\t\t\t\t\tBuffer.Pos = pos+1; NextCh();");
                 gen.Write("\t\t\t\t\t");
             }
             if (endOf == null)
             {
                 gen.WriteLine("t.kind = noSym; goto done;}");
             }
             else
             {
                 gen.Write("t.kind = {0}; ", endOf.n);
                 if (endOf.tokenKind == Symbol.classLitToken)
                 {
                     gen.WriteLine("t.val = buf.ToString(); CheckLiteral(); return t;}");
                 }
                 else
                 {
                     gen.WriteLine("goto done;}");
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="939" endline="954"><![CDATA[
 
         static void FillStartTab(int[] startTab)
         {
             startTab[0] = State.lastNr + 1; // eof
             for (Action action = firstState.firstAction; action != null; action = action.next)
             {
                 int targetState = action.target.state.nr;
                 if (action.typ == Node.chr) startTab[action.sym] = targetState;
                 else
                 {
                     BitArray s = CharClass.Set(action.sym);
                     for (int i = 0; i < s.Count; i++)
                         if (s[i]) startTab[i] = targetState;
                     for (int i = 0; i < s.Count; i++)
                         if (s[i]) startTab[i] = targetState;
                 }
             }
             for (Action action = firstState.firstAction; action != null; action = action.next)
             {
                 int targetState = action.target.state.nr;
                 if (action.typ == Node.chr) startTab[action.sym] = targetState;
                 else
                 {
                     BitArray s = CharClass.Set(action.sym);
                     for (int i = 0; i < s.Count; i++)
                         if (s[i]) startTab[i] = targetState;
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="955" endline="1045"><![CDATA[
 
         public static void WriteScanner()
         {
             int i, j;
             int[] startTab = new int[CharClass.charSetSize];
             string dir = System.Environment.CurrentDirectory;
             string fr = dir + "\\Scanner.frame";
             if (!File.Exists(fr))
             {
                 string frameDir = Environment.GetEnvironmentVariable("crframes");
                 if (frameDir != null) fr = frameDir.Trim() + "\\Scanner.frame";
                 if (!File.Exists(fr)) Errors.Exception("-- Cannot find Scanner.frame");
             }
             try
             {
                 fram = new FileStream(fr, FileMode.Open);
             }
             catch (FileNotFoundException)
             {
                 Errors.Exception("-- Cannot open Scanner.frame.");
             }
             try
             {
                 string fn = dir + "\\Scanner.cs";
                 if (File.Exists(fn)) File.Copy(fn, fn + ".old", true);
                 FileStream s = new FileStream(fn, FileMode.Create);
                 gen = new StreamWriter(s);
             }
             catch (IOException)
             {
                 Errors.Exception("-- Cannot generate scanner file.");
             }
             if (dirtyDFA) MakeDeterministic();
             FillStartTab(startTab);
             CopyFramePart("-->namespace");
             gen.Write(Tab.gramSy.name);
             CopyFramePart("-->declarations");
             gen.WriteLine("\tconst int noSym = {0};", Tab.noSym.n);
             gen.WriteLine("\tstatic short[] start = {");
             for (i = 0; i < CharClass.charSetSize / 16; i++)
             {
                 gen.Write("\t");
                 for (j = 0; j < 16; j++)
                     gen.Write("{0,3},", startTab[16 * i + j]);
                 for (j = 0; j < 16; j++)
                     gen.Write("{0,3},", startTab[16 * i + j]);
                 gen.WriteLine();
             }
             for (i = 0; i < CharClass.charSetSize / 16; i++)
             {
                 gen.Write("\t");
                 for (j = 0; j < 16; j++)
                     gen.Write("{0,3},", startTab[16 * i + j]);
                 gen.WriteLine();
             }
             gen.WriteLine("\t  0};");
             CopyFramePart("-->initialization");
             gen.WriteLine("\t\tignore = new BitArray({0});", CharClass.charSetSize);
             gen.Write("\t\t");
             if (Tab.ignored == null) gen.Write("ignore[' '] = true;");
             else
             {
                 j = 0;
                 for (i = 0; i < Tab.ignored.Count; i++)
                     if (Tab.ignored[i])
                     {
                         gen.Write("ignore[{0}] = true; ", i);
                         if (++j % 4 == 0) { gen.WriteLine(); gen.Write("\t\t"); }
                     }
                 for (i = 0; i < Tab.ignored.Count; i++)
                     if (Tab.ignored[i])
                     {
                         gen.Write("ignore[{0}] = true; ", i);
                         if (++j % 4 == 0) { gen.WriteLine(); gen.Write("\t\t"); }
                     }
             }
             CopyFramePart("-->comment");
             Comment com = Comment.first; i = 0;
             while (com != null)
             {
                 GenComment(com, i);
                 com = com.next; i++;
             }
             while (com != null)
             {
                 GenComment(com, i);
                 com = com.next; i++;
             }
             CopyFramePart("-->literals"); GenLiterals();
             CopyFramePart("-->scan1");
             if (Comment.first != null)
             {
                 gen.Write("\t\tif (");
                 com = Comment.first; i = 0;
                 while (com != null)
                 {
                     gen.Write(ChCond(com.start[0]));
                     gen.Write(" && Comment{0}() ", i);
                     if (com.next != null) gen.Write(" || ");
                     com = com.next; i++;
                 }
                 while (com != null)
                 {
                     gen.Write(ChCond(com.start[0]));
                     gen.Write(" && Comment{0}() ", i);
                     if (com.next != null) gen.Write(" || ");
                     com = com.next; i++;
                 }
                 gen.Write(") return Scan();");
             }
             if (hasCtxMoves) gen.WriteLine("\t\tint apx = 0;");
             CopyFramePart("-->scan2");
             for (State state = firstState.next; state != null; state = state.next)
                 WriteState(state);
             for (State state = firstState.next; state != null; state = state.next)
                 WriteState(state);
             gen.Write("\t\t\tcase " + (State.lastNr + 1) + "
             CopyFramePart("$$$");
             gen.Close();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="1046" endline="1055"><![CDATA[
 
         public static void Init(TextWriter w)
         {
             trace = w;
             firstState = null; lastState = null; State.lastNr = -1;
             firstState = NewState();
             Melted.first = null; Comment.first = null;
             dirtyDFA = false;
             hasCtxMoves = false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="37" endline="41"><![CDATA[
         public Webber()
         {
             this.Navigate("about
             while (this.Document.Body == null) Application.DoEvents();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="42" endline="57"><![CDATA[
 
         /// <summary>
         /// Get the current selection.
         /// </summary>
         public string Selection
         {
             get
             {
                 IHTMLDocument2 doc = (IHTMLDocument2)this.Document.DomDocument;
                 IHTMLSelectionObject sel = doc.selection;
                 IHTMLTxtRange range = (IHTMLTxtRange)sel.createRange();
                 if (range.text == null)
                     return "";
                 else
                     return range.text.Trim();
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="58" endline="70"><![CDATA[
         }
 
         /// <summary>
         /// Sets the HTML of the document giving the ability to use CSS and scripts.
         /// </summary>
         public string HTML
         {
             set
             {
                 IHTMLDocument2 doc = (IHTMLDocument2)this.Document.DomDocument;
                 doc.write(value);
                 doc.close();
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="71" endline="83"><![CDATA[
         }
 
         /// <summary>
         /// Select the word clicked.
         /// </summary>
         public void SelectWord()
         {
             IHTMLDocument2 doc = (IHTMLDocument2)this.Document.DomDocument;
             IHTMLSelectionObject sel = (IHTMLSelectionObject)doc.selection;
             IHTMLTxtRange rng = (IHTMLTxtRange)sel.createRange();
             rng.expand("word");
             rng.select();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="84" endline="93"><![CDATA[
 
         /// <summary>
         /// Clear any selection.
         /// </summary>
         public void ClearSelection()
         {
             IHTMLDocument2 doc = (IHTMLDocument2)this.Document.DomDocument;
             IHTMLSelectionObject sel = (IHTMLSelectionObject)doc.selection;
             sel.empty();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="94" endline="102"><![CDATA[
 
         /// <summary>
         /// Copy Current Selection.
         /// </summary>
         public void Copy()
         {
             this.Document.ExecCommand("Copy", false, null);
             ClearSelection();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="103" endline="110"><![CDATA[
 
         /// <summary>
         /// Paste data from the clipboard.
         /// </summary>
         public void Paste()
         {
             this.Document.ExecCommand("Paste", false, null);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="111" endline="118"><![CDATA[
 
         /// <summary>
         /// Cut Current Selection.
         /// </summary>
         public void Cut()
         {
             this.Document.ExecCommand("Cut", false, null);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="119" endline="126"><![CDATA[
 
         /// <summary>
         /// Select Everything in the Document.
         /// </summary>
         public void SelectAll()
         {
             this.Document.ExecCommand("SelectAll", false, null);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="127" endline="134"><![CDATA[
 
         /// <summary>
         /// Deletes the Current Selection...
         /// </summary>
         public void Delete()
         {
             this.Document.ExecCommand("Delete", false, null);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="135" endline="156"><![CDATA[
 
         /// <summary>
         /// Find the first occurance of the given text.
         /// </summary>
         /// <param name="text">Text to find.</param>
         /// <returns>Found or not Found</returns>
         public bool FindFirst(string text)
         {
             IHTMLDocument2 doc = (IHTMLDocument2)this.Document.DomDocument;
             IHTMLSelectionObject sel = (IHTMLSelectionObject)doc.selection;
             sel.empty(); // get an empty selection, so we start from the beginning
             IHTMLTxtRange rng = (IHTMLTxtRange)sel.createRange();
             if (rng.findText(text, 1000000000, 0))
             {
                 rng.select();
                 return true;
             }
             else
             {
                 return false;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CocoParser\DFA.cs" startline="157" endline="178"><![CDATA[
 
         /// <summary>
         /// Finds occurances of the given text.
         /// </summary>
         /// <param name="text">Text to find.</param>
         /// <returns>Found or not Found</returns>
         public bool FindNext(string text)
         {
             IHTMLDocument2 doc = (IHTMLDocument2)this.Document.DomDocument;
             IHTMLSelectionObject sel = (IHTMLSelectionObject)doc.selection;
             IHTMLTxtRange rng = (IHTMLTxtRange)sel.createRange();
             rng.collapse(false); // collapse the current selection so we start from the end of the previous range
             if (rng.findText(text, 1000000000, 0))
             {
                 rng.select();
                 return true;
             }
             else
             {
                 return false;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\fHtmlToolTip.cs" startline="24" endline="26"><![CDATA[
         private System.ComponentModel.IContainer components = null;
         public fHtmlToolTip()
         {
             InitializeComponent();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\fHtmlToolTip.cs" startline="27" endline="33"><![CDATA[
 
         /// <summary>
         /// Gets or Sets the WebBrowser Control...
         /// </summary>
         public WebBrowser WebBrowser
         {
             get { return this.WebMain; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\fHtmlToolTip.cs" startline="34" endline="34"><![CDATA[
             set { this.WebMain = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\fHtmlToolTip.cs" startline="35" endline="42"><![CDATA[
         }
 
         protected override bool ShowWithoutActivation
         {
             get
             {
                 return true;// base.ShowWithoutActivation;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\fHtmlToolTip.cs" startline="43" endline="52"><![CDATA[
         }
 
         /// <summary>
         /// Checks if the mouse is inside the window
         /// </summary>
         /// <returns>True if the mouse is inside, False if its not</returns>
         public bool CanClose ()
         {
             return this.DesktopBounds.Contains(MousePosition);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\fHtmlToolTip.cs" startline="31" endline="37"><![CDATA[
         {
             if (disposing && (components != null))
             {
                 components.Dispose();
             }
             base.Dispose(disposing);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\fHtmlToolTip.cs" startline="38" endline="80"><![CDATA[
 
         #region Windows Form Designer generated code
 
         /// <summary>
         /// Required method for Designer support - do not modify
         /// the contents of this method with the code editor.
         /// </summary>
         private void InitializeComponent()
         {
             this.WebMain = new System.Windows.Forms.WebBrowser();
             this.SuspendLayout();
             // 
             // WebMain
             // 
             this.WebMain.AllowNavigation = false;
             this.WebMain.AllowWebBrowserDrop = false;
             this.WebMain.Dock = System.Windows.Forms.DockStyle.Fill;
             this.WebMain.IsWebBrowserContextMenuEnabled = false;
             this.WebMain.Location = new System.Drawing.Point(0, 0);
             this.WebMain.MinimumSize = new System.Drawing.Size(20, 20);
             this.WebMain.Name = "WebMain";
             this.WebMain.ScriptErrorsSuppressed = true;
             this.WebMain.ScrollBarsEnabled = false;
             this.WebMain.Size = new System.Drawing.Size(202, 49);
             this.WebMain.TabIndex = 0;
             // 
             // HtmlToolTip
             // 
             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.BackColor = System.Drawing.SystemColors.Info;
             this.ClientSize = new System.Drawing.Size(202, 49);
             this.ControlBox = false;
             this.Controls.Add(this.WebMain);
             this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedToolWindow;
             this.Name = "HtmlToolTip";
             this.ShowIcon = false;
             this.ShowInTaskbar = false;
             this.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide;
             this.StartPosition = System.Windows.Forms.FormStartPosition.Manual;
             this.ResumeLayout(false);
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\fHtmlToolTip.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\fHtmlToolTip.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\fHtmlToolTip.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\fHtmlToolTip.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\fHtmlToolTip.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\fHtmlToolTip.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\fHtmlToolTip.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\fHtmlToolTip.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="24" endline="84"><![CDATA[
         private System.ComponentModel.IContainer components = null;
         public Find(MainForm main)
         {
             InitializeComponent();
 
             this.m_MainForm = main;
             this.m_Trace = new TraceDelegate(this.Trace);
             this.m_AddTreeNode = new AddTreeNodeDelegate(this.AddNode);
             this.m_FindLocations = new ArrayList();
             this.m_Results = new FindResults();
             this.m_Results.Tree.DoubleClick += new EventHandler(Tree_DoubleClick);
             this.cmbFindText.KeyDown += new KeyEventHandler(cmbFindText_KeyDown);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="85" endline="93"><![CDATA[
 
         #endregion
 
         /// <summary>
         /// Gets or Sets the Host Application...
         /// </summary>
         public IPeterPluginHost Host
         {
             get { return this.m_Host; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="94" endline="95"><![CDATA[
 
             set { this.m_Host = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="96" endline="135"><![CDATA[
         }
 
         /// <summary>
         /// Add a node to the FindResults
         /// </summary>
         /// <param name="node">The node to add</param>
         private void AddNode(TreeNode node)
         {
             string file = node.ToolTipText;
             string ext = Path.GetExtension(file);
             if (ext.Trim() == string.Empty)
             {
                 ext = "none";
             }
             if (!this.m_Results.Images.Images.ContainsKey(ext))
             {
                 this.m_Results.Images.Images.Add(ext, Common.GetFileIcon(file, false).ToBitmap());
             }
 
             node.ImageIndex = node.SelectedImageIndex = this.m_Results.Images.Images.IndexOfKey(ext);
 
             this.m_Results.Tree.Nodes.Add(node);
             node.Expand();
 
             // Update count...
             if (this.m_Results.TabText.IndexOf("-") != -1)
             {
                 string[] txt = this.m_Results.TabText.Split('-');
                 string matchCnt = txt[1].Trim();
                 matchCnt = matchCnt.Split(' ')[0].Trim();
                 matchCnt = Convert.ToString(Convert.ToInt32(matchCnt) + node.Nodes.Count);
                 this.m_Results.TabText = "Find Results - " + matchCnt;
                 this.m_Results.TabText += (matchCnt.Equals("1")) ? " result" 
             }
             else
             {
                 this.m_Results.TabText += " - " + node.Nodes.Count.ToString();
                 this.m_Results.TabText += (node.Nodes.Count == 1) ? " result" 
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="136" endline="149"><![CDATA[
 
         /// <summary>
         /// Writes given text to status bar and disables the stop button
         /// if the search is complete
         /// </summary>
         /// <param name="text">Text to Write</param>
         private void Trace(string text)
         {
             if (text.Equals("Search Complete."))
             {
                 this.btnStop.Visible = false;
             }
             this.m_Host.Trace(text);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="150" endline="156"><![CDATA[
 
         protected override void OnClosing(CancelEventArgs e)
         {
             e.Cancel = true;
             this.Hide();
             base.OnClosing(e);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="157" endline="189"><![CDATA[
 
         /// <summary>
         /// Occurs when the Find toolstrip button is clicked
         /// </summary>
         /// <param name="sender">Find Dialog Find ToolStripButton</param>
         /// <param name="e">Events</param>
         private void tsbFind_Click(object sender, EventArgs e)
         {
             tsbFind.Checked = true;
             tsbReplace.Checked = false;
             lblReplace.Enabled = false;
             cmbReplace.Enabled = false;
             this.btnFind.Text = "Find Next";
             this.btnMark.Text = "Mark All";
 
             string text = this.cmbFindIn.SelectedText;
             this.cmbFindIn.Items.Clear();
             this.cmbFindIn.Items.Add(OPEN_DOC);
             this.cmbFindIn.Items.Add(BROWSE);
             this.cmbFindIn.Text = OPEN_DOC;
             for (int a = 0; a < this.m_FindLocations.Count; a++)
             {
                 this.cmbFindIn.Items.Add(this.m_FindLocations[a]);
             }
             for (int a = 0; a < this.m_FindLocations.Count; a++)
             {
                 this.cmbFindIn.Items.Add(this.m_FindLocations[a]);
             }
             this.cmbFindIn.Text = text;
             if (this.cmbFindIn.Text == "")
             {
                 this.cmbFindIn.Text = OPEN_DOC;
             }
 
             ckbFindIn_CheckedChanged(null, null);
             this.cmbFindText.Focus();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="190" endline="216"><![CDATA[
         
         /// <summary>
         /// Occurs when the Replace toolstrip button is clicked
         /// </summary>
         /// <param name="sender">Find Dialog Replace ToolStripButton</param>
         /// <param name="e">Events</param>
         private void tsbReplace_Click(object sender, EventArgs e)
         {
             this.tsbFind.Checked = false;
             this.tsbReplace.Checked = true;
             this.lblReplace.Enabled = true;
             this.cmbReplace.Enabled = true;
 
             this.cmbFindIn.Items.Clear();
             this.cmbFindIn.Items.Add(OPEN_DOC);
             this.cmbFindIn.Text = OPEN_DOC;
             if (this.cmbFindIn.Text == "")
             {
                 this.cmbFindIn.Text = OPEN_DOC;
             }
 
             this.btnFind.Text = "Replace Next";
             this.btnMark.Text = "Replace All";
 
             ckbFindIn_CheckedChanged(null, null);
             this.cmbReplace.Focus();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="217" endline="229"><![CDATA[
 
         /// <summary>
         /// Occurs when Enter key is pressed while focused on the Find ComboBox
         /// </summary>
         /// <param name="sender">Find Dialog Find ComboBox</param>
         /// <param name="e">Events</param>
         private void cmbFindText_KeyDown(object sender, KeyEventArgs e)
         {
             if (e.KeyCode == Keys.Enter)
             {
                 btnFind_Click(null, null);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="230" endline="268"><![CDATA[
 
         /// <summary>
         /// Gets the Regular Expression to search for...
         /// </summary>
         /// <returns>RegEx</returns>
         public Regex GetRegEx()
         {
             string regExString = this.cmbFindText.Text;
 
             if (this.ckbUseRegEx.Checked)
             {
                 // We dont need to do anything...
             }
             else if (this.ckbWildCard.Checked)
             {
                 regExString = regExString.Replace("*", @"\w*");
                 regExString = regExString.Replace("?", @"\w");
 
                 regExString = String.Format("{0}{1}{0}", @"\b", regExString);
             }
             else
             {
                 regExString = Regex.Escape(regExString);
             }
 
             if (this.ckbMatchWord.Checked)
             {
                 regExString = String.Format("{0}{1}{0}", @"\b", regExString);
             }
 
             if (this.ckbMatchCase.Checked)
             {
                 return new Regex(regExString);
             }
             else
             {
                 return new Regex(regExString, RegexOptions.IgnoreCase);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="269" endline="275"><![CDATA[
 
         /// <summary>
         /// Gets the Find Results DockControl...
         /// </summary>
         public FindResults Results
         {
             get { return this.m_Results; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="276" endline="283"><![CDATA[
         }
 
         /// <summary>
         /// Gets if we should search up or not...
         /// </summary>
         public bool FindUp
         {
             get { return this.ckbSearchUp.Checked; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="284" endline="291"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets the Text to Find...
         /// </summary>
         public string FindText
         {
             get { return this.cmbFindText.Text; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="292" endline="293"><![CDATA[
 
             set { this.cmbFindText.Text = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="294" endline="301"><![CDATA[
         }
 
         /// <summary>
         /// Gets the Text to Replace..
         /// </summary>
         public string ReplaceText
         {
             get { return this.cmbReplace.Text; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="302" endline="347"><![CDATA[
         }
 
         /// <summary>
         /// Occurs when the state of the Look In checkbox changes
         /// </summary>
         /// <param name="sender">Find Dialog Look In CheckBox</param>
         /// <param name="e">Events</param>
         private void ckbFindIn_CheckedChanged(object sender, EventArgs e)
         {
             if (tsbFind.Checked)
             {
                 if (ckbFindIn.Checked)
                 {
                     this.cmbFindIn.Enabled = true;
                     this.btnMark.Text = "Find All";
                     this.btnFind.Enabled = false;
                     this.lblFilter.Enabled = true;
                     this.cmbFilter.Enabled = true;
                 }
                 else
                 {
                     this.cmbFindIn.Enabled = false;
                     this.btnMark.Text = "Mark All";
                     this.btnFind.Enabled = true;
                     this.lblFilter.Enabled = false;
                     this.cmbFilter.Enabled = false;
                 }
             }
             else
             {
                 if (ckbFindIn.Checked)
                 {
                     this.cmbFindIn.Enabled = true;
                     this.btnFind.Enabled = false;
                     this.lblFilter.Enabled = true;
                     this.cmbFilter.Enabled = true;
                 }
                 else
                 {
                     this.cmbFindIn.Enabled = false;
                     this.btnFind.Enabled = true;
                     this.lblFilter.Enabled = false;
                     this.cmbFilter.Enabled = false;
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="348" endline="357"><![CDATA[
 
         /// <summary>
         /// Selects the Find tab in the Find Dialog and toggles the Look In CheckBox
         /// </summary>
         /// <param name="files">True to check the Look In CheckBox, False to uncheck it</param>
         public void SetFind(bool files)
         {
             this.ckbFindIn.Checked = files;
             tsbFind_Click(null, null);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="358" endline="367"><![CDATA[
 
         /// <summary>
         /// Selects the Replace tab in the Find Dialog and toggles the Look In CheckBox
         /// </summary>
         /// <param name="files">True to check the Look In CheckBox, False to uncheck it</param>
         public void SetReplace(bool files)
         {
             this.ckbFindIn.Checked = files;
             tsbReplace_Click(null, null);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="368" endline="403"><![CDATA[
 
         /// <summary>
         /// Updates all ComboBoxes
         /// </summary>
         private void UpdateComboBoxes()
         {
             if (!this.cmbFindText.Items.Contains(cmbFindText.Text))
             {
                 this.cmbFindText.Items.Add(cmbFindText.Text);
             }
             if (this.cmbReplace.Enabled)
             {
                 if (!this.cmbReplace.Items.Contains(this.cmbReplace.Text))
                 {
                     this.cmbReplace.Items.Add(this.cmbReplace.Text);
                 }
             }
             if (this.cmbFilter.Enabled)
             {
                 if (!this.cmbFilter.Items.Contains(this.cmbFilter.Text))
                 {
                     this.cmbFilter.Items.Add(this.cmbFilter.Text);
                 }
             }
             if (this.cmbFindIn.Enabled)
             {
                 if (!this.cmbFindIn.Items.Contains(this.cmbFindIn.Text))
                 {
                     this.cmbFindIn.Items.Add(this.cmbFindIn.Text);
                 }
                 if (!this.m_FindLocations.Contains(this.cmbFindIn.Text))
                 {
                     this.m_FindLocations.Add(this.cmbFindIn.Text);
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="404" endline="428"><![CDATA[
 
         /// <summary>
         /// Occurs when the state of the Find In ComboBox changes
         /// </summary>
         /// <param name="sender">Find Dialog Find In ComboBox</param>
         /// <param name="e">Events</param>
         private void cmbFindIn_SelectedIndexChanged(object sender, EventArgs e)
         {
             if (this.cmbFindIn.Text == BROWSE)
             {
                 if (fbdMain.ShowDialog() == DialogResult.OK)
                 {
                     if (!this.cmbFindIn.Items.Contains(fbdMain.SelectedPath))
                     {
                         this.cmbFindIn.Items.Add(fbdMain.SelectedPath);
                         this.m_FindLocations.Add(fbdMain.SelectedPath);
                     }
                     this.cmbFindIn.Text = fbdMain.SelectedPath;
                 }
                 else
                 {
                     this.cmbFindIn.Text = OPEN_DOC;
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="429" endline="452"><![CDATA[
 
         /// <summary>
         /// Find the entered text and pattern in all files in the provided directory
         /// </summary>
         /// <param name="dirObj">Collection containing the string to search for, the directory to search in, 
         /// the filters specified and the regular expression</param>
         public void FindInFiles(object dirObj)
         {
             ArrayList info = (ArrayList)dirObj;
             DirectoryInfo dirInfo = new DirectoryInfo(info[1].ToString());
             string[] filters = info[2].ToString().Split('|');
             foreach (string filter in filters)
             {
                 if (filter.Trim() != string.Empty)
                 {
                     foreach (FileInfo file in dirInfo.GetFiles(filter.Trim(), SearchOption.AllDirectories))
                     {
                         this.FindInFile(file, info[0].ToString(), (Regex)info[3]);
                     }
                     foreach (FileInfo file in dirInfo.GetFiles(filter.Trim(), SearchOption.AllDirectories))
                     {
                         this.FindInFile(file, info[0].ToString(), (Regex)info[3]);
                     }
                 }
             }
             foreach (string filter in filters)
             {
                 if (filter.Trim() != string.Empty)
                 {
                     foreach (FileInfo file in dirInfo.GetFiles(filter.Trim(), SearchOption.AllDirectories))
                     {
                         this.FindInFile(file, info[0].ToString(), (Regex)info[3]);
                     }
                 }
             }
 
             this.Invoke(this.m_Trace, new object[] { "Search Complete." });
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="453" endline="483"><![CDATA[
 
         /// <summary>
         /// Finds the given text and pattern in the given file
         /// </summary>
         /// <param name="file">The file to look in</param>
         /// <param name="searchText">The text to look for</param>
         /// <param name="reg">The regular expression to match</param>
         public void FindInFile(FileInfo file, string searchText, Regex reg)
         {
             this.Invoke(this.m_Trace, new object[] { "Searching " + file.FullName });
             StreamReader sr = new StreamReader(file.FullName);
             string line;
             int lineNum = 1;
             TreeNode nodeRoot = new TreeNode(file.Name);
             nodeRoot.ToolTipText = file.FullName;
             while ((line = sr.ReadLine()) != null)
             {
                 Match m = reg.Match(line);
                 if (m.Success)
                 {
                     TreeNode node = new TreeNode(lineNum.ToString() + " - " + line.Replace("\t"," ").Trim());
                     node.Tag = new FindInfo(m.Index, lineNum, searchText, file.FullName);
                     nodeRoot.Nodes.Add(node);
                 }
                 lineNum++;
             }
             while ((line = sr.ReadLine()) != null)
             {
                 Match m = reg.Match(line);
                 if (m.Success)
                 {
                     TreeNode node = new TreeNode(lineNum.ToString() + " - " + line.Replace("\t"," ").Trim());
                     node.Tag = new FindInfo(m.Index, lineNum, searchText, file.FullName);
                     nodeRoot.Nodes.Add(node);
                 }
                 lineNum++;
             }
             if (nodeRoot.Nodes.Count > 0)
             {
                 this.Invoke(this.m_AddTreeNode, new object[] { nodeRoot });
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="484" endline="510"><![CDATA[
 
         /// <summary>
         /// Occurs when the Find button is clicked
         /// </summary>
         /// <param name="sender">Find Dialog Find Button</param>
         /// <param name="e">Events</param>
         private void btnFind_Click(object sender, EventArgs e)
         {
             this.UpdateComboBoxes();
             if (this.tsbFind.Checked)
             {
                 if (!this.ckbFindIn.Checked)
                 {
                     // Find Next...
                     if(this.m_MainForm.FindNext(this.FindUp))
                         this.Hide();
                 }
             }
             else
             {
                 if (!this.ckbFindIn.Checked)
                 {
                     // Replace Next..
                     this.m_MainForm.ReplaceNext();
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="511" endline="580"><![CDATA[
 
         /// <summary>
         /// Occurs when the Mark All button is clicked
         /// </summary>
         /// <param name="sender">Find Dialog Mark Button</param>
         /// <param name="e">Events</param>
         private void btnMark_Click(object sender, EventArgs e)
         {
             this.UpdateComboBoxes();
             if (this.tsbFind.Checked)
             {
                 if (this.ckbFindIn.Checked)
                 {
                     this.m_Results.Tree.Nodes.Clear();
                     this.m_Results.TabText = "Find Results";
                     if (this.m_Results.DockState == DockState.Unknown)
                     {
                         this.m_Host.AddDockContent(this.m_Results, DockState.DockBottom);
                     }
                     else if (this.m_Results.DockState == DockState.Hidden)
                     {
                         this.m_Results.Show();
                     }
                     // Find All in Files...
                     if (this.cmbFindIn.Text == OPEN_DOC)
                     {
                         this.m_MainForm.FindInOpenFiles();
                     }
                     else
                     {
                         this.m_MainForm.Trace("Building File List...");
                         ArrayList info = new ArrayList();
                         info.Add(this.cmbFindText.Text);
                         info.Add(this.cmbFindIn.Text);
                         info.Add(this.cmbFilter.Text);
                         info.Add(this.GetRegEx());
                         this.btnStop.Visible = true;
 
                         if(this.m_thrdFind != null)
                             if (this.m_thrdFind.IsAlive)
                                 this.m_thrdFind.Abort();
 
                         this.m_thrdFind = null;
                         this.m_thrdFind = new Thread(new ParameterizedThreadStart(FindInFiles));
                         this.m_thrdFind.Start(info);
                     }
                 }
                 else
                 {
                     // Mark All...
                     this.m_MainForm.MarkAll();
                 }
             }
             else
             {
                 if (!this.ckbFindIn.Checked)
                 {
                     // Replace All..
                     this.m_MainForm.ReplaceAll();
                 }
                 else
                 {
                     // Replace All in Files...
                     if (this.cmbFindIn.Text == OPEN_DOC)
                     {
                         this.m_MainForm.ReplaceInOpenFiles();
                     }
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="581" endline="595"><![CDATA[
 
         /// <summary>
         /// Occurs when we double click on a result
         /// </summary>
         /// <param name="sender">FindResults TreeNode</param>
         /// <param name="e">Events</param>
         private void Tree_DoubleClick(object sender, EventArgs e)
         {
             if (this.m_Results.Tree.SelectedNode != null)
             {
                 FindInfo fi = (FindInfo)this.m_Results.Tree.SelectedNode.Tag;
                 this.m_MainForm.CreateEditor(fi.FilePath, Path.GetFileName(fi.FilePath));
                 this.m_MainForm.SelectWord(fi.Line - 1, fi.Index, fi.FindString.Length);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="596" endline="612"><![CDATA[
 
         /// <summary>
         /// Occurs when the Stop button is clicked
         /// </summary>
         /// <param name="sender">Find Dialog Stop Button</param>
         /// <param name="e">Events</param>
         private void btnStop_Click (object sender, EventArgs e)
         {
             if (this.m_thrdFind.IsAlive)
             {
                 this.btnStop.Visible = false;
                 this.m_thrdFind.Abort();
                 this.m_thrdFind = null;
                 Application.DoEvents();
                 this.Trace("Search Aborted...");
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="31" endline="37"><![CDATA[
         {
             if (disposing && (components != null))
             {
                 components.Dispose();
             }
             base.Dispose(disposing);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="38" endline="341"><![CDATA[
 
         #region Windows Form Designer generated code
 
         /// <summary>
         /// Required method for Designer support - do not modify
         /// the contents of this method with the code editor.
         /// </summary>
         private void InitializeComponent()
         {
             System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(Find));
             this.toolStrip1 = new System.Windows.Forms.ToolStrip();
             this.tsbFind = new System.Windows.Forms.ToolStripButton();
             this.toolStripSeparator1 = new System.Windows.Forms.ToolStripSeparator();
             this.tsbReplace = new System.Windows.Forms.ToolStripButton();
             this.lblFilter = new System.Windows.Forms.Label();
             this.cmbFilter = new System.Windows.Forms.ComboBox();
             this.btnMark = new System.Windows.Forms.Button();
             this.btnFind = new System.Windows.Forms.Button();
             this.lblReplace = new System.Windows.Forms.Label();
             this.cmbReplace = new System.Windows.Forms.ComboBox();
             this.ckbFindIn = new System.Windows.Forms.CheckBox();
             this.cmbFindIn = new System.Windows.Forms.ComboBox();
             this.lblFind = new System.Windows.Forms.Label();
             this.cmbFindText = new System.Windows.Forms.ComboBox();
             this.groupBox1 = new System.Windows.Forms.GroupBox();
             this.ckbWildCard = new System.Windows.Forms.CheckBox();
             this.ckbUseRegEx = new System.Windows.Forms.CheckBox();
             this.ckbSearchUp = new System.Windows.Forms.CheckBox();
             this.ckbMatchWord = new System.Windows.Forms.CheckBox();
             this.ckbMatchCase = new System.Windows.Forms.CheckBox();
             this.fbdMain = new System.Windows.Forms.FolderBrowserDialog();
             this.btnStop = new System.Windows.Forms.Button();
             this.toolStrip1.SuspendLayout();
             this.groupBox1.SuspendLayout();
             this.SuspendLayout();
             // 
             // toolStrip1
             // 
             this.toolStrip1.GripStyle = System.Windows.Forms.ToolStripGripStyle.Hidden;
             this.toolStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.tsbFind,
             this.toolStripSeparator1,
             this.tsbReplace});
             this.toolStrip1.Location = new System.Drawing.Point(0, 0);
             this.toolStrip1.Name = "toolStrip1";
             this.toolStrip1.Size = new System.Drawing.Size(490, 25);
             this.toolStrip1.TabIndex = 1;
             this.toolStrip1.Text = "toolStrip1";
             // 
             // tsbFind
             // 
             this.tsbFind.Checked = true;
             this.tsbFind.CheckState = System.Windows.Forms.CheckState.Checked;
             this.tsbFind.Image = ((System.Drawing.Image)(resources.GetObject("tsbFind.Image")));
             this.tsbFind.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.tsbFind.Name = "tsbFind";
             this.tsbFind.Size = new System.Drawing.Size(47, 22);
             this.tsbFind.Text = "Find";
             this.tsbFind.Click += new System.EventHandler(this.tsbFind_Click);
             // 
             // toolStripSeparator1
             // 
             this.toolStripSeparator1.Name = "toolStripSeparator1";
             this.toolStripSeparator1.Size = new System.Drawing.Size(6, 25);
             // 
             // tsbReplace
             // 
             this.tsbReplace.Image = ((System.Drawing.Image)(resources.GetObject("tsbReplace.Image")));
             this.tsbReplace.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.tsbReplace.Name = "tsbReplace";
             this.tsbReplace.Size = new System.Drawing.Size(65, 22);
             this.tsbReplace.Text = "Replace";
             this.tsbReplace.Click += new System.EventHandler(this.tsbReplace_Click);
             // 
             // lblFilter
             // 
             this.lblFilter.AutoSize = true;
             this.lblFilter.Enabled = false;
             this.lblFilter.Location = new System.Drawing.Point(12, 155);
             this.lblFilter.Name = "lblFilter";
             this.lblFilter.Size = new System.Drawing.Size(32, 13);
             this.lblFilter.TabIndex = 31;
             this.lblFilter.Text = "Filter
             // 
             // cmbFilter
             // 
             this.cmbFilter.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                         | System.Windows.Forms.AnchorStyles.Right)));
             this.cmbFilter.AutoCompleteMode = System.Windows.Forms.AutoCompleteMode.Suggest;
             this.cmbFilter.AutoCompleteSource = System.Windows.Forms.AutoCompleteSource.ListItems;
             this.cmbFilter.Enabled = false;
             this.cmbFilter.FormattingEnabled = true;
             this.cmbFilter.Items.AddRange(new object[] {
             "*.*"});
             this.cmbFilter.Location = new System.Drawing.Point(12, 171);
             this.cmbFilter.Name = "cmbFilter";
             this.cmbFilter.Size = new System.Drawing.Size(82, 21);
             this.cmbFilter.TabIndex = 30;
             this.cmbFilter.Text = "*.*";
             // 
             // btnMark
             // 
             this.btnMark.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this.btnMark.Location = new System.Drawing.Point(209, 169);
             this.btnMark.Name = "btnMark";
             this.btnMark.Size = new System.Drawing.Size(75, 23);
             this.btnMark.TabIndex = 26;
             this.btnMark.Text = "Mark All";
             this.btnMark.UseVisualStyleBackColor = true;
             this.btnMark.Click += new System.EventHandler(this.btnMark_Click);
             // 
             // btnFind
             // 
             this.btnFind.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this.btnFind.Location = new System.Drawing.Point(109, 169);
             this.btnFind.Name = "btnFind";
             this.btnFind.Size = new System.Drawing.Size(75, 23);
             this.btnFind.TabIndex = 25;
             this.btnFind.Text = "Find Next";
             this.btnFind.UseVisualStyleBackColor = true;
             this.btnFind.Click += new System.EventHandler(this.btnFind_Click);
             // 
             // lblReplace
             // 
             this.lblReplace.AutoSize = true;
             this.lblReplace.Enabled = false;
             this.lblReplace.Location = new System.Drawing.Point(12, 65);
             this.lblReplace.Name = "lblReplace";
             this.lblReplace.Size = new System.Drawing.Size(72, 13);
             this.lblReplace.TabIndex = 29;
             this.lblReplace.Text = "Replace with
             // 
             // cmbReplace
             // 
             this.cmbReplace.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                         | System.Windows.Forms.AnchorStyles.Right)));
             this.cmbReplace.AutoCompleteMode = System.Windows.Forms.AutoCompleteMode.Suggest;
             this.cmbReplace.AutoCompleteSource = System.Windows.Forms.AutoCompleteSource.ListItems;
             this.cmbReplace.Enabled = false;
             this.cmbReplace.FormattingEnabled = true;
             this.cmbReplace.Location = new System.Drawing.Point(12, 81);
             this.cmbReplace.Name = "cmbReplace";
             this.cmbReplace.Size = new System.Drawing.Size(283, 21);
             this.cmbReplace.TabIndex = 22;
             // 
             // ckbFindIn
             // 
             this.ckbFindIn.AutoSize = true;
             this.ckbFindIn.Location = new System.Drawing.Point(12, 108);
             this.ckbFindIn.Name = "ckbFindIn";
             this.ckbFindIn.Size = new System.Drawing.Size(65, 17);
             this.ckbFindIn.TabIndex = 23;
             this.ckbFindIn.Text = "Look In
             this.ckbFindIn.UseVisualStyleBackColor = true;
             this.ckbFindIn.CheckedChanged += new System.EventHandler(this.ckbFindIn_CheckedChanged);
             // 
             // cmbFindIn
             // 
             this.cmbFindIn.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                         | System.Windows.Forms.AnchorStyles.Right)));
             this.cmbFindIn.AutoCompleteMode = System.Windows.Forms.AutoCompleteMode.Suggest;
             this.cmbFindIn.AutoCompleteSource = System.Windows.Forms.AutoCompleteSource.ListItems;
             this.cmbFindIn.Enabled = false;
             this.cmbFindIn.FormattingEnabled = true;
             this.cmbFindIn.Items.AddRange(new object[] {
             "Open Documents"});
             this.cmbFindIn.Location = new System.Drawing.Point(12, 131);
             this.cmbFindIn.Name = "cmbFindIn";
             this.cmbFindIn.Size = new System.Drawing.Size(283, 21);
             this.cmbFindIn.TabIndex = 24;
             this.cmbFindIn.Text = "Open Documents";
             this.cmbFindIn.SelectedIndexChanged += new System.EventHandler(this.cmbFindIn_SelectedIndexChanged);
             // 
             // lblFind
             // 
             this.lblFind.AutoSize = true;
             this.lblFind.Location = new System.Drawing.Point(12, 25);
             this.lblFind.Name = "lblFind";
             this.lblFind.Size = new System.Drawing.Size(30, 13);
             this.lblFind.TabIndex = 28;
             this.lblFind.Text = "Find
             // 
             // cmbFindText
             // 
             this.cmbFindText.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                         | System.Windows.Forms.AnchorStyles.Right)));
             this.cmbFindText.AutoCompleteMode = System.Windows.Forms.AutoCompleteMode.Suggest;
             this.cmbFindText.AutoCompleteSource = System.Windows.Forms.AutoCompleteSource.ListItems;
             this.cmbFindText.FormattingEnabled = true;
             this.cmbFindText.Location = new System.Drawing.Point(12, 41);
             this.cmbFindText.Name = "cmbFindText";
             this.cmbFindText.Size = new System.Drawing.Size(283, 21);
             this.cmbFindText.TabIndex = 21;
             // 
             // groupBox1
             // 
             this.groupBox1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                         | System.Windows.Forms.AnchorStyles.Right)));
             this.groupBox1.Controls.Add(this.ckbWildCard);
             this.groupBox1.Controls.Add(this.ckbUseRegEx);
             this.groupBox1.Controls.Add(this.ckbSearchUp);
             this.groupBox1.Controls.Add(this.ckbMatchWord);
             this.groupBox1.Controls.Add(this.ckbMatchCase);
             this.groupBox1.Location = new System.Drawing.Point(301, 25);
             this.groupBox1.Name = "groupBox1";
             this.groupBox1.Size = new System.Drawing.Size(175, 143);
             this.groupBox1.TabIndex = 27;
             this.groupBox1.TabStop = false;
             this.groupBox1.Text = "Options";
             // 
             // ckbWildCard
             // 
             this.ckbWildCard.AutoSize = true;
             this.ckbWildCard.Location = new System.Drawing.Point(15, 111);
             this.ckbWildCard.Name = "ckbWildCard";
             this.ckbWildCard.Size = new System.Drawing.Size(99, 17);
             this.ckbWildCard.TabIndex = 10;
             this.ckbWildCard.Text = "Use Wild Cards";
             this.ckbWildCard.UseVisualStyleBackColor = true;
             // 
             // ckbUseRegEx
             // 
             this.ckbUseRegEx.AutoSize = true;
             this.ckbUseRegEx.Location = new System.Drawing.Point(15, 88);
             this.ckbUseRegEx.Name = "ckbUseRegEx";
             this.ckbUseRegEx.Size = new System.Drawing.Size(139, 17);
             this.ckbUseRegEx.TabIndex = 9;
             this.ckbUseRegEx.Text = "Use Regular Expresions";
             this.ckbUseRegEx.UseVisualStyleBackColor = true;
             // 
             // ckbSearchUp
             // 
             this.ckbSearchUp.AutoSize = true;
             this.ckbSearchUp.Location = new System.Drawing.Point(15, 65);
             this.ckbSearchUp.Name = "ckbSearchUp";
             this.ckbSearchUp.Size = new System.Drawing.Size(77, 17);
             this.ckbSearchUp.TabIndex = 8;
             this.ckbSearchUp.Text = "Search Up";
             this.ckbSearchUp.UseVisualStyleBackColor = true;
             // 
             // ckbMatchWord
             // 
             this.ckbMatchWord.AutoSize = true;
             this.ckbMatchWord.Location = new System.Drawing.Point(15, 42);
             this.ckbMatchWord.Name = "ckbMatchWord";
             this.ckbMatchWord.Size = new System.Drawing.Size(119, 17);
             this.ckbMatchWord.TabIndex = 7;
             this.ckbMatchWord.Text = "Match Whole Word";
             this.ckbMatchWord.UseVisualStyleBackColor = true;
             // 
             // ckbMatchCase
             // 
             this.ckbMatchCase.AutoSize = true;
             this.ckbMatchCase.Location = new System.Drawing.Point(15, 19);
             this.ckbMatchCase.Name = "ckbMatchCase";
             this.ckbMatchCase.Size = new System.Drawing.Size(83, 17);
             this.ckbMatchCase.TabIndex = 6;
             this.ckbMatchCase.Text = "Match Case";
             this.ckbMatchCase.UseVisualStyleBackColor = true;
             // 
             // btnStop
             // 
             this.btnStop.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this.btnStop.Location = new System.Drawing.Point(307, 169);
             this.btnStop.Name = "btnStop";
             this.btnStop.Size = new System.Drawing.Size(75, 23);
             this.btnStop.TabIndex = 32;
             this.btnStop.Text = "Stop";
             this.btnStop.UseVisualStyleBackColor = true;
             this.btnStop.Visible = false;
             this.btnStop.Click += new System.EventHandler(this.btnStop_Click);
             // 
             // Find
             // 
             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.ClientSize = new System.Drawing.Size(490, 205);
             this.Controls.Add(this.btnStop);
             this.Controls.Add(this.lblFilter);
             this.Controls.Add(this.cmbFilter);
             this.Controls.Add(this.btnMark);
             this.Controls.Add(this.btnFind);
             this.Controls.Add(this.lblReplace);
             this.Controls.Add(this.cmbReplace);
             this.Controls.Add(this.ckbFindIn);
             this.Controls.Add(this.cmbFindIn);
             this.Controls.Add(this.lblFind);
             this.Controls.Add(this.cmbFindText);
             this.Controls.Add(this.groupBox1);
             this.Controls.Add(this.toolStrip1);
             this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedToolWindow;
             this.Name = "Find";
             this.ShowInTaskbar = false;
             this.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide;
             this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
             this.Text = "Find";
             this.toolStrip1.ResumeLayout(false);
             this.toolStrip1.PerformLayout();
             this.groupBox1.ResumeLayout(false);
             this.groupBox1.PerformLayout();
             this.ResumeLayout(false);
             this.PerformLayout();
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="32" endline="34"><![CDATA[
         {
             for (int i = 1; i <= n; i++) gen.Write('\t');
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="35" endline="41"><![CDATA[
 
         static int Alternatives(Node p)
         {
             int i = 0;
             while (p != null) { i++; p = p.down; }
             return i;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="42" endline="65"><![CDATA[
 
         static void CopyFramePart(string stop)
         {
             char startCh = stop[0];
             int endOfStopString = stop.Length - 1;
             int ch = fram.ReadByte();
             while (ch != EOF)
                 if (ch == startCh)
                 {
                     int i = 0;
                     do
                     {
                         if (i == endOfStopString) return; // stop[0..i] found
                         ch = fram.ReadByte(); i++;
                     } while (ch == stop[i]);
                     // stop[0..i-1] found; continue with last read character
                     gen.Write(stop.Substring(0, i));
                 }
                 else
                 {
                     gen.Write((char)ch); ch = fram.ReadByte();
                 }
             while (ch != EOF)
                 if (ch == startCh)
                 {
                     int i = 0;
                     do
                     {
                         if (i == endOfStopString) return; // stop[0..i] found
                         ch = fram.ReadByte(); i++;
                     } while (ch == stop[i]);
                     // stop[0..i-1] found; continue with last read character
                     gen.Write(stop.Substring(0, i));
                 }
                 else
                 {
                     gen.Write((char)ch); ch = fram.ReadByte();
                 }
             Errors.Exception(" -- incomplete or corrupt parser frame file");
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="66" endline="95"><![CDATA[
 
         static void CopySourcePart(Position pos, int indent)
         {
             // Copy text described by pos from atg to gen
             int ch, nChars, i;
             if (pos != null)
             {
                 Buffer.Pos = pos.beg; ch = Buffer.Read(); nChars = pos.len - 1;
                 Indent(indent);
                 while (nChars >= 0)
                 {
                     while (ch == CR || ch == LF)
                     {
                         gen.WriteLine(); Indent(indent);
                         int lastCh = ch; ch = Buffer.Read(); nChars--;
                         if (ch == LF && lastCh == CR) { ch = Buffer.Read(); nChars--; }
                         for (i = 1; i <= pos.col && ch <= ' '; i++)
                         { // skip blanks at beginning of line
                             ch = Buffer.Read(); nChars--;
                         }
                         for (i = 1; i <= pos.col && ch <= ' '; i++)
                         { // skip blanks at beginning of line
                             ch = Buffer.Read(); nChars--;
                         }
                         if (i <= pos.col) pos.col = i - 1; // heading TABs => not enough blanks
                         if (nChars < 0) goto done;
                     }
                     while (ch == CR || ch == LF)
                     {
                         gen.WriteLine(); Indent(indent);
                         int lastCh = ch; ch = Buffer.Read(); nChars--;
                         if (ch == LF && lastCh == CR) { ch = Buffer.Read(); nChars--; }
                         for (i = 1; i <= pos.col && ch <= ' '; i++)
                         { // skip blanks at beginning of line
                             ch = Buffer.Read(); nChars--;
                         }
                         if (i <= pos.col) pos.col = i - 1; // heading TABs => not enough blanks
                         if (nChars < 0) goto done;
                     }
                     gen.Write((char)ch);
                     ch = Buffer.Read(); nChars--;
                 }
                 while (nChars >= 0)
                 {
                     while (ch == CR || ch == LF)
                     {
                         gen.WriteLine(); Indent(indent);
                         int lastCh = ch; ch = Buffer.Read(); nChars--;
                         if (ch == LF && lastCh == CR) { ch = Buffer.Read(); nChars--; }
                         for (i = 1; i <= pos.col && ch <= ' '; i++)
                         { // skip blanks at beginning of line
                             ch = Buffer.Read(); nChars--;
                         }
                         if (i <= pos.col) pos.col = i - 1; // heading TABs => not enough blanks
                         if (nChars < 0) goto done;
                     }
                     gen.Write((char)ch);
                     ch = Buffer.Read(); nChars--;
                 }
             done
                 if (indent > 0) gen.WriteLine();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="96" endline="111"><![CDATA[
 
         static string EscapedName(string s)
         {
             StringBuilder buf = new StringBuilder();
             for (int i = 1; i < s.Length - 1; i++)
             {
                 switch (s[i])
                 {
                     case '\\'
                     case '\''
                     case '\"'
                     default
                 }
             }
             for (int i = 1; i < s.Length - 1; i++)
             {
                 switch (s[i])
                 {
                     case '\\'
                     case '\''
                     case '\"'
                     default
                 }
             }
             return buf.ToString();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="112" endline="128"><![CDATA[
 
         static void GenErrorMsg(int errTyp, Symbol sym)
         {
             errorNr++;
             err.Write("\t\t\tcase " + errorNr + "
             switch (errTyp)
             {
                 case tErr
                     {
                         if (sym.name[0] == '"') err.Write('"' + EscapedName(sym.name) + " expected");
                         else err.Write('"' + sym.name + " expected"); break;
                     }
                 case altErr
                 case syncErr
             }
             err.WriteLine(" ({0})\"; break;", errorNr);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="129" endline="136"><![CDATA[
 
         static int NewCondSet(BitArray s)
         {
             for (int i = 1; i < symSet.Count; i++) // skip symSet[0] (reserved for union of SYNC sets)
                 if (Sets.Equals(s, (BitArray)symSet[i])) return i;
             for (int i = 1; i < symSet.Count; i++) // skip symSet[0] (reserved for union of SYNC sets)
                 if (Sets.Equals(s, (BitArray)symSet[i])) return i;
             symSet.Add(s.Clone());
             return symSet.Count - 1;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="137" endline="152"><![CDATA[
 
         static void GenCond(BitArray s)
         {
             int n = Sets.Elements(s);
             if (n == 0) gen.Write("false"); // should never happen
             else if (n <= maxTerm)
                 foreach (Symbol sym in Symbol.terminals)
                 {
                     if (s[sym.n])
                     {
                         gen.Write("t.kind == {0}", sym.n);
                         n--; if (n > 0) gen.Write(" || ");
                     }
                 }
                 foreach (Symbol sym in Symbol.terminals)
                 {
                     if (s[sym.n])
                     {
                         gen.Write("t.kind == {0}", sym.n);
                         n--; if (n > 0) gen.Write(" || ");
                     }
                 }
             else gen.Write("StartOf({0})", NewCondSet(s));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="153" endline="158"><![CDATA[
 
         static void PutCaseLabels(BitArray s)
         {
             foreach (Symbol sym in Symbol.terminals)
                 if (s[sym.n]) gen.Write("case {0}
             foreach (Symbol sym in Symbol.terminals)
                 if (s[sym.n]) gen.Write("case {0}
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="159" endline="295"><![CDATA[
 
         static void GenCode(Node p, int indent, BitArray isChecked)
         {
             Node p2;
             BitArray s1, s2;
             while (p != null)
             {
                 switch (p.typ)
                 {
                     case Node.nt
                         {
                             Indent(indent);
                             gen.Write(p.sym.name + "(");
                             CopySourcePart(p.pos, 0);
                             gen.WriteLine(");");
                             break;
                         }
                     case Node.t
                         {
                             Indent(indent);
                             if (isChecked[p.sym.n]) gen.WriteLine("Get();");
                             else gen.WriteLine("Expect({0});", p.sym.n);
                             break;
                         }
                     case Node.wt
                         {
                             Indent(indent);
                             s1 = Tab.Expected(p.next, curSy);
                             s1.Or(Tab.allSyncSets);
                             gen.WriteLine("ExpectWeak({0}, {1});", p.sym.n, NewCondSet(s1));
                             break;
                         }
                     case Node.any
                         {
                             Indent(indent);
                             gen.WriteLine("Get();");
                             break;
                         }
                     case Node.eps
                     case Node.sem
                         {
                             CopySourcePart(p.pos, indent);
                             break;
                         }
                     case Node.sync
                         {
                             Indent(indent);
                             GenErrorMsg(syncErr, curSy);
                             s1 = (BitArray)p.set.Clone();
                             gen.Write("while (!("); GenCond(s1); gen.Write(")) {");
                             gen.Write("Error({0}); Get();", errorNr); gen.WriteLine("}");
                             break;
                         }
                     case Node.alt
                         {
                             s1 = Tab.First(p);
                             bool equal = Sets.Equals(s1, isChecked);
                             int alts = Alternatives(p);
                             if (alts > 5) { Indent(indent); gen.WriteLine("switch (t.kind) {"); }
                             p2 = p;
                             while (p2 != null)
                             {
                                 s1 = Tab.Expected(p2.sub, curSy);
                                 Indent(indent);
                                 if (alts > 5) { PutCaseLabels(s1); gen.WriteLine("{"); }
                                 else if (p2 == p) { gen.Write("if ("); GenCond(s1); gen.WriteLine(") {"); }
                                 else if (p2.down == null && equal) gen.WriteLine("} else {");
                                 else { gen.Write("} else if ("); GenCond(s1); gen.WriteLine(") {"); }
                                 s1.Or(isChecked);
                                 GenCode(p2.sub, indent + 1, s1);
                                 if (alts > 5)
                                 {
                                     Indent(indent); gen.WriteLine("\tbreak;");
                                     Indent(indent); gen.WriteLine("}");
                                 }
                                 p2 = p2.down;
                             }
                             while (p2 != null)
                             {
                                 s1 = Tab.Expected(p2.sub, curSy);
                                 Indent(indent);
                                 if (alts > 5) { PutCaseLabels(s1); gen.WriteLine("{"); }
                                 else if (p2 == p) { gen.Write("if ("); GenCond(s1); gen.WriteLine(") {"); }
                                 else if (p2.down == null && equal) gen.WriteLine("} else {");
                                 else { gen.Write("} else if ("); GenCond(s1); gen.WriteLine(") {"); }
                                 s1.Or(isChecked);
                                 GenCode(p2.sub, indent + 1, s1);
                                 if (alts > 5)
                                 {
                                     Indent(indent); gen.WriteLine("\tbreak;");
                                     Indent(indent); gen.WriteLine("}");
                                 }
                                 p2 = p2.down;
                             }
                             Indent(indent);
                             if (equal)
                             {
                                 gen.WriteLine("}");
                             }
                             else
                             {
                                 GenErrorMsg(altErr, curSy);
                                 if (alts > 5)
                                 {
                                     gen.WriteLine("default
                                     Indent(indent); gen.WriteLine("}");
                                 }
                                 else
                                 {
                                     gen.Write("} "); gen.WriteLine("else { Error(" + /*{0}*/errorNr + "); } "/*, errorNr*/);
                                 }
                             }
                             break;
                         }
                     case Node.iter
                         {
                             Indent(indent);
                             p2 = p.sub;
                             gen.Write("while (");
                             if (p2.typ == Node.wt)
                             {
                                 s1 = Tab.Expected(p2.next, curSy);
                                 s2 = Tab.Expected(p.next, curSy);
                                 gen.Write("WeakSeparator({0},{1},{2}) ", p2.sym.n, NewCondSet(s1), NewCondSet(s2));
                                 s1 = new BitArray(Symbol.terminals.Count); // for inner structure
                                 if (p2.up || p2.next == null) p2 = null; else p2 = p2.next;
                             }
                             else
                             {
                                 s1 = Tab.First(p2); GenCond(s1);
                             }
                             gen.WriteLine(") {");
                             GenCode(p2, indent + 1, s1);
                             Indent(indent); gen.WriteLine("}");
                             break;
                         }
                     case Node.opt
                         s1 = Tab.First(p.sub);
                         if (!Sets.Equals(isChecked, s1))
                         {
                             Indent(indent);
                             gen.Write("if ("); GenCond(s1); gen.WriteLine(") {");
                             GenCode(p.sub, indent + 1, s1);
                             Indent(indent); gen.WriteLine("}");
                         }
                         else GenCode(p.sub, indent, isChecked);
                         break;
                 }
                 if (p.typ != Node.eps && p.typ != Node.sem && p.typ != Node.sync)
                     isChecked.SetAll(false);// = new BitArray(Symbol.terminals.Count);
                 if (p.up) break;
                 p = p.next;
             }
             while (p != null)
             {
                 switch (p.typ)
                 {
                     case Node.nt
                         {
                             Indent(indent);
                             gen.Write(p.sym.name + "(");
                             CopySourcePart(p.pos, 0);
                             gen.WriteLine(");");
                             break;
                         }
                     case Node.t
                         {
                             Indent(indent);
                             if (isChecked[p.sym.n]) gen.WriteLine("Get();");
                             else gen.WriteLine("Expect({0});", p.sym.n);
                             break;
                         }
                     case Node.wt
                         {
                             Indent(indent);
                             s1 = Tab.Expected(p.next, curSy);
                             s1.Or(Tab.allSyncSets);
                             gen.WriteLine("ExpectWeak({0}, {1});", p.sym.n, NewCondSet(s1));
                             break;
                         }
                     case Node.any
                         {
                             Indent(indent);
                             gen.WriteLine("Get();");
                             break;
                         }
                     case Node.eps
                     case Node.sem
                         {
                             CopySourcePart(p.pos, indent);
                             break;
                         }
                     case Node.sync
                         {
                             Indent(indent);
                             GenErrorMsg(syncErr, curSy);
                             s1 = (BitArray)p.set.Clone();
                             gen.Write("while (!("); GenCond(s1); gen.Write(")) {");
                             gen.Write("Error({0}); Get();", errorNr); gen.WriteLine("}");
                             break;
                         }
                     case Node.alt
                         {
                             s1 = Tab.First(p);
                             bool equal = Sets.Equals(s1, isChecked);
                             int alts = Alternatives(p);
                             if (alts > 5) { Indent(indent); gen.WriteLine("switch (t.kind) {"); }
                             p2 = p;
                             while (p2 != null)
                             {
                                 s1 = Tab.Expected(p2.sub, curSy);
                                 Indent(indent);
                                 if (alts > 5) { PutCaseLabels(s1); gen.WriteLine("{"); }
                                 else if (p2 == p) { gen.Write("if ("); GenCond(s1); gen.WriteLine(") {"); }
                                 else if (p2.down == null && equal) gen.WriteLine("} else {");
                                 else { gen.Write("} else if ("); GenCond(s1); gen.WriteLine(") {"); }
                                 s1.Or(isChecked);
                                 GenCode(p2.sub, indent + 1, s1);
                                 if (alts > 5)
                                 {
                                     Indent(indent); gen.WriteLine("\tbreak;");
                                     Indent(indent); gen.WriteLine("}");
                                 }
                                 p2 = p2.down;
                             }
                             Indent(indent);
                             if (equal)
                             {
                                 gen.WriteLine("}");
                             }
                             else
                             {
                                 GenErrorMsg(altErr, curSy);
                                 if (alts > 5)
                                 {
                                     gen.WriteLine("default
                                     Indent(indent); gen.WriteLine("}");
                                 }
                                 else
                                 {
                                     gen.Write("} "); gen.WriteLine("else { Error(" + /*{0}*/errorNr + "); } "/*, errorNr*/);
                                 }
                             }
                             break;
                         }
                     case Node.iter
                         {
                             Indent(indent);
                             p2 = p.sub;
                             gen.Write("while (");
                             if (p2.typ == Node.wt)
                             {
                                 s1 = Tab.Expected(p2.next, curSy);
                                 s2 = Tab.Expected(p.next, curSy);
                                 gen.Write("WeakSeparator({0},{1},{2}) ", p2.sym.n, NewCondSet(s1), NewCondSet(s2));
                                 s1 = new BitArray(Symbol.terminals.Count); // for inner structure
                                 if (p2.up || p2.next == null) p2 = null; else p2 = p2.next;
                             }
                             else
                             {
                                 s1 = Tab.First(p2); GenCond(s1);
                             }
                             gen.WriteLine(") {");
                             GenCode(p2, indent + 1, s1);
                             Indent(indent); gen.WriteLine("}");
                             break;
                         }
                     case Node.opt
                         s1 = Tab.First(p.sub);
                         if (!Sets.Equals(isChecked, s1))
                         {
                             Indent(indent);
                             gen.Write("if ("); GenCond(s1); gen.WriteLine(") {");
                             GenCode(p.sub, indent + 1, s1);
                             Indent(indent); gen.WriteLine("}");
                         }
                         else GenCode(p.sub, indent, isChecked);
                         break;
                 }
                 if (p.typ != Node.eps && p.typ != Node.sem && p.typ != Node.sync)
                     isChecked.SetAll(false);// = new BitArray(Symbol.terminals.Count);
                 if (p.up) break;
                 p = p.next;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="296" endline="340"><![CDATA[
 
         // 07_09_2002 ML 
         static void GenTokens()
         {
             string name;
             foreach (Symbol sym in Symbol.terminals)
             {
                 name = sym.name;
 
                 if (name.Equals("\"") || name.Equals("\"\"\"") || name.Equals("\\\"")) name = "DoubleQuote";
                 name = name.Replace("\"", null);
                 if (name.Equals(".")) name = "Dot";
                 else if (name.Equals("'")) name = "SingleQuote";
                 else if (name.Equals("(")) name = "BraceOpen";
                 else if (name.Equals(")")) name = "BraceClose";
                 else if (name.Equals("{")) name = "CurlBraceOpen";
                 else if (name.Equals("}")) name = "CurlBraceClose";
                 else if (name.Equals("[")) name = "SquareBraceOpen";
                 else if (name.Equals("]")) name = "SquareBraceClose";
                 else if (name.Equals(";")) name = "Semicolon";
                 else if (name.Equals("
                 else if (name.Equals(",")) name = "Comma";
                 else if (name.Equals("*eof*")) name = "Eof";
                 else if (name.Equals("->")) name = "PointerAccess";
 
                 name = name.Replace("\\", "Backslash");
                 name = name.Replace("==", "Equals");
                 name = name.Replace("=", "Assign");
                 name = name.Replace("!", "Not");
                 name = name.Replace("<", "Smaller");
                 name = name.Replace(">", "Bigger");
                 name = name.Replace("~", "Tilde");
                 name = name.Replace("+", "Plus");
                 name = name.Replace("-", "Minus");
                 name = name.Replace("&", "And");
                 name = name.Replace("|", "Or");
                 name = name.Replace("*", "Times");
                 name = name.Replace("/", "Div");
                 name = name.Replace("%", "Mod");
                 name = name.Replace("^", "Pow");
                 name = name.Replace("?", "QuestionMark");
 
                 gen.WriteLine("\tpublic const int _{0}={1};", name, sym.n);
             }
             foreach (Symbol sym in Symbol.terminals)
             {
                 name = sym.name;
 
                 if (name.Equals("\"") || name.Equals("\"\"\"") || name.Equals("\\\"")) name = "DoubleQuote";
                 name = name.Replace("\"", null);
                 if (name.Equals(".")) name = "Dot";
                 else if (name.Equals("'")) name = "SingleQuote";
                 else if (name.Equals("(")) name = "BraceOpen";
                 else if (name.Equals(")")) name = "BraceClose";
                 else if (name.Equals("{")) name = "CurlBraceOpen";
                 else if (name.Equals("}")) name = "CurlBraceClose";
                 else if (name.Equals("[")) name = "SquareBraceOpen";
                 else if (name.Equals("]")) name = "SquareBraceClose";
                 else if (name.Equals(";")) name = "Semicolon";
                 else if (name.Equals("
                 else if (name.Equals(",")) name = "Comma";
                 else if (name.Equals("*eof*")) name = "Eof";
                 else if (name.Equals("->")) name = "PointerAccess";
 
                 name = name.Replace("\\", "Backslash");
                 name = name.Replace("==", "Equals");
                 name = name.Replace("=", "Assign");
                 name = name.Replace("!", "Not");
                 name = name.Replace("<", "Smaller");
                 name = name.Replace(">", "Bigger");
                 name = name.Replace("~", "Tilde");
                 name = name.Replace("+", "Plus");
                 name = name.Replace("-", "Minus");
                 name = name.Replace("&", "And");
                 name = name.Replace("|", "Or");
                 name = name.Replace("*", "Times");
                 name = name.Replace("/", "Div");
                 name = name.Replace("%", "Mod");
                 name = name.Replace("^", "Pow");
                 name = name.Replace("?", "QuestionMark");
 
                 gen.WriteLine("\tpublic const int _{0}={1};", name, sym.n);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="341" endline="352"><![CDATA[
 
         static void GenCodePragmas()
         {
             gen.WriteLine("\t\t\tif (!peekMode) {");																// ML 16_10_2002
             foreach (Symbol sym in Symbol.pragmas)
             {
                 gen.Write("\t\t\t\tif (t.kind == {0}) ", sym.n); gen.WriteLine("{");
                 CopySourcePart(sym.semPos, 4);
                 gen.WriteLine("\t\t\t\t}");
             }
             foreach (Symbol sym in Symbol.pragmas)
             {
                 gen.Write("\t\t\t\tif (t.kind == {0}) ", sym.n); gen.WriteLine("{");
                 CopySourcePart(sym.semPos, 4);
                 gen.WriteLine("\t\t\t\t}");
             }
             gen.WriteLine("\t\t\t}");																								// ML 16_10_2002
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="353" endline="366"><![CDATA[
 
         static void GenProductions()
         {
             foreach (Symbol sym in Symbol.nonterminals)
             {
                 curSy = sym;
                 gen.Write("\tstatic void {0}(", sym.name);
                 CopySourcePart(sym.attrPos, 0);
                 gen.WriteLine(") {");
                 CopySourcePart(sym.semPos, 2);
                 GenCode(sym.graph, 2, new BitArray(Symbol.terminals.Count));
                 gen.WriteLine("\t}"); gen.WriteLine();
             }
             foreach (Symbol sym in Symbol.nonterminals)
             {
                 curSy = sym;
                 gen.Write("\tstatic void {0}(", sym.name);
                 CopySourcePart(sym.attrPos, 0);
                 gen.WriteLine(") {");
                 CopySourcePart(sym.semPos, 2);
                 GenCode(sym.graph, 2, new BitArray(Symbol.terminals.Count));
                 gen.WriteLine("\t}"); gen.WriteLine();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="367" endline="381"><![CDATA[
 
         static void InitSets()
         {
             for (int i = 0; i < symSet.Count; i++)
             {
                 BitArray s = (BitArray)symSet[i];
                 gen.Write("\t{"); int j = 0;
                 foreach (Symbol sym in Symbol.terminals)
                 {
                     if (s[sym.n]) gen.Write("T,"); else gen.Write("x,");
                     j++; if (j % 4 == 0) gen.Write(" ");
                 }
                 foreach (Symbol sym in Symbol.terminals)
                 {
                     if (s[sym.n]) gen.Write("T,"); else gen.Write("x,");
                     j++; if (j % 4 == 0) gen.Write(" ");
                 }
                 if (i == symSet.Count - 1) gen.WriteLine("x}"); else gen.WriteLine("x},");
             }
             for (int i = 0; i < symSet.Count; i++)
             {
                 BitArray s = (BitArray)symSet[i];
                 gen.Write("\t{"); int j = 0;
                 foreach (Symbol sym in Symbol.terminals)
                 {
                     if (s[sym.n]) gen.Write("T,"); else gen.Write("x,");
                     j++; if (j % 4 == 0) gen.Write(" ");
                 }
                 if (i == symSet.Count - 1) gen.WriteLine("x}"); else gen.WriteLine("x},");
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="382" endline="391"><![CDATA[
 
         public static string GetString(int beg, int end)
         {
             StringBuilder s = new StringBuilder(64);
             int oldPos = Buffer.Pos;
             Buffer.Pos = beg;
             while (beg < end) { s.Append((char)Buffer.Read()); beg++; }
             Buffer.Pos = oldPos;
             return s.ToString();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="392" endline="439"><![CDATA[
 
         public static void WriteParser()
         {
             FileStream s;
             symSet.Add(Tab.allSyncSets);
             string dir = System.Environment.CurrentDirectory;
             string fr = dir + "\\Parser.frame";
             if (!File.Exists(fr))
             {
                 string frameDir = Environment.GetEnvironmentVariable("crframes");
                 if (frameDir != null) fr = frameDir.Trim() + "\\Parser.frame";
                 if (!File.Exists(fr)) Errors.Exception("-- Cannot find Parser.frame");
             }
             try
             {
                 fram = new FileStream(fr, FileMode.Open);
             }
             catch (IOException)
             {
                 Errors.Exception("-- Cannot open Parser.frame.");
             }
             try
             {
                 string fn = dir + "\\Parser.cs";
                 if (File.Exists(fn)) File.Copy(fn, fn + ".old", true);
                 s = new FileStream(fn, FileMode.Create);
                 gen = new StreamWriter(s);
             }
             catch (IOException)
             {
                 Errors.Exception("-- Cannot generate parser file");
             }
             err = new StringWriter();
             foreach (Symbol sym in Symbol.terminals) GenErrorMsg(tErr, sym);
             if (usingPos != null) CopySourcePart(usingPos, 0);
             CopyFramePart("-->namespace"); gen.Write(Tab.gramSy.name);
             CopyFramePart("-->tokens"); GenTokens(); // 07_09_2002 ML write the tokenkinds
             CopyFramePart("-->constants");
             gen.WriteLine("\tconst int maxT = {0};", Symbol.terminals.Count - 1);
             CopyFramePart("-->declarations"); CopySourcePart(Tab.semDeclPos, 0);
             CopyFramePart("-->pragmas"); GenCodePragmas();
             CopyFramePart("-->productions"); GenProductions();
             CopyFramePart("-->parseRoot"); gen.WriteLine("\t\t{0}();", Tab.gramSy.name);
             CopyFramePart("-->errors"); gen.Write(err.ToString());
             CopyFramePart("-->initialization"); InitSets();
             CopyFramePart("$$$");
             gen.Close();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="440" endline="449"><![CDATA[
 
         public static void WriteStatistics()
         {
             trace.WriteLine();
             trace.WriteLine("{0} terminals", Symbol.terminals.Count);
             trace.WriteLine("{0} symbols", Symbol.terminals.Count + Symbol.pragmas.Count
                 + Symbol.nonterminals.Count);
             trace.WriteLine("{0} nodes", Node.nodes.Count);
             trace.WriteLine("{0} sets", symSet.Count);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="450" endline="456"><![CDATA[
 
         public static void Init(TextWriter w)
         {
             trace = w;
             errorNr = -1;
             usingPos = null;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="29" endline="29"><![CDATA[
         static ArrayList symSet = new ArrayList();
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="27" endline="68"><![CDATA[
         {
             List<FoldMarker> markers = new List<FoldMarker>();
             Stack<FoldStartMarker> startMarkers = new Stack<FoldStartMarker>();
             try
             {
                 using (XmlTextReader xmlReader = new XmlTextReader(
                     new StringReader(document.TextContent)))
                 {
                     while (xmlReader.Read())
                     {
                         if (xmlReader.NodeType == XmlNodeType.Element &&
                             xmlReader.IsEmptyElement == false)
                         {
                             startMarkers.Push(
                                 CreateStartMarker(xmlReader));
                         }
                         else if (xmlReader.NodeType == XmlNodeType.EndElement)
                         {
                             FoldStartMarker startMarker = startMarkers.Pop();
                             FoldMarker foldMarker = CreateFoldMarker(document, xmlReader, startMarker);
                             if (foldMarker != null)
                             {
                                 markers.Add(foldMarker);
                             }
                         }
                         else if (xmlReader.NodeType == XmlNodeType.Comment)
                         {
                             FoldMarker foldMarker = CreateCommentFoldMarker(document, xmlReader);
                             if (foldMarker != null)
                             {
                                 markers.Add(foldMarker);
                             }
                         }
                     }
                     while (xmlReader.Read())
                     {
                         if (xmlReader.NodeType == XmlNodeType.Element &&
                             xmlReader.IsEmptyElement == false)
                         {
                             startMarkers.Push(
                                 CreateStartMarker(xmlReader));
                         }
                         else if (xmlReader.NodeType == XmlNodeType.EndElement)
                         {
                             FoldStartMarker startMarker = startMarkers.Pop();
                             FoldMarker foldMarker = CreateFoldMarker(document, xmlReader, startMarker);
                             if (foldMarker != null)
                             {
                                 markers.Add(foldMarker);
                             }
                         }
                         else if (xmlReader.NodeType == XmlNodeType.Comment)
                         {
                             FoldMarker foldMarker = CreateCommentFoldMarker(document, xmlReader);
                             if (foldMarker != null)
                             {
                                 markers.Add(foldMarker);
                             }
                         }
                     }
                 }
             }
             catch
             {
                 return (List<FoldMarker>)document.FoldingManager.FoldMarker;
             }
             return markers;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="69" endline="76"><![CDATA[
 
         private FoldStartMarker CreateStartMarker(XmlTextReader xmlReader)
         {
             FoldStartMarker startMarker = new FoldStartMarker(
                 xmlReader.LinePosition - 2, xmlReader.LineNumber - 1,
                 xmlReader.LocalName, xmlReader.Prefix);
             return startMarker;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="77" endline="90"><![CDATA[
 
         private FoldMarker CreateFoldMarker(IDocument document, XmlTextReader reader,
             FoldStartMarker startMarker)
         {
             int endLineNumber = reader.LineNumber - 1;
             FoldMarker marker = null;
             if (endLineNumber > startMarker.LineNumber)
             {
                 marker = new FoldMarker(document, startMarker.LineNumber,
                     startMarker.Column, endLineNumber, reader.LinePosition +
                     startMarker.QualifiedName.Length, FoldType.TypeBody, startMarker.FoldText);
             }
             return marker;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="91" endline="111"><![CDATA[
 
         private FoldMarker CreateCommentFoldMarker(IDocument document, XmlTextReader xmlReader)
         {
             FoldMarker marker = null;
             string comment = xmlReader.Value;
             if (String.IsNullOrEmpty(comment) == false)
             {
                 string[] lines = comment.Replace(Environment.NewLine, "\n").Split('\n');
                 if (lines.Length > 1)
                 {
                     int startLineNumber = xmlReader.LineNumber - 1;
                     int startColumn = xmlReader.LinePosition - 5;
                     int endLine = startLineNumber + lines.Length - 1;
                     int endColumn = lines[lines.Length - 1].Length + 3;
                     string foldText = "...";
                     marker = new FoldMarker(document, startLineNumber, startColumn,
                         endLine, endColumn, FoldType.TypeBody, foldText);
                 }
             }
             return marker;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="16" endline="16"><![CDATA[
             get { return this.attribute; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="17" endline="17"><![CDATA[
             set { this.attribute = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="18" endline="23"><![CDATA[
         }
 
         /// <summary></summary>
         public List<PropertyValue> Values
         {
             get { return this.values; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="24" endline="24"><![CDATA[
             set { this.values = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="11" endline="11"><![CDATA[
         private List<PropertyValue> values = new List<PropertyValue>();
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="16" endline="16"><![CDATA[
             get { return filename; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="17" endline="17"><![CDATA[
             set { filename = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="18" endline="23"><![CDATA[
         }
 
         /// <summary></summary>
         public List<Selector> Selectors
         {
             get { return selectors; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="24" endline="24"><![CDATA[
             set { selectors = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\Find.cs" startline="11" endline="11"><![CDATA[
         private List<Selector> selectors = new List<Selector>();
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="24" endline="48"><![CDATA[
         private System.ComponentModel.IContainer components = null;
         public FileDifference(string[] fileList, string activeFile)
         {
             InitializeComponent();
             this.TabText = "File Difference";
 
             foreach (string file in fileList)
             {
                 if (!string.IsNullOrEmpty(file))
                 {
                     this._cmbFile1.Items.Add(file);
                     this._cmbFile2.Items.Add(file);
                 }
             }
             foreach (string file in fileList)
             {
                 if (!string.IsNullOrEmpty(file))
                 {
                     this._cmbFile1.Items.Add(file);
                     this._cmbFile2.Items.Add(file);
                 }
             }
 
             if (!string.IsNullOrEmpty(activeFile))
             {
                 this._cmbFile1.Text = activeFile;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="49" endline="54"><![CDATA[
 
         #region IPeterPluginTab Members
 
         public void Save()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="55" endline="58"><![CDATA[
 
         public void SaveAs(string filePath)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="59" endline="62"><![CDATA[
 
         public void Cut()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="63" endline="66"><![CDATA[
 
         public void Copy()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="67" endline="70"><![CDATA[
 
         public void Paste()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="71" endline="74"><![CDATA[
 
         public void Undo()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="75" endline="78"><![CDATA[
 
         public void Redo()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="79" endline="82"><![CDATA[
 
         public void Delete()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="83" endline="86"><![CDATA[
 
         public void Duplicate()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="87" endline="90"><![CDATA[
 
         public void Print()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="91" endline="94"><![CDATA[
 
         public void SelectAll()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="95" endline="100"><![CDATA[
 
         public bool CloseTab()
         {
             this.Close();
             return true;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="101" endline="104"><![CDATA[
 
         public IPeterPluginHost Host
         {
             get { return this.m_Host; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="105" endline="106"><![CDATA[
 
             set { this.m_Host = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="107" endline="111"><![CDATA[
         }
 
         public string FileName
         {
             get { return ""; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="112" endline="116"><![CDATA[
         }
 
         public string Selection
         {
             get { return ""; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="117" endline="121"><![CDATA[
         }
 
         public bool AbleToUndo
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="122" endline="126"><![CDATA[
         }
 
         public bool AbleToRedo
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="127" endline="131"><![CDATA[
         }
 
         public bool AbleToPaste
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="132" endline="136"><![CDATA[
         }
 
         public bool AbleToCut
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="137" endline="141"><![CDATA[
         }
 
         public bool AbleToCopy
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="142" endline="146"><![CDATA[
         }
 
         public bool AbleToSelectAll
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="147" endline="151"><![CDATA[
         }
 
         public bool AbleToSave
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="152" endline="156"><![CDATA[
         }
 
         public bool AbleToDelete
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="157" endline="161"><![CDATA[
         }
 
         public bool NeedsSaving
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="162" endline="166"><![CDATA[
         }
 
         public void MarkAll(System.Text.RegularExpressions.Regex reg)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="167" endline="171"><![CDATA[
 
         public bool FindNext(System.Text.RegularExpressions.Regex reg, bool searchUp)
         {
             return this.webber1.FindNext(reg.ToString());
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="172" endline="175"><![CDATA[
 
         public void ReplaceNext(System.Text.RegularExpressions.Regex reg, string replaceWith, bool searchUp)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="176" endline="179"><![CDATA[
 
         public void ReplaceAll(System.Text.RegularExpressions.Regex reg, string replaceWith)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="180" endline="183"><![CDATA[
 
         public void SelectWord(int line, int offset, int wordLeng)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="184" endline="195"><![CDATA[
 
         #endregion
 
         private string GetFileName()
         {
             if (this.ofdMain.ShowDialog() == DialogResult.OK)
             {
                 return ofdMain.FileName;
             }
 
             return "";
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="196" endline="207"><![CDATA[
 
         private bool ValidFile(string file)
         {
             if (!string.IsNullOrEmpty(file))
             {
                 if (File.Exists(file))
                 {
                     return true;
                 }
             }
             return false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="208" endline="302"><![CDATA[
 
         private void _btnCompare_Click (object sender, EventArgs e)
         {
             string file1 = this._cmbFile1.Text.Trim();
             string file2 = this._cmbFile2.Text.Trim();
 
             if (!this.ValidFile(file1))
             {
                 MessageBox.Show("The File specified for File 1 does not Exist.", "Peter", MessageBoxButtons.OK, MessageBoxIcon.Error);
                 return;
             }
             if (!this.ValidFile(file2))
             {
                 MessageBox.Show("The File specified for File 2 does not Exist.", "Peter", MessageBoxButtons.OK, MessageBoxIcon.Error);
                 return;
             }
 
             StreamReader sr1 = new StreamReader(file1);
             StreamReader sr2 = new StreamReader(file2);
             string text1 = sr1.ReadToEnd();
             string text2 = sr2.ReadToEnd();
             sr1.Close();
             sr2.Close();
 
             cDiff.Item[] changes = cDiff.DiffText(text1, text2, this._ckbTrimSpace.Checked, this._ckbIgnoreSpace.Checked, this._ckbIgnoreCase.Checked);
             string[] lines1 = text1.Split('\n');
             string[] lines2 = text2.Split('\n');
             int cnt = 0;
             StringBuilder table = new StringBuilder();
             table.Append("<table cellspacing=\"0\" cellpadding=\"0\">");
             foreach (cDiff.Item item in changes)
             {
                 // unchanged...
                 while ((cnt < item.StartB) && (cnt < lines2.Length))
                 {
                     table.Append("<tr><td>");
                     string text = lines2[cnt];
                     table.Append(cnt.ToString());
                     table.Append("</td><td>");
                     table.Append(System.Web.HttpUtility.HtmlEncode(text).Replace("\t", "&nbsp;&nbsp;&nbsp;&nbsp;"));
                     table.Append("</td><td>");
                     table.Append(cnt.ToString());
                     table.Append("</td><td>");
                     table.Append(System.Web.HttpUtility.HtmlEncode(text).Replace("\t", "&nbsp;&nbsp;&nbsp;&nbsp;"));
                     cnt++;
                     table.Append("</td></tr>");
                 }
                 while ((cnt < item.StartB) && (cnt < lines2.Length))
                 {
                     table.Append("<tr><td>");
                     string text = lines2[cnt];
                     table.Append(cnt.ToString());
                     table.Append("</td><td>");
                     table.Append(System.Web.HttpUtility.HtmlEncode(text).Replace("\t", "&nbsp;&nbsp;&nbsp;&nbsp;"));
                     table.Append("</td><td>");
                     table.Append(cnt.ToString());
                     table.Append("</td><td>");
                     table.Append(System.Web.HttpUtility.HtmlEncode(text).Replace("\t", "&nbsp;&nbsp;&nbsp;&nbsp;"));
                     cnt++;
                     table.Append("</td></tr>");
                 }
 
                 // Deleted...
                 for (int temp = 0; temp < item.deletedA; temp++)
                 {
                     table.Append("<tr><td style=\"background-color
                     string text = lines1[item.StartA + temp];
                     table.Append(Convert.ToString(item.StartA + temp + 1));
                     table.Append(")</td><td style=\"background-color
                     table.Append(System.Web.HttpUtility.HtmlEncode(text).Replace("\t", "&nbsp;&nbsp;&nbsp;&nbsp;"));
                     table.Append("</td><td>");
                     table.Append("</td><td>");
                     table.Append("</td></tr>");
                 }
                 for (int temp = 0; temp < item.deletedA; temp++)
                 {
                     table.Append("<tr><td style=\"background-color
                     string text = lines1[item.StartA + temp];
                     table.Append(Convert.ToString(item.StartA + temp + 1));
                     table.Append(")</td><td style=\"background-color
                     table.Append(System.Web.HttpUtility.HtmlEncode(text).Replace("\t", "&nbsp;&nbsp;&nbsp;&nbsp;"));
                     table.Append("</td><td>");
                     table.Append("</td><td>");
                     table.Append("</td></tr>");
                 }
 
                 // Inserted...
                 while (cnt < item.StartB + item.insertedB)
                 {
                     table.Append("<tr><td>");
                     string text = lines2[cnt];
                     table.Append("</td><td>");
                     table.Append("</td><td style=\"background-color
                     table.Append(cnt.ToString());
                     table.Append("</td><td style=\"background-color
                     table.Append(System.Web.HttpUtility.HtmlEncode(text).Replace("\t", "&nbsp;&nbsp;&nbsp;&nbsp;"));
                     cnt++;
                     table.Append("</td></tr>");
                 }
                 while (cnt < item.StartB + item.insertedB)
                 {
                     table.Append("<tr><td>");
                     string text = lines2[cnt];
                     table.Append("</td><td>");
                     table.Append("</td><td style=\"background-color
                     table.Append(cnt.ToString());
                     table.Append("</td><td style=\"background-color
                     table.Append(System.Web.HttpUtility.HtmlEncode(text).Replace("\t", "&nbsp;&nbsp;&nbsp;&nbsp;"));
                     cnt++;
                     table.Append("</td></tr>");
                 }
             }
             foreach (cDiff.Item item in changes)
             {
                 // unchanged...
                 while ((cnt < item.StartB) && (cnt < lines2.Length))
                 {
                     table.Append("<tr><td>");
                     string text = lines2[cnt];
                     table.Append(cnt.ToString());
                     table.Append("</td><td>");
                     table.Append(System.Web.HttpUtility.HtmlEncode(text).Replace("\t", "&nbsp;&nbsp;&nbsp;&nbsp;"));
                     table.Append("</td><td>");
                     table.Append(cnt.ToString());
                     table.Append("</td><td>");
                     table.Append(System.Web.HttpUtility.HtmlEncode(text).Replace("\t", "&nbsp;&nbsp;&nbsp;&nbsp;"));
                     cnt++;
                     table.Append("</td></tr>");
                 }
 
                 // Deleted...
                 for (int temp = 0; temp < item.deletedA; temp++)
                 {
                     table.Append("<tr><td style=\"background-color
                     string text = lines1[item.StartA + temp];
                     table.Append(Convert.ToString(item.StartA + temp + 1));
                     table.Append(")</td><td style=\"background-color
                     table.Append(System.Web.HttpUtility.HtmlEncode(text).Replace("\t", "&nbsp;&nbsp;&nbsp;&nbsp;"));
                     table.Append("</td><td>");
                     table.Append("</td><td>");
                     table.Append("</td></tr>");
                 }
 
                 // Inserted...
                 while (cnt < item.StartB + item.insertedB)
                 {
                     table.Append("<tr><td>");
                     string text = lines2[cnt];
                     table.Append("</td><td>");
                     table.Append("</td><td style=\"background-color
                     table.Append(cnt.ToString());
                     table.Append("</td><td style=\"background-color
                     table.Append(System.Web.HttpUtility.HtmlEncode(text).Replace("\t", "&nbsp;&nbsp;&nbsp;&nbsp;"));
                     cnt++;
                     table.Append("</td></tr>");
                 }
             }
 
             // unchanged...
             while (cnt < lines2.Length)
             {
                 table.Append("<tr><td>");
                 string text = lines2[cnt];
                 table.Append(cnt.ToString());
                 table.Append("</td><td>");
                 table.Append(System.Web.HttpUtility.HtmlEncode(text).Replace("\t", "&nbsp;&nbsp;&nbsp;&nbsp;"));
                 table.Append("</td><td>");
                 table.Append(cnt.ToString());
                 table.Append("</td><td>");
                 table.Append(System.Web.HttpUtility.HtmlEncode(text).Replace("\t", "&nbsp;&nbsp;&nbsp;&nbsp;"));
                 cnt++;
                 table.Append("</td></tr>");
             }
             while (cnt < lines2.Length)
             {
                 table.Append("<tr><td>");
                 string text = lines2[cnt];
                 table.Append(cnt.ToString());
                 table.Append("</td><td>");
                 table.Append(System.Web.HttpUtility.HtmlEncode(text).Replace("\t", "&nbsp;&nbsp;&nbsp;&nbsp;"));
                 table.Append("</td><td>");
                 table.Append(cnt.ToString());
                 table.Append("</td><td>");
                 table.Append(System.Web.HttpUtility.HtmlEncode(text).Replace("\t", "&nbsp;&nbsp;&nbsp;&nbsp;"));
                 cnt++;
                 table.Append("</td></tr>");
             }
 
             table.Append("</table>");
             this.webber1.HTML = table.ToString();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="303" endline="315"><![CDATA[
 
         private void _btnBrowseFile1_Click (object sender, EventArgs e)
         {
             string file = this.GetFileName();
             if (!string.IsNullOrEmpty(file))
             {
                 this._cmbFile1.Text = file;
                 if (!this._cmbFile1.Items.Contains(file))
                 {
                     this._cmbFile1.Items.Add(file);
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="316" endline="328"><![CDATA[
 
         private void _btnBrowseFile2_Click (object sender, EventArgs e)
         {
             string file = this.GetFileName();
             if (!string.IsNullOrEmpty(file))
             {
                 this._cmbFile2.Text = file;
                 if (!this._cmbFile2.Items.Contains(file))
                 {
                     this._cmbFile2.Items.Add(file);
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="329" endline="333"><![CDATA[
 
         private void _btnBrowseFile2_Click_1 (object sender, EventArgs e)
         {
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="31" endline="37"><![CDATA[
         {
             if (disposing && (components != null))
             {
                 components.Dispose();
             }
             base.Dispose(disposing);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="38" endline="239"><![CDATA[
 
         #region Windows Form Designer generated code
 
         /// <summary>
         /// Required method for Designer support - do not modify
         /// the contents of this method with the code editor.
         /// </summary>
         private void InitializeComponent()
         {
             this.ofdMain = new System.Windows.Forms.OpenFileDialog();
             this._ckbIgnoreCase = new System.Windows.Forms.CheckBox();
             this._cmbFile2 = new System.Windows.Forms.ComboBox();
             this._cmbFile1 = new System.Windows.Forms.ComboBox();
             this._ckbIgnoreSpace = new System.Windows.Forms.CheckBox();
             this._ckbTrimSpace = new System.Windows.Forms.CheckBox();
             this.webber1 = new InternetBrowser.Webber();
             this._grprOptions = new Peter.Grouper();
             this._btnBrowseFile2 = new Peter.VistaButton();
             this._btnBrowseFile1 = new Peter.VistaButton();
             this._btnCompare = new Peter.VistaButton();
             this.label2 = new System.Windows.Forms.Label();
             this.label1 = new System.Windows.Forms.Label();
             this._grprOptions.SuspendLayout();
             this.SuspendLayout();
             // 
             // ofdMain
             // 
             this.ofdMain.Title = "Please Select a File";
             // 
             // _ckbIgnoreCase
             // 
             this._ckbIgnoreCase.AutoSize = true;
             this._ckbIgnoreCase.Location = new System.Drawing.Point(205, 28);
             this._ckbIgnoreCase.Name = "_ckbIgnoreCase";
             this._ckbIgnoreCase.Size = new System.Drawing.Size(83, 17);
             this._ckbIgnoreCase.TabIndex = 7;
             this._ckbIgnoreCase.Text = "Ignore Case";
             this._ckbIgnoreCase.UseVisualStyleBackColor = true;
             // 
             // _cmbFile2
             // 
             this._cmbFile2.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                         | System.Windows.Forms.AnchorStyles.Right)));
             this._cmbFile2.FormattingEnabled = true;
             this._cmbFile2.Location = new System.Drawing.Point(23, 104);
             this._cmbFile2.Name = "_cmbFile2";
             this._cmbFile2.Size = new System.Drawing.Size(660, 21);
             this._cmbFile2.TabIndex = 1;
             // 
             // _cmbFile1
             // 
             this._cmbFile1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                         | System.Windows.Forms.AnchorStyles.Right)));
             this._cmbFile1.FormattingEnabled = true;
             this._cmbFile1.Location = new System.Drawing.Point(23, 64);
             this._cmbFile1.Name = "_cmbFile1";
             this._cmbFile1.Size = new System.Drawing.Size(660, 21);
             this._cmbFile1.TabIndex = 0;
             // 
             // _ckbIgnoreSpace
             // 
             this._ckbIgnoreSpace.AutoSize = true;
             this._ckbIgnoreSpace.Location = new System.Drawing.Point(109, 28);
             this._ckbIgnoreSpace.Name = "_ckbIgnoreSpace";
             this._ckbIgnoreSpace.Size = new System.Drawing.Size(90, 17);
             this._ckbIgnoreSpace.TabIndex = 6;
             this._ckbIgnoreSpace.Text = "Ignore Space";
             this._ckbIgnoreSpace.UseVisualStyleBackColor = true;
             // 
             // _ckbTrimSpace
             // 
             this._ckbTrimSpace.AutoSize = true;
             this._ckbTrimSpace.Location = new System.Drawing.Point(23, 28);
             this._ckbTrimSpace.Name = "_ckbTrimSpace";
             this._ckbTrimSpace.Size = new System.Drawing.Size(80, 17);
             this._ckbTrimSpace.TabIndex = 5;
             this._ckbTrimSpace.Text = "Trim Space";
             this._ckbTrimSpace.UseVisualStyleBackColor = true;
             // 
             // webber1
             // 
             this.webber1.Dock = System.Windows.Forms.DockStyle.Fill;
             this.webber1.Location = new System.Drawing.Point(0, 135);
             this.webber1.MinimumSize = new System.Drawing.Size(20, 20);
             this.webber1.Name = "webber1";
             this.webber1.Size = new System.Drawing.Size(737, 374);
             this.webber1.TabIndex = 3;
             this.webber1.Url = new System.Uri("about
             // 
             // _grprOptions
             // 
             this._grprOptions.BackgroundColor = System.Drawing.Color.White;
             this._grprOptions.BackgroundGradientColor = System.Drawing.Color.White;
             this._grprOptions.BackgroundGradientMode = Peter.Grouper.GroupBoxGradientMode.None;
             this._grprOptions.BorderColor = System.Drawing.Color.Black;
             this._grprOptions.BorderThickness = 1F;
             this._grprOptions.Controls.Add(this._btnBrowseFile2);
             this._grprOptions.Controls.Add(this._btnBrowseFile1);
             this._grprOptions.Controls.Add(this._btnCompare);
             this._grprOptions.Controls.Add(this.label2);
             this._grprOptions.Controls.Add(this.label1);
             this._grprOptions.Controls.Add(this._ckbIgnoreCase);
             this._grprOptions.Controls.Add(this._cmbFile2);
             this._grprOptions.Controls.Add(this._ckbTrimSpace);
             this._grprOptions.Controls.Add(this._ckbIgnoreSpace);
             this._grprOptions.Controls.Add(this._cmbFile1);
             this._grprOptions.CustomGroupBoxColor = System.Drawing.Color.White;
             this._grprOptions.Dock = System.Windows.Forms.DockStyle.Top;
             this._grprOptions.GroupImage = null;
             this._grprOptions.GroupTitle = "Options";
             this._grprOptions.Location = new System.Drawing.Point(0, 0);
             this._grprOptions.Name = "_grprOptions";
             this._grprOptions.Padding = new System.Windows.Forms.Padding(20);
             this._grprOptions.PaintGroupBox = false;
             this._grprOptions.RoundCorners = 10;
             this._grprOptions.ShadowColor = System.Drawing.Color.DarkGray;
             this._grprOptions.ShadowControl = true;
             this._grprOptions.ShadowThickness = 3;
             this._grprOptions.Size = new System.Drawing.Size(737, 135);
             this._grprOptions.TabIndex = 6;
             // 
             // _btnBrowseFile2
             // 
             this._btnBrowseFile2.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this._btnBrowseFile2.BackColor = System.Drawing.Color.Transparent;
             this._btnBrowseFile2.BaseColor = System.Drawing.Color.Transparent;
             this._btnBrowseFile2.ButtonColor = System.Drawing.Color.Silver;
             this._btnBrowseFile2.ButtonText = "...";
             this._btnBrowseFile2.CornerRadius = 0;
             this._btnBrowseFile2.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
             this._btnBrowseFile2.ForeColor = System.Drawing.Color.Black;
             this._btnBrowseFile2.Location = new System.Drawing.Point(689, 99);
             this._btnBrowseFile2.Name = "_btnBrowseFile2";
             this._btnBrowseFile2.Size = new System.Drawing.Size(31, 26);
             this._btnBrowseFile2.TabIndex = 12;
             this._btnBrowseFile2.Click += new System.EventHandler(this._btnBrowseFile2_Click);
             // 
             // _btnBrowseFile1
             // 
             this._btnBrowseFile1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this._btnBrowseFile1.BackColor = System.Drawing.Color.Transparent;
             this._btnBrowseFile1.BaseColor = System.Drawing.Color.Transparent;
             this._btnBrowseFile1.ButtonColor = System.Drawing.Color.Silver;
             this._btnBrowseFile1.ButtonText = "...";
             this._btnBrowseFile1.CornerRadius = 0;
             this._btnBrowseFile1.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
             this._btnBrowseFile1.ForeColor = System.Drawing.Color.Black;
             this._btnBrowseFile1.Location = new System.Drawing.Point(689, 61);
             this._btnBrowseFile1.Name = "_btnBrowseFile1";
             this._btnBrowseFile1.Size = new System.Drawing.Size(31, 26);
             this._btnBrowseFile1.TabIndex = 11;
             this._btnBrowseFile1.Click += new System.EventHandler(this._btnBrowseFile1_Click);
             // 
             // _btnCompare
             // 
             this._btnCompare.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this._btnCompare.BackColor = System.Drawing.Color.Transparent;
             this._btnCompare.BaseColor = System.Drawing.Color.Transparent;
             this._btnCompare.ButtonColor = System.Drawing.Color.Silver;
             this._btnCompare.ButtonText = "Compare";
             this._btnCompare.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
             this._btnCompare.ForeColor = System.Drawing.Color.Black;
             this._btnCompare.Location = new System.Drawing.Point(620, 23);
             this._btnCompare.Name = "_btnCompare";
             this._btnCompare.Size = new System.Drawing.Size(100, 32);
             this._btnCompare.TabIndex = 10;
             this._btnCompare.Click += new System.EventHandler(this._btnCompare_Click);
             // 
             // label2
             // 
             this.label2.AutoSize = true;
             this.label2.Location = new System.Drawing.Point(20, 88);
             this.label2.Name = "label2";
             this.label2.Size = new System.Drawing.Size(35, 13);
             this.label2.TabIndex = 9;
             this.label2.Text = "File 2
             // 
             // label1
             // 
             this.label1.AutoSize = true;
             this.label1.Location = new System.Drawing.Point(20, 48);
             this.label1.Name = "label1";
             this.label1.Size = new System.Drawing.Size(35, 13);
             this.label1.TabIndex = 8;
             this.label1.Text = "File 1
             // 
             // FileDifference
             // 
             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.BackColor = System.Drawing.Color.White;
             this.ClientSize = new System.Drawing.Size(737, 509);
             this.Controls.Add(this.webber1);
             this.Controls.Add(this._grprOptions);
             this.Name = "FileDifference";
             this.TabText = "FileDifference";
             this.Text = "FileDifference";
             this._grprOptions.ResumeLayout(false);
             this._grprOptions.PerformLayout();
             this.ResumeLayout(false);
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\FileDifference.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CParser\CCodeInfo.cs" startline="18" endline="27"><![CDATA[
         public CCodeInfo()
         {
             this.m_Includes = new ArrayList();
             this.m_GlobalVars = new ArrayList();
             this.m_Functions = new ArrayList();
             this.m_Prototypes = new ArrayList();
             this.m_Defines = new ArrayList();
             this.m_Structs = new ArrayList();
             this.m_TypeDefs = new ArrayList();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CParser\CCodeInfo.cs" startline="28" endline="34"><![CDATA[
 
         /// <summary>
         /// Gets or Sets the List of 'includes ...' in the code...
         /// </summary>
         public ArrayList Includes
         {
             get { return this.m_Includes; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CParser\CCodeInfo.cs" startline="35" endline="36"><![CDATA[
 
             set { this.m_Includes = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CParser\CCodeInfo.cs" startline="37" endline="44"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets the List of Global Variables in the code...
         /// </summary>
         public ArrayList GlobalVariables
         {
             get { return this.m_GlobalVars; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CParser\CCodeInfo.cs" startline="45" endline="46"><![CDATA[
 
             set { this.m_GlobalVars = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CParser\CCodeInfo.cs" startline="47" endline="54"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets the List of Functions in the code...
         /// </summary>
         public ArrayList Functions
         {
             get { return this.m_Functions; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CParser\CCodeInfo.cs" startline="55" endline="56"><![CDATA[
 
             set { this.m_Functions = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CParser\CCodeInfo.cs" startline="57" endline="64"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets the List of Prototypes in the code...
         /// </summary>
         public ArrayList Prototypes
         {
             get { return this.m_Prototypes; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CParser\CCodeInfo.cs" startline="65" endline="66"><![CDATA[
 
             set { this.m_Prototypes = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CParser\CCodeInfo.cs" startline="67" endline="74"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets the List of Defines in the Code...
         /// </summary>
         public ArrayList Defines
         {
             get { return this.m_Defines; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CParser\CCodeInfo.cs" startline="75" endline="76"><![CDATA[
 
             set { this.m_Defines = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CParser\CCodeInfo.cs" startline="77" endline="84"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets the List of Structs in the Code...
         /// </summary>
         public ArrayList Structs
         {
             get { return this.m_Structs; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CParser\CCodeInfo.cs" startline="85" endline="86"><![CDATA[
 
             set { this.m_Structs = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CParser\CCodeInfo.cs" startline="87" endline="94"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets the List of TypeDefs in the Code...
         /// </summary>
         public ArrayList TypeDefs
         {
             get { return this.m_TypeDefs; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CParser\CCodeInfo.cs" startline="95" endline="96"><![CDATA[
 
             set { this.m_TypeDefs = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="8" endline="38"><![CDATA[
         private System.ComponentModel.IContainer components = null;
         public OutlookGrid ()
         {
             this.m_Collapsable = true;
             this.m_Layout = false;
             InitializeComponent();
 
             // very important, this indicates that a new default row class is going to be used to fill the grid
             // in this case our custom OutlookGridRow class
             this.SetStyle(ControlStyles.ResizeRedraw, true);
             base.RowTemplate = new OutlookGridRow();
             this.groupTemplate = new OutlookgGridDefaultGroup();
             this.AutoSize = true;
             this.AutoSizeRowsMode = DataGridViewAutoSizeRowsMode.AllCells;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="39" endline="49"><![CDATA[
         #endregion OutlookGrid constructor
 
         #region OutlookGrid property definitions
         /// <summary>
         /// Gets the row that represents the template for all the Rows in the Control
         /// </summary>
         [Browsable(false)]
         [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
         public new DataGridViewRow RowTemplate
         {
             get { return base.RowTemplate; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="50" endline="63"><![CDATA[
         }
 
         private IOutlookGridGroup groupTemplate;
         /// <summary>
         /// Gets or Sets the template for the Group
         /// </summary>
         [Browsable(false)]
         [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
         public IOutlookGridGroup GroupTemplate
         {
             get
             {
                 return groupTemplate;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="64" endline="67"><![CDATA[
             set
             {
                 groupTemplate = value;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="68" endline="77"><![CDATA[
         }
 
         private Image iconCollapse;
         /// <summary>
         /// Gets or Sets the icon for the collapsed OutlookGrid
         /// </summary>
         [Category("Appearance")]
         public Image CollapseIcon
         {
             get { return iconCollapse; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="78" endline="78"><![CDATA[
             set { iconCollapse = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="79" endline="88"><![CDATA[
         }
 
         private Image iconExpand;
         /// <summary>
         /// Gets or Sets the icon for the expanded OutlookGrid
         /// </summary>
         [Category("Appearance")]
         public Image ExpandIcon
         {
             get { return iconExpand; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="89" endline="89"><![CDATA[
             set { iconExpand = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="90" endline="99"><![CDATA[
         }
 
         private bool m_Collapsable;
         /// <summary>
         /// Gets or Sets a Boolean value that specifies whether the OutlookGrid can be collapsed or not
         /// </summary>
         [Category("Appearance")]
         public bool CanCollapse
         {
             get { return this.m_Collapsable; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="100" endline="100"><![CDATA[
             set { this.m_Collapsable = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="101" endline="110"><![CDATA[
         }
 
         private bool m_ShowItemCount;
         /// <summary>
         /// Gets or Sets a Boolean value that specifies whether the item count should be shown or not
         /// </summary>
         [Category("Appearance")]
         public bool ShowItemCount
         {
             get { return this.m_ShowItemCount; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="111" endline="111"><![CDATA[
             set { this.m_ShowItemCount = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="112" endline="130"><![CDATA[
         }
 
         private DataSourceManager dataSource;
         /// <summary>
         /// Gets the DataSource for the OutlookGrid
         /// </summary>
         public new object DataSource
         {
             get
             {
                 if (dataSource == null) return null;
 
                 // special case, datasource is bound to itself.
                 // for client it must look like no binding is set,so return null in this case
                 if (dataSource.DataSource.Equals(this)) return null;
 
                 // return the origional datasource.
                 return dataSource.DataSource;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="131" endline="141"><![CDATA[
         }
         #endregion OutlookGrid property definitions
 
         #region OutlookGrid new methods
         /// <summary>
         /// Collapse all rows
         /// </summary>
         public void CollapseAll ()
         {
             SetGroupCollapse(true);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="142" endline="149"><![CDATA[
 
         /// <summary>
         /// Expand all rows
         /// </summary>
         public void ExpandAll ()
         {
             SetGroupCollapse(false);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="150" endline="158"><![CDATA[
 
         /// <summary>
         /// Clear the groups
         /// </summary>
         public void ClearGroups ()
         {
             groupTemplate.Column = null; //reset
             FillGrid(null);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="159" endline="179"><![CDATA[
 
         /// <summary>
         /// Populates the OutlookGrid with data from the data source
         /// </summary>
         /// <param name="dataSource">The data source</param>
         /// <param name="dataMember">The name of the list or table in the dataSource for which this grid is displaying data</param>
         public void BindData (object dataSource, string dataMember)
         {
             this.DataMember = DataMember;
             if (dataSource == null)
             {
                 this.dataSource = null;
                 Columns.Clear();
             }
             else
             {
                 this.dataSource = new DataSourceManager(dataSource, dataMember);
                 SetupColumns();
                 FillGrid(null);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="180" endline="192"><![CDATA[
 
         /// <summary>
         /// Sorts the OutlookGrid using an implementation of the System.Collections.IComparer interface.
         /// </summary>
         /// <param name="comparer">An implementation of System.Collections.IComparer that performs the custom sorting operation</param>
         public override void Sort (System.Collections.IComparer comparer)
         {
             if (dataSource == null) // if no datasource is set, then bind to the grid itself
                 dataSource = new DataSourceManager(this, null);
 
             dataSource.Sort(comparer);
             FillGrid(groupTemplate);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="193" endline="201"><![CDATA[
 
         /// <summary>
         /// Sets the data source
         /// </summary>
         /// <param name="ds">The data source object</param>
         public void SetDataSource (object ds)
         {
             this.dataSource = new DataSourceManager(ds, null);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="202" endline="215"><![CDATA[
 
         /// <summary>
         /// Sorts the OutlookGrid in ascending or descending order based on the contents of the specified column.
         /// </summary>
         /// <param name="dataGridViewColumn">The column by which to sort the contents of the OutlookGrid</param>
         /// <param name="direction">One of the System.ComponentModel.ListSortDirection values</param>
         public override void Sort (DataGridViewColumn dataGridViewColumn, ListSortDirection direction)
         {
             if (dataSource == null) // if no datasource is set, then bind to the grid itself
                 dataSource = new DataSourceManager(this, null);
 
             dataSource.Sort(new OutlookGridRowComparer(dataGridViewColumn.Index, direction));
             FillGrid(groupTemplate);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="216" endline="226"><![CDATA[
         #endregion OutlookGrid new methods
 
         #region OutlookGrid event handlers
         protected override void OnCellBeginEdit (DataGridViewCellCancelEventArgs e)
         {
             OutlookGridRow row = (OutlookGridRow)base.Rows[e.RowIndex];
             if (row.IsGroupRow)
                 e.Cancel = true;
             else
                 base.OnCellBeginEdit(e);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="227" endline="247"><![CDATA[
 
         protected override void OnCellDoubleClick (DataGridViewCellEventArgs e)
         {
             if (e.RowIndex >= 0)
             {
 
                 OutlookGridRow row = (OutlookGridRow)base.Rows[e.RowIndex];
                 if (row.IsGroupRow && this.m_Collapsable)
                 {
                     row.Group.Collapsed = !row.Group.Collapsed;
 
                     //this is a workaround to make the grid re-calculate it's contents and backgroun bounds
                     // so the background is updated correctly.
                     // this will also invalidate the control, so it will redraw itself
                     row.Visible = false;
                     row.Visible = true;
                     return;
                 }
             }
             base.OnCellClick(e);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="248" endline="269"><![CDATA[
 
         // the OnCellMouseDown is overriden so the control can check to see if the
         // user clicked the + or - sign of the group-row
         protected override void OnCellMouseDown (DataGridViewCellMouseEventArgs e)
         {
             if (e.RowIndex < 0) return;
 
             OutlookGridRow row = (OutlookGridRow)base.Rows[e.RowIndex];
             if (row.IsGroupRow && row.IsIconHit(e) && this.m_Collapsable)
             {
                 System.Diagnostics.Debug.WriteLine("OnCellMouseDown " + DateTime.Now.Ticks.ToString());
                 row.Group.Collapsed = !row.Group.Collapsed;
 
                 //this is a workaround to make the grid re-calculate it's contents and backgroun bounds
                 // so the background is updated correctly.
                 // this will also invalidate the control, so it will redraw itself
                 row.Visible = false;
                 row.Visible = true;
             }
             else
                 base.OnCellMouseDown(e);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="270" endline="274"><![CDATA[
 
         private bool m_Layout;
         internal bool LayoutMode
         {
             get { return this.m_Layout; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="275" endline="280"><![CDATA[
             set 
             { 
                 this.m_Layout = value;
                 if (!this.m_Layout)
                     this.Refresh();
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="281" endline="296"><![CDATA[
         }
 
         protected override void OnPaint (PaintEventArgs e)
         {
             if (!this.m_Layout)
             {
                 base.OnPaint(e);
                 if (this.Rows.Count <= 0)
                 {
                     string text = "Properties";
                     SizeF s = e.Graphics.MeasureString(text, new Font(this.Font.FontFamily.Name, this.Font.Size, FontStyle.Bold));
                     e.Graphics.DrawString(text, new Font(this.Font.FontFamily.Name, this.Font.Size, FontStyle.Bold), Brushes.Black, (this.Width / 2) - (s.Width / 2),
                         (this.Height / 2) - (s.Height / 2));
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="297" endline="301"><![CDATA[
 
         protected override void OnRowsRemoved (DataGridViewRowsRemovedEventArgs e)
         {
             base.OnRowsRemoved(e);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="302" endline="328"><![CDATA[
 
         #endregion OutlookGrid event handlers
 
         #region Grid Fill functions
         /// <summary>
         /// Collapses or Expands the all rows of the OutlookGrid
         /// </summary>
         /// <param name="collapsed">A Boolean value specifying whether to collapse the OutlookGrid or expand it</param>
         private void SetGroupCollapse (bool collapsed)
         {
             if (Rows.Count == 0) return;
             if (groupTemplate == null) return;
 
             // set the default grouping style template collapsed property
             groupTemplate.Collapsed = collapsed;
 
             // loop through all rows to find the GroupRows
             foreach (OutlookGridRow row in Rows)
             {
                 if (row.IsGroupRow)
                     row.Group.Collapsed = collapsed;
             }
             foreach (OutlookGridRow row in Rows)
             {
                 if (row.IsGroupRow)
                     row.Group.Collapsed = collapsed;
             }
 
             // workaround, make the grid refresh properly
             Rows[0].Visible = !Rows[0].Visible;
             Rows[0].Visible = !Rows[0].Visible;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="329" endline="359"><![CDATA[
 
         /// <summary>
         /// Fill Columns of the OutlookGrid with data from the data source
         /// </summary>
         private void SetupColumns ()
         {
             ArrayList list;
 
             // clear all columns, this is a somewhat crude implementation
             // refinement may be welcome.
             Columns.Clear();
 
             // start filling the grid
             if (dataSource == null)
                 return;
             else
                 list = dataSource.Rows;
             if (list.Count <= 0) return;
 
             foreach (string c in dataSource.Columns)
             {
                 int index;
                 DataGridViewColumn column = Columns[c];
                 if (column == null)
                     index = Columns.Add(c, c);
                 else
                     index = column.Index;
                 Columns[index].SortMode = DataGridViewColumnSortMode.Programmatic; // always programmatic!
             }
             foreach (string c in dataSource.Columns)
             {
                 int index;
                 DataGridViewColumn column = Columns[c];
                 if (column == null)
                     index = Columns.Add(c, c);
                 else
                     index = column.Index;
                 Columns[index].SortMode = DataGridViewColumnSortMode.Programmatic; // always programmatic!
             }
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="360" endline="443"><![CDATA[
 
         /// <summary>
         /// the fill grid method fills the grid with the data from the DataSourceManager
         /// It takes the grouping style into account, if it is set.
         /// </summary>
         private void FillGrid (IOutlookGridGroup groupingStyle)
         {
 
             ArrayList list;
             OutlookGridRow row;
 
             this.Rows.Clear();
 
             // start filling the grid
             if (dataSource == null)
                 return;
             else
                 list = dataSource.Rows;
             if (list.Count <= 0) return;
 
             // this block is used of grouping is turned off
             // this will simply list all attributes of each object in the list
             if (groupingStyle == null)
             {
                 foreach (DataSourceRow r in list)
                 {
                     row = (OutlookGridRow)this.RowTemplate.Clone();
                     foreach (object val in r)
                     {
                         DataGridViewCell cell = new DataGridViewTextBoxCell();
                         cell.Value = val.ToString();
                         row.Cells.Add(cell);
                     }
                     foreach (object val in r)
                     {
                         DataGridViewCell cell = new DataGridViewTextBoxCell();
                         cell.Value = val.ToString();
                         row.Cells.Add(cell);
                     }
                     Rows.Add(row);
                 }
                 foreach (DataSourceRow r in list)
                 {
                     row = (OutlookGridRow)this.RowTemplate.Clone();
                     foreach (object val in r)
                     {
                         DataGridViewCell cell = new DataGridViewTextBoxCell();
                         cell.Value = val.ToString();
                         row.Cells.Add(cell);
                     }
                     Rows.Add(row);
                 }
             }
             // this block is used when grouping is used
             // items in the list must be sorted, and then they will automatically be grouped
             else
             {
                 IOutlookGridGroup groupCur = null;
                 object result = null;
                 int counter = 0; // counts number of items in the group
 
                 foreach (DataSourceRow r in list)
                 {
                     row = (OutlookGridRow)this.RowTemplate.Clone();
                     result = r[groupingStyle.Column.Index];
                     if (groupCur != null && groupCur.CompareTo(result) == 0) // item is part of the group
                     {
                         row.Group = groupCur;
                         counter++;
                     }
                     else // item is not part of the group, so create new group
                     {
                         if (groupCur != null)
                             groupCur.ItemCount = counter;
 
                         groupCur = (IOutlookGridGroup)groupingStyle.Clone(); // init
                         groupCur.Value = result;
                         row.Group = groupCur;
                         row.IsGroupRow = true;
                         row.Height = groupCur.Height;
                         row.CreateCells(this, groupCur.Value);
                         Rows.Add(row);
 
                         // add content row after this
                         row = (OutlookGridRow)this.RowTemplate.Clone();
                         row.Group = groupCur;
                         counter = 1; // reset counter for next group
                     }
 
                     foreach (object obj in r)
                     {
                         DataGridViewCell cell = new DataGridViewTextBoxCell();
                         cell.Value = obj.ToString();
                         row.Cells.Add(cell);
                     }
                     foreach (object obj in r)
                     {
                         DataGridViewCell cell = new DataGridViewTextBoxCell();
                         cell.Value = obj.ToString();
                         row.Cells.Add(cell);
                     }
                     Rows.Add(row);
                     groupCur.ItemCount = counter;
                 }
                 foreach (DataSourceRow r in list)
                 {
                     row = (OutlookGridRow)this.RowTemplate.Clone();
                     result = r[groupingStyle.Column.Index];
                     if (groupCur != null && groupCur.CompareTo(result) == 0) // item is part of the group
                     {
                         row.Group = groupCur;
                         counter++;
                     }
                     else // item is not part of the group, so create new group
                     {
                         if (groupCur != null)
                             groupCur.ItemCount = counter;
 
                         groupCur = (IOutlookGridGroup)groupingStyle.Clone(); // init
                         groupCur.Value = result;
                         row.Group = groupCur;
                         row.IsGroupRow = true;
                         row.Height = groupCur.Height;
                         row.CreateCells(this, groupCur.Value);
                         Rows.Add(row);
 
                         // add content row after this
                         row = (OutlookGridRow)this.RowTemplate.Clone();
                         row.Group = groupCur;
                         counter = 1; // reset counter for next group
                     }
 
                     foreach (object obj in r)
                     {
                         DataGridViewCell cell = new DataGridViewTextBoxCell();
                         cell.Value = obj.ToString();
                         row.Cells.Add(cell);
                     }
                     Rows.Add(row);
                     groupCur.ItemCount = counter;
                 }
             }
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="15" endline="21"><![CDATA[
         {
             if (disposing && (components != null))
             {
                 components.Dispose();
             }
             base.Dispose(disposing);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="22" endline="32"><![CDATA[
 
         #region Component Designer generated code
 
         /// <summary> 
         /// Required method for Designer support - do not modify 
         /// the contents of this method with the code editor.
         /// </summary>
         private void InitializeComponent ()
         {
             components = new System.ComponentModel.Container();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="17" endline="33"><![CDATA[
         {
             try
             {
                 XmlDocument xDoc = new XmlDocument();
                 xDoc.Load(fileName);
 
                 FillXMLTree(xDoc.DocumentElement, nodes);
                 foreach (TreeNode n in nodes)
                 {
                     n.Expand();
                 }
                 foreach (TreeNode n in nodes)
                 {
                     n.Expand();
                 }
             }
             catch (Exception ex)
             {
                 Console.WriteLine(ex.Message);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="34" endline="53"><![CDATA[
 
         /// <summary>
         /// Recursively add the XmlNode to the collection
         /// </summary>
         /// <param name="node">The XmlNode to add</param>
         /// <param name="parentNode">The TreeNodeCollection to add to</param>
         private static void FillXMLTree (XmlNode node, TreeNodeCollection parentNode)
         {
             // End recursion if the node is a text type
             if (node != null && node.NodeType != XmlNodeType.Text && node.NodeType != XmlNodeType.CDATA && node.NodeType != XmlNodeType.Comment)
             {
                 TreeNodeCollection tmptreenodecollection = AddNodeToTree(node, parentNode);
 
                 // Add all the children of the current node to the treeview
                 foreach (XmlNode tmpchildnode in node.ChildNodes)
                 {
                     FillXMLTree(tmpchildnode, tmptreenodecollection);
                 }
                 foreach (XmlNode tmpchildnode in node.ChildNodes)
                 {
                     FillXMLTree(tmpchildnode, tmptreenodecollection);
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="54" endline="72"><![CDATA[
 
         /// <summary>
         /// Adds an XmlNode to the tree
         /// </summary>
         /// <param name="node">The XmlNode to add</param>
         /// <param name="parentnode">The TreeNodeCollection to add to</param>
         /// <returns>A TreeNodeCollection that contains all the child nodes, including the node itself, of the XmlNode added</returns>
         private static TreeNodeCollection AddNodeToTree (XmlNode node, TreeNodeCollection parentnode)
         {
             TreeNode newchildnode = CreateTreeNodeFromXmlNode(node);
 
             // if nothing to add, return the parent item
             if (newchildnode == null) return parentnode;
 
             // add the newly created tree node to its parent
             if (parentnode != null) parentnode.Add(newchildnode);
 
             return newchildnode.Nodes;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="73" endline="105"><![CDATA[
 
         /// <summary>
         /// Creates a TreeNode from an XmlNode
         /// </summary>
         /// <param name="node">The XmlNode to create the TreeNode from</param>
         /// <returns>The TreeNode corresponding to the input XmlNode</returns>
         private static TreeNode CreateTreeNodeFromXmlNode (XmlNode node)
         {
             TreeNode tmptreenode = new TreeNode();
 
             if ((node.HasChildNodes) && (node.FirstChild.Value != null))
             {
                 tmptreenode = new TreeNode(node.Name);
                 TreeNode tmptreenode2 = new TreeNode(node.FirstChild.Value);
                 tmptreenode.Nodes.Add(tmptreenode2);
             }
             else if (node.NodeType != XmlNodeType.CDATA)
             {
                 tmptreenode = new TreeNode(node.Name);
             }
 
             if (node.Attributes.Count > 0)
             {
                 tmptreenode.Text += " (";
                 foreach (XmlAttribute att in node.Attributes)
                 {
                     tmptreenode.Text += att.Name + "=\"" + att.Value + "\" ";
                 }
                 foreach (XmlAttribute att in node.Attributes)
                 {
                     tmptreenode.Text += att.Name + "=\"" + att.Value + "\" ";
                 }
                 tmptreenode.Text += ")";
             }
 
             return tmptreenode;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="40" endline="40"><![CDATA[
             get { return group; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="41" endline="41"><![CDATA[
             set { group = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="42" endline="47"><![CDATA[
         }
 
         [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
         public bool IsGroupRow
         {
             get { return isGroupRow; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="48" endline="48"><![CDATA[
             set { isGroupRow = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="49" endline="56"><![CDATA[
         }
 
         #region Constructors
 
         public OutlookGridRow ()
             
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="57" endline="61"><![CDATA[
 
         public OutlookGridRow (IOutlookGridGroup group)
             
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="62" endline="69"><![CDATA[
 
         public OutlookGridRow (IOutlookGridGroup group, bool isGroupRow)
             
         {
             this.group = group;
             this.isGroupRow = isGroupRow;
             this.DefaultCellStyle.WrapMode = DataGridViewTriState.True;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="70" endline="86"><![CDATA[
 
         #endregion
 
         /// <summary>
         /// Gets state of a particular row
         /// </summary>
         /// <param name="rowIndex">The index of the row whose state is requested</param>
         /// <returns>State of the row as a DataGridViewElementStates object</returns>
         public override DataGridViewElementStates GetState (int rowIndex)
         {
             if (!IsGroupRow && group != null && group.Collapsed)
             {
                 return base.GetState(rowIndex) & DataGridViewElementStates.Selected;
             }
 
             return base.GetState(rowIndex);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="87" endline="158"><![CDATA[
 
         /// <summary>
         /// the main difference with a Group row and a regular row is the way it is painted on the control.
         /// the Paint method is therefore overridden and specifies how the Group row is painted.
         /// Note
         /// </summary>
         /// <param name="graphics"></param>
         /// <param name="clipBounds"></param>
         /// <param name="rowBounds"></param>
         /// <param name="rowIndex"></param>
         /// <param name="rowState"></param>
         /// <param name="isFirstDisplayedRow"></param>
         /// <param name="isLastVisibleRow"></param>
         protected override void Paint (System.Drawing.Graphics graphics, System.Drawing.Rectangle clipBounds, System.Drawing.Rectangle rowBounds, int rowIndex, DataGridViewElementStates rowState, bool isFirstDisplayedRow, bool isLastVisibleRow)
         {
             if (this.isGroupRow)
             {
                 OutlookGrid grid = (OutlookGrid)this.DataGridView;
                 int rowHeadersWidth = grid.RowHeadersVisible ? grid.RowHeadersWidth 
 
                 int gridwidth = grid.Columns.GetColumnsWidth(DataGridViewElementStates.Displayed);
                 Rectangle rowBounds2 = grid.GetRowDisplayRectangle(this.Index, true);
 
                 // draw the background
                 using (Brush bgBrush = new SolidBrush(grid.DefaultCellStyle.BackColor))
                 {
                     graphics.FillRectangle(bgBrush, rowBounds.Left + rowHeadersWidth - grid.HorizontalScrollingOffset, rowBounds.Top, gridwidth, rowBounds.Height - 1);
                 }
 
                 int offset = (grid.CanCollapse) ? 23 
                 // draw text, using the current grid font
                 graphics.DrawString(group.Text, new Font(grid.Font.FontFamily.Name, grid.Font.Size, FontStyle.Bold),
                     Brushes.Black, rowHeadersWidth - grid.HorizontalScrollingOffset + offset, rowBounds.Bottom - 18);
 
                 //draw bottom line
                 using (LinearGradientBrush lgb = new LinearGradientBrush(new RectangleF(rowBounds.Left + rowHeadersWidth - grid.HorizontalScrollingOffset,
                     rowBounds.Bottom - 2, gridwidth - 1, 2), SystemColors.GradientActiveCaption, Color.White, LinearGradientMode.Horizontal))
                 {
                     graphics.FillRectangle(lgb, rowBounds.Left + rowHeadersWidth - grid.HorizontalScrollingOffset, rowBounds.Bottom - 2, gridwidth - 1, 2);
                 }
 
                 // draw right vertical bar
                 if (grid.CellBorderStyle == DataGridViewCellBorderStyle.SingleVertical || grid.CellBorderStyle == DataGridViewCellBorderStyle.Single)
                 {
                     using (Brush borderBrush = new SolidBrush(SystemColors.GradientActiveCaption))
                     {
                         graphics.FillRectangle(borderBrush, rowBounds.Left + rowHeadersWidth - grid.HorizontalScrollingOffset + gridwidth - 1,
                             rowBounds.Top, 1, rowBounds.Height);
                     }
                 }
 
                 if (group.Collapsed)
                 {
                     if (grid.ExpandIcon != null)
                         graphics.DrawImage(grid.ExpandIcon, rowBounds.Left + rowHeadersWidth - grid.HorizontalScrollingOffset + 4, rowBounds.Bottom - 18, 11, 11);
                 }
                 else
                 {
                     if (grid.CollapseIcon != null)
                         graphics.DrawImage(grid.CollapseIcon, rowBounds.Left + rowHeadersWidth - grid.HorizontalScrollingOffset + 4, rowBounds.Bottom - 18, 11, 11);
                 }
             }
             else
             {
                 foreach (DataGridViewCell cell in this.Cells)
                 {
                     cell.Value = cell.Value.ToString().Replace("\t", "    ");
                 }
                 foreach (DataGridViewCell cell in this.Cells)
                 {
                     cell.Value = cell.Value.ToString().Replace("\t", "    ");
                 }
             }
             base.Paint(graphics, clipBounds, rowBounds, rowIndex, rowState, isFirstDisplayedRow, isLastVisibleRow);
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="159" endline="175"><![CDATA[
 
         /// <summary>
         /// Paints the cells in the current row
         /// </summary>
         /// <param name="graphics"></param>
         /// <param name="clipBounds"></param>
         /// <param name="rowBounds"></param>
         /// <param name="rowIndex"></param>
         /// <param name="rowState"></param>
         /// <param name="isFirstDisplayedRow"></param>
         /// <param name="isLastVisibleRow"></param>
         /// <param name="paintParts"></param>
         protected override void PaintCells (System.Drawing.Graphics graphics, System.Drawing.Rectangle clipBounds, System.Drawing.Rectangle rowBounds, int rowIndex, DataGridViewElementStates rowState, bool isFirstDisplayedRow, bool isLastVisibleRow, DataGridViewPaintParts paintParts)
         {
             if (!this.isGroupRow)
                 base.PaintCells(graphics, clipBounds, rowBounds, rowIndex, rowState, isFirstDisplayedRow, isLastVisibleRow, paintParts);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="176" endline="202"><![CDATA[
 
 
         /// <summary>
         /// this function checks if the user hit the expand (+) or collapse (-) icon.
         /// if it was hit it will return true
         /// </summary>
         /// <param name="e">mouse click event arguments</param>
         /// <returns>returns true if the icon was hit, false otherwise</returns>
         internal bool IsIconHit (DataGridViewCellMouseEventArgs e)
         {
             if (e.ColumnIndex < 0) return false;
 
             OutlookGrid grid = (OutlookGrid)this.DataGridView;
             Rectangle rowBounds = grid.GetRowDisplayRectangle(this.Index, false);
             int x = e.X;
 
             //DataGridViewColumn c = grid.Columns[e.ColumnIndex];
             if (this.isGroupRow &&
                 //(c.DisplayIndex == 0) &&
                 (x > rowBounds.Left + 4) &&
                 (x < rowBounds.Left + 16) &&
                 (e.Y > rowBounds.Height - 18) &&
                 (e.Y < rowBounds.Height - 7))
                 return true;
 
             return false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="203" endline="222"><![CDATA[
     }
     #endregion OutlookGridRow - subclasses the DataGridView's DataGridViewRow class
 
     #region OutlookGridRowComparer implementation
     /// <summary>
     /// the OutlookGridRowComparer object is used to sort unbound data in the OutlookGrid.
     /// currently the comparison is only done for string values. 
     /// therefore dates or numbers may not be sorted correctly.
     /// Note
     /// </summary>
     internal class OutlookGridRowComparer 
     {
         ListSortDirection direction;
         int columnIndex;
 
         public OutlookGridRowComparer (int columnIndex, ListSortDirection direction)
         {
             this.columnIndex = columnIndex;
             this.direction = direction;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="223" endline="237"><![CDATA[
 
         #region IComparer Members
 
         /// <summary>
         /// Compares two OutlookGridRow objects
         /// </summary>
         /// <param name="x">The first object</param>
         /// <param name="y">The second object</param>
         /// <returns></returns>
         public int Compare (object x, object y)
         {
             OutlookGridRow obj1 = (OutlookGridRow)x;
             OutlookGridRow obj2 = (OutlookGridRow)y;
             return string.Compare(obj1.Cells[this.columnIndex].Value.ToString(), obj2.Cells[this.columnIndex].Value.ToString()) * (direction == ListSortDirection.Ascending ? 1 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="41" endline="60"><![CDATA[
         public Buffer(Stream s, bool isUserStream)
         {
             stream = s; this.isUserStream = isUserStream;
 
             if (stream.CanSeek)
             {
                 fileLen = (int)stream.Length;
                 bufLen = Math.Min(fileLen, MAX_BUFFER_LENGTH);
                 bufStart = Int32.MaxValue; // nothing in the buffer so far
             }
             else
             {
                 fileLen = bufLen = bufStart = 0;
             }
 
             buf = new byte[(bufLen > 0) ? bufLen 
             if (fileLen > 0) Pos = 0; // setup buffer to position 0 (start)
             else bufPos = 0; // index 0 is already after the file, thus Pos = 0 is invalid
             if (bufLen == fileLen && stream.CanSeek) Close();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="61" endline="73"><![CDATA[
 
         protected Buffer(Buffer b)
         { // called in UTF8Buffer constructor
             buf = b.buf;
             bufStart = b.bufStart;
             bufLen = b.bufLen;
             fileLen = b.fileLen;
             bufPos = b.bufPos;
             stream = b.stream;
             // keep destructor from closing the stream
             b.stream = null;
             isUserStream = b.isUserStream;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="74" endline="75"><![CDATA[
 
         ~Buffer() { Close(); }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="76" endline="84"><![CDATA[
 
         protected void Close()
         {
             if (!isUserStream && stream != null)
             {
                 stream.Close();
                 stream = null;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="85" endline="105"><![CDATA[
 
         public virtual int Read()
         {
             if (bufPos < bufLen)
             {
                 return buf[bufPos++];
             }
             else if (Pos < fileLen)
             {
                 Pos = Pos; // shift buffer start to Pos
                 return buf[bufPos++];
             }
             else if (stream != null && !stream.CanSeek && ReadNextStreamChunk() > 0)
             {
                 return buf[bufPos++];
             }
             else
             {
                 return EOF;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="106" endline="113"><![CDATA[
 
         public int Peek()
         {
             int curPos = Pos;
             int ch = Read();
             Pos = curPos;
             return ch;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="114" endline="124"><![CDATA[
 
         public string GetString(int beg, int end)
         {
             int len = end - beg;
             char[] buf = new char[len];
             int oldPos = Pos;
             Pos = beg;
             for (int i = 0; i < len; i++) buf[i] = (char)Read();
             Pos = oldPos;
             return new String(buf);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="125" endline="128"><![CDATA[
 
         public int Pos
         {
             get { return bufPos + bufStart; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="129" endline="160"><![CDATA[
             set
             {
                 if (value >= fileLen && stream != null && !stream.CanSeek)
                 {
                     // Wanted position is after buffer and the stream
                     // is not seek-able e.g. network or console,
                     // thus we have to read the stream manually till
                     // the wanted position is in sight.
                     while (value >= fileLen && ReadNextStreamChunk() > 0) ;
                 }
 
                 if (value < 0 || value > fileLen)
                 {
                     throw new FatalError("buffer out of bounds access, position
                 }
 
                 if (value >= bufStart && value < bufStart + bufLen)
                 { // already in buffer
                     bufPos = value - bufStart;
                 }
                 else if (stream != null)
                 { // must be swapped in
                     stream.Seek(value, SeekOrigin.Begin);
                     bufLen = stream.Read(buf, 0, buf.Length);
                     bufStart = value; bufPos = 0;
                 }
                 else
                 {
                     // set the position to the end of the file, Pos will return fileLen.
                     bufPos = fileLen - bufStart;
                 }
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="161" endline="188"><![CDATA[
         }
 
         // Read the next chunk of bytes from the stream, increases the buffer
         // if needed and updates the fields fileLen and bufLen.
         // Returns the number of bytes read.
         private int ReadNextStreamChunk()
         {
             int free = buf.Length - bufLen;
             if (free == 0)
             {
                 // in the case of a growing input stream
                 // we can neither seek in the stream, nor can we
                 // foresee the maximum length, thus we must adapt
                 // the buffer size on demand.
                 byte[] newBuf = new byte[bufLen * 2];
                 Array.Copy(buf, newBuf, bufLen);
                 buf = newBuf;
                 free = bufLen;
             }
             int read = stream.Read(buf, bufLen, free);
             if (read > 0)
             {
                 fileLen = bufLen = (bufLen + read);
                 return read;
             }
             // end of stream reached
             return 0;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="189" endline="196"><![CDATA[
     }
 
     //-----------------------------------------------------------------------------------
     // UTF8Buffer
     //-----------------------------------------------------------------------------------
     public class UTF8Buffer 
     {
         public UTF8Buffer(Buffer b) 
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="197" endline="236"><![CDATA[
 
         public override int Read()
         {
             int ch;
             do
             {
                 ch = base.Read();
                 // until we find a uft8 start (0xxxxxxx or 11xxxxxx)
             } while ((ch >= 128) && ((ch & 0xC0) != 0xC0) && (ch != EOF));
             if (ch < 128 || ch == EOF)
             {
                 // nothing to do, first 127 chars are the same in ascii and utf8
                 // 0xxxxxxx or end of file character
             }
             else if ((ch & 0xF0) == 0xF0)
             {
                 // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
                 int c1 = ch & 0x07; ch = base.Read();
                 int c2 = ch & 0x3F; ch = base.Read();
                 int c3 = ch & 0x3F; ch = base.Read();
                 int c4 = ch & 0x3F;
                 ch = (((((c1 << 6) | c2) << 6) | c3) << 6) | c4;
             }
             else if ((ch & 0xE0) == 0xE0)
             {
                 // 1110xxxx 10xxxxxx 10xxxxxx
                 int c1 = ch & 0x0F; ch = base.Read();
                 int c2 = ch & 0x3F; ch = base.Read();
                 int c3 = ch & 0x3F;
                 ch = (((c1 << 6) | c2) << 6) | c3;
             }
             else if ((ch & 0xC0) == 0xC0)
             {
                 // 110xxxxx 10xxxxxx
                 int c1 = ch & 0x1F; ch = base.Read();
                 int c2 = ch & 0x3F;
                 ch = (c1 << 6) | c2;
             }
             return ch;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="237" endline="278"><![CDATA[
     }
 
     //-----------------------------------------------------------------------------------
     // Scanner
     //-----------------------------------------------------------------------------------
     public class Scanner
     {
         const char EOL = '\n';
         const int eofSym = 0; /* pdt */
         const int maxT = 130;
         const int noSym = 130;
 
 
         public Buffer buffer; // scanner buffer
 
         Token t;          // current token
         int ch;           // current input character
         int pos;          // byte position of current character
         int col;          // column number of current character
         int line;         // line number of current character
         int oldEols;      // EOLs that appeared in a comment;
         Dictionary<int, int> start; // maps first token character to start state
 
         Token tokens;     // list of tokens already peeked (first token is a dummy)
         Token pt;         // current peek token
 
         char[] tval = new char[128]; // text of current token
         int tlen;         // length of current token
 
         public Scanner(string fileName)
         {
             try
             {
                 Stream stream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
                 buffer = new Buffer(stream, false);
                 Init();
             }
             catch (IOException)
             {
                 throw new FatalError("Cannot open file " + fileName);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="263" endline="284"><![CDATA[
         char[] tval = new char[128]; // text of current token
         int tlen;         // length of current token
 
         public Scanner(string fileName)
         {
             try
             {
                 Stream stream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
                 buffer = new Buffer(stream, false);
                 Init();
             }
             catch (IOException)
             {
                 throw new FatalError("Cannot open file " + fileName);
             }
         }
 
         public Scanner(Stream s)
         {
             buffer = new Buffer(s, true);
             Init();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="285" endline="346"><![CDATA[
 
         void Init()
         {
             pos = -1; line = 1; col = 0;
             oldEols = 0;
             NextCh();
             if (ch == 0xEF)
             { // check optional byte order mark for UTF-8
                 NextCh(); int ch1 = ch;
                 NextCh(); int ch2 = ch;
                 if (ch1 != 0xBB || ch2 != 0xBF)
                 {
                     throw new FatalError(String.Format("illegal byte order mark
                 }
                 buffer = new UTF8Buffer(buffer); col = 0;
                 NextCh();
             }
             start = new Dictionary<int, int>(128);
             for (int i = 65; i <= 90; ++i) start[i] = 1;
             for (int i = 95; i <= 95; ++i) start[i] = 1;
             for (int i = 97; i <= 122; ++i) start[i] = 1;
             for (int i = 170; i <= 170; ++i) start[i] = 1;
             for (int i = 181; i <= 181; ++i) start[i] = 1;
             for (int i = 186; i <= 186; ++i) start[i] = 1;
             for (int i = 192; i <= 214; ++i) start[i] = 1;
             for (int i = 216; i <= 246; ++i) start[i] = 1;
             for (int i = 248; i <= 255; ++i) start[i] = 1;
             for (int i = 49; i <= 57; ++i) start[i] = 159;
             start[92] = 15;
             start[64] = 160;
             start[48] = 161;
             start[46] = 162;
             start[39] = 44;
             start[34] = 61;
             start[38] = 196;
             start[61] = 163;
             start[58] = 164;
             start[44] = 79;
             start[45] = 197;
             start[47] = 198;
             start[62] = 165;
             start[43] = 166;
             start[123] = 86;
             start[91] = 87;
             start[40] = 88;
             start[60] = 199;
             start[37] = 200;
             start[33] = 167;
             start[124] = 201;
             start[63] = 202;
             start[125] = 95;
             start[93] = 96;
             start[41] = 97;
             start[59] = 98;
             start[126] = 99;
             start[42] = 168;
             start[94] = 203;
             start[35] = 169;
             start[Buffer.EOF] = -1;
 
             pt = tokens = new Token();  // first token is a dummy
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="347" endline="361"><![CDATA[
 
         void NextCh()
         {
             if (oldEols > 0) { ch = EOL; oldEols--; }
             else
             {
                 pos = buffer.Pos;
                 ch = buffer.Read(); col++;
                 // replace isolated '\r' by '\n' in order to make
                 // eol handling uniform across Windows, Unix and Mac
                 if (ch == '\r' && buffer.Peek() != '\n') ch = EOL;
                 if (ch == EOL) { line++; col = 0; }
             }
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="362" endline="373"><![CDATA[
 
         void AddCh()
         {
             if (tlen >= tval.Length)
             {
                 char[] newBuf = new char[2 * tval.Length];
                 Array.Copy(tval, 0, newBuf, 0, tval.Length);
                 tval = newBuf;
             }
             tval[tlen++] = (char)ch;
             NextCh();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="374" endline="401"><![CDATA[
 
 
 
         bool Comment0()
         {
             int level = 1, pos0 = pos, line0 = line, col0 = col;
             NextCh();
             if (ch == '/')
             {
                 NextCh();
                 for (; ; )
                 {
                     if (ch == 10)
                     {
                         level--;
                         if (level == 0) { oldEols = line - line0; NextCh(); return true; }
                         NextCh();
                     }
                     else if (ch == Buffer.EOF) return false;
                     else NextCh();
                 }
             }
             else
             {
                 buffer.Pos = pos0; NextCh(); line = line0; col = col0;
             }
             return false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="402" endline="431"><![CDATA[
 
         bool Comment1()
         {
             int level = 1, pos0 = pos, line0 = line, col0 = col;
             NextCh();
             if (ch == '*')
             {
                 NextCh();
                 for (; ; )
                 {
                     if (ch == '*')
                     {
                         NextCh();
                         if (ch == '/')
                         {
                             level--;
                             if (level == 0) { oldEols = line - line0; NextCh(); return true; }
                             NextCh();
                         }
                     }
                     else if (ch == Buffer.EOF) return false;
                     else NextCh();
                 }
             }
             else
             {
                 buffer.Pos = pos0; NextCh(); line = line0; col = col0;
             }
             return false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="432" endline="519"><![CDATA[
 
 
         void CheckLiteral()
         {
             switch (t.val)
             {
                 case "abstract"
                 case "as"
                 case "base"
                 case "bool"
                 case "break"
                 case "byte"
                 case "case"
                 case "catch"
                 case "char"
                 case "checked"
                 case "class"
                 case "const"
                 case "continue"
                 case "decimal"
                 case "default"
                 case "delegate"
                 case "do"
                 case "double"
                 case "else"
                 case "enum"
                 case "event"
                 case "explicit"
                 case "extern"
                 case "false"
                 case "finally"
                 case "fixed"
                 case "float"
                 case "for"
                 case "foreach"
                 case "goto"
                 case "if"
                 case "implicit"
                 case "in"
                 case "int"
                 case "interface"
                 case "internal"
                 case "is"
                 case "lock"
                 case "long"
                 case "namespace"
                 case "new"
                 case "null"
                 case "object"
                 case "operator"
                 case "out"
                 case "override"
                 case "params"
                 case "private"
                 case "protected"
                 case "public"
                 case "readonly"
                 case "ref"
                 case "return"
                 case "sbyte"
                 case "sealed"
                 case "short"
                 case "sizeof"
                 case "stackalloc"
                 case "static"
                 case "string"
                 case "struct"
                 case "switch"
                 case "this"
                 case "throw"
                 case "true"
                 case "try"
                 case "typeof"
                 case "uint"
                 case "ulong"
                 case "unchecked"
                 case "unsafe"
                 case "ushort"
                 case "using"
                 case "virtual"
                 case "void"
                 case "volatile"
                 case "while"
                 case "partial"
                 case "yield"
                 default
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="520" endline="1202"><![CDATA[
 
         Token NextToken()
         {
             while (ch == ' ' ||
                 ch >= 9 && ch <= 10 || ch == 13
             ) NextCh();
             while (ch == ' ' ||
                 ch >= 9 && ch <= 10 || ch == 13
             ) NextCh();
             if (ch == '/' && Comment0() || ch == '/' && Comment1()) return NextToken();
             int apx = 0;
             t = new Token();
             t.pos = pos; t.col = col; t.line = line;
             int state;
             try { state = start[ch]; }
             catch (KeyNotFoundException) { state = 0; }
             tlen = 0; AddCh();
 
             switch (state)
             {
                 case -1
                 case 0
                 case 1
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'Z' || ch == '_' || ch >= 'a' && ch <= 'z' || ch == 160 || ch == 170 || ch == 181 || ch == 186 || ch >= 192 && ch <= 214 || ch >= 216 && ch <= 246 || ch >= 248 && ch <= 255) { AddCh(); goto case 1; }
                     else if (ch == 92) { AddCh(); goto case 2; }
                     else { t.kind = 1; t.val = new String(tval, 0, tlen); CheckLiteral(); return t; }
                 case 2
                     if (ch == 'u') { AddCh(); goto case 3; }
                     else if (ch == 'U') { AddCh(); goto case 7; }
                     else { t.kind = noSym; break; }
                 case 3
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 4; }
                     else { t.kind = noSym; break; }
                 case 4
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 5; }
                     else { t.kind = noSym; break; }
                 case 5
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 6; }
                     else { t.kind = noSym; break; }
                 case 6
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 1; }
                     else { t.kind = noSym; break; }
                 case 7
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 8; }
                     else { t.kind = noSym; break; }
                 case 8
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 9; }
                     else { t.kind = noSym; break; }
                 case 9
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 10; }
                     else { t.kind = noSym; break; }
                 case 10
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 11; }
                     else { t.kind = noSym; break; }
                 case 11
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 12; }
                     else { t.kind = noSym; break; }
                 case 12
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 13; }
                     else { t.kind = noSym; break; }
                 case 13
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 14; }
                     else { t.kind = noSym; break; }
                 case 14
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 1; }
                     else { t.kind = noSym; break; }
                 case 15
                     if (ch == 'u') { AddCh(); goto case 16; }
                     else if (ch == 'U') { AddCh(); goto case 20; }
                     else { t.kind = noSym; break; }
                 case 16
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 17; }
                     else { t.kind = noSym; break; }
                 case 17
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 18; }
                     else { t.kind = noSym; break; }
                 case 18
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 19; }
                     else { t.kind = noSym; break; }
                 case 19
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 1; }
                     else { t.kind = noSym; break; }
                 case 20
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 21; }
                     else { t.kind = noSym; break; }
                 case 21
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 22; }
                     else { t.kind = noSym; break; }
                 case 22
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 23; }
                     else { t.kind = noSym; break; }
                 case 23
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 24; }
                     else { t.kind = noSym; break; }
                 case 24
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 25; }
                     else { t.kind = noSym; break; }
                 case 25
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 26; }
                     else { t.kind = noSym; break; }
                 case 26
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 27; }
                     else { t.kind = noSym; break; }
                 case 27
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 1; }
                     else { t.kind = noSym; break; }
                 case 28
                     if (ch >= '0' && ch <= '9') { apx = 0; AddCh(); goto case 28; }
                     else if (ch == 'U') { apx = 0; AddCh(); goto case 170; }
                     else if (ch == 'u') { apx = 0; AddCh(); goto case 171; }
                     else if (ch == 'L') { apx = 0; AddCh(); goto case 172; }
                     else if (ch == 'l') { apx = 0; AddCh(); goto case 173; }
                     else
                     {
                         tlen -= apx;
                         buffer.Pos = t.pos; NextCh(); line = t.line; col = t.col;
                         for (int i = 0; i < tlen; i++) NextCh();
                         t.kind = 2; break;
                     }
                 case 29
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 30; }
                     else { t.kind = noSym; break; }
                 case 30
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 30; }
                     else if (ch == 'U') { AddCh(); goto case 174; }
                     else if (ch == 'u') { AddCh(); goto case 175; }
                     else if (ch == 'L') { AddCh(); goto case 176; }
                     else if (ch == 'l') { AddCh(); goto case 177; }
                     else { t.kind = 2; break; }
                 case 31
                     { t.kind = 2; break; }
                 case 32
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 32; }
                     else if (ch == 'D' || ch == 'F' || ch == 'M' || ch == 'd' || ch == 'f' || ch == 'm') { AddCh(); goto case 43; }
                     else if (ch == 'E' || ch == 'e') { AddCh(); goto case 33; }
                     else { t.kind = 3; break; }
                 case 33
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 35; }
                     else if (ch == '+' || ch == '-') { AddCh(); goto case 34; }
                     else { t.kind = noSym; break; }
                 case 34
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 35; }
                     else { t.kind = noSym; break; }
                 case 35
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 35; }
                     else if (ch == 'D' || ch == 'F' || ch == 'M' || ch == 'd' || ch == 'f' || ch == 'm') { AddCh(); goto case 43; }
                     else { t.kind = 3; break; }
                 case 36
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 36; }
                     else if (ch == 'D' || ch == 'F' || ch == 'M' || ch == 'd' || ch == 'f' || ch == 'm') { AddCh(); goto case 43; }
                     else if (ch == 'E' || ch == 'e') { AddCh(); goto case 37; }
                     else { t.kind = 3; break; }
                 case 37
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 39; }
                     else if (ch == '+' || ch == '-') { AddCh(); goto case 38; }
                     else { t.kind = noSym; break; }
                 case 38
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 39; }
                     else { t.kind = noSym; break; }
                 case 39
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 39; }
                     else if (ch == 'D' || ch == 'F' || ch == 'M' || ch == 'd' || ch == 'f' || ch == 'm') { AddCh(); goto case 43; }
                     else { t.kind = 3; break; }
                 case 40
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 42; }
                     else if (ch == '+' || ch == '-') { AddCh(); goto case 41; }
                     else { t.kind = noSym; break; }
                 case 41
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 42; }
                     else { t.kind = noSym; break; }
                 case 42
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 42; }
                     else if (ch == 'D' || ch == 'F' || ch == 'M' || ch == 'd' || ch == 'f' || ch == 'm') { AddCh(); goto case 43; }
                     else { t.kind = 3; break; }
                 case 43
                     { t.kind = 3; break; }
                 case 44
                     if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= '&' || ch >= '(' && ch <= '[' || ch >= ']' && ch <= 65535) { AddCh(); goto case 45; }
                     else if (ch == 92) { AddCh(); goto case 178; }
                     else { t.kind = noSym; break; }
                 case 45
                     if (ch == 39) { AddCh(); goto case 60; }
                     else { t.kind = noSym; break; }
                 case 46
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 47; }
                     else { t.kind = noSym; break; }
                 case 47
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 179; }
                     else if (ch == 39) { AddCh(); goto case 60; }
                     else { t.kind = noSym; break; }
                 case 48
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 49; }
                     else { t.kind = noSym; break; }
                 case 49
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 50; }
                     else { t.kind = noSym; break; }
                 case 50
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 51; }
                     else { t.kind = noSym; break; }
                 case 51
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 45; }
                     else { t.kind = noSym; break; }
                 case 52
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 53; }
                     else { t.kind = noSym; break; }
                 case 53
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 54; }
                     else { t.kind = noSym; break; }
                 case 54
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 55; }
                     else { t.kind = noSym; break; }
                 case 55
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 56; }
                     else { t.kind = noSym; break; }
                 case 56
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 57; }
                     else { t.kind = noSym; break; }
                 case 57
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 58; }
                     else { t.kind = noSym; break; }
                 case 58
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 59; }
                     else { t.kind = noSym; break; }
                 case 59
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 45; }
                     else { t.kind = noSym; break; }
                 case 60
                     { t.kind = 4; break; }
                 case 61
                     if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= '!' || ch >= '#' && ch <= '[' || ch >= ']' && ch <= 65535) { AddCh(); goto case 61; }
                     else if (ch == '"') { AddCh(); goto case 77; }
                     else if (ch == 92) { AddCh(); goto case 181; }
                     else { t.kind = noSym; break; }
                 case 62
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 63; }
                     else { t.kind = noSym; break; }
                 case 63
                     if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= '!' || ch >= '#' && ch <= '/' || ch >= '
                     else if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 182; }
                     else if (ch == '"') { AddCh(); goto case 77; }
                     else if (ch == 92) { AddCh(); goto case 181; }
                     else { t.kind = noSym; break; }
                 case 64
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 65; }
                     else { t.kind = noSym; break; }
                 case 65
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 66; }
                     else { t.kind = noSym; break; }
                 case 66
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 67; }
                     else { t.kind = noSym; break; }
                 case 67
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 61; }
                     else { t.kind = noSym; break; }
                 case 68
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 69; }
                     else { t.kind = noSym; break; }
                 case 69
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 70; }
                     else { t.kind = noSym; break; }
                 case 70
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 71; }
                     else { t.kind = noSym; break; }
                 case 71
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 72; }
                     else { t.kind = noSym; break; }
                 case 72
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 73; }
                     else { t.kind = noSym; break; }
                 case 73
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 74; }
                     else { t.kind = noSym; break; }
                 case 74
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 75; }
                     else { t.kind = noSym; break; }
                 case 75
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 61; }
                     else { t.kind = noSym; break; }
                 case 76
                     if (ch <= '!' || ch >= '#' && ch <= 65535) { AddCh(); goto case 76; }
                     else if (ch == '"') { AddCh(); goto case 184; }
                     else { t.kind = noSym; break; }
                 case 77
                     { t.kind = 5; break; }
                 case 78
                     { t.kind = 84; break; }
                 case 79
                     { t.kind = 87; break; }
                 case 80
                     { t.kind = 88; break; }
                 case 81
                     { t.kind = 89; break; }
                 case 82
                     { t.kind = 91; break; }
                 case 83
                     { t.kind = 92; break; }
                 case 84
                     { t.kind = 94; break; }
                 case 85
                     { t.kind = 95; break; }
                 case 86
                     { t.kind = 96; break; }
                 case 87
                     { t.kind = 97; break; }
                 case 88
                     { t.kind = 98; break; }
                 case 89
                     { t.kind = 99; break; }
                 case 90
                     { t.kind = 103; break; }
                 case 91
                     { t.kind = 104; break; }
                 case 92
                     { t.kind = 105; break; }
                 case 93
                     { t.kind = 107; break; }
                 case 94
                     { t.kind = 109; break; }
                 case 95
                     { t.kind = 111; break; }
                 case 96
                     { t.kind = 112; break; }
                 case 97
                     { t.kind = 113; break; }
                 case 98
                     { t.kind = 114; break; }
                 case 99
                     { t.kind = 115; break; }
                 case 100
                     { t.kind = 117; break; }
                 case 101
                     { t.kind = 118; break; }
                 case 102
                     if (ch == 'e') { AddCh(); goto case 103; }
                     else { t.kind = noSym; break; }
                 case 103
                     if (ch == 'f') { AddCh(); goto case 104; }
                     else { t.kind = noSym; break; }
                 case 104
                     if (ch == 'i') { AddCh(); goto case 105; }
                     else { t.kind = noSym; break; }
                 case 105
                     if (ch == 'n') { AddCh(); goto case 106; }
                     else { t.kind = noSym; break; }
                 case 106
                     if (ch == 'e') { AddCh(); goto case 107; }
                     else { t.kind = noSym; break; }
                 case 107
                     if (ch == 10 || ch == 13) { AddCh(); goto case 108; }
                     else if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 65535) { AddCh(); goto case 107; }
                     else { t.kind = noSym; break; }
                 case 108
                     { t.kind = 131; break; }
                 case 109
                     if (ch == 'n') { AddCh(); goto case 110; }
                     else { t.kind = noSym; break; }
                 case 110
                     if (ch == 'd') { AddCh(); goto case 111; }
                     else { t.kind = noSym; break; }
                 case 111
                     if (ch == 'e') { AddCh(); goto case 112; }
                     else { t.kind = noSym; break; }
                 case 112
                     if (ch == 'f') { AddCh(); goto case 113; }
                     else { t.kind = noSym; break; }
                 case 113
                     if (ch == 10 || ch == 13) { AddCh(); goto case 114; }
                     else if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 65535) { AddCh(); goto case 113; }
                     else { t.kind = noSym; break; }
                 case 114
                     { t.kind = 132; break; }
                 case 115
                     if (ch == 'f') { AddCh(); goto case 116; }
                     else { t.kind = noSym; break; }
                 case 116
                     if (ch == 10 || ch == 13) { AddCh(); goto case 117; }
                     else if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 65535) { AddCh(); goto case 116; }
                     else { t.kind = noSym; break; }
                 case 117
                     { t.kind = 133; break; }
                 case 118
                     if (ch == 'f') { AddCh(); goto case 119; }
                     else { t.kind = noSym; break; }
                 case 119
                     if (ch == 10 || ch == 13) { AddCh(); goto case 120; }
                     else if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 65535) { AddCh(); goto case 119; }
                     else { t.kind = noSym; break; }
                 case 120
                     { t.kind = 134; break; }
                 case 121
                     if (ch == 'e') { AddCh(); goto case 122; }
                     else { t.kind = noSym; break; }
                 case 122
                     if (ch == 10 || ch == 13) { AddCh(); goto case 123; }
                     else if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 65535) { AddCh(); goto case 122; }
                     else { t.kind = noSym; break; }
                 case 123
                     { t.kind = 135; break; }
                 case 124
                     if (ch == 'f') { AddCh(); goto case 125; }
                     else { t.kind = noSym; break; }
                 case 125
                     if (ch == 10 || ch == 13) { AddCh(); goto case 126; }
                     else if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 65535) { AddCh(); goto case 125; }
                     else { t.kind = noSym; break; }
                 case 126
                     { t.kind = 136; break; }
                 case 127
                     if (ch == 'i') { AddCh(); goto case 128; }
                     else { t.kind = noSym; break; }
                 case 128
                     if (ch == 'n') { AddCh(); goto case 129; }
                     else { t.kind = noSym; break; }
                 case 129
                     if (ch == 'e') { AddCh(); goto case 130; }
                     else { t.kind = noSym; break; }
                 case 130
                     if (ch == 10 || ch == 13) { AddCh(); goto case 131; }
                     else if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 65535) { AddCh(); goto case 130; }
                     else { t.kind = noSym; break; }
                 case 131
                     { t.kind = 137; break; }
                 case 132
                     if (ch == 'r') { AddCh(); goto case 133; }
                     else { t.kind = noSym; break; }
                 case 133
                     if (ch == 'o') { AddCh(); goto case 134; }
                     else { t.kind = noSym; break; }
                 case 134
                     if (ch == 'r') { AddCh(); goto case 135; }
                     else { t.kind = noSym; break; }
                 case 135
                     if (ch == 10 || ch == 13) { AddCh(); goto case 136; }
                     else if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 65535) { AddCh(); goto case 135; }
                     else { t.kind = noSym; break; }
                 case 136
                     { t.kind = 138; break; }
                 case 137
                     if (ch == 'a') { AddCh(); goto case 138; }
                     else { t.kind = noSym; break; }
                 case 138
                     if (ch == 'r') { AddCh(); goto case 139; }
                     else { t.kind = noSym; break; }
                 case 139
                     if (ch == 'n') { AddCh(); goto case 140; }
                     else { t.kind = noSym; break; }
                 case 140
                     if (ch == 'i') { AddCh(); goto case 141; }
                     else { t.kind = noSym; break; }
                 case 141
                     if (ch == 'n') { AddCh(); goto case 142; }
                     else { t.kind = noSym; break; }
                 case 142
                     if (ch == 'g') { AddCh(); goto case 143; }
                     else { t.kind = noSym; break; }
                 case 143
                     if (ch == 10 || ch == 13) { AddCh(); goto case 144; }
                     else if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 65535) { AddCh(); goto case 143; }
                     else { t.kind = noSym; break; }
                 case 144
                     { t.kind = 139; break; }
                 case 145
                     if (ch == 'e') { AddCh(); goto case 146; }
                     else { t.kind = noSym; break; }
                 case 146
                     if (ch == 'g') { AddCh(); goto case 147; }
                     else { t.kind = noSym; break; }
                 case 147
                     if (ch == 'i') { AddCh(); goto case 148; }
                     else { t.kind = noSym; break; }
                 case 148
                     if (ch == 'o') { AddCh(); goto case 149; }
                     else { t.kind = noSym; break; }
                 case 149
                     if (ch == 'n') { AddCh(); goto case 150; }
                     else { t.kind = noSym; break; }
                 case 150
                     if (ch == 10 || ch == 13) { AddCh(); goto case 151; }
                     else if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 65535) { AddCh(); goto case 150; }
                     else { t.kind = noSym; break; }
                 case 151
                     { t.kind = 140; break; }
                 case 152
                     if (ch == 'e') { AddCh(); goto case 153; }
                     else { t.kind = noSym; break; }
                 case 153
                     if (ch == 'g') { AddCh(); goto case 154; }
                     else { t.kind = noSym; break; }
                 case 154
                     if (ch == 'i') { AddCh(); goto case 155; }
                     else { t.kind = noSym; break; }
                 case 155
                     if (ch == 'o') { AddCh(); goto case 156; }
                     else { t.kind = noSym; break; }
                 case 156
                     if (ch == 'n') { AddCh(); goto case 157; }
                     else { t.kind = noSym; break; }
                 case 157
                     if (ch == 10 || ch == 13) { AddCh(); goto case 158; }
                     else if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 65535) { AddCh(); goto case 157; }
                     else { t.kind = noSym; break; }
                 case 158
                     { t.kind = 141; break; }
                 case 159
                     if (ch >= '0' && ch <= '9') { apx = 0; AddCh(); goto case 159; }
                     else if (ch == 'U') { apx = 0; AddCh(); goto case 170; }
                     else if (ch == 'u') { apx = 0; AddCh(); goto case 171; }
                     else if (ch == 'L') { apx = 0; AddCh(); goto case 172; }
                     else if (ch == 'l') { apx = 0; AddCh(); goto case 173; }
                     else if (ch == '.') { apx++; AddCh(); goto case 185; }
                     else if (ch == 'E' || ch == 'e') { apx = 0; AddCh(); goto case 40; }
                     else if (ch == 'D' || ch == 'F' || ch == 'M' || ch == 'd' || ch == 'f' || ch == 'm') { apx = 0; AddCh(); goto case 43; }
                     else { t.kind = 2; break; }
                 case 160
                     if (ch >= 'A' && ch <= 'Z' || ch == '_' || ch >= 'a' && ch <= 'z' || ch == 170 || ch == 181 || ch == 186 || ch >= 192 && ch <= 214 || ch >= 216 && ch <= 246 || ch >= 248 && ch <= 255) { AddCh(); goto case 1; }
                     else if (ch == 92) { AddCh(); goto case 15; }
                     else if (ch == '"') { AddCh(); goto case 76; }
                     else { t.kind = noSym; break; }
                 case 161
                     if (ch >= '0' && ch <= '9') { apx = 0; AddCh(); goto case 159; }
                     else if (ch == 'U') { apx = 0; AddCh(); goto case 170; }
                     else if (ch == 'u') { apx = 0; AddCh(); goto case 171; }
                     else if (ch == 'L') { apx = 0; AddCh(); goto case 172; }
                     else if (ch == 'l') { apx = 0; AddCh(); goto case 173; }
                     else if (ch == '.') { apx++; AddCh(); goto case 185; }
                     else if (ch == 'X' || ch == 'x') { apx = 0; AddCh(); goto case 29; }
                     else if (ch == 'E' || ch == 'e') { apx = 0; AddCh(); goto case 40; }
                     else if (ch == 'D' || ch == 'F' || ch == 'M' || ch == 'd' || ch == 'f' || ch == 'm') { apx = 0; AddCh(); goto case 43; }
                     else { t.kind = 2; break; }
                 case 162
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 32; }
                     else { t.kind = 90; break; }
                 case 163
                     if (ch == '=') { AddCh(); goto case 83; }
                     else { t.kind = 85; break; }
                 case 164
                     if (ch == '
                     else { t.kind = 86; break; }
                 case 165
                     if (ch == '=') { AddCh(); goto case 84; }
                     else { t.kind = 93; break; }
                 case 166
                     if (ch == '+') { AddCh(); goto case 85; }
                     else if (ch == '=') { AddCh(); goto case 94; }
                     else { t.kind = 108; break; }
                 case 167
                     if (ch == '=') { AddCh(); goto case 92; }
                     else { t.kind = 106; break; }
                 case 168
                     if (ch == '=') { AddCh(); goto case 100; }
                     else { t.kind = 116; break; }
                 case 169
                     if (ch == 9 || ch >= 11 && ch <= 12 || ch == ' ') { AddCh(); goto case 169; }
                     else if (ch == 'd') { AddCh(); goto case 102; }
                     else if (ch == 'u') { AddCh(); goto case 109; }
                     else if (ch == 'i') { AddCh(); goto case 115; }
                     else if (ch == 'e') { AddCh(); goto case 187; }
                     else if (ch == 'l') { AddCh(); goto case 127; }
                     else if (ch == 'w') { AddCh(); goto case 137; }
                     else if (ch == 'r') { AddCh(); goto case 145; }
                     else { t.kind = noSym; break; }
                 case 170
                     if (ch == 'L' || ch == 'l') { AddCh(); goto case 31; }
                     else { t.kind = 2; break; }
                 case 171
                     if (ch == 'L' || ch == 'l') { AddCh(); goto case 31; }
                     else { t.kind = 2; break; }
                 case 172
                     if (ch == 'U' || ch == 'u') { AddCh(); goto case 31; }
                     else { t.kind = 2; break; }
                 case 173
                     if (ch == 'U' || ch == 'u') { AddCh(); goto case 31; }
                     else { t.kind = 2; break; }
                 case 174
                     if (ch == 'L' || ch == 'l') { AddCh(); goto case 31; }
                     else { t.kind = 2; break; }
                 case 175
                     if (ch == 'L' || ch == 'l') { AddCh(); goto case 31; }
                     else { t.kind = 2; break; }
                 case 176
                     if (ch == 'U' || ch == 'u') { AddCh(); goto case 31; }
                     else { t.kind = 2; break; }
                 case 177
                     if (ch == 'U' || ch == 'u') { AddCh(); goto case 31; }
                     else { t.kind = 2; break; }
                 case 178
                     if (ch == '"' || ch == 39 || ch == '0' || ch == 92 || ch >= 'a' && ch <= 'b' || ch == 'f' || ch == 'n' || ch == 'r' || ch == 't' || ch == 'v') { AddCh(); goto case 45; }
                     else if (ch == 'x') { AddCh(); goto case 46; }
                     else if (ch == 'u') { AddCh(); goto case 48; }
                     else if (ch == 'U') { AddCh(); goto case 52; }
                     else { t.kind = noSym; break; }
                 case 179
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 180; }
                     else if (ch == 39) { AddCh(); goto case 60; }
                     else { t.kind = noSym; break; }
                 case 180
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 45; }
                     else if (ch == 39) { AddCh(); goto case 60; }
                     else { t.kind = noSym; break; }
                 case 181
                     if (ch == '"' || ch == 39 || ch == '0' || ch == 92 || ch >= 'a' && ch <= 'b' || ch == 'f' || ch == 'n' || ch == 'r' || ch == 't' || ch == 'v') { AddCh(); goto case 61; }
                     else if (ch == 'x') { AddCh(); goto case 62; }
                     else if (ch == 'u') { AddCh(); goto case 64; }
                     else if (ch == 'U') { AddCh(); goto case 68; }
                     else { t.kind = noSym; break; }
                 case 182
                     if (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') { AddCh(); goto case 183; }
                     else if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= '!' || ch >= '#' && ch <= '/' || ch >= '
                     else if (ch == '"') { AddCh(); goto case 77; }
                     else if (ch == 92) { AddCh(); goto case 181; }
                     else { t.kind = noSym; break; }
                 case 183
                     if (ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= '!' || ch >= '#' && ch <= '[' || ch >= ']' && ch <= 65535) { AddCh(); goto case 61; }
                     else if (ch == '"') { AddCh(); goto case 77; }
                     else if (ch == 92) { AddCh(); goto case 181; }
                     else { t.kind = noSym; break; }
                 case 184
                     if (ch == '"') { AddCh(); goto case 76; }
                     else { t.kind = 5; break; }
                 case 185
                     if (ch <= '/' || ch >= '
                     else if (ch >= '0' && ch <= '9') { apx = 0; AddCh(); goto case 36; }
                     else { t.kind = noSym; break; }
                 case 186
                     if (ch == '=') { AddCh(); goto case 89; }
                     else { t.kind = 101; break; }
                 case 187
                     if (ch == 'l') { AddCh(); goto case 188; }
                     else if (ch == 'n') { AddCh(); goto case 189; }
                     else if (ch == 'r') { AddCh(); goto case 132; }
                     else { t.kind = noSym; break; }
                 case 188
                     if (ch == 'i') { AddCh(); goto case 118; }
                     else if (ch == 's') { AddCh(); goto case 121; }
                     else { t.kind = noSym; break; }
                 case 189
                     if (ch == 'd') { AddCh(); goto case 190; }
                     else { t.kind = noSym; break; }
                 case 190
                     if (ch == 'i') { AddCh(); goto case 124; }
                     else if (ch == 'r') { AddCh(); goto case 152; }
                     else { t.kind = noSym; break; }
                 case 191
                     { t.kind = 121; break; }
                 case 192
                     { t.kind = 122; break; }
                 case 193
                     { t.kind = 123; break; }
                 case 194
                     { t.kind = 126; break; }
                 case 195
                     { t.kind = 129; break; }
                 case 196
                     if (ch == '=') { AddCh(); goto case 78; }
                     else if (ch == '&') { AddCh(); goto case 193; }
                     else { t.kind = 83; break; }
                 case 197
                     if (ch == '-') { AddCh(); goto case 80; }
                     else if (ch == '=') { AddCh(); goto case 90; }
                     else if (ch == '>') { AddCh(); goto case 195; }
                     else { t.kind = 102; break; }
                 case 198
                     if (ch == '=') { AddCh(); goto case 81; }
                     else { t.kind = 127; break; }
                 case 199
                     if (ch == '<') { AddCh(); goto case 186; }
                     else if (ch == '=') { AddCh(); goto case 194; }
                     else { t.kind = 100; break; }
                 case 200
                     if (ch == '=') { AddCh(); goto case 91; }
                     else { t.kind = 128; break; }
                 case 201
                     if (ch == '=') { AddCh(); goto case 93; }
                     else if (ch == '|') { AddCh(); goto case 192; }
                     else { t.kind = 124; break; }
                 case 202
                     if (ch == '?') { AddCh(); goto case 191; }
                     else { t.kind = 110; break; }
                 case 203
                     if (ch == '=') { AddCh(); goto case 101; }
                     else { t.kind = 125; break; }
 
             }
             t.val = new String(tval, 0, tlen);
             return t;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="1203" endline="1216"><![CDATA[
 
         // get the next token (possibly a token already seen during peeking)
         public Token Scan()
         {
             if (tokens.next == null)
             {
                 return NextToken();
             }
             else
             {
                 pt = tokens = tokens.next;
                 return tokens;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="1217" endline="1236"><![CDATA[
 
         // peek for the next token, ignore pragmas
         public Token Peek()
         {
             if (pt.next == null)
             {
                 do
                 {
                     pt = pt.next = NextToken();
                 } while (pt.kind > maxT); // skip pragmas
             }
             else
             {
                 do
                 {
                     pt = pt.next;
                 } while (pt.kind > maxT);
             }
             return pt;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\OutlookGrid\OutlookGrid.cs" startline="1237" endline="1239"><![CDATA[
 
         // make sure that peeking starts at the current scan position
         public void ResetPeek() { pt = tokens; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cProjectInfo.cs" startline="47" endline="53"><![CDATA[
         public cProjectInfo ()
         {
             this.m_ProjectPath = "";
             this.m_ProjectName = "";
             this.m_ProjectType = "";
             this.m_ProjectData = null;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cProjectInfo.cs" startline="54" endline="60"><![CDATA[
 
         /// <summary>
         /// Gets or Sets the Path of the Project...
         /// </summary>
         public string Path
         {
             get { return this.m_ProjectPath; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cProjectInfo.cs" startline="61" endline="61"><![CDATA[
             set { this.m_ProjectPath = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cProjectInfo.cs" startline="62" endline="69"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets the Name of the Project...
         /// </summary>
         public string Name
         {
             get { return this.m_ProjectName; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cProjectInfo.cs" startline="70" endline="70"><![CDATA[
             set { this.m_ProjectName = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cProjectInfo.cs" startline="71" endline="78"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets the Type of the Project...
         /// </summary>
         public string Type
         {
             get { return this.m_ProjectType; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cProjectInfo.cs" startline="79" endline="79"><![CDATA[
             set { this.m_ProjectType = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cProjectInfo.cs" startline="80" endline="87"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets the Data of the Project...
         /// </summary>
         public TreeNode Data
         {
             get { return this.m_ProjectData; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cProjectInfo.cs" startline="88" endline="88"><![CDATA[
             set { this.m_ProjectData = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cProjectInfo.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cProjectInfo.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cProjectInfo.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cProjectInfo.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="24" endline="42"><![CDATA[
         private System.ComponentModel.IContainer components = null;
         public CommandPrompt()
         {
             InitializeComponent();
 
             this.Load += new EventHandler(CommandPrompt_Load);
             this.TabText = "Command Prompt";
             this.m_Command = false;
             this.cmbInput.KeyDown += new KeyEventHandler(InputKeyPress);
             this.rtbOutput.GotFocus += new EventHandler(rtbOutput_GotFocus);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="43" endline="47"><![CDATA[
 
         void rtbOutput_GotFocus(object sender, EventArgs e)
         {
             this.cmbInput.Focus();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="48" endline="53"><![CDATA[
 
         void CommandPrompt_Load(object sender, EventArgs e)
         {
             this.StartCommandPrompt();
             this.cmbInput.Focus();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="54" endline="61"><![CDATA[
 
         private void InputKeyPress(object sender, KeyEventArgs e)
         {
             if (e.KeyCode == Keys.Enter)
             {
                 this.RunCommand(this.cmbInput.Text);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="62" endline="82"><![CDATA[
 
         private void StartCommandPrompt()
         {
             Process cmd = new Process();
             cmd.StartInfo.FileName = "cmd.exe";
             cmd.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
             cmd.StartInfo.CreateNoWindow = true;
             cmd.StartInfo.UseShellExecute = false;
             cmd.StartInfo.RedirectStandardError = true;
             cmd.StartInfo.RedirectStandardInput = true;
             cmd.StartInfo.RedirectStandardOutput = true;
 
             cmd.OutputDataReceived += new DataReceivedEventHandler(HandleOutput);
             cmd.ErrorDataReceived += new DataReceivedEventHandler(HandleError);
 
             cmd.Start();
             this.m_Writer = cmd.StandardInput;
             this.m_Writer.WriteLine("cd " + Path.GetDirectoryName(Application.ExecutablePath));
             cmd.BeginErrorReadLine();
             cmd.BeginOutputReadLine();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="83" endline="90"><![CDATA[
 
         void HandleError(object sender, DataReceivedEventArgs e)
         {
             if (!string.IsNullOrEmpty(e.Data))
             {
                 this.rtbOutput.Invoke(new UpdateOutputCallback(this.UpdateError), new object[] { e.Data });
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="91" endline="98"><![CDATA[
 
         void HandleOutput(object sender, DataReceivedEventArgs e)
         {
             if (!string.IsNullOrEmpty(e.Data))
             {
                 this.rtbOutput.Invoke(new UpdateOutputCallback(this.UpdateOutput), new object[] { e.Data });
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="99" endline="120"><![CDATA[
 
         private void UpdateOutput(string text)
         {
             if (!this.m_Command && text.IndexOf(">cd") == text.Length - 3)
             {
                 return;
             }
 
             int start = this.rtbOutput.TextLength;
 
             this.rtbOutput.AppendText(text + System.Environment.NewLine);
 
             if (this.m_Command)
             {
                 this.rtbOutput.Select(start, text.Length);
                 this.rtbOutput.SelectionColor = Color.Yellow;
                 this.rtbOutput.Select(this.rtbOutput.TextLength, 0);
                 this.m_Command = false;
             }
 
             this.rtbOutput.ScrollToCaret();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="121" endline="130"><![CDATA[
 
         private void UpdateError(string text)
         {
             int start = this.rtbOutput.TextLength;
             this.rtbOutput.AppendText(text + System.Environment.NewLine);
             this.rtbOutput.Select(start, text.Length);
             this.rtbOutput.SelectionColor = Color.Red;
             this.rtbOutput.Select(this.rtbOutput.TextLength, 0);
             this.rtbOutput.ScrollToCaret();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="131" endline="153"><![CDATA[
 
         /// <summary>
         /// Runs the given Script...
         /// </summary>
         /// <param name="script">Script to run (Commands should be separated by a new line '\n').</param>
         /// <param name="workingDirectory">Directory to run script.</param>
         public void RunScript(string script, string workingDirectory)
         {
             int index = workingDirectory.IndexOf("
             if (index > 0)
             {
                 this.m_Writer.WriteLine(workingDirectory.Substring(0, index + 1));
             }
             this.m_Writer.WriteLine("cd " + workingDirectory);
             string[] commands = Regex.Split(script, System.Environment.NewLine);
             foreach (string command in commands)
             {
                 if (!string.IsNullOrEmpty(command))
                 {
                     this.m_Writer.WriteLine(command);
                 }
             }
             foreach (string command in commands)
             {
                 if (!string.IsNullOrEmpty(command))
                 {
                     this.m_Writer.WriteLine(command);
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="154" endline="169"><![CDATA[
 
         /// <summary>
         /// Runs the given command...
         /// </summary>
         /// <param name="command">Command to run.</param>
         public void RunCommand(string command)
         {
             this.m_Writer.WriteLine(command);
             this.m_Command = true;
             if (!this.cmbInput.Items.Contains(command))
             {
                 this.cmbInput.Items.Add(command);
             }
             this.cmbInput.Text = "";
             this.m_Writer.WriteLine("cd");
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="170" endline="176"><![CDATA[
 
         #region IPeterPluginTab Members
 
         public void Save()
         {
             this.m_Host.SaveAs(this);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="177" endline="181"><![CDATA[
 
         public void SaveAs(string filePath)
         {
             this.rtbOutput.SaveFile(filePath);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="182" endline="185"><![CDATA[
 
         public void Cut()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="186" endline="190"><![CDATA[
 
         public void Copy()
         {
             this.rtbOutput.Copy();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="191" endline="198"><![CDATA[
 
         public void Paste()
         {
             if (Clipboard.ContainsText())
             {
                 this.cmbInput.Text = Clipboard.GetText();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="199" endline="202"><![CDATA[
 
         public void Undo()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="203" endline="206"><![CDATA[
 
         public void Redo()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="207" endline="210"><![CDATA[
 
         public void Delete()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="211" endline="214"><![CDATA[
 
         public void Duplicate()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="215" endline="218"><![CDATA[
 
         public void Print()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="219" endline="223"><![CDATA[
 
         public void SelectAll()
         {
             this.rtbOutput.SelectAll();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="224" endline="229"><![CDATA[
 
         public bool CloseTab()
         {
             this.Close();
             return true;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="230" endline="233"><![CDATA[
 
         public IPeterPluginHost Host
         {
             get {  return this.m_Host; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="234" endline="235"><![CDATA[
 
             set { this.m_Host = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="236" endline="240"><![CDATA[
         }
 
         public string FileName
         {
             get { return ""; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="241" endline="245"><![CDATA[
         }
 
         public string Selection
         {
             get { return this.rtbOutput.SelectedText; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="246" endline="250"><![CDATA[
         }
 
         public bool AbleToUndo
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="251" endline="255"><![CDATA[
         }
 
         public bool AbleToRedo
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="256" endline="260"><![CDATA[
         }
 
         public bool AbleToPaste
         {
             get { return true; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="261" endline="265"><![CDATA[
         }
 
         public bool AbleToCut
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="266" endline="270"><![CDATA[
         }
 
         public bool AbleToCopy
         {
             get { return true; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="271" endline="275"><![CDATA[
         }
 
         public bool AbleToSelectAll
         {
             get { return true; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="276" endline="280"><![CDATA[
         }
 
         public bool AbleToSave
         {
             get { return true; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="281" endline="285"><![CDATA[
         }
 
         public bool AbleToDelete
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="286" endline="290"><![CDATA[
         }
 
         public bool NeedsSaving
         {
             get { return false; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="291" endline="295"><![CDATA[
         }
 
         public void MarkAll(System.Text.RegularExpressions.Regex reg)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="296" endline="306"><![CDATA[
 
         public bool FindNext(System.Text.RegularExpressions.Regex reg, bool searchUp)
         {
             Match m = reg.Match(this.rtbOutput.Text, this.rtbOutput.SelectionStart);
             if (m.Success)
             {
                 this.rtbOutput.Select(m.Index, m.Length);
                 return true;
             }
             return false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="307" endline="310"><![CDATA[
 
         public void ReplaceNext(System.Text.RegularExpressions.Regex reg, string replaceWith, bool searchUp)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="311" endline="314"><![CDATA[
 
         public void ReplaceAll(System.Text.RegularExpressions.Regex reg, string replaceWith)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="315" endline="318"><![CDATA[
 
         public void SelectWord(int line, int offset, int wordLeng)
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="31" endline="37"><![CDATA[
         {
             if (disposing && (components != null))
             {
                 components.Dispose();
             }
             base.Dispose(disposing);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="38" endline="90"><![CDATA[
 
         #region Component Designer generated code
 
         /// <summary> 
         /// Required method for Designer support - do not modify 
         /// the contents of this method with the code editor.
         /// </summary>
         private void InitializeComponent()
         {
             this.cmbInput = new System.Windows.Forms.ComboBox();
             this.rtbOutput = new System.Windows.Forms.RichTextBox();
             this.SuspendLayout();
             // 
             // cmbInput
             // 
             this.cmbInput.AutoCompleteMode = System.Windows.Forms.AutoCompleteMode.Suggest;
             this.cmbInput.AutoCompleteSource = System.Windows.Forms.AutoCompleteSource.ListItems;
             this.cmbInput.BackColor = System.Drawing.Color.Black;
             this.cmbInput.Dock = System.Windows.Forms.DockStyle.Bottom;
             this.cmbInput.FlatStyle = System.Windows.Forms.FlatStyle.Popup;
             this.cmbInput.ForeColor = System.Drawing.Color.White;
             this.cmbInput.FormattingEnabled = true;
             this.cmbInput.Location = new System.Drawing.Point(0, 208);
             this.cmbInput.Name = "cmbInput";
             this.cmbInput.Size = new System.Drawing.Size(335, 21);
             this.cmbInput.TabIndex = 0;
             // 
             // rtbOutput
             // 
             this.rtbOutput.BackColor = System.Drawing.Color.Black;
             this.rtbOutput.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
             this.rtbOutput.Dock = System.Windows.Forms.DockStyle.Fill;
             this.rtbOutput.Font = new System.Drawing.Font("Courier New", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
             this.rtbOutput.ForeColor = System.Drawing.Color.White;
             this.rtbOutput.Location = new System.Drawing.Point(0, 0);
             this.rtbOutput.Name = "rtbOutput";
             this.rtbOutput.ReadOnly = true;
             this.rtbOutput.ScrollBars = System.Windows.Forms.RichTextBoxScrollBars.Vertical;
             this.rtbOutput.Size = new System.Drawing.Size(335, 208);
             this.rtbOutput.TabIndex = 1;
             this.rtbOutput.Text = "";
             // 
             // CommandPrompt
             // 
             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.ClientSize = new System.Drawing.Size(335, 229);
             this.Controls.Add(this.rtbOutput);
             this.Controls.Add(this.cmbInput);
             this.Name = "CommandPrompt";
             this.ResumeLayout(false);
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="17" endline="76"><![CDATA[
         {
             Peter.JavaParser.Scanner scanner = new Peter.JavaParser.Scanner(fileName);
             Peter.JavaParser.Parser parser = new Peter.JavaParser.Parser(scanner);
             parser.Parse();
 
             // Import...
             TreeNode nImport = new TreeNode("Imports");
             foreach (TokenMatch tm in parser.CodeInfo.Imports)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nImport.Nodes.Add(n);
             }
             foreach (TokenMatch tm in parser.CodeInfo.Imports)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nImport.Nodes.Add(n);
             }
             if (nImport.Nodes.Count > 0)
             {
                 nodes.Add(nImport);
             }
 
             // Fields...
             TreeNode nField = new TreeNode("Fields");
             foreach (TokenMatch tm in parser.CodeInfo.Fields)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nField.Nodes.Add(n);
             }
             foreach (TokenMatch tm in parser.CodeInfo.Fields)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nField.Nodes.Add(n);
             }
             if (nField.Nodes.Count > 0)
             {
                 nodes.Add(nField);
                 nField.Expand();
             }
 
             // Constructors...
             TreeNode nConstruct = new TreeNode("Constructors");
             foreach (TokenMatch tm in parser.CodeInfo.Constructors)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nConstruct.Nodes.Add(n);
             }
             foreach (TokenMatch tm in parser.CodeInfo.Constructors)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nConstruct.Nodes.Add(n);
             }
             if (nConstruct.Nodes.Count > 0)
             {
                 nodes.Add(nConstruct);
                 nConstruct.Expand();
             }
 
             // Methods...
             TreeNode nMethod = new TreeNode("Methods");
             foreach (TokenMatch tm in parser.CodeInfo.Methods)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nMethod.Nodes.Add(n);
             }
             foreach (TokenMatch tm in parser.CodeInfo.Methods)
             {
                 TreeNode n = new TreeNode(tm.Value);
                 n.Tag = tm.Position;
                 nMethod.Nodes.Add(n);
             }
             if (nMethod.Nodes.Count > 0)
             {
                 nodes.Add(nMethod);
                 nMethod.Expand();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="26" endline="39"><![CDATA[
         {
             try
             {
                 FileStream s = new FileStream(fileName, FileMode.Open);
                 bufLen = (int)s.Length;
                 buf = new byte[bufLen];
                 s.Read(buf, 0, bufLen); pos = 0;
             }
             catch (IOException)
             {
                 Console.WriteLine("--- Cannot open file {0}", fileName);
                 System.Environment.Exit(0);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="40" endline="47"><![CDATA[
 
         public static int Read()
         {
             if (pos < bufLen)
                 return buf[pos++];
             else
                 return eof;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="48" endline="51"><![CDATA[
 
         public static int Pos
         {
             get { return pos; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="52" endline="55"><![CDATA[
             set
             {
                 if (value < 0) pos = 0; else if (value >= bufLen) pos = bufLen; else pos = value;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="56" endline="104"><![CDATA[
         }
     }
 
 
     public class Scanner
     {
         const char EOF = '\0';
         const char CR = '\r';
         const char LF = '\n';
         const int noSym = 39;
         static short[] start = {
 	 30,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 	  0,  0, 11,  0, 10,  0,  0,  5, 21, 22,  0, 15,  0, 16, 14,  0,
 	  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  0, 29, 18, 13, 19,  0,
 	  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
 	  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, 23,  0, 24,  0,  0,
 	  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
 	  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, 25, 20, 26,  0,  0,
 	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 	  0};
 
 
         static Token t;			// current token
         static char ch;			// current input character
         static char lastCh; // last input character
         static int pos;     // column number of current character
         static int line;		// line number of current character
         static int lineStart;	    // start position of current line
         static Queue oldEols;		  // EOLs that appeared in a comment;
         static BitArray ignore;	  // set of characters to be ignored by the scanner	
 
         public static void Init(String fileName)
         {
             Buffer.Fill(fileName);
             pos = -1; line = 1; lineStart = 0; lastCh = '\0';
             oldEols = new Queue();
             NextCh();
             ignore = new BitArray(256);
             ignore[9] = true; ignore[10] = true; ignore[13] = true; ignore[32] = true;
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="105" endline="129"><![CDATA[
 
         private static void NextCh()
         {
             if (oldEols.Count > 0)
             {
                 ch = (char)oldEols.Dequeue();
             }
             else
             {
                 lastCh = ch;
                 ch = (char)Buffer.Read(); pos++;
                 if (ch == '\uffff') ch = EOF;
                 else if (ch == CR) { line++; lineStart = pos + 1; }
                 else if (ch == LF)
                 {
                     if (lastCh != CR) line++;
                     lineStart = pos + 1;
                 }
                 else if (ch > '\u00ff')
                 {
                     Console.WriteLine("-- line {0} col {1}
                     Errors.count++; ch = ' ';
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="130" endline="173"><![CDATA[
 
 
         static bool Comment0()
         {
             int level = 1, line0 = line, lineStart0 = lineStart;
             NextCh();
             if (ch == '*')
             {
                 NextCh();
                 for (; ; )
                 {
                     if (ch == '*')
                     {
                         NextCh();
                         if (ch == '/')
                         {
                             level--;
                             if (level == 0)
                             {
                                 while (line0 < line) { oldEols.Enqueue('\r'); oldEols.Enqueue('\n'); line0++; }
                                 NextCh(); return true;
                             }
                             NextCh();
                         }
                     }
                     else if (ch == '/')
                     {
                         NextCh();
                         if (ch == '*')
                         {
                             level++; NextCh();
                         }
                     }
                     else if (ch == EOF) return false;
                     else NextCh();
                 }
             }
             else
             {
                 if (ch == CR) { line--; lineStart = lineStart0; }
                 pos = pos - 2; Buffer.Pos = pos + 1; NextCh();
             }
             return false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="174" endline="199"><![CDATA[
 
 
         static void CheckLiteral()
         {
             switch (t.val)
             {
                 case "COMPILER"
                 case "PRODUCTIONS"
                 case "END"
                 case "CHARACTERS"
                 case "TOKENS"
                 case "PRAGMAS"
                 case "COMMENTS"
                 case "FROM"
                 case "TO"
                 case "NESTED"
                 case "IGNORE"
                 case "ANY"
                 case "WEAK"
                 case "SYNC"
                 case "CONTEXT"
                 case "using"
                 default
 
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="200" endline="294"><![CDATA[
 
         public static Token Scan()
         {
             while (ignore[ch]) NextCh();
             if (ch == '/' && Comment0()) return Scan();
             t = new Token();
             t.pos = pos; t.col = pos - lineStart + 1; t.line = line;
             int state = start[ch];
             StringBuilder buf = new StringBuilder(16);
             buf.Append(ch); NextCh();
 
             switch (state)
             {
                 case 0
                 case 1
                     if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'Z' || ch >= 'a' && ch <= 'z')) { buf.Append(ch); NextCh(); goto case 1; }
                     else { t.kind = 1; t.val = buf.ToString(); CheckLiteral(); return t; }
                 case 2
                     if ((ch >= '0' && ch <= '9')) { buf.Append(ch); NextCh(); goto case 2; }
                     else { t.kind = 2; goto done; }
                 case 3
                     { t.kind = 3; goto done; }
                 case 4
                     { t.kind = 4; goto done; }
                 case 5
                     if ((ch >= 1 && ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= '&' || ch >= '(' && ch <= '[' || ch >= ']')) { buf.Append(ch); NextCh(); goto case 6; }
                     else if (ch == 92) { buf.Append(ch); NextCh(); goto case 7; }
                     else { t.kind = noSym; goto done; }
                 case 6
                     if (ch == 39) { buf.Append(ch); NextCh(); goto case 9; }
                     else { t.kind = noSym; goto done; }
                 case 7
                     if ((ch >= ' ' && ch <= '~')) { buf.Append(ch); NextCh(); goto case 8; }
                     else { t.kind = noSym; goto done; }
                 case 8
                     if ((ch >= '0' && ch <= '9' || ch >= 'a' && ch <= 'f')) { buf.Append(ch); NextCh(); goto case 8; }
                     else if (ch == 39) { buf.Append(ch); NextCh(); goto case 9; }
                     else { t.kind = noSym; goto done; }
                 case 9
                     { t.kind = 5; goto done; }
                 case 10
                     if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'Z' || ch >= 'a' && ch <= 'z')) { buf.Append(ch); NextCh(); goto case 10; }
                     else { t.kind = 40; goto done; }
                 case 11
                     if ((ch >= 1 && ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= '!' || ch >= '#' && ch <= '[' || ch >= ']')) { buf.Append(ch); NextCh(); goto case 11; }
                     else if ((ch == 10 || ch == 13)) { buf.Append(ch); NextCh(); goto case 4; }
                     else if (ch == '"') { buf.Append(ch); NextCh(); goto case 3; }
                     else if (ch == 92) { buf.Append(ch); NextCh(); goto case 12; }
                     else { t.kind = noSym; goto done; }
                 case 12
                     if ((ch >= ' ' && ch <= '~')) { buf.Append(ch); NextCh(); goto case 11; }
                     else { t.kind = noSym; goto done; }
                 case 13
                     { t.kind = 8; goto done; }
                 case 14
                     if (ch == '.') { buf.Append(ch); NextCh(); goto case 17; }
                     else if (ch == ')') { buf.Append(ch); NextCh(); goto case 28; }
                     else { t.kind = 9; goto done; }
                 case 15
                     { t.kind = 19; goto done; }
                 case 16
                     { t.kind = 20; goto done; }
                 case 17
                     { t.kind = 21; goto done; }
                 case 18
                     { t.kind = 23; goto done; }
                 case 19
                     { t.kind = 24; goto done; }
                 case 20
                     { t.kind = 25; goto done; }
                 case 21
                     if (ch == '.') { buf.Append(ch); NextCh(); goto case 27; }
                     else { t.kind = 27; goto done; }
                 case 22
                     { t.kind = 28; goto done; }
                 case 23
                     { t.kind = 29; goto done; }
                 case 24
                     { t.kind = 30; goto done; }
                 case 25
                     { t.kind = 31; goto done; }
                 case 26
                     { t.kind = 32; goto done; }
                 case 27
                     { t.kind = 35; goto done; }
                 case 28
                     { t.kind = 36; goto done; }
                 case 29
                     { t.kind = 38; goto done; }
                 case 30
             }
         done
             t.val = buf.ToString();
             return t;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="66" endline="66"><![CDATA[
         static short[] start = {
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="67" endline="310"><![CDATA[
 	 30,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 	  0,  0, 11,  0, 10,  0,  0,  5, 21, 22,  0, 15,  0, 16, 14,  0,
 	  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  0, 29, 18, 13, 19,  0,
 	  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
 	  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, 23,  0, 24,  0,  0,
 	  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
 	  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, 25, 20, 26,  0,  0,
 	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 	  0};
 
 
         static Token t;			// current token
         static char ch;			// current input character
         static char lastCh; // last input character
         static int pos;     // column number of current character
         static int line;		// line number of current character
         static int lineStart;	    // start position of current line
         static Queue oldEols;		  // EOLs that appeared in a comment;
         static BitArray ignore;	  // set of characters to be ignored by the scanner	
 
         public static void Init(String fileName)
         {
             Buffer.Fill(fileName);
             pos = -1; line = 1; lineStart = 0; lastCh = '\0';
             oldEols = new Queue();
             NextCh();
             ignore = new BitArray(256);
             ignore[9] = true; ignore[10] = true; ignore[13] = true; ignore[32] = true;
 
         }
 
         private static void NextCh()
         {
             if (oldEols.Count > 0)
             {
                 ch = (char)oldEols.Dequeue();
             }
             else
             {
                 lastCh = ch;
                 ch = (char)Buffer.Read(); pos++;
                 if (ch == '\uffff') ch = EOF;
                 else if (ch == CR) { line++; lineStart = pos + 1; }
                 else if (ch == LF)
                 {
                     if (lastCh != CR) line++;
                     lineStart = pos + 1;
                 }
                 else if (ch > '\u00ff')
                 {
                     Console.WriteLine("-- line {0} col {1}
                     Errors.count++; ch = ' ';
                 }
             }
         }
 
 
         static bool Comment0()
         {
             int level = 1, line0 = line, lineStart0 = lineStart;
             NextCh();
             if (ch == '*')
             {
                 NextCh();
                 for (; ; )
                 {
                     if (ch == '*')
                     {
                         NextCh();
                         if (ch == '/')
                         {
                             level--;
                             if (level == 0)
                             {
                                 while (line0 < line) { oldEols.Enqueue('\r'); oldEols.Enqueue('\n'); line0++; }
                                 NextCh(); return true;
                             }
                             NextCh();
                         }
                     }
                     else if (ch == '/')
                     {
                         NextCh();
                         if (ch == '*')
                         {
                             level++; NextCh();
                         }
                     }
                     else if (ch == EOF) return false;
                     else NextCh();
                 }
             }
             else
             {
                 if (ch == CR) { line--; lineStart = lineStart0; }
                 pos = pos - 2; Buffer.Pos = pos + 1; NextCh();
             }
             return false;
         }
 
 
         static void CheckLiteral()
         {
             switch (t.val)
             {
                 case "COMPILER"
                 case "PRODUCTIONS"
                 case "END"
                 case "CHARACTERS"
                 case "TOKENS"
                 case "PRAGMAS"
                 case "COMMENTS"
                 case "FROM"
                 case "TO"
                 case "NESTED"
                 case "IGNORE"
                 case "ANY"
                 case "WEAK"
                 case "SYNC"
                 case "CONTEXT"
                 case "using"
                 default
 
             }
         }
 
         public static Token Scan()
         {
             while (ignore[ch]) NextCh();
             if (ch == '/' && Comment0()) return Scan();
             t = new Token();
             t.pos = pos; t.col = pos - lineStart + 1; t.line = line;
             int state = start[ch];
             StringBuilder buf = new StringBuilder(16);
             buf.Append(ch); NextCh();
 
             switch (state)
             {
                 case 0
                 case 1
                     if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'Z' || ch >= 'a' && ch <= 'z')) { buf.Append(ch); NextCh(); goto case 1; }
                     else { t.kind = 1; t.val = buf.ToString(); CheckLiteral(); return t; }
                 case 2
                     if ((ch >= '0' && ch <= '9')) { buf.Append(ch); NextCh(); goto case 2; }
                     else { t.kind = 2; goto done; }
                 case 3
                     { t.kind = 3; goto done; }
                 case 4
                     { t.kind = 4; goto done; }
                 case 5
                     if ((ch >= 1 && ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= '&' || ch >= '(' && ch <= '[' || ch >= ']')) { buf.Append(ch); NextCh(); goto case 6; }
                     else if (ch == 92) { buf.Append(ch); NextCh(); goto case 7; }
                     else { t.kind = noSym; goto done; }
                 case 6
                     if (ch == 39) { buf.Append(ch); NextCh(); goto case 9; }
                     else { t.kind = noSym; goto done; }
                 case 7
                     if ((ch >= ' ' && ch <= '~')) { buf.Append(ch); NextCh(); goto case 8; }
                     else { t.kind = noSym; goto done; }
                 case 8
                     if ((ch >= '0' && ch <= '9' || ch >= 'a' && ch <= 'f')) { buf.Append(ch); NextCh(); goto case 8; }
                     else if (ch == 39) { buf.Append(ch); NextCh(); goto case 9; }
                     else { t.kind = noSym; goto done; }
                 case 9
                     { t.kind = 5; goto done; }
                 case 10
                     if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'Z' || ch >= 'a' && ch <= 'z')) { buf.Append(ch); NextCh(); goto case 10; }
                     else { t.kind = 40; goto done; }
                 case 11
                     if ((ch >= 1 && ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= '!' || ch >= '#' && ch <= '[' || ch >= ']')) { buf.Append(ch); NextCh(); goto case 11; }
                     else if ((ch == 10 || ch == 13)) { buf.Append(ch); NextCh(); goto case 4; }
                     else if (ch == '"') { buf.Append(ch); NextCh(); goto case 3; }
                     else if (ch == 92) { buf.Append(ch); NextCh(); goto case 12; }
                     else { t.kind = noSym; goto done; }
                 case 12
                     if ((ch >= ' ' && ch <= '~')) { buf.Append(ch); NextCh(); goto case 11; }
                     else { t.kind = noSym; goto done; }
                 case 13
                     { t.kind = 8; goto done; }
                 case 14
                     if (ch == '.') { buf.Append(ch); NextCh(); goto case 17; }
                     else if (ch == ')') { buf.Append(ch); NextCh(); goto case 28; }
                     else { t.kind = 9; goto done; }
                 case 15
                     { t.kind = 19; goto done; }
                 case 16
                     { t.kind = 20; goto done; }
                 case 17
                     { t.kind = 21; goto done; }
                 case 18
                     { t.kind = 23; goto done; }
                 case 19
                     { t.kind = 24; goto done; }
                 case 20
                     { t.kind = 25; goto done; }
                 case 21
                     if (ch == '.') { buf.Append(ch); NextCh(); goto case 27; }
                     else { t.kind = 27; goto done; }
                 case 22
                     { t.kind = 28; goto done; }
                 case 23
                     { t.kind = 29; goto done; }
                 case 24
                     { t.kind = 30; goto done; }
                 case 25
                     { t.kind = 31; goto done; }
                 case 26
                     { t.kind = 32; goto done; }
                 case 27
                     { t.kind = 35; goto done; }
                 case 28
                     { t.kind = 36; goto done; }
                 case 29
                     { t.kind = 38; goto done; }
                 case 30
             }
         done
             t.val = buf.ToString();
             return t;
         }
 
     } // end Scanner
 
 
     public delegate void ErrorProc(int n, int line, int col);
 
     public class Errors
     {
         public static int count = 0;	// number of errors detected
         public static ErrorProc SynErr = new ErrorProc(Default);	// syntactic errors
         public static ErrorProc SemErr = new ErrorProc(Default);	// semantic errors
 
         public static void Exception(string s)
         {
             Console.WriteLine(s); System.Environment.Exit(0);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="311" endline="316"><![CDATA[
 
         static void Default(int n, int line, int col)
         {
             Console.WriteLine("-- line {0} col {1}
             count++;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="303" endline="305"><![CDATA[
         public static int count = 0;	// number of errors detected
         public static ErrorProc SynErr = new ErrorProc(Default);	// syntactic errors
         public static ErrorProc SemErr = new ErrorProc(Default);	// semantic errors
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="39" endline="58"><![CDATA[
         public Buffer(Stream s, bool isUserStream)
         {
             stream = s; this.isUserStream = isUserStream;
 
             if (stream.CanSeek)
             {
                 fileLen = (int)stream.Length;
                 bufLen = Math.Min(fileLen, MAX_BUFFER_LENGTH);
                 bufStart = Int32.MaxValue; // nothing in the buffer so far
             }
             else
             {
                 fileLen = bufLen = bufStart = 0;
             }
 
             buf = new byte[(bufLen > 0) ? bufLen 
             if (fileLen > 0) Pos = 0; // setup buffer to position 0 (start)
             else bufPos = 0; // index 0 is already after the file, thus Pos = 0 is invalid
             if (bufLen == fileLen && stream.CanSeek) Close();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="59" endline="71"><![CDATA[
 
         protected Buffer(Buffer b)
         { // called in UTF8Buffer constructor
             buf = b.buf;
             bufStart = b.bufStart;
             bufLen = b.bufLen;
             fileLen = b.fileLen;
             bufPos = b.bufPos;
             stream = b.stream;
             // keep destructor from closing the stream
             b.stream = null;
             isUserStream = b.isUserStream;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="72" endline="73"><![CDATA[
 
         ~Buffer() { Close(); }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="74" endline="82"><![CDATA[
 
         protected void Close()
         {
             if (!isUserStream && stream != null)
             {
                 stream.Close();
                 stream = null;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="83" endline="103"><![CDATA[
 
         public virtual int Read()
         {
             if (bufPos < bufLen)
             {
                 return buf[bufPos++];
             }
             else if (Pos < fileLen)
             {
                 Pos = Pos; // shift buffer start to Pos
                 return buf[bufPos++];
             }
             else if (stream != null && !stream.CanSeek && ReadNextStreamChunk() > 0)
             {
                 return buf[bufPos++];
             }
             else
             {
                 return EOF;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="104" endline="111"><![CDATA[
 
         public int Peek()
         {
             int curPos = Pos;
             int ch = Read();
             Pos = curPos;
             return ch;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="112" endline="122"><![CDATA[
 
         public string GetString(int beg, int end)
         {
             int len = end - beg;
             char[] buf = new char[len];
             int oldPos = Pos;
             Pos = beg;
             for (int i = 0; i < len; i++) buf[i] = (char)Read();
             Pos = oldPos;
             return new String(buf);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="123" endline="126"><![CDATA[
 
         public int Pos
         {
             get { return bufPos + bufStart; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="127" endline="158"><![CDATA[
             set
             {
                 if (value >= fileLen && stream != null && !stream.CanSeek)
                 {
                     // Wanted position is after buffer and the stream
                     // is not seek-able e.g. network or console,
                     // thus we have to read the stream manually till
                     // the wanted position is in sight.
                     while (value >= fileLen && ReadNextStreamChunk() > 0) ;
                 }
 
                 if (value < 0 || value > fileLen)
                 {
                     throw new FatalError("buffer out of bounds access, position
                 }
 
                 if (value >= bufStart && value < bufStart + bufLen)
                 { // already in buffer
                     bufPos = value - bufStart;
                 }
                 else if (stream != null)
                 { // must be swapped in
                     stream.Seek(value, SeekOrigin.Begin);
                     bufLen = stream.Read(buf, 0, buf.Length);
                     bufStart = value; bufPos = 0;
                 }
                 else
                 {
                     // set the position to the end of the file, Pos will return fileLen.
                     bufPos = fileLen - bufStart;
                 }
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="159" endline="186"><![CDATA[
         }
 
         // Read the next chunk of bytes from the stream, increases the buffer
         // if needed and updates the fields fileLen and bufLen.
         // Returns the number of bytes read.
         private int ReadNextStreamChunk()
         {
             int free = buf.Length - bufLen;
             if (free == 0)
             {
                 // in the case of a growing input stream
                 // we can neither seek in the stream, nor can we
                 // foresee the maximum length, thus we must adapt
                 // the buffer size on demand.
                 byte[] newBuf = new byte[bufLen * 2];
                 Array.Copy(buf, newBuf, bufLen);
                 buf = newBuf;
                 free = bufLen;
             }
             int read = stream.Read(buf, bufLen, free);
             if (read > 0)
             {
                 fileLen = bufLen = (bufLen + read);
                 return read;
             }
             // end of stream reached
             return 0;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="187" endline="194"><![CDATA[
     }
 
     //-----------------------------------------------------------------------------------
     // UTF8Buffer
     //-----------------------------------------------------------------------------------
     public class UTF8Buffer 
     {
         public UTF8Buffer(Buffer b) 
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="195" endline="234"><![CDATA[
 
         public override int Read()
         {
             int ch;
             do
             {
                 ch = base.Read();
                 // until we find a uft8 start (0xxxxxxx or 11xxxxxx)
             } while ((ch >= 128) && ((ch & 0xC0) != 0xC0) && (ch != EOF));
             if (ch < 128 || ch == EOF)
             {
                 // nothing to do, first 127 chars are the same in ascii and utf8
                 // 0xxxxxxx or end of file character
             }
             else if ((ch & 0xF0) == 0xF0)
             {
                 // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
                 int c1 = ch & 0x07; ch = base.Read();
                 int c2 = ch & 0x3F; ch = base.Read();
                 int c3 = ch & 0x3F; ch = base.Read();
                 int c4 = ch & 0x3F;
                 ch = (((((c1 << 6) | c2) << 6) | c3) << 6) | c4;
             }
             else if ((ch & 0xE0) == 0xE0)
             {
                 // 1110xxxx 10xxxxxx 10xxxxxx
                 int c1 = ch & 0x0F; ch = base.Read();
                 int c2 = ch & 0x3F; ch = base.Read();
                 int c3 = ch & 0x3F;
                 ch = (((c1 << 6) | c2) << 6) | c3;
             }
             else if ((ch & 0xC0) == 0xC0)
             {
                 // 110xxxxx 10xxxxxx
                 int c1 = ch & 0x1F; ch = base.Read();
                 int c2 = ch & 0x3F;
                 ch = (c1 << 6) | c2;
             }
             return ch;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="235" endline="276"><![CDATA[
     }
 
     //-----------------------------------------------------------------------------------
     // Scanner
     //-----------------------------------------------------------------------------------
     public class Scanner
     {
         const char EOL = '\n';
         const int eofSym = 0; /* pdt */
         const int maxT = 89;
         const int noSym = 89;
 
 
         public Buffer buffer; // scanner buffer
 
         Token t;          // current token
         int ch;           // current input character
         int pos;          // byte position of current character
         int col;          // column number of current character
         int line;         // line number of current character
         int oldEols;      // EOLs that appeared in a comment;
         Dictionary<int, int> start; // maps first token character to start state
 
         Token tokens;     // list of tokens already peeked (first token is a dummy)
         Token pt;         // current peek token
 
         char[] tval = new char[128]; // text of current token
         int tlen;         // length of current token
 
         public Scanner(string fileName)
         {
             try
             {
                 Stream stream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
                 buffer = new Buffer(stream, false);
                 Init();
             }
             catch (IOException)
             {
                 throw new FatalError("Cannot open file " + fileName);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="261" endline="282"><![CDATA[
         char[] tval = new char[128]; // text of current token
         int tlen;         // length of current token
 
         public Scanner(string fileName)
         {
             try
             {
                 Stream stream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
                 buffer = new Buffer(stream, false);
                 Init();
             }
             catch (IOException)
             {
                 throw new FatalError("Cannot open file " + fileName);
             }
         }
 
         public Scanner(Stream s)
         {
             buffer = new Buffer(s, true);
             Init();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="283" endline="323"><![CDATA[
 
         void Init()
         {
             pos = -1; line = 1; col = 0;
             oldEols = 0;
             NextCh();
             if (ch == 0xEF)
             { // check optional byte order mark for UTF-8
                 NextCh(); int ch1 = ch;
                 NextCh(); int ch2 = ch;
                 if (ch1 != 0xBB || ch2 != 0xBF)
                 {
                     throw new FatalError(String.Format("illegal byte order mark
                 }
                 buffer = new UTF8Buffer(buffer); col = 0;
                 NextCh();
             }
             start = new Dictionary<int, int>(128);
             for (int i = 48; i <= 57; ++i) start[i] = 1;
             for (int i = 65; i <= 90; ++i) start[i] = 5;
             for (int i = 95; i <= 95; ++i) start[i] = 5;
             for (int i = 97; i <= 122; ++i) start[i] = 5;
             start[34] = 4;
             start[44] = 7;
             start[43] = 8;
             start[45] = 9;
             start[42] = 10;
             start[47] = 11;
             start[92] = 12;
             start[38] = 13;
             start[40] = 14;
             start[41] = 15;
             start[46] = 16;
             start[61] = 17;
             start[60] = 30;
             start[62] = 31;
             start[35] = 32;
             start[Buffer.EOF] = -1;
 
             pt = tokens = new Token();  // first token is a dummy
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="324" endline="338"><![CDATA[
 
         void NextCh()
         {
             if (oldEols > 0) { ch = EOL; oldEols--; }
             else
             {
                 pos = buffer.Pos;
                 ch = buffer.Read(); col++;
                 // replace isolated '\r' by '\n' in order to make
                 // eol handling uniform across Windows, Unix and Mac
                 if (ch == '\r' && buffer.Peek() != '\n') ch = EOL;
                 if (ch == EOL) { line++; col = 0; }
             }
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="339" endline="350"><![CDATA[
 
         void AddCh()
         {
             if (tlen >= tval.Length)
             {
                 char[] newBuf = new char[2 * tval.Length];
                 Array.Copy(tval, 0, newBuf, 0, tval.Length);
                 tval = newBuf;
             }
             tval[tlen++] = (char)ch;
             NextCh();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="351" endline="369"><![CDATA[
 
 
 
         bool Comment0()
         {
             int level = 1, pos0 = pos, line0 = line, col0 = col;
             NextCh();
             for (; ; )
             {
                 if (ch == 10)
                 {
                     level--;
                     if (level == 0) { oldEols = line - line0; NextCh(); return true; }
                     NextCh();
                 }
                 else if (ch == Buffer.EOF) return false;
                 else NextCh();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="370" endline="445"><![CDATA[
 
 
         void CheckLiteral()
         {
             switch (t.val)
             {
                 case "Imports"
                 case "Option"
                 case "Explicit"
                 case "On"
                 case "Off"
                 case "Strict"
                 case "Compare"
                 case "Text"
                 case "Binary"
                 case "Inherits"
                 case "Implements"
                 case "Class"
                 case "Structure"
                 case "End"
                 case "Module"
                 case "Mod"
                 case "Not"
                 case "TypeOf"
                 case "Is"
                 case "True"
                 case "False"
                 case "Nothing"
                 case "Me"
                 case "New"
                 case "And"
                 case "Or"
                 case "Public"
                 case "Private"
                 case "Protected"
                 case "Overrides"
                 case "Shared"
                 case "Friend"
                 case "Interface"
                 case "Enum"
                 case "Region"
                 case "Const"
                 case "As"
                 case "Handles"
                 case "Sub"
                 case "Function"
                 case "SyncLock"
                 case "Throw"
                 case "Do"
                 case "Loop"
                 case "While"
                 case "Until"
                 case "Exit"
                 case "For"
                 case "To"
                 case "Step"
                 case "Next"
                 case "Each"
                 case "In"
                 case "Call"
                 case "Return"
                 case "Try"
                 case "Catch"
                 case "Finally"
                 case "Select"
                 case "Case"
                 case "Else"
                 case "ElseIf"
                 case "Then"
                 case "If"
                 case "Dim"
                 case "ByVal"
                 case "ByRef"
                 default
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="446" endline="552"><![CDATA[
 
         Token NextToken()
         {
             while (ch == ' ' ||
                 ch >= 9 && ch <= 10 || ch == 13 || ch == ' ' || ch == '_'
             ) NextCh();
             while (ch == ' ' ||
                 ch >= 9 && ch <= 10 || ch == 13 || ch == ' ' || ch == '_'
             ) NextCh();
             if (ch == 39 && Comment0()) return NextToken();
             t = new Token();
             t.pos = pos; t.col = col; t.line = line;
             int state;
             try { state = start[ch]; }
             catch (KeyNotFoundException) { state = 0; }
             tlen = 0; AddCh();
 
             switch (state)
             {
                 case -1
                 case 0
                 case 1
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 1; }
                     else if (ch == '.') { AddCh(); goto case 2; }
                     else { t.kind = 1; break; }
                 case 2
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 3; }
                     else { t.kind = noSym; break; }
                 case 3
                     if (ch >= '0' && ch <= '9') { AddCh(); goto case 3; }
                     else { t.kind = 1; break; }
                 case 4
                     if (ch <= '!' || ch >= '#' && ch <= 65535) { AddCh(); goto case 4; }
                     else if (ch == '"') { AddCh(); goto case 6; }
                     else { t.kind = noSym; break; }
                 case 5
                     if (ch == '.' || ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'Z' || ch == '_' || ch >= 'a' && ch <= 'z') { AddCh(); goto case 5; }
                     else { t.kind = 3; t.val = new String(tval, 0, tlen); CheckLiteral(); return t; }
                 case 6
                     if (ch == '"') { AddCh(); goto case 4; }
                     else { t.kind = 2; break; }
                 case 7
                     { t.kind = 15; break; }
                 case 8
                     { t.kind = 20; break; }
                 case 9
                     { t.kind = 21; break; }
                 case 10
                     { t.kind = 22; break; }
                 case 11
                     { t.kind = 23; break; }
                 case 12
                     { t.kind = 24; break; }
                 case 13
                     { t.kind = 26; break; }
                 case 14
                     { t.kind = 30; break; }
                 case 15
                     { t.kind = 31; break; }
                 case 16
                     { t.kind = 36; break; }
                 case 17
                     { t.kind = 38; break; }
                 case 18
                     { t.kind = 41; break; }
                 case 19
                     { t.kind = 42; break; }
                 case 20
                     { t.kind = 43; break; }
                 case 21
                     if (ch == 'e') { AddCh(); goto case 22; }
                     else { t.kind = noSym; break; }
                 case 22
                     if (ch == 'g') { AddCh(); goto case 23; }
                     else { t.kind = noSym; break; }
                 case 23
                     if (ch == 'i') { AddCh(); goto case 24; }
                     else { t.kind = noSym; break; }
                 case 24
                     if (ch == 'o') { AddCh(); goto case 25; }
                     else { t.kind = noSym; break; }
                 case 25
                     if (ch == 'n') { AddCh(); goto case 26; }
                     else { t.kind = noSym; break; }
                 case 26
                     { t.kind = 54; break; }
                 case 27
                     if (ch == 'n') { AddCh(); goto case 28; }
                     else { t.kind = noSym; break; }
                 case 28
                     if (ch == 'd') { AddCh(); goto case 29; }
                     else { t.kind = noSym; break; }
                 case 29
                     { t.kind = 55; break; }
                 case 30
                     if (ch == '=') { AddCh(); goto case 19; }
                     else if (ch == '>') { AddCh(); goto case 20; }
                     else { t.kind = 39; break; }
                 case 31
                     if (ch == '=') { AddCh(); goto case 18; }
                     else { t.kind = 40; break; }
                 case 32
                     if (ch == 'R') { AddCh(); goto case 21; }
                     else if (ch == 'E') { AddCh(); goto case 27; }
                     else { t.kind = noSym; break; }
 
             }
             t.val = new String(tval, 0, tlen);
             return t;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="553" endline="566"><![CDATA[
 
         // get the next token (possibly a token already seen during peeking)
         public Token Scan()
         {
             if (tokens.next == null)
             {
                 return NextToken();
             }
             else
             {
                 pt = tokens = tokens.next;
                 return tokens;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="567" endline="586"><![CDATA[
 
         // peek for the next token, ignore pragmas
         public Token Peek()
         {
             if (pt.next == null)
             {
                 do
                 {
                     pt = pt.next = NextToken();
                 } while (pt.kind > maxT); // skip pragmas
             }
             else
             {
                 do
                 {
                     pt = pt.next;
                 } while (pt.kind > maxT);
             }
             return pt;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\DockContent\CommandPrompt.cs" startline="587" endline="589"><![CDATA[
 
         // make sure that peeking starts at the current scan position
         public void ResetPeek() { pt = tokens; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Resources.Designer.cs" startline="31" endline="33"><![CDATA[
         [global
         internal Resources() {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Resources.Designer.cs" startline="34" endline="46"><![CDATA[
         
         /// <summary>
         ///   Returns the cached ResourceManager instance used by this class.
         /// </summary>
         [global
         internal static global
             get {
                 if (object.ReferenceEquals(resourceMan, null)) {
                     global
                     resourceMan = temp;
                 }
                 return resourceMan;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Resources.Designer.cs" startline="47" endline="57"><![CDATA[
         }
         
         /// <summary>
         ///   Overrides the current thread's CurrentUICulture property for all
         ///   resource lookups using this strongly typed resource class.
         /// </summary>
         [global
         internal static global
             get {
                 return resourceCulture;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Properties\Resources.Designer.cs" startline="58" endline="60"><![CDATA[
             set {
                 resourceCulture = value;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="13" endline="15"><![CDATA[
         {
             FillCSSTree(ParseFile(fileName), nodes);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="16" endline="26"><![CDATA[
 
         private static CSS ParseFile(string file)
         {
             StringBuilder sb = new StringBuilder();
             TextWriter errorCatch = new StringWriter(sb);
             Scanner scanner = new Scanner(file);
             Parser parser = new Parser(scanner);
             parser.errors.errorStream = errorCatch;
             parser.Parse();
             return parser.CSSDocument;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="27" endline="65"><![CDATA[
 
         private static void FillCSSTree (CSS css, TreeNodeCollection nodes)
         {
             foreach (Selector sel in css.Selectors)
             {
                 TreeNode s = new TreeNode();
                 s.ImageIndex = 0;
                 bool first = true;
                 foreach (Tag t in sel.Tags)
                 {
                     if (first) { first = false; } else { s.Text += ", "; }
                     s.Text += t.ToString();
                 }
                 foreach (Tag t in sel.Tags)
                 {
                     if (first) { first = false; } else { s.Text += ", "; }
                     s.Text += t.ToString();
                 }
                 s.Tag = sel;
                 nodes.Add(s);
                 foreach (Tag tag in sel.Tags)
                 {
                     TreeNode t = AddChild(tag);
                     s.Nodes.Add(t);
                 }
                 foreach (Tag tag in sel.Tags)
                 {
                     TreeNode t = AddChild(tag);
                     s.Nodes.Add(t);
                 }
                 foreach (Property prp in sel.Properties)
                 {
                     TreeNode p = new TreeNode(prp.Attribute, 2, 2);
                     p.Tag = prp;
                     s.Nodes.Add(p);
 
                     foreach (PropertyValue pv in prp.Values)
                     {
                         TreeNode v = new TreeNode(pv.ToString(), 3, 3);
                         if (pv.IsColor)
                         {
                             v.ForeColor = pv.ToColor();
                         }
                         v.Tag = pv;
                         p.Nodes.Add(v);
                     }
                     foreach (PropertyValue pv in prp.Values)
                     {
                         TreeNode v = new TreeNode(pv.ToString(), 3, 3);
                         if (pv.IsColor)
                         {
                             v.ForeColor = pv.ToColor();
                         }
                         v.Tag = pv;
                         p.Nodes.Add(v);
                     }
                 }
                 foreach (Property prp in sel.Properties)
                 {
                     TreeNode p = new TreeNode(prp.Attribute, 2, 2);
                     p.Tag = prp;
                     s.Nodes.Add(p);
 
                     foreach (PropertyValue pv in prp.Values)
                     {
                         TreeNode v = new TreeNode(pv.ToString(), 3, 3);
                         if (pv.IsColor)
                         {
                             v.ForeColor = pv.ToColor();
                         }
                         v.Tag = pv;
                         p.Nodes.Add(v);
                     }
                 }
             }
             foreach (Selector sel in css.Selectors)
             {
                 TreeNode s = new TreeNode();
                 s.ImageIndex = 0;
                 bool first = true;
                 foreach (Tag t in sel.Tags)
                 {
                     if (first) { first = false; } else { s.Text += ", "; }
                     s.Text += t.ToString();
                 }
                 s.Tag = sel;
                 nodes.Add(s);
                 foreach (Tag tag in sel.Tags)
                 {
                     TreeNode t = AddChild(tag);
                     s.Nodes.Add(t);
                 }
                 foreach (Property prp in sel.Properties)
                 {
                     TreeNode p = new TreeNode(prp.Attribute, 2, 2);
                     p.Tag = prp;
                     s.Nodes.Add(p);
 
                     foreach (PropertyValue pv in prp.Values)
                     {
                         TreeNode v = new TreeNode(pv.ToString(), 3, 3);
                         if (pv.IsColor)
                         {
                             v.ForeColor = pv.ToColor();
                         }
                         v.Tag = pv;
                         p.Nodes.Add(v);
                     }
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="66" endline="75"><![CDATA[
         private static TreeNode AddChild (Tag tag)
         {
             TreeNode t = new TreeNode(tag.ToShortString(), 1, 1);
             t.Tag = tag;
             foreach (Tag sub in tag.SubTags)
             {
                 t.Nodes.Add(AddChild(sub));
             }
             foreach (Tag sub in tag.SubTags)
             {
                 t.Nodes.Add(AddChild(sub));
             }
             return t;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="76" endline="92"><![CDATA[
 
         public List<Token> GetTokens(string file)
         {
             StringBuilder sb = new StringBuilder();
             TextWriter errorCatch = new StringWriter(sb);
             Scanner scanner = new Scanner(file);
 
             List<Token> ts = new List<Token>();
             Token t = scanner.Scan();
             if (t.val != "\0") { ts.Add(t); }
             while (t.val != "\0")
             {
                 t = scanner.Scan();
                 ts.Add(t);
             }
             while (t.val != "\0")
             {
                 t = scanner.Scan();
                 ts.Add(t);
             }
             return ts;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="93" endline="100"><![CDATA[
 
         public CSS ParseText(string content)
         {
             MemoryStream mem = new MemoryStream();
             byte[] bytes = ASCIIEncoding.ASCII.GetBytes(content);
             mem.Write(bytes, 0, bytes.Length);
             return ParseStream(mem);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="101" endline="111"><![CDATA[
 
         public CSS ParseStream(Stream stream)
         {
             StringBuilder sb = new StringBuilder();
             TextWriter errorCatch = new StringWriter(sb);
             Scanner scanner = new Scanner(stream);
             Parser parser = new Parser(scanner);
             parser.errors.errorStream = errorCatch;
             parser.Parse();
             return parser.CSSDocument;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="116" endline="116"><![CDATA[
             get { return this.m_CodeInfo; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="107" endline="125"><![CDATA[
         int errDist = minErrDist;
 
         private CCodeInfo m_CodeInfo = new CCodeInfo();
         private string m_DataType = "";
         private string m_Current = "";
         private int m_Count = 0;
 
         public CCodeInfo CodeInfo
         {
             get { return this.m_CodeInfo; }
         }
 
 
 
         public Parser(Scanner scanner)
         {
             this.scanner = scanner;
             errors = new Errors();
         }
 
         void SynErr(int n)
         {
             if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n);
             errDist = 0;
         }
 
         public void SemErr(string msg)
         {
             if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg);
             errDist = 0;
         }
 
         void Get()
         {
             for (; ; )
             {
                 t = la;
                 la = scanner.Scan();
                 if (la.kind <= maxT) { ++errDist; break; }
                 if (la.kind == 81)
                 {
                     //AddCCS(la.val);
                     string def = la.val.Replace("\t", " ");
                     def = def.Replace("#define", "");
                     int count = 0;
                     while (def[count] == ' ')
                     {
                         count++;
                     }
                     def = def.Trim();
                     bool space = false;
                     string temp = "";
                     for (int a = 0; a < def.Length; a++)
                     {
                         if (space && def[a] == ' ')
                         {
                         }
                         else if (def[a] == ' ')
                         {
                             space = true;
                             temp += def[a];
                         }
                         else
                         {
                             space = false;
                             temp += def[a];
                         }
                     }
                     while (temp.Substring(temp.Length - 1).Equals("\\"))
                     {
                         Get();
                         temp += " " + la.val;
                         int line = la.line;
                         while (scanner.Peek().line == line)
                         {
                             Get();
                             temp += " " + la.val;
                         }
                     }
                     TokenMatch tm = new TokenMatch(temp, la.pos + 8);
                     this.m_CodeInfo.Defines.Add(tm);
                 }
                 if (la.kind == 82)
                 {
                     //RemCCS(la.val);
                 }
                 if (la.kind == 83)
                 {
                     //IfPragma(la.val);
                 }
                 if (la.kind == 84)
                 {
                     //ElifOrElsePragma();
                 }
                 if (la.kind == 85)
                 {
                     //ElifOrElsePragma();
                 }
                 if (la.kind == 86)
                 {
                 }
                 if (la.kind == 87)
                 {
                 }
                 if (la.kind == 88)
                 {
                 }
                 if (la.kind == 89)
                 {
                 }
                 if (la.kind == 90)
                 {
                 }
                 if (la.kind == 91)
                 {
                 }
 
                 la = t;
             }
         }
 
         void Expect(int n)
         {
             if (la.kind == n) Get(); else { SynErr(n); }
         }
 
         bool StartOf(int s)
         {
             return set[s, la.kind];
         }
 
         void ExpectWeak(int n, int follow)
         {
             if (la.kind == n) Get();
             else
             {
                 SynErr(n);
                 while (!StartOf(follow)) Get();
             }
         }
 
 
         bool WeakSeparator(int n, int syFol, int repFol)
         {
             int kind = la.kind;
             if (kind == n) { Get(); return true; }
             else if (StartOf(repFol)) { return false; }
             else
             {
                 SynErr(n);
                 while (!(set[syFol, kind] || set[repFol, kind] || set[0, kind]))
                 {
                     Get();
                     kind = la.kind;
                 }
                 return StartOf(syFol);
             }
         }
 
 
         void C()
         {
             while (la.kind == 75)
             {
                 IncludeDirective();
             }
             while (StartOf(1) || la.kind == 33 || la.kind == 37)
             {
                 TypeDeclaration();
             }
         }
 
         void IncludeDirective()
         {
             Application.DoEvents();
             TokenMatch tm = new TokenMatch();
             Expect(75);
             tm.Position = la.pos;
             tm.Value = la.val;
             while (scanner.Peek().line == la.line)
             {
                 Get();
                 tm.Value += la.val;
             }
             Get();
             this.m_CodeInfo.Includes.Add(tm);
         }
 
         void TypeDeclaration()
         {
             Application.DoEvents();
             this.m_DataType = "";
             while ((StartOf(2) || la.kind == 33 || la.kind == 37) && la.kind != 0)
             {
                 this.m_DataType += la.val + " ";
                 Get();
             }
 
             int tempPos = la.pos;
             if (StartOf(3))
             {
                 this.m_Current = "";
                 Type();
                 this.m_DataType += this.m_Current;
             }
             else if (la.kind == 1)
             {
                 this.m_DataType += la.val;
                 Get();
             }
             else SynErr(83);
 
             if (StartOf(3))
             {
                 this.m_Current = "";
                 Type();
                 this.m_DataType +=  " " + this.m_Current;
             }
 
             TokenMatch tm = new TokenMatch(la.val, la.pos);
             if (la.val == "{" && this.m_DataType.Trim().ToLower().IndexOf("struct") == 0)
             {
                 Block();
                 Expect(70);
                 tm.Position = tempPos;
                 tm.Value = this.m_DataType.Substring(6).Trim();
                 this.m_CodeInfo.Structs.Add(tm);
             }
             else if (this.m_DataType.ToLower().IndexOf("typedef") == 0)
             {
                 // typedef...
                 if (la.val != "{")
                 {
                     tm.Position = la.pos;
                     tm.Value = la.val;
                     Get();
                 }
                 if (la.val == "{")
                 {
                     Block();
                     tm.Value = la.val;
                     tm.Position = la.pos;
                     Get();
                     while (la.kind != 70 && la.kind != 0)
                     {
                         tm.Value += " " + la.val;
                         Get();
                     }
                     tm.Value += "
                     Expect(70);
                 }
                 else
                 {
                     while (tm.Value == "*" && la.kind != 0)
                     {
                         tm.Value = la.val;
                         tm.Position = la.pos;
                         this.m_DataType += "*";
                         Get();
                     }
                     tm.Value += "
                     Expression();
                     Expect(70);
                 }
                 this.m_CodeInfo.TypeDefs.Add(tm);
             }
             else
             {
                 Application.DoEvents();
                 while (la.kind == 72 && la.kind != 0)
                 {
                     this.m_DataType += "*";
                     Get();
                 }
                 if (tm.Value == "*")
                 {
                     tm.Position = la.pos;
                     tm.Value = la.val;
                 }
                 Expect(1);
                 while (la.kind == 1 && la.kind != 0)
                 {
                     tm.Value += " " + la.val;
                     Get();
                 }
                 while (la.kind == 53 && la.kind != 0)
                 {
                     while (la.kind != 68)
                     {
                         Get();
                     }
                     Expect(68);
                     this.m_DataType += "[]";
                 }
 
                 if (la.kind == 70)
                 {
                     tm.Value += "
                     this.m_CodeInfo.GlobalVariables.Add(tm);
                     Get();
                     return;
                 }
 
                 if (la.val.Equals("("))
                 {
                     Function(tm);
                 }
                 else
                 {
                     Assignment(tm);
                 }
             }
         }
 
         #region -= Type =-
 
         void Type()
         {
             Application.DoEvents();
             this.m_Current += la.val;
             switch (la.kind)
             {
                 case 27
                     {
                         Get();
                         if (la.kind == 23)
                         {
                             this.m_Current += " " + la.val;
                             Get();
                         }
                         break;
                     }
                 case 24
                     {
                         Get();
                         if (la.kind == 19 || la.kind == 23)
                         {
                             this.m_Current += " " + la.val;
                             Get();
                         }
                         break;
                     }
                 case 78
                     {
                         Get();
                         if (la.kind == 10 || la.kind == 23 || la.kind == 24 || la.kind == 27)
                         {
                             this.m_Current += " " + la.val;
                             Get();
                         }
                         break;
                     }
                 case 10
                     {
                         Get();
                         break;
                     }
                 case 23
                     {
                         Get();
                         break;
                     }
                 case 19
                     {
                         Get();
                         break;
                     }
                 case 15
                     {
                         Get();
                         break;
                     }
                 case 36
                     {
                         Get();
                         break;
                     }
                 default
             }
         }
 
         #endregion
 
         void Expression()
         {
             Application.DoEvents();
             while (!la.val.Equals(";"))
             {
                 Get();
             }
         }
 
         #region -= Function =-
 
         void Function(TokenMatch tm)
         {
             Application.DoEvents();
             Expect(54);
             tm.Value += "(";
             if (StartOf(5) || StartOf(2))
             {
                 this.m_Current = "";
                 Parameters();
             }
             //tm.Value += ")";
             //Expect(69);
             if (this.m_Count == 2 && la.kind != 70)
             {
                 this.m_Current = "";
                 while (!la.val.Equals("{") && la.kind != 0)
                 {
                     if (la.kind == 70)
                     {
                         this.m_Current += ",";
                     }
                     else
                     {
                         this.m_Current += " " + la.val;
                     }
                     Get();
                 }
                 this.m_Current = this.m_Current.TrimEnd(new char[] { ',' }) + " )";
             }
 
             tm.Value += this.m_Current;
 
             if (la.val.Equals("{"))
             {
                 Block();
                 tm.Value += "
                 this.m_CodeInfo.Functions.Add(tm);
             }
             else
             {
                 while (la.kind != 70 && la.kind != 0)
                 {
                     Get();
                 }
                 tm.Value += "
                 this.m_CodeInfo.Prototypes.Add(tm);
                 Expect(70);
             }
         }
 
         #endregion
 
         void Assignment(TokenMatch tm)
         {
             Application.DoEvents();
             if (StartOf(4))
             {
                 Expression();
                 tm.Value += "
                 this.m_CodeInfo.GlobalVariables.Add(tm);
             }
             else if (la.kind == 43)
             {
                 // Comma(,)
                 tm.Value += "
                 this.m_CodeInfo.GlobalVariables.Add(tm);
                 bool comma = true;
                 while (la.kind != 70 && la.kind != 0)
                 {
                     Get();
                     if (comma)
                     {
                         this.m_CodeInfo.GlobalVariables.Add(new TokenMatch(la.val + "
                         comma = false;
                     }
                     else if (la.kind == 43)
                     {
                         comma = true;
                     }
                 }
             }
             Expect(70);
         }
 
         #region -= Assignment Operator =-
 
         void AssignmentOperator()
         {
             switch (la.kind)
             {
                 case 41
                     {
                         Get();
                         break;
                     }
                 case 73
                     {
                         Get();
                         break;
                     }
                 case 45
                     {
                         Get();
                         break;
                     }
                 case 60
                     {
                         Get();
                         break;
                     }
                 case 65
                     {
                         Get();
                         break;
                     }
                 case 59
                     {
                         Get();
                         break;
                     }
                 case 40
                     {
                         Get();
                         break;
                     }
                 case 74
                     {
                         Get();
                         break;
                     }
                 case 63
                     {
                         Get();
                         break;
                     }
                 case 55
                     {
                         Get();
                         break;
                     }
                 case 79
                     {
                         Get();
                         break;
                     }
                 default
             }
         }
 
         #endregion
 
         #region -= Block =-
 
         void Block()
         {
             Application.DoEvents();
             Expect(52);
             int oBrackCount = 1;
             int cBrackCount = 0;
             while (oBrackCount != cBrackCount && la.kind != 0)
             {
                 if (la.val.Equals("{"))
                 {
                     oBrackCount++;
                 }
                 if (la.val.Equals("}"))
                 {
                     cBrackCount++;
                 }
                 Get();
             }
             //Expect(67);
         }
 
         #endregion
 
         #region -= Parmeters =-
 
         void Parameters()
         {
             Application.DoEvents();
             this.m_Count = 0;
             int oPar = 1;
             int cPar = 0;
             while (cPar != oPar && la.kind != 0)
             {
                 if (la.kind == 43)
                 {
                     this.m_Current += la.val;
                     this.m_Count = 0;
                 }
                 else
                 {
                     this.m_Current += " " + la.val;
                     this.m_Count++;
                 }
 
                 if (la.val.Equals("void"))
                 {
                     this.m_Count++;
                 }
 
                 if (la.kind == 54)
                 {
                     oPar++;
                 }
                 if (la.kind == 69)
                 {
                     cPar++;
                 }
                 Get();
             }
         }
 
         #endregion
 
         public void Parse()
         {
             la = new Token();
             la.val = "";
             Get();
             C();
 
             Expect(0);
         }
 
         #region -= Set =-
 
         bool[,] set = {
         public Parser(Scanner scanner)
         {
             this.scanner = scanner;
             errors = new Errors();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="126" endline="131"><![CDATA[
 
         void SynErr(int n)
         {
             if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n);
             errDist = 0;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="132" endline="137"><![CDATA[
 
         public void SemErr(string msg)
         {
             if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg);
             errDist = 0;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="138" endline="226"><![CDATA[
 
         void Get()
         {
             for (; ; )
             {
                 t = la;
                 la = scanner.Scan();
                 if (la.kind <= maxT) { ++errDist; break; }
                 if (la.kind == 81)
                 {
                     //AddCCS(la.val);
                     string def = la.val.Replace("\t", " ");
                     def = def.Replace("#define", "");
                     int count = 0;
                     while (def[count] == ' ')
                     {
                         count++;
                     }
                     while (def[count] == ' ')
                     {
                         count++;
                     }
                     def = def.Trim();
                     bool space = false;
                     string temp = "";
                     for (int a = 0; a < def.Length; a++)
                     {
                         if (space && def[a] == ' ')
                         {
                         }
                         else if (def[a] == ' ')
                         {
                             space = true;
                             temp += def[a];
                         }
                         else
                         {
                             space = false;
                             temp += def[a];
                         }
                     }
                     for (int a = 0; a < def.Length; a++)
                     {
                         if (space && def[a] == ' ')
                         {
                         }
                         else if (def[a] == ' ')
                         {
                             space = true;
                             temp += def[a];
                         }
                         else
                         {
                             space = false;
                             temp += def[a];
                         }
                     }
                     while (temp.Substring(temp.Length - 1).Equals("\\"))
                     {
                         Get();
                         temp += " " + la.val;
                         int line = la.line;
                         while (scanner.Peek().line == line)
                         {
                             Get();
                             temp += " " + la.val;
                         }
                         while (scanner.Peek().line == line)
                         {
                             Get();
                             temp += " " + la.val;
                         }
                     }
                     while (temp.Substring(temp.Length - 1).Equals("\\"))
                     {
                         Get();
                         temp += " " + la.val;
                         int line = la.line;
                         while (scanner.Peek().line == line)
                         {
                             Get();
                             temp += " " + la.val;
                         }
                     }
                     TokenMatch tm = new TokenMatch(temp, la.pos + 8);
                     this.m_CodeInfo.Defines.Add(tm);
                 }
                 if (la.kind == 82)
                 {
                     //RemCCS(la.val);
                 }
                 if (la.kind == 83)
                 {
                     //IfPragma(la.val);
                 }
                 if (la.kind == 84)
                 {
                     //ElifOrElsePragma();
                 }
                 if (la.kind == 85)
                 {
                     //ElifOrElsePragma();
                 }
                 if (la.kind == 86)
                 {
                 }
                 if (la.kind == 87)
                 {
                 }
                 if (la.kind == 88)
                 {
                 }
                 if (la.kind == 89)
                 {
                 }
                 if (la.kind == 90)
                 {
                 }
                 if (la.kind == 91)
                 {
                 }
 
                 la = t;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="227" endline="231"><![CDATA[
 
         void Expect(int n)
         {
             if (la.kind == n) Get(); else { SynErr(n); }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="232" endline="236"><![CDATA[
 
         bool StartOf(int s)
         {
             return set[s, la.kind];
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="237" endline="246"><![CDATA[
 
         void ExpectWeak(int n, int follow)
         {
             if (la.kind == n) Get();
             else
             {
                 SynErr(n);
                 while (!StartOf(follow)) Get();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="247" endline="264"><![CDATA[
 
 
         bool WeakSeparator(int n, int syFol, int repFol)
         {
             int kind = la.kind;
             if (kind == n) { Get(); return true; }
             else if (StartOf(repFol)) { return false; }
             else
             {
                 SynErr(n);
                 while (!(set[syFol, kind] || set[repFol, kind] || set[0, kind]))
                 {
                     Get();
                     kind = la.kind;
                 }
                 while (!(set[syFol, kind] || set[repFol, kind] || set[0, kind]))
                 {
                     Get();
                     kind = la.kind;
                 }
                 return StartOf(syFol);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="265" endline="277"><![CDATA[
 
 
         void C()
         {
             while (la.kind == 75)
             {
                 IncludeDirective();
             }
             while (la.kind == 75)
             {
                 IncludeDirective();
             }
             while (StartOf(1) || la.kind == 33 || la.kind == 37)
             {
                 TypeDeclaration();
             }
             while (StartOf(1) || la.kind == 33 || la.kind == 37)
             {
                 TypeDeclaration();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="278" endline="293"><![CDATA[
 
         void IncludeDirective()
         {
             Application.DoEvents();
             TokenMatch tm = new TokenMatch();
             Expect(75);
             tm.Position = la.pos;
             tm.Value = la.val;
             while (scanner.Peek().line == la.line)
             {
                 Get();
                 tm.Value += la.val;
             }
             while (scanner.Peek().line == la.line)
             {
                 Get();
                 tm.Value += la.val;
             }
             Get();
             this.m_CodeInfo.Includes.Add(tm);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="294" endline="419"><![CDATA[
 
         void TypeDeclaration()
         {
             Application.DoEvents();
             this.m_DataType = "";
             while ((StartOf(2) || la.kind == 33 || la.kind == 37) && la.kind != 0)
             {
                 this.m_DataType += la.val + " ";
                 Get();
             }
             while ((StartOf(2) || la.kind == 33 || la.kind == 37) && la.kind != 0)
             {
                 this.m_DataType += la.val + " ";
                 Get();
             }
 
             int tempPos = la.pos;
             if (StartOf(3))
             {
                 this.m_Current = "";
                 Type();
                 this.m_DataType += this.m_Current;
             }
             else if (la.kind == 1)
             {
                 this.m_DataType += la.val;
                 Get();
             }
             else SynErr(83);
 
             if (StartOf(3))
             {
                 this.m_Current = "";
                 Type();
                 this.m_DataType +=  " " + this.m_Current;
             }
 
             TokenMatch tm = new TokenMatch(la.val, la.pos);
             if (la.val == "{" && this.m_DataType.Trim().ToLower().IndexOf("struct") == 0)
             {
                 Block();
                 Expect(70);
                 tm.Position = tempPos;
                 tm.Value = this.m_DataType.Substring(6).Trim();
                 this.m_CodeInfo.Structs.Add(tm);
             }
             else if (this.m_DataType.ToLower().IndexOf("typedef") == 0)
             {
                 // typedef...
                 if (la.val != "{")
                 {
                     tm.Position = la.pos;
                     tm.Value = la.val;
                     Get();
                 }
                 if (la.val == "{")
                 {
                     Block();
                     tm.Value = la.val;
                     tm.Position = la.pos;
                     Get();
                     while (la.kind != 70 && la.kind != 0)
                     {
                         tm.Value += " " + la.val;
                         Get();
                     }
                     while (la.kind != 70 && la.kind != 0)
                     {
                         tm.Value += " " + la.val;
                         Get();
                     }
                     tm.Value += "
                     Expect(70);
                 }
                 else
                 {
                     while (tm.Value == "*" && la.kind != 0)
                     {
                         tm.Value = la.val;
                         tm.Position = la.pos;
                         this.m_DataType += "*";
                         Get();
                     }
                     while (tm.Value == "*" && la.kind != 0)
                     {
                         tm.Value = la.val;
                         tm.Position = la.pos;
                         this.m_DataType += "*";
                         Get();
                     }
                     tm.Value += "
                     Expression();
                     Expect(70);
                 }
                 this.m_CodeInfo.TypeDefs.Add(tm);
             }
             else
             {
                 Application.DoEvents();
                 while (la.kind == 72 && la.kind != 0)
                 {
                     this.m_DataType += "*";
                     Get();
                 }
                 while (la.kind == 72 && la.kind != 0)
                 {
                     this.m_DataType += "*";
                     Get();
                 }
                 if (tm.Value == "*")
                 {
                     tm.Position = la.pos;
                     tm.Value = la.val;
                 }
                 Expect(1);
                 while (la.kind == 1 && la.kind != 0)
                 {
                     tm.Value += " " + la.val;
                     Get();
                 }
                 while (la.kind == 1 && la.kind != 0)
                 {
                     tm.Value += " " + la.val;
                     Get();
                 }
                 while (la.kind == 53 && la.kind != 0)
                 {
                     while (la.kind != 68)
                     {
                         Get();
                     }
                     while (la.kind != 68)
                     {
                         Get();
                     }
                     Expect(68);
                     this.m_DataType += "[]";
                 }
                 while (la.kind == 53 && la.kind != 0)
                 {
                     while (la.kind != 68)
                     {
                         Get();
                     }
                     Expect(68);
                     this.m_DataType += "[]";
                 }
 
                 if (la.kind == 70)
                 {
                     tm.Value += "
                     this.m_CodeInfo.GlobalVariables.Add(tm);
                     Get();
                     return;
                 }
 
                 if (la.val.Equals("("))
                 {
                     Function(tm);
                 }
                 else
                 {
                     Assignment(tm);
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="420" endline="486"><![CDATA[
 
         #region -= Type =-
 
         void Type()
         {
             Application.DoEvents();
             this.m_Current += la.val;
             switch (la.kind)
             {
                 case 27
                     {
                         Get();
                         if (la.kind == 23)
                         {
                             this.m_Current += " " + la.val;
                             Get();
                         }
                         break;
                     }
                 case 24
                     {
                         Get();
                         if (la.kind == 19 || la.kind == 23)
                         {
                             this.m_Current += " " + la.val;
                             Get();
                         }
                         break;
                     }
                 case 78
                     {
                         Get();
                         if (la.kind == 10 || la.kind == 23 || la.kind == 24 || la.kind == 27)
                         {
                             this.m_Current += " " + la.val;
                             Get();
                         }
                         break;
                     }
                 case 10
                     {
                         Get();
                         break;
                     }
                 case 23
                     {
                         Get();
                         break;
                     }
                 case 19
                     {
                         Get();
                         break;
                     }
                 case 15
                     {
                         Get();
                         break;
                     }
                 case 36
                     {
                         Get();
                         break;
                     }
                 default
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="487" endline="497"><![CDATA[
 
         #endregion
 
         void Expression()
         {
             Application.DoEvents();
             while (!la.val.Equals(";"))
             {
                 Get();
             }
             while (!la.val.Equals(";"))
             {
                 Get();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="498" endline="549"><![CDATA[
 
         #region -= Function =-
 
         void Function(TokenMatch tm)
         {
             Application.DoEvents();
             Expect(54);
             tm.Value += "(";
             if (StartOf(5) || StartOf(2))
             {
                 this.m_Current = "";
                 Parameters();
             }
             //tm.Value += ")";
             //Expect(69);
             if (this.m_Count == 2 && la.kind != 70)
             {
                 this.m_Current = "";
                 while (!la.val.Equals("{") && la.kind != 0)
                 {
                     if (la.kind == 70)
                     {
                         this.m_Current += ",";
                     }
                     else
                     {
                         this.m_Current += " " + la.val;
                     }
                     Get();
                 }
                 while (!la.val.Equals("{") && la.kind != 0)
                 {
                     if (la.kind == 70)
                     {
                         this.m_Current += ",";
                     }
                     else
                     {
                         this.m_Current += " " + la.val;
                     }
                     Get();
                 }
                 this.m_Current = this.m_Current.TrimEnd(new char[] { ',' }) + " )";
             }
 
             tm.Value += this.m_Current;
 
             if (la.val.Equals("{"))
             {
                 Block();
                 tm.Value += "
                 this.m_CodeInfo.Functions.Add(tm);
             }
             else
             {
                 while (la.kind != 70 && la.kind != 0)
                 {
                     Get();
                 }
                 while (la.kind != 70 && la.kind != 0)
                 {
                     Get();
                 }
                 tm.Value += "
                 this.m_CodeInfo.Prototypes.Add(tm);
                 Expect(70);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="550" endline="583"><![CDATA[
 
         #endregion
 
         void Assignment(TokenMatch tm)
         {
             Application.DoEvents();
             if (StartOf(4))
             {
                 Expression();
                 tm.Value += "
                 this.m_CodeInfo.GlobalVariables.Add(tm);
             }
             else if (la.kind == 43)
             {
                 // Comma(,)
                 tm.Value += "
                 this.m_CodeInfo.GlobalVariables.Add(tm);
                 bool comma = true;
                 while (la.kind != 70 && la.kind != 0)
                 {
                     Get();
                     if (comma)
                     {
                         this.m_CodeInfo.GlobalVariables.Add(new TokenMatch(la.val + "
                         comma = false;
                     }
                     else if (la.kind == 43)
                     {
                         comma = true;
                     }
                 }
                 while (la.kind != 70 && la.kind != 0)
                 {
                     Get();
                     if (comma)
                     {
                         this.m_CodeInfo.GlobalVariables.Add(new TokenMatch(la.val + "
                         comma = false;
                     }
                     else if (la.kind == 43)
                     {
                         comma = true;
                     }
                 }
             }
             Expect(70);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="584" endline="648"><![CDATA[
 
         #region -= Assignment Operator =-
 
         void AssignmentOperator()
         {
             switch (la.kind)
             {
                 case 41
                     {
                         Get();
                         break;
                     }
                 case 73
                     {
                         Get();
                         break;
                     }
                 case 45
                     {
                         Get();
                         break;
                     }
                 case 60
                     {
                         Get();
                         break;
                     }
                 case 65
                     {
                         Get();
                         break;
                     }
                 case 59
                     {
                         Get();
                         break;
                     }
                 case 40
                     {
                         Get();
                         break;
                     }
                 case 74
                     {
                         Get();
                         break;
                     }
                 case 63
                     {
                         Get();
                         break;
                     }
                 case 55
                     {
                         Get();
                         break;
                     }
                 case 79
                     {
                         Get();
                         break;
                     }
                 default
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="649" endline="673"><![CDATA[
 
         #endregion
 
         #region -= Block =-
 
         void Block()
         {
             Application.DoEvents();
             Expect(52);
             int oBrackCount = 1;
             int cBrackCount = 0;
             while (oBrackCount != cBrackCount && la.kind != 0)
             {
                 if (la.val.Equals("{"))
                 {
                     oBrackCount++;
                 }
                 if (la.val.Equals("}"))
                 {
                     cBrackCount++;
                 }
                 Get();
             }
             while (oBrackCount != cBrackCount && la.kind != 0)
             {
                 if (la.val.Equals("{"))
                 {
                     oBrackCount++;
                 }
                 if (la.val.Equals("}"))
                 {
                     cBrackCount++;
                 }
                 Get();
             }
             //Expect(67);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="674" endline="713"><![CDATA[
 
         #endregion
 
         #region -= Parmeters =-
 
         void Parameters()
         {
             Application.DoEvents();
             this.m_Count = 0;
             int oPar = 1;
             int cPar = 0;
             while (cPar != oPar && la.kind != 0)
             {
                 if (la.kind == 43)
                 {
                     this.m_Current += la.val;
                     this.m_Count = 0;
                 }
                 else
                 {
                     this.m_Current += " " + la.val;
                     this.m_Count++;
                 }
 
                 if (la.val.Equals("void"))
                 {
                     this.m_Count++;
                 }
 
                 if (la.kind == 54)
                 {
                     oPar++;
                 }
                 if (la.kind == 69)
                 {
                     cPar++;
                 }
                 Get();
             }
             while (cPar != oPar && la.kind != 0)
             {
                 if (la.kind == 43)
                 {
                     this.m_Current += la.val;
                     this.m_Count = 0;
                 }
                 else
                 {
                     this.m_Current += " " + la.val;
                     this.m_Count++;
                 }
 
                 if (la.val.Equals("void"))
                 {
                     this.m_Count++;
                 }
 
                 if (la.kind == 54)
                 {
                     oPar++;
                 }
                 if (la.kind == 69)
                 {
                     cPar++;
                 }
                 Get();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="714" endline="725"><![CDATA[
 
         #endregion
 
         public void Parse()
         {
             la = new Token();
             la.val = "";
             Get();
             C();
 
             Expect(0);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="726" endline="850"><![CDATA[
 
         #region -= Set =-
 
         bool[,] set = {
 		{T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
 		{x,T,x,x, x,x,T,x, x,x,T,T, x,x,x,T, x,x,T,T, x,x,x,T, T,x,x,T, x,x,T,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x},
 		{x,x,x,x, x,x,T,x, x,x,x,T, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x},
 		{x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,T, x,x,x,T, x,x,x,T, T,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x},
 		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,x,x, x,T,x,x, x,x,x,x, x,x,x,T, x,x,x,T, T,x,x,T, x,T,x,x, x,x,x,x, x,T,T,x, x,x,x,T, x,x},
 		{x,T,x,x, x,x,x,x, x,x,T,x, x,x,x,T, x,x,x,T, x,x,x,T, T,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,T,x, x,x},
 		{x,T,x,x, x,x,x,x, x,x,T,x, x,x,x,T, x,x,x,T, x,x,x,T, T,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x}
 
 	    };
 
         #endregion
 
     } // end Parser
 
     #region -= Errors =-
 
     public class Errors
     {
         public int count = 0;                                    // number of errors detected
         public System.IO.TextWriter errorStream = Console.Out;   // error messages go to this stream
         public string errMsgFormat = "-- line {0} col {1}
 
         public void SynErr(int line, int col, int n)
         {
             string s;
             switch (n)
             {
                 case 0
                 case 1
                 case 2
                 case 3
                 case 4
                 case 5
                 case 6
                 case 7
                 case 8
                 case 9
                 case 10
                 case 11
                 case 12
                 case 13
                 case 14
                 case 15
                 case 16
                 case 17
                 case 18
                 case 19
                 case 20
                 case 21
                 case 22
                 case 23
                 case 24
                 case 25
                 case 26
                 case 27
                 case 28
                 case 29
                 case 30
                 case 31
                 case 32
                 case 33
                 case 34
                 case 35
                 case 36
                 case 37
                 case 38
                 case 39
                 case 40
                 case 41
                 case 42
                 case 43
                 case 44
                 case 45
                 case 46
                 case 47
                 case 48
                 case 49
                 case 50
                 case 51
                 case 52
                 case 53
                 case 54
                 case 55
                 case 56
                 case 57
                 case 58
                 case 59
                 case 60
                 case 61
                 case 62
                 case 63
                 case 64
                 case 65
                 case 66
                 case 67
                 case 68
                 case 69
                 case 70
                 case 71
                 case 72
                 case 73
                 case 74
                 case 75
                 case 76
                 case 77
                 case 78
                 case 79
                 case 80
                 case 81
                 case 82
                 case 83
                 case 84
                 case 85
                 case 86
                 case 87
 
                 default
             }
             errorStream.WriteLine(errMsgFormat, line, col, s);
             count++;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="851" endline="856"><![CDATA[
 
         public void SemErr(int line, int col, string s)
         {
             errorStream.WriteLine(errMsgFormat, line, col, s);
             count++;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="857" endline="862"><![CDATA[
 
         public void SemErr(string s)
         {
             errorStream.WriteLine(s);
             count++;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="863" endline="867"><![CDATA[
 
         public void Warning(int line, int col, string s)
         {
             errorStream.WriteLine(errMsgFormat, line, col, s);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="868" endline="872"><![CDATA[
 
         public void Warning(string s)
         {
             errorStream.WriteLine(s);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="748" endline="750"><![CDATA[
         public int count = 0;                                    // number of errors detected
         public System.IO.TextWriter errorStream = Console.Out;   // error messages go to this stream
         public string errMsgFormat = "-- line {0} col {1}
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSSParser\CSSParser.cs" startline="751" endline="878"><![CDATA[
 
         public void SynErr(int line, int col, int n)
         {
             string s;
             switch (n)
             {
                 case 0
                 case 1
                 case 2
                 case 3
                 case 4
                 case 5
                 case 6
                 case 7
                 case 8
                 case 9
                 case 10
                 case 11
                 case 12
                 case 13
                 case 14
                 case 15
                 case 16
                 case 17
                 case 18
                 case 19
                 case 20
                 case 21
                 case 22
                 case 23
                 case 24
                 case 25
                 case 26
                 case 27
                 case 28
                 case 29
                 case 30
                 case 31
                 case 32
                 case 33
                 case 34
                 case 35
                 case 36
                 case 37
                 case 38
                 case 39
                 case 40
                 case 41
                 case 42
                 case 43
                 case 44
                 case 45
                 case 46
                 case 47
                 case 48
                 case 49
                 case 50
                 case 51
                 case 52
                 case 53
                 case 54
                 case 55
                 case 56
                 case 57
                 case 58
                 case 59
                 case 60
                 case 61
                 case 62
                 case 63
                 case 64
                 case 65
                 case 66
                 case 67
                 case 68
                 case 69
                 case 70
                 case 71
                 case 72
                 case 73
                 case 74
                 case 75
                 case 76
                 case 77
                 case 78
                 case 79
                 case 80
                 case 81
                 case 82
                 case 83
                 case 84
                 case 85
                 case 86
                 case 87
 
                 default
             }
             errorStream.WriteLine(errMsgFormat, line, col, s);
             count++;
         }
 
         public void SemErr(int line, int col, string s)
         {
             errorStream.WriteLine(errMsgFormat, line, col, s);
             count++;
         }
 
         public void SemErr(string s)
         {
             errorStream.WriteLine(s);
             count++;
         }
 
         public void Warning(int line, int col, string s)
         {
             errorStream.WriteLine(errMsgFormat, line, col, s);
         }
 
         public void Warning(string s)
         {
             errorStream.WriteLine(s);
         }
     } // Errors
 
 
     public class FatalError 
     {
         public FatalError(string m) 
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="53" endline="56"><![CDATA[
         public cHtmlToolTip(IHtmlInterface parent)
         {
             Startup(parent);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="57" endline="63"><![CDATA[
 
         public cHtmlToolTip(string html, Point location, IHtmlInterface parent)
         {
             Startup(parent);
             this.HTML = html;
             this.m_ToolTip.Location = location;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="64" endline="82"><![CDATA[
 
         private void Startup(IHtmlInterface parent)
         {
             this.m_Showing = false;
             this.m_ToolTip = new fHtmlToolTip();
             this.m_ToolTip.WebBrowser.Navigate("about
             while (this.m_ToolTip.WebBrowser.Document.Body == null) Application.DoEvents();
             this.m_ToolTip.WebBrowser.Document.Click += new HtmlElementEventHandler(Document_Click);
             this.m_Timer = new Timer();
             this.m_Timer.Interval = 5000;
             this.m_Timer.Tick += new EventHandler(TimerTick);
             this.m_Parent = parent;
 
             this.m_Shadow = new Form();
             this.m_Shadow.ShowInTaskbar = false;
             this.m_Shadow.FormBorderStyle = FormBorderStyle.None;
             this.m_Shadow.BackColor = Color.Black;
             this.m_Shadow.GotFocus += new EventHandler(Shadow_GotFocus);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="83" endline="87"><![CDATA[
 
         void Shadow_GotFocus (object sender, EventArgs e)
         {
             this.m_ToolTip.Focus();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="88" endline="100"><![CDATA[
 
         void Document_Click (object sender, HtmlElementEventArgs e)
         {
             if (this.m_Parent != null)
             {
                 if (this.m_ToolTip.WebBrowser.Document.ActiveElement.TagName.Equals("A"))
                 {
                     this.m_Parent.LinkClick(this.m_ToolTip.WebBrowser.Document.ActiveElement);
                     this.m_Shadow.Hide();
                     this.m_ToolTip.Hide();
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="101" endline="110"><![CDATA[
 
         void TimerTick (object sender, EventArgs e)
         {
             if (!this.m_ToolTip.CanClose())
             {
                 this.m_Shadow.Hide();
                 this.m_ToolTip.Hide();
                 this.m_Timer.Stop();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="111" endline="122"><![CDATA[
 
         /// <summary>
         /// Sets the HTML of the document giving the ability to use CSS and scripts.
         /// </summary>
         private string Doc_HTML
         {
             set
             {
                 IHTMLDocument2 doc = (IHTMLDocument2)this.m_ToolTip.WebBrowser.Document.DomDocument;
                 doc.write(value);
                 doc.close();
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="123" endline="130"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets the HTML of the ToolTip...
         /// </summary>
         public string HTML
         {
             get { return this.m_HTML; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="131" endline="146"><![CDATA[
 
             set
             {
                 this.m_HTML = value;
                 StringBuilder sb = new StringBuilder();
                 sb.Append("<html><head><title>ToolTip</title>");
                 sb.Append("<style type=\"text/css\">");
                 sb.Append("table {margin
                 sb.Append("a
                 sb.Append("ul ul { list-style
                 sb.Append("</style>");
                 sb.Append("</head><body style=\"background
                 sb.Append(value);
                 sb.Append("</body></html>");
                 this.Doc_HTML = sb.ToString();
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="147" endline="154"><![CDATA[
         }
 
         /// <summary>
         /// Get or Sets the Delay of the Tool Tip
         /// </summary>
         public int Delay
         {
             get { return this.m_Timer.Interval; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="155" endline="163"><![CDATA[
 
             set
             {
                 if (this.m_Timer.Enabled)
                 {
                     this.m_Timer.Stop();
                 }
                 this.m_Timer.Interval = value;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="164" endline="171"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets if the Tool Tip if Visible...
         /// </summary>
         public bool Visible
         {
             get { return this.m_ToolTip.Visible; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="172" endline="172"><![CDATA[
             set { this.m_ToolTip.Visible = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="173" endline="180"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets the Location of the Tool Tip...
         /// </summary>
         public Point Location
         {
             get { return this.m_ToolTip.Location; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="181" endline="181"><![CDATA[
             set { this.m_ToolTip.Location = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="182" endline="194"><![CDATA[
         }
 
         /// <summary>
         /// Hides the Tool Tip...
         /// </summary>
         public void Hide ()
         {
 
             Timer tHide = new Timer();
             tHide.Interval = 10;
             tHide.Tick += new EventHandler(tHideTick);
             tHide.Start();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="195" endline="216"><![CDATA[
 
         void tHideTick (object sender, EventArgs e)
         {
             if (this.m_Showing)
             {
                 Timer t = (Timer)sender;
                 t.Stop();
                 return;
             }
             if (this.m_ToolTip.Opacity <= 0)
             {
                 Timer t = (Timer)sender;
                 t.Stop();
                 this.m_Shadow.Hide();
                 this.m_ToolTip.Hide();
             }
             else
             {
                 this.m_Shadow.Opacity -= .10;
                 this.m_ToolTip.Opacity -= .20;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="217" endline="266"><![CDATA[
 
         /// <summary>
         /// Shows the Tool Tip...
         /// </summary>
         public void Show ()
         {
             this.m_Showing = true;
             this.m_ToolTip.WebBrowser.ScrollBarsEnabled = false;
             this.m_ToolTip.Height = this.m_ToolTip.WebBrowser.Document.Body.ScrollRectangle.Height;
             this.m_ToolTip.Width = this.m_ToolTip.WebBrowser.Document.Body.ScrollRectangle.Width;
 
             int left = this.m_ToolTip.Location.X;
             int top = this.m_ToolTip.Location.Y;
 
             if (this.m_ToolTip.Height > 500)
             {
                 this.m_ToolTip.Height = 500;
                 this.m_ToolTip.WebBrowser.ScrollBarsEnabled = true;
             }
 
             if (this.m_Timer.Enabled)
             {
                 this.m_Timer.Stop();
             }
 
             if (Screen.PrimaryScreen.Bounds.Right < (left + this.m_ToolTip.Width))
                 left = Screen.PrimaryScreen.Bounds.Right - this.m_ToolTip.Width - 5;
             if (Screen.PrimaryScreen.Bounds.Bottom < (top + this.m_ToolTip.Height))
                 top = Screen.PrimaryScreen.Bounds.Bottom - this.m_ToolTip.Height - 5;
 
             this.m_Timer.Start();
 
             this.m_ToolTip.Opacity = 0;
             this.m_Shadow.Opacity = 0;
             this.m_Shadow.Show();
 
             SetWindowPos(this.m_Shadow.Handle.ToInt32(), HWND_TOPMOST, left + 3,
                 top + 3, this.m_ToolTip.Width, this.m_ToolTip.Height, SWP_NOACTIVATE);
             ShowWindow(this.m_Shadow.Handle.ToInt32(), SW_SHOWNOACTIVATE);
 
             SetWindowPos(this.m_ToolTip.Handle.ToInt32(), HWND_TOPMOST, left,
                 top, this.m_ToolTip.Width, this.m_ToolTip.Height, SWP_NOACTIVATE);
             ShowWindow(this.m_ToolTip.Handle.ToInt32(), SW_SHOWNOACTIVATE);
             //this.m_ToolTip.Show();
 
             Timer tShow = new Timer();
             tShow.Interval = 20;
             tShow.Tick += new EventHandler(tShowTick);
             tShow.Start();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="267" endline="281"><![CDATA[
 
         void tShowTick (object sender, EventArgs e)
         {
             if (this.m_ToolTip.Opacity >= 1)
             {
                 Timer t = (Timer)sender;
                 t.Stop();
                 this.m_Showing = false;
             }
             else
             {
                 this.m_ToolTip.Opacity += .10;
                 this.m_Shadow.Opacity += .05;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="33" endline="33"><![CDATA[
             get { return this.m_CodeInfo; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="25" endline="40"><![CDATA[
         int errDist = minErrDist;
         private VBCodeInfo m_CodeInfo = new VBCodeInfo();
 
         //public Util util = new Util();
 
 
         public VBCodeInfo CodeInfo
         {
             get { return this.m_CodeInfo; }
         }
 
         public Parser(Scanner scanner)
         {
             this.scanner = scanner;
             errors = new Errors();
         }
 
         void SynErr(int n)
         {
             if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n);
             errDist = 0;
         }
 
         public void SemErr(string msg)
         {
             if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg);
             errDist = 0;
         }
 
         void Get()
         {
             for (; ; )
             {
                 t = la;
                 la = scanner.Scan();
                 if (la.kind <= maxT) { ++errDist; break; }
 
                 la = t;
             }
         }
 
         void Expect(int n)
         {
             if (la.kind == n) Get(); else { SynErr(n); }
         }
 
         bool StartOf(int s)
         {
             return set[s, la.kind];
         }
 
         void ExpectWeak(int n, int follow)
         {
             if (la.kind == n) Get();
             else
             {
                 SynErr(n);
                 while (!StartOf(follow)) Get();
             }
         }
 
 
         bool WeakSeparator(int n, int syFol, int repFol)
         {
             int kind = la.kind;
             if (kind == n) { Get(); return true; }
             else if (StartOf(repFol)) { return false; }
             else
             {
                 SynErr(n);
                 while (!(set[syFol, kind] || set[repFol, kind] || set[0, kind]))
                 {
                     Get();
                     kind = la.kind;
                 }
                 return StartOf(syFol);
             }
         }
 
 
         void VBNET()
         {
             string modifier = "";
             while (la.kind == 5)
             {
                 OptionStmt();
             }
             while (la.kind == 4)
             {
                 ImportStmt();
             }
             if (la.kind == 39)
             {
                 AttributeList();
             }
             if (StartOf(1))
             {
                 ModifierGroup(out modifier);
             }
             TypeDeclaration(modifier);
         }
 
         void OptionStmt()
         {
             Expect(5);
             if (la.kind == 6)
             {
                 Get();
                 if (la.kind == 7)
                 {
                     Get();
                 }
                 else if (la.kind == 8)
                 {
                     Get();
                 }
                 else SynErr(90);
             }
             else if (la.kind == 9)
             {
                 Get();
                 if (la.kind == 7)
                 {
                     Get();
                 }
                 else if (la.kind == 8)
                 {
                     Get();
                 }
                 else SynErr(91);
             }
             else if (la.kind == 10)
             {
                 Get();
                 if (la.kind == 11)
                 {
                     Get();
                 }
                 else if (la.kind == 12)
                 {
                     Get();
                 }
                 else SynErr(92);
             }
             else SynErr(93);
         }
 
         void ImportStmt()
         {
             string nmspc;
             Expect(4);
             this.m_CodeInfo.Imports.Add(new TokenMatch(la.val, la.pos));
             QualName(out nmspc);
             //util.Writeline("using " + nmspc + ";");
         }
 
         void AttributeList()
         {
             string attlist;
             string attspec;
 
             Expect(39);
             AttribSpec(out attlist);
             while (la.kind == 15)
             {
                 Get();
                 attlist += la.val;
                 AttribSpec(out attspec);
                 attlist += attspec;
             }
             Expect(40);
             //util.Writeline("[" + attlist + "]");
 
         }
 
         void ModifierGroup(out string modgroup)
         {
             string modifier;
             modgroup = "";
 
             Modifier(out modifier);
             modgroup += modifier;
             while (StartOf(1))
             {
                 Modifier(out modifier);
                 modgroup += modifier;
             }
         }
 
         void TypeDeclaration(string modifier)
         {
             string bases = "";
             string decl = modifier;
             string typename;
 
             if (la.kind == 16)
             {
                 Get();
                 decl += "class ";
             }
             else if (la.kind == 17)
             {
                 Get();
                 decl += "struct ";
             }
             else SynErr(94);
             QualName(out typename);
             decl += typename;
             if (la.kind == 13)
             {
                 InheritanceDecl(out bases);
             }
             if (la.kind == 14)
             {
                 ImplementsDecl(ref bases);
             }
             decl += bases;
             //util.Writeline(decl);
             //util.OpenBlock();
 
             while (StartOf(2))
             {
                 MemberDeclaration();
             }
             Expect(18);
             if (la.kind == 16)
             {
                 Get();
             }
             else if (la.kind == 19)
             {
                 Get();
             }
             else SynErr(95);
             //util.CloseBlock();
         }
 
         void Modifier(out string modifier)
         {
             switch (la.kind)
             {
                 case 46
                     {
                         Get();
                         break;
                     }
                 case 47
                     {
                         Get();
                         break;
                     }
                 case 48
                     {
                         Get();
                         break;
                     }
                 case 49
                     {
                         Get();
                         break;
                     }
                 case 50
                     {
                         Get();
                         break;
                     }
                 case 51
                     {
                         Get();
                         break;
                     }
                 default
             }
             modifier = la.val;// util.ConvertModifier(la.val);
 
         }
 
         void QualName(out string typename)
         {
             Expect(3);
             typename = la.val;// util.ConverteTipo(la.val);
         }
 
         void InheritanceDecl(out string decl)
         {
             string typename;
             Expect(13);
             QualName(out typename);
             decl = " 
         }
 
         void ImplementsDecl(ref string decl)
         {
             string typename;
             Expect(14);
             QualName(out typename);
             if (decl == "")
                 decl = " 
             else
                 decl += ", " + typename;
 
             while (la.kind == 15)
             {
                 Get();
                 QualName(out typename);
                 decl += ", " + typename;
 
             }
         }
 
         void MemberDeclaration()
         {
             string modifier = "";
 
             if (la.kind == 39)
             {
                 AttributeList();
             }
             if (StartOf(1))
             {
                 ModifierGroup(out modifier);
             }
             switch (la.kind)
             {
                 case 52
                     {
                         InterfaceDeclaration(modifier);
                         break;
                     }
                 case 16
                 case 17
                     {
                         TypeDeclaration(modifier);
                         break;
                     }
                 case 53
                     {
                         EnumDeclaration(modifier);
                         break;
                     }
                 case 60
                     {
                         SubDeclaration(modifier);
                         break;
                     }
                 case 61
                     {
                         FunctionDeclaration(modifier);
                         break;
                     }
                 case 57
                     {
                         ConstDeclaration(modifier);
                         break;
                     }
                 case 3
                     {
                         FieldDeclaration(modifier);
                         break;
                     }
                 case 54
                     {
                         BeginRegion();
                         break;
                     }
                 case 55
                     {
                         EndRegion();
                         break;
                     }
                 default
             }
         }
 
         void ArithOp(out string op)
         {
             op = "";
             switch (la.kind)
             {
                 case 20
                 case 21
                 case 22
                 case 23
                     {
                         if (la.kind == 20)
                         {
                             Get();
                         }
                         else if (la.kind == 21)
                         {
                             Get();
                         }
                         else if (la.kind == 22)
                         {
                             Get();
                         }
                         else
                         {
                             Get();
                         }
                         op = la.val;
                         break;
                     }
                 case 24
                     {
                         Get();
                         op = "/";
                         break;
                     }
                 case 25
                     {
                         Get();
                         op = "%";
                         break;
                     }
                 case 26
                     {
                         Get();
                         op = "+";
                         break;
                     }
                 case 27
                     {
                         Get();
                         op = "!";
                         break;
                     }
                 case 44
                 case 45
                     {
                         BoolOp(out op);
                         break;
                     }
                 case 38
                 case 39
                 case 40
                 case 41
                 case 42
                 case 43
                     {
                         LogicalOp(out op);
                         break;
                     }
                 default
             }
         }
 
         void BoolOp(out string op)
         {
             op = "";
             if (la.kind == 44)
             {
                 Get();
                 op = " && ";
             }
             else if (la.kind == 45)
             {
                 Get();
                 op = " || ";
             }
             else SynErr(99);
         }
 
         void LogicalOp(out string op)
         {
             switch (la.kind)
             {
                 case 38
                     {
                         Get();
                         break;
                     }
                 case 39
                     {
                         Get();
                         break;
                     }
                 case 40
                     {
                         Get();
                         break;
                     }
                 case 41
                     {
                         Get();
                         break;
                     }
                 case 42
                     {
                         Get();
                         break;
                     }
                 case 43
                     {
                         Get();
                         break;
                     }
                 default
             }
             op = la.val;//util.ConverteLogicalOp(la.val);
         }
 
         void ArithExpr(out string exp)
         {
             string op, exp2;
             ArithOp(out op);
             Expression(out exp2);
             exp = op + " " + exp2;
         }
 
         void Expression(out string exp)
         {
             string parms = "";
             string typename;
             string exp2 = "";
             exp = "";
 
             switch (la.kind)
             {
                 case 32
                     {
                         Get();
                         exp = "true";
                         break;
                     }
                 case 33
                     {
                         Get();
                         exp = "false";
                         break;
                     }
                 case 34
                     {
                         Get();
                         exp = "null";
                         break;
                     }
                 case 35
                     {
                         Get();
                         exp = "this";
                         break;
                     }
                 case 28
                     {
                         TypeOfExp(out exp);
                         break;
                     }
                 case 1
                     {
                         NumericConstant(out exp);
                         break;
                     }
                 case 2
                     {
                         StringConstant(out exp);
                         break;
                     }
                 case 30
                     {
                         ParentExp(out exp);
                         break;
                     }
                 case 3
                     {
                         QualName(out exp);
                         if (la.kind == 29 || la.kind == 30)
                         {
                             if (la.kind == 29)
                             {
                                 Get();
                                 Expect(34);
                                 exp += " == null";
                             }
                             else
                             {
                                 CallParams(out parms);
                                 exp += parms;
                                 if (la.kind == 36)
                                 {
                                     Get();
                                     Expression(out exp2);
                                     exp += "." + exp2;
                                 }
                             }
                         }
                         break;
                     }
                 case 37
                     {
                         Get();
                         QualName(out typename);
                         if (la.kind == 30)
                         {
                             CallParams(out parms);
                         }
                         exp = "new " + typename + parms;
                         break;
                     }
                 default
             }
             if (StartOf(3))
             {
                 ArithExpr(out exp2);
                 exp += exp2;
             }
         }
 
         void TypeOfExp(out string exp)
         {
             string exp2, typespec;
             Expect(28);
             QualName(out exp2);
             Expect(29);
             QualName(out typespec);
             exp = exp2 + " is " + typespec;
         }
 
         void ParentExp(out string exp)
         {
             string exp2;
             Expect(30);
             Expression(out exp2);
             Expect(31);
             exp = "(" + exp2 + ")";
         }
 
         void NumericConstant(out string exp)
         {
             Expect(1);
             exp = la.val;
         }
 
         void StringConstant(out string exp)
         {
             Expect(2);
             exp = la.val;//util.ConverteString(la.val);
         }
 
         void CallParams(out string parms)
         {
             string expList;
             Expect(30);
             parms = la.val;
             if (StartOf(4))
             {
                 ExpressionList(out expList);
                 parms += expList;
             }
             Expect(31);
             parms += la.val;
         }
 
         void ExpressionList(out string expList)
         {
             string exp;
             Expression(out exp);
             expList = exp;
             while (la.kind == 15)
             {
                 Get();
                 expList += la.val + " ";
                 Expression(out exp);
                 expList += exp;
             }
         }
 
         void AttribSpec(out string attspec)
         {
             string pl;
             string typename;
 
             QualName(out typename);
             attspec = typename;
             if (la.kind == 30)
             {
                 CallParams(out pl);
                 attspec += pl;
             }
         }
 
         void InterfaceDeclaration(string modifier)
         {
             Expect(52);
             Expect(3);
             //util.Writeline(modifier + "interface " + la.val);
             //util.OpenBlock();
 
             while (la.kind == 60 || la.kind == 61)
             {
                 if (la.kind == 60)
                 {
                     SubHeader("");
                 }
                 else
                 {
                     FunctionHeader("");
                 }
             }
             Expect(18);
             Expect(52);
             //util.CloseBlock();
         }
 
         void EnumDeclaration(string modifier)
         {
             string constName;
             string constValue;
 
             Expect(53);
             Expect(3);
             //util.Writeline(modifier + " enum " + la.val);
             //util.OpenBlock();
 
             while (la.kind == 3)
             {
                 Get();
                 constName = la.val; constValue = null;
                 if (la.kind == 38)
                 {
                     Get();
                     Expression(out constValue);
                 }
                 //if (constValue == null)
                     //util.Writeline(constName);
                 //else
                     //util.Writeline(constName + " = " + constValue);
 
             }
             Expect(18);
             Expect(53);
             //util.CloseBlock();
         }
 
         void SubDeclaration(string modifier)
         {
             SubHeader(modifier);
             //util.OpenBlock();
             if (StartOf(5))
             {
                 RoutineBody();
             }
             Expect(18);
             Expect(60);
             //util.CloseBlock();
         }
 
         void FunctionDeclaration(string modifier)
         {
             FunctionHeader(modifier);
             //util.OpenBlock();
             if (StartOf(5))
             {
                 RoutineBody();
             }
             Expect(18);
             Expect(61);
             //util.CloseBlock();
         }
 
         void ConstDeclaration(string modifier)
         {
             string decl;
             Expect(57);
             VarDeclaration(out decl);
             //util.Writeline(modifier + "const " + decl + ";");
         }
 
         void FieldDeclaration(string modifier)
         {
             string decl;
             VarDeclaration(out decl);
             //util.Writeline(modifier + decl + ";");
         }
 
         void BeginRegion()
         {
             Expect(54);
             Expect(2);
             //util.Writeline("#region " + la.val);
         }
 
         void EndRegion()
         {
             Expect(55);
             Expect(56);
             //util.Writeline("#endregion");
         }
 
         void SubHeader(string modifier)
         {
             string decl = modifier;
             string paramList;
 
             Expect(60);
             decl += "void ";
             Expect(3);
             decl += la.val;
             if (la.kind == 30)
             {
                 ParameterList(out paramList);
                 decl += paramList;
             }
             //if (modifier == "") // In interface declaration?
                 //util.Writeline(decl + ";");
             //else
                 //util.Writeline(decl);
 
             if (la.kind == 14)
             {
                 SubImplementsInterface();
             }
             if (la.kind == 59)
             {
                 Handles();
             }
         }
 
         void FunctionHeader(string modifier)
         {
             string funcName;
             string paramList = "";
             string returnType;
 
             Expect(61);
             Expect(3);
             funcName = la.val;
             if (la.kind == 30)
             {
                 ParameterList(out paramList);
             }
             Expect(58);
             QualName(out returnType);
             //util.Writeline(modifier + returnType + " " + funcName + paramList);
 
             if (la.kind == 14)
             {
                 SubImplementsInterface();
             }
             if (la.kind == 59)
             {
                 Handles();
             }
         }
 
         void VarDeclaration(out string declaration)
         {
             string typename;
             string varname;
             string exp;
             string dimensions = null;
             bool bIsArray = false;
             string parms = "";
             declaration = "";
 
             QualName(out varname);
             if (la.kind == 30)
             {
                 Get();
                 if (StartOf(4))
                 {
                     ExpressionList(out dimensions);
                 }
                 Expect(31);
                 bIsArray = true;
             }
             Expect(58);
             if (la.kind == 37)
             {
                 Get();
                 QualName(out typename);
                 if (la.kind == 30)
                 {
                     CallParams(out parms);
                 }
                 declaration = typename + " " + varname + " = new " + typename + parms;
 
             }
             else if (la.kind == 3)
             {
                 QualName(out typename);
                 if (!bIsArray)
                     declaration = typename + " " + varname;
                 else
                 {
                     declaration = typename + "[] " + varname;
                     if (dimensions != null)
                         declaration += String.Format(" = new {0}[{1}]", typename, dimensions);
                 }
 
             }
             else SynErr(102);
             if (la.kind == 38)
             {
                 Get();
                 Expression(out exp);
                 declaration += " = " + exp;
             }
         }
 
         void SubImplementsInterface()
         {
             string lixo;
 
             Expect(14);
             QualName(out lixo);
         }
 
         void Handles()
         {
             string lixo;
 
             Expect(59);
             QualName(out lixo);
         }
 
         void ParameterList(out string paramList)
         {
             string decl;
             Expect(30);
             paramList = la.val;
             if (la.kind == 3 || la.kind == 87 || la.kind == 88)
             {
                 ParameterDeclaration(out decl);
                 paramList += decl;
                 while (la.kind == 15)
                 {
                     Get();
                     paramList += la.val + " ";
                     ParameterDeclaration(out decl);
                     paramList += decl;
                 }
             }
             Expect(31);
             paramList += la.val;
         }
 
         void RoutineBody()
         {
             RoutineStmt();
             while (StartOf(5))
             {
                 RoutineStmt();
             }
         }
 
         void RoutineStmt()
         {
             switch (la.kind)
             {
                 case 3
                     {
                         AssignCall();
                         break;
                     }
                 case 62
                     {
                         SyncLockStmt();
                         break;
                     }
                 case 63
                     {
                         ThrowStmt();
                         break;
                     }
                 case 64
                     {
                         DoWhileStmt();
                         break;
                     }
                 case 68
                     {
                         ExitStmt();
                         break;
                     }
                 case 66
                     {
                         WhileStmt();
                         break;
                     }
                 case 75
                     {
                         CallStmt();
                         break;
                     }
                 case 80
                     {
                         SelectCase();
                         break;
                     }
                 case 69
                     {
                         ForStmt();
                         break;
                     }
                 case 85
                     {
                         IfStmt();
                         break;
                     }
                 case 77
                     {
                         TryCatch();
                         break;
                     }
                 case 76
                     {
                         ReturnStmt();
                         break;
                     }
                 case 57
                 case 86
                     {
                         LocalDeclaration();
                         break;
                     }
                 default
             }
         }
 
         void AssignCall()
         {
             string call;
             string operation = "";
             string rvalue = null;
 
             LeftAssign(out call);
             if (StartOf(6))
             {
                 if (StartOf(7))
                 {
                     if (la.kind == 20)
                     {
                         Get();
                     }
                     else if (la.kind == 21)
                     {
                         Get();
                     }
                     else if (la.kind == 22)
                     {
                         Get();
                     }
                     else if (la.kind == 23)
                     {
                         Get();
                     }
                     else
                     {
                         Get();
                         operation = la.val;
                     }
                 }
                 Expect(38);
                 Expression(out rvalue);
             }
             //if (rvalue != null)
                 //util.Writeline(call + " " + operation + "= " + rvalue + ";");
             //else
                 //util.Writeline(call + ";");
 
         }
 
         void SyncLockStmt()
         {
             string exp;
             Expect(62);
             Expression(out exp);
             //util.Writeline("lock (" + exp + ")");
             //util.OpenBlock();
 
             if (StartOf(5))
             {
                 RoutineBody();
             }
             Expect(18);
             Expect(62);
             //util.CloseBlock();
         }
 
         void ThrowStmt()
         {
             string exp;
             Expect(63);
             Expression(out exp);
             //util.Writeline("throw " + exp + ";");
         }
 
         void DoWhileStmt()
         {
             string exp;
             Expect(64);
             //util.Writeline("do");
             //util.OpenBlock();
 
             RoutineBody();
             Expect(65);
             if (la.kind == 66)
             {
                 Get();
                 Expression(out exp);
                 //util.CloseBlock();
                 //util.Writeline("while (" + exp + ")");
 
             }
             else if (la.kind == 67)
             {
                 Get();
                 Expression(out exp);
                 //util.CloseBlock();
                 //util.Writeline("while (!(" + exp + "))");
 
             }
             else SynErr(104);
         }
 
         void ExitStmt()
         {
             Expect(68);
             if (la.kind == 69)
             {
                 Get();
             }
             else if (la.kind == 66)
             {
                 Get();
             }
             else if (la.kind == 64)
             {
                 Get();
             }
             else SynErr(105);
             //util.Writeline("break;");
         }
 
         void WhileStmt()
         {
             string exp;
             Expect(66);
             Expression(out exp);
             //util.Writeline("while (" + exp + ")");
             //util.OpenBlock();
 
             if (StartOf(5))
             {
                 RoutineBody();
             }
             Expect(18);
             Expect(66);
             //util.CloseBlock();
         }
 
         void CallStmt()
         {
             string funcname;
             string parms = "";
 
             Expect(75);
             QualName(out funcname);
             if (la.kind == 30)
             {
                 CallParams(out parms);
             }
             //util.Writeline(funcname + parms + ";");
         }
 
         void SelectCase()
         {
             string exp;
             Expect(80);
             Expect(81);
             Expression(out exp);
             //util.Writeline("switch (" + exp + ")");
             //util.OpenBlock();
 
             CaseStmts();
             Expect(18);
             Expect(80);
             //util.CloseBlock();
         }
 
         void ForStmt()
         {
             Expect(69);
             if (la.kind == 3)
             {
                 ForVar();
             }
             else if (la.kind == 73)
             {
                 ForEach();
             }
             else SynErr(106);
         }
 
         void IfStmt()
         {
             string exp;
             Expect(85);
             Expression(out exp);
             Expect(84);
             //util.Writeline("if (" + exp + ")");
             //util.OpenBlock();
 
             RoutineBody();
             if (la.kind == 82 || la.kind == 83)
             {
                 ElseStmt();
             }
             Expect(18);
             Expect(85);
             //util.CloseBlock();
 
         }
 
         void TryCatch()
         {
             string varname = "Exception";
             Expect(77);
             //util.Writeline("try");
             //util.OpenBlock();
 
             RoutineBody();
             if (la.kind == 78)
             {
                 Get();
                 if (la.kind == 3)
                 {
                     VarDeclaration(out varname);
                 }
                 //util.CloseBlock();
                 //util.Writeline("catch (" + varname + ")");
                 //util.OpenBlock();
 
                 if (StartOf(5))
                 {
                     RoutineBody();
                 }
             }
             if (la.kind == 79)
             {
                 Get();
                 //util.CloseBlock();
                 //util.Writeline("finally");
                 //util.OpenBlock();
 
                 RoutineBody();
             }
             Expect(18);
             Expect(77);
             //util.CloseBlock();
 
         }
 
         void ReturnStmt()
         {
             string exp;
             Expect(76);
             Expression(out exp);
             //util.Writeline("return " + exp + ";");
         }
 
         void LocalDeclaration()
         {
             string decl;
             //string constant = "";
 
             if (la.kind == 86)
             {
                 Get();
             }
             else if (la.kind == 57)
             {
                 Get();
                 //constant = "const ";
             }
             else SynErr(107);
             VarDeclaration(out decl);
             //util.Writeline(constant + decl + ";");
             while (la.kind == 15)
             {
                 Get();
                 VarDeclaration(out decl);
                 //util.Writeline(constant + decl + ";");
             }
         }
 
         void ForVar()
         {
             string loopvar;
             string expIni;
             string expEnd;
             string stepExp;
             string stepCS;
 
             QualName(out loopvar);
             stepCS = loopvar + "++";
             Expect(38);
             Expression(out expIni);
             Expect(70);
             Expression(out expEnd);
             if (la.kind == 71)
             {
                 Get();
                 Expression(out stepExp);
                 stepCS = loopvar + " += " + stepExp;
             }
             //util.Writeline(string.Format("for ({0}={1}; {0} <= {2}; {3})", loopvar, expIni, expEnd, stepCS));
             //util.OpenBlock();
 
             RoutineBody();
             Expect(72);
             if (la.kind == 3)
             {
                 Get();
             }
             //util.CloseBlock();
 
         }
 
         void ForEach()
         {
             string loopvar;
             string expIni;
 
             Expect(73);
             QualName(out loopvar);
             Expect(74);
             Expression(out expIni);
             //util.Writeline(string.Format("foreach ({0} in {1})", loopvar, expIni));
             //util.OpenBlock();
 
             RoutineBody();
             Expect(72);
             if (la.kind == 3)
             {
                 Get();
             }
             //util.CloseBlock();
 
         }
 
         void CaseStmts()
         {
             CaseStmt();
             while (la.kind == 81)
             {
                 CaseStmt();
             }
         }
 
         void CaseStmt()
         {
             string exp;
             Expect(81);
             if (la.kind == 82)
             {
                 Get();
                 //util.Writeline("default
                 //util.Ident();
 
             }
             else if (StartOf(4))
             {
                 Expression(out exp);
                 //util.Writeline("case " + exp + "
                 //util.Ident();
 
                 while (la.kind == 15)
                 {
                     Get();
                     Expression(out exp);
                     //util.Unident();
                     //util.Writeline("case " + exp + "
                     //util.Ident();
 
                 }
             }
             else SynErr(108);
             RoutineBody();
             //util.Unident();
 
         }
 
         void ElseStmt()
         {
             string exp;
             if (la.kind == 82)
             {
                 Get();
                 //util.CloseBlock();
                 //util.Writeline("else");
                 //util.OpenBlock();
 
                 RoutineBody();
             }
             else if (la.kind == 83)
             {
                 Get();
                 Expression(out exp);
                 Expect(84);
                 //util.CloseBlock();
                 //util.Writeline("else if (" + exp + ")");
                 //util.OpenBlock();
 
                 RoutineBody();
                 if (la.kind == 82 || la.kind == 83)
                 {
                     ElseStmt();
                 }
             }
             else SynErr(109);
         }
 
         void LeftAssign(out string call)
         {
             string typename, pl, call2;
             QualName(out typename);
             call = typename;
             if (la.kind == 30)
             {
                 CallParams(out pl);
                 call += pl;
                 if (la.kind == 36)
                 {
                     Get();
                     LeftAssign(out call2);
                     call += "." + call2;
                 }
             }
         }
 
         void ParameterDeclaration(out string declaration)
         {
             string decl;
             if (la.kind == 87 || la.kind == 88)
             {
                 if (la.kind == 87)
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                 }
             }
             declaration = la.val;//util.ConvertByX(la.val);
             VarDeclaration(out decl);
             declaration += decl;
         }
 
 
 
         public void Parse()
         {
             la = new Token();
             la.val = "";
             Get();
             VBNET();
 
             Expect(0);
         }
 
         bool[,] set = {
         public Parser(Scanner scanner)
         {
             this.scanner = scanner;
             errors = new Errors();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="41" endline="46"><![CDATA[
 
         void SynErr(int n)
         {
             if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n);
             errDist = 0;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="47" endline="52"><![CDATA[
 
         public void SemErr(string msg)
         {
             if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg);
             errDist = 0;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="53" endline="64"><![CDATA[
 
         void Get()
         {
             for (; ; )
             {
                 t = la;
                 la = scanner.Scan();
                 if (la.kind <= maxT) { ++errDist; break; }
 
                 la = t;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="65" endline="69"><![CDATA[
 
         void Expect(int n)
         {
             if (la.kind == n) Get(); else { SynErr(n); }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="70" endline="74"><![CDATA[
 
         bool StartOf(int s)
         {
             return set[s, la.kind];
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="75" endline="84"><![CDATA[
 
         void ExpectWeak(int n, int follow)
         {
             if (la.kind == n) Get();
             else
             {
                 SynErr(n);
                 while (!StartOf(follow)) Get();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="85" endline="102"><![CDATA[
 
 
         bool WeakSeparator(int n, int syFol, int repFol)
         {
             int kind = la.kind;
             if (kind == n) { Get(); return true; }
             else if (StartOf(repFol)) { return false; }
             else
             {
                 SynErr(n);
                 while (!(set[syFol, kind] || set[repFol, kind] || set[0, kind]))
                 {
                     Get();
                     kind = la.kind;
                 }
                 while (!(set[syFol, kind] || set[repFol, kind] || set[0, kind]))
                 {
                     Get();
                     kind = la.kind;
                 }
                 return StartOf(syFol);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="103" endline="125"><![CDATA[
 
 
         void VBNET()
         {
             string modifier = "";
             while (la.kind == 5)
             {
                 OptionStmt();
             }
             while (la.kind == 5)
             {
                 OptionStmt();
             }
             while (la.kind == 4)
             {
                 ImportStmt();
             }
             while (la.kind == 4)
             {
                 ImportStmt();
             }
             if (la.kind == 39)
             {
                 AttributeList();
             }
             if (StartOf(1))
             {
                 ModifierGroup(out modifier);
             }
             TypeDeclaration(modifier);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="126" endline="170"><![CDATA[
 
         void OptionStmt()
         {
             Expect(5);
             if (la.kind == 6)
             {
                 Get();
                 if (la.kind == 7)
                 {
                     Get();
                 }
                 else if (la.kind == 8)
                 {
                     Get();
                 }
                 else SynErr(90);
             }
             else if (la.kind == 9)
             {
                 Get();
                 if (la.kind == 7)
                 {
                     Get();
                 }
                 else if (la.kind == 8)
                 {
                     Get();
                 }
                 else SynErr(91);
             }
             else if (la.kind == 10)
             {
                 Get();
                 if (la.kind == 11)
                 {
                     Get();
                 }
                 else if (la.kind == 12)
                 {
                     Get();
                 }
                 else SynErr(92);
             }
             else SynErr(93);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="171" endline="179"><![CDATA[
 
         void ImportStmt()
         {
             string nmspc;
             Expect(4);
             this.m_CodeInfo.Imports.Add(new TokenMatch(la.val, la.pos));
             QualName(out nmspc);
             //util.Writeline("using " + nmspc + ";");
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="180" endline="198"><![CDATA[
 
         void AttributeList()
         {
             string attlist;
             string attspec;
 
             Expect(39);
             AttribSpec(out attlist);
             while (la.kind == 15)
             {
                 Get();
                 attlist += la.val;
                 AttribSpec(out attspec);
                 attlist += attspec;
             }
             while (la.kind == 15)
             {
                 Get();
                 attlist += la.val;
                 AttribSpec(out attspec);
                 attlist += attspec;
             }
             Expect(40);
             //util.Writeline("[" + attlist + "]");
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="199" endline="212"><![CDATA[
 
         void ModifierGroup(out string modgroup)
         {
             string modifier;
             modgroup = "";
 
             Modifier(out modifier);
             modgroup += modifier;
             while (StartOf(1))
             {
                 Modifier(out modifier);
                 modgroup += modifier;
             }
             while (StartOf(1))
             {
                 Modifier(out modifier);
                 modgroup += modifier;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="213" endline="260"><![CDATA[
 
         void TypeDeclaration(string modifier)
         {
             string bases = "";
             string decl = modifier;
             string typename;
 
             if (la.kind == 16)
             {
                 Get();
                 decl += "class ";
             }
             else if (la.kind == 17)
             {
                 Get();
                 decl += "struct ";
             }
             else SynErr(94);
             QualName(out typename);
             decl += typename;
             if (la.kind == 13)
             {
                 InheritanceDecl(out bases);
             }
             if (la.kind == 14)
             {
                 ImplementsDecl(ref bases);
             }
             decl += bases;
             //util.Writeline(decl);
             //util.OpenBlock();
 
             while (StartOf(2))
             {
                 MemberDeclaration();
             }
             while (StartOf(2))
             {
                 MemberDeclaration();
             }
             Expect(18);
             if (la.kind == 16)
             {
                 Get();
             }
             else if (la.kind == 19)
             {
                 Get();
             }
             else SynErr(95);
             //util.CloseBlock();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="261" endline="300"><![CDATA[
 
         void Modifier(out string modifier)
         {
             switch (la.kind)
             {
                 case 46
                     {
                         Get();
                         break;
                     }
                 case 47
                     {
                         Get();
                         break;
                     }
                 case 48
                     {
                         Get();
                         break;
                     }
                 case 49
                     {
                         Get();
                         break;
                     }
                 case 50
                     {
                         Get();
                         break;
                     }
                 case 51
                     {
                         Get();
                         break;
                     }
                 default
             }
             modifier = la.val;// util.ConvertModifier(la.val);
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="301" endline="306"><![CDATA[
 
         void QualName(out string typename)
         {
             Expect(3);
             typename = la.val;// util.ConverteTipo(la.val);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="307" endline="314"><![CDATA[
 
         void InheritanceDecl(out string decl)
         {
             string typename;
             Expect(13);
             QualName(out typename);
             decl = " 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="315" endline="333"><![CDATA[
 
         void ImplementsDecl(ref string decl)
         {
             string typename;
             Expect(14);
             QualName(out typename);
             if (decl == "")
                 decl = " 
             else
                 decl += ", " + typename;
 
             while (la.kind == 15)
             {
                 Get();
                 QualName(out typename);
                 decl += ", " + typename;
 
             }
             while (la.kind == 15)
             {
                 Get();
                 QualName(out typename);
                 decl += ", " + typename;
 
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="334" endline="397"><![CDATA[
 
         void MemberDeclaration()
         {
             string modifier = "";
 
             if (la.kind == 39)
             {
                 AttributeList();
             }
             if (StartOf(1))
             {
                 ModifierGroup(out modifier);
             }
             switch (la.kind)
             {
                 case 52
                     {
                         InterfaceDeclaration(modifier);
                         break;
                     }
                 case 16
                 case 17
                     {
                         TypeDeclaration(modifier);
                         break;
                     }
                 case 53
                     {
                         EnumDeclaration(modifier);
                         break;
                     }
                 case 60
                     {
                         SubDeclaration(modifier);
                         break;
                     }
                 case 61
                     {
                         FunctionDeclaration(modifier);
                         break;
                     }
                 case 57
                     {
                         ConstDeclaration(modifier);
                         break;
                     }
                 case 3
                     {
                         FieldDeclaration(modifier);
                         break;
                     }
                 case 54
                     {
                         BeginRegion();
                         break;
                     }
                 case 55
                     {
                         EndRegion();
                         break;
                     }
                 default
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="398" endline="470"><![CDATA[
 
         void ArithOp(out string op)
         {
             op = "";
             switch (la.kind)
             {
                 case 20
                 case 21
                 case 22
                 case 23
                     {
                         if (la.kind == 20)
                         {
                             Get();
                         }
                         else if (la.kind == 21)
                         {
                             Get();
                         }
                         else if (la.kind == 22)
                         {
                             Get();
                         }
                         else
                         {
                             Get();
                         }
                         op = la.val;
                         break;
                     }
                 case 24
                     {
                         Get();
                         op = "/";
                         break;
                     }
                 case 25
                     {
                         Get();
                         op = "%";
                         break;
                     }
                 case 26
                     {
                         Get();
                         op = "+";
                         break;
                     }
                 case 27
                     {
                         Get();
                         op = "!";
                         break;
                     }
                 case 44
                 case 45
                     {
                         BoolOp(out op);
                         break;
                     }
                 case 38
                 case 39
                 case 40
                 case 41
                 case 42
                 case 43
                     {
                         LogicalOp(out op);
                         break;
                     }
                 default
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="471" endline="486"><![CDATA[
 
         void BoolOp(out string op)
         {
             op = "";
             if (la.kind == 44)
             {
                 Get();
                 op = " && ";
             }
             else if (la.kind == 45)
             {
                 Get();
                 op = " || ";
             }
             else SynErr(99);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="487" endline="525"><![CDATA[
 
         void LogicalOp(out string op)
         {
             switch (la.kind)
             {
                 case 38
                     {
                         Get();
                         break;
                     }
                 case 39
                     {
                         Get();
                         break;
                     }
                 case 40
                     {
                         Get();
                         break;
                     }
                 case 41
                     {
                         Get();
                         break;
                     }
                 case 42
                     {
                         Get();
                         break;
                     }
                 case 43
                     {
                         Get();
                         break;
                     }
                 default
             }
             op = la.val;//util.ConverteLogicalOp(la.val);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="526" endline="533"><![CDATA[
 
         void ArithExpr(out string exp)
         {
             string op, exp2;
             ArithOp(out op);
             Expression(out exp2);
             exp = op + " " + exp2;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="534" endline="631"><![CDATA[
 
         void Expression(out string exp)
         {
             string parms = "";
             string typename;
             string exp2 = "";
             exp = "";
 
             switch (la.kind)
             {
                 case 32
                     {
                         Get();
                         exp = "true";
                         break;
                     }
                 case 33
                     {
                         Get();
                         exp = "false";
                         break;
                     }
                 case 34
                     {
                         Get();
                         exp = "null";
                         break;
                     }
                 case 35
                     {
                         Get();
                         exp = "this";
                         break;
                     }
                 case 28
                     {
                         TypeOfExp(out exp);
                         break;
                     }
                 case 1
                     {
                         NumericConstant(out exp);
                         break;
                     }
                 case 2
                     {
                         StringConstant(out exp);
                         break;
                     }
                 case 30
                     {
                         ParentExp(out exp);
                         break;
                     }
                 case 3
                     {
                         QualName(out exp);
                         if (la.kind == 29 || la.kind == 30)
                         {
                             if (la.kind == 29)
                             {
                                 Get();
                                 Expect(34);
                                 exp += " == null";
                             }
                             else
                             {
                                 CallParams(out parms);
                                 exp += parms;
                                 if (la.kind == 36)
                                 {
                                     Get();
                                     Expression(out exp2);
                                     exp += "." + exp2;
                                 }
                             }
                         }
                         break;
                     }
                 case 37
                     {
                         Get();
                         QualName(out typename);
                         if (la.kind == 30)
                         {
                             CallParams(out parms);
                         }
                         exp = "new " + typename + parms;
                         break;
                     }
                 default
             }
             if (StartOf(3))
             {
                 ArithExpr(out exp2);
                 exp += exp2;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="632" endline="641"><![CDATA[
 
         void TypeOfExp(out string exp)
         {
             string exp2, typespec;
             Expect(28);
             QualName(out exp2);
             Expect(29);
             QualName(out typespec);
             exp = exp2 + " is " + typespec;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="642" endline="650"><![CDATA[
 
         void ParentExp(out string exp)
         {
             string exp2;
             Expect(30);
             Expression(out exp2);
             Expect(31);
             exp = "(" + exp2 + ")";
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="651" endline="656"><![CDATA[
 
         void NumericConstant(out string exp)
         {
             Expect(1);
             exp = la.val;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="657" endline="662"><![CDATA[
 
         void StringConstant(out string exp)
         {
             Expect(2);
             exp = la.val;//util.ConverteString(la.val);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="663" endline="676"><![CDATA[
 
         void CallParams(out string parms)
         {
             string expList;
             Expect(30);
             parms = la.val;
             if (StartOf(4))
             {
                 ExpressionList(out expList);
                 parms += expList;
             }
             Expect(31);
             parms += la.val;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="677" endline="690"><![CDATA[
 
         void ExpressionList(out string expList)
         {
             string exp;
             Expression(out exp);
             expList = exp;
             while (la.kind == 15)
             {
                 Get();
                 expList += la.val + " ";
                 Expression(out exp);
                 expList += exp;
             }
             while (la.kind == 15)
             {
                 Get();
                 expList += la.val + " ";
                 Expression(out exp);
                 expList += exp;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="691" endline="704"><![CDATA[
 
         void AttribSpec(out string attspec)
         {
             string pl;
             string typename;
 
             QualName(out typename);
             attspec = typename;
             if (la.kind == 30)
             {
                 CallParams(out pl);
                 attspec += pl;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="705" endline="727"><![CDATA[
 
         void InterfaceDeclaration(string modifier)
         {
             Expect(52);
             Expect(3);
             //util.Writeline(modifier + "interface " + la.val);
             //util.OpenBlock();
 
             while (la.kind == 60 || la.kind == 61)
             {
                 if (la.kind == 60)
                 {
                     SubHeader("");
                 }
                 else
                 {
                     FunctionHeader("");
                 }
             }
             while (la.kind == 60 || la.kind == 61)
             {
                 if (la.kind == 60)
                 {
                     SubHeader("");
                 }
                 else
                 {
                     FunctionHeader("");
                 }
             }
             Expect(18);
             Expect(52);
             //util.CloseBlock();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="728" endline="757"><![CDATA[
 
         void EnumDeclaration(string modifier)
         {
             string constName;
             string constValue;
 
             Expect(53);
             Expect(3);
             //util.Writeline(modifier + " enum " + la.val);
             //util.OpenBlock();
 
             while (la.kind == 3)
             {
                 Get();
                 constName = la.val; constValue = null;
                 if (la.kind == 38)
                 {
                     Get();
                     Expression(out constValue);
                 }
                 //if (constValue == null)
                     //util.Writeline(constName);
                 //else
                     //util.Writeline(constName + " = " + constValue);
 
             }
             while (la.kind == 3)
             {
                 Get();
                 constName = la.val; constValue = null;
                 if (la.kind == 38)
                 {
                     Get();
                     Expression(out constValue);
                 }
                 //if (constValue == null)
                     //util.Writeline(constName);
                 //else
                     //util.Writeline(constName + " = " + constValue);
 
             }
             Expect(18);
             Expect(53);
             //util.CloseBlock();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="758" endline="770"><![CDATA[
 
         void SubDeclaration(string modifier)
         {
             SubHeader(modifier);
             //util.OpenBlock();
             if (StartOf(5))
             {
                 RoutineBody();
             }
             Expect(18);
             Expect(60);
             //util.CloseBlock();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="771" endline="783"><![CDATA[
 
         void FunctionDeclaration(string modifier)
         {
             FunctionHeader(modifier);
             //util.OpenBlock();
             if (StartOf(5))
             {
                 RoutineBody();
             }
             Expect(18);
             Expect(61);
             //util.CloseBlock();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="784" endline="791"><![CDATA[
 
         void ConstDeclaration(string modifier)
         {
             string decl;
             Expect(57);
             VarDeclaration(out decl);
             //util.Writeline(modifier + "const " + decl + ";");
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="792" endline="798"><![CDATA[
 
         void FieldDeclaration(string modifier)
         {
             string decl;
             VarDeclaration(out decl);
             //util.Writeline(modifier + decl + ";");
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="799" endline="805"><![CDATA[
 
         void BeginRegion()
         {
             Expect(54);
             Expect(2);
             //util.Writeline("#region " + la.val);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="806" endline="812"><![CDATA[
 
         void EndRegion()
         {
             Expect(55);
             Expect(56);
             //util.Writeline("#endregion");
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="813" endline="841"><![CDATA[
 
         void SubHeader(string modifier)
         {
             string decl = modifier;
             string paramList;
 
             Expect(60);
             decl += "void ";
             Expect(3);
             decl += la.val;
             if (la.kind == 30)
             {
                 ParameterList(out paramList);
                 decl += paramList;
             }
             //if (modifier == "") // In interface declaration?
                 //util.Writeline(decl + ";");
             //else
                 //util.Writeline(decl);
 
             if (la.kind == 14)
             {
                 SubImplementsInterface();
             }
             if (la.kind == 59)
             {
                 Handles();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="842" endline="868"><![CDATA[
 
         void FunctionHeader(string modifier)
         {
             string funcName;
             string paramList = "";
             string returnType;
 
             Expect(61);
             Expect(3);
             funcName = la.val;
             if (la.kind == 30)
             {
                 ParameterList(out paramList);
             }
             Expect(58);
             QualName(out returnType);
             //util.Writeline(modifier + returnType + " " + funcName + paramList);
 
             if (la.kind == 14)
             {
                 SubImplementsInterface();
             }
             if (la.kind == 59)
             {
                 Handles();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="869" endline="923"><![CDATA[
 
         void VarDeclaration(out string declaration)
         {
             string typename;
             string varname;
             string exp;
             string dimensions = null;
             bool bIsArray = false;
             string parms = "";
             declaration = "";
 
             QualName(out varname);
             if (la.kind == 30)
             {
                 Get();
                 if (StartOf(4))
                 {
                     ExpressionList(out dimensions);
                 }
                 Expect(31);
                 bIsArray = true;
             }
             Expect(58);
             if (la.kind == 37)
             {
                 Get();
                 QualName(out typename);
                 if (la.kind == 30)
                 {
                     CallParams(out parms);
                 }
                 declaration = typename + " " + varname + " = new " + typename + parms;
 
             }
             else if (la.kind == 3)
             {
                 QualName(out typename);
                 if (!bIsArray)
                     declaration = typename + " " + varname;
                 else
                 {
                     declaration = typename + "[] " + varname;
                     if (dimensions != null)
                         declaration += String.Format(" = new {0}[{1}]", typename, dimensions);
                 }
 
             }
             else SynErr(102);
             if (la.kind == 38)
             {
                 Get();
                 Expression(out exp);
                 declaration += " = " + exp;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="924" endline="931"><![CDATA[
 
         void SubImplementsInterface()
         {
             string lixo;
 
             Expect(14);
             QualName(out lixo);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="932" endline="939"><![CDATA[
 
         void Handles()
         {
             string lixo;
 
             Expect(59);
             QualName(out lixo);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="940" endline="960"><![CDATA[
 
         void ParameterList(out string paramList)
         {
             string decl;
             Expect(30);
             paramList = la.val;
             if (la.kind == 3 || la.kind == 87 || la.kind == 88)
             {
                 ParameterDeclaration(out decl);
                 paramList += decl;
                 while (la.kind == 15)
                 {
                     Get();
                     paramList += la.val + " ";
                     ParameterDeclaration(out decl);
                     paramList += decl;
                 }
                 while (la.kind == 15)
                 {
                     Get();
                     paramList += la.val + " ";
                     ParameterDeclaration(out decl);
                     paramList += decl;
                 }
             }
             Expect(31);
             paramList += la.val;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="961" endline="969"><![CDATA[
 
         void RoutineBody()
         {
             RoutineStmt();
             while (StartOf(5))
             {
                 RoutineStmt();
             }
             while (StartOf(5))
             {
                 RoutineStmt();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="970" endline="1043"><![CDATA[
 
         void RoutineStmt()
         {
             switch (la.kind)
             {
                 case 3
                     {
                         AssignCall();
                         break;
                     }
                 case 62
                     {
                         SyncLockStmt();
                         break;
                     }
                 case 63
                     {
                         ThrowStmt();
                         break;
                     }
                 case 64
                     {
                         DoWhileStmt();
                         break;
                     }
                 case 68
                     {
                         ExitStmt();
                         break;
                     }
                 case 66
                     {
                         WhileStmt();
                         break;
                     }
                 case 75
                     {
                         CallStmt();
                         break;
                     }
                 case 80
                     {
                         SelectCase();
                         break;
                     }
                 case 69
                     {
                         ForStmt();
                         break;
                     }
                 case 85
                     {
                         IfStmt();
                         break;
                     }
                 case 77
                     {
                         TryCatch();
                         break;
                     }
                 case 76
                     {
                         ReturnStmt();
                         break;
                     }
                 case 57
                 case 86
                     {
                         LocalDeclaration();
                         break;
                     }
                 default
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1044" endline="1086"><![CDATA[
 
         void AssignCall()
         {
             string call;
             string operation = "";
             string rvalue = null;
 
             LeftAssign(out call);
             if (StartOf(6))
             {
                 if (StartOf(7))
                 {
                     if (la.kind == 20)
                     {
                         Get();
                     }
                     else if (la.kind == 21)
                     {
                         Get();
                     }
                     else if (la.kind == 22)
                     {
                         Get();
                     }
                     else if (la.kind == 23)
                     {
                         Get();
                     }
                     else
                     {
                         Get();
                         operation = la.val;
                     }
                 }
                 Expect(38);
                 Expression(out rvalue);
             }
             //if (rvalue != null)
                 //util.Writeline(call + " " + operation + "= " + rvalue + ";");
             //else
                 //util.Writeline(call + ";");
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1087" endline="1103"><![CDATA[
 
         void SyncLockStmt()
         {
             string exp;
             Expect(62);
             Expression(out exp);
             //util.Writeline("lock (" + exp + ")");
             //util.OpenBlock();
 
             if (StartOf(5))
             {
                 RoutineBody();
             }
             Expect(18);
             Expect(62);
             //util.CloseBlock();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1104" endline="1111"><![CDATA[
 
         void ThrowStmt()
         {
             string exp;
             Expect(63);
             Expression(out exp);
             //util.Writeline("throw " + exp + ";");
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1112" endline="1139"><![CDATA[
 
         void DoWhileStmt()
         {
             string exp;
             Expect(64);
             //util.Writeline("do");
             //util.OpenBlock();
 
             RoutineBody();
             Expect(65);
             if (la.kind == 66)
             {
                 Get();
                 Expression(out exp);
                 //util.CloseBlock();
                 //util.Writeline("while (" + exp + ")");
 
             }
             else if (la.kind == 67)
             {
                 Get();
                 Expression(out exp);
                 //util.CloseBlock();
                 //util.Writeline("while (!(" + exp + "))");
 
             }
             else SynErr(104);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1140" endline="1158"><![CDATA[
 
         void ExitStmt()
         {
             Expect(68);
             if (la.kind == 69)
             {
                 Get();
             }
             else if (la.kind == 66)
             {
                 Get();
             }
             else if (la.kind == 64)
             {
                 Get();
             }
             else SynErr(105);
             //util.Writeline("break;");
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1159" endline="1175"><![CDATA[
 
         void WhileStmt()
         {
             string exp;
             Expect(66);
             Expression(out exp);
             //util.Writeline("while (" + exp + ")");
             //util.OpenBlock();
 
             if (StartOf(5))
             {
                 RoutineBody();
             }
             Expect(18);
             Expect(66);
             //util.CloseBlock();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1176" endline="1189"><![CDATA[
 
         void CallStmt()
         {
             string funcname;
             string parms = "";
 
             Expect(75);
             QualName(out funcname);
             if (la.kind == 30)
             {
                 CallParams(out parms);
             }
             //util.Writeline(funcname + parms + ";");
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1190" endline="1204"><![CDATA[
 
         void SelectCase()
         {
             string exp;
             Expect(80);
             Expect(81);
             Expression(out exp);
             //util.Writeline("switch (" + exp + ")");
             //util.OpenBlock();
 
             CaseStmts();
             Expect(18);
             Expect(80);
             //util.CloseBlock();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1205" endline="1218"><![CDATA[
 
         void ForStmt()
         {
             Expect(69);
             if (la.kind == 3)
             {
                 ForVar();
             }
             else if (la.kind == 73)
             {
                 ForEach();
             }
             else SynErr(106);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1219" endline="1238"><![CDATA[
 
         void IfStmt()
         {
             string exp;
             Expect(85);
             Expression(out exp);
             Expect(84);
             //util.Writeline("if (" + exp + ")");
             //util.OpenBlock();
 
             RoutineBody();
             if (la.kind == 82 || la.kind == 83)
             {
                 ElseStmt();
             }
             Expect(18);
             Expect(85);
             //util.CloseBlock();
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1239" endline="1277"><![CDATA[
 
         void TryCatch()
         {
             string varname = "Exception";
             Expect(77);
             //util.Writeline("try");
             //util.OpenBlock();
 
             RoutineBody();
             if (la.kind == 78)
             {
                 Get();
                 if (la.kind == 3)
                 {
                     VarDeclaration(out varname);
                 }
                 //util.CloseBlock();
                 //util.Writeline("catch (" + varname + ")");
                 //util.OpenBlock();
 
                 if (StartOf(5))
                 {
                     RoutineBody();
                 }
             }
             if (la.kind == 79)
             {
                 Get();
                 //util.CloseBlock();
                 //util.Writeline("finally");
                 //util.OpenBlock();
 
                 RoutineBody();
             }
             Expect(18);
             Expect(77);
             //util.CloseBlock();
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1278" endline="1285"><![CDATA[
 
         void ReturnStmt()
         {
             string exp;
             Expect(76);
             Expression(out exp);
             //util.Writeline("return " + exp + ";");
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1286" endline="1310"><![CDATA[
 
         void LocalDeclaration()
         {
             string decl;
             //string constant = "";
 
             if (la.kind == 86)
             {
                 Get();
             }
             else if (la.kind == 57)
             {
                 Get();
                 //constant = "const ";
             }
             else SynErr(107);
             VarDeclaration(out decl);
             //util.Writeline(constant + decl + ";");
             while (la.kind == 15)
             {
                 Get();
                 VarDeclaration(out decl);
                 //util.Writeline(constant + decl + ";");
             }
             while (la.kind == 15)
             {
                 Get();
                 VarDeclaration(out decl);
                 //util.Writeline(constant + decl + ";");
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1311" endline="1343"><![CDATA[
 
         void ForVar()
         {
             string loopvar;
             string expIni;
             string expEnd;
             string stepExp;
             string stepCS;
 
             QualName(out loopvar);
             stepCS = loopvar + "++";
             Expect(38);
             Expression(out expIni);
             Expect(70);
             Expression(out expEnd);
             if (la.kind == 71)
             {
                 Get();
                 Expression(out stepExp);
                 stepCS = loopvar + " += " + stepExp;
             }
             //util.Writeline(string.Format("for ({0}={1}; {0} <= {2}; {3})", loopvar, expIni, expEnd, stepCS));
             //util.OpenBlock();
 
             RoutineBody();
             Expect(72);
             if (la.kind == 3)
             {
                 Get();
             }
             //util.CloseBlock();
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1344" endline="1365"><![CDATA[
 
         void ForEach()
         {
             string loopvar;
             string expIni;
 
             Expect(73);
             QualName(out loopvar);
             Expect(74);
             Expression(out expIni);
             //util.Writeline(string.Format("foreach ({0} in {1})", loopvar, expIni));
             //util.OpenBlock();
 
             RoutineBody();
             Expect(72);
             if (la.kind == 3)
             {
                 Get();
             }
             //util.CloseBlock();
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1366" endline="1374"><![CDATA[
 
         void CaseStmts()
         {
             CaseStmt();
             while (la.kind == 81)
             {
                 CaseStmt();
             }
             while (la.kind == 81)
             {
                 CaseStmt();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1375" endline="1407"><![CDATA[
 
         void CaseStmt()
         {
             string exp;
             Expect(81);
             if (la.kind == 82)
             {
                 Get();
                 //util.Writeline("default
                 //util.Ident();
 
             }
             else if (StartOf(4))
             {
                 Expression(out exp);
                 //util.Writeline("case " + exp + "
                 //util.Ident();
 
                 while (la.kind == 15)
                 {
                     Get();
                     Expression(out exp);
                     //util.Unident();
                     //util.Writeline("case " + exp + "
                     //util.Ident();
 
                 }
                 while (la.kind == 15)
                 {
                     Get();
                     Expression(out exp);
                     //util.Unident();
                     //util.Writeline("case " + exp + "
                     //util.Ident();
 
                 }
             }
             else SynErr(108);
             RoutineBody();
             //util.Unident();
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1408" endline="1437"><![CDATA[
 
         void ElseStmt()
         {
             string exp;
             if (la.kind == 82)
             {
                 Get();
                 //util.CloseBlock();
                 //util.Writeline("else");
                 //util.OpenBlock();
 
                 RoutineBody();
             }
             else if (la.kind == 83)
             {
                 Get();
                 Expression(out exp);
                 Expect(84);
                 //util.CloseBlock();
                 //util.Writeline("else if (" + exp + ")");
                 //util.OpenBlock();
 
                 RoutineBody();
                 if (la.kind == 82 || la.kind == 83)
                 {
                     ElseStmt();
                 }
             }
             else SynErr(109);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1438" endline="1455"><![CDATA[
 
         void LeftAssign(out string call)
         {
             string typename, pl, call2;
             QualName(out typename);
             call = typename;
             if (la.kind == 30)
             {
                 CallParams(out pl);
                 call += pl;
                 if (la.kind == 36)
                 {
                     Get();
                     LeftAssign(out call2);
                     call += "." + call2;
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1456" endline="1474"><![CDATA[
 
         void ParameterDeclaration(out string declaration)
         {
             string decl;
             if (la.kind == 87 || la.kind == 88)
             {
                 if (la.kind == 87)
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                 }
             }
             declaration = la.val;//util.ConvertByX(la.val);
             VarDeclaration(out decl);
             declaration += decl;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1475" endline="1486"><![CDATA[
 
 
 
         public void Parse()
         {
             la = new Token();
             la.val = "";
             Get();
             VBNET();
 
             Expect(0);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1487" endline="1628"><![CDATA[
 
         bool[,] set = {
 		{T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,T,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,T,T, T,T,T,T, T,T,T,T, x,T,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,T, T,T,T,T, x,x,x,x, x,x,x,x, x,x,T,T, T,T,T,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,T,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,x, T,T,T,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,T,T, T,x,T,x, T,T,x,x, x,x,x,T, T,T,x,x, T,x,x,x, x,T,T,x, x,x,x},
 		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,T, x,x,T,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x},
 		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,T,T, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x}
 
 	};
     } // end Parser
 
 
     public class Errors
     {
         public int count = 0;                                    // number of errors detected
         public System.IO.TextWriter errorStream = Console.Out;   // error messages go to this stream
         public string errMsgFormat = "-- line {0} col {1}
 
         public void SynErr(int line, int col, int n)
         {
             string s;
             switch (n)
             {
                 case 0
                 case 1
                 case 2
                 case 3
                 case 4
                 case 5
                 case 6
                 case 7
                 case 8
                 case 9
                 case 10
                 case 11
                 case 12
                 case 13
                 case 14
                 case 15
                 case 16
                 case 17
                 case 18
                 case 19
                 case 20
                 case 21
                 case 22
                 case 23
                 case 24
                 case 25
                 case 26
                 case 27
                 case 28
                 case 29
                 case 30
                 case 31
                 case 32
                 case 33
                 case 34
                 case 35
                 case 36
                 case 37
                 case 38
                 case 39
                 case 40
                 case 41
                 case 42
                 case 43
                 case 44
                 case 45
                 case 46
                 case 47
                 case 48
                 case 49
                 case 50
                 case 51
                 case 52
                 case 53
                 case 54
                 case 55
                 case 56
                 case 57
                 case 58
                 case 59
                 case 60
                 case 61
                 case 62
                 case 63
                 case 64
                 case 65
                 case 66
                 case 67
                 case 68
                 case 69
                 case 70
                 case 71
                 case 72
                 case 73
                 case 74
                 case 75
                 case 76
                 case 77
                 case 78
                 case 79
                 case 80
                 case 81
                 case 82
                 case 83
                 case 84
                 case 85
                 case 86
                 case 87
                 case 88
                 case 89
                 case 90
                 case 91
                 case 92
                 case 93
                 case 94
                 case 95
                 case 96
                 case 97
                 case 98
                 case 99
                 case 100
                 case 101
                 case 102
                 case 103
                 case 104
                 case 105
                 case 106
                 case 107
                 case 108
                 case 109
 
                 default
             }
             errorStream.WriteLine(errMsgFormat, line, col, s);
             count++;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1629" endline="1634"><![CDATA[
 
         public void SemErr(int line, int col, string s)
         {
             errorStream.WriteLine(errMsgFormat, line, col, s);
             count++;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1635" endline="1640"><![CDATA[
 
         public void SemErr(string s)
         {
             errorStream.WriteLine(s);
             count++;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1641" endline="1645"><![CDATA[
 
         public void Warning(int line, int col, string s)
         {
             errorStream.WriteLine(errMsgFormat, line, col, s);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1646" endline="1650"><![CDATA[
 
         public void Warning(string s)
         {
             errorStream.WriteLine(s);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1504" endline="1506"><![CDATA[
         public int count = 0;                                    // number of errors detected
         public System.IO.TextWriter errorStream = Console.Out;   // error messages go to this stream
         public string errMsgFormat = "-- line {0} col {1}
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Classes\cHtmlToolTip.cs" startline="1507" endline="1656"><![CDATA[
 
         public void SynErr(int line, int col, int n)
         {
             string s;
             switch (n)
             {
                 case 0
                 case 1
                 case 2
                 case 3
                 case 4
                 case 5
                 case 6
                 case 7
                 case 8
                 case 9
                 case 10
                 case 11
                 case 12
                 case 13
                 case 14
                 case 15
                 case 16
                 case 17
                 case 18
                 case 19
                 case 20
                 case 21
                 case 22
                 case 23
                 case 24
                 case 25
                 case 26
                 case 27
                 case 28
                 case 29
                 case 30
                 case 31
                 case 32
                 case 33
                 case 34
                 case 35
                 case 36
                 case 37
                 case 38
                 case 39
                 case 40
                 case 41
                 case 42
                 case 43
                 case 44
                 case 45
                 case 46
                 case 47
                 case 48
                 case 49
                 case 50
                 case 51
                 case 52
                 case 53
                 case 54
                 case 55
                 case 56
                 case 57
                 case 58
                 case 59
                 case 60
                 case 61
                 case 62
                 case 63
                 case 64
                 case 65
                 case 66
                 case 67
                 case 68
                 case 69
                 case 70
                 case 71
                 case 72
                 case 73
                 case 74
                 case 75
                 case 76
                 case 77
                 case 78
                 case 79
                 case 80
                 case 81
                 case 82
                 case 83
                 case 84
                 case 85
                 case 86
                 case 87
                 case 88
                 case 89
                 case 90
                 case 91
                 case 92
                 case 93
                 case 94
                 case 95
                 case 96
                 case 97
                 case 98
                 case 99
                 case 100
                 case 101
                 case 102
                 case 103
                 case 104
                 case 105
                 case 106
                 case 107
                 case 108
                 case 109
 
                 default
             }
             errorStream.WriteLine(errMsgFormat, line, col, s);
             count++;
         }
 
         public void SemErr(int line, int col, string s)
         {
             errorStream.WriteLine(errMsgFormat, line, col, s);
             count++;
         }
 
         public void SemErr(string s)
         {
             errorStream.WriteLine(s);
             count++;
         }
 
         public void Warning(int line, int col, string s)
         {
             errorStream.WriteLine(errMsgFormat, line, col, s);
         }
 
         public void Warning(string s)
         {
             errorStream.WriteLine(s);
         }
     } // Errors
 
 
     public class FatalError 
     {
         public FatalError(string m) 
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="161" endline="161"><![CDATA[
             get { return this.m_CodeInfo; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="162" endline="177"><![CDATA[
         }
 
         public void AddConditionalCompilationSymbols(String[] symbols)
         {
             if (symbols != null)
             {
                 for (int i = 0; i < symbols.Length; ++i)
                 {
                     symbols[i] = symbols[i].Trim();
                     if (symbols[i].Length > 0 && !ccs.Contains(symbols[i]))
                     {
                         ccs.Add(symbols[i]);
                     }
                 }
                 for (int i = 0; i < symbols.Length; ++i)
                 {
                     symbols[i] = symbols[i].Trim();
                     if (symbols[i].Length > 0 && !ccs.Contains(symbols[i]))
                     {
                         ccs.Add(symbols[i]);
                     }
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="178" endline="190"><![CDATA[
 
         // returns the end of the whitespaces in the given
         // string if whitespaces is true otherwise returns
         // the end of the non-whitespaces.
         int EndOf(String symbol, int start, bool whitespaces)
         {
             while ((start < symbol.Length) && (Char.IsWhiteSpace(symbol[start]) ^ !whitespaces))
             {
                 ++start;
             }
             while ((start < symbol.Length) && (Char.IsWhiteSpace(symbol[start]) ^ !whitespaces))
             {
                 ++start;
             }
 
             return start;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="191" endline="210"><![CDATA[
 
         // input
         // valid input
         // output
         String RemPPDirective(String symbol)
         {
             int start = 1;
             int end;
 
             // skip {ws}
             start = EndOf(symbol, start, true);
             // skip directive  
             start = EndOf(symbol, start, false);
             // skip ws {ws}
             start = EndOf(symbol, start, true);
             // search end of symbol
             end = EndOf(symbol, start, false);
 
             return symbol.Substring(start, end - start);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="211" endline="219"><![CDATA[
 
         void AddCCS(String symbol)
         {
             symbol = RemPPDirective(symbol);
             if (!ccs.Contains(symbol))
             {
                 ccs.Add(symbol);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="220" endline="224"><![CDATA[
 
         void RemCCS(String symbol)
         {
             ccs.Remove(RemPPDirective(symbol));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="225" endline="229"><![CDATA[
 
         bool IsCCS(String symbol)
         {
             return ccs.Contains(RemPPDirective(symbol));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="230" endline="261"><![CDATA[
 
         // search for the correct alternative and enter
         // drop everything before the correct alternative
         void IfPragma(String symbol)
         {
             if (!IsCCS(symbol))
             {
                 int state = 0;
                 Token cur = scanner.Scan();
 
                 for (; ; )
                 {
                     switch (cur.kind)
                     {
                         case _ppIf
                         case _ppEndif
                             if (state == 0) { return; }
                             --state;
                             break;
                         case _ppElif
                             if (state == 0 && IsCCS(cur.val)) { return; }
                             break;
                         case _ppElse
                             if (state == 0) { return; }
                             break;
                         case _EOF
                         default
                     }
                     cur = scanner.Scan();
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="262" endline="282"><![CDATA[
 
         // drop everything until the end of this if, elif, else directive
         void ElifOrElsePragma()
         {
             int state = 0;
             Token cur = scanner.Scan();
 
             for (; ; )
             {
                 switch (cur.kind)
                 {
                     case _ppIf
                     case _ppEndif
                         if (state == 0) { return; }
                         --state;
                         break;
                     default
                 }
                 cur = scanner.Scan();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="283" endline="293"><![CDATA[
 
         /*----------------------------- token sets -------------------------------*/
 
         const int maxTerminals = 160;  // set size
 
         static BitArray NewSet(params int[] values)
         {
             BitArray a = new BitArray(maxTerminals);
             foreach (int x in values) a[x] = true;
             return a;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="294" endline="340"><![CDATA[
 
         static BitArray
           unaryOp = NewSet(_plus, _minus, _not, _tilde, _inc, _dec, _true, _false),
           typeKW = NewSet(_char, _bool, _object, _string, _sbyte, _byte, _short,
                          _ushort, _int, _uint, _long, _ulong, _float, _double, _decimal),
           unaryHead = NewSet(_plus, _minus, _not, _tilde, _times, _inc, _dec, _and),
           assnStartOp = NewSet(_plus, _minus, _not, _tilde, _times),
           castFollower = NewSet(_tilde, _not, _lpar, _ident,
             /* literals */
                          _intCon, _realCon, _charCon, _stringCon,
             /* any keyword expect as and is */
                          _abstract, _base, _bool, _break, _byte, _case, _catch,
                          _char, _checked, _class, _const, _continue, _decimal, _default,
                          _delegate, _do, _double, _else, _enum, _event, _explicit,
                          _extern, _false, _finally, _fixed, _float, _for, _foreach,
                          _goto, _if, _implicit, _in, _int, _interface, _internal,
                          _lock, _long, _namespace, _new, _null, _object, _operator,
                          _out, _override, _params, _private, _protected, _public,
                          _readonly, _ref, _return, _sbyte, _sealed, _short, _sizeof,
                          _stackalloc, _static, _string, _struct, _switch, _this, _throw,
                          _true, _try, _typeof, _uint, _ulong, _unchecked, _unsafe,
                          _ushort, _usingKW, _virtual, _void, _volatile, _while
                          ),
           typArgLstFol = NewSet(_lpar, _rpar, _rbrack, _colon, _scolon, _comma, _dot,
                          _question, _eq, _neq),
           keyword = NewSet(_abstract, _as, _base, _bool, _break, _byte, _case, _catch,
                          _char, _checked, _class, _const, _continue, _decimal, _default,
                          _delegate, _do, _double, _else, _enum, _event, _explicit,
                          _extern, _false, _finally, _fixed, _float, _for, _foreach,
                          _goto, _if, _implicit, _in, _int, _interface, _internal,
                          _is, _lock, _long, _namespace, _new, _null, _object, _operator,
                          _out, _override, _params, _private, _protected, _public,
                          _readonly, _ref, _return, _sbyte, _sealed, _short, _sizeof,
                          _stackalloc, _static, _string, _struct, _switch, _this, _throw,
                          _true, _try, _typeof, _uint, _ulong, _unchecked, _unsafe,
                          _ushort, _usingKW, _virtual, _void, _volatile, _while),
           assgnOps = NewSet(_assgn, _plusassgn, _minusassgn, _timesassgn, _divassgn,
                          _modassgn, _andassgn, _orassgn, _xorassgn, _lshassgn) /* rshassgn
                          ;
 
         /*---------------------------- auxiliary methods ------------------------*/
 
         void Error(string s)
         {
             if (errDist >= minErrDist) errors.SemErr(la.line, la.col, s);
             errDist = 0;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="341" endline="349"><![CDATA[
 
         // Return the n-th token after the current lookahead token
         Token Peek(int n)
         {
             scanner.ResetPeek();
             Token x = la;
             while (n > 0) { x = scanner.Peek(); n--; }
             return x;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="350" endline="355"><![CDATA[
 
         // ident "="
         bool IsAssignment()
         {
             return la.kind == _ident && Peek(1).kind == _assgn;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="356" endline="363"><![CDATA[
 
         /* True, if the comma is not a trailing one, *
          * like the last one in
         bool NotFinalComma()
         {
             int peek = Peek(1).kind;
             return la.kind == _comma && peek != _rbrace && peek != _rbrack;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="364" endline="385"><![CDATA[
 
         /* Checks whether the next sequence of tokens is a qualident *
          * and returns the qualident string                          *
          * !!! Proceeds from current peek position !!!               */
         bool IsQualident(ref Token pt, out string qualident)
         {
             qualident = "";
             if (pt.kind == _ident)
             {
                 qualident = pt.val;
                 pt = scanner.Peek();
                 while (pt.kind == _dot)
                 {
                     pt = scanner.Peek();
                     if (pt.kind != _ident) return false;
                     qualident += "." + pt.val;
                     pt = scanner.Peek();
                 }
                 while (pt.kind == _dot)
                 {
                     pt = scanner.Peek();
                     if (pt.kind != _ident) return false;
                     qualident += "." + pt.val;
                     pt = scanner.Peek();
                 }
                 return true;
             }
             else return false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="386" endline="396"><![CDATA[
 
         bool IsGeneric()
         {
             scanner.ResetPeek();
             Token pt = la;
             if (!IsTypeArgumentList(ref pt))
             {
                 return false;
             }
             return typArgLstFol[pt.kind];
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="397" endline="432"><![CDATA[
 
         bool IsTypeArgumentList(ref Token pt)
         {
             if (pt.kind == _lt)
             {
                 pt = scanner.Peek();
                 while (true)
                 {
                     if (!IsType(ref pt))
                     {
                         return false;
                     }
                     if (pt.kind == _gt)
                     {
                         // list recognized
                         pt = scanner.Peek();
                         break;
                     }
                     else if (pt.kind == _comma)
                     {
                         // another argument
                         pt = scanner.Peek();
                     }
                     else
                     {
                         // error in type argument list
                         return false;
                     }
                 }
                 while (true)
                 {
                     if (!IsType(ref pt))
                     {
                         return false;
                     }
                     if (pt.kind == _gt)
                     {
                         // list recognized
                         pt = scanner.Peek();
                         break;
                     }
                     else if (pt.kind == _comma)
                     {
                         // another argument
                         pt = scanner.Peek();
                     }
                     else
                     {
                         // error in type argument list
                         return false;
                     }
                 }
             }
             else
             {
                 return false;
             }
             return true;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="433" endline="479"><![CDATA[
 
         // Type
         bool IsType(ref Token pt)
         {
             String dummyId;
 
             if (typeKW[pt.kind])
             {
                 pt = scanner.Peek();
             }
             else if (pt.kind == _void)
             {
                 pt = scanner.Peek();
                 if (pt.kind != _times)
                 {
                     return false;
                 }
                 pt = scanner.Peek();
             }
             else if (pt.kind == _ident)
             {
                 pt = scanner.Peek();
                 if (pt.kind == _dblcolon || pt.kind == _dot)
                 {
                     // either namespace alias qualifier "
                     // part of the qualident
                     pt = scanner.Peek();
                     if (!IsQualident(ref pt, out dummyId))
                     {
                         return false;
                     }
                 }
                 if (pt.kind == _lt && !IsTypeArgumentList(ref pt))
                 {
                     return false;
                 }
             }
             else
             {
                 return false;
             }
             if (pt.kind == _question)
             {
                 pt = scanner.Peek();
             }
             return SkipPointerOrDims(ref pt);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="480" endline="488"><![CDATA[
 
         // Type ident
         // (Type can be void*)
         bool IsLocalVarDecl()
         {
             Token pt = la;
             scanner.ResetPeek();
             return IsType(ref pt) && pt.kind == _ident;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="489" endline="495"><![CDATA[
 
         // "[" ("," | "]")
         bool IsDims()
         {
             int peek = Peek(1).kind;
             return la.kind == _lbrack && (peek == _comma || peek == _rbrack);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="496" endline="501"><![CDATA[
 
         // "*" | "[" ("," | "]")
         bool IsPointerOrDims()
         {
             return la.kind == _times || IsDims();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="502" endline="519"><![CDATA[
 
         /* skip
         /* !!! Proceeds from current peek position !!! */
         bool SkipPointerOrDims(ref Token pt)
         {
             for (; ; )
             {
                 if (pt.kind == _lbrack)
                 {
                     do pt = scanner.Peek();
                     while (pt.kind == _comma);
                     if (pt.kind != _rbrack) return false;
                 }
                 else if (pt.kind != _times) break;
                 pt = scanner.Peek();
             }
             return true;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="520" endline="526"><![CDATA[
 
         // Is attribute target specifier
         // (ident | keyword) "
         bool IsAttrTargSpec()
         {
             return (la.kind == _ident || keyword[la.kind]) && Peek(1).kind == _colon;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="527" endline="534"><![CDATA[
 
         // ident ("," | "=" | ";")
         bool IsFieldDecl()
         {
             int peek = Peek(1).kind;
             return la.kind == _ident &&
                    (peek == _comma || peek == _assgn || peek == _scolon);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="535" endline="541"><![CDATA[
 
         bool IsTypeCast()
         {
             if (la.kind != _lpar) { return false; }
             if (IsSimpleTypeCast()) { return true; }
             return GuessTypeCast();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="542" endline="553"><![CDATA[
 
         // "(" typeKW ")"
         bool IsSimpleTypeCast()
         {
             // assert
             scanner.ResetPeek();
             Token pt1 = scanner.Peek();
             Token pt2 = scanner.Peek();
             return typeKW[pt1.kind] &&
                     (pt2.kind == _rpar ||
                     (pt2.kind == _question && scanner.Peek().kind == _rpar));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="554" endline="571"><![CDATA[
 
         // "(" Type ")" castFollower
         bool GuessTypeCast()
         {
             // assert
             scanner.ResetPeek();
             Token pt = scanner.Peek();
             if (!IsType(ref pt))
             {
                 return false;
             }
             if (pt.kind != _rpar)
             {
                 return false;
             }
             pt = scanner.Peek();
             return castFollower[pt.kind];
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="572" endline="578"><![CDATA[
 
         // "[" "assembly"
         bool IsGlobalAttrTarget()
         {
             Token pt = Peek(1);
             return la.kind == _lbrack && pt.kind == _ident && ("assembly".Equals(pt.val) || "module".Equals(pt.val));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="579" endline="585"><![CDATA[
 
         // "extern" "alias"
         // where alias is an identifier, no keyword
         bool IsExternAliasDirective()
         {
             return la.kind == _extern && "alias".Equals(Peek(1).val);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="586" endline="593"><![CDATA[
 
         // true
         // no whitespace between the token and the "<" allowed
         // anything else will return false.
         bool IsLtNoWs()
         {
             return (la.kind == _lt) && ((t.pos + t.val.Length) == la.pos);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="594" endline="599"><![CDATA[
 
         bool IsNoSwitchLabelOrRBrace()
         {
             return (la.kind != _case && la.kind != _default && la.kind != _rbrace) ||
                    (la.kind == _default && Peek(1).kind != _colon);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="600" endline="609"><![CDATA[
 
         bool IsShift()
         {
             Token pt = Peek(1);
             return (la.kind == _ltlt) ||
                    (la.kind == _gt &&
                      pt.kind == _gt &&
                      (la.pos + la.val.Length == pt.pos)
                    );
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="610" endline="621"><![CDATA[
 
         // true
         bool IsPartOfMemberName()
         {
             scanner.ResetPeek();
             Token pt = la;
             if (!IsTypeArgumentList(ref pt))
             {
                 return false;
             }
             return pt.kind != _lpar;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="146" endline="739"><![CDATA[
         private string m_Current = "";
 
         public Scanner scanner;
         public Errors errors;
 
         public Token t;    // last recognized token
         public Token la;   // lookahead token
         int errDist = minErrDist;
 
         ArrayList ccs = new ArrayList();
         public ArrayList exts = new ArrayList();
         private CSCodeInfo m_CodeInfo = new CSCodeInfo();
 
         public CSCodeInfo CodeInfo
         {
             get { return this.m_CodeInfo; }
         }
 
         public void AddConditionalCompilationSymbols(String[] symbols)
         {
             if (symbols != null)
             {
                 for (int i = 0; i < symbols.Length; ++i)
                 {
                     symbols[i] = symbols[i].Trim();
                     if (symbols[i].Length > 0 && !ccs.Contains(symbols[i]))
                     {
                         ccs.Add(symbols[i]);
                     }
                 }
             }
         }
 
         // returns the end of the whitespaces in the given
         // string if whitespaces is true otherwise returns
         // the end of the non-whitespaces.
         int EndOf(String symbol, int start, bool whitespaces)
         {
             while ((start < symbol.Length) && (Char.IsWhiteSpace(symbol[start]) ^ !whitespaces))
             {
                 ++start;
             }
 
             return start;
         }
 
         // input
         // valid input
         // output
         String RemPPDirective(String symbol)
         {
             int start = 1;
             int end;
 
             // skip {ws}
             start = EndOf(symbol, start, true);
             // skip directive  
             start = EndOf(symbol, start, false);
             // skip ws {ws}
             start = EndOf(symbol, start, true);
             // search end of symbol
             end = EndOf(symbol, start, false);
 
             return symbol.Substring(start, end - start);
         }
 
         void AddCCS(String symbol)
         {
             symbol = RemPPDirective(symbol);
             if (!ccs.Contains(symbol))
             {
                 ccs.Add(symbol);
             }
         }
 
         void RemCCS(String symbol)
         {
             ccs.Remove(RemPPDirective(symbol));
         }
 
         bool IsCCS(String symbol)
         {
             return ccs.Contains(RemPPDirective(symbol));
         }
 
         // search for the correct alternative and enter
         // drop everything before the correct alternative
         void IfPragma(String symbol)
         {
             if (!IsCCS(symbol))
             {
                 int state = 0;
                 Token cur = scanner.Scan();
 
                 for (; ; )
                 {
                     switch (cur.kind)
                     {
                         case _ppIf
                         case _ppEndif
                             if (state == 0) { return; }
                             --state;
                             break;
                         case _ppElif
                             if (state == 0 && IsCCS(cur.val)) { return; }
                             break;
                         case _ppElse
                             if (state == 0) { return; }
                             break;
                         case _EOF
                         default
                     }
                     cur = scanner.Scan();
                 }
             }
         }
 
         // drop everything until the end of this if, elif, else directive
         void ElifOrElsePragma()
         {
             int state = 0;
             Token cur = scanner.Scan();
 
             for (; ; )
             {
                 switch (cur.kind)
                 {
                     case _ppIf
                     case _ppEndif
                         if (state == 0) { return; }
                         --state;
                         break;
                     default
                 }
                 cur = scanner.Scan();
             }
         }
 
         /*----------------------------- token sets -------------------------------*/
 
         const int maxTerminals = 160;  // set size
 
         static BitArray NewSet(params int[] values)
         {
             BitArray a = new BitArray(maxTerminals);
             foreach (int x in values) a[x] = true;
             return a;
         }
 
         static BitArray
           unaryOp = NewSet(_plus, _minus, _not, _tilde, _inc, _dec, _true, _false),
           typeKW = NewSet(_char, _bool, _object, _string, _sbyte, _byte, _short,
                          _ushort, _int, _uint, _long, _ulong, _float, _double, _decimal),
           unaryHead = NewSet(_plus, _minus, _not, _tilde, _times, _inc, _dec, _and),
           assnStartOp = NewSet(_plus, _minus, _not, _tilde, _times),
           castFollower = NewSet(_tilde, _not, _lpar, _ident,
             /* literals */
                          _intCon, _realCon, _charCon, _stringCon,
             /* any keyword expect as and is */
                          _abstract, _base, _bool, _break, _byte, _case, _catch,
                          _char, _checked, _class, _const, _continue, _decimal, _default,
                          _delegate, _do, _double, _else, _enum, _event, _explicit,
                          _extern, _false, _finally, _fixed, _float, _for, _foreach,
                          _goto, _if, _implicit, _in, _int, _interface, _internal,
                          _lock, _long, _namespace, _new, _null, _object, _operator,
                          _out, _override, _params, _private, _protected, _public,
                          _readonly, _ref, _return, _sbyte, _sealed, _short, _sizeof,
                          _stackalloc, _static, _string, _struct, _switch, _this, _throw,
                          _true, _try, _typeof, _uint, _ulong, _unchecked, _unsafe,
                          _ushort, _usingKW, _virtual, _void, _volatile, _while
                          ),
           typArgLstFol = NewSet(_lpar, _rpar, _rbrack, _colon, _scolon, _comma, _dot,
                          _question, _eq, _neq),
           keyword = NewSet(_abstract, _as, _base, _bool, _break, _byte, _case, _catch,
                          _char, _checked, _class, _const, _continue, _decimal, _default,
                          _delegate, _do, _double, _else, _enum, _event, _explicit,
                          _extern, _false, _finally, _fixed, _float, _for, _foreach,
                          _goto, _if, _implicit, _in, _int, _interface, _internal,
                          _is, _lock, _long, _namespace, _new, _null, _object, _operator,
                          _out, _override, _params, _private, _protected, _public,
                          _readonly, _ref, _return, _sbyte, _sealed, _short, _sizeof,
                          _stackalloc, _static, _string, _struct, _switch, _this, _throw,
                          _true, _try, _typeof, _uint, _ulong, _unchecked, _unsafe,
                          _ushort, _usingKW, _virtual, _void, _volatile, _while),
           assgnOps = NewSet(_assgn, _plusassgn, _minusassgn, _timesassgn, _divassgn,
                          _modassgn, _andassgn, _orassgn, _xorassgn, _lshassgn) /* rshassgn
                          ;
 
         /*---------------------------- auxiliary methods ------------------------*/
 
         void Error(string s)
         {
             if (errDist >= minErrDist) errors.SemErr(la.line, la.col, s);
             errDist = 0;
         }
 
         // Return the n-th token after the current lookahead token
         Token Peek(int n)
         {
             scanner.ResetPeek();
             Token x = la;
             while (n > 0) { x = scanner.Peek(); n--; }
             return x;
         }
 
         // ident "="
         bool IsAssignment()
         {
             return la.kind == _ident && Peek(1).kind == _assgn;
         }
 
         /* True, if the comma is not a trailing one, *
          * like the last one in
         bool NotFinalComma()
         {
             int peek = Peek(1).kind;
             return la.kind == _comma && peek != _rbrace && peek != _rbrack;
         }
 
         /* Checks whether the next sequence of tokens is a qualident *
          * and returns the qualident string                          *
          * !!! Proceeds from current peek position !!!               */
         bool IsQualident(ref Token pt, out string qualident)
         {
             qualident = "";
             if (pt.kind == _ident)
             {
                 qualident = pt.val;
                 pt = scanner.Peek();
                 while (pt.kind == _dot)
                 {
                     pt = scanner.Peek();
                     if (pt.kind != _ident) return false;
                     qualident += "." + pt.val;
                     pt = scanner.Peek();
                 }
                 return true;
             }
             else return false;
         }
 
         bool IsGeneric()
         {
             scanner.ResetPeek();
             Token pt = la;
             if (!IsTypeArgumentList(ref pt))
             {
                 return false;
             }
             return typArgLstFol[pt.kind];
         }
 
         bool IsTypeArgumentList(ref Token pt)
         {
             if (pt.kind == _lt)
             {
                 pt = scanner.Peek();
                 while (true)
                 {
                     if (!IsType(ref pt))
                     {
                         return false;
                     }
                     if (pt.kind == _gt)
                     {
                         // list recognized
                         pt = scanner.Peek();
                         break;
                     }
                     else if (pt.kind == _comma)
                     {
                         // another argument
                         pt = scanner.Peek();
                     }
                     else
                     {
                         // error in type argument list
                         return false;
                     }
                 }
             }
             else
             {
                 return false;
             }
             return true;
         }
 
         // Type
         bool IsType(ref Token pt)
         {
             String dummyId;
 
             if (typeKW[pt.kind])
             {
                 pt = scanner.Peek();
             }
             else if (pt.kind == _void)
             {
                 pt = scanner.Peek();
                 if (pt.kind != _times)
                 {
                     return false;
                 }
                 pt = scanner.Peek();
             }
             else if (pt.kind == _ident)
             {
                 pt = scanner.Peek();
                 if (pt.kind == _dblcolon || pt.kind == _dot)
                 {
                     // either namespace alias qualifier "
                     // part of the qualident
                     pt = scanner.Peek();
                     if (!IsQualident(ref pt, out dummyId))
                     {
                         return false;
                     }
                 }
                 if (pt.kind == _lt && !IsTypeArgumentList(ref pt))
                 {
                     return false;
                 }
             }
             else
             {
                 return false;
             }
             if (pt.kind == _question)
             {
                 pt = scanner.Peek();
             }
             return SkipPointerOrDims(ref pt);
         }
 
         // Type ident
         // (Type can be void*)
         bool IsLocalVarDecl()
         {
             Token pt = la;
             scanner.ResetPeek();
             return IsType(ref pt) && pt.kind == _ident;
         }
 
         // "[" ("," | "]")
         bool IsDims()
         {
             int peek = Peek(1).kind;
             return la.kind == _lbrack && (peek == _comma || peek == _rbrack);
         }
 
         // "*" | "[" ("," | "]")
         bool IsPointerOrDims()
         {
             return la.kind == _times || IsDims();
         }
 
         /* skip
         /* !!! Proceeds from current peek position !!! */
         bool SkipPointerOrDims(ref Token pt)
         {
             for (; ; )
             {
                 if (pt.kind == _lbrack)
                 {
                     do pt = scanner.Peek();
                     while (pt.kind == _comma);
                     if (pt.kind != _rbrack) return false;
                 }
                 else if (pt.kind != _times) break;
                 pt = scanner.Peek();
             }
             return true;
         }
 
         // Is attribute target specifier
         // (ident | keyword) "
         bool IsAttrTargSpec()
         {
             return (la.kind == _ident || keyword[la.kind]) && Peek(1).kind == _colon;
         }
 
         // ident ("," | "=" | ";")
         bool IsFieldDecl()
         {
             int peek = Peek(1).kind;
             return la.kind == _ident &&
                    (peek == _comma || peek == _assgn || peek == _scolon);
         }
 
         bool IsTypeCast()
         {
             if (la.kind != _lpar) { return false; }
             if (IsSimpleTypeCast()) { return true; }
             return GuessTypeCast();
         }
 
         // "(" typeKW ")"
         bool IsSimpleTypeCast()
         {
             // assert
             scanner.ResetPeek();
             Token pt1 = scanner.Peek();
             Token pt2 = scanner.Peek();
             return typeKW[pt1.kind] &&
                     (pt2.kind == _rpar ||
                     (pt2.kind == _question && scanner.Peek().kind == _rpar));
         }
 
         // "(" Type ")" castFollower
         bool GuessTypeCast()
         {
             // assert
             scanner.ResetPeek();
             Token pt = scanner.Peek();
             if (!IsType(ref pt))
             {
                 return false;
             }
             if (pt.kind != _rpar)
             {
                 return false;
             }
             pt = scanner.Peek();
             return castFollower[pt.kind];
         }
 
         // "[" "assembly"
         bool IsGlobalAttrTarget()
         {
             Token pt = Peek(1);
             return la.kind == _lbrack && pt.kind == _ident && ("assembly".Equals(pt.val) || "module".Equals(pt.val));
         }
 
         // "extern" "alias"
         // where alias is an identifier, no keyword
         bool IsExternAliasDirective()
         {
             return la.kind == _extern && "alias".Equals(Peek(1).val);
         }
 
         // true
         // no whitespace between the token and the "<" allowed
         // anything else will return false.
         bool IsLtNoWs()
         {
             return (la.kind == _lt) && ((t.pos + t.val.Length) == la.pos);
         }
 
         bool IsNoSwitchLabelOrRBrace()
         {
             return (la.kind != _case && la.kind != _default && la.kind != _rbrace) ||
                    (la.kind == _default && Peek(1).kind != _colon);
         }
 
         bool IsShift()
         {
             Token pt = Peek(1);
             return (la.kind == _ltlt) ||
                    (la.kind == _gt &&
                      pt.kind == _gt &&
                      (la.pos + la.val.Length == pt.pos)
                    );
         }
 
         // true
         bool IsPartOfMemberName()
         {
             scanner.ResetPeek();
             Token pt = la;
             if (!IsTypeArgumentList(ref pt))
             {
                 return false;
             }
             return pt.kind != _lpar;
         }
 
 
         enum TypeKind { simple, array, pointer, @void }
 
         [Flags]
         enum Operator
         {
             plus = 0x00000001, minus = 0x00000002, not = 0x00000004, tilde = 0x00000008,
             inc = 0x00000010, dec = 0x00000020, @true = 0x00000040, @false = 0x00000080,
             times = 0x00000100, div = 0x00000200, mod = 0x00000400, and = 0x00000800,
             or = 0x00001000, xor = 0x00002000, lshift = 0x00004000, rshift = 0x00008000,
             eq = 0x00010000, neq = 0x00020000, gt = 0x00040000, lt = 0x00080000,
             gte = 0x00100000, lte = 0x00200000,
             unary = plus | minus | not | tilde | inc | dec | @true | @false,
             binary = plus | minus | times | div | mod | and | or | xor | lshift | rshift | eq | neq | gt | lt | gte | lte
         }
 
         /*------------------------- modifier handling -----------------------------*/
 
         [Flags]
         enum Modifier
         {
             @new = 0x0001, @public = 0x0002, @protected = 0x0004, @internal = 0x0008,
             @private = 0x0010, @unsafe = 0x0020, @static = 0x0040, @readonly = 0x0080,
             @volatile = 0x0100, @virtual = 0x0200, @sealed = 0x0400, @override = 0x0800,
             @abstract = 0x1000, @extern = 0x2000,
 
             /* sets of modifiers that can be attached to certain program elements    *
              * e.g., "constants" marks all modifiers that may be used with constants */
             none = 0x0000,
             classes = @new | @public | @protected | @internal | @private | @unsafe | @abstract | @sealed | @static,
             constants = @new | @public | @protected | @internal | @private,
             fields = @new | @public | @protected | @internal | @private | @unsafe | @static | @readonly | @volatile,
             propEvntMeths = @new | @public | @protected | @internal | @private | @unsafe | @static | @virtual | @sealed | @override | @abstract | @extern,
             accessorsPossib1 = @private,
             accessorsPossib2 = @protected | @internal,
             indexers = @new | @public | @protected | @internal | @private | @unsafe | @virtual | @sealed | @override | @abstract | @extern,
             operators = @public | @unsafe | @static | @extern,
             operatorsMust = @public | @static,
             constructors = @public | @protected | @internal | @private | @unsafe | @extern,
             staticConstr = @extern | @static,
             staticConstrMust = @static,
             nonClassTypes = @new | @public | @protected | @internal | @private | @unsafe,
             destructors = @extern | @unsafe,
             all = 0x3fff
         }
 
         class Modifiers
         {
             private Modifier cur = Modifier.none;
             private Parser parser;
 
             public Modifiers(Parser parser)
             {
                 this.parser = parser;
             }
 
             public void Add(Modifier m)
             {
                 if ((cur & m) == 0) cur |= m;
                 else parser.Error("modifier " + m + " already defined");
             }
 
             public void Add(Modifiers m) { Add(m.cur); }
 
             public bool IsNone { get { return cur == Modifier.none; } }
 
             public void Check(Modifier allowed)
             {
                 Modifier wrong = cur & (allowed ^ Modifier.all);
                 if (wrong != Modifier.none)
                     parser.Error("modifier(s) " + wrong + " not allowed here");
             }
 
             public void Check(Modifier allowEither, Modifier allowOr)
             {
                 Modifier wrong = cur & ((allowEither | allowOr) ^ Modifier.all);
                 if ((allowEither & allowOr) != Modifier.none)
                 {
                     parser.Error("modifiers providerd must not overlap");
                 }
                 else if (wrong != Modifier.none)
                 {
                     parser.Error("modifier(s) " + wrong + " not allowed here");
                 }
                 else if (((cur & allowEither) != Modifier.none) && ((cur & allowOr) != Modifier.none))
                 {
                     parser.Error("modifier(s) may either be " + allowEither + " or " + allowOr);
                 }
             }
 
             public void CheckMust(Modifier mustHave)
             {
                 Modifier missing = (cur & mustHave) ^ mustHave;
                 if (missing != Modifier.none)
                 {
                     parser.Error("modifier(s) " + missing + " must be applied here");
                 }
             }
 
             public bool Has(Modifier mod)
             {
                 return (cur & mod) == mod;
             }
         }
 
 
         /*------------------------------------------------------------------------*
          *----- SCANNER DESCRIPTION ----------------------------------------------*
          *------------------------------------------------------------------------*/
 
 
 
         public Parser(Scanner scanner)
         {
             this.scanner = scanner;
             errors = new Errors();
         }
 
         void SynErr(int n)
         {
             if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n);
             errDist = 0;
         }
 
         public void SemErr(string msg)
         {
             if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg);
             errDist = 0;
         }
 
         void Get()
         {
             for (; ; )
             {
                 t = la;
                 la = scanner.Scan();
                 if (la.kind <= maxT) { ++errDist; break; }
                 if (la.kind == 131)
                 {
                     AddCCS(la.val);
                 }
                 if (la.kind == 132)
                 {
                     RemCCS(la.val);
                 }
                 if (la.kind == 133)
                 {
                     IfPragma(la.val);
                 }
                 if (la.kind == 134)
                 {
                     ElifOrElsePragma();
                 }
                 if (la.kind == 135)
                 {
                     ElifOrElsePragma();
                 }
                 if (la.kind == 136)
                 {
                 }
                 if (la.kind == 137)
                 {
                 }
                 if (la.kind == 138)
                 {
                 }
                 if (la.kind == 139)
                 {
                 }
                 if (la.kind == 140)
                 {
                 }
                 if (la.kind == 141)
                 {
                 }
 
                 la = t;
             }
         }
 
         void Expect(int n)
         {
             if (la.kind == n) Get(); else { SynErr(n); }
         }
 
         bool StartOf(int s)
         {
             return set[s, la.kind];
         }
 
         void ExpectWeak(int n, int follow)
         {
             if (la.kind == n) Get();
             else
             {
                 SynErr(n);
                 while (!StartOf(follow)) Get();
             }
         }
 
 
         bool WeakSeparator(int n, int syFol, int repFol)
         {
             int kind = la.kind;
             if (kind == n) { Get(); return true; }
             else if (StartOf(repFol)) { return false; }
             else
             {
                 SynErr(n);
                 while (!(set[syFol, kind] || set[repFol, kind] || set[0, kind]))
                 {
                     Get();
                     kind = la.kind;
                 }
                 return StartOf(syFol);
             }
         }
 
 
         void CS2()
         {
             while (IsExternAliasDirective())
             {
                 ExternAliasDirective();
             }
             while (la.kind == 78)
             {
                 UsingDirective();
             }
             while (IsGlobalAttrTarget())
             {
                 GlobalAttributes();
             }
             while (StartOf(1))
             {
                 NamespaceMemberDeclaration();
             }
         }
 
         void ExternAliasDirective()
         {
             Expect(28);
             Expect(1);
             if (t.val != "alias")
             {
                 Error("alias expected");
             }
             else
             {
                 exts.Add(t.val);
             }
 
             Expect(1);
             Expect(114);
         }
 
         void UsingDirective()
         {
             Expect(78);
             if (IsAssignment())
             {
                 Expect(1);
                 Expect(85);
             }
             TokenMatch tm = new TokenMatch();
             tm.Position = la.pos;
             this.m_Current = la.val;
             TypeName();
             tm.Value = this.m_Current;
             this.m_CodeInfo.Usings.Add(tm);
             Expect(114);
         }
 
         void GlobalAttributes()
         {
             Expect(97);
             Expect(1);
             if (!"assembly".Equals(t.val) && !"module".Equals(t.val)) Error("global attribute target specifier \"assembly\" or \"module\" expected");
 
             Expect(86);
             Attribute();
             while (NotFinalComma())
             {
                 Expect(87);
                 Attribute();
             }
             if (la.kind == 87)
             {
                 Get();
             }
             Expect(112);
         }
 
         void NamespaceMemberDeclaration()
         {
             Modifiers m = new Modifiers(this);
             if (la.kind == 45)
             {
                 Get();
                 this.m_Current = la.val;
                 Expect(1);
                 while (la.kind == 90)
                 {
                     Get();
                     this.m_Current += "." + la.val;
                     Expect(1);
                 }
                 Expect(96);
                 while (IsExternAliasDirective())
                 {
                     ExternAliasDirective();
                 }
                 while (la.kind == 78)
                 {
                     UsingDirective();
                 }
                 while (StartOf(1))
                 {
                     NamespaceMemberDeclaration();
                 }
                 Expect(111);
                 if (la.kind == 114)
                 {
                     Get();
                 }
                 this.m_CodeInfo.NameSpaces.Add(this.m_Current);
             }
             else if (StartOf(2))
             {
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 ModifierList(m);
                 TypeDeclaration(m);
             }
             else SynErr(131);
         }
 
         void TypeName()
         {
             Expect(1);
             if (la.kind == 91)
             {
                 Get();
                 Expect(1);
             }
             if (la.kind == 100)
             {
                 TypeArgumentList();
             }
             while (la.kind == 90)
             {
                 Get();
                 this.m_Current += "." + la.val;
                 Expect(1);
                 if (la.kind == 100)
                 {
                     TypeArgumentList();
                 }
             }
         }
 
         void Attributes()
         {
             Expect(97);
             if (IsAttrTargSpec())
             {
                 if (la.kind == 1)
                 {
                     Get();
                 }
                 else if (StartOf(3))
                 {
                     Keyword();
                 }
                 else SynErr(132);
                 Expect(86);
             }
             Attribute();
             while (la.kind == _comma && Peek(1).kind != _rbrack)
             {
                 Expect(87);
                 Attribute();
             }
             if (la.kind == 87)
             {
                 Get();
             }
             Expect(112);
         }
 
         void ModifierList(Modifiers m)
         {
             while (StartOf(4))
             {
                 switch (la.kind)
                 {
                     case 46
                         {
                             Get();
                             m.Add(Modifier.@new);
                             break;
                         }
                     case 55
                         {
                             Get();
                             m.Add(Modifier.@public);
                             break;
                         }
                     case 54
                         {
                             Get();
                             m.Add(Modifier.@protected);
                             break;
                         }
                     case 41
                         {
                             Get();
                             m.Add(Modifier.@internal);
                             break;
                         }
                     case 53
                         {
                             Get();
                             m.Add(Modifier.@private);
                             break;
                         }
                     case 76
                         {
                             Get();
                             m.Add(Modifier.@unsafe);
                             break;
                         }
                     case 64
                         {
                             Get();
                             m.Add(Modifier.@static);
                             break;
                         }
                     case 56
                         {
                             Get();
                             m.Add(Modifier.@readonly);
                             break;
                         }
                     case 81
                         {
                             Get();
                             m.Add(Modifier.@volatile);
                             break;
                         }
                     case 79
                         {
                             Get();
                             m.Add(Modifier.@virtual);
                             break;
                         }
                     case 60
                         {
                             Get();
                             m.Add(Modifier.@sealed);
                             break;
                         }
                     case 51
                         {
                             Get();
                             m.Add(Modifier.@override);
                             break;
                         }
                     case 6
                         {
                             Get();
                             m.Add(Modifier.@abstract);
                             break;
                         }
                     case 28
                         {
                             Get();
                             m.Add(Modifier.@extern);
                             break;
                         }
                 }
             }
         }
 
         void TypeDeclaration(Modifiers m)
         {
             TypeKind dummy;
             if (StartOf(5))
             {
                 if (la.kind == 119)
                 {
                     Get();
                 }
                 if (la.kind == 16)
                 {
                     m.Check(Modifier.classes);
                     Get();
                     Expect(1);
                     if (la.kind == 100)
                     {
                         TypeParameterList();
                     }
                     if (la.kind == 86)
                     {
                         ClassBase();
                     }
                     while (la.kind == 1)
                     {
                         TypeParameterConstraintsClause();
                     }
                     ClassBody();
                     if (la.kind == 114)
                     {
                         Get();
                     }
                 }
                 else if (la.kind == 66)
                 {
                     m.Check(Modifier.nonClassTypes);
                     Get();
                     Expect(1);
                     if (la.kind == 100)
                     {
                         TypeParameterList();
                     }
                     if (la.kind == 86)
                     {
                         Get();
                         TypeName();
                         while (la.kind == 87)
                         {
                             Get();
                             TypeName();
                         }
                     }
                     while (la.kind == 1)
                     {
                         TypeParameterConstraintsClause();
                     }
                     StructBody();
                     if (la.kind == 114)
                     {
                         Get();
                     }
                 }
                 else if (la.kind == 40)
                 {
                     m.Check(Modifier.nonClassTypes);
                     Get();
                     Expect(1);
                     if (la.kind == 100)
                     {
                         TypeParameterList();
                     }
                     if (la.kind == 86)
                     {
                         Get();
                         TypeName();
                         while (la.kind == 87)
                         {
                             Get();
                             TypeName();
                         }
                     }
                     while (la.kind == 1)
                     {
                         TypeParameterConstraintsClause();
                     }
                     Expect(96);
                     while (StartOf(6))
                     {
                         InterfaceMemberDeclaration();
                     }
                     Expect(111);
                     if (la.kind == 114)
                     {
                         Get();
                     }
                 }
                 else SynErr(133);
             }
             else if (la.kind == 25)
             {
                 m.Check(Modifier.nonClassTypes);
                 Get();
                 Expect(1);
                 if (la.kind == 86)
                 {
                     Get();
                     IntegralType();
                 }
                 EnumBody();
                 if (la.kind == 114)
                 {
                     Get();
                 }
             }
             else if (la.kind == 21)
             {
                 m.Check(Modifier.nonClassTypes);
                 Get();
                 Type(out dummy, true);
                 Expect(1);
                 if (la.kind == 100)
                 {
                     TypeParameterList();
                 }
                 Expect(98);
                 if (StartOf(7))
                 {
                     FormalParameterList();
                 }
                 Expect(113);
                 while (la.kind == 1)
                 {
                     TypeParameterConstraintsClause();
                 }
                 Expect(114);
             }
             else SynErr(134);
         }
 
         void TypeParameterList()
         {
             Expect(100);
             while (la.kind == 97)
             {
                 Attributes();
             }
             Expect(1);
             while (la.kind == 87)
             {
                 Get();
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 Expect(1);
             }
             Expect(93);
         }
 
         void ClassBase()
         {
             Expect(86);
             ClassType();
             while (la.kind == 87)
             {
                 Get();
                 TypeName();
             }
         }
 
         void TypeParameterConstraintsClause()
         {
             Expect(1);
             if (t.val != "where")
             {
                 Error("type parameter constraints clause must start with
             }
 
             Expect(1);
             Expect(86);
             if (StartOf(8))
             {
                 if (la.kind == 16)
                 {
                     Get();
                 }
                 else if (la.kind == 66)
                 {
                     Get();
                 }
                 else if (la.kind == 48)
                 {
                     Get();
                 }
                 else if (la.kind == 65)
                 {
                     Get();
                 }
                 else
                 {
                     TypeName();
                 }
                 while (la.kind == _comma && Peek(1).kind != _new)
                 {
                     Expect(87);
                     TypeName();
                 }
                 if (la.kind == 87)
                 {
                     Get();
                     Expect(46);
                     Expect(98);
                     Expect(113);
                 }
             }
             else if (la.kind == 46)
             {
                 Get();
                 Expect(98);
                 Expect(113);
             }
             else SynErr(135);
         }
 
         void ClassBody()
         {
             Expect(96);
             while (StartOf(9))
             {
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 Modifiers m = new Modifiers(this);
                 ModifierList(m);
                 ClassMemberDeclaration(m);
             }
             Expect(111);
         }
 
         void StructBody()
         {
             Expect(96);
             while (StartOf(10))
             {
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 Modifiers m = new Modifiers(this);
                 ModifierList(m);
                 StructMemberDeclaration(m);
             }
             Expect(111);
         }
 
         void InterfaceMemberDeclaration()
         {
             Modifiers m = new Modifiers(this);
             TypeKind dummy;
 
             while (la.kind == 97)
             {
                 Attributes();
             }
             if (la.kind == 46)
             {
                 Get();
             }
             if (StartOf(11))
             {
                 Type(out dummy, true);
                 if (la.kind == 1)
                 {
                     Get();
                     if (la.kind == 98 || la.kind == 100)
                     {
                         if (la.kind == 100)
                         {
                             TypeParameterList();
                         }
                         Expect(98);
                         if (StartOf(7))
                         {
                             FormalParameterList();
                         }
                         Expect(113);
                         while (la.kind == 1)
                         {
                             TypeParameterConstraintsClause();
                         }
                         Expect(114);
                     }
                     else if (la.kind == 96)
                     {
                         Get();
                         InterfaceAccessors(m);
                         Expect(111);
                     }
                     else SynErr(136);
                 }
                 else if (la.kind == 68)
                 {
                     Get();
                     Expect(97);
                     FormalParameterList();
                     Expect(112);
                     Expect(96);
                     InterfaceAccessors(m);
                     Expect(111);
                 }
                 else SynErr(137);
             }
             else if (la.kind == 26)
             {
                 Get();
                 Type(out dummy, false);
                 Expect(1);
                 Expect(114);
             }
             else SynErr(138);
         }
 
         void IntegralType()
         {
             switch (la.kind)
             {
                 case 59
                     {
                         Get();
                         break;
                     }
                 case 11
                     {
                         Get();
                         break;
                     }
                 case 61
                     {
                         Get();
                         break;
                     }
                 case 77
                     {
                         Get();
                         break;
                     }
                 case 39
                     {
                         Get();
                         break;
                     }
                 case 73
                     {
                         Get();
                         break;
                     }
                 case 44
                     {
                         Get();
                         break;
                     }
                 case 74
                     {
                         Get();
                         break;
                     }
                 case 14
                     {
                         Get();
                         break;
                     }
                 default
             }
         }
 
         void EnumBody()
         {
             Expect(96);
             if (la.kind == 1 || la.kind == 97)
             {
                 EnumMemberDeclaration();
                 while (NotFinalComma())
                 {
                     Expect(87);
                     EnumMemberDeclaration();
                 }
                 if (la.kind == 87)
                 {
                     Get();
                 }
             }
             Expect(111);
         }
 
         void Type(out TypeKind type, bool voidAllowed)
         {
             type = TypeKind.simple;
             if (StartOf(12))
             {
                 PrimitiveType();
             }
             else if (la.kind == 1 || la.kind == 48 || la.kind == 65)
             {
                 ClassType();
             }
             else if (la.kind == 80)
             {
                 Get();
                 type = TypeKind.@void;
             }
             else SynErr(140);
             if (la.kind == 110)
             {
                 Get();
                 if (type == TypeKind.@void) { Error("Unexpected token ?, void must not be nullable."); }
             }
             PointerOrArray(ref type);
             if (type == TypeKind.@void && !voidAllowed) { Error("type expected, void found, maybe you mean void*"); }
         }
 
         void FormalParameterList()
         {
             TypeKind type;
             while (la.kind == 97)
             {
                 Attributes();
             }
             if (StartOf(13))
             {
                 if (la.kind == 50 || la.kind == 57)
                 {
                     if (la.kind == 57)
                     {
                         Get();
                     }
                     else
                     {
                         Get();
                     }
                 }
                 Type(out type, false);
                 Expect(1);
                 if (la.kind == 87)
                 {
                     Get();
                     this.m_Current += ", " + la.val;
                     FormalParameterList();
                 }
             }
             else if (la.kind == 52)
             {
                 Get();
                 Type(out type, false);
                 if (type != TypeKind.array) { Error("params argument must be an array"); }
                 Expect(1);
             }
             else SynErr(141);
         }
 
         void ClassType()
         {
             if (la.kind == 1)
             {
                 TypeName();
             }
             else if (la.kind == 48 || la.kind == 65)
             {
                 InternalClassType();
             }
             else SynErr(142);
         }
 
         void ClassMemberDeclaration(Modifiers m)
         {
             if (StartOf(14))
             {
                 StructMemberDeclaration(m);
             }
             else if (la.kind == 115)
             {
                 Get();
                 Expect(1);
                 Expect(98);
                 Expect(113);
                 if (la.kind == 96)
                 {
                     Block();
                 }
                 else if (la.kind == 114)
                 {
                     Get();
                 }
                 else SynErr(143);
             }
             else SynErr(144);
         }
 
         void StructMemberDeclaration(Modifiers m)
         {
             TypeKind type; Operator op;
             string dataType = la.val;
             if (la.kind == 17)
             {
                 TokenMatch tm = new TokenMatch();
                 m.Check(Modifier.constants);
                 Get();
                 dataType = la.val;
                 Type(out type, false);
                 tm.Position = la.pos;
                 tm.Value = la.val + "
                 Expect(1);
                 tm.Value += " = ";
                 Expect(85);
                 tm.Value += la.val;
                 Expression();
                 while (la.kind == 87)
                 {
                     Get();
                     Expect(1);
                     Expect(85);
                     Expression();
                 }
                 Expect(114);
                 this.m_CodeInfo.Fields.Add(tm);
             }
             else if (la.kind == 26)
             {
                 m.Check(Modifier.propEvntMeths);
                 Get();
                 Type(out type, false);
                 if (IsFieldDecl())
                 {
                     VariableDeclarators();
                     Expect(114);
                 }
                 else if (la.kind == 1)
                 {
                     TypeName();
                     Expect(96);
                     EventAccessorDeclarations();
                     Expect(111);
                 }
                 else SynErr(145);
             }
             else if (la.kind == _ident && Peek(1).kind == _lpar)
             {
                 TokenMatch tm = new TokenMatch(la.val, la.pos);
                 this.m_Current = "(";
                 m.Check(Modifier.constructors | Modifier.staticConstr);
                 Expect(1);
                 Expect(98);
                 this.m_Current += la.val;
                 if (StartOf(7))
                 {
                     m.Check(Modifier.constructors);
                     FormalParameterList();
                 }
                 Expect(113);
                 if (!this.m_Current.Equals("()"))
                 {
                     this.m_Current += ")";
                 }
                 tm.Value += this.m_Current;
                 this.m_CodeInfo.Constructors.Add(tm);
                 if (la.kind == 86)
                 {
                     m.Check(Modifier.constructors);
                     Get();
                     if (la.kind == 8)
                     {
                         Get();
                     }
                     else if (la.kind == 68)
                     {
                         Get();
                     }
                     else SynErr(146);
                     Expect(98);
                     if (StartOf(15))
                     {
                         Argument();
                         while (la.kind == 87)
                         {
                             Get();
                             Argument();
                         }
                     }
                     Expect(113);
                 }
                 if (la.kind == 96)
                 {
                     Block();
                 }
                 else if (la.kind == 114)
                 {
                     Get();
                 }
                 else SynErr(147);
             }
             else if (StartOf(11))
             {
                 Type(out type, true);
                 if (la.kind == 49)
                 {
                     m.Check(Modifier.operators);
                     m.CheckMust(Modifier.operatorsMust);
                     if (type == TypeKind.@void) { Error("operator not allowed on void"); }
 
                     Get();
                     OverloadableOp(out op);
                     Expect(98);
                     Type(out type, false);
                     Expect(1);
                     if (la.kind == 87)
                     {
                         Get();
                         Type(out type, false);
                         Expect(1);
                         if ((op & Operator.binary) == 0) Error("too many operands for unary operator");
                     }
                     else if (la.kind == 113)
                     {
                         if ((op & Operator.unary) == 0) Error("too few operands for binary operator");
                     }
                     else SynErr(148);
                     Expect(113);
                     if (la.kind == 96)
                     {
                         Block();
                     }
                     else if (la.kind == 114)
                     {
                         Get();
                     }
                     else SynErr(149);
                 }
                 else if (IsFieldDecl())
                 {
                     m.Check(Modifier.fields);
                     if (type == TypeKind.@void) { Error("field type must not be void"); }
 
                     this.m_CodeInfo.Fields.Add(new TokenMatch(la.val + "
                     VariableDeclarators();
                     Expect(114);
                 }
                 else if (la.kind == 1)
                 {
                     TokenMatch tm = new TokenMatch(la.val, la.pos);
                     //this.m_CodeInfo.Methods.Add(new TokenMatch(la.val + "
                     MemberName();
                     if (la.kind == 96)
                     {
                         m.Check(Modifier.propEvntMeths);
                         if (type == TypeKind.@void) { Error("property type must not be void"); }
 
                         this.m_Current = "(";
                         Get();
                         AccessorDeclarations(m);
                         Expect(111);
                         this.m_Current += ")";
 
                         tm.Value += this.m_Current;
                         tm.Value += "
                         this.m_CodeInfo.Properties.Add(tm);
                     }
                     else if (la.kind == 90)
                     {
                         m.Check(Modifier.indexers);
                         if (type == TypeKind.@void) { Error("indexer type must not be void"); }
 
                         Get();
                         Expect(68);
                         Expect(97);
                         FormalParameterList();
                         Expect(112);
                         Expect(96);
                         AccessorDeclarations(m);
                         Expect(111);
                     }
                     else if (la.kind == 98 || la.kind == 100)
                     {
                         m.Check(Modifier.propEvntMeths);
                         if (la.kind == 100)
                         {
                             TypeParameterList();
                         }
                         Expect(98);
                         this.m_Current = "(" + la.val;
                         if (StartOf(7))
                         {
                             FormalParameterList();
                         }
                         if (!this.m_Current.Equals("()"))
                         {
                             this.m_Current += ")";
                         }
                         tm.Value += this.m_Current;
                         Expect(113);
                         while (la.kind == 1)
                         {
                             TypeParameterConstraintsClause();
                         }
                         if (la.kind == 96)
                         {
                             Block();
                         }
                         else if (la.kind == 114)
                         {
                             Get();
                         }
                         else SynErr(150);
 
                         tm.Value += "
                         this.m_CodeInfo.Methods.Add(tm);
                     }
                     else SynErr(151);
                 }
                 else if (la.kind == 68)
                 {
                     m.Check(Modifier.indexers);
                     if (type == TypeKind.@void) { Error("indexer type must not be void"); }
 
                     Get();
                     Expect(97);
                     FormalParameterList();
                     Expect(112);
                     Expect(96);
                     AccessorDeclarations(m);
                     Expect(111);
                 }
                 else SynErr(152);
             }
             else if (la.kind == 27 || la.kind == 37)
             {
                 m.Check(Modifier.operators);
                 m.CheckMust(Modifier.operatorsMust);
 
                 if (la.kind == 37)
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                 }
                 Expect(49);
                 Type(out type, false);
                 if (type == TypeKind.@void) { Error("cast type must not be void"); }
                 Expect(98);
                 Type(out type, false);
                 Expect(1);
                 Expect(113);
                 if (la.kind == 96)
                 {
                     Block();
                 }
                 else if (la.kind == 114)
                 {
                     Get();
                 }
                 else SynErr(153);
             }
             else if (StartOf(16))
             {
                 TypeDeclaration(m);
             }
             else SynErr(154);
         }
 
         void EnumMemberDeclaration()
         {
             while (la.kind == 97)
             {
                 Attributes();
             }
             Expect(1);
             if (la.kind == 85)
             {
                 Get();
                 Expression();
             }
         }
 
         void Block()
         {
             Expect(96);
             while (StartOf(17))
             {
                 Statement();
             }
             Expect(111);
         }
 
         void Expression()
         {
             Unary();
             if (assgnOps[la.kind] || (la.kind == _gt && Peek(1).kind == _gteq))
             {
                 AssignmentOperator();
                 Expression();
             }
             else if (StartOf(18))
             {
                 NullCoalescingExpr();
                 if (la.kind == 110)
                 {
                     Get();
                     Expression();
                     Expect(86);
                     Expression();
                 }
             }
             else SynErr(155);
         }
 
         void VariableDeclarators()
         {
             Expect(1);
             if (la.kind == 85)
             {
                 Get();
                 VariableInitializer();
             }
             while (la.kind == 87)
             {
                 Get();
                 Expect(1);
                 if (la.kind == 85)
                 {
                     Get();
                     VariableInitializer();
                 }
             }
         }
 
         void EventAccessorDeclarations()
         {
             bool addFound = false, remFound = false;
             while (la.kind == 97)
             {
                 Attributes();
             }
             if ("add".Equals(la.val))
             {
                 Expect(1);
                 addFound = true;
             }
             else if ("remove".Equals(la.val))
             {
                 Expect(1);
                 remFound = true;
             }
             else if (la.kind == 1)
             {
                 Get();
                 Error("add or remove expected");
             }
             else SynErr(156);
             Block();
             if (la.kind == 1 || la.kind == 97)
             {
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 if ("add".Equals(la.val))
                 {
                     Expect(1);
                     if (addFound) Error("add already declared");
                 }
                 else if ("remove".Equals(la.val))
                 {
                     Expect(1);
                     if (remFound) Error("remove already declared");
                 }
                 else if (la.kind == 1)
                 {
                     Get();
                     Error("add or remove expected");
                 }
                 else SynErr(157);
                 Block();
             }
         }
 
         void Argument()
         {
             if (la.kind == 50 || la.kind == 57)
             {
                 if (la.kind == 57)
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                 }
             }
             Expression();
         }
 
         void OverloadableOp(out Operator op)
         {
             op = Operator.plus;
             switch (la.kind)
             {
                 case 108
                     {
                         Get();
                         break;
                     }
                 case 102
                     {
                         Get();
                         op = Operator.minus;
                         break;
                     }
                 case 106
                     {
                         Get();
                         op = Operator.not;
                         break;
                     }
                 case 115
                     {
                         Get();
                         op = Operator.tilde;
                         break;
                     }
                 case 95
                     {
                         Get();
                         op = Operator.inc;
                         break;
                     }
                 case 88
                     {
                         Get();
                         op = Operator.dec;
                         break;
                     }
                 case 70
                     {
                         Get();
                         op = Operator.@true;
                         break;
                     }
                 case 29
                     {
                         Get();
                         op = Operator.@false;
                         break;
                     }
                 case 116
                     {
                         Get();
                         op = Operator.times;
                         break;
                     }
                 case 127
                     {
                         Get();
                         op = Operator.div;
                         break;
                     }
                 case 128
                     {
                         Get();
                         op = Operator.mod;
                         break;
                     }
                 case 83
                     {
                         Get();
                         op = Operator.and;
                         break;
                     }
                 case 124
                     {
                         Get();
                         op = Operator.or;
                         break;
                     }
                 case 125
                     {
                         Get();
                         op = Operator.xor;
                         break;
                     }
                 case 101
                     {
                         Get();
                         op = Operator.lshift;
                         break;
                     }
                 case 92
                     {
                         Get();
                         op = Operator.eq;
                         break;
                     }
                 case 105
                     {
                         Get();
                         op = Operator.neq;
                         break;
                     }
                 case 93
                     {
                         Get();
                         op = Operator.gt;
                         if (la.kind == 93)
                         {
                             if (la.pos > t.pos + 1) Error("no whitespace allowed in right shift operator");
                             Get();
                             op = Operator.rshift;
                         }
                         break;
                     }
                 case 100
                     {
                         Get();
                         op = Operator.lt;
                         break;
                     }
                 case 94
                     {
                         Get();
                         op = Operator.gte;
                         break;
                     }
                 case 126
                     {
                         Get();
                         op = Operator.lte;
                         break;
                     }
                 default
             }
         }
 
         void MemberName()
         {
             Expect(1);
             if (la.kind == 91)
             {
                 Get();
                 Expect(1);
             }
             if (la.kind == _lt && IsPartOfMemberName())
             {
                 TypeArgumentList();
             }
             while (la.kind == _dot && Peek(1).kind == _ident)
             {
                 Expect(90);
                 Expect(1);
                 if (la.kind == _lt && IsPartOfMemberName())
                 {
                     TypeArgumentList();
                 }
             }
         }
 
         void AccessorDeclarations(Modifiers m)
         {
             Modifiers am = new Modifiers(this);
             bool getFound = false, setFound = false;
 
             while (la.kind == 97)
             {
                 Attributes();
             }
             ModifierList(am);
             am.Check(Modifier.accessorsPossib1, Modifier.accessorsPossib2);
             if ("get".Equals(la.val))
             {
                 if (!this.m_Current.Equals("("))
                 {
                     this.m_Current += ", ";
                 }
                 this.m_Current += "get";
                 Expect(1);
                 getFound = true;
             }
             else if ("set".Equals(la.val))
             {
                 if (!this.m_Current.Equals("("))
                 {
                     this.m_Current += ", ";
                 }
                 this.m_Current += "set";
                 Expect(1);
                 setFound = true;
             }
             else if (la.kind == 1)
             {
                 Get();
                 Error("set or get expected");
             }
             else SynErr(159);
             if (la.kind == 96)
             {
                 Block();
             }
             else if (la.kind == 114)
             {
                 Get();
             }
             else SynErr(160);
             if (StartOf(19))
             {
                 am = new Modifiers(this);
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 ModifierList(am);
                 am.Check(Modifier.accessorsPossib1, Modifier.accessorsPossib2);
                 if ("get".Equals(la.val))
                 {
                     Expect(1);
                     if (getFound) Error("get already declared");
                 }
                 else if ("set".Equals(la.val))
                 {
                     Expect(1);
                     if (setFound) Error("set already declared");
                 }
                 else if (la.kind == 1)
                 {
                     Get();
                     Error("set or get expected");
                 }
                 else SynErr(161);
                 if (la.kind == 96)
                 {
                     Block();
                 }
                 else if (la.kind == 114)
                 {
                     Get();
                 }
                 else SynErr(162);
             }
         }
 
         void InterfaceAccessors(Modifiers m)
         {
             bool getFound = false, setFound = false;
             while (la.kind == 97)
             {
                 Attributes();
             }
             if ("get".Equals(la.val))
             {
                 Expect(1);
                 getFound = true;
             }
             else if ("set".Equals(la.val))
             {
                 Expect(1);
                 setFound = true;
             }
             else if (la.kind == 1)
             {
                 Get();
                 Error("set or get expected");
             }
             else SynErr(163);
             Expect(114);
             if (la.kind == 1 || la.kind == 97)
             {
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 if ("get".Equals(la.val))
                 {
                     Expect(1);
                     if (getFound) Error("get already declared");
                 }
                 else if ("set".Equals(la.val))
                 {
                     Expect(1);
                     if (setFound) Error("set already declared");
                 }
                 else if (la.kind == 1)
                 {
                     Get();
                     Error("set or get expected");
                 }
                 else SynErr(164);
                 Expect(114);
             }
         }
 
         void LocalVariableDeclaration()
         {
             TypeKind dummy;
             Type(out dummy, false);
             LocalVariableDeclarator();
             while (la.kind == 87)
             {
                 Get();
                 LocalVariableDeclarator();
             }
         }
 
         void LocalVariableDeclarator()
         {
             TypeKind dummy;
             Expect(1);
             if (la.kind == 85)
             {
                 Get();
                 if (StartOf(20))
                 {
                     VariableInitializer();
                 }
                 else if (la.kind == 63)
                 {
                     Get();
                     Type(out dummy, false);
                     Expect(97);
                     Expression();
                     Expect(112);
                 }
                 else SynErr(165);
             }
         }
 
         void VariableInitializer()
         {
             if (StartOf(21))
             {
                 Expression();
             }
             else if (la.kind == 96)
             {
                 ArrayInitializer();
             }
             else SynErr(166);
         }
 
         void ArrayInitializer()
         {
             Expect(96);
             if (StartOf(20))
             {
                 VariableInitializer();
                 while (NotFinalComma())
                 {
                     Expect(87);
                     VariableInitializer();
                 }
                 if (la.kind == 87)
                 {
                     Get();
                 }
             }
             Expect(111);
         }
 
         void Attribute()
         {
             TypeName();
             if (la.kind == 98)
             {
                 AttributeArguments();
             }
         }
 
         void Keyword()
         {
             switch (la.kind)
             {
                 case 6
                     {
                         Get();
                         break;
                     }
                 case 7
                     {
                         Get();
                         break;
                     }
                 case 8
                     {
                         Get();
                         break;
                     }
                 case 9
                     {
                         Get();
                         break;
                     }
                 case 10
                     {
                         Get();
                         break;
                     }
                 case 11
                     {
                         Get();
                         break;
                     }
                 case 12
                     {
                         Get();
                         break;
                     }
                 case 13
                     {
                         Get();
                         break;
                     }
                 case 14
                     {
                         Get();
                         break;
                     }
                 case 15
                     {
                         Get();
                         break;
                     }
                 case 16
                     {
                         Get();
                         break;
                     }
                 case 17
                     {
                         Get();
                         break;
                     }
                 case 18
                     {
                         Get();
                         break;
                     }
                 case 19
                     {
                         Get();
                         break;
                     }
                 case 20
                     {
                         Get();
                         break;
                     }
                 case 21
                     {
                         Get();
                         break;
                     }
                 case 22
                     {
                         Get();
                         break;
                     }
                 case 23
                     {
                         Get();
                         break;
                     }
                 case 24
                     {
                         Get();
                         break;
                     }
                 case 25
                     {
                         Get();
                         break;
                     }
                 case 26
                     {
                         Get();
                         break;
                     }
                 case 27
                     {
                         Get();
                         break;
                     }
                 case 28
                     {
                         Get();
                         break;
                     }
                 case 29
                     {
                         Get();
                         break;
                     }
                 case 30
                     {
                         Get();
                         break;
                     }
                 case 31
                     {
                         Get();
                         break;
                     }
                 case 32
                     {
                         Get();
                         break;
                     }
                 case 33
                     {
                         Get();
                         break;
                     }
                 case 34
                     {
                         Get();
                         break;
                     }
                 case 35
                     {
                         Get();
                         break;
                     }
                 case 36
                     {
                         Get();
                         break;
                     }
                 case 37
                     {
                         Get();
                         break;
                     }
                 case 38
                     {
                         Get();
                         break;
                     }
                 case 39
                     {
                         Get();
                         break;
                     }
                 case 40
                     {
                         Get();
                         break;
                     }
                 case 41
                     {
                         Get();
                         break;
                     }
                 case 42
                     {
                         Get();
                         break;
                     }
                 case 43
                     {
                         Get();
                         break;
                     }
                 case 44
                     {
                         Get();
                         break;
                     }
                 case 45
                     {
                         Get();
                         break;
                     }
                 case 46
                     {
                         Get();
                         break;
                     }
                 case 47
                     {
                         Get();
                         break;
                     }
                 case 48
                     {
                         Get();
                         break;
                     }
                 case 49
                     {
                         Get();
                         break;
                     }
                 case 50
                     {
                         Get();
                         break;
                     }
                 case 51
                     {
                         Get();
                         break;
                     }
                 case 52
                     {
                         Get();
                         break;
                     }
                 case 53
                     {
                         Get();
                         break;
                     }
                 case 54
                     {
                         Get();
                         break;
                     }
                 case 55
                     {
                         Get();
                         break;
                     }
                 case 56
                     {
                         Get();
                         break;
                     }
                 case 57
                     {
                         Get();
                         break;
                     }
                 case 58
                     {
                         Get();
                         break;
                     }
                 case 59
                     {
                         Get();
                         break;
                     }
                 case 60
                     {
                         Get();
                         break;
                     }
                 case 61
                     {
                         Get();
                         break;
                     }
                 case 62
                     {
                         Get();
                         break;
                     }
                 case 63
                     {
                         Get();
                         break;
                     }
                 case 64
                     {
                         Get();
                         break;
                     }
                 case 65
                     {
                         Get();
                         break;
                     }
                 case 66
                     {
                         Get();
                         break;
                     }
                 case 67
                     {
                         Get();
                         break;
                     }
                 case 68
                     {
                         Get();
                         break;
                     }
                 case 69
                     {
                         Get();
                         break;
                     }
                 case 70
                     {
                         Get();
                         break;
                     }
                 case 71
                     {
                         Get();
                         break;
                     }
                 case 72
                     {
                         Get();
                         break;
                     }
                 case 73
                     {
                         Get();
                         break;
                     }
                 case 74
                     {
                         Get();
                         break;
                     }
                 case 75
                     {
                         Get();
                         break;
                     }
                 case 76
                     {
                         Get();
                         break;
                     }
                 case 77
                     {
                         Get();
                         break;
                     }
                 case 78
                     {
                         Get();
                         break;
                     }
                 case 79
                     {
                         Get();
                         break;
                     }
                 case 80
                     {
                         Get();
                         break;
                     }
                 case 81
                     {
                         Get();
                         break;
                     }
                 case 82
                     {
                         Get();
                         break;
                     }
                 default
             }
         }
 
         void AttributeArguments()
         {
             bool nameFound = false;
             Expect(98);
             if (StartOf(21))
             {
                 if (IsAssignment())
                 {
                     nameFound = true;
                     Expect(1);
                     Expect(85);
                 }
                 Expression();
                 while (la.kind == 87)
                 {
                     Get();
                     if (IsAssignment())
                     {
                         nameFound = true;
                         Expect(1);
                         Expect(85);
                     }
                     else if (StartOf(21))
                     {
                         if (nameFound) Error("no positional argument after named arguments");
                     }
                     else SynErr(168);
                     Expression();
                 }
             }
             Expect(113);
         }
 
         void PrimitiveType()
         {
             if (StartOf(22))
             {
                 IntegralType();
             }
             else if (la.kind == 32)
             {
                 Get();
             }
             else if (la.kind == 23)
             {
                 Get();
             }
             else if (la.kind == 19)
             {
                 Get();
             }
             else if (la.kind == 9)
             {
                 Get();
             }
             else SynErr(169);
         }
 
         void PointerOrArray(ref TypeKind type)
         {
             while (IsPointerOrDims())
             {
                 if (la.kind == 116)
                 {
                     Get();
                     type = TypeKind.pointer;
                 }
                 else if (la.kind == 97)
                 {
                     Get();
                     while (la.kind == 87)
                     {
                         Get();
                     }
                     this.m_Current += "[]";
                     Expect(112);
                     type = TypeKind.array;
                 }
                 else SynErr(170);
             }
         }
 
         void ResolvedType()
         {
             TypeKind type = TypeKind.simple;
             if (StartOf(12))
             {
                 PrimitiveType();
             }
             else if (la.kind == 48)
             {
                 Get();
             }
             else if (la.kind == 65)
             {
                 Get();
             }
             else if (la.kind == 1)
             {
                 Get();
                 if (la.kind == 91)
                 {
                     Get();
                     Expect(1);
                 }
                 if (IsGeneric())
                 {
                     TypeArgumentList();
                 }
                 while (la.kind == 90)
                 {
                     Get();
                     Expect(1);
                     if (IsGeneric())
                     {
                         TypeArgumentList();
                     }
                 }
             }
             else if (la.kind == 80)
             {
                 Get();
                 type = TypeKind.@void;
             }
             else SynErr(171);
             PointerOrArray(ref type);
             if (type == TypeKind.@void) Error("type expected, void found, maybe you mean void*");
         }
 
         void TypeArgumentList()
         {
             TypeKind dummy;
             Expect(100);
             if (StartOf(11))
             {
                 Type(out dummy, false);
             }
             while (la.kind == 87)
             {
                 Get();
                 if (StartOf(11))
                 {
                     Type(out dummy, false);
                 }
             }
             Expect(93);
         }
 
         void InternalClassType()
         {
             if (la.kind == 48)
             {
                 Get();
             }
             else if (la.kind == 65)
             {
                 Get();
             }
             else SynErr(172);
         }
 
         void Statement()
         {
             TypeKind dummy;
             if (la.kind == _ident && Peek(1).kind == _colon)
             {
                 Expect(1);
                 Expect(86);
                 Statement();
             }
             else if (la.kind == 17)
             {
                 Get();
                 Type(out dummy, false);
                 Expect(1);
                 Expect(85);
                 Expression();
                 while (la.kind == 87)
                 {
                     Get();
                     Expect(1);
                     Expect(85);
                     Expression();
                 }
                 Expect(114);
             }
             else if (IsLocalVarDecl())
             {
                 LocalVariableDeclaration();
                 Expect(114);
             }
             else if (StartOf(23))
             {
                 EmbeddedStatement();
             }
             else SynErr(173);
         }
 
         void EmbeddedStatement()
         {
             TypeKind type;
             if (la.kind == 96)
             {
                 Block();
             }
             else if (la.kind == 114)
             {
                 Get();
             }
             else if (la.kind == _checked && Peek(1).kind == _lbrace)
             {
                 Expect(15);
                 Block();
             }
             else if (la.kind == _unchecked && Peek(1).kind == _lbrace)
             {
                 Expect(75);
                 Block();
             }
             else if (StartOf(21))
             {
                 StatementExpression();
                 Expect(114);
             }
             else if (la.kind == 36)
             {
                 Get();
                 Expect(98);
                 Expression();
                 Expect(113);
                 EmbeddedStatement();
                 if (la.kind == 24)
                 {
                     Get();
                     EmbeddedStatement();
                 }
             }
             else if (la.kind == 67)
             {
                 Get();
                 Expect(98);
                 Expression();
                 Expect(113);
                 Expect(96);
                 while (la.kind == 12 || la.kind == 20)
                 {
                     SwitchSection();
                 }
                 Expect(111);
             }
             else if (la.kind == 82)
             {
                 Get();
                 Expect(98);
                 Expression();
                 Expect(113);
                 EmbeddedStatement();
             }
             else if (la.kind == 22)
             {
                 Get();
                 EmbeddedStatement();
                 Expect(82);
                 Expect(98);
                 Expression();
                 Expect(113);
                 Expect(114);
             }
             else if (la.kind == 33)
             {
                 Get();
                 Expect(98);
                 if (StartOf(24))
                 {
                     ForInitializer();
                 }
                 Expect(114);
                 if (StartOf(21))
                 {
                     Expression();
                 }
                 Expect(114);
                 if (StartOf(21))
                 {
                     ForIterator();
                 }
                 Expect(113);
                 EmbeddedStatement();
             }
             else if (la.kind == 34)
             {
                 Get();
                 Expect(98);
                 Type(out type, false);
                 Expect(1);
                 Expect(38);
                 Expression();
                 Expect(113);
                 EmbeddedStatement();
             }
             else if (la.kind == 10)
             {
                 Get();
                 Expect(114);
             }
             else if (la.kind == 18)
             {
                 Get();
                 Expect(114);
             }
             else if (la.kind == 35)
             {
                 Get();
                 if (la.kind == 1)
                 {
                     Get();
                 }
                 else if (la.kind == 12)
                 {
                     Get();
                     Expression();
                 }
                 else if (la.kind == 20)
                 {
                     Get();
                 }
                 else SynErr(174);
                 Expect(114);
             }
             else if (la.kind == 58)
             {
                 Get();
                 if (StartOf(21))
                 {
                     Expression();
                 }
                 Expect(114);
             }
             else if (la.kind == 69)
             {
                 Get();
                 if (StartOf(21))
                 {
                     Expression();
                 }
                 Expect(114);
             }
             else if (la.kind == 71)
             {
                 Get();
                 Block();
                 if (la.kind == 13)
                 {
                     CatchClauses();
                     if (la.kind == 30)
                     {
                         Get();
                         Block();
                     }
                 }
                 else if (la.kind == 30)
                 {
                     Get();
                     Block();
                 }
                 else SynErr(175);
             }
             else if (la.kind == 43)
             {
                 Get();
                 Expect(98);
                 Expression();
                 Expect(113);
                 EmbeddedStatement();
             }
             else if (la.kind == 78)
             {
                 Get();
                 Expect(98);
                 ResourceAcquisition();
                 Expect(113);
                 EmbeddedStatement();
             }
             else if (la.kind == 120)
             {
                 Get();
                 if (la.kind == 58)
                 {
                     Get();
                     Expression();
                 }
                 else if (la.kind == 10)
                 {
                     Get();
                 }
                 else SynErr(176);
                 Expect(114);
             }
             else if (la.kind == 76)
             {
                 Get();
                 Block();
             }
             else if (la.kind == 31)
             {
                 Get();
                 Expect(98);
                 Type(out type, false);
                 if (type != TypeKind.pointer) Error("can only fix pointer types");
                 Expect(1);
                 Expect(85);
                 Expression();
                 while (la.kind == 87)
                 {
                     Get();
                     Expect(1);
                     Expect(85);
                     Expression();
                 }
                 Expect(113);
                 EmbeddedStatement();
             }
             else SynErr(177);
         }
 
         void StatementExpression()
         {
             bool isAssignment = assnStartOp[la.kind] || IsTypeCast();
             Unary();
             if (StartOf(25))
             {
                 AssignmentOperator();
                 Expression();
             }
             else if (la.kind == 87 || la.kind == 113 || la.kind == 114)
             {
                 if (isAssignment) Error("error in assignment.");
             }
             else SynErr(178);
         }
 
         void SwitchSection()
         {
             SwitchLabel();
             while (la.kind == _case || (la.kind == _default && Peek(1).kind == _colon))
             {
                 SwitchLabel();
             }
             Statement();
             while (IsNoSwitchLabelOrRBrace())
             {
                 Statement();
             }
         }
 
         void ForInitializer()
         {
             if (IsLocalVarDecl())
             {
                 LocalVariableDeclaration();
             }
             else if (StartOf(21))
             {
                 StatementExpression();
                 while (la.kind == 87)
                 {
                     Get();
                     StatementExpression();
                 }
             }
             else SynErr(179);
         }
 
         void ForIterator()
         {
             StatementExpression();
             while (la.kind == 87)
             {
                 Get();
                 StatementExpression();
             }
         }
 
         void CatchClauses()
         {
             Expect(13);
             if (la.kind == 96)
             {
                 Block();
             }
             else if (la.kind == 98)
             {
                 Get();
                 ClassType();
                 if (la.kind == 1)
                 {
                     Get();
                 }
                 Expect(113);
                 Block();
                 if (la.kind == 13)
                 {
                     CatchClauses();
                 }
             }
             else SynErr(180);
         }
 
         void ResourceAcquisition()
         {
             if (IsLocalVarDecl())
             {
                 LocalVariableDeclaration();
             }
             else if (StartOf(21))
             {
                 Expression();
             }
             else SynErr(181);
         }
 
         void Unary()
         {
             TypeKind dummy;
             while (unaryHead[la.kind] || IsTypeCast())
             {
                 switch (la.kind)
                 {
                     case 108
                         {
                             Get();
                             break;
                         }
                     case 102
                         {
                             Get();
                             break;
                         }
                     case 106
                         {
                             Get();
                             break;
                         }
                     case 115
                         {
                             Get();
                             break;
                         }
                     case 95
                         {
                             Get();
                             break;
                         }
                     case 88
                         {
                             Get();
                             break;
                         }
                     case 116
                         {
                             Get();
                             break;
                         }
                     case 83
                         {
                             Get();
                             break;
                         }
                     case 98
                         {
                             Get();
                             Type(out dummy, false);
                             Expect(113);
                             break;
                         }
                     default
                 }
             }
             Primary();
         }
 
         void AssignmentOperator()
         {
             switch (la.kind)
             {
                 case 85
                     {
                         Get();
                         break;
                     }
                 case 109
                     {
                         Get();
                         break;
                     }
                 case 103
                     {
                         Get();
                         break;
                     }
                 case 117
                     {
                         Get();
                         break;
                     }
                 case 89
                     {
                         Get();
                         break;
                     }
                 case 104
                     {
                         Get();
                         break;
                     }
                 case 84
                     {
                         Get();
                         break;
                     }
                 case 107
                     {
                         Get();
                         break;
                     }
                 case 118
                     {
                         Get();
                         break;
                     }
                 case 99
                     {
                         Get();
                         break;
                     }
                 case 93
                     {
                         Get();
                         int pos = t.pos;
                         Expect(94);
                         if (pos + 1 < t.pos) Error("no whitespace allowed in right shift assignment");
                         break;
                     }
                 default
             }
         }
 
         void SwitchLabel()
         {
             if (la.kind == 12)
             {
                 Get();
                 Expression();
                 Expect(86);
             }
             else if (la.kind == 20)
             {
                 Get();
                 Expect(86);
             }
             else SynErr(184);
         }
 
         void NullCoalescingExpr()
         {
             OrExpr();
             while (la.kind == 121)
             {
                 Get();
                 Unary();
                 OrExpr();
             }
         }
 
         void OrExpr()
         {
             AndExpr();
             while (la.kind == 122)
             {
                 Get();
                 Unary();
                 AndExpr();
             }
         }
 
         void AndExpr()
         {
             BitOrExpr();
             while (la.kind == 123)
             {
                 Get();
                 Unary();
                 BitOrExpr();
             }
         }
 
         void BitOrExpr()
         {
             BitXorExpr();
             while (la.kind == 124)
             {
                 Get();
                 Unary();
                 BitXorExpr();
             }
         }
 
         void BitXorExpr()
         {
             BitAndExpr();
             while (la.kind == 125)
             {
                 Get();
                 Unary();
                 BitAndExpr();
             }
         }
 
         void BitAndExpr()
         {
             EqlExpr();
             while (la.kind == 83)
             {
                 Get();
                 Unary();
                 EqlExpr();
             }
         }
 
         void EqlExpr()
         {
             RelExpr();
             while (la.kind == 92 || la.kind == 105)
             {
                 if (la.kind == 105)
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                 }
                 Unary();
                 RelExpr();
             }
         }
 
         void RelExpr()
         {
             ShiftExpr();
             while (StartOf(26))
             {
                 if (StartOf(27))
                 {
                     if (la.kind == 100)
                     {
                         Get();
                     }
                     else if (la.kind == 93)
                     {
                         Get();
                     }
                     else if (la.kind == 126)
                     {
                         Get();
                     }
                     else if (la.kind == 94)
                     {
                         Get();
                     }
                     else SynErr(185);
                     Unary();
                     ShiftExpr();
                 }
                 else
                 {
                     if (la.kind == 42)
                     {
                         Get();
                     }
                     else if (la.kind == 7)
                     {
                         Get();
                     }
                     else SynErr(186);
                     ResolvedType();
                 }
             }
         }
 
         void ShiftExpr()
         {
             AddExpr();
             while (IsShift())
             {
                 if (la.kind == 101)
                 {
                     Get();
                 }
                 else if (la.kind == 93)
                 {
                     Get();
                     Expect(93);
                 }
                 else SynErr(187);
                 Unary();
                 AddExpr();
             }
         }
 
         void AddExpr()
         {
             MulExpr();
             while (la.kind == 102 || la.kind == 108)
             {
                 if (la.kind == 108)
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                 }
                 Unary();
                 MulExpr();
             }
         }
 
         void MulExpr()
         {
             while (la.kind == 116 || la.kind == 127 || la.kind == 128)
             {
                 if (la.kind == 116)
                 {
                     Get();
                 }
                 else if (la.kind == 127)
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                 }
                 Unary();
             }
         }
 
         void Primary()
         {
             TypeKind type; bool isArrayCreation = false;
             switch (la.kind)
             {
                 case 2
                 case 3
                 case 4
                 case 5
                 case 29
                 case 47
                 case 70
                     {
                         Literal();
                         break;
                     }
                 case 98
                     {
                         Get();
                         Expression();
                         Expect(113);
                         break;
                     }
                 case 9
                 case 11
                 case 14
                 case 19
                 case 23
                 case 32
                 case 39
                 case 44
                 case 48
                 case 59
                 case 61
                 case 65
                 case 73
                 case 74
                 case 77
                     {
                         switch (la.kind)
                         {
                             case 9
                                 {
                                     Get();
                                     break;
                                 }
                             case 11
                                 {
                                     Get();
                                     break;
                                 }
                             case 14
                                 {
                                     Get();
                                     break;
                                 }
                             case 19
                                 {
                                     Get();
                                     break;
                                 }
                             case 23
                                 {
                                     Get();
                                     break;
                                 }
                             case 32
                                 {
                                     Get();
                                     break;
                                 }
                             case 39
                                 {
                                     Get();
                                     break;
                                 }
                             case 44
                                 {
                                     Get();
                                     break;
                                 }
                             case 48
                                 {
                                     Get();
                                     break;
                                 }
                             case 59
                                 {
                                     Get();
                                     break;
                                 }
                             case 61
                                 {
                                     Get();
                                     break;
                                 }
                             case 65
                                 {
                                     Get();
                                     break;
                                 }
                             case 73
                                 {
                                     Get();
                                     break;
                                 }
                             case 74
                                 {
                                     Get();
                                     break;
                                 }
                             case 77
                                 {
                                     Get();
                                     break;
                                 }
                         }
                         Expect(90);
                         Expect(1);
                         if (IsGeneric())
                         {
                             TypeArgumentList();
                         }
                         break;
                     }
                 case 1
                     {
                         Get();
                         if (la.kind == 91)
                         {
                             Get();
                             Expect(1);
                             if (la.kind == 100)
                             {
                                 TypeArgumentList();
                             }
                             Expect(90);
                             Expect(1);
                         }
                         if (IsGeneric())
                         {
                             TypeArgumentList();
                         }
                         break;
                     }
                 case 68
                     {
                         Get();
                         break;
                     }
                 case 8
                     {
                         Get();
                         if (la.kind == 90)
                         {
                             Get();
                             Expect(1);
                             if (IsGeneric())
                             {
                                 TypeArgumentList();
                             }
                         }
                         else if (la.kind == 97)
                         {
                             Get();
                             Expression();
                             while (la.kind == 87)
                             {
                                 Get();
                                 Expression();
                             }
                             Expect(112);
                         }
                         else SynErr(188);
                         break;
                     }
                 case 46
                     {
                         Get();
                         Type(out type, false);
                         if (la.kind == 98)
                         {
                             Get();
                             if (StartOf(15))
                             {
                                 Argument();
                                 while (la.kind == 87)
                                 {
                                     Get();
                                     Argument();
                                 }
                             }
                             Expect(113);
                         }
                         else if (la.kind == 97)
                         {
                             Get();
                             Expression();
                             while (la.kind == 87)
                             {
                                 Get();
                                 Expression();
                             }
                             Expect(112);
                             while (IsDims())
                             {
                                 Expect(97);
                                 while (la.kind == 87)
                                 {
                                     Get();
                                 }
                                 Expect(112);
                             }
                             if (la.kind == 96)
                             {
                                 ArrayInitializer();
                             }
                             isArrayCreation = true;
                         }
                         else if (la.kind == 96)
                         {
                             ArrayInitializer();
                             if (type != TypeKind.array) Error("array type expected");
                             isArrayCreation = true;
 
                         }
                         else SynErr(189);
                         break;
                     }
                 case 72
                     {
                         Get();
                         Expect(98);
                         Type(out type, true);
                         Expect(113);
                         break;
                     }
                 case 15
                     {
                         Get();
                         Expect(98);
                         Expression();
                         Expect(113);
                         break;
                     }
                 case 75
                     {
                         Get();
                         Expect(98);
                         Expression();
                         Expect(113);
                         break;
                     }
                 case 20
                     {
                         Get();
                         Expect(98);
                         Primary();
                         Expect(113);
                         break;
                     }
                 case 21
                     {
                         Get();
                         if (la.kind == 98)
                         {
                             Get();
                             if (StartOf(13))
                             {
                                 AnonymousMethodParameter();
                                 while (la.kind == 87)
                                 {
                                     Get();
                                     AnonymousMethodParameter();
                                 }
                             }
                             Expect(113);
                         }
                         Block();
                         break;
                     }
                 case 62
                     {
                         Get();
                         Expect(98);
                         Type(out type, false);
                         Expect(113);
                         break;
                     }
                 default
             }
             while (StartOf(28))
             {
                 switch (la.kind)
                 {
                     case 95
                         {
                             Get();
                             break;
                         }
                     case 88
                         {
                             Get();
                             break;
                         }
                     case 129
                         {
                             Get();
                             Expect(1);
                             if (IsGeneric())
                             {
                                 TypeArgumentList();
                             }
                             break;
                         }
                     case 90
                         {
                             Get();
                             Expect(1);
                             if (IsGeneric())
                             {
                                 TypeArgumentList();
                             }
                             break;
                         }
                     case 98
                         {
                             Get();
                             if (StartOf(15))
                             {
                                 Argument();
                                 while (la.kind == 87)
                                 {
                                     Get();
                                     Argument();
                                 }
                             }
                             Expect(113);
                             break;
                         }
                     case 97
                         {
                             if (isArrayCreation) Error("element access not allow on array creation");
                             Get();
                             Expression();
                             while (la.kind == 87)
                             {
                                 Get();
                                 Expression();
                             }
                             Expect(112);
                             break;
                         }
                 }
             }
         }
 
         void Literal()
         {
             switch (la.kind)
             {
                 case 2
                     {
                         Get();
                         break;
                     }
                 case 3
                     {
                         Get();
                         break;
                     }
                 case 4
                     {
                         Get();
                         break;
                     }
                 case 5
                     {
                         Get();
                         break;
                     }
                 case 70
                     {
                         Get();
                         break;
                     }
                 case 29
                     {
                         Get();
                         break;
                     }
                 case 47
                     {
                         Get();
                         break;
                     }
                 default
             }
         }
 
         void AnonymousMethodParameter()
         {
             TypeKind dummy;
             if (la.kind == 50 || la.kind == 57)
             {
                 if (la.kind == 57)
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                 }
             }
             Type(out dummy, false);
             Expect(1);
         }
 
 
 
         public void Parse()
         {
             la = new Token();
             la.val = "";
             Get();
             CS2();
 
             Expect(0);
         }
 
         bool[,] set = {
         public Parser(Scanner scanner)
         {
             this.scanner = scanner;
             errors = new Errors();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="740" endline="745"><![CDATA[
 
         void SynErr(int n)
         {
             if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n);
             errDist = 0;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="746" endline="751"><![CDATA[
 
         public void SemErr(string msg)
         {
             if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg);
             errDist = 0;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="752" endline="801"><![CDATA[
 
         void Get()
         {
             for (; ; )
             {
                 t = la;
                 la = scanner.Scan();
                 if (la.kind <= maxT) { ++errDist; break; }
                 if (la.kind == 131)
                 {
                     AddCCS(la.val);
                 }
                 if (la.kind == 132)
                 {
                     RemCCS(la.val);
                 }
                 if (la.kind == 133)
                 {
                     IfPragma(la.val);
                 }
                 if (la.kind == 134)
                 {
                     ElifOrElsePragma();
                 }
                 if (la.kind == 135)
                 {
                     ElifOrElsePragma();
                 }
                 if (la.kind == 136)
                 {
                 }
                 if (la.kind == 137)
                 {
                 }
                 if (la.kind == 138)
                 {
                 }
                 if (la.kind == 139)
                 {
                 }
                 if (la.kind == 140)
                 {
                 }
                 if (la.kind == 141)
                 {
                 }
 
                 la = t;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="802" endline="806"><![CDATA[
 
         void Expect(int n)
         {
             if (la.kind == n) Get(); else { SynErr(n); }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="807" endline="811"><![CDATA[
 
         bool StartOf(int s)
         {
             return set[s, la.kind];
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="812" endline="821"><![CDATA[
 
         void ExpectWeak(int n, int follow)
         {
             if (la.kind == n) Get();
             else
             {
                 SynErr(n);
                 while (!StartOf(follow)) Get();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="822" endline="839"><![CDATA[
 
 
         bool WeakSeparator(int n, int syFol, int repFol)
         {
             int kind = la.kind;
             if (kind == n) { Get(); return true; }
             else if (StartOf(repFol)) { return false; }
             else
             {
                 SynErr(n);
                 while (!(set[syFol, kind] || set[repFol, kind] || set[0, kind]))
                 {
                     Get();
                     kind = la.kind;
                 }
                 while (!(set[syFol, kind] || set[repFol, kind] || set[0, kind]))
                 {
                     Get();
                     kind = la.kind;
                 }
                 return StartOf(syFol);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="840" endline="860"><![CDATA[
 
 
         void CS2()
         {
             while (IsExternAliasDirective())
             {
                 ExternAliasDirective();
             }
             while (IsExternAliasDirective())
             {
                 ExternAliasDirective();
             }
             while (la.kind == 78)
             {
                 UsingDirective();
             }
             while (la.kind == 78)
             {
                 UsingDirective();
             }
             while (IsGlobalAttrTarget())
             {
                 GlobalAttributes();
             }
             while (IsGlobalAttrTarget())
             {
                 GlobalAttributes();
             }
             while (StartOf(1))
             {
                 NamespaceMemberDeclaration();
             }
             while (StartOf(1))
             {
                 NamespaceMemberDeclaration();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="861" endline="877"><![CDATA[
 
         void ExternAliasDirective()
         {
             Expect(28);
             Expect(1);
             if (t.val != "alias")
             {
                 Error("alias expected");
             }
             else
             {
                 exts.Add(t.val);
             }
 
             Expect(1);
             Expect(114);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="878" endline="894"><![CDATA[
 
         void UsingDirective()
         {
             Expect(78);
             if (IsAssignment())
             {
                 Expect(1);
                 Expect(85);
             }
             TokenMatch tm = new TokenMatch();
             tm.Position = la.pos;
             this.m_Current = la.val;
             TypeName();
             tm.Value = this.m_Current;
             this.m_CodeInfo.Usings.Add(tm);
             Expect(114);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="895" endline="914"><![CDATA[
 
         void GlobalAttributes()
         {
             Expect(97);
             Expect(1);
             if (!"assembly".Equals(t.val) && !"module".Equals(t.val)) Error("global attribute target specifier \"assembly\" or \"module\" expected");
 
             Expect(86);
             Attribute();
             while (NotFinalComma())
             {
                 Expect(87);
                 Attribute();
             }
             while (NotFinalComma())
             {
                 Expect(87);
                 Attribute();
             }
             if (la.kind == 87)
             {
                 Get();
             }
             Expect(112);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="915" endline="960"><![CDATA[
 
         void NamespaceMemberDeclaration()
         {
             Modifiers m = new Modifiers(this);
             if (la.kind == 45)
             {
                 Get();
                 this.m_Current = la.val;
                 Expect(1);
                 while (la.kind == 90)
                 {
                     Get();
                     this.m_Current += "." + la.val;
                     Expect(1);
                 }
                 while (la.kind == 90)
                 {
                     Get();
                     this.m_Current += "." + la.val;
                     Expect(1);
                 }
                 Expect(96);
                 while (IsExternAliasDirective())
                 {
                     ExternAliasDirective();
                 }
                 while (IsExternAliasDirective())
                 {
                     ExternAliasDirective();
                 }
                 while (la.kind == 78)
                 {
                     UsingDirective();
                 }
                 while (la.kind == 78)
                 {
                     UsingDirective();
                 }
                 while (StartOf(1))
                 {
                     NamespaceMemberDeclaration();
                 }
                 while (StartOf(1))
                 {
                     NamespaceMemberDeclaration();
                 }
                 Expect(111);
                 if (la.kind == 114)
                 {
                     Get();
                 }
                 this.m_CodeInfo.NameSpaces.Add(this.m_Current);
             }
             else if (StartOf(2))
             {
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 ModifierList(m);
                 TypeDeclaration(m);
             }
             else SynErr(131);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="961" endline="984"><![CDATA[
 
         void TypeName()
         {
             Expect(1);
             if (la.kind == 91)
             {
                 Get();
                 Expect(1);
             }
             if (la.kind == 100)
             {
                 TypeArgumentList();
             }
             while (la.kind == 90)
             {
                 Get();
                 this.m_Current += "." + la.val;
                 Expect(1);
                 if (la.kind == 100)
                 {
                     TypeArgumentList();
                 }
             }
             while (la.kind == 90)
             {
                 Get();
                 this.m_Current += "." + la.val;
                 Expect(1);
                 if (la.kind == 100)
                 {
                     TypeArgumentList();
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="985" endline="1013"><![CDATA[
 
         void Attributes()
         {
             Expect(97);
             if (IsAttrTargSpec())
             {
                 if (la.kind == 1)
                 {
                     Get();
                 }
                 else if (StartOf(3))
                 {
                     Keyword();
                 }
                 else SynErr(132);
                 Expect(86);
             }
             Attribute();
             while (la.kind == _comma && Peek(1).kind != _rbrack)
             {
                 Expect(87);
                 Attribute();
             }
             while (la.kind == _comma && Peek(1).kind != _rbrack)
             {
                 Expect(87);
                 Attribute();
             }
             if (la.kind == 87)
             {
                 Get();
             }
             Expect(112);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="1014" endline="1107"><![CDATA[
 
         void ModifierList(Modifiers m)
         {
             while (StartOf(4))
             {
                 switch (la.kind)
                 {
                     case 46
                         {
                             Get();
                             m.Add(Modifier.@new);
                             break;
                         }
                     case 55
                         {
                             Get();
                             m.Add(Modifier.@public);
                             break;
                         }
                     case 54
                         {
                             Get();
                             m.Add(Modifier.@protected);
                             break;
                         }
                     case 41
                         {
                             Get();
                             m.Add(Modifier.@internal);
                             break;
                         }
                     case 53
                         {
                             Get();
                             m.Add(Modifier.@private);
                             break;
                         }
                     case 76
                         {
                             Get();
                             m.Add(Modifier.@unsafe);
                             break;
                         }
                     case 64
                         {
                             Get();
                             m.Add(Modifier.@static);
                             break;
                         }
                     case 56
                         {
                             Get();
                             m.Add(Modifier.@readonly);
                             break;
                         }
                     case 81
                         {
                             Get();
                             m.Add(Modifier.@volatile);
                             break;
                         }
                     case 79
                         {
                             Get();
                             m.Add(Modifier.@virtual);
                             break;
                         }
                     case 60
                         {
                             Get();
                             m.Add(Modifier.@sealed);
                             break;
                         }
                     case 51
                         {
                             Get();
                             m.Add(Modifier.@override);
                             break;
                         }
                     case 6
                         {
                             Get();
                             m.Add(Modifier.@abstract);
                             break;
                         }
                     case 28
                         {
                             Get();
                             m.Add(Modifier.@extern);
                             break;
                         }
                 }
             }
             while (StartOf(4))
             {
                 switch (la.kind)
                 {
                     case 46
                         {
                             Get();
                             m.Add(Modifier.@new);
                             break;
                         }
                     case 55
                         {
                             Get();
                             m.Add(Modifier.@public);
                             break;
                         }
                     case 54
                         {
                             Get();
                             m.Add(Modifier.@protected);
                             break;
                         }
                     case 41
                         {
                             Get();
                             m.Add(Modifier.@internal);
                             break;
                         }
                     case 53
                         {
                             Get();
                             m.Add(Modifier.@private);
                             break;
                         }
                     case 76
                         {
                             Get();
                             m.Add(Modifier.@unsafe);
                             break;
                         }
                     case 64
                         {
                             Get();
                             m.Add(Modifier.@static);
                             break;
                         }
                     case 56
                         {
                             Get();
                             m.Add(Modifier.@readonly);
                             break;
                         }
                     case 81
                         {
                             Get();
                             m.Add(Modifier.@volatile);
                             break;
                         }
                     case 79
                         {
                             Get();
                             m.Add(Modifier.@virtual);
                             break;
                         }
                     case 60
                         {
                             Get();
                             m.Add(Modifier.@sealed);
                             break;
                         }
                     case 51
                         {
                             Get();
                             m.Add(Modifier.@override);
                             break;
                         }
                     case 6
                         {
                             Get();
                             m.Add(Modifier.@abstract);
                             break;
                         }
                     case 28
                         {
                             Get();
                             m.Add(Modifier.@extern);
                             break;
                         }
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="1108" endline="1245"><![CDATA[
 
         void TypeDeclaration(Modifiers m)
         {
             TypeKind dummy;
             if (StartOf(5))
             {
                 if (la.kind == 119)
                 {
                     Get();
                 }
                 if (la.kind == 16)
                 {
                     m.Check(Modifier.classes);
                     Get();
                     Expect(1);
                     if (la.kind == 100)
                     {
                         TypeParameterList();
                     }
                     if (la.kind == 86)
                     {
                         ClassBase();
                     }
                     while (la.kind == 1)
                     {
                         TypeParameterConstraintsClause();
                     }
                     while (la.kind == 1)
                     {
                         TypeParameterConstraintsClause();
                     }
                     ClassBody();
                     if (la.kind == 114)
                     {
                         Get();
                     }
                 }
                 else if (la.kind == 66)
                 {
                     m.Check(Modifier.nonClassTypes);
                     Get();
                     Expect(1);
                     if (la.kind == 100)
                     {
                         TypeParameterList();
                     }
                     if (la.kind == 86)
                     {
                         Get();
                         TypeName();
                         while (la.kind == 87)
                         {
                             Get();
                             TypeName();
                         }
                         while (la.kind == 87)
                         {
                             Get();
                             TypeName();
                         }
                     }
                     while (la.kind == 1)
                     {
                         TypeParameterConstraintsClause();
                     }
                     while (la.kind == 1)
                     {
                         TypeParameterConstraintsClause();
                     }
                     StructBody();
                     if (la.kind == 114)
                     {
                         Get();
                     }
                 }
                 else if (la.kind == 40)
                 {
                     m.Check(Modifier.nonClassTypes);
                     Get();
                     Expect(1);
                     if (la.kind == 100)
                     {
                         TypeParameterList();
                     }
                     if (la.kind == 86)
                     {
                         Get();
                         TypeName();
                         while (la.kind == 87)
                         {
                             Get();
                             TypeName();
                         }
                         while (la.kind == 87)
                         {
                             Get();
                             TypeName();
                         }
                     }
                     while (la.kind == 1)
                     {
                         TypeParameterConstraintsClause();
                     }
                     while (la.kind == 1)
                     {
                         TypeParameterConstraintsClause();
                     }
                     Expect(96);
                     while (StartOf(6))
                     {
                         InterfaceMemberDeclaration();
                     }
                     while (StartOf(6))
                     {
                         InterfaceMemberDeclaration();
                     }
                     Expect(111);
                     if (la.kind == 114)
                     {
                         Get();
                     }
                 }
                 else SynErr(133);
             }
             else if (la.kind == 25)
             {
                 m.Check(Modifier.nonClassTypes);
                 Get();
                 Expect(1);
                 if (la.kind == 86)
                 {
                     Get();
                     IntegralType();
                 }
                 EnumBody();
                 if (la.kind == 114)
                 {
                     Get();
                 }
             }
             else if (la.kind == 21)
             {
                 m.Check(Modifier.nonClassTypes);
                 Get();
                 Type(out dummy, true);
                 Expect(1);
                 if (la.kind == 100)
                 {
                     TypeParameterList();
                 }
                 Expect(98);
                 if (StartOf(7))
                 {
                     FormalParameterList();
                 }
                 Expect(113);
                 while (la.kind == 1)
                 {
                     TypeParameterConstraintsClause();
                 }
                 while (la.kind == 1)
                 {
                     TypeParameterConstraintsClause();
                 }
                 Expect(114);
             }
             else SynErr(134);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="1246" endline="1265"><![CDATA[
 
         void TypeParameterList()
         {
             Expect(100);
             while (la.kind == 97)
             {
                 Attributes();
             }
             while (la.kind == 97)
             {
                 Attributes();
             }
             Expect(1);
             while (la.kind == 87)
             {
                 Get();
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 Expect(1);
             }
             while (la.kind == 87)
             {
                 Get();
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 Expect(1);
             }
             Expect(93);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="1266" endline="1276"><![CDATA[
 
         void ClassBase()
         {
             Expect(86);
             ClassType();
             while (la.kind == 87)
             {
                 Get();
                 TypeName();
             }
             while (la.kind == 87)
             {
                 Get();
                 TypeName();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="1277" endline="1330"><![CDATA[
 
         void TypeParameterConstraintsClause()
         {
             Expect(1);
             if (t.val != "where")
             {
                 Error("type parameter constraints clause must start with
             }
 
             Expect(1);
             Expect(86);
             if (StartOf(8))
             {
                 if (la.kind == 16)
                 {
                     Get();
                 }
                 else if (la.kind == 66)
                 {
                     Get();
                 }
                 else if (la.kind == 48)
                 {
                     Get();
                 }
                 else if (la.kind == 65)
                 {
                     Get();
                 }
                 else
                 {
                     TypeName();
                 }
                 while (la.kind == _comma && Peek(1).kind != _new)
                 {
                     Expect(87);
                     TypeName();
                 }
                 while (la.kind == _comma && Peek(1).kind != _new)
                 {
                     Expect(87);
                     TypeName();
                 }
                 if (la.kind == 87)
                 {
                     Get();
                     Expect(46);
                     Expect(98);
                     Expect(113);
                 }
             }
             else if (la.kind == 46)
             {
                 Get();
                 Expect(98);
                 Expect(113);
             }
             else SynErr(135);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="1331" endline="1346"><![CDATA[
 
         void ClassBody()
         {
             Expect(96);
             while (StartOf(9))
             {
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 Modifiers m = new Modifiers(this);
                 ModifierList(m);
                 ClassMemberDeclaration(m);
             }
             while (StartOf(9))
             {
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 Modifiers m = new Modifiers(this);
                 ModifierList(m);
                 ClassMemberDeclaration(m);
             }
             Expect(111);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="1347" endline="1362"><![CDATA[
 
         void StructBody()
         {
             Expect(96);
             while (StartOf(10))
             {
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 Modifiers m = new Modifiers(this);
                 ModifierList(m);
                 StructMemberDeclaration(m);
             }
             while (StartOf(10))
             {
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 Modifiers m = new Modifiers(this);
                 ModifierList(m);
                 StructMemberDeclaration(m);
             }
             Expect(111);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="1363" endline="1429"><![CDATA[
 
         void InterfaceMemberDeclaration()
         {
             Modifiers m = new Modifiers(this);
             TypeKind dummy;
 
             while (la.kind == 97)
             {
                 Attributes();
             }
             while (la.kind == 97)
             {
                 Attributes();
             }
             if (la.kind == 46)
             {
                 Get();
             }
             if (StartOf(11))
             {
                 Type(out dummy, true);
                 if (la.kind == 1)
                 {
                     Get();
                     if (la.kind == 98 || la.kind == 100)
                     {
                         if (la.kind == 100)
                         {
                             TypeParameterList();
                         }
                         Expect(98);
                         if (StartOf(7))
                         {
                             FormalParameterList();
                         }
                         Expect(113);
                         while (la.kind == 1)
                         {
                             TypeParameterConstraintsClause();
                         }
                         while (la.kind == 1)
                         {
                             TypeParameterConstraintsClause();
                         }
                         Expect(114);
                     }
                     else if (la.kind == 96)
                     {
                         Get();
                         InterfaceAccessors(m);
                         Expect(111);
                     }
                     else SynErr(136);
                 }
                 else if (la.kind == 68)
                 {
                     Get();
                     Expect(97);
                     FormalParameterList();
                     Expect(112);
                     Expect(96);
                     InterfaceAccessors(m);
                     Expect(111);
                 }
                 else SynErr(137);
             }
             else if (la.kind == 26)
             {
                 Get();
                 Type(out dummy, false);
                 Expect(1);
                 Expect(114);
             }
             else SynErr(138);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="1430" endline="1482"><![CDATA[
 
         void IntegralType()
         {
             switch (la.kind)
             {
                 case 59
                     {
                         Get();
                         break;
                     }
                 case 11
                     {
                         Get();
                         break;
                     }
                 case 61
                     {
                         Get();
                         break;
                     }
                 case 77
                     {
                         Get();
                         break;
                     }
                 case 39
                     {
                         Get();
                         break;
                     }
                 case 73
                     {
                         Get();
                         break;
                     }
                 case 44
                     {
                         Get();
                         break;
                     }
                 case 74
                     {
                         Get();
                         break;
                     }
                 case 14
                     {
                         Get();
                         break;
                     }
                 default
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="1483" endline="1501"><![CDATA[
 
         void EnumBody()
         {
             Expect(96);
             if (la.kind == 1 || la.kind == 97)
             {
                 EnumMemberDeclaration();
                 while (NotFinalComma())
                 {
                     Expect(87);
                     EnumMemberDeclaration();
                 }
                 while (NotFinalComma())
                 {
                     Expect(87);
                     EnumMemberDeclaration();
                 }
                 if (la.kind == 87)
                 {
                     Get();
                 }
             }
             Expect(111);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="1502" endline="1527"><![CDATA[
 
         void Type(out TypeKind type, bool voidAllowed)
         {
             type = TypeKind.simple;
             if (StartOf(12))
             {
                 PrimitiveType();
             }
             else if (la.kind == 1 || la.kind == 48 || la.kind == 65)
             {
                 ClassType();
             }
             else if (la.kind == 80)
             {
                 Get();
                 type = TypeKind.@void;
             }
             else SynErr(140);
             if (la.kind == 110)
             {
                 Get();
                 if (type == TypeKind.@void) { Error("Unexpected token ?, void must not be nullable."); }
             }
             PointerOrArray(ref type);
             if (type == TypeKind.@void && !voidAllowed) { Error("type expected, void found, maybe you mean void*"); }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="1528" endline="1566"><![CDATA[
 
         void FormalParameterList()
         {
             TypeKind type;
             while (la.kind == 97)
             {
                 Attributes();
             }
             while (la.kind == 97)
             {
                 Attributes();
             }
             if (StartOf(13))
             {
                 if (la.kind == 50 || la.kind == 57)
                 {
                     if (la.kind == 57)
                     {
                         Get();
                     }
                     else
                     {
                         Get();
                     }
                 }
                 Type(out type, false);
                 Expect(1);
                 if (la.kind == 87)
                 {
                     Get();
                     this.m_Current += ", " + la.val;
                     FormalParameterList();
                 }
             }
             else if (la.kind == 52)
             {
                 Get();
                 Type(out type, false);
                 if (type != TypeKind.array) { Error("params argument must be an array"); }
                 Expect(1);
             }
             else SynErr(141);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="1567" endline="1579"><![CDATA[
 
         void ClassType()
         {
             if (la.kind == 1)
             {
                 TypeName();
             }
             else if (la.kind == 48 || la.kind == 65)
             {
                 InternalClassType();
             }
             else SynErr(142);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="1580" endline="1604"><![CDATA[
 
         void ClassMemberDeclaration(Modifiers m)
         {
             if (StartOf(14))
             {
                 StructMemberDeclaration(m);
             }
             else if (la.kind == 115)
             {
                 Get();
                 Expect(1);
                 Expect(98);
                 Expect(113);
                 if (la.kind == 96)
                 {
                     Block();
                 }
                 else if (la.kind == 114)
                 {
                     Get();
                 }
                 else SynErr(143);
             }
             else SynErr(144);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="1605" endline="1876"><![CDATA[
 
         void StructMemberDeclaration(Modifiers m)
         {
             TypeKind type; Operator op;
             string dataType = la.val;
             if (la.kind == 17)
             {
                 TokenMatch tm = new TokenMatch();
                 m.Check(Modifier.constants);
                 Get();
                 dataType = la.val;
                 Type(out type, false);
                 tm.Position = la.pos;
                 tm.Value = la.val + "
                 Expect(1);
                 tm.Value += " = ";
                 Expect(85);
                 tm.Value += la.val;
                 Expression();
                 while (la.kind == 87)
                 {
                     Get();
                     Expect(1);
                     Expect(85);
                     Expression();
                 }
                 while (la.kind == 87)
                 {
                     Get();
                     Expect(1);
                     Expect(85);
                     Expression();
                 }
                 Expect(114);
                 this.m_CodeInfo.Fields.Add(tm);
             }
             else if (la.kind == 26)
             {
                 m.Check(Modifier.propEvntMeths);
                 Get();
                 Type(out type, false);
                 if (IsFieldDecl())
                 {
                     VariableDeclarators();
                     Expect(114);
                 }
                 else if (la.kind == 1)
                 {
                     TypeName();
                     Expect(96);
                     EventAccessorDeclarations();
                     Expect(111);
                 }
                 else SynErr(145);
             }
             else if (la.kind == _ident && Peek(1).kind == _lpar)
             {
                 TokenMatch tm = new TokenMatch(la.val, la.pos);
                 this.m_Current = "(";
                 m.Check(Modifier.constructors | Modifier.staticConstr);
                 Expect(1);
                 Expect(98);
                 this.m_Current += la.val;
                 if (StartOf(7))
                 {
                     m.Check(Modifier.constructors);
                     FormalParameterList();
                 }
                 Expect(113);
                 if (!this.m_Current.Equals("()"))
                 {
                     this.m_Current += ")";
                 }
                 tm.Value += this.m_Current;
                 this.m_CodeInfo.Constructors.Add(tm);
                 if (la.kind == 86)
                 {
                     m.Check(Modifier.constructors);
                     Get();
                     if (la.kind == 8)
                     {
                         Get();
                     }
                     else if (la.kind == 68)
                     {
                         Get();
                     }
                     else SynErr(146);
                     Expect(98);
                     if (StartOf(15))
                     {
                         Argument();
                         while (la.kind == 87)
                         {
                             Get();
                             Argument();
                         }
                         while (la.kind == 87)
                         {
                             Get();
                             Argument();
                         }
                     }
                     Expect(113);
                 }
                 if (la.kind == 96)
                 {
                     Block();
                 }
                 else if (la.kind == 114)
                 {
                     Get();
                 }
                 else SynErr(147);
             }
             else if (StartOf(11))
             {
                 Type(out type, true);
                 if (la.kind == 49)
                 {
                     m.Check(Modifier.operators);
                     m.CheckMust(Modifier.operatorsMust);
                     if (type == TypeKind.@void) { Error("operator not allowed on void"); }
 
                     Get();
                     OverloadableOp(out op);
                     Expect(98);
                     Type(out type, false);
                     Expect(1);
                     if (la.kind == 87)
                     {
                         Get();
                         Type(out type, false);
                         Expect(1);
                         if ((op & Operator.binary) == 0) Error("too many operands for unary operator");
                     }
                     else if (la.kind == 113)
                     {
                         if ((op & Operator.unary) == 0) Error("too few operands for binary operator");
                     }
                     else SynErr(148);
                     Expect(113);
                     if (la.kind == 96)
                     {
                         Block();
                     }
                     else if (la.kind == 114)
                     {
                         Get();
                     }
                     else SynErr(149);
                 }
                 else if (IsFieldDecl())
                 {
                     m.Check(Modifier.fields);
                     if (type == TypeKind.@void) { Error("field type must not be void"); }
 
                     this.m_CodeInfo.Fields.Add(new TokenMatch(la.val + "
                     VariableDeclarators();
                     Expect(114);
                 }
                 else if (la.kind == 1)
                 {
                     TokenMatch tm = new TokenMatch(la.val, la.pos);
                     //this.m_CodeInfo.Methods.Add(new TokenMatch(la.val + "
                     MemberName();
                     if (la.kind == 96)
                     {
                         m.Check(Modifier.propEvntMeths);
                         if (type == TypeKind.@void) { Error("property type must not be void"); }
 
                         this.m_Current = "(";
                         Get();
                         AccessorDeclarations(m);
                         Expect(111);
                         this.m_Current += ")";
 
                         tm.Value += this.m_Current;
                         tm.Value += "
                         this.m_CodeInfo.Properties.Add(tm);
                     }
                     else if (la.kind == 90)
                     {
                         m.Check(Modifier.indexers);
                         if (type == TypeKind.@void) { Error("indexer type must not be void"); }
 
                         Get();
                         Expect(68);
                         Expect(97);
                         FormalParameterList();
                         Expect(112);
                         Expect(96);
                         AccessorDeclarations(m);
                         Expect(111);
                     }
                     else if (la.kind == 98 || la.kind == 100)
                     {
                         m.Check(Modifier.propEvntMeths);
                         if (la.kind == 100)
                         {
                             TypeParameterList();
                         }
                         Expect(98);
                         this.m_Current = "(" + la.val;
                         if (StartOf(7))
                         {
                             FormalParameterList();
                         }
                         if (!this.m_Current.Equals("()"))
                         {
                             this.m_Current += ")";
                         }
                         tm.Value += this.m_Current;
                         Expect(113);
                         while (la.kind == 1)
                         {
                             TypeParameterConstraintsClause();
                         }
                         while (la.kind == 1)
                         {
                             TypeParameterConstraintsClause();
                         }
                         if (la.kind == 96)
                         {
                             Block();
                         }
                         else if (la.kind == 114)
                         {
                             Get();
                         }
                         else SynErr(150);
 
                         tm.Value += "
                         this.m_CodeInfo.Methods.Add(tm);
                     }
                     else SynErr(151);
                 }
                 else if (la.kind == 68)
                 {
                     m.Check(Modifier.indexers);
                     if (type == TypeKind.@void) { Error("indexer type must not be void"); }
 
                     Get();
                     Expect(97);
                     FormalParameterList();
                     Expect(112);
                     Expect(96);
                     AccessorDeclarations(m);
                     Expect(111);
                 }
                 else SynErr(152);
             }
             else if (la.kind == 27 || la.kind == 37)
             {
                 m.Check(Modifier.operators);
                 m.CheckMust(Modifier.operatorsMust);
 
                 if (la.kind == 37)
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                 }
                 Expect(49);
                 Type(out type, false);
                 if (type == TypeKind.@void) { Error("cast type must not be void"); }
                 Expect(98);
                 Type(out type, false);
                 Expect(1);
                 Expect(113);
                 if (la.kind == 96)
                 {
                     Block();
                 }
                 else if (la.kind == 114)
                 {
                     Get();
                 }
                 else SynErr(153);
             }
             else if (StartOf(16))
             {
                 TypeDeclaration(m);
             }
             else SynErr(154);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="1877" endline="1890"><![CDATA[
 
         void EnumMemberDeclaration()
         {
             while (la.kind == 97)
             {
                 Attributes();
             }
             while (la.kind == 97)
             {
                 Attributes();
             }
             Expect(1);
             if (la.kind == 85)
             {
                 Get();
                 Expression();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="1891" endline="1900"><![CDATA[
 
         void Block()
         {
             Expect(96);
             while (StartOf(17))
             {
                 Statement();
             }
             while (StartOf(17))
             {
                 Statement();
             }
             Expect(111);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="1901" endline="1922"><![CDATA[
 
         void Expression()
         {
             Unary();
             if (assgnOps[la.kind] || (la.kind == _gt && Peek(1).kind == _gteq))
             {
                 AssignmentOperator();
                 Expression();
             }
             else if (StartOf(18))
             {
                 NullCoalescingExpr();
                 if (la.kind == 110)
                 {
                     Get();
                     Expression();
                     Expect(86);
                     Expression();
                 }
             }
             else SynErr(155);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="1923" endline="1942"><![CDATA[
 
         void VariableDeclarators()
         {
             Expect(1);
             if (la.kind == 85)
             {
                 Get();
                 VariableInitializer();
             }
             while (la.kind == 87)
             {
                 Get();
                 Expect(1);
                 if (la.kind == 85)
                 {
                     Get();
                     VariableInitializer();
                 }
             }
             while (la.kind == 87)
             {
                 Get();
                 Expect(1);
                 if (la.kind == 85)
                 {
                     Get();
                     VariableInitializer();
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="1943" endline="1992"><![CDATA[
 
         void EventAccessorDeclarations()
         {
             bool addFound = false, remFound = false;
             while (la.kind == 97)
             {
                 Attributes();
             }
             while (la.kind == 97)
             {
                 Attributes();
             }
             if ("add".Equals(la.val))
             {
                 Expect(1);
                 addFound = true;
             }
             else if ("remove".Equals(la.val))
             {
                 Expect(1);
                 remFound = true;
             }
             else if (la.kind == 1)
             {
                 Get();
                 Error("add or remove expected");
             }
             else SynErr(156);
             Block();
             if (la.kind == 1 || la.kind == 97)
             {
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 if ("add".Equals(la.val))
                 {
                     Expect(1);
                     if (addFound) Error("add already declared");
                 }
                 else if ("remove".Equals(la.val))
                 {
                     Expect(1);
                     if (remFound) Error("remove already declared");
                 }
                 else if (la.kind == 1)
                 {
                     Get();
                     Error("add or remove expected");
                 }
                 else SynErr(157);
                 Block();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="1993" endline="2008"><![CDATA[
 
         void Argument()
         {
             if (la.kind == 50 || la.kind == 57)
             {
                 if (la.kind == 57)
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                 }
             }
             Expression();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="2009" endline="2148"><![CDATA[
 
         void OverloadableOp(out Operator op)
         {
             op = Operator.plus;
             switch (la.kind)
             {
                 case 108
                     {
                         Get();
                         break;
                     }
                 case 102
                     {
                         Get();
                         op = Operator.minus;
                         break;
                     }
                 case 106
                     {
                         Get();
                         op = Operator.not;
                         break;
                     }
                 case 115
                     {
                         Get();
                         op = Operator.tilde;
                         break;
                     }
                 case 95
                     {
                         Get();
                         op = Operator.inc;
                         break;
                     }
                 case 88
                     {
                         Get();
                         op = Operator.dec;
                         break;
                     }
                 case 70
                     {
                         Get();
                         op = Operator.@true;
                         break;
                     }
                 case 29
                     {
                         Get();
                         op = Operator.@false;
                         break;
                     }
                 case 116
                     {
                         Get();
                         op = Operator.times;
                         break;
                     }
                 case 127
                     {
                         Get();
                         op = Operator.div;
                         break;
                     }
                 case 128
                     {
                         Get();
                         op = Operator.mod;
                         break;
                     }
                 case 83
                     {
                         Get();
                         op = Operator.and;
                         break;
                     }
                 case 124
                     {
                         Get();
                         op = Operator.or;
                         break;
                     }
                 case 125
                     {
                         Get();
                         op = Operator.xor;
                         break;
                     }
                 case 101
                     {
                         Get();
                         op = Operator.lshift;
                         break;
                     }
                 case 92
                     {
                         Get();
                         op = Operator.eq;
                         break;
                     }
                 case 105
                     {
                         Get();
                         op = Operator.neq;
                         break;
                     }
                 case 93
                     {
                         Get();
                         op = Operator.gt;
                         if (la.kind == 93)
                         {
                             if (la.pos > t.pos + 1) Error("no whitespace allowed in right shift operator");
                             Get();
                             op = Operator.rshift;
                         }
                         break;
                     }
                 case 100
                     {
                         Get();
                         op = Operator.lt;
                         break;
                     }
                 case 94
                     {
                         Get();
                         op = Operator.gte;
                         break;
                     }
                 case 126
                     {
                         Get();
                         op = Operator.lte;
                         break;
                     }
                 default
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="2149" endline="2171"><![CDATA[
 
         void MemberName()
         {
             Expect(1);
             if (la.kind == 91)
             {
                 Get();
                 Expect(1);
             }
             if (la.kind == _lt && IsPartOfMemberName())
             {
                 TypeArgumentList();
             }
             while (la.kind == _dot && Peek(1).kind == _ident)
             {
                 Expect(90);
                 Expect(1);
                 if (la.kind == _lt && IsPartOfMemberName())
                 {
                     TypeArgumentList();
                 }
             }
             while (la.kind == _dot && Peek(1).kind == _ident)
             {
                 Expect(90);
                 Expect(1);
                 if (la.kind == _lt && IsPartOfMemberName())
                 {
                     TypeArgumentList();
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="2172" endline="2254"><![CDATA[
 
         void AccessorDeclarations(Modifiers m)
         {
             Modifiers am = new Modifiers(this);
             bool getFound = false, setFound = false;
 
             while (la.kind == 97)
             {
                 Attributes();
             }
             while (la.kind == 97)
             {
                 Attributes();
             }
             ModifierList(am);
             am.Check(Modifier.accessorsPossib1, Modifier.accessorsPossib2);
             if ("get".Equals(la.val))
             {
                 if (!this.m_Current.Equals("("))
                 {
                     this.m_Current += ", ";
                 }
                 this.m_Current += "get";
                 Expect(1);
                 getFound = true;
             }
             else if ("set".Equals(la.val))
             {
                 if (!this.m_Current.Equals("("))
                 {
                     this.m_Current += ", ";
                 }
                 this.m_Current += "set";
                 Expect(1);
                 setFound = true;
             }
             else if (la.kind == 1)
             {
                 Get();
                 Error("set or get expected");
             }
             else SynErr(159);
             if (la.kind == 96)
             {
                 Block();
             }
             else if (la.kind == 114)
             {
                 Get();
             }
             else SynErr(160);
             if (StartOf(19))
             {
                 am = new Modifiers(this);
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 ModifierList(am);
                 am.Check(Modifier.accessorsPossib1, Modifier.accessorsPossib2);
                 if ("get".Equals(la.val))
                 {
                     Expect(1);
                     if (getFound) Error("get already declared");
                 }
                 else if ("set".Equals(la.val))
                 {
                     Expect(1);
                     if (setFound) Error("set already declared");
                 }
                 else if (la.kind == 1)
                 {
                     Get();
                     Error("set or get expected");
                 }
                 else SynErr(161);
                 if (la.kind == 96)
                 {
                     Block();
                 }
                 else if (la.kind == 114)
                 {
                     Get();
                 }
                 else SynErr(162);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="2255" endline="2304"><![CDATA[
 
         void InterfaceAccessors(Modifiers m)
         {
             bool getFound = false, setFound = false;
             while (la.kind == 97)
             {
                 Attributes();
             }
             while (la.kind == 97)
             {
                 Attributes();
             }
             if ("get".Equals(la.val))
             {
                 Expect(1);
                 getFound = true;
             }
             else if ("set".Equals(la.val))
             {
                 Expect(1);
                 setFound = true;
             }
             else if (la.kind == 1)
             {
                 Get();
                 Error("set or get expected");
             }
             else SynErr(163);
             Expect(114);
             if (la.kind == 1 || la.kind == 97)
             {
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 if ("get".Equals(la.val))
                 {
                     Expect(1);
                     if (getFound) Error("get already declared");
                 }
                 else if ("set".Equals(la.val))
                 {
                     Expect(1);
                     if (setFound) Error("set already declared");
                 }
                 else if (la.kind == 1)
                 {
                     Get();
                     Error("set or get expected");
                 }
                 else SynErr(164);
                 Expect(114);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="2305" endline="2316"><![CDATA[
 
         void LocalVariableDeclaration()
         {
             TypeKind dummy;
             Type(out dummy, false);
             LocalVariableDeclarator();
             while (la.kind == 87)
             {
                 Get();
                 LocalVariableDeclarator();
             }
             while (la.kind == 87)
             {
                 Get();
                 LocalVariableDeclarator();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="2317" endline="2339"><![CDATA[
 
         void LocalVariableDeclarator()
         {
             TypeKind dummy;
             Expect(1);
             if (la.kind == 85)
             {
                 Get();
                 if (StartOf(20))
                 {
                     VariableInitializer();
                 }
                 else if (la.kind == 63)
                 {
                     Get();
                     Type(out dummy, false);
                     Expect(97);
                     Expression();
                     Expect(112);
                 }
                 else SynErr(165);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="2340" endline="2352"><![CDATA[
 
         void VariableInitializer()
         {
             if (StartOf(21))
             {
                 Expression();
             }
             else if (la.kind == 96)
             {
                 ArrayInitializer();
             }
             else SynErr(166);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="2353" endline="2371"><![CDATA[
 
         void ArrayInitializer()
         {
             Expect(96);
             if (StartOf(20))
             {
                 VariableInitializer();
                 while (NotFinalComma())
                 {
                     Expect(87);
                     VariableInitializer();
                 }
                 while (NotFinalComma())
                 {
                     Expect(87);
                     VariableInitializer();
                 }
                 if (la.kind == 87)
                 {
                     Get();
                 }
             }
             Expect(111);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="2372" endline="2380"><![CDATA[
 
         void Attribute()
         {
             TypeName();
             if (la.kind == 98)
             {
                 AttributeArguments();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="2381" endline="2773"><![CDATA[
 
         void Keyword()
         {
             switch (la.kind)
             {
                 case 6
                     {
                         Get();
                         break;
                     }
                 case 7
                     {
                         Get();
                         break;
                     }
                 case 8
                     {
                         Get();
                         break;
                     }
                 case 9
                     {
                         Get();
                         break;
                     }
                 case 10
                     {
                         Get();
                         break;
                     }
                 case 11
                     {
                         Get();
                         break;
                     }
                 case 12
                     {
                         Get();
                         break;
                     }
                 case 13
                     {
                         Get();
                         break;
                     }
                 case 14
                     {
                         Get();
                         break;
                     }
                 case 15
                     {
                         Get();
                         break;
                     }
                 case 16
                     {
                         Get();
                         break;
                     }
                 case 17
                     {
                         Get();
                         break;
                     }
                 case 18
                     {
                         Get();
                         break;
                     }
                 case 19
                     {
                         Get();
                         break;
                     }
                 case 20
                     {
                         Get();
                         break;
                     }
                 case 21
                     {
                         Get();
                         break;
                     }
                 case 22
                     {
                         Get();
                         break;
                     }
                 case 23
                     {
                         Get();
                         break;
                     }
                 case 24
                     {
                         Get();
                         break;
                     }
                 case 25
                     {
                         Get();
                         break;
                     }
                 case 26
                     {
                         Get();
                         break;
                     }
                 case 27
                     {
                         Get();
                         break;
                     }
                 case 28
                     {
                         Get();
                         break;
                     }
                 case 29
                     {
                         Get();
                         break;
                     }
                 case 30
                     {
                         Get();
                         break;
                     }
                 case 31
                     {
                         Get();
                         break;
                     }
                 case 32
                     {
                         Get();
                         break;
                     }
                 case 33
                     {
                         Get();
                         break;
                     }
                 case 34
                     {
                         Get();
                         break;
                     }
                 case 35
                     {
                         Get();
                         break;
                     }
                 case 36
                     {
                         Get();
                         break;
                     }
                 case 37
                     {
                         Get();
                         break;
                     }
                 case 38
                     {
                         Get();
                         break;
                     }
                 case 39
                     {
                         Get();
                         break;
                     }
                 case 40
                     {
                         Get();
                         break;
                     }
                 case 41
                     {
                         Get();
                         break;
                     }
                 case 42
                     {
                         Get();
                         break;
                     }
                 case 43
                     {
                         Get();
                         break;
                     }
                 case 44
                     {
                         Get();
                         break;
                     }
                 case 45
                     {
                         Get();
                         break;
                     }
                 case 46
                     {
                         Get();
                         break;
                     }
                 case 47
                     {
                         Get();
                         break;
                     }
                 case 48
                     {
                         Get();
                         break;
                     }
                 case 49
                     {
                         Get();
                         break;
                     }
                 case 50
                     {
                         Get();
                         break;
                     }
                 case 51
                     {
                         Get();
                         break;
                     }
                 case 52
                     {
                         Get();
                         break;
                     }
                 case 53
                     {
                         Get();
                         break;
                     }
                 case 54
                     {
                         Get();
                         break;
                     }
                 case 55
                     {
                         Get();
                         break;
                     }
                 case 56
                     {
                         Get();
                         break;
                     }
                 case 57
                     {
                         Get();
                         break;
                     }
                 case 58
                     {
                         Get();
                         break;
                     }
                 case 59
                     {
                         Get();
                         break;
                     }
                 case 60
                     {
                         Get();
                         break;
                     }
                 case 61
                     {
                         Get();
                         break;
                     }
                 case 62
                     {
                         Get();
                         break;
                     }
                 case 63
                     {
                         Get();
                         break;
                     }
                 case 64
                     {
                         Get();
                         break;
                     }
                 case 65
                     {
                         Get();
                         break;
                     }
                 case 66
                     {
                         Get();
                         break;
                     }
                 case 67
                     {
                         Get();
                         break;
                     }
                 case 68
                     {
                         Get();
                         break;
                     }
                 case 69
                     {
                         Get();
                         break;
                     }
                 case 70
                     {
                         Get();
                         break;
                     }
                 case 71
                     {
                         Get();
                         break;
                     }
                 case 72
                     {
                         Get();
                         break;
                     }
                 case 73
                     {
                         Get();
                         break;
                     }
                 case 74
                     {
                         Get();
                         break;
                     }
                 case 75
                     {
                         Get();
                         break;
                     }
                 case 76
                     {
                         Get();
                         break;
                     }
                 case 77
                     {
                         Get();
                         break;
                     }
                 case 78
                     {
                         Get();
                         break;
                     }
                 case 79
                     {
                         Get();
                         break;
                     }
                 case 80
                     {
                         Get();
                         break;
                     }
                 case 81
                     {
                         Get();
                         break;
                     }
                 case 82
                     {
                         Get();
                         break;
                     }
                 default
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="2774" endline="2806"><![CDATA[
 
         void AttributeArguments()
         {
             bool nameFound = false;
             Expect(98);
             if (StartOf(21))
             {
                 if (IsAssignment())
                 {
                     nameFound = true;
                     Expect(1);
                     Expect(85);
                 }
                 Expression();
                 while (la.kind == 87)
                 {
                     Get();
                     if (IsAssignment())
                     {
                         nameFound = true;
                         Expect(1);
                         Expect(85);
                     }
                     else if (StartOf(21))
                     {
                         if (nameFound) Error("no positional argument after named arguments");
                     }
                     else SynErr(168);
                     Expression();
                 }
                 while (la.kind == 87)
                 {
                     Get();
                     if (IsAssignment())
                     {
                         nameFound = true;
                         Expect(1);
                         Expect(85);
                     }
                     else if (StartOf(21))
                     {
                         if (nameFound) Error("no positional argument after named arguments");
                     }
                     else SynErr(168);
                     Expression();
                 }
             }
             Expect(113);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="2807" endline="2831"><![CDATA[
 
         void PrimitiveType()
         {
             if (StartOf(22))
             {
                 IntegralType();
             }
             else if (la.kind == 32)
             {
                 Get();
             }
             else if (la.kind == 23)
             {
                 Get();
             }
             else if (la.kind == 19)
             {
                 Get();
             }
             else if (la.kind == 9)
             {
                 Get();
             }
             else SynErr(169);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="2832" endline="2855"><![CDATA[
 
         void PointerOrArray(ref TypeKind type)
         {
             while (IsPointerOrDims())
             {
                 if (la.kind == 116)
                 {
                     Get();
                     type = TypeKind.pointer;
                 }
                 else if (la.kind == 97)
                 {
                     Get();
                     while (la.kind == 87)
                     {
                         Get();
                     }
                     while (la.kind == 87)
                     {
                         Get();
                     }
                     this.m_Current += "[]";
                     Expect(112);
                     type = TypeKind.array;
                 }
                 else SynErr(170);
             }
             while (IsPointerOrDims())
             {
                 if (la.kind == 116)
                 {
                     Get();
                     type = TypeKind.pointer;
                 }
                 else if (la.kind == 97)
                 {
                     Get();
                     while (la.kind == 87)
                     {
                         Get();
                     }
                     this.m_Current += "[]";
                     Expect(112);
                     type = TypeKind.array;
                 }
                 else SynErr(170);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="2856" endline="2902"><![CDATA[
 
         void ResolvedType()
         {
             TypeKind type = TypeKind.simple;
             if (StartOf(12))
             {
                 PrimitiveType();
             }
             else if (la.kind == 48)
             {
                 Get();
             }
             else if (la.kind == 65)
             {
                 Get();
             }
             else if (la.kind == 1)
             {
                 Get();
                 if (la.kind == 91)
                 {
                     Get();
                     Expect(1);
                 }
                 if (IsGeneric())
                 {
                     TypeArgumentList();
                 }
                 while (la.kind == 90)
                 {
                     Get();
                     Expect(1);
                     if (IsGeneric())
                     {
                         TypeArgumentList();
                     }
                 }
                 while (la.kind == 90)
                 {
                     Get();
                     Expect(1);
                     if (IsGeneric())
                     {
                         TypeArgumentList();
                     }
                 }
             }
             else if (la.kind == 80)
             {
                 Get();
                 type = TypeKind.@void;
             }
             else SynErr(171);
             PointerOrArray(ref type);
             if (type == TypeKind.@void) Error("type expected, void found, maybe you mean void*");
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="2903" endline="2921"><![CDATA[
 
         void TypeArgumentList()
         {
             TypeKind dummy;
             Expect(100);
             if (StartOf(11))
             {
                 Type(out dummy, false);
             }
             while (la.kind == 87)
             {
                 Get();
                 if (StartOf(11))
                 {
                     Type(out dummy, false);
                 }
             }
             while (la.kind == 87)
             {
                 Get();
                 if (StartOf(11))
                 {
                     Type(out dummy, false);
                 }
             }
             Expect(93);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="2922" endline="2934"><![CDATA[
 
         void InternalClassType()
         {
             if (la.kind == 48)
             {
                 Get();
             }
             else if (la.kind == 65)
             {
                 Get();
             }
             else SynErr(172);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="2935" endline="2971"><![CDATA[
 
         void Statement()
         {
             TypeKind dummy;
             if (la.kind == _ident && Peek(1).kind == _colon)
             {
                 Expect(1);
                 Expect(86);
                 Statement();
             }
             else if (la.kind == 17)
             {
                 Get();
                 Type(out dummy, false);
                 Expect(1);
                 Expect(85);
                 Expression();
                 while (la.kind == 87)
                 {
                     Get();
                     Expect(1);
                     Expect(85);
                     Expression();
                 }
                 while (la.kind == 87)
                 {
                     Get();
                     Expect(1);
                     Expect(85);
                     Expression();
                 }
                 Expect(114);
             }
             else if (IsLocalVarDecl())
             {
                 LocalVariableDeclaration();
                 Expect(114);
             }
             else if (StartOf(23))
             {
                 EmbeddedStatement();
             }
             else SynErr(173);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="2972" endline="3198"><![CDATA[
 
         void EmbeddedStatement()
         {
             TypeKind type;
             if (la.kind == 96)
             {
                 Block();
             }
             else if (la.kind == 114)
             {
                 Get();
             }
             else if (la.kind == _checked && Peek(1).kind == _lbrace)
             {
                 Expect(15);
                 Block();
             }
             else if (la.kind == _unchecked && Peek(1).kind == _lbrace)
             {
                 Expect(75);
                 Block();
             }
             else if (StartOf(21))
             {
                 StatementExpression();
                 Expect(114);
             }
             else if (la.kind == 36)
             {
                 Get();
                 Expect(98);
                 Expression();
                 Expect(113);
                 EmbeddedStatement();
                 if (la.kind == 24)
                 {
                     Get();
                     EmbeddedStatement();
                 }
             }
             else if (la.kind == 67)
             {
                 Get();
                 Expect(98);
                 Expression();
                 Expect(113);
                 Expect(96);
                 while (la.kind == 12 || la.kind == 20)
                 {
                     SwitchSection();
                 }
                 while (la.kind == 12 || la.kind == 20)
                 {
                     SwitchSection();
                 }
                 Expect(111);
             }
             else if (la.kind == 82)
             {
                 Get();
                 Expect(98);
                 Expression();
                 Expect(113);
                 EmbeddedStatement();
             }
             else if (la.kind == 22)
             {
                 Get();
                 EmbeddedStatement();
                 Expect(82);
                 Expect(98);
                 Expression();
                 Expect(113);
                 Expect(114);
             }
             else if (la.kind == 33)
             {
                 Get();
                 Expect(98);
                 if (StartOf(24))
                 {
                     ForInitializer();
                 }
                 Expect(114);
                 if (StartOf(21))
                 {
                     Expression();
                 }
                 Expect(114);
                 if (StartOf(21))
                 {
                     ForIterator();
                 }
                 Expect(113);
                 EmbeddedStatement();
             }
             else if (la.kind == 34)
             {
                 Get();
                 Expect(98);
                 Type(out type, false);
                 Expect(1);
                 Expect(38);
                 Expression();
                 Expect(113);
                 EmbeddedStatement();
             }
             else if (la.kind == 10)
             {
                 Get();
                 Expect(114);
             }
             else if (la.kind == 18)
             {
                 Get();
                 Expect(114);
             }
             else if (la.kind == 35)
             {
                 Get();
                 if (la.kind == 1)
                 {
                     Get();
                 }
                 else if (la.kind == 12)
                 {
                     Get();
                     Expression();
                 }
                 else if (la.kind == 20)
                 {
                     Get();
                 }
                 else SynErr(174);
                 Expect(114);
             }
             else if (la.kind == 58)
             {
                 Get();
                 if (StartOf(21))
                 {
                     Expression();
                 }
                 Expect(114);
             }
             else if (la.kind == 69)
             {
                 Get();
                 if (StartOf(21))
                 {
                     Expression();
                 }
                 Expect(114);
             }
             else if (la.kind == 71)
             {
                 Get();
                 Block();
                 if (la.kind == 13)
                 {
                     CatchClauses();
                     if (la.kind == 30)
                     {
                         Get();
                         Block();
                     }
                 }
                 else if (la.kind == 30)
                 {
                     Get();
                     Block();
                 }
                 else SynErr(175);
             }
             else if (la.kind == 43)
             {
                 Get();
                 Expect(98);
                 Expression();
                 Expect(113);
                 EmbeddedStatement();
             }
             else if (la.kind == 78)
             {
                 Get();
                 Expect(98);
                 ResourceAcquisition();
                 Expect(113);
                 EmbeddedStatement();
             }
             else if (la.kind == 120)
             {
                 Get();
                 if (la.kind == 58)
                 {
                     Get();
                     Expression();
                 }
                 else if (la.kind == 10)
                 {
                     Get();
                 }
                 else SynErr(176);
                 Expect(114);
             }
             else if (la.kind == 76)
             {
                 Get();
                 Block();
             }
             else if (la.kind == 31)
             {
                 Get();
                 Expect(98);
                 Type(out type, false);
                 if (type != TypeKind.pointer) Error("can only fix pointer types");
                 Expect(1);
                 Expect(85);
                 Expression();
                 while (la.kind == 87)
                 {
                     Get();
                     Expect(1);
                     Expect(85);
                     Expression();
                 }
                 while (la.kind == 87)
                 {
                     Get();
                     Expect(1);
                     Expect(85);
                     Expression();
                 }
                 Expect(113);
                 EmbeddedStatement();
             }
             else SynErr(177);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="3199" endline="3214"><![CDATA[
 
         void StatementExpression()
         {
             bool isAssignment = assnStartOp[la.kind] || IsTypeCast();
             Unary();
             if (StartOf(25))
             {
                 AssignmentOperator();
                 Expression();
             }
             else if (la.kind == 87 || la.kind == 113 || la.kind == 114)
             {
                 if (isAssignment) Error("error in assignment.");
             }
             else SynErr(178);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="3215" endline="3228"><![CDATA[
 
         void SwitchSection()
         {
             SwitchLabel();
             while (la.kind == _case || (la.kind == _default && Peek(1).kind == _colon))
             {
                 SwitchLabel();
             }
             while (la.kind == _case || (la.kind == _default && Peek(1).kind == _colon))
             {
                 SwitchLabel();
             }
             Statement();
             while (IsNoSwitchLabelOrRBrace())
             {
                 Statement();
             }
             while (IsNoSwitchLabelOrRBrace())
             {
                 Statement();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="3229" endline="3246"><![CDATA[
 
         void ForInitializer()
         {
             if (IsLocalVarDecl())
             {
                 LocalVariableDeclaration();
             }
             else if (StartOf(21))
             {
                 StatementExpression();
                 while (la.kind == 87)
                 {
                     Get();
                     StatementExpression();
                 }
                 while (la.kind == 87)
                 {
                     Get();
                     StatementExpression();
                 }
             }
             else SynErr(179);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="3247" endline="3256"><![CDATA[
 
         void ForIterator()
         {
             StatementExpression();
             while (la.kind == 87)
             {
                 Get();
                 StatementExpression();
             }
             while (la.kind == 87)
             {
                 Get();
                 StatementExpression();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="3257" endline="3281"><![CDATA[
 
         void CatchClauses()
         {
             Expect(13);
             if (la.kind == 96)
             {
                 Block();
             }
             else if (la.kind == 98)
             {
                 Get();
                 ClassType();
                 if (la.kind == 1)
                 {
                     Get();
                 }
                 Expect(113);
                 Block();
                 if (la.kind == 13)
                 {
                     CatchClauses();
                 }
             }
             else SynErr(180);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="3282" endline="3294"><![CDATA[
 
         void ResourceAcquisition()
         {
             if (IsLocalVarDecl())
             {
                 LocalVariableDeclaration();
             }
             else if (StartOf(21))
             {
                 Expression();
             }
             else SynErr(181);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="3295" endline="3354"><![CDATA[
 
         void Unary()
         {
             TypeKind dummy;
             while (unaryHead[la.kind] || IsTypeCast())
             {
                 switch (la.kind)
                 {
                     case 108
                         {
                             Get();
                             break;
                         }
                     case 102
                         {
                             Get();
                             break;
                         }
                     case 106
                         {
                             Get();
                             break;
                         }
                     case 115
                         {
                             Get();
                             break;
                         }
                     case 95
                         {
                             Get();
                             break;
                         }
                     case 88
                         {
                             Get();
                             break;
                         }
                     case 116
                         {
                             Get();
                             break;
                         }
                     case 83
                         {
                             Get();
                             break;
                         }
                     case 98
                         {
                             Get();
                             Type(out dummy, false);
                             Expect(113);
                             break;
                         }
                     default
                 }
             }
             while (unaryHead[la.kind] || IsTypeCast())
             {
                 switch (la.kind)
                 {
                     case 108
                         {
                             Get();
                             break;
                         }
                     case 102
                         {
                             Get();
                             break;
                         }
                     case 106
                         {
                             Get();
                             break;
                         }
                     case 115
                         {
                             Get();
                             break;
                         }
                     case 95
                         {
                             Get();
                             break;
                         }
                     case 88
                         {
                             Get();
                             break;
                         }
                     case 116
                         {
                             Get();
                             break;
                         }
                     case 83
                         {
                             Get();
                             break;
                         }
                     case 98
                         {
                             Get();
                             Type(out dummy, false);
                             Expect(113);
                             break;
                         }
                     default
                 }
             }
             Primary();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="3355" endline="3420"><![CDATA[
 
         void AssignmentOperator()
         {
             switch (la.kind)
             {
                 case 85
                     {
                         Get();
                         break;
                     }
                 case 109
                     {
                         Get();
                         break;
                     }
                 case 103
                     {
                         Get();
                         break;
                     }
                 case 117
                     {
                         Get();
                         break;
                     }
                 case 89
                     {
                         Get();
                         break;
                     }
                 case 104
                     {
                         Get();
                         break;
                     }
                 case 84
                     {
                         Get();
                         break;
                     }
                 case 107
                     {
                         Get();
                         break;
                     }
                 case 118
                     {
                         Get();
                         break;
                     }
                 case 99
                     {
                         Get();
                         break;
                     }
                 case 93
                     {
                         Get();
                         int pos = t.pos;
                         Expect(94);
                         if (pos + 1 < t.pos) Error("no whitespace allowed in right shift assignment");
                         break;
                     }
                 default
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="3421" endline="3436"><![CDATA[
 
         void SwitchLabel()
         {
             if (la.kind == 12)
             {
                 Get();
                 Expression();
                 Expect(86);
             }
             else if (la.kind == 20)
             {
                 Get();
                 Expect(86);
             }
             else SynErr(184);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="3437" endline="3447"><![CDATA[
 
         void NullCoalescingExpr()
         {
             OrExpr();
             while (la.kind == 121)
             {
                 Get();
                 Unary();
                 OrExpr();
             }
             while (la.kind == 121)
             {
                 Get();
                 Unary();
                 OrExpr();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="3448" endline="3458"><![CDATA[
 
         void OrExpr()
         {
             AndExpr();
             while (la.kind == 122)
             {
                 Get();
                 Unary();
                 AndExpr();
             }
             while (la.kind == 122)
             {
                 Get();
                 Unary();
                 AndExpr();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="3459" endline="3469"><![CDATA[
 
         void AndExpr()
         {
             BitOrExpr();
             while (la.kind == 123)
             {
                 Get();
                 Unary();
                 BitOrExpr();
             }
             while (la.kind == 123)
             {
                 Get();
                 Unary();
                 BitOrExpr();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="3470" endline="3480"><![CDATA[
 
         void BitOrExpr()
         {
             BitXorExpr();
             while (la.kind == 124)
             {
                 Get();
                 Unary();
                 BitXorExpr();
             }
             while (la.kind == 124)
             {
                 Get();
                 Unary();
                 BitXorExpr();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="3481" endline="3491"><![CDATA[
 
         void BitXorExpr()
         {
             BitAndExpr();
             while (la.kind == 125)
             {
                 Get();
                 Unary();
                 BitAndExpr();
             }
             while (la.kind == 125)
             {
                 Get();
                 Unary();
                 BitAndExpr();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="3492" endline="3502"><![CDATA[
 
         void BitAndExpr()
         {
             EqlExpr();
             while (la.kind == 83)
             {
                 Get();
                 Unary();
                 EqlExpr();
             }
             while (la.kind == 83)
             {
                 Get();
                 Unary();
                 EqlExpr();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="3503" endline="3520"><![CDATA[
 
         void EqlExpr()
         {
             RelExpr();
             while (la.kind == 92 || la.kind == 105)
             {
                 if (la.kind == 105)
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                 }
                 Unary();
                 RelExpr();
             }
             while (la.kind == 92 || la.kind == 105)
             {
                 if (la.kind == 105)
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                 }
                 Unary();
                 RelExpr();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="3521" endline="3563"><![CDATA[
 
         void RelExpr()
         {
             ShiftExpr();
             while (StartOf(26))
             {
                 if (StartOf(27))
                 {
                     if (la.kind == 100)
                     {
                         Get();
                     }
                     else if (la.kind == 93)
                     {
                         Get();
                     }
                     else if (la.kind == 126)
                     {
                         Get();
                     }
                     else if (la.kind == 94)
                     {
                         Get();
                     }
                     else SynErr(185);
                     Unary();
                     ShiftExpr();
                 }
                 else
                 {
                     if (la.kind == 42)
                     {
                         Get();
                     }
                     else if (la.kind == 7)
                     {
                         Get();
                     }
                     else SynErr(186);
                     ResolvedType();
                 }
             }
             while (StartOf(26))
             {
                 if (StartOf(27))
                 {
                     if (la.kind == 100)
                     {
                         Get();
                     }
                     else if (la.kind == 93)
                     {
                         Get();
                     }
                     else if (la.kind == 126)
                     {
                         Get();
                     }
                     else if (la.kind == 94)
                     {
                         Get();
                     }
                     else SynErr(185);
                     Unary();
                     ShiftExpr();
                 }
                 else
                 {
                     if (la.kind == 42)
                     {
                         Get();
                     }
                     else if (la.kind == 7)
                     {
                         Get();
                     }
                     else SynErr(186);
                     ResolvedType();
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="3564" endline="3583"><![CDATA[
 
         void ShiftExpr()
         {
             AddExpr();
             while (IsShift())
             {
                 if (la.kind == 101)
                 {
                     Get();
                 }
                 else if (la.kind == 93)
                 {
                     Get();
                     Expect(93);
                 }
                 else SynErr(187);
                 Unary();
                 AddExpr();
             }
             while (IsShift())
             {
                 if (la.kind == 101)
                 {
                     Get();
                 }
                 else if (la.kind == 93)
                 {
                     Get();
                     Expect(93);
                 }
                 else SynErr(187);
                 Unary();
                 AddExpr();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="3584" endline="3601"><![CDATA[
 
         void AddExpr()
         {
             MulExpr();
             while (la.kind == 102 || la.kind == 108)
             {
                 if (la.kind == 108)
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                 }
                 Unary();
                 MulExpr();
             }
             while (la.kind == 102 || la.kind == 108)
             {
                 if (la.kind == 108)
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                 }
                 Unary();
                 MulExpr();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="3602" endline="3621"><![CDATA[
 
         void MulExpr()
         {
             while (la.kind == 116 || la.kind == 127 || la.kind == 128)
             {
                 if (la.kind == 116)
                 {
                     Get();
                 }
                 else if (la.kind == 127)
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                 }
                 Unary();
             }
             while (la.kind == 116 || la.kind == 127 || la.kind == 128)
             {
                 if (la.kind == 116)
                 {
                     Get();
                 }
                 else if (la.kind == 127)
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                 }
                 Unary();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="3622" endline="3978"><![CDATA[
 
         void Primary()
         {
             TypeKind type; bool isArrayCreation = false;
             switch (la.kind)
             {
                 case 2
                 case 3
                 case 4
                 case 5
                 case 29
                 case 47
                 case 70
                     {
                         Literal();
                         break;
                     }
                 case 98
                     {
                         Get();
                         Expression();
                         Expect(113);
                         break;
                     }
                 case 9
                 case 11
                 case 14
                 case 19
                 case 23
                 case 32
                 case 39
                 case 44
                 case 48
                 case 59
                 case 61
                 case 65
                 case 73
                 case 74
                 case 77
                     {
                         switch (la.kind)
                         {
                             case 9
                                 {
                                     Get();
                                     break;
                                 }
                             case 11
                                 {
                                     Get();
                                     break;
                                 }
                             case 14
                                 {
                                     Get();
                                     break;
                                 }
                             case 19
                                 {
                                     Get();
                                     break;
                                 }
                             case 23
                                 {
                                     Get();
                                     break;
                                 }
                             case 32
                                 {
                                     Get();
                                     break;
                                 }
                             case 39
                                 {
                                     Get();
                                     break;
                                 }
                             case 44
                                 {
                                     Get();
                                     break;
                                 }
                             case 48
                                 {
                                     Get();
                                     break;
                                 }
                             case 59
                                 {
                                     Get();
                                     break;
                                 }
                             case 61
                                 {
                                     Get();
                                     break;
                                 }
                             case 65
                                 {
                                     Get();
                                     break;
                                 }
                             case 73
                                 {
                                     Get();
                                     break;
                                 }
                             case 74
                                 {
                                     Get();
                                     break;
                                 }
                             case 77
                                 {
                                     Get();
                                     break;
                                 }
                         }
                         Expect(90);
                         Expect(1);
                         if (IsGeneric())
                         {
                             TypeArgumentList();
                         }
                         break;
                     }
                 case 1
                     {
                         Get();
                         if (la.kind == 91)
                         {
                             Get();
                             Expect(1);
                             if (la.kind == 100)
                             {
                                 TypeArgumentList();
                             }
                             Expect(90);
                             Expect(1);
                         }
                         if (IsGeneric())
                         {
                             TypeArgumentList();
                         }
                         break;
                     }
                 case 68
                     {
                         Get();
                         break;
                     }
                 case 8
                     {
                         Get();
                         if (la.kind == 90)
                         {
                             Get();
                             Expect(1);
                             if (IsGeneric())
                             {
                                 TypeArgumentList();
                             }
                         }
                         else if (la.kind == 97)
                         {
                             Get();
                             Expression();
                             while (la.kind == 87)
                             {
                                 Get();
                                 Expression();
                             }
                             while (la.kind == 87)
                             {
                                 Get();
                                 Expression();
                             }
                             Expect(112);
                         }
                         else SynErr(188);
                         break;
                     }
                 case 46
                     {
                         Get();
                         Type(out type, false);
                         if (la.kind == 98)
                         {
                             Get();
                             if (StartOf(15))
                             {
                                 Argument();
                                 while (la.kind == 87)
                                 {
                                     Get();
                                     Argument();
                                 }
                                 while (la.kind == 87)
                                 {
                                     Get();
                                     Argument();
                                 }
                             }
                             Expect(113);
                         }
                         else if (la.kind == 97)
                         {
                             Get();
                             Expression();
                             while (la.kind == 87)
                             {
                                 Get();
                                 Expression();
                             }
                             while (la.kind == 87)
                             {
                                 Get();
                                 Expression();
                             }
                             Expect(112);
                             while (IsDims())
                             {
                                 Expect(97);
                                 while (la.kind == 87)
                                 {
                                     Get();
                                 }
                                 while (la.kind == 87)
                                 {
                                     Get();
                                 }
                                 Expect(112);
                             }
                             while (IsDims())
                             {
                                 Expect(97);
                                 while (la.kind == 87)
                                 {
                                     Get();
                                 }
                                 Expect(112);
                             }
                             if (la.kind == 96)
                             {
                                 ArrayInitializer();
                             }
                             isArrayCreation = true;
                         }
                         else if (la.kind == 96)
                         {
                             ArrayInitializer();
                             if (type != TypeKind.array) Error("array type expected");
                             isArrayCreation = true;
 
                         }
                         else SynErr(189);
                         break;
                     }
                 case 72
                     {
                         Get();
                         Expect(98);
                         Type(out type, true);
                         Expect(113);
                         break;
                     }
                 case 15
                     {
                         Get();
                         Expect(98);
                         Expression();
                         Expect(113);
                         break;
                     }
                 case 75
                     {
                         Get();
                         Expect(98);
                         Expression();
                         Expect(113);
                         break;
                     }
                 case 20
                     {
                         Get();
                         Expect(98);
                         Primary();
                         Expect(113);
                         break;
                     }
                 case 21
                     {
                         Get();
                         if (la.kind == 98)
                         {
                             Get();
                             if (StartOf(13))
                             {
                                 AnonymousMethodParameter();
                                 while (la.kind == 87)
                                 {
                                     Get();
                                     AnonymousMethodParameter();
                                 }
                                 while (la.kind == 87)
                                 {
                                     Get();
                                     AnonymousMethodParameter();
                                 }
                             }
                             Expect(113);
                         }
                         Block();
                         break;
                     }
                 case 62
                     {
                         Get();
                         Expect(98);
                         Type(out type, false);
                         Expect(113);
                         break;
                     }
                 default
             }
             while (StartOf(28))
             {
                 switch (la.kind)
                 {
                     case 95
                         {
                             Get();
                             break;
                         }
                     case 88
                         {
                             Get();
                             break;
                         }
                     case 129
                         {
                             Get();
                             Expect(1);
                             if (IsGeneric())
                             {
                                 TypeArgumentList();
                             }
                             break;
                         }
                     case 90
                         {
                             Get();
                             Expect(1);
                             if (IsGeneric())
                             {
                                 TypeArgumentList();
                             }
                             break;
                         }
                     case 98
                         {
                             Get();
                             if (StartOf(15))
                             {
                                 Argument();
                                 while (la.kind == 87)
                                 {
                                     Get();
                                     Argument();
                                 }
                                 while (la.kind == 87)
                                 {
                                     Get();
                                     Argument();
                                 }
                             }
                             Expect(113);
                             break;
                         }
                     case 97
                         {
                             if (isArrayCreation) Error("element access not allow on array creation");
                             Get();
                             Expression();
                             while (la.kind == 87)
                             {
                                 Get();
                                 Expression();
                             }
                             while (la.kind == 87)
                             {
                                 Get();
                                 Expression();
                             }
                             Expect(112);
                             break;
                         }
                 }
             }
             while (StartOf(28))
             {
                 switch (la.kind)
                 {
                     case 95
                         {
                             Get();
                             break;
                         }
                     case 88
                         {
                             Get();
                             break;
                         }
                     case 129
                         {
                             Get();
                             Expect(1);
                             if (IsGeneric())
                             {
                                 TypeArgumentList();
                             }
                             break;
                         }
                     case 90
                         {
                             Get();
                             Expect(1);
                             if (IsGeneric())
                             {
                                 TypeArgumentList();
                             }
                             break;
                         }
                     case 98
                         {
                             Get();
                             if (StartOf(15))
                             {
                                 Argument();
                                 while (la.kind == 87)
                                 {
                                     Get();
                                     Argument();
                                 }
                             }
                             Expect(113);
                             break;
                         }
                     case 97
                         {
                             if (isArrayCreation) Error("element access not allow on array creation");
                             Get();
                             Expression();
                             while (la.kind == 87)
                             {
                                 Get();
                                 Expression();
                             }
                             Expect(112);
                             break;
                         }
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="3979" endline="4021"><![CDATA[
 
         void Literal()
         {
             switch (la.kind)
             {
                 case 2
                     {
                         Get();
                         break;
                     }
                 case 3
                     {
                         Get();
                         break;
                     }
                 case 4
                     {
                         Get();
                         break;
                     }
                 case 5
                     {
                         Get();
                         break;
                     }
                 case 70
                     {
                         Get();
                         break;
                     }
                 case 29
                     {
                         Get();
                         break;
                     }
                 case 47
                     {
                         Get();
                         break;
                     }
                 default
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="4022" endline="4039"><![CDATA[
 
         void AnonymousMethodParameter()
         {
             TypeKind dummy;
             if (la.kind == 50 || la.kind == 57)
             {
                 if (la.kind == 57)
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                 }
             }
             Type(out dummy, false);
             Expect(1);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="4040" endline="4051"><![CDATA[
 
 
 
         public void Parse()
         {
             la = new Token();
             la.val = "";
             Get();
             CS2();
 
             Expect(0);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="295" endline="330"><![CDATA[
         static BitArray
           unaryOp = NewSet(_plus, _minus, _not, _tilde, _inc, _dec, _true, _false),
           typeKW = NewSet(_char, _bool, _object, _string, _sbyte, _byte, _short,
                          _ushort, _int, _uint, _long, _ulong, _float, _double, _decimal),
           unaryHead = NewSet(_plus, _minus, _not, _tilde, _times, _inc, _dec, _and),
           assnStartOp = NewSet(_plus, _minus, _not, _tilde, _times),
           castFollower = NewSet(_tilde, _not, _lpar, _ident,
             /* literals */
                          _intCon, _realCon, _charCon, _stringCon,
             /* any keyword expect as and is */
                          _abstract, _base, _bool, _break, _byte, _case, _catch,
                          _char, _checked, _class, _const, _continue, _decimal, _default,
                          _delegate, _do, _double, _else, _enum, _event, _explicit,
                          _extern, _false, _finally, _fixed, _float, _for, _foreach,
                          _goto, _if, _implicit, _in, _int, _interface, _internal,
                          _lock, _long, _namespace, _new, _null, _object, _operator,
                          _out, _override, _params, _private, _protected, _public,
                          _readonly, _ref, _return, _sbyte, _sealed, _short, _sizeof,
                          _stackalloc, _static, _string, _struct, _switch, _this, _throw,
                          _true, _try, _typeof, _uint, _ulong, _unchecked, _unsafe,
                          _ushort, _usingKW, _virtual, _void, _volatile, _while
                          ),
           typArgLstFol = NewSet(_lpar, _rpar, _rbrack, _colon, _scolon, _comma, _dot,
                          _question, _eq, _neq),
           keyword = NewSet(_abstract, _as, _base, _bool, _break, _byte, _case, _catch,
                          _char, _checked, _class, _const, _continue, _decimal, _default,
                          _delegate, _do, _double, _else, _enum, _event, _explicit,
                          _extern, _false, _finally, _fixed, _float, _for, _foreach,
                          _goto, _if, _implicit, _in, _int, _interface, _internal,
                          _is, _lock, _long, _namespace, _new, _null, _object, _operator,
                          _out, _override, _params, _private, _protected, _public,
                          _readonly, _ref, _return, _sbyte, _sealed, _short, _sizeof,
                          _stackalloc, _static, _string, _struct, _switch, _this, _throw,
                          _true, _try, _typeof, _uint, _ulong, _unchecked, _unsafe,
                          _ushort, _usingKW, _virtual, _void, _volatile, _while),
           assgnOps = NewSet(_assgn, _plusassgn, _minusassgn, _timesassgn, _divassgn,
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="331" endline="4296"><![CDATA[
                          _modassgn, _andassgn, _orassgn, _xorassgn, _lshassgn) /* rshassgn
                          ;
 
         /*---------------------------- auxiliary methods ------------------------*/
 
         void Error(string s)
         {
             if (errDist >= minErrDist) errors.SemErr(la.line, la.col, s);
             errDist = 0;
         }
 
         // Return the n-th token after the current lookahead token
         Token Peek(int n)
         {
             scanner.ResetPeek();
             Token x = la;
             while (n > 0) { x = scanner.Peek(); n--; }
             return x;
         }
 
         // ident "="
         bool IsAssignment()
         {
             return la.kind == _ident && Peek(1).kind == _assgn;
         }
 
         /* True, if the comma is not a trailing one, *
          * like the last one in
         bool NotFinalComma()
         {
             int peek = Peek(1).kind;
             return la.kind == _comma && peek != _rbrace && peek != _rbrack;
         }
 
         /* Checks whether the next sequence of tokens is a qualident *
          * and returns the qualident string                          *
          * !!! Proceeds from current peek position !!!               */
         bool IsQualident(ref Token pt, out string qualident)
         {
             qualident = "";
             if (pt.kind == _ident)
             {
                 qualident = pt.val;
                 pt = scanner.Peek();
                 while (pt.kind == _dot)
                 {
                     pt = scanner.Peek();
                     if (pt.kind != _ident) return false;
                     qualident += "." + pt.val;
                     pt = scanner.Peek();
                 }
                 return true;
             }
             else return false;
         }
 
         bool IsGeneric()
         {
             scanner.ResetPeek();
             Token pt = la;
             if (!IsTypeArgumentList(ref pt))
             {
                 return false;
             }
             return typArgLstFol[pt.kind];
         }
 
         bool IsTypeArgumentList(ref Token pt)
         {
             if (pt.kind == _lt)
             {
                 pt = scanner.Peek();
                 while (true)
                 {
                     if (!IsType(ref pt))
                     {
                         return false;
                     }
                     if (pt.kind == _gt)
                     {
                         // list recognized
                         pt = scanner.Peek();
                         break;
                     }
                     else if (pt.kind == _comma)
                     {
                         // another argument
                         pt = scanner.Peek();
                     }
                     else
                     {
                         // error in type argument list
                         return false;
                     }
                 }
             }
             else
             {
                 return false;
             }
             return true;
         }
 
         // Type
         bool IsType(ref Token pt)
         {
             String dummyId;
 
             if (typeKW[pt.kind])
             {
                 pt = scanner.Peek();
             }
             else if (pt.kind == _void)
             {
                 pt = scanner.Peek();
                 if (pt.kind != _times)
                 {
                     return false;
                 }
                 pt = scanner.Peek();
             }
             else if (pt.kind == _ident)
             {
                 pt = scanner.Peek();
                 if (pt.kind == _dblcolon || pt.kind == _dot)
                 {
                     // either namespace alias qualifier "
                     // part of the qualident
                     pt = scanner.Peek();
                     if (!IsQualident(ref pt, out dummyId))
                     {
                         return false;
                     }
                 }
                 if (pt.kind == _lt && !IsTypeArgumentList(ref pt))
                 {
                     return false;
                 }
             }
             else
             {
                 return false;
             }
             if (pt.kind == _question)
             {
                 pt = scanner.Peek();
             }
             return SkipPointerOrDims(ref pt);
         }
 
         // Type ident
         // (Type can be void*)
         bool IsLocalVarDecl()
         {
             Token pt = la;
             scanner.ResetPeek();
             return IsType(ref pt) && pt.kind == _ident;
         }
 
         // "[" ("," | "]")
         bool IsDims()
         {
             int peek = Peek(1).kind;
             return la.kind == _lbrack && (peek == _comma || peek == _rbrack);
         }
 
         // "*" | "[" ("," | "]")
         bool IsPointerOrDims()
         {
             return la.kind == _times || IsDims();
         }
 
         /* skip
         /* !!! Proceeds from current peek position !!! */
         bool SkipPointerOrDims(ref Token pt)
         {
             for (; ; )
             {
                 if (pt.kind == _lbrack)
                 {
                     do pt = scanner.Peek();
                     while (pt.kind == _comma);
                     if (pt.kind != _rbrack) return false;
                 }
                 else if (pt.kind != _times) break;
                 pt = scanner.Peek();
             }
             return true;
         }
 
         // Is attribute target specifier
         // (ident | keyword) "
         bool IsAttrTargSpec()
         {
             return (la.kind == _ident || keyword[la.kind]) && Peek(1).kind == _colon;
         }
 
         // ident ("," | "=" | ";")
         bool IsFieldDecl()
         {
             int peek = Peek(1).kind;
             return la.kind == _ident &&
                    (peek == _comma || peek == _assgn || peek == _scolon);
         }
 
         bool IsTypeCast()
         {
             if (la.kind != _lpar) { return false; }
             if (IsSimpleTypeCast()) { return true; }
             return GuessTypeCast();
         }
 
         // "(" typeKW ")"
         bool IsSimpleTypeCast()
         {
             // assert
             scanner.ResetPeek();
             Token pt1 = scanner.Peek();
             Token pt2 = scanner.Peek();
             return typeKW[pt1.kind] &&
                     (pt2.kind == _rpar ||
                     (pt2.kind == _question && scanner.Peek().kind == _rpar));
         }
 
         // "(" Type ")" castFollower
         bool GuessTypeCast()
         {
             // assert
             scanner.ResetPeek();
             Token pt = scanner.Peek();
             if (!IsType(ref pt))
             {
                 return false;
             }
             if (pt.kind != _rpar)
             {
                 return false;
             }
             pt = scanner.Peek();
             return castFollower[pt.kind];
         }
 
         // "[" "assembly"
         bool IsGlobalAttrTarget()
         {
             Token pt = Peek(1);
             return la.kind == _lbrack && pt.kind == _ident && ("assembly".Equals(pt.val) || "module".Equals(pt.val));
         }
 
         // "extern" "alias"
         // where alias is an identifier, no keyword
         bool IsExternAliasDirective()
         {
             return la.kind == _extern && "alias".Equals(Peek(1).val);
         }
 
         // true
         // no whitespace between the token and the "<" allowed
         // anything else will return false.
         bool IsLtNoWs()
         {
             return (la.kind == _lt) && ((t.pos + t.val.Length) == la.pos);
         }
 
         bool IsNoSwitchLabelOrRBrace()
         {
             return (la.kind != _case && la.kind != _default && la.kind != _rbrace) ||
                    (la.kind == _default && Peek(1).kind != _colon);
         }
 
         bool IsShift()
         {
             Token pt = Peek(1);
             return (la.kind == _ltlt) ||
                    (la.kind == _gt &&
                      pt.kind == _gt &&
                      (la.pos + la.val.Length == pt.pos)
                    );
         }
 
         // true
         bool IsPartOfMemberName()
         {
             scanner.ResetPeek();
             Token pt = la;
             if (!IsTypeArgumentList(ref pt))
             {
                 return false;
             }
             return pt.kind != _lpar;
         }
 
 
         enum TypeKind { simple, array, pointer, @void }
 
         [Flags]
         enum Operator
         {
             plus = 0x00000001, minus = 0x00000002, not = 0x00000004, tilde = 0x00000008,
             inc = 0x00000010, dec = 0x00000020, @true = 0x00000040, @false = 0x00000080,
             times = 0x00000100, div = 0x00000200, mod = 0x00000400, and = 0x00000800,
             or = 0x00001000, xor = 0x00002000, lshift = 0x00004000, rshift = 0x00008000,
             eq = 0x00010000, neq = 0x00020000, gt = 0x00040000, lt = 0x00080000,
             gte = 0x00100000, lte = 0x00200000,
             unary = plus | minus | not | tilde | inc | dec | @true | @false,
             binary = plus | minus | times | div | mod | and | or | xor | lshift | rshift | eq | neq | gt | lt | gte | lte
         }
 
         /*------------------------- modifier handling -----------------------------*/
 
         [Flags]
         enum Modifier
         {
             @new = 0x0001, @public = 0x0002, @protected = 0x0004, @internal = 0x0008,
             @private = 0x0010, @unsafe = 0x0020, @static = 0x0040, @readonly = 0x0080,
             @volatile = 0x0100, @virtual = 0x0200, @sealed = 0x0400, @override = 0x0800,
             @abstract = 0x1000, @extern = 0x2000,
 
             /* sets of modifiers that can be attached to certain program elements    *
              * e.g., "constants" marks all modifiers that may be used with constants */
             none = 0x0000,
             classes = @new | @public | @protected | @internal | @private | @unsafe | @abstract | @sealed | @static,
             constants = @new | @public | @protected | @internal | @private,
             fields = @new | @public | @protected | @internal | @private | @unsafe | @static | @readonly | @volatile,
             propEvntMeths = @new | @public | @protected | @internal | @private | @unsafe | @static | @virtual | @sealed | @override | @abstract | @extern,
             accessorsPossib1 = @private,
             accessorsPossib2 = @protected | @internal,
             indexers = @new | @public | @protected | @internal | @private | @unsafe | @virtual | @sealed | @override | @abstract | @extern,
             operators = @public | @unsafe | @static | @extern,
             operatorsMust = @public | @static,
             constructors = @public | @protected | @internal | @private | @unsafe | @extern,
             staticConstr = @extern | @static,
             staticConstrMust = @static,
             nonClassTypes = @new | @public | @protected | @internal | @private | @unsafe,
             destructors = @extern | @unsafe,
             all = 0x3fff
         }
 
         class Modifiers
         {
             private Modifier cur = Modifier.none;
             private Parser parser;
 
             public Modifiers(Parser parser)
             {
                 this.parser = parser;
             }
 
             public void Add(Modifier m)
             {
                 if ((cur & m) == 0) cur |= m;
                 else parser.Error("modifier " + m + " already defined");
             }
 
             public void Add(Modifiers m) { Add(m.cur); }
 
             public bool IsNone { get { return cur == Modifier.none; } }
 
             public void Check(Modifier allowed)
             {
                 Modifier wrong = cur & (allowed ^ Modifier.all);
                 if (wrong != Modifier.none)
                     parser.Error("modifier(s) " + wrong + " not allowed here");
             }
 
             public void Check(Modifier allowEither, Modifier allowOr)
             {
                 Modifier wrong = cur & ((allowEither | allowOr) ^ Modifier.all);
                 if ((allowEither & allowOr) != Modifier.none)
                 {
                     parser.Error("modifiers providerd must not overlap");
                 }
                 else if (wrong != Modifier.none)
                 {
                     parser.Error("modifier(s) " + wrong + " not allowed here");
                 }
                 else if (((cur & allowEither) != Modifier.none) && ((cur & allowOr) != Modifier.none))
                 {
                     parser.Error("modifier(s) may either be " + allowEither + " or " + allowOr);
                 }
             }
 
             public void CheckMust(Modifier mustHave)
             {
                 Modifier missing = (cur & mustHave) ^ mustHave;
                 if (missing != Modifier.none)
                 {
                     parser.Error("modifier(s) " + missing + " must be applied here");
                 }
             }
 
             public bool Has(Modifier mod)
             {
                 return (cur & mod) == mod;
             }
         }
 
 
         /*------------------------------------------------------------------------*
          *----- SCANNER DESCRIPTION ----------------------------------------------*
          *------------------------------------------------------------------------*/
 
 
 
         public Parser(Scanner scanner)
         {
             this.scanner = scanner;
             errors = new Errors();
         }
 
         void SynErr(int n)
         {
             if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n);
             errDist = 0;
         }
 
         public void SemErr(string msg)
         {
             if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg);
             errDist = 0;
         }
 
         void Get()
         {
             for (; ; )
             {
                 t = la;
                 la = scanner.Scan();
                 if (la.kind <= maxT) { ++errDist; break; }
                 if (la.kind == 131)
                 {
                     AddCCS(la.val);
                 }
                 if (la.kind == 132)
                 {
                     RemCCS(la.val);
                 }
                 if (la.kind == 133)
                 {
                     IfPragma(la.val);
                 }
                 if (la.kind == 134)
                 {
                     ElifOrElsePragma();
                 }
                 if (la.kind == 135)
                 {
                     ElifOrElsePragma();
                 }
                 if (la.kind == 136)
                 {
                 }
                 if (la.kind == 137)
                 {
                 }
                 if (la.kind == 138)
                 {
                 }
                 if (la.kind == 139)
                 {
                 }
                 if (la.kind == 140)
                 {
                 }
                 if (la.kind == 141)
                 {
                 }
 
                 la = t;
             }
         }
 
         void Expect(int n)
         {
             if (la.kind == n) Get(); else { SynErr(n); }
         }
 
         bool StartOf(int s)
         {
             return set[s, la.kind];
         }
 
         void ExpectWeak(int n, int follow)
         {
             if (la.kind == n) Get();
             else
             {
                 SynErr(n);
                 while (!StartOf(follow)) Get();
             }
         }
 
 
         bool WeakSeparator(int n, int syFol, int repFol)
         {
             int kind = la.kind;
             if (kind == n) { Get(); return true; }
             else if (StartOf(repFol)) { return false; }
             else
             {
                 SynErr(n);
                 while (!(set[syFol, kind] || set[repFol, kind] || set[0, kind]))
                 {
                     Get();
                     kind = la.kind;
                 }
                 return StartOf(syFol);
             }
         }
 
 
         void CS2()
         {
             while (IsExternAliasDirective())
             {
                 ExternAliasDirective();
             }
             while (la.kind == 78)
             {
                 UsingDirective();
             }
             while (IsGlobalAttrTarget())
             {
                 GlobalAttributes();
             }
             while (StartOf(1))
             {
                 NamespaceMemberDeclaration();
             }
         }
 
         void ExternAliasDirective()
         {
             Expect(28);
             Expect(1);
             if (t.val != "alias")
             {
                 Error("alias expected");
             }
             else
             {
                 exts.Add(t.val);
             }
 
             Expect(1);
             Expect(114);
         }
 
         void UsingDirective()
         {
             Expect(78);
             if (IsAssignment())
             {
                 Expect(1);
                 Expect(85);
             }
             TokenMatch tm = new TokenMatch();
             tm.Position = la.pos;
             this.m_Current = la.val;
             TypeName();
             tm.Value = this.m_Current;
             this.m_CodeInfo.Usings.Add(tm);
             Expect(114);
         }
 
         void GlobalAttributes()
         {
             Expect(97);
             Expect(1);
             if (!"assembly".Equals(t.val) && !"module".Equals(t.val)) Error("global attribute target specifier \"assembly\" or \"module\" expected");
 
             Expect(86);
             Attribute();
             while (NotFinalComma())
             {
                 Expect(87);
                 Attribute();
             }
             if (la.kind == 87)
             {
                 Get();
             }
             Expect(112);
         }
 
         void NamespaceMemberDeclaration()
         {
             Modifiers m = new Modifiers(this);
             if (la.kind == 45)
             {
                 Get();
                 this.m_Current = la.val;
                 Expect(1);
                 while (la.kind == 90)
                 {
                     Get();
                     this.m_Current += "." + la.val;
                     Expect(1);
                 }
                 Expect(96);
                 while (IsExternAliasDirective())
                 {
                     ExternAliasDirective();
                 }
                 while (la.kind == 78)
                 {
                     UsingDirective();
                 }
                 while (StartOf(1))
                 {
                     NamespaceMemberDeclaration();
                 }
                 Expect(111);
                 if (la.kind == 114)
                 {
                     Get();
                 }
                 this.m_CodeInfo.NameSpaces.Add(this.m_Current);
             }
             else if (StartOf(2))
             {
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 ModifierList(m);
                 TypeDeclaration(m);
             }
             else SynErr(131);
         }
 
         void TypeName()
         {
             Expect(1);
             if (la.kind == 91)
             {
                 Get();
                 Expect(1);
             }
             if (la.kind == 100)
             {
                 TypeArgumentList();
             }
             while (la.kind == 90)
             {
                 Get();
                 this.m_Current += "." + la.val;
                 Expect(1);
                 if (la.kind == 100)
                 {
                     TypeArgumentList();
                 }
             }
         }
 
         void Attributes()
         {
             Expect(97);
             if (IsAttrTargSpec())
             {
                 if (la.kind == 1)
                 {
                     Get();
                 }
                 else if (StartOf(3))
                 {
                     Keyword();
                 }
                 else SynErr(132);
                 Expect(86);
             }
             Attribute();
             while (la.kind == _comma && Peek(1).kind != _rbrack)
             {
                 Expect(87);
                 Attribute();
             }
             if (la.kind == 87)
             {
                 Get();
             }
             Expect(112);
         }
 
         void ModifierList(Modifiers m)
         {
             while (StartOf(4))
             {
                 switch (la.kind)
                 {
                     case 46
                         {
                             Get();
                             m.Add(Modifier.@new);
                             break;
                         }
                     case 55
                         {
                             Get();
                             m.Add(Modifier.@public);
                             break;
                         }
                     case 54
                         {
                             Get();
                             m.Add(Modifier.@protected);
                             break;
                         }
                     case 41
                         {
                             Get();
                             m.Add(Modifier.@internal);
                             break;
                         }
                     case 53
                         {
                             Get();
                             m.Add(Modifier.@private);
                             break;
                         }
                     case 76
                         {
                             Get();
                             m.Add(Modifier.@unsafe);
                             break;
                         }
                     case 64
                         {
                             Get();
                             m.Add(Modifier.@static);
                             break;
                         }
                     case 56
                         {
                             Get();
                             m.Add(Modifier.@readonly);
                             break;
                         }
                     case 81
                         {
                             Get();
                             m.Add(Modifier.@volatile);
                             break;
                         }
                     case 79
                         {
                             Get();
                             m.Add(Modifier.@virtual);
                             break;
                         }
                     case 60
                         {
                             Get();
                             m.Add(Modifier.@sealed);
                             break;
                         }
                     case 51
                         {
                             Get();
                             m.Add(Modifier.@override);
                             break;
                         }
                     case 6
                         {
                             Get();
                             m.Add(Modifier.@abstract);
                             break;
                         }
                     case 28
                         {
                             Get();
                             m.Add(Modifier.@extern);
                             break;
                         }
                 }
             }
         }
 
         void TypeDeclaration(Modifiers m)
         {
             TypeKind dummy;
             if (StartOf(5))
             {
                 if (la.kind == 119)
                 {
                     Get();
                 }
                 if (la.kind == 16)
                 {
                     m.Check(Modifier.classes);
                     Get();
                     Expect(1);
                     if (la.kind == 100)
                     {
                         TypeParameterList();
                     }
                     if (la.kind == 86)
                     {
                         ClassBase();
                     }
                     while (la.kind == 1)
                     {
                         TypeParameterConstraintsClause();
                     }
                     ClassBody();
                     if (la.kind == 114)
                     {
                         Get();
                     }
                 }
                 else if (la.kind == 66)
                 {
                     m.Check(Modifier.nonClassTypes);
                     Get();
                     Expect(1);
                     if (la.kind == 100)
                     {
                         TypeParameterList();
                     }
                     if (la.kind == 86)
                     {
                         Get();
                         TypeName();
                         while (la.kind == 87)
                         {
                             Get();
                             TypeName();
                         }
                     }
                     while (la.kind == 1)
                     {
                         TypeParameterConstraintsClause();
                     }
                     StructBody();
                     if (la.kind == 114)
                     {
                         Get();
                     }
                 }
                 else if (la.kind == 40)
                 {
                     m.Check(Modifier.nonClassTypes);
                     Get();
                     Expect(1);
                     if (la.kind == 100)
                     {
                         TypeParameterList();
                     }
                     if (la.kind == 86)
                     {
                         Get();
                         TypeName();
                         while (la.kind == 87)
                         {
                             Get();
                             TypeName();
                         }
                     }
                     while (la.kind == 1)
                     {
                         TypeParameterConstraintsClause();
                     }
                     Expect(96);
                     while (StartOf(6))
                     {
                         InterfaceMemberDeclaration();
                     }
                     Expect(111);
                     if (la.kind == 114)
                     {
                         Get();
                     }
                 }
                 else SynErr(133);
             }
             else if (la.kind == 25)
             {
                 m.Check(Modifier.nonClassTypes);
                 Get();
                 Expect(1);
                 if (la.kind == 86)
                 {
                     Get();
                     IntegralType();
                 }
                 EnumBody();
                 if (la.kind == 114)
                 {
                     Get();
                 }
             }
             else if (la.kind == 21)
             {
                 m.Check(Modifier.nonClassTypes);
                 Get();
                 Type(out dummy, true);
                 Expect(1);
                 if (la.kind == 100)
                 {
                     TypeParameterList();
                 }
                 Expect(98);
                 if (StartOf(7))
                 {
                     FormalParameterList();
                 }
                 Expect(113);
                 while (la.kind == 1)
                 {
                     TypeParameterConstraintsClause();
                 }
                 Expect(114);
             }
             else SynErr(134);
         }
 
         void TypeParameterList()
         {
             Expect(100);
             while (la.kind == 97)
             {
                 Attributes();
             }
             Expect(1);
             while (la.kind == 87)
             {
                 Get();
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 Expect(1);
             }
             Expect(93);
         }
 
         void ClassBase()
         {
             Expect(86);
             ClassType();
             while (la.kind == 87)
             {
                 Get();
                 TypeName();
             }
         }
 
         void TypeParameterConstraintsClause()
         {
             Expect(1);
             if (t.val != "where")
             {
                 Error("type parameter constraints clause must start with
             }
 
             Expect(1);
             Expect(86);
             if (StartOf(8))
             {
                 if (la.kind == 16)
                 {
                     Get();
                 }
                 else if (la.kind == 66)
                 {
                     Get();
                 }
                 else if (la.kind == 48)
                 {
                     Get();
                 }
                 else if (la.kind == 65)
                 {
                     Get();
                 }
                 else
                 {
                     TypeName();
                 }
                 while (la.kind == _comma && Peek(1).kind != _new)
                 {
                     Expect(87);
                     TypeName();
                 }
                 if (la.kind == 87)
                 {
                     Get();
                     Expect(46);
                     Expect(98);
                     Expect(113);
                 }
             }
             else if (la.kind == 46)
             {
                 Get();
                 Expect(98);
                 Expect(113);
             }
             else SynErr(135);
         }
 
         void ClassBody()
         {
             Expect(96);
             while (StartOf(9))
             {
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 Modifiers m = new Modifiers(this);
                 ModifierList(m);
                 ClassMemberDeclaration(m);
             }
             Expect(111);
         }
 
         void StructBody()
         {
             Expect(96);
             while (StartOf(10))
             {
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 Modifiers m = new Modifiers(this);
                 ModifierList(m);
                 StructMemberDeclaration(m);
             }
             Expect(111);
         }
 
         void InterfaceMemberDeclaration()
         {
             Modifiers m = new Modifiers(this);
             TypeKind dummy;
 
             while (la.kind == 97)
             {
                 Attributes();
             }
             if (la.kind == 46)
             {
                 Get();
             }
             if (StartOf(11))
             {
                 Type(out dummy, true);
                 if (la.kind == 1)
                 {
                     Get();
                     if (la.kind == 98 || la.kind == 100)
                     {
                         if (la.kind == 100)
                         {
                             TypeParameterList();
                         }
                         Expect(98);
                         if (StartOf(7))
                         {
                             FormalParameterList();
                         }
                         Expect(113);
                         while (la.kind == 1)
                         {
                             TypeParameterConstraintsClause();
                         }
                         Expect(114);
                     }
                     else if (la.kind == 96)
                     {
                         Get();
                         InterfaceAccessors(m);
                         Expect(111);
                     }
                     else SynErr(136);
                 }
                 else if (la.kind == 68)
                 {
                     Get();
                     Expect(97);
                     FormalParameterList();
                     Expect(112);
                     Expect(96);
                     InterfaceAccessors(m);
                     Expect(111);
                 }
                 else SynErr(137);
             }
             else if (la.kind == 26)
             {
                 Get();
                 Type(out dummy, false);
                 Expect(1);
                 Expect(114);
             }
             else SynErr(138);
         }
 
         void IntegralType()
         {
             switch (la.kind)
             {
                 case 59
                     {
                         Get();
                         break;
                     }
                 case 11
                     {
                         Get();
                         break;
                     }
                 case 61
                     {
                         Get();
                         break;
                     }
                 case 77
                     {
                         Get();
                         break;
                     }
                 case 39
                     {
                         Get();
                         break;
                     }
                 case 73
                     {
                         Get();
                         break;
                     }
                 case 44
                     {
                         Get();
                         break;
                     }
                 case 74
                     {
                         Get();
                         break;
                     }
                 case 14
                     {
                         Get();
                         break;
                     }
                 default
             }
         }
 
         void EnumBody()
         {
             Expect(96);
             if (la.kind == 1 || la.kind == 97)
             {
                 EnumMemberDeclaration();
                 while (NotFinalComma())
                 {
                     Expect(87);
                     EnumMemberDeclaration();
                 }
                 if (la.kind == 87)
                 {
                     Get();
                 }
             }
             Expect(111);
         }
 
         void Type(out TypeKind type, bool voidAllowed)
         {
             type = TypeKind.simple;
             if (StartOf(12))
             {
                 PrimitiveType();
             }
             else if (la.kind == 1 || la.kind == 48 || la.kind == 65)
             {
                 ClassType();
             }
             else if (la.kind == 80)
             {
                 Get();
                 type = TypeKind.@void;
             }
             else SynErr(140);
             if (la.kind == 110)
             {
                 Get();
                 if (type == TypeKind.@void) { Error("Unexpected token ?, void must not be nullable."); }
             }
             PointerOrArray(ref type);
             if (type == TypeKind.@void && !voidAllowed) { Error("type expected, void found, maybe you mean void*"); }
         }
 
         void FormalParameterList()
         {
             TypeKind type;
             while (la.kind == 97)
             {
                 Attributes();
             }
             if (StartOf(13))
             {
                 if (la.kind == 50 || la.kind == 57)
                 {
                     if (la.kind == 57)
                     {
                         Get();
                     }
                     else
                     {
                         Get();
                     }
                 }
                 Type(out type, false);
                 Expect(1);
                 if (la.kind == 87)
                 {
                     Get();
                     this.m_Current += ", " + la.val;
                     FormalParameterList();
                 }
             }
             else if (la.kind == 52)
             {
                 Get();
                 Type(out type, false);
                 if (type != TypeKind.array) { Error("params argument must be an array"); }
                 Expect(1);
             }
             else SynErr(141);
         }
 
         void ClassType()
         {
             if (la.kind == 1)
             {
                 TypeName();
             }
             else if (la.kind == 48 || la.kind == 65)
             {
                 InternalClassType();
             }
             else SynErr(142);
         }
 
         void ClassMemberDeclaration(Modifiers m)
         {
             if (StartOf(14))
             {
                 StructMemberDeclaration(m);
             }
             else if (la.kind == 115)
             {
                 Get();
                 Expect(1);
                 Expect(98);
                 Expect(113);
                 if (la.kind == 96)
                 {
                     Block();
                 }
                 else if (la.kind == 114)
                 {
                     Get();
                 }
                 else SynErr(143);
             }
             else SynErr(144);
         }
 
         void StructMemberDeclaration(Modifiers m)
         {
             TypeKind type; Operator op;
             string dataType = la.val;
             if (la.kind == 17)
             {
                 TokenMatch tm = new TokenMatch();
                 m.Check(Modifier.constants);
                 Get();
                 dataType = la.val;
                 Type(out type, false);
                 tm.Position = la.pos;
                 tm.Value = la.val + "
                 Expect(1);
                 tm.Value += " = ";
                 Expect(85);
                 tm.Value += la.val;
                 Expression();
                 while (la.kind == 87)
                 {
                     Get();
                     Expect(1);
                     Expect(85);
                     Expression();
                 }
                 Expect(114);
                 this.m_CodeInfo.Fields.Add(tm);
             }
             else if (la.kind == 26)
             {
                 m.Check(Modifier.propEvntMeths);
                 Get();
                 Type(out type, false);
                 if (IsFieldDecl())
                 {
                     VariableDeclarators();
                     Expect(114);
                 }
                 else if (la.kind == 1)
                 {
                     TypeName();
                     Expect(96);
                     EventAccessorDeclarations();
                     Expect(111);
                 }
                 else SynErr(145);
             }
             else if (la.kind == _ident && Peek(1).kind == _lpar)
             {
                 TokenMatch tm = new TokenMatch(la.val, la.pos);
                 this.m_Current = "(";
                 m.Check(Modifier.constructors | Modifier.staticConstr);
                 Expect(1);
                 Expect(98);
                 this.m_Current += la.val;
                 if (StartOf(7))
                 {
                     m.Check(Modifier.constructors);
                     FormalParameterList();
                 }
                 Expect(113);
                 if (!this.m_Current.Equals("()"))
                 {
                     this.m_Current += ")";
                 }
                 tm.Value += this.m_Current;
                 this.m_CodeInfo.Constructors.Add(tm);
                 if (la.kind == 86)
                 {
                     m.Check(Modifier.constructors);
                     Get();
                     if (la.kind == 8)
                     {
                         Get();
                     }
                     else if (la.kind == 68)
                     {
                         Get();
                     }
                     else SynErr(146);
                     Expect(98);
                     if (StartOf(15))
                     {
                         Argument();
                         while (la.kind == 87)
                         {
                             Get();
                             Argument();
                         }
                     }
                     Expect(113);
                 }
                 if (la.kind == 96)
                 {
                     Block();
                 }
                 else if (la.kind == 114)
                 {
                     Get();
                 }
                 else SynErr(147);
             }
             else if (StartOf(11))
             {
                 Type(out type, true);
                 if (la.kind == 49)
                 {
                     m.Check(Modifier.operators);
                     m.CheckMust(Modifier.operatorsMust);
                     if (type == TypeKind.@void) { Error("operator not allowed on void"); }
 
                     Get();
                     OverloadableOp(out op);
                     Expect(98);
                     Type(out type, false);
                     Expect(1);
                     if (la.kind == 87)
                     {
                         Get();
                         Type(out type, false);
                         Expect(1);
                         if ((op & Operator.binary) == 0) Error("too many operands for unary operator");
                     }
                     else if (la.kind == 113)
                     {
                         if ((op & Operator.unary) == 0) Error("too few operands for binary operator");
                     }
                     else SynErr(148);
                     Expect(113);
                     if (la.kind == 96)
                     {
                         Block();
                     }
                     else if (la.kind == 114)
                     {
                         Get();
                     }
                     else SynErr(149);
                 }
                 else if (IsFieldDecl())
                 {
                     m.Check(Modifier.fields);
                     if (type == TypeKind.@void) { Error("field type must not be void"); }
 
                     this.m_CodeInfo.Fields.Add(new TokenMatch(la.val + "
                     VariableDeclarators();
                     Expect(114);
                 }
                 else if (la.kind == 1)
                 {
                     TokenMatch tm = new TokenMatch(la.val, la.pos);
                     //this.m_CodeInfo.Methods.Add(new TokenMatch(la.val + "
                     MemberName();
                     if (la.kind == 96)
                     {
                         m.Check(Modifier.propEvntMeths);
                         if (type == TypeKind.@void) { Error("property type must not be void"); }
 
                         this.m_Current = "(";
                         Get();
                         AccessorDeclarations(m);
                         Expect(111);
                         this.m_Current += ")";
 
                         tm.Value += this.m_Current;
                         tm.Value += "
                         this.m_CodeInfo.Properties.Add(tm);
                     }
                     else if (la.kind == 90)
                     {
                         m.Check(Modifier.indexers);
                         if (type == TypeKind.@void) { Error("indexer type must not be void"); }
 
                         Get();
                         Expect(68);
                         Expect(97);
                         FormalParameterList();
                         Expect(112);
                         Expect(96);
                         AccessorDeclarations(m);
                         Expect(111);
                     }
                     else if (la.kind == 98 || la.kind == 100)
                     {
                         m.Check(Modifier.propEvntMeths);
                         if (la.kind == 100)
                         {
                             TypeParameterList();
                         }
                         Expect(98);
                         this.m_Current = "(" + la.val;
                         if (StartOf(7))
                         {
                             FormalParameterList();
                         }
                         if (!this.m_Current.Equals("()"))
                         {
                             this.m_Current += ")";
                         }
                         tm.Value += this.m_Current;
                         Expect(113);
                         while (la.kind == 1)
                         {
                             TypeParameterConstraintsClause();
                         }
                         if (la.kind == 96)
                         {
                             Block();
                         }
                         else if (la.kind == 114)
                         {
                             Get();
                         }
                         else SynErr(150);
 
                         tm.Value += "
                         this.m_CodeInfo.Methods.Add(tm);
                     }
                     else SynErr(151);
                 }
                 else if (la.kind == 68)
                 {
                     m.Check(Modifier.indexers);
                     if (type == TypeKind.@void) { Error("indexer type must not be void"); }
 
                     Get();
                     Expect(97);
                     FormalParameterList();
                     Expect(112);
                     Expect(96);
                     AccessorDeclarations(m);
                     Expect(111);
                 }
                 else SynErr(152);
             }
             else if (la.kind == 27 || la.kind == 37)
             {
                 m.Check(Modifier.operators);
                 m.CheckMust(Modifier.operatorsMust);
 
                 if (la.kind == 37)
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                 }
                 Expect(49);
                 Type(out type, false);
                 if (type == TypeKind.@void) { Error("cast type must not be void"); }
                 Expect(98);
                 Type(out type, false);
                 Expect(1);
                 Expect(113);
                 if (la.kind == 96)
                 {
                     Block();
                 }
                 else if (la.kind == 114)
                 {
                     Get();
                 }
                 else SynErr(153);
             }
             else if (StartOf(16))
             {
                 TypeDeclaration(m);
             }
             else SynErr(154);
         }
 
         void EnumMemberDeclaration()
         {
             while (la.kind == 97)
             {
                 Attributes();
             }
             Expect(1);
             if (la.kind == 85)
             {
                 Get();
                 Expression();
             }
         }
 
         void Block()
         {
             Expect(96);
             while (StartOf(17))
             {
                 Statement();
             }
             Expect(111);
         }
 
         void Expression()
         {
             Unary();
             if (assgnOps[la.kind] || (la.kind == _gt && Peek(1).kind == _gteq))
             {
                 AssignmentOperator();
                 Expression();
             }
             else if (StartOf(18))
             {
                 NullCoalescingExpr();
                 if (la.kind == 110)
                 {
                     Get();
                     Expression();
                     Expect(86);
                     Expression();
                 }
             }
             else SynErr(155);
         }
 
         void VariableDeclarators()
         {
             Expect(1);
             if (la.kind == 85)
             {
                 Get();
                 VariableInitializer();
             }
             while (la.kind == 87)
             {
                 Get();
                 Expect(1);
                 if (la.kind == 85)
                 {
                     Get();
                     VariableInitializer();
                 }
             }
         }
 
         void EventAccessorDeclarations()
         {
             bool addFound = false, remFound = false;
             while (la.kind == 97)
             {
                 Attributes();
             }
             if ("add".Equals(la.val))
             {
                 Expect(1);
                 addFound = true;
             }
             else if ("remove".Equals(la.val))
             {
                 Expect(1);
                 remFound = true;
             }
             else if (la.kind == 1)
             {
                 Get();
                 Error("add or remove expected");
             }
             else SynErr(156);
             Block();
             if (la.kind == 1 || la.kind == 97)
             {
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 if ("add".Equals(la.val))
                 {
                     Expect(1);
                     if (addFound) Error("add already declared");
                 }
                 else if ("remove".Equals(la.val))
                 {
                     Expect(1);
                     if (remFound) Error("remove already declared");
                 }
                 else if (la.kind == 1)
                 {
                     Get();
                     Error("add or remove expected");
                 }
                 else SynErr(157);
                 Block();
             }
         }
 
         void Argument()
         {
             if (la.kind == 50 || la.kind == 57)
             {
                 if (la.kind == 57)
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                 }
             }
             Expression();
         }
 
         void OverloadableOp(out Operator op)
         {
             op = Operator.plus;
             switch (la.kind)
             {
                 case 108
                     {
                         Get();
                         break;
                     }
                 case 102
                     {
                         Get();
                         op = Operator.minus;
                         break;
                     }
                 case 106
                     {
                         Get();
                         op = Operator.not;
                         break;
                     }
                 case 115
                     {
                         Get();
                         op = Operator.tilde;
                         break;
                     }
                 case 95
                     {
                         Get();
                         op = Operator.inc;
                         break;
                     }
                 case 88
                     {
                         Get();
                         op = Operator.dec;
                         break;
                     }
                 case 70
                     {
                         Get();
                         op = Operator.@true;
                         break;
                     }
                 case 29
                     {
                         Get();
                         op = Operator.@false;
                         break;
                     }
                 case 116
                     {
                         Get();
                         op = Operator.times;
                         break;
                     }
                 case 127
                     {
                         Get();
                         op = Operator.div;
                         break;
                     }
                 case 128
                     {
                         Get();
                         op = Operator.mod;
                         break;
                     }
                 case 83
                     {
                         Get();
                         op = Operator.and;
                         break;
                     }
                 case 124
                     {
                         Get();
                         op = Operator.or;
                         break;
                     }
                 case 125
                     {
                         Get();
                         op = Operator.xor;
                         break;
                     }
                 case 101
                     {
                         Get();
                         op = Operator.lshift;
                         break;
                     }
                 case 92
                     {
                         Get();
                         op = Operator.eq;
                         break;
                     }
                 case 105
                     {
                         Get();
                         op = Operator.neq;
                         break;
                     }
                 case 93
                     {
                         Get();
                         op = Operator.gt;
                         if (la.kind == 93)
                         {
                             if (la.pos > t.pos + 1) Error("no whitespace allowed in right shift operator");
                             Get();
                             op = Operator.rshift;
                         }
                         break;
                     }
                 case 100
                     {
                         Get();
                         op = Operator.lt;
                         break;
                     }
                 case 94
                     {
                         Get();
                         op = Operator.gte;
                         break;
                     }
                 case 126
                     {
                         Get();
                         op = Operator.lte;
                         break;
                     }
                 default
             }
         }
 
         void MemberName()
         {
             Expect(1);
             if (la.kind == 91)
             {
                 Get();
                 Expect(1);
             }
             if (la.kind == _lt && IsPartOfMemberName())
             {
                 TypeArgumentList();
             }
             while (la.kind == _dot && Peek(1).kind == _ident)
             {
                 Expect(90);
                 Expect(1);
                 if (la.kind == _lt && IsPartOfMemberName())
                 {
                     TypeArgumentList();
                 }
             }
         }
 
         void AccessorDeclarations(Modifiers m)
         {
             Modifiers am = new Modifiers(this);
             bool getFound = false, setFound = false;
 
             while (la.kind == 97)
             {
                 Attributes();
             }
             ModifierList(am);
             am.Check(Modifier.accessorsPossib1, Modifier.accessorsPossib2);
             if ("get".Equals(la.val))
             {
                 if (!this.m_Current.Equals("("))
                 {
                     this.m_Current += ", ";
                 }
                 this.m_Current += "get";
                 Expect(1);
                 getFound = true;
             }
             else if ("set".Equals(la.val))
             {
                 if (!this.m_Current.Equals("("))
                 {
                     this.m_Current += ", ";
                 }
                 this.m_Current += "set";
                 Expect(1);
                 setFound = true;
             }
             else if (la.kind == 1)
             {
                 Get();
                 Error("set or get expected");
             }
             else SynErr(159);
             if (la.kind == 96)
             {
                 Block();
             }
             else if (la.kind == 114)
             {
                 Get();
             }
             else SynErr(160);
             if (StartOf(19))
             {
                 am = new Modifiers(this);
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 ModifierList(am);
                 am.Check(Modifier.accessorsPossib1, Modifier.accessorsPossib2);
                 if ("get".Equals(la.val))
                 {
                     Expect(1);
                     if (getFound) Error("get already declared");
                 }
                 else if ("set".Equals(la.val))
                 {
                     Expect(1);
                     if (setFound) Error("set already declared");
                 }
                 else if (la.kind == 1)
                 {
                     Get();
                     Error("set or get expected");
                 }
                 else SynErr(161);
                 if (la.kind == 96)
                 {
                     Block();
                 }
                 else if (la.kind == 114)
                 {
                     Get();
                 }
                 else SynErr(162);
             }
         }
 
         void InterfaceAccessors(Modifiers m)
         {
             bool getFound = false, setFound = false;
             while (la.kind == 97)
             {
                 Attributes();
             }
             if ("get".Equals(la.val))
             {
                 Expect(1);
                 getFound = true;
             }
             else if ("set".Equals(la.val))
             {
                 Expect(1);
                 setFound = true;
             }
             else if (la.kind == 1)
             {
                 Get();
                 Error("set or get expected");
             }
             else SynErr(163);
             Expect(114);
             if (la.kind == 1 || la.kind == 97)
             {
                 while (la.kind == 97)
                 {
                     Attributes();
                 }
                 if ("get".Equals(la.val))
                 {
                     Expect(1);
                     if (getFound) Error("get already declared");
                 }
                 else if ("set".Equals(la.val))
                 {
                     Expect(1);
                     if (setFound) Error("set already declared");
                 }
                 else if (la.kind == 1)
                 {
                     Get();
                     Error("set or get expected");
                 }
                 else SynErr(164);
                 Expect(114);
             }
         }
 
         void LocalVariableDeclaration()
         {
             TypeKind dummy;
             Type(out dummy, false);
             LocalVariableDeclarator();
             while (la.kind == 87)
             {
                 Get();
                 LocalVariableDeclarator();
             }
         }
 
         void LocalVariableDeclarator()
         {
             TypeKind dummy;
             Expect(1);
             if (la.kind == 85)
             {
                 Get();
                 if (StartOf(20))
                 {
                     VariableInitializer();
                 }
                 else if (la.kind == 63)
                 {
                     Get();
                     Type(out dummy, false);
                     Expect(97);
                     Expression();
                     Expect(112);
                 }
                 else SynErr(165);
             }
         }
 
         void VariableInitializer()
         {
             if (StartOf(21))
             {
                 Expression();
             }
             else if (la.kind == 96)
             {
                 ArrayInitializer();
             }
             else SynErr(166);
         }
 
         void ArrayInitializer()
         {
             Expect(96);
             if (StartOf(20))
             {
                 VariableInitializer();
                 while (NotFinalComma())
                 {
                     Expect(87);
                     VariableInitializer();
                 }
                 if (la.kind == 87)
                 {
                     Get();
                 }
             }
             Expect(111);
         }
 
         void Attribute()
         {
             TypeName();
             if (la.kind == 98)
             {
                 AttributeArguments();
             }
         }
 
         void Keyword()
         {
             switch (la.kind)
             {
                 case 6
                     {
                         Get();
                         break;
                     }
                 case 7
                     {
                         Get();
                         break;
                     }
                 case 8
                     {
                         Get();
                         break;
                     }
                 case 9
                     {
                         Get();
                         break;
                     }
                 case 10
                     {
                         Get();
                         break;
                     }
                 case 11
                     {
                         Get();
                         break;
                     }
                 case 12
                     {
                         Get();
                         break;
                     }
                 case 13
                     {
                         Get();
                         break;
                     }
                 case 14
                     {
                         Get();
                         break;
                     }
                 case 15
                     {
                         Get();
                         break;
                     }
                 case 16
                     {
                         Get();
                         break;
                     }
                 case 17
                     {
                         Get();
                         break;
                     }
                 case 18
                     {
                         Get();
                         break;
                     }
                 case 19
                     {
                         Get();
                         break;
                     }
                 case 20
                     {
                         Get();
                         break;
                     }
                 case 21
                     {
                         Get();
                         break;
                     }
                 case 22
                     {
                         Get();
                         break;
                     }
                 case 23
                     {
                         Get();
                         break;
                     }
                 case 24
                     {
                         Get();
                         break;
                     }
                 case 25
                     {
                         Get();
                         break;
                     }
                 case 26
                     {
                         Get();
                         break;
                     }
                 case 27
                     {
                         Get();
                         break;
                     }
                 case 28
                     {
                         Get();
                         break;
                     }
                 case 29
                     {
                         Get();
                         break;
                     }
                 case 30
                     {
                         Get();
                         break;
                     }
                 case 31
                     {
                         Get();
                         break;
                     }
                 case 32
                     {
                         Get();
                         break;
                     }
                 case 33
                     {
                         Get();
                         break;
                     }
                 case 34
                     {
                         Get();
                         break;
                     }
                 case 35
                     {
                         Get();
                         break;
                     }
                 case 36
                     {
                         Get();
                         break;
                     }
                 case 37
                     {
                         Get();
                         break;
                     }
                 case 38
                     {
                         Get();
                         break;
                     }
                 case 39
                     {
                         Get();
                         break;
                     }
                 case 40
                     {
                         Get();
                         break;
                     }
                 case 41
                     {
                         Get();
                         break;
                     }
                 case 42
                     {
                         Get();
                         break;
                     }
                 case 43
                     {
                         Get();
                         break;
                     }
                 case 44
                     {
                         Get();
                         break;
                     }
                 case 45
                     {
                         Get();
                         break;
                     }
                 case 46
                     {
                         Get();
                         break;
                     }
                 case 47
                     {
                         Get();
                         break;
                     }
                 case 48
                     {
                         Get();
                         break;
                     }
                 case 49
                     {
                         Get();
                         break;
                     }
                 case 50
                     {
                         Get();
                         break;
                     }
                 case 51
                     {
                         Get();
                         break;
                     }
                 case 52
                     {
                         Get();
                         break;
                     }
                 case 53
                     {
                         Get();
                         break;
                     }
                 case 54
                     {
                         Get();
                         break;
                     }
                 case 55
                     {
                         Get();
                         break;
                     }
                 case 56
                     {
                         Get();
                         break;
                     }
                 case 57
                     {
                         Get();
                         break;
                     }
                 case 58
                     {
                         Get();
                         break;
                     }
                 case 59
                     {
                         Get();
                         break;
                     }
                 case 60
                     {
                         Get();
                         break;
                     }
                 case 61
                     {
                         Get();
                         break;
                     }
                 case 62
                     {
                         Get();
                         break;
                     }
                 case 63
                     {
                         Get();
                         break;
                     }
                 case 64
                     {
                         Get();
                         break;
                     }
                 case 65
                     {
                         Get();
                         break;
                     }
                 case 66
                     {
                         Get();
                         break;
                     }
                 case 67
                     {
                         Get();
                         break;
                     }
                 case 68
                     {
                         Get();
                         break;
                     }
                 case 69
                     {
                         Get();
                         break;
                     }
                 case 70
                     {
                         Get();
                         break;
                     }
                 case 71
                     {
                         Get();
                         break;
                     }
                 case 72
                     {
                         Get();
                         break;
                     }
                 case 73
                     {
                         Get();
                         break;
                     }
                 case 74
                     {
                         Get();
                         break;
                     }
                 case 75
                     {
                         Get();
                         break;
                     }
                 case 76
                     {
                         Get();
                         break;
                     }
                 case 77
                     {
                         Get();
                         break;
                     }
                 case 78
                     {
                         Get();
                         break;
                     }
                 case 79
                     {
                         Get();
                         break;
                     }
                 case 80
                     {
                         Get();
                         break;
                     }
                 case 81
                     {
                         Get();
                         break;
                     }
                 case 82
                     {
                         Get();
                         break;
                     }
                 default
             }
         }
 
         void AttributeArguments()
         {
             bool nameFound = false;
             Expect(98);
             if (StartOf(21))
             {
                 if (IsAssignment())
                 {
                     nameFound = true;
                     Expect(1);
                     Expect(85);
                 }
                 Expression();
                 while (la.kind == 87)
                 {
                     Get();
                     if (IsAssignment())
                     {
                         nameFound = true;
                         Expect(1);
                         Expect(85);
                     }
                     else if (StartOf(21))
                     {
                         if (nameFound) Error("no positional argument after named arguments");
                     }
                     else SynErr(168);
                     Expression();
                 }
             }
             Expect(113);
         }
 
         void PrimitiveType()
         {
             if (StartOf(22))
             {
                 IntegralType();
             }
             else if (la.kind == 32)
             {
                 Get();
             }
             else if (la.kind == 23)
             {
                 Get();
             }
             else if (la.kind == 19)
             {
                 Get();
             }
             else if (la.kind == 9)
             {
                 Get();
             }
             else SynErr(169);
         }
 
         void PointerOrArray(ref TypeKind type)
         {
             while (IsPointerOrDims())
             {
                 if (la.kind == 116)
                 {
                     Get();
                     type = TypeKind.pointer;
                 }
                 else if (la.kind == 97)
                 {
                     Get();
                     while (la.kind == 87)
                     {
                         Get();
                     }
                     this.m_Current += "[]";
                     Expect(112);
                     type = TypeKind.array;
                 }
                 else SynErr(170);
             }
         }
 
         void ResolvedType()
         {
             TypeKind type = TypeKind.simple;
             if (StartOf(12))
             {
                 PrimitiveType();
             }
             else if (la.kind == 48)
             {
                 Get();
             }
             else if (la.kind == 65)
             {
                 Get();
             }
             else if (la.kind == 1)
             {
                 Get();
                 if (la.kind == 91)
                 {
                     Get();
                     Expect(1);
                 }
                 if (IsGeneric())
                 {
                     TypeArgumentList();
                 }
                 while (la.kind == 90)
                 {
                     Get();
                     Expect(1);
                     if (IsGeneric())
                     {
                         TypeArgumentList();
                     }
                 }
             }
             else if (la.kind == 80)
             {
                 Get();
                 type = TypeKind.@void;
             }
             else SynErr(171);
             PointerOrArray(ref type);
             if (type == TypeKind.@void) Error("type expected, void found, maybe you mean void*");
         }
 
         void TypeArgumentList()
         {
             TypeKind dummy;
             Expect(100);
             if (StartOf(11))
             {
                 Type(out dummy, false);
             }
             while (la.kind == 87)
             {
                 Get();
                 if (StartOf(11))
                 {
                     Type(out dummy, false);
                 }
             }
             Expect(93);
         }
 
         void InternalClassType()
         {
             if (la.kind == 48)
             {
                 Get();
             }
             else if (la.kind == 65)
             {
                 Get();
             }
             else SynErr(172);
         }
 
         void Statement()
         {
             TypeKind dummy;
             if (la.kind == _ident && Peek(1).kind == _colon)
             {
                 Expect(1);
                 Expect(86);
                 Statement();
             }
             else if (la.kind == 17)
             {
                 Get();
                 Type(out dummy, false);
                 Expect(1);
                 Expect(85);
                 Expression();
                 while (la.kind == 87)
                 {
                     Get();
                     Expect(1);
                     Expect(85);
                     Expression();
                 }
                 Expect(114);
             }
             else if (IsLocalVarDecl())
             {
                 LocalVariableDeclaration();
                 Expect(114);
             }
             else if (StartOf(23))
             {
                 EmbeddedStatement();
             }
             else SynErr(173);
         }
 
         void EmbeddedStatement()
         {
             TypeKind type;
             if (la.kind == 96)
             {
                 Block();
             }
             else if (la.kind == 114)
             {
                 Get();
             }
             else if (la.kind == _checked && Peek(1).kind == _lbrace)
             {
                 Expect(15);
                 Block();
             }
             else if (la.kind == _unchecked && Peek(1).kind == _lbrace)
             {
                 Expect(75);
                 Block();
             }
             else if (StartOf(21))
             {
                 StatementExpression();
                 Expect(114);
             }
             else if (la.kind == 36)
             {
                 Get();
                 Expect(98);
                 Expression();
                 Expect(113);
                 EmbeddedStatement();
                 if (la.kind == 24)
                 {
                     Get();
                     EmbeddedStatement();
                 }
             }
             else if (la.kind == 67)
             {
                 Get();
                 Expect(98);
                 Expression();
                 Expect(113);
                 Expect(96);
                 while (la.kind == 12 || la.kind == 20)
                 {
                     SwitchSection();
                 }
                 Expect(111);
             }
             else if (la.kind == 82)
             {
                 Get();
                 Expect(98);
                 Expression();
                 Expect(113);
                 EmbeddedStatement();
             }
             else if (la.kind == 22)
             {
                 Get();
                 EmbeddedStatement();
                 Expect(82);
                 Expect(98);
                 Expression();
                 Expect(113);
                 Expect(114);
             }
             else if (la.kind == 33)
             {
                 Get();
                 Expect(98);
                 if (StartOf(24))
                 {
                     ForInitializer();
                 }
                 Expect(114);
                 if (StartOf(21))
                 {
                     Expression();
                 }
                 Expect(114);
                 if (StartOf(21))
                 {
                     ForIterator();
                 }
                 Expect(113);
                 EmbeddedStatement();
             }
             else if (la.kind == 34)
             {
                 Get();
                 Expect(98);
                 Type(out type, false);
                 Expect(1);
                 Expect(38);
                 Expression();
                 Expect(113);
                 EmbeddedStatement();
             }
             else if (la.kind == 10)
             {
                 Get();
                 Expect(114);
             }
             else if (la.kind == 18)
             {
                 Get();
                 Expect(114);
             }
             else if (la.kind == 35)
             {
                 Get();
                 if (la.kind == 1)
                 {
                     Get();
                 }
                 else if (la.kind == 12)
                 {
                     Get();
                     Expression();
                 }
                 else if (la.kind == 20)
                 {
                     Get();
                 }
                 else SynErr(174);
                 Expect(114);
             }
             else if (la.kind == 58)
             {
                 Get();
                 if (StartOf(21))
                 {
                     Expression();
                 }
                 Expect(114);
             }
             else if (la.kind == 69)
             {
                 Get();
                 if (StartOf(21))
                 {
                     Expression();
                 }
                 Expect(114);
             }
             else if (la.kind == 71)
             {
                 Get();
                 Block();
                 if (la.kind == 13)
                 {
                     CatchClauses();
                     if (la.kind == 30)
                     {
                         Get();
                         Block();
                     }
                 }
                 else if (la.kind == 30)
                 {
                     Get();
                     Block();
                 }
                 else SynErr(175);
             }
             else if (la.kind == 43)
             {
                 Get();
                 Expect(98);
                 Expression();
                 Expect(113);
                 EmbeddedStatement();
             }
             else if (la.kind == 78)
             {
                 Get();
                 Expect(98);
                 ResourceAcquisition();
                 Expect(113);
                 EmbeddedStatement();
             }
             else if (la.kind == 120)
             {
                 Get();
                 if (la.kind == 58)
                 {
                     Get();
                     Expression();
                 }
                 else if (la.kind == 10)
                 {
                     Get();
                 }
                 else SynErr(176);
                 Expect(114);
             }
             else if (la.kind == 76)
             {
                 Get();
                 Block();
             }
             else if (la.kind == 31)
             {
                 Get();
                 Expect(98);
                 Type(out type, false);
                 if (type != TypeKind.pointer) Error("can only fix pointer types");
                 Expect(1);
                 Expect(85);
                 Expression();
                 while (la.kind == 87)
                 {
                     Get();
                     Expect(1);
                     Expect(85);
                     Expression();
                 }
                 Expect(113);
                 EmbeddedStatement();
             }
             else SynErr(177);
         }
 
         void StatementExpression()
         {
             bool isAssignment = assnStartOp[la.kind] || IsTypeCast();
             Unary();
             if (StartOf(25))
             {
                 AssignmentOperator();
                 Expression();
             }
             else if (la.kind == 87 || la.kind == 113 || la.kind == 114)
             {
                 if (isAssignment) Error("error in assignment.");
             }
             else SynErr(178);
         }
 
         void SwitchSection()
         {
             SwitchLabel();
             while (la.kind == _case || (la.kind == _default && Peek(1).kind == _colon))
             {
                 SwitchLabel();
             }
             Statement();
             while (IsNoSwitchLabelOrRBrace())
             {
                 Statement();
             }
         }
 
         void ForInitializer()
         {
             if (IsLocalVarDecl())
             {
                 LocalVariableDeclaration();
             }
             else if (StartOf(21))
             {
                 StatementExpression();
                 while (la.kind == 87)
                 {
                     Get();
                     StatementExpression();
                 }
             }
             else SynErr(179);
         }
 
         void ForIterator()
         {
             StatementExpression();
             while (la.kind == 87)
             {
                 Get();
                 StatementExpression();
             }
         }
 
         void CatchClauses()
         {
             Expect(13);
             if (la.kind == 96)
             {
                 Block();
             }
             else if (la.kind == 98)
             {
                 Get();
                 ClassType();
                 if (la.kind == 1)
                 {
                     Get();
                 }
                 Expect(113);
                 Block();
                 if (la.kind == 13)
                 {
                     CatchClauses();
                 }
             }
             else SynErr(180);
         }
 
         void ResourceAcquisition()
         {
             if (IsLocalVarDecl())
             {
                 LocalVariableDeclaration();
             }
             else if (StartOf(21))
             {
                 Expression();
             }
             else SynErr(181);
         }
 
         void Unary()
         {
             TypeKind dummy;
             while (unaryHead[la.kind] || IsTypeCast())
             {
                 switch (la.kind)
                 {
                     case 108
                         {
                             Get();
                             break;
                         }
                     case 102
                         {
                             Get();
                             break;
                         }
                     case 106
                         {
                             Get();
                             break;
                         }
                     case 115
                         {
                             Get();
                             break;
                         }
                     case 95
                         {
                             Get();
                             break;
                         }
                     case 88
                         {
                             Get();
                             break;
                         }
                     case 116
                         {
                             Get();
                             break;
                         }
                     case 83
                         {
                             Get();
                             break;
                         }
                     case 98
                         {
                             Get();
                             Type(out dummy, false);
                             Expect(113);
                             break;
                         }
                     default
                 }
             }
             Primary();
         }
 
         void AssignmentOperator()
         {
             switch (la.kind)
             {
                 case 85
                     {
                         Get();
                         break;
                     }
                 case 109
                     {
                         Get();
                         break;
                     }
                 case 103
                     {
                         Get();
                         break;
                     }
                 case 117
                     {
                         Get();
                         break;
                     }
                 case 89
                     {
                         Get();
                         break;
                     }
                 case 104
                     {
                         Get();
                         break;
                     }
                 case 84
                     {
                         Get();
                         break;
                     }
                 case 107
                     {
                         Get();
                         break;
                     }
                 case 118
                     {
                         Get();
                         break;
                     }
                 case 99
                     {
                         Get();
                         break;
                     }
                 case 93
                     {
                         Get();
                         int pos = t.pos;
                         Expect(94);
                         if (pos + 1 < t.pos) Error("no whitespace allowed in right shift assignment");
                         break;
                     }
                 default
             }
         }
 
         void SwitchLabel()
         {
             if (la.kind == 12)
             {
                 Get();
                 Expression();
                 Expect(86);
             }
             else if (la.kind == 20)
             {
                 Get();
                 Expect(86);
             }
             else SynErr(184);
         }
 
         void NullCoalescingExpr()
         {
             OrExpr();
             while (la.kind == 121)
             {
                 Get();
                 Unary();
                 OrExpr();
             }
         }
 
         void OrExpr()
         {
             AndExpr();
             while (la.kind == 122)
             {
                 Get();
                 Unary();
                 AndExpr();
             }
         }
 
         void AndExpr()
         {
             BitOrExpr();
             while (la.kind == 123)
             {
                 Get();
                 Unary();
                 BitOrExpr();
             }
         }
 
         void BitOrExpr()
         {
             BitXorExpr();
             while (la.kind == 124)
             {
                 Get();
                 Unary();
                 BitXorExpr();
             }
         }
 
         void BitXorExpr()
         {
             BitAndExpr();
             while (la.kind == 125)
             {
                 Get();
                 Unary();
                 BitAndExpr();
             }
         }
 
         void BitAndExpr()
         {
             EqlExpr();
             while (la.kind == 83)
             {
                 Get();
                 Unary();
                 EqlExpr();
             }
         }
 
         void EqlExpr()
         {
             RelExpr();
             while (la.kind == 92 || la.kind == 105)
             {
                 if (la.kind == 105)
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                 }
                 Unary();
                 RelExpr();
             }
         }
 
         void RelExpr()
         {
             ShiftExpr();
             while (StartOf(26))
             {
                 if (StartOf(27))
                 {
                     if (la.kind == 100)
                     {
                         Get();
                     }
                     else if (la.kind == 93)
                     {
                         Get();
                     }
                     else if (la.kind == 126)
                     {
                         Get();
                     }
                     else if (la.kind == 94)
                     {
                         Get();
                     }
                     else SynErr(185);
                     Unary();
                     ShiftExpr();
                 }
                 else
                 {
                     if (la.kind == 42)
                     {
                         Get();
                     }
                     else if (la.kind == 7)
                     {
                         Get();
                     }
                     else SynErr(186);
                     ResolvedType();
                 }
             }
         }
 
         void ShiftExpr()
         {
             AddExpr();
             while (IsShift())
             {
                 if (la.kind == 101)
                 {
                     Get();
                 }
                 else if (la.kind == 93)
                 {
                     Get();
                     Expect(93);
                 }
                 else SynErr(187);
                 Unary();
                 AddExpr();
             }
         }
 
         void AddExpr()
         {
             MulExpr();
             while (la.kind == 102 || la.kind == 108)
             {
                 if (la.kind == 108)
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                 }
                 Unary();
                 MulExpr();
             }
         }
 
         void MulExpr()
         {
             while (la.kind == 116 || la.kind == 127 || la.kind == 128)
             {
                 if (la.kind == 116)
                 {
                     Get();
                 }
                 else if (la.kind == 127)
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                 }
                 Unary();
             }
         }
 
         void Primary()
         {
             TypeKind type; bool isArrayCreation = false;
             switch (la.kind)
             {
                 case 2
                 case 3
                 case 4
                 case 5
                 case 29
                 case 47
                 case 70
                     {
                         Literal();
                         break;
                     }
                 case 98
                     {
                         Get();
                         Expression();
                         Expect(113);
                         break;
                     }
                 case 9
                 case 11
                 case 14
                 case 19
                 case 23
                 case 32
                 case 39
                 case 44
                 case 48
                 case 59
                 case 61
                 case 65
                 case 73
                 case 74
                 case 77
                     {
                         switch (la.kind)
                         {
                             case 9
                                 {
                                     Get();
                                     break;
                                 }
                             case 11
                                 {
                                     Get();
                                     break;
                                 }
                             case 14
                                 {
                                     Get();
                                     break;
                                 }
                             case 19
                                 {
                                     Get();
                                     break;
                                 }
                             case 23
                                 {
                                     Get();
                                     break;
                                 }
                             case 32
                                 {
                                     Get();
                                     break;
                                 }
                             case 39
                                 {
                                     Get();
                                     break;
                                 }
                             case 44
                                 {
                                     Get();
                                     break;
                                 }
                             case 48
                                 {
                                     Get();
                                     break;
                                 }
                             case 59
                                 {
                                     Get();
                                     break;
                                 }
                             case 61
                                 {
                                     Get();
                                     break;
                                 }
                             case 65
                                 {
                                     Get();
                                     break;
                                 }
                             case 73
                                 {
                                     Get();
                                     break;
                                 }
                             case 74
                                 {
                                     Get();
                                     break;
                                 }
                             case 77
                                 {
                                     Get();
                                     break;
                                 }
                         }
                         Expect(90);
                         Expect(1);
                         if (IsGeneric())
                         {
                             TypeArgumentList();
                         }
                         break;
                     }
                 case 1
                     {
                         Get();
                         if (la.kind == 91)
                         {
                             Get();
                             Expect(1);
                             if (la.kind == 100)
                             {
                                 TypeArgumentList();
                             }
                             Expect(90);
                             Expect(1);
                         }
                         if (IsGeneric())
                         {
                             TypeArgumentList();
                         }
                         break;
                     }
                 case 68
                     {
                         Get();
                         break;
                     }
                 case 8
                     {
                         Get();
                         if (la.kind == 90)
                         {
                             Get();
                             Expect(1);
                             if (IsGeneric())
                             {
                                 TypeArgumentList();
                             }
                         }
                         else if (la.kind == 97)
                         {
                             Get();
                             Expression();
                             while (la.kind == 87)
                             {
                                 Get();
                                 Expression();
                             }
                             Expect(112);
                         }
                         else SynErr(188);
                         break;
                     }
                 case 46
                     {
                         Get();
                         Type(out type, false);
                         if (la.kind == 98)
                         {
                             Get();
                             if (StartOf(15))
                             {
                                 Argument();
                                 while (la.kind == 87)
                                 {
                                     Get();
                                     Argument();
                                 }
                             }
                             Expect(113);
                         }
                         else if (la.kind == 97)
                         {
                             Get();
                             Expression();
                             while (la.kind == 87)
                             {
                                 Get();
                                 Expression();
                             }
                             Expect(112);
                             while (IsDims())
                             {
                                 Expect(97);
                                 while (la.kind == 87)
                                 {
                                     Get();
                                 }
                                 Expect(112);
                             }
                             if (la.kind == 96)
                             {
                                 ArrayInitializer();
                             }
                             isArrayCreation = true;
                         }
                         else if (la.kind == 96)
                         {
                             ArrayInitializer();
                             if (type != TypeKind.array) Error("array type expected");
                             isArrayCreation = true;
 
                         }
                         else SynErr(189);
                         break;
                     }
                 case 72
                     {
                         Get();
                         Expect(98);
                         Type(out type, true);
                         Expect(113);
                         break;
                     }
                 case 15
                     {
                         Get();
                         Expect(98);
                         Expression();
                         Expect(113);
                         break;
                     }
                 case 75
                     {
                         Get();
                         Expect(98);
                         Expression();
                         Expect(113);
                         break;
                     }
                 case 20
                     {
                         Get();
                         Expect(98);
                         Primary();
                         Expect(113);
                         break;
                     }
                 case 21
                     {
                         Get();
                         if (la.kind == 98)
                         {
                             Get();
                             if (StartOf(13))
                             {
                                 AnonymousMethodParameter();
                                 while (la.kind == 87)
                                 {
                                     Get();
                                     AnonymousMethodParameter();
                                 }
                             }
                             Expect(113);
                         }
                         Block();
                         break;
                     }
                 case 62
                     {
                         Get();
                         Expect(98);
                         Type(out type, false);
                         Expect(113);
                         break;
                     }
                 default
             }
             while (StartOf(28))
             {
                 switch (la.kind)
                 {
                     case 95
                         {
                             Get();
                             break;
                         }
                     case 88
                         {
                             Get();
                             break;
                         }
                     case 129
                         {
                             Get();
                             Expect(1);
                             if (IsGeneric())
                             {
                                 TypeArgumentList();
                             }
                             break;
                         }
                     case 90
                         {
                             Get();
                             Expect(1);
                             if (IsGeneric())
                             {
                                 TypeArgumentList();
                             }
                             break;
                         }
                     case 98
                         {
                             Get();
                             if (StartOf(15))
                             {
                                 Argument();
                                 while (la.kind == 87)
                                 {
                                     Get();
                                     Argument();
                                 }
                             }
                             Expect(113);
                             break;
                         }
                     case 97
                         {
                             if (isArrayCreation) Error("element access not allow on array creation");
                             Get();
                             Expression();
                             while (la.kind == 87)
                             {
                                 Get();
                                 Expression();
                             }
                             Expect(112);
                             break;
                         }
                 }
             }
         }
 
         void Literal()
         {
             switch (la.kind)
             {
                 case 2
                     {
                         Get();
                         break;
                     }
                 case 3
                     {
                         Get();
                         break;
                     }
                 case 4
                     {
                         Get();
                         break;
                     }
                 case 5
                     {
                         Get();
                         break;
                     }
                 case 70
                     {
                         Get();
                         break;
                     }
                 case 29
                     {
                         Get();
                         break;
                     }
                 case 47
                     {
                         Get();
                         break;
                     }
                 default
             }
         }
 
         void AnonymousMethodParameter()
         {
             TypeKind dummy;
             if (la.kind == 50 || la.kind == 57)
             {
                 if (la.kind == 57)
                 {
                     Get();
                 }
                 else
                 {
                     Get();
                 }
             }
             Type(out dummy, false);
             Expect(1);
         }
 
 
 
         public void Parse()
         {
             la = new Token();
             la.val = "";
             Get();
             CS2();
 
             Expect(0);
         }
 
         bool[,] set = {
 		{T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
 		{x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, T,x,x,x, x,T,x,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, T,T,x,x, x,T,T,x, x,x,x,T, x,T,T,T, T,x,x,x, T,x,x,x, T,x,T,x, x,x,x,x, x,x,x,x, T,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x},
 		{x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, T,x,x,x, x,T,x,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, T,T,x,x, x,x,T,x, x,x,x,T, x,T,T,T, T,x,x,x, T,x,x,x, T,x,T,x, x,x,x,x, x,x,x,x, T,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x},
 		{x,x,x,x, x,x,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
 		{x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,T,x, x,x,x,T, x,T,T,T, T,x,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, T,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
 		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x},
 		{x,T,x,x, x,x,x,x, x,T,x,T, x,x,T,x, x,x,x,T, x,x,x,T, x,x,T,x, x,x,x,x, T,x,x,x, x,x,x,T, x,x,x,x, T,x,T,x, T,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, x,T,x,x, x,x,x,x, x,T,T,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
 		{x,T,x,x, x,x,x,x, x,T,x,T, x,x,T,x, x,x,x,T, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,T, x,x,x,x, T,x,x,x, T,x,T,x, T,x,x,x, x,T,x,T, x,T,x,x, x,T,x,x, x,x,x,x, x,T,T,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
 		{x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
 		{x,T,x,x, x,x,T,x, x,T,x,T, x,x,T,x, T,T,x,T, x,T,x,T, x,T,T,T, T,x,x,x, T,x,x,x, x,T,x,T, T,T,x,x, T,x,T,x, T,x,x,T, x,T,T,T, T,x,x,T, T,T,x,x, T,T,T,x, x,x,x,x, x,T,T,x, T,T,x,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x},
 		{x,T,x,x, x,x,T,x, x,T,x,T, x,x,T,x, T,T,x,T, x,T,x,T, x,T,T,T, T,x,x,x, T,x,x,x, x,T,x,T, T,T,x,x, T,x,T,x, T,x,x,T, x,T,T,T, T,x,x,T, T,T,x,x, T,T,T,x, x,x,x,x, x,T,T,x, T,T,x,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x},
 		{x,T,x,x, x,x,x,x, x,T,x,T, x,x,T,x, x,x,x,T, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,T, x,x,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, x,T,x,x, x,x,x,x, x,T,T,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
 		{x,x,x,x, x,x,x,x, x,T,x,T, x,x,T,x, x,x,x,T, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
 		{x,T,x,x, x,x,x,x, x,T,x,T, x,x,T,x, x,x,x,T, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,T, x,x,x,x, T,x,x,x, T,x,T,x, x,x,x,x, x,T,x,T, x,T,x,x, x,T,x,x, x,x,x,x, x,T,T,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
 		{x,T,x,x, x,x,x,x, x,T,x,T, x,x,T,x, T,T,x,T, x,T,x,T, x,T,T,T, x,x,x,x, T,x,x,x, x,T,x,T, T,x,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, x,T,T,x, x,x,x,x, x,T,T,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x},
 		{x,T,T,T, T,T,x,x, T,T,x,T, x,x,T,T, x,x,x,T, T,T,x,T, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,T, x,x,x,x, T,x,T,T, T,x,T,x, x,x,x,x, x,T,x,T, x,T,T,x, x,T,x,x, T,x,T,x, T,T,T,T, x,T,x,x, x,x,x,T, x,x,x,x, T,x,x,x, x,x,x,T, x,x,T,x, x,x,T,x, x,x,T,x, T,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
 		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,T,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x},
 		{x,T,T,T, T,T,x,x, T,T,T,T, x,x,T,T, x,T,T,T, T,T,T,T, x,x,x,x, x,T,x,T, T,T,T,T, T,x,x,T, x,x,x,T, T,x,T,T, T,x,x,x, x,x,x,x, x,x,T,T, x,T,T,x, x,T,x,T, T,T,T,T, T,T,T,T, T,T,T,x, T,x,T,T, x,x,x,x, T,x,x,x, x,x,x,T, T,x,T,x, x,x,T,x, x,x,T,x, T,x,x,x, x,x,T,T, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x},
 		{x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,T,T, x,x,x,x, T,T,T,x, x,x,x,x, T,T,T,x, x,T,x,x, T,x,T,T, T,T,T,x, T,x,x,x, x,T,T,T, T,T,T,T, T,x,x,x},
 		{x,T,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,T,x, x,x,x,T, x,T,T,T, T,x,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, T,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
 		{x,T,T,T, T,T,x,x, T,T,x,T, x,x,T,T, x,x,x,T, T,T,x,T, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,T, x,x,x,x, T,x,T,T, T,x,x,x, x,x,x,x, x,x,x,T, x,T,T,x, x,T,x,x, T,x,T,x, T,T,T,T, x,T,x,x, x,x,x,T, x,x,x,x, T,x,x,x, x,x,x,T, T,x,T,x, x,x,T,x, x,x,T,x, T,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
 		{x,T,T,T, T,T,x,x, T,T,x,T, x,x,T,T, x,x,x,T, T,T,x,T, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,T, x,x,x,x, T,x,T,T, T,x,x,x, x,x,x,x, x,x,x,T, x,T,T,x, x,T,x,x, T,x,T,x, T,T,T,T, x,T,x,x, x,x,x,T, x,x,x,x, T,x,x,x, x,x,x,T, x,x,T,x, x,x,T,x, x,x,T,x, T,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
 		{x,x,x,x, x,x,x,x, x,x,x,T, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
 		{x,T,T,T, T,T,x,x, T,T,T,T, x,x,T,T, x,x,T,T, T,T,T,T, x,x,x,x, x,T,x,T, T,T,T,T, T,x,x,T, x,x,x,T, T,x,T,T, T,x,x,x, x,x,x,x, x,x,T,T, x,T,T,x, x,T,x,T, T,T,T,T, T,T,T,T, T,T,T,x, x,x,T,T, x,x,x,x, T,x,x,x, x,x,x,T, T,x,T,x, x,x,T,x, x,x,T,x, T,x,x,x, x,x,T,T, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x},
 		{x,T,T,T, T,T,x,x, T,T,x,T, x,x,T,T, x,x,x,T, T,T,x,T, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,T, x,x,x,x, T,x,T,T, T,x,x,x, x,x,x,x, x,x,x,T, x,T,T,x, x,T,x,x, T,x,T,x, T,T,T,T, x,T,x,x, T,x,x,T, x,x,x,x, T,x,x,x, x,x,x,T, x,x,T,x, x,x,T,x, x,x,T,x, T,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x},
 		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,x,x, x,T,x,x, x,T,x,x, x,x,x,T, x,x,x,T, T,x,x,T, x,T,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x},
 		{x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x},
 		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x},
 		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,x, x,x,x,T, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x}
 
 	};
     } // end Parser
 
 
     public class Errors
     {
         public int count = 0;                                    // number of errors detected
         public System.IO.TextWriter errorStream = Console.Out;   // error messages go to this stream
         public string errMsgFormat = "-- line {0} col {1}
 
         public void SynErr(int line, int col, int n)
         {
             string s;
             switch (n)
             {
                 case 0
                 case 1
                 case 2
                 case 3
                 case 4
                 case 5
                 case 6
                 case 7
                 case 8
                 case 9
                 case 10
                 case 11
                 case 12
                 case 13
                 case 14
                 case 15
                 case 16
                 case 17
                 case 18
                 case 19
                 case 20
                 case 21
                 case 22
                 case 23
                 case 24
                 case 25
                 case 26
                 case 27
                 case 28
                 case 29
                 case 30
                 case 31
                 case 32
                 case 33
                 case 34
                 case 35
                 case 36
                 case 37
                 case 38
                 case 39
                 case 40
                 case 41
                 case 42
                 case 43
                 case 44
                 case 45
                 case 46
                 case 47
                 case 48
                 case 49
                 case 50
                 case 51
                 case 52
                 case 53
                 case 54
                 case 55
                 case 56
                 case 57
                 case 58
                 case 59
                 case 60
                 case 61
                 case 62
                 case 63
                 case 64
                 case 65
                 case 66
                 case 67
                 case 68
                 case 69
                 case 70
                 case 71
                 case 72
                 case 73
                 case 74
                 case 75
                 case 76
                 case 77
                 case 78
                 case 79
                 case 80
                 case 81
                 case 82
                 case 83
                 case 84
                 case 85
                 case 86
                 case 87
                 case 88
                 case 89
                 case 90
                 case 91
                 case 92
                 case 93
                 case 94
                 case 95
                 case 96
                 case 97
                 case 98
                 case 99
                 case 100
                 case 101
                 case 102
                 case 103
                 case 104
                 case 105
                 case 106
                 case 107
                 case 108
                 case 109
                 case 110
                 case 111
                 case 112
                 case 113
                 case 114
                 case 115
                 case 116
                 case 117
                 case 118
                 case 119
                 case 120
                 case 121
                 case 122
                 case 123
                 case 124
                 case 125
                 case 126
                 case 127
                 case 128
                 case 129
                 case 130
                 case 131
                 case 132
                 case 133
                 case 134
                 case 135
                 case 136
                 case 137
                 case 138
                 case 139
                 case 140
                 case 141
                 case 142
                 case 143
                 case 144
                 case 145
                 case 146
                 case 147
                 case 148
                 case 149
                 case 150
                 case 151
                 case 152
                 case 153
                 case 154
                 case 155
                 case 156
                 case 157
                 case 158
                 case 159
                 case 160
                 case 161
                 case 162
                 case 163
                 case 164
                 case 165
                 case 166
                 case 167
                 case 168
                 case 169
                 case 170
                 case 171
                 case 172
                 case 173
                 case 174
                 case 175
                 case 176
                 case 177
                 case 178
                 case 179
                 case 180
                 case 181
                 case 182
                 case 183
                 case 184
                 case 185
                 case 186
                 case 187
                 case 188
                 case 189
                 case 190
                 case 191
 
                 default
             }
             errorStream.WriteLine(errMsgFormat, line, col, s);
             count++;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="4297" endline="4302"><![CDATA[
 
         public void SemErr(int line, int col, string s)
         {
             errorStream.WriteLine(errMsgFormat, line, col, s);
             count++;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="4303" endline="4308"><![CDATA[
 
         public void SemErr(string s)
         {
             errorStream.WriteLine(s);
             count++;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="4309" endline="4313"><![CDATA[
 
         public void Warning(int line, int col, string s)
         {
             errorStream.WriteLine(errMsgFormat, line, col, s);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="4314" endline="4318"><![CDATA[
 
         public void Warning(string s)
         {
             errorStream.WriteLine(s);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="4090" endline="4092"><![CDATA[
         public int count = 0;                                    // number of errors detected
         public System.IO.TextWriter errorStream = Console.Out;   // error messages go to this stream
         public string errMsgFormat = "-- line {0} col {1}
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="4093" endline="4324"><![CDATA[
 
         public void SynErr(int line, int col, int n)
         {
             string s;
             switch (n)
             {
                 case 0
                 case 1
                 case 2
                 case 3
                 case 4
                 case 5
                 case 6
                 case 7
                 case 8
                 case 9
                 case 10
                 case 11
                 case 12
                 case 13
                 case 14
                 case 15
                 case 16
                 case 17
                 case 18
                 case 19
                 case 20
                 case 21
                 case 22
                 case 23
                 case 24
                 case 25
                 case 26
                 case 27
                 case 28
                 case 29
                 case 30
                 case 31
                 case 32
                 case 33
                 case 34
                 case 35
                 case 36
                 case 37
                 case 38
                 case 39
                 case 40
                 case 41
                 case 42
                 case 43
                 case 44
                 case 45
                 case 46
                 case 47
                 case 48
                 case 49
                 case 50
                 case 51
                 case 52
                 case 53
                 case 54
                 case 55
                 case 56
                 case 57
                 case 58
                 case 59
                 case 60
                 case 61
                 case 62
                 case 63
                 case 64
                 case 65
                 case 66
                 case 67
                 case 68
                 case 69
                 case 70
                 case 71
                 case 72
                 case 73
                 case 74
                 case 75
                 case 76
                 case 77
                 case 78
                 case 79
                 case 80
                 case 81
                 case 82
                 case 83
                 case 84
                 case 85
                 case 86
                 case 87
                 case 88
                 case 89
                 case 90
                 case 91
                 case 92
                 case 93
                 case 94
                 case 95
                 case 96
                 case 97
                 case 98
                 case 99
                 case 100
                 case 101
                 case 102
                 case 103
                 case 104
                 case 105
                 case 106
                 case 107
                 case 108
                 case 109
                 case 110
                 case 111
                 case 112
                 case 113
                 case 114
                 case 115
                 case 116
                 case 117
                 case 118
                 case 119
                 case 120
                 case 121
                 case 122
                 case 123
                 case 124
                 case 125
                 case 126
                 case 127
                 case 128
                 case 129
                 case 130
                 case 131
                 case 132
                 case 133
                 case 134
                 case 135
                 case 136
                 case 137
                 case 138
                 case 139
                 case 140
                 case 141
                 case 142
                 case 143
                 case 144
                 case 145
                 case 146
                 case 147
                 case 148
                 case 149
                 case 150
                 case 151
                 case 152
                 case 153
                 case 154
                 case 155
                 case 156
                 case 157
                 case 158
                 case 159
                 case 160
                 case 161
                 case 162
                 case 163
                 case 164
                 case 165
                 case 166
                 case 167
                 case 168
                 case 169
                 case 170
                 case 171
                 case 172
                 case 173
                 case 174
                 case 175
                 case 176
                 case 177
                 case 178
                 case 179
                 case 180
                 case 181
                 case 182
                 case 183
                 case 184
                 case 185
                 case 186
                 case 187
                 case 188
                 case 189
                 case 190
                 case 191
 
                 default
             }
             errorStream.WriteLine(errMsgFormat, line, col, s);
             count++;
         }
 
         public void SemErr(int line, int col, string s)
         {
             errorStream.WriteLine(errMsgFormat, line, col, s);
             count++;
         }
 
         public void SemErr(string s)
         {
             errorStream.WriteLine(s);
             count++;
         }
 
         public void Warning(int line, int col, string s)
         {
             errorStream.WriteLine(errMsgFormat, line, col, s);
         }
 
         public void Warning(string s)
         {
             errorStream.WriteLine(s);
         }
     } // Errors
 
 
     public class FatalError 
     {
         public FatalError(string m) 
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="32" endline="40"><![CDATA[
         {
             // Make sure the plugin is not null...
             if (plugin == null)
             {
                 throw new ArgumentNullException("IPeterPlugin", "IPeterPlugin is null!");
             }
 
             return this.List.Add(plugin);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="41" endline="61"><![CDATA[
 
         #endregion
 
         #region Remove
 
         /// <summary>
         /// Removes a IPeterPlugin from the Collection...
         /// </summary>
         /// <param name="plugin">IPeterPlugin to remove...</param>
         public void Remove(IPeterPlugin plugin)
         {
             // Get the index of the plugin...
             int index = this.IndexOf(plugin);
 
             // Make sure it is a valid index...
             if (index != -1)
             {
                 // Remove Page...
                 this.RemoveAt(index);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="62" endline="79"><![CDATA[
 
         /// <summary>
         /// Removes all IPeterPlugins from the collection...
         /// </summary>
         public new void Clear()
         {
             if (this.Count == 0)
             {
                 // Nothing to do, return...
                 return;
             }
 
             // Clear the list...
             base.Clear();
 
             // Rest the Capacity...
             this.InnerList.Capacity = 0;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="80" endline="100"><![CDATA[
 
         /// <summary>
         /// Gets the index of a specified IPeterPlugin...
         /// </summary>
         /// <param name="plugin">IPeterPlugin to get index for...</param>
         /// <returns>Index of IPeterPlugin</returns>
         public int IndexOf(IPeterPlugin plugin)
         {
             // Look for the IPeterPlugin...
             for (int a = 0; a < this.Count; a++)
             {
                 if (this[a] == plugin)
                 {
                     // Found it...
                     return a;
                 }
             }
             for (int a = 0; a < this.Count; a++)
             {
                 if (this[a] == plugin)
                 {
                     // Found it...
                     return a;
                 }
             }
 
             // Not found...
             return -1;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="101" endline="123"><![CDATA[
 
         #endregion
 
         #region Properties
 
         /// <summary>
         /// Gets a IPeterPlugin at the requested Index...
         /// </summary>
         /// <param name="index">Index of IPeterPlugin...</param>
         /// <returns>IPeterPlugin at requested Index...</returns>
         public IPeterPlugin this[int index]
         {
             get
             {
                 // Make sure it is a valid index...
                 if (index < 0 || index >= this.Count)
                 {
                     return null;
                 }
 
                 // Return the tabber page...
                 return this.List[index] as IPeterPlugin;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="31" endline="37"><![CDATA[
         {
             if (disposing && (components != null))
             {
                 components.Dispose();
             }
             base.Dispose(disposing);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\CSParser\Parser.cs" startline="38" endline="1110"><![CDATA[
 
         #region Windows Form Designer generated code
 
         /// <summary>
         /// Required method for Designer support - do not modify
         /// the contents of this method with the code editor.
         /// </summary>
         private void InitializeComponent()
         {
             this.components = new System.ComponentModel.Container();
             System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainForm));
             this.toolStrip1 = new System.Windows.Forms.ToolStrip();
             this.tsbNew = new System.Windows.Forms.ToolStripButton();
             this.tsbOpen = new System.Windows.Forms.ToolStripButton();
             this.tsbSave = new System.Windows.Forms.ToolStripButton();
             this.tsbSaveAll = new System.Windows.Forms.ToolStripButton();
             this.tsbPrint = new System.Windows.Forms.ToolStripButton();
             this.toolStripSeparator1 = new System.Windows.Forms.ToolStripSeparator();
             this.tsbCut = new System.Windows.Forms.ToolStripButton();
             this.tsbCopy = new System.Windows.Forms.ToolStripButton();
             this.tsbPaste = new System.Windows.Forms.ToolStripButton();
             this.toolStripSeparator2 = new System.Windows.Forms.ToolStripSeparator();
             this.tsbUndo = new System.Windows.Forms.ToolStripButton();
             this.tsbRedo = new System.Windows.Forms.ToolStripButton();
             this.toolStripSeparator3 = new System.Windows.Forms.ToolStripSeparator();
             this.toolStripDropDownButton1 = new System.Windows.Forms.ToolStripDropDownButton();
             this.helpToolStripMenuItem2 = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuHelpAbout = new System.Windows.Forms.ToolStripMenuItem();
             this.txtFindNext = new System.Windows.Forms.ToolStripTextBox();
             this.tsbFind = new System.Windows.Forms.ToolStripButton();
             this.toolStripSeparator16 = new System.Windows.Forms.ToolStripSeparator();
             this.menuStrip1 = new System.Windows.Forms.MenuStrip();
             this.fileToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuFileNew = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuFileOpen = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuFileOpenRecent = new System.Windows.Forms.ToolStripMenuItem();
             this.toolStripSeparator4 = new System.Windows.Forms.ToolStripSeparator();
             this.mnuFileSave = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuFileSaveAs = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuFileSaveAll = new System.Windows.Forms.ToolStripMenuItem();
             this.toolStripSeparator5 = new System.Windows.Forms.ToolStripSeparator();
             this.mnuFileDifference = new System.Windows.Forms.ToolStripMenuItem();
             this.toolStripSeparator15 = new System.Windows.Forms.ToolStripSeparator();
             this.mnuFileExit = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuEdit = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuEditUndo = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuEditRedo = new System.Windows.Forms.ToolStripMenuItem();
             this.toolStripSeparator6 = new System.Windows.Forms.ToolStripSeparator();
             this.mnuEditCut = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuEditCopy = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuEditPaste = new System.Windows.Forms.ToolStripMenuItem();
             this.toolStripSeparator17 = new System.Windows.Forms.ToolStripSeparator();
             this.duplicateToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuEditDelete = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuEditSelectAll = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuSearch = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuSearchFind = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuSearchFindNext = new System.Windows.Forms.ToolStripMenuItem();
             this.findPreviousToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.findInFilesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.toolStripSeparator11 = new System.Windows.Forms.ToolStripSeparator();
             this.mnuSearchReplace = new System.Windows.Forms.ToolStripMenuItem();
             this.replaceNextToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.replaceInFilesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.projectToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuProjectShow = new System.Windows.Forms.ToolStripMenuItem();
             this.toolStripSeparator12 = new System.Windows.Forms.ToolStripSeparator();
             this.mnuProjectNew = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuProjectOpen = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuProjectReopen = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuCode = new System.Windows.Forms.ToolStripMenuItem();
             this.generateToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.surroundWithToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.toolStripSeparator13 = new System.Windows.Forms.ToolStripSeparator();
             this.mnuCodeLineComment = new System.Windows.Forms.ToolStripMenuItem();
             this.blockCommentToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.toolStripSeparator14 = new System.Windows.Forms.ToolStripSeparator();
             this.reformatCodeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.xMLToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.bookMarksToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuBookMarkToggle = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuBookMarkRemoveAll = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuBookMarkNext = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuBookMarkPrevious = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuHighlighting = new System.Windows.Forms.ToolStripMenuItem();
             this.runToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuRunCMD = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuPlugins = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuToolsFileExplorer = new System.Windows.Forms.ToolStripMenuItem();
             this.tsmiCodeStructure = new System.Windows.Forms.ToolStripMenuItem();
             this.mnuOptions = new System.Windows.Forms.ToolStripMenuItem();
             this.statMain = new System.Windows.Forms.StatusStrip();
             this.sslMain = new System.Windows.Forms.ToolStripStatusLabel();
             this.sslLine = new System.Windows.Forms.ToolStripStatusLabel();
             this.sslColumn = new System.Windows.Forms.ToolStripStatusLabel();
             this.sslInsert = new System.Windows.Forms.ToolStripStatusLabel();
             this.sslOther = new System.Windows.Forms.ToolStripStatusLabel();
             this.ofdMain = new System.Windows.Forms.OpenFileDialog();
             this.sfdMain = new System.Windows.Forms.SaveFileDialog();
             this.ctxEditor = new System.Windows.Forms.ContextMenuStrip(this.components);
             this.ctxUndo = new System.Windows.Forms.ToolStripMenuItem();
             this.ctxRedo = new System.Windows.Forms.ToolStripMenuItem();
             this.toolStripSeparator9 = new System.Windows.Forms.ToolStripSeparator();
             this.ctxCut = new System.Windows.Forms.ToolStripMenuItem();
             this.ctxCopy = new System.Windows.Forms.ToolStripMenuItem();
             this.ctxPaste = new System.Windows.Forms.ToolStripMenuItem();
             this.ctxDelete = new System.Windows.Forms.ToolStripMenuItem();
             this.toolStripSeparator8 = new System.Windows.Forms.ToolStripSeparator();
             this.ctxSelectAll = new System.Windows.Forms.ToolStripMenuItem();
             this.ctxTab = new System.Windows.Forms.ContextMenuStrip(this.components);
             this.saveToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.toolStripSeparator10 = new System.Windows.Forms.ToolStripSeparator();
             this.ctsClose = new System.Windows.Forms.ToolStripMenuItem();
             this.ctxCloseAllBut = new System.Windows.Forms.ToolStripMenuItem();
             this.toolStripSeparator7 = new System.Windows.Forms.ToolStripSeparator();
             this.copyPathToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.openFolderToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
             this.DockMain = new WeifenLuo.WinFormsUI.Docking.DockPanel();
             this.toolStrip1.SuspendLayout();
             this.menuStrip1.SuspendLayout();
             this.statMain.SuspendLayout();
             this.ctxEditor.SuspendLayout();
             this.ctxTab.SuspendLayout();
             this.SuspendLayout();
             // 
             // toolStrip1
             // 
             this.toolStrip1.GripStyle = System.Windows.Forms.ToolStripGripStyle.Hidden;
             this.toolStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.tsbNew,
             this.tsbOpen,
             this.tsbSave,
             this.tsbSaveAll,
             this.tsbPrint,
             this.toolStripSeparator1,
             this.tsbCut,
             this.tsbCopy,
             this.tsbPaste,
             this.toolStripSeparator2,
             this.tsbUndo,
             this.tsbRedo,
             this.toolStripSeparator3,
             this.toolStripDropDownButton1,
             this.txtFindNext,
             this.tsbFind,
             this.toolStripSeparator16});
             this.toolStrip1.Location = new System.Drawing.Point(0, 24);
             this.toolStrip1.Name = "toolStrip1";
             this.toolStrip1.Size = new System.Drawing.Size(1016, 25);
             this.toolStrip1.TabIndex = 3;
             // 
             // tsbNew
             // 
             this.tsbNew.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
             this.tsbNew.Image = ((System.Drawing.Image)(resources.GetObject("tsbNew.Image")));
             this.tsbNew.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.tsbNew.Name = "tsbNew";
             this.tsbNew.Size = new System.Drawing.Size(23, 22);
             this.tsbNew.Text = "toolStripSplitButton1";
             this.tsbNew.Click += new System.EventHandler(this.tsbNew_Click);
             // 
             // tsbOpen
             // 
             this.tsbOpen.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
             this.tsbOpen.Image = ((System.Drawing.Image)(resources.GetObject("tsbOpen.Image")));
             this.tsbOpen.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.tsbOpen.Name = "tsbOpen";
             this.tsbOpen.Size = new System.Drawing.Size(23, 22);
             this.tsbOpen.Text = "open";
             this.tsbOpen.Click += new System.EventHandler(this.tsbOpen_Click);
             // 
             // tsbSave
             // 
             this.tsbSave.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
             this.tsbSave.Image = ((System.Drawing.Image)(resources.GetObject("tsbSave.Image")));
             this.tsbSave.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.tsbSave.Name = "tsbSave";
             this.tsbSave.Size = new System.Drawing.Size(23, 22);
             this.tsbSave.Text = "Save";
             this.tsbSave.Click += new System.EventHandler(this.tsbSave_Click);
             // 
             // tsbSaveAll
             // 
             this.tsbSaveAll.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
             this.tsbSaveAll.Image = ((System.Drawing.Image)(resources.GetObject("tsbSaveAll.Image")));
             this.tsbSaveAll.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.tsbSaveAll.Name = "tsbSaveAll";
             this.tsbSaveAll.Size = new System.Drawing.Size(23, 22);
             this.tsbSaveAll.Text = "Save All";
             this.tsbSaveAll.Click += new System.EventHandler(this.tsbSaveAll_Click);
             // 
             // tsbPrint
             // 
             this.tsbPrint.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
             this.tsbPrint.Image = ((System.Drawing.Image)(resources.GetObject("tsbPrint.Image")));
             this.tsbPrint.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.tsbPrint.Name = "tsbPrint";
             this.tsbPrint.Size = new System.Drawing.Size(23, 22);
             this.tsbPrint.Text = "Print";
             this.tsbPrint.Click += new System.EventHandler(this.tsbPrint_Click);
             // 
             // toolStripSeparator1
             // 
             this.toolStripSeparator1.Name = "toolStripSeparator1";
             this.toolStripSeparator1.Size = new System.Drawing.Size(6, 25);
             // 
             // tsbCut
             // 
             this.tsbCut.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
             this.tsbCut.Image = ((System.Drawing.Image)(resources.GetObject("tsbCut.Image")));
             this.tsbCut.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.tsbCut.Name = "tsbCut";
             this.tsbCut.Size = new System.Drawing.Size(23, 22);
             this.tsbCut.Text = "Cut";
             this.tsbCut.Click += new System.EventHandler(this.tsbCut_Click);
             // 
             // tsbCopy
             // 
             this.tsbCopy.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
             this.tsbCopy.Image = ((System.Drawing.Image)(resources.GetObject("tsbCopy.Image")));
             this.tsbCopy.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.tsbCopy.Name = "tsbCopy";
             this.tsbCopy.Size = new System.Drawing.Size(23, 22);
             this.tsbCopy.Text = "Copy";
             this.tsbCopy.Click += new System.EventHandler(this.tsbCopy_Click);
             // 
             // tsbPaste
             // 
             this.tsbPaste.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
             this.tsbPaste.Image = ((System.Drawing.Image)(resources.GetObject("tsbPaste.Image")));
             this.tsbPaste.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.tsbPaste.Name = "tsbPaste";
             this.tsbPaste.Size = new System.Drawing.Size(23, 22);
             this.tsbPaste.Text = "Paste";
             this.tsbPaste.Click += new System.EventHandler(this.tsbPaste_Click);
             // 
             // toolStripSeparator2
             // 
             this.toolStripSeparator2.Name = "toolStripSeparator2";
             this.toolStripSeparator2.Size = new System.Drawing.Size(6, 25);
             // 
             // tsbUndo
             // 
             this.tsbUndo.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
             this.tsbUndo.Image = ((System.Drawing.Image)(resources.GetObject("tsbUndo.Image")));
             this.tsbUndo.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.tsbUndo.Name = "tsbUndo";
             this.tsbUndo.Size = new System.Drawing.Size(23, 22);
             this.tsbUndo.Text = "Undo";
             this.tsbUndo.Click += new System.EventHandler(this.tsbUndo_Click);
             // 
             // tsbRedo
             // 
             this.tsbRedo.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
             this.tsbRedo.Image = ((System.Drawing.Image)(resources.GetObject("tsbRedo.Image")));
             this.tsbRedo.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.tsbRedo.Name = "tsbRedo";
             this.tsbRedo.Size = new System.Drawing.Size(23, 22);
             this.tsbRedo.Text = "Redo";
             this.tsbRedo.Click += new System.EventHandler(this.tsbRedo_Click);
             // 
             // toolStripSeparator3
             // 
             this.toolStripSeparator3.Name = "toolStripSeparator3";
             this.toolStripSeparator3.Size = new System.Drawing.Size(6, 25);
             // 
             // toolStripDropDownButton1
             // 
             this.toolStripDropDownButton1.Alignment = System.Windows.Forms.ToolStripItemAlignment.Right;
             this.toolStripDropDownButton1.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.helpToolStripMenuItem2,
             this.mnuHelpAbout});
             this.toolStripDropDownButton1.Image = ((System.Drawing.Image)(resources.GetObject("toolStripDropDownButton1.Image")));
             this.toolStripDropDownButton1.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.toolStripDropDownButton1.Name = "toolStripDropDownButton1";
             this.toolStripDropDownButton1.Size = new System.Drawing.Size(57, 22);
             this.toolStripDropDownButton1.Text = "Help";
             // 
             // helpToolStripMenuItem2
             // 
             this.helpToolStripMenuItem2.Image = ((System.Drawing.Image)(resources.GetObject("helpToolStripMenuItem2.Image")));
             this.helpToolStripMenuItem2.Name = "helpToolStripMenuItem2";
             this.helpToolStripMenuItem2.Size = new System.Drawing.Size(114, 22);
             this.helpToolStripMenuItem2.Text = "Help";
             // 
             // mnuHelpAbout
             // 
             this.mnuHelpAbout.Image = ((System.Drawing.Image)(resources.GetObject("mnuHelpAbout.Image")));
             this.mnuHelpAbout.Name = "mnuHelpAbout";
             this.mnuHelpAbout.Size = new System.Drawing.Size(114, 22);
             this.mnuHelpAbout.Text = "About";
             this.mnuHelpAbout.Click += new System.EventHandler(this.mnuHelpAbout_Click);
             // 
             // txtFindNext
             // 
             this.txtFindNext.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
             this.txtFindNext.Name = "txtFindNext";
             this.txtFindNext.Size = new System.Drawing.Size(133, 25);
             // 
             // tsbFind
             // 
             this.tsbFind.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
             this.tsbFind.Image = ((System.Drawing.Image)(resources.GetObject("tsbFind.Image")));
             this.tsbFind.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.tsbFind.Name = "tsbFind";
             this.tsbFind.Size = new System.Drawing.Size(23, 22);
             this.tsbFind.Text = "Find Next";
             this.tsbFind.Click += new System.EventHandler(this.tsbFind_Click);
             // 
             // toolStripSeparator16
             // 
             this.toolStripSeparator16.Name = "toolStripSeparator16";
             this.toolStripSeparator16.Size = new System.Drawing.Size(6, 25);
             // 
             // menuStrip1
             // 
             this.menuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.fileToolStripMenuItem,
             this.mnuEdit,
             this.mnuSearch,
             this.projectToolStripMenuItem,
             this.mnuCode,
             this.bookMarksToolStripMenuItem,
             this.mnuHighlighting,
             this.runToolStripMenuItem,
             this.mnuPlugins,
             this.mnuOptions});
             this.menuStrip1.Location = new System.Drawing.Point(0, 0);
             this.menuStrip1.Name = "menuStrip1";
             this.menuStrip1.Size = new System.Drawing.Size(1016, 24);
             this.menuStrip1.TabIndex = 2;
             this.menuStrip1.Text = "menuStrip1";
             // 
             // fileToolStripMenuItem
             // 
             this.fileToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.mnuFileNew,
             this.mnuFileOpen,
             this.mnuFileOpenRecent,
             this.toolStripSeparator4,
             this.mnuFileSave,
             this.mnuFileSaveAs,
             this.mnuFileSaveAll,
             this.toolStripSeparator5,
             this.mnuFileDifference,
             this.toolStripSeparator15,
             this.mnuFileExit});
             this.fileToolStripMenuItem.Name = "fileToolStripMenuItem";
             this.fileToolStripMenuItem.Size = new System.Drawing.Size(35, 20);
             this.fileToolStripMenuItem.Text = "&File";
             // 
             // mnuFileNew
             // 
             this.mnuFileNew.Image = ((System.Drawing.Image)(resources.GetObject("mnuFileNew.Image")));
             this.mnuFileNew.Name = "mnuFileNew";
             this.mnuFileNew.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.N)));
             this.mnuFileNew.Size = new System.Drawing.Size(261, 22);
             this.mnuFileNew.Text = "&New";
             this.mnuFileNew.Click += new System.EventHandler(this.mnuFileNew_Click);
             // 
             // mnuFileOpen
             // 
             this.mnuFileOpen.Image = ((System.Drawing.Image)(resources.GetObject("mnuFileOpen.Image")));
             this.mnuFileOpen.Name = "mnuFileOpen";
             this.mnuFileOpen.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.O)));
             this.mnuFileOpen.Size = new System.Drawing.Size(261, 22);
             this.mnuFileOpen.Text = "&Open";
             this.mnuFileOpen.Click += new System.EventHandler(this.mnuFileOpen_Click);
             // 
             // mnuFileOpenRecent
             // 
             this.mnuFileOpenRecent.Image = ((System.Drawing.Image)(resources.GetObject("mnuFileOpenRecent.Image")));
             this.mnuFileOpenRecent.Name = "mnuFileOpenRecent";
             this.mnuFileOpenRecent.Size = new System.Drawing.Size(261, 22);
             this.mnuFileOpenRecent.Text = "Open &Recent";
             // 
             // toolStripSeparator4
             // 
             this.toolStripSeparator4.Name = "toolStripSeparator4";
             this.toolStripSeparator4.Size = new System.Drawing.Size(258, 6);
             // 
             // mnuFileSave
             // 
             this.mnuFileSave.Image = ((System.Drawing.Image)(resources.GetObject("mnuFileSave.Image")));
             this.mnuFileSave.Name = "mnuFileSave";
             this.mnuFileSave.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.S)));
             this.mnuFileSave.Size = new System.Drawing.Size(261, 22);
             this.mnuFileSave.Text = "&Save";
             this.mnuFileSave.Click += new System.EventHandler(this.mnuFileSave_Click);
             // 
             // mnuFileSaveAs
             // 
             this.mnuFileSaveAs.Image = ((System.Drawing.Image)(resources.GetObject("mnuFileSaveAs.Image")));
             this.mnuFileSaveAs.Name = "mnuFileSaveAs";
             this.mnuFileSaveAs.ShortcutKeys = ((System.Windows.Forms.Keys)((((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.Alt)
                         | System.Windows.Forms.Keys.Shift)
                         | System.Windows.Forms.Keys.S)));
             this.mnuFileSaveAs.Size = new System.Drawing.Size(261, 22);
             this.mnuFileSaveAs.Text = "Save &As";
             this.mnuFileSaveAs.Click += new System.EventHandler(this.mnuFileSaveAs_Click);
             // 
             // mnuFileSaveAll
             // 
             this.mnuFileSaveAll.Image = ((System.Drawing.Image)(resources.GetObject("mnuFileSaveAll.Image")));
             this.mnuFileSaveAll.Name = "mnuFileSaveAll";
             this.mnuFileSaveAll.ShortcutKeys = ((System.Windows.Forms.Keys)(((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.Shift)
                         | System.Windows.Forms.Keys.S)));
             this.mnuFileSaveAll.Size = new System.Drawing.Size(261, 22);
             this.mnuFileSaveAll.Text = "Save A&ll";
             this.mnuFileSaveAll.Click += new System.EventHandler(this.mnuFileSaveAll_Click);
             // 
             // toolStripSeparator5
             // 
             this.toolStripSeparator5.Name = "toolStripSeparator5";
             this.toolStripSeparator5.Size = new System.Drawing.Size(258, 6);
             // 
             // mnuFileDifference
             // 
             this.mnuFileDifference.Image = ((System.Drawing.Image)(resources.GetObject("mnuFileDifference.Image")));
             this.mnuFileDifference.Name = "mnuFileDifference";
             this.mnuFileDifference.ShortcutKeys = ((System.Windows.Forms.Keys)((((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.Alt)
                         | System.Windows.Forms.Keys.Shift)
                         | System.Windows.Forms.Keys.D)));
             this.mnuFileDifference.Size = new System.Drawing.Size(261, 22);
             this.mnuFileDifference.Text = "File Differences...";
             this.mnuFileDifference.Click += new System.EventHandler(this.mnuFileDifference_Click);
             // 
             // toolStripSeparator15
             // 
             this.toolStripSeparator15.Name = "toolStripSeparator15";
             this.toolStripSeparator15.Size = new System.Drawing.Size(258, 6);
             // 
             // mnuFileExit
             // 
             this.mnuFileExit.Image = ((System.Drawing.Image)(resources.GetObject("mnuFileExit.Image")));
             this.mnuFileExit.Name = "mnuFileExit";
             this.mnuFileExit.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Alt | System.Windows.Forms.Keys.F4)));
             this.mnuFileExit.Size = new System.Drawing.Size(261, 22);
             this.mnuFileExit.Text = "E&xit";
             this.mnuFileExit.Click += new System.EventHandler(this.mnuFileExit_Click);
             // 
             // mnuEdit
             // 
             this.mnuEdit.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.mnuEditUndo,
             this.mnuEditRedo,
             this.toolStripSeparator6,
             this.mnuEditCut,
             this.mnuEditCopy,
             this.mnuEditPaste,
             this.toolStripSeparator17,
             this.duplicateToolStripMenuItem,
             this.mnuEditDelete,
             this.mnuEditSelectAll});
             this.mnuEdit.Name = "mnuEdit";
             this.mnuEdit.Size = new System.Drawing.Size(37, 20);
             this.mnuEdit.Text = "&Edit";
             // 
             // mnuEditUndo
             // 
             this.mnuEditUndo.Image = ((System.Drawing.Image)(resources.GetObject("mnuEditUndo.Image")));
             this.mnuEditUndo.Name = "mnuEditUndo";
             this.mnuEditUndo.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.Z)));
             this.mnuEditUndo.Size = new System.Drawing.Size(168, 22);
             this.mnuEditUndo.Text = "&Undo";
             this.mnuEditUndo.Click += new System.EventHandler(this.mnuEditUndo_Click);
             // 
             // mnuEditRedo
             // 
             this.mnuEditRedo.Image = ((System.Drawing.Image)(resources.GetObject("mnuEditRedo.Image")));
             this.mnuEditRedo.Name = "mnuEditRedo";
             this.mnuEditRedo.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.Y)));
             this.mnuEditRedo.Size = new System.Drawing.Size(168, 22);
             this.mnuEditRedo.Text = "&Redo";
             this.mnuEditRedo.Click += new System.EventHandler(this.mnuEditRedo_Click);
             // 
             // toolStripSeparator6
             // 
             this.toolStripSeparator6.Name = "toolStripSeparator6";
             this.toolStripSeparator6.Size = new System.Drawing.Size(165, 6);
             // 
             // mnuEditCut
             // 
             this.mnuEditCut.Image = ((System.Drawing.Image)(resources.GetObject("mnuEditCut.Image")));
             this.mnuEditCut.Name = "mnuEditCut";
             this.mnuEditCut.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.X)));
             this.mnuEditCut.Size = new System.Drawing.Size(168, 22);
             this.mnuEditCut.Text = "C&ut";
             this.mnuEditCut.Click += new System.EventHandler(this.mnuEditCut_Click);
             // 
             // mnuEditCopy
             // 
             this.mnuEditCopy.Image = ((System.Drawing.Image)(resources.GetObject("mnuEditCopy.Image")));
             this.mnuEditCopy.Name = "mnuEditCopy";
             this.mnuEditCopy.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.C)));
             this.mnuEditCopy.Size = new System.Drawing.Size(168, 22);
             this.mnuEditCopy.Text = "&Copy";
             this.mnuEditCopy.Click += new System.EventHandler(this.mnuEditCopy_Click);
             // 
             // mnuEditPaste
             // 
             this.mnuEditPaste.Image = ((System.Drawing.Image)(resources.GetObject("mnuEditPaste.Image")));
             this.mnuEditPaste.Name = "mnuEditPaste";
             this.mnuEditPaste.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.V)));
             this.mnuEditPaste.Size = new System.Drawing.Size(168, 22);
             this.mnuEditPaste.Text = "&Paste";
             this.mnuEditPaste.Click += new System.EventHandler(this.mnuEditPaste_Click);
             // 
             // toolStripSeparator17
             // 
             this.toolStripSeparator17.Name = "toolStripSeparator17";
             this.toolStripSeparator17.Size = new System.Drawing.Size(165, 6);
             // 
             // duplicateToolStripMenuItem
             // 
             this.duplicateToolStripMenuItem.Image = ((System.Drawing.Image)(resources.GetObject("duplicateToolStripMenuItem.Image")));
             this.duplicateToolStripMenuItem.Name = "duplicateToolStripMenuItem";
             this.duplicateToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.D)));
             this.duplicateToolStripMenuItem.Size = new System.Drawing.Size(168, 22);
             this.duplicateToolStripMenuItem.Text = "D&uplicate";
             this.duplicateToolStripMenuItem.Click += new System.EventHandler(this.duplicateToolStripMenuItem_Click);
             // 
             // mnuEditDelete
             // 
             this.mnuEditDelete.Image = ((System.Drawing.Image)(resources.GetObject("mnuEditDelete.Image")));
             this.mnuEditDelete.Name = "mnuEditDelete";
             this.mnuEditDelete.ShortcutKeys = System.Windows.Forms.Keys.Delete;
             this.mnuEditDelete.Size = new System.Drawing.Size(168, 22);
             this.mnuEditDelete.Text = "&Delete";
             this.mnuEditDelete.Click += new System.EventHandler(this.mnuEditDelete_Click);
             // 
             // mnuEditSelectAll
             // 
             this.mnuEditSelectAll.Name = "mnuEditSelectAll";
             this.mnuEditSelectAll.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.A)));
             this.mnuEditSelectAll.Size = new System.Drawing.Size(168, 22);
             this.mnuEditSelectAll.Text = "&Select All";
             this.mnuEditSelectAll.Click += new System.EventHandler(this.mnuEditSelectAll_Click);
             // 
             // mnuSearch
             // 
             this.mnuSearch.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.mnuSearchFind,
             this.mnuSearchFindNext,
             this.findPreviousToolStripMenuItem,
             this.findInFilesToolStripMenuItem,
             this.toolStripSeparator11,
             this.mnuSearchReplace,
             this.replaceNextToolStripMenuItem,
             this.replaceInFilesToolStripMenuItem});
             this.mnuSearch.Name = "mnuSearch";
             this.mnuSearch.Size = new System.Drawing.Size(52, 20);
             this.mnuSearch.Text = "&Search";
             // 
             // mnuSearchFind
             // 
             this.mnuSearchFind.Image = ((System.Drawing.Image)(resources.GetObject("mnuSearchFind.Image")));
             this.mnuSearchFind.Name = "mnuSearchFind";
             this.mnuSearchFind.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.F)));
             this.mnuSearchFind.Size = new System.Drawing.Size(227, 22);
             this.mnuSearchFind.Text = "&Find...";
             this.mnuSearchFind.Click += new System.EventHandler(this.mnuSearchFind_Click);
             // 
             // mnuSearchFindNext
             // 
             this.mnuSearchFindNext.Image = ((System.Drawing.Image)(resources.GetObject("mnuSearchFindNext.Image")));
             this.mnuSearchFindNext.Name = "mnuSearchFindNext";
             this.mnuSearchFindNext.ShortcutKeys = System.Windows.Forms.Keys.F3;
             this.mnuSearchFindNext.Size = new System.Drawing.Size(227, 22);
             this.mnuSearchFindNext.Text = "Find Next";
             this.mnuSearchFindNext.Click += new System.EventHandler(this.mnuSearchFindNext_Click);
             // 
             // findPreviousToolStripMenuItem
             // 
             this.findPreviousToolStripMenuItem.Name = "findPreviousToolStripMenuItem";
             this.findPreviousToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Shift | System.Windows.Forms.Keys.F3)));
             this.findPreviousToolStripMenuItem.Size = new System.Drawing.Size(227, 22);
             this.findPreviousToolStripMenuItem.Text = "Find Previous";
             this.findPreviousToolStripMenuItem.Click += new System.EventHandler(this.findPreviousToolStripMenuItem_Click);
             // 
             // findInFilesToolStripMenuItem
             // 
             this.findInFilesToolStripMenuItem.Name = "findInFilesToolStripMenuItem";
             this.findInFilesToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)(((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.Shift)
                         | System.Windows.Forms.Keys.F)));
             this.findInFilesToolStripMenuItem.Size = new System.Drawing.Size(227, 22);
             this.findInFilesToolStripMenuItem.Text = "Find in Files";
             this.findInFilesToolStripMenuItem.Click += new System.EventHandler(this.findInFilesToolStripMenuItem_Click);
             // 
             // toolStripSeparator11
             // 
             this.toolStripSeparator11.Name = "toolStripSeparator11";
             this.toolStripSeparator11.Size = new System.Drawing.Size(224, 6);
             // 
             // mnuSearchReplace
             // 
             this.mnuSearchReplace.Image = ((System.Drawing.Image)(resources.GetObject("mnuSearchReplace.Image")));
             this.mnuSearchReplace.Name = "mnuSearchReplace";
             this.mnuSearchReplace.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.H)));
             this.mnuSearchReplace.Size = new System.Drawing.Size(227, 22);
             this.mnuSearchReplace.Text = "Replace";
             this.mnuSearchReplace.Click += new System.EventHandler(this.mnuSearchReplace_Click);
             // 
             // replaceNextToolStripMenuItem
             // 
             this.replaceNextToolStripMenuItem.Name = "replaceNextToolStripMenuItem";
             this.replaceNextToolStripMenuItem.ShortcutKeys = System.Windows.Forms.Keys.F4;
             this.replaceNextToolStripMenuItem.Size = new System.Drawing.Size(227, 22);
             this.replaceNextToolStripMenuItem.Text = "Replace Next";
             this.replaceNextToolStripMenuItem.Click += new System.EventHandler(this.replaceNextToolStripMenuItem_Click);
             // 
             // replaceInFilesToolStripMenuItem
             // 
             this.replaceInFilesToolStripMenuItem.Name = "replaceInFilesToolStripMenuItem";
             this.replaceInFilesToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)(((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.Shift)
                         | System.Windows.Forms.Keys.H)));
             this.replaceInFilesToolStripMenuItem.Size = new System.Drawing.Size(227, 22);
             this.replaceInFilesToolStripMenuItem.Text = "Replace in Files";
             this.replaceInFilesToolStripMenuItem.Click += new System.EventHandler(this.replaceInFilesToolStripMenuItem_Click);
             // 
             // projectToolStripMenuItem
             // 
             this.projectToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.mnuProjectShow,
             this.toolStripSeparator12,
             this.mnuProjectNew,
             this.mnuProjectOpen,
             this.mnuProjectReopen});
             this.projectToolStripMenuItem.Name = "projectToolStripMenuItem";
             this.projectToolStripMenuItem.Size = new System.Drawing.Size(53, 20);
             this.projectToolStripMenuItem.Text = "&Project";
             // 
             // mnuProjectShow
             // 
             this.mnuProjectShow.Image = ((System.Drawing.Image)(resources.GetObject("mnuProjectShow.Image")));
             this.mnuProjectShow.Name = "mnuProjectShow";
             this.mnuProjectShow.Size = new System.Drawing.Size(160, 22);
             this.mnuProjectShow.Text = "Show Manager";
             this.mnuProjectShow.Click += new System.EventHandler(this.mnuProjectShow_Click);
             // 
             // toolStripSeparator12
             // 
             this.toolStripSeparator12.Name = "toolStripSeparator12";
             this.toolStripSeparator12.Size = new System.Drawing.Size(157, 6);
             // 
             // mnuProjectNew
             // 
             this.mnuProjectNew.Image = ((System.Drawing.Image)(resources.GetObject("mnuProjectNew.Image")));
             this.mnuProjectNew.Name = "mnuProjectNew";
             this.mnuProjectNew.Size = new System.Drawing.Size(160, 22);
             this.mnuProjectNew.Text = "New Project";
             this.mnuProjectNew.Click += new System.EventHandler(this.mnuProjectNew_Click);
             // 
             // mnuProjectOpen
             // 
             this.mnuProjectOpen.Image = ((System.Drawing.Image)(resources.GetObject("mnuProjectOpen.Image")));
             this.mnuProjectOpen.Name = "mnuProjectOpen";
             this.mnuProjectOpen.Size = new System.Drawing.Size(160, 22);
             this.mnuProjectOpen.Text = "Open Project...";
             this.mnuProjectOpen.Click += new System.EventHandler(this.mnuProjectOpen_Click);
             // 
             // mnuProjectReopen
             // 
             this.mnuProjectReopen.Image = ((System.Drawing.Image)(resources.GetObject("mnuProjectReopen.Image")));
             this.mnuProjectReopen.Name = "mnuProjectReopen";
             this.mnuProjectReopen.Size = new System.Drawing.Size(160, 22);
             this.mnuProjectReopen.Text = "Open Recent";
             // 
             // mnuCode
             // 
             this.mnuCode.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.generateToolStripMenuItem,
             this.surroundWithToolStripMenuItem,
             this.toolStripSeparator13,
             this.mnuCodeLineComment,
             this.blockCommentToolStripMenuItem,
             this.toolStripSeparator14,
             this.reformatCodeToolStripMenuItem});
             this.mnuCode.Name = "mnuCode";
             this.mnuCode.Size = new System.Drawing.Size(44, 20);
             this.mnuCode.Text = "&Code";
             // 
             // generateToolStripMenuItem
             // 
             this.generateToolStripMenuItem.Name = "generateToolStripMenuItem";
             this.generateToolStripMenuItem.Size = new System.Drawing.Size(221, 22);
             this.generateToolStripMenuItem.Text = "Generate...";
             // 
             // surroundWithToolStripMenuItem
             // 
             this.surroundWithToolStripMenuItem.Name = "surroundWithToolStripMenuItem";
             this.surroundWithToolStripMenuItem.Size = new System.Drawing.Size(221, 22);
             this.surroundWithToolStripMenuItem.Text = "Surround With...";
             // 
             // toolStripSeparator13
             // 
             this.toolStripSeparator13.Name = "toolStripSeparator13";
             this.toolStripSeparator13.Size = new System.Drawing.Size(218, 6);
             // 
             // mnuCodeLineComment
             // 
             this.mnuCodeLineComment.Name = "mnuCodeLineComment";
             this.mnuCodeLineComment.ShortcutKeys = ((System.Windows.Forms.Keys)(((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.Shift)
                         | System.Windows.Forms.Keys.C)));
             this.mnuCodeLineComment.Size = new System.Drawing.Size(221, 22);
             this.mnuCodeLineComment.Text = "Line Comment";
             this.mnuCodeLineComment.Click += new System.EventHandler(this.mnuCodeLineComment_Click);
             // 
             // blockCommentToolStripMenuItem
             // 
             this.blockCommentToolStripMenuItem.Name = "blockCommentToolStripMenuItem";
             this.blockCommentToolStripMenuItem.Size = new System.Drawing.Size(221, 22);
             this.blockCommentToolStripMenuItem.Text = "Block Comment";
             // 
             // toolStripSeparator14
             // 
             this.toolStripSeparator14.Name = "toolStripSeparator14";
             this.toolStripSeparator14.Size = new System.Drawing.Size(218, 6);
             // 
             // reformatCodeToolStripMenuItem
             // 
             this.reformatCodeToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.xMLToolStripMenuItem});
             this.reformatCodeToolStripMenuItem.Name = "reformatCodeToolStripMenuItem";
             this.reformatCodeToolStripMenuItem.Size = new System.Drawing.Size(221, 22);
             this.reformatCodeToolStripMenuItem.Text = "Reformat Code";
             // 
             // xMLToolStripMenuItem
             // 
             this.xMLToolStripMenuItem.Name = "xMLToolStripMenuItem";
             this.xMLToolStripMenuItem.Size = new System.Drawing.Size(104, 22);
             this.xMLToolStripMenuItem.Text = "XML";
             this.xMLToolStripMenuItem.Click += new System.EventHandler(this.xMLToolStripMenuItem_Click);
             // 
             // bookMarksToolStripMenuItem
             // 
             this.bookMarksToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.mnuBookMarkToggle,
             this.mnuBookMarkRemoveAll,
             this.mnuBookMarkNext,
             this.mnuBookMarkPrevious});
             this.bookMarksToolStripMenuItem.Name = "bookMarksToolStripMenuItem";
             this.bookMarksToolStripMenuItem.Size = new System.Drawing.Size(73, 20);
             this.bookMarksToolStripMenuItem.Text = "&Book Marks";
             // 
             // mnuBookMarkToggle
             // 
             this.mnuBookMarkToggle.Image = ((System.Drawing.Image)(resources.GetObject("mnuBookMarkToggle.Image")));
             this.mnuBookMarkToggle.Name = "mnuBookMarkToggle";
             this.mnuBookMarkToggle.ShortcutKeys = System.Windows.Forms.Keys.F2;
             this.mnuBookMarkToggle.Size = new System.Drawing.Size(230, 22);
             this.mnuBookMarkToggle.Text = "&Toggle Book Mark";
             this.mnuBookMarkToggle.Click += new System.EventHandler(this.mnuBookMarkToggle_Click);
             // 
             // mnuBookMarkRemoveAll
             // 
             this.mnuBookMarkRemoveAll.Image = ((System.Drawing.Image)(resources.GetObject("mnuBookMarkRemoveAll.Image")));
             this.mnuBookMarkRemoveAll.Name = "mnuBookMarkRemoveAll";
             this.mnuBookMarkRemoveAll.ShortcutKeys = ((System.Windows.Forms.Keys)(((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.Shift)
                         | System.Windows.Forms.Keys.F2)));
             this.mnuBookMarkRemoveAll.Size = new System.Drawing.Size(230, 22);
             this.mnuBookMarkRemoveAll.Text = "&Remove All";
             this.mnuBookMarkRemoveAll.Click += new System.EventHandler(this.mnuBookMarkRemoveAll_Click);
             // 
             // mnuBookMarkNext
             // 
             this.mnuBookMarkNext.Image = ((System.Drawing.Image)(resources.GetObject("mnuBookMarkNext.Image")));
             this.mnuBookMarkNext.Name = "mnuBookMarkNext";
             this.mnuBookMarkNext.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.F2)));
             this.mnuBookMarkNext.Size = new System.Drawing.Size(230, 22);
             this.mnuBookMarkNext.Text = "Go to &Next Mark";
             this.mnuBookMarkNext.Click += new System.EventHandler(this.mnuBookMarkNext_Click);
             // 
             // mnuBookMarkPrevious
             // 
             this.mnuBookMarkPrevious.Image = ((System.Drawing.Image)(resources.GetObject("mnuBookMarkPrevious.Image")));
             this.mnuBookMarkPrevious.Name = "mnuBookMarkPrevious";
             this.mnuBookMarkPrevious.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Shift | System.Windows.Forms.Keys.F2)));
             this.mnuBookMarkPrevious.Size = new System.Drawing.Size(230, 22);
             this.mnuBookMarkPrevious.Text = "Go to &Previous Mark";
             this.mnuBookMarkPrevious.Click += new System.EventHandler(this.mnuBookMarkPrevious_Click);
             // 
             // mnuHighlighting
             // 
             this.mnuHighlighting.Name = "mnuHighlighting";
             this.mnuHighlighting.Size = new System.Drawing.Size(74, 20);
             this.mnuHighlighting.Text = "&Highlighting";
             // 
             // runToolStripMenuItem
             // 
             this.runToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.mnuRunCMD});
             this.runToolStripMenuItem.Name = "runToolStripMenuItem";
             this.runToolStripMenuItem.Size = new System.Drawing.Size(38, 20);
             this.runToolStripMenuItem.Text = "&Run";
             // 
             // mnuRunCMD
             // 
             this.mnuRunCMD.Image = ((System.Drawing.Image)(resources.GetObject("mnuRunCMD.Image")));
             this.mnuRunCMD.Name = "mnuRunCMD";
             this.mnuRunCMD.ShortcutKeys = System.Windows.Forms.Keys.F8;
             this.mnuRunCMD.Size = new System.Drawing.Size(188, 22);
             this.mnuRunCMD.Text = "&Command Prompt";
             this.mnuRunCMD.Click += new System.EventHandler(this.mnuRunCMD_Click);
             // 
             // mnuPlugins
             // 
             this.mnuPlugins.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.mnuToolsFileExplorer,
             this.tsmiCodeStructure});
             this.mnuPlugins.Name = "mnuPlugins";
             this.mnuPlugins.Size = new System.Drawing.Size(44, 20);
             this.mnuPlugins.Text = "&Tools";
             // 
             // mnuToolsFileExplorer
             // 
             this.mnuToolsFileExplorer.Image = global
             this.mnuToolsFileExplorer.Name = "mnuToolsFileExplorer";
             this.mnuToolsFileExplorer.Size = new System.Drawing.Size(158, 22);
             this.mnuToolsFileExplorer.Text = "File Explorer";
             this.mnuToolsFileExplorer.Click += new System.EventHandler(this.mnuToolsFileExplorer_Click);
             // 
             // tsmiCodeStructure
             // 
             this.tsmiCodeStructure.Image = global
             this.tsmiCodeStructure.Name = "tsmiCodeStructure";
             this.tsmiCodeStructure.Size = new System.Drawing.Size(158, 22);
             this.tsmiCodeStructure.Text = "Code Structure";
             this.tsmiCodeStructure.Click += new System.EventHandler(this.tsmiCodeStructure_Click);
             // 
             // mnuOptions
             // 
             this.mnuOptions.Alignment = System.Windows.Forms.ToolStripItemAlignment.Right;
             this.mnuOptions.Image = ((System.Drawing.Image)(resources.GetObject("mnuOptions.Image")));
             this.mnuOptions.Name = "mnuOptions";
             this.mnuOptions.Size = new System.Drawing.Size(72, 20);
             this.mnuOptions.Text = "&Options";
             this.mnuOptions.Click += new System.EventHandler(this.mnuOptions_Click);
             // 
             // statMain
             // 
             this.statMain.GripStyle = System.Windows.Forms.ToolStripGripStyle.Visible;
             this.statMain.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.sslMain,
             this.sslLine,
             this.sslColumn,
             this.sslInsert,
             this.sslOther});
             this.statMain.Location = new System.Drawing.Point(0, 719);
             this.statMain.Name = "statMain";
             this.statMain.RenderMode = System.Windows.Forms.ToolStripRenderMode.ManagerRenderMode;
             this.statMain.Size = new System.Drawing.Size(1016, 22);
             this.statMain.TabIndex = 4;
             // 
             // sslMain
             // 
             this.sslMain.BorderStyle = System.Windows.Forms.Border3DStyle.Etched;
             this.sslMain.Name = "sslMain";
             this.sslMain.Size = new System.Drawing.Size(1001, 17);
             this.sslMain.Spring = true;
             this.sslMain.Text = "Welcome";
             this.sslMain.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
             // 
             // sslLine
             // 
             this.sslLine.Name = "sslLine";
             this.sslLine.Size = new System.Drawing.Size(0, 17);
             // 
             // sslColumn
             // 
             this.sslColumn.Name = "sslColumn";
             this.sslColumn.Size = new System.Drawing.Size(0, 17);
             // 
             // sslInsert
             // 
             this.sslInsert.Name = "sslInsert";
             this.sslInsert.Size = new System.Drawing.Size(0, 17);
             // 
             // sslOther
             // 
             this.sslOther.Name = "sslOther";
             this.sslOther.Size = new System.Drawing.Size(0, 17);
             // 
             // ofdMain
             // 
             this.ofdMain.Multiselect = true;
             this.ofdMain.SupportMultiDottedExtensions = true;
             // 
             // ctxEditor
             // 
             this.ctxEditor.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.ctxUndo,
             this.ctxRedo,
             this.toolStripSeparator9,
             this.ctxCut,
             this.ctxCopy,
             this.ctxPaste,
             this.ctxDelete,
             this.toolStripSeparator8,
             this.ctxSelectAll});
             this.ctxEditor.Name = "ctxEditor";
             this.ctxEditor.Size = new System.Drawing.Size(165, 170);
             // 
             // ctxUndo
             // 
             this.ctxUndo.Image = ((System.Drawing.Image)(resources.GetObject("ctxUndo.Image")));
             this.ctxUndo.Name = "ctxUndo";
             this.ctxUndo.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.Z)));
             this.ctxUndo.Size = new System.Drawing.Size(164, 22);
             this.ctxUndo.Text = "Undo";
             this.ctxUndo.Click += new System.EventHandler(this.ctxUndo_Click);
             // 
             // ctxRedo
             // 
             this.ctxRedo.Image = ((System.Drawing.Image)(resources.GetObject("ctxRedo.Image")));
             this.ctxRedo.Name = "ctxRedo";
             this.ctxRedo.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.Y)));
             this.ctxRedo.Size = new System.Drawing.Size(164, 22);
             this.ctxRedo.Text = "Redo";
             this.ctxRedo.Click += new System.EventHandler(this.ctxRedo_Click);
             // 
             // toolStripSeparator9
             // 
             this.toolStripSeparator9.Name = "toolStripSeparator9";
             this.toolStripSeparator9.Size = new System.Drawing.Size(161, 6);
             // 
             // ctxCut
             // 
             this.ctxCut.Image = ((System.Drawing.Image)(resources.GetObject("ctxCut.Image")));
             this.ctxCut.Name = "ctxCut";
             this.ctxCut.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.X)));
             this.ctxCut.Size = new System.Drawing.Size(164, 22);
             this.ctxCut.Text = "Cut";
             this.ctxCut.Click += new System.EventHandler(this.ctxCut_Click);
             // 
             // ctxCopy
             // 
             this.ctxCopy.Image = ((System.Drawing.Image)(resources.GetObject("ctxCopy.Image")));
             this.ctxCopy.Name = "ctxCopy";
             this.ctxCopy.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.C)));
             this.ctxCopy.Size = new System.Drawing.Size(164, 22);
             this.ctxCopy.Text = "Copy";
             this.ctxCopy.Click += new System.EventHandler(this.ctxCopy_Click);
             // 
             // ctxPaste
             // 
             this.ctxPaste.Image = ((System.Drawing.Image)(resources.GetObject("ctxPaste.Image")));
             this.ctxPaste.Name = "ctxPaste";
             this.ctxPaste.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.V)));
             this.ctxPaste.Size = new System.Drawing.Size(164, 22);
             this.ctxPaste.Text = "Paste";
             this.ctxPaste.Click += new System.EventHandler(this.ctxPaste_Click);
             // 
             // ctxDelete
             // 
             this.ctxDelete.Image = ((System.Drawing.Image)(resources.GetObject("ctxDelete.Image")));
             this.ctxDelete.Name = "ctxDelete";
             this.ctxDelete.ShortcutKeys = System.Windows.Forms.Keys.Delete;
             this.ctxDelete.Size = new System.Drawing.Size(164, 22);
             this.ctxDelete.Text = "Delete";
             this.ctxDelete.Click += new System.EventHandler(this.ctxDelete_Click);
             // 
             // toolStripSeparator8
             // 
             this.toolStripSeparator8.Name = "toolStripSeparator8";
             this.toolStripSeparator8.Size = new System.Drawing.Size(161, 6);
             // 
             // ctxSelectAll
             // 
             this.ctxSelectAll.Name = "ctxSelectAll";
             this.ctxSelectAll.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.A)));
             this.ctxSelectAll.Size = new System.Drawing.Size(164, 22);
             this.ctxSelectAll.Text = "SelectAll";
             this.ctxSelectAll.Click += new System.EventHandler(this.ctxSelectAll_Click);
             // 
             // ctxTab
             // 
             this.ctxTab.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.saveToolStripMenuItem,
             this.toolStripSeparator10,
             this.ctsClose,
             this.ctxCloseAllBut,
             this.toolStripSeparator7,
             this.copyPathToolStripMenuItem,
             this.openFolderToolStripMenuItem});
             this.ctxTab.Name = "ctxTab";
             this.ctxTab.Size = new System.Drawing.Size(199, 126);
             // 
             // saveToolStripMenuItem
             // 
             this.saveToolStripMenuItem.Image = ((System.Drawing.Image)(resources.GetObject("saveToolStripMenuItem.Image")));
             this.saveToolStripMenuItem.Name = "saveToolStripMenuItem";
             this.saveToolStripMenuItem.Size = new System.Drawing.Size(198, 22);
             this.saveToolStripMenuItem.Text = "Save";
             this.saveToolStripMenuItem.Click += new System.EventHandler(this.saveToolStripMenuItem_Click);
             // 
             // toolStripSeparator10
             // 
             this.toolStripSeparator10.Name = "toolStripSeparator10";
             this.toolStripSeparator10.Size = new System.Drawing.Size(195, 6);
             // 
             // ctsClose
             // 
             this.ctsClose.Image = ((System.Drawing.Image)(resources.GetObject("ctsClose.Image")));
             this.ctsClose.Name = "ctsClose";
             this.ctsClose.Size = new System.Drawing.Size(198, 22);
             this.ctsClose.Text = "Close";
             this.ctsClose.Click += new System.EventHandler(this.ctsClose_Click);
             // 
             // ctxCloseAllBut
             // 
             this.ctxCloseAllBut.Name = "ctxCloseAllBut";
             this.ctxCloseAllBut.Size = new System.Drawing.Size(198, 22);
             this.ctxCloseAllBut.Text = "Close All but this Tab";
             this.ctxCloseAllBut.Click += new System.EventHandler(this.ctxCloseAllBut_Click);
             // 
             // toolStripSeparator7
             // 
             this.toolStripSeparator7.Name = "toolStripSeparator7";
             this.toolStripSeparator7.Size = new System.Drawing.Size(195, 6);
             // 
             // copyPathToolStripMenuItem
             // 
             this.copyPathToolStripMenuItem.Image = ((System.Drawing.Image)(resources.GetObject("copyPathToolStripMenuItem.Image")));
             this.copyPathToolStripMenuItem.Name = "copyPathToolStripMenuItem";
             this.copyPathToolStripMenuItem.Size = new System.Drawing.Size(198, 22);
             this.copyPathToolStripMenuItem.Text = "Copy Path";
             this.copyPathToolStripMenuItem.Click += new System.EventHandler(this.copyPathToolStripMenuItem_Click);
             // 
             // openFolderToolStripMenuItem
             // 
             this.openFolderToolStripMenuItem.Image = ((System.Drawing.Image)(resources.GetObject("openFolderToolStripMenuItem.Image")));
             this.openFolderToolStripMenuItem.Name = "openFolderToolStripMenuItem";
             this.openFolderToolStripMenuItem.Size = new System.Drawing.Size(198, 22);
             this.openFolderToolStripMenuItem.Text = "Open Containing Folder";
             this.openFolderToolStripMenuItem.Click += new System.EventHandler(this.openFolderToolStripMenuItem_Click);
             // 
             // DockMain
             // 
             this.DockMain.ActiveAutoHideContent = null;
             this.DockMain.Dock = System.Windows.Forms.DockStyle.Fill;
             this.DockMain.Font = new System.Drawing.Font("Tahoma", 11F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.World);
             this.DockMain.Location = new System.Drawing.Point(0, 49);
             this.DockMain.Name = "DockMain";
             this.DockMain.Size = new System.Drawing.Size(1016, 670);
             this.DockMain.TabIndex = 5;
             // 
             // MainForm
             // 
             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.ClientSize = new System.Drawing.Size(1016, 741);
             this.Controls.Add(this.DockMain);
             this.Controls.Add(this.toolStrip1);
             this.Controls.Add(this.menuStrip1);
             this.Controls.Add(this.statMain);
             this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
             this.IsMdiContainer = true;
             this.Name = "MainForm";
             this.StartPosition = System.Windows.Forms.FormStartPosition.Manual;
             this.Text = "Peter";
             this.toolStrip1.ResumeLayout(false);
             this.toolStrip1.PerformLayout();
             this.menuStrip1.ResumeLayout(false);
             this.menuStrip1.PerformLayout();
             this.statMain.ResumeLayout(false);
             this.statMain.PerformLayout();
             this.ctxEditor.ResumeLayout(false);
             this.ctxTab.ResumeLayout(false);
             this.ResumeLayout(false);
             this.PerformLayout();
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="24" endline="158"><![CDATA[
         private System.ComponentModel.IContainer components = null;
         public MainForm (List<string> args)
         {
             SplashScreen ss = new SplashScreen(false);
             ss.Show();
             this.m_SaveonExit = true;
 
             InitializeComponent();
 
             // Set the Config File...
             this.m_DockConfigFile = Path.GetDirectoryName(Application.ExecutablePath) + "\\" + DOCK_CONFIG_FILE;
             this.m_ConfigFile = Path.GetDirectoryName(Application.ExecutablePath) + "\\" + CONFIG_FILE;
             this.m_EditorConfig = new Common.EditorConfig();
 
             // Load Any Configuration from Config File...
             if (File.Exists(this.m_ConfigFile))
             {
                 // Load Config File...
                 LoadConfigFile(false);
             }
 
             // Set Variabales...
             this.m_NewCount = 0;
             this.m_Plugins = new cPluginCollection();
             this.mnuHighlighting.Enabled = false;
             this.bookMarksToolStripMenuItem.Enabled = false;
             this.mnuCode.Enabled = false;
             this.m_ActiveContent = null;
 
             // Set up Find Control...
             this.m_FindControl = new Find(this);
             this.m_FindControl.Host = this;
             this.m_FindControl.Icon = Icon.FromHandle(((Bitmap)this.GetInternalImage("Find")).GetHicon());
 
             // Set up Project Manager...
             this.m_ProjMan = new ProjectManager(this);
             this.m_ProjMan.Host = this;
             this.m_ProjMan.TabPageContextMenuStrip = this.ctxTab;
             this.m_ProjMan.Icon = Icon.FromHandle(((Bitmap)this.GetInternalImage("Project")).GetHicon());
 
             // Set up Code Structure...
             this.m_CodeStructure = new ctrlCodeStructure();
             this.m_CodeStructure.Host = this;
             this.m_CodeStructure.Icon = Icon.FromHandle(((Bitmap)this.GetInternalImage("Code")).GetHicon());
 
             // Set Events...
             this.ctxEditor.Opening += new CancelEventHandler(ctxEditor_Opening);
             this.ctxTab.Opening += new CancelEventHandler(ctxTab_Opening);
             this.mnuEdit.DropDownOpening += new EventHandler(mnuEdit_DropDownOpening);
             this.fileToolStripMenuItem.DropDownOpening += new EventHandler(fileToolStripMenuItem_DropDownOpening);
             this.txtFindNext.KeyDown += new KeyEventHandler(txtFindNext_KeyDown);
 
             // Setup The Dock Panel...
             this.DockMain.ShowDocumentIcon = true;
             this.DockMain.ActiveContentChanged += new EventHandler(DockMain_ActiveContentChanged);
             this.DockMain.ContentRemoved += new EventHandler<DockContentEventArgs>(DockMain_ContentRemoved);
             this.DockMain.ActiveDocumentChanged += new EventHandler(DockMain_ActiveDocumentChanged);
 
             // Drag N Drop...
             this.DockMain.AllowDrop = true;
             this.DockMain.DragEnter += new DragEventHandler(DockMain_DragEnter);
             this.DockMain.DragDrop += new DragEventHandler(DockMain_DragDrop);
 
             // Load Highlighting Files...
             this.LoadHighlighting();
 
             // Load Plugins...
             this.LoadPlugins();
 
             // Load Configuration...
             if (File.Exists(this.m_DockConfigFile))
             {
                 this.DockMain.LoadFromXml(this.m_DockConfigFile, new DeserializeDockContent(this.GetContent));
             }
 
             // Load Files passed by arguments...
             foreach (string s in args)
             {
                 if (File.Exists(s))
                 {
                     if (Path.GetExtension(s).ToLower().Equals(".pproj"))
                     {
                         this.OpenProject(s);
                     }
                     else
                     {
                         this.CreateEditor(s, Path.GetFileName(s), Common.GetFileIcon(s, false));
                     }
                 }
             }
             foreach (string s in args)
             {
                 if (File.Exists(s))
                 {
                     if (Path.GetExtension(s).ToLower().Equals(".pproj"))
                     {
                         this.OpenProject(s);
                     }
                     else
                     {
                         this.CreateEditor(s, Path.GetFileName(s), Common.GetFileIcon(s, false));
                     }
                 }
             }
 
             ss.Close();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="159" endline="361"><![CDATA[
 
         #endregion
 
         #region -= Load Config file =-
 
         /// <summary>
         /// Loads the Configuration File...
         /// </summary>
         /// <param name="reload">Reloaded or Not.</param>
         public void LoadConfigFile(bool reload)
         {
             XmlDocument xDoc = new XmlDocument();
             xDoc.Load(this.m_ConfigFile);
 
             // Get Editor Config...
             XmlNodeList nodes = xDoc.GetElementsByTagName("Editor");
             if (nodes.Count == 1)
             {
                 #region -= Parse Editor Config =-
                 foreach (XmlNode node in nodes[0].ChildNodes)
                 {
                     switch (node.Name.ToLower())
                     {
                         case "showeol"
                             this.m_EditorConfig.ShowEOL = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showinvalidlines"
                             this.m_EditorConfig.ShowInvalidLines = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showspaces"
                             this.m_EditorConfig.ShowSpaces = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showtabs"
                             this.m_EditorConfig.ShowTabs = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showmatchbracket"
                             this.m_EditorConfig.ShowMatchingBracket = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showlinenumbers"
                             this.m_EditorConfig.ShowLineNumbers = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showhruler"
                             this.m_EditorConfig.ShowHRuler = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showvruler"
                             this.m_EditorConfig.ShowVRuler = Convert.ToBoolean(node.InnerText);
                             break;
                         case "enablecodefolding"
                             this.m_EditorConfig.EnableCodeFolding = Convert.ToBoolean(node.InnerText);
                             break;
                         case "converttabs"
                             this.m_EditorConfig.ConvertTabs = Convert.ToBoolean(node.InnerText);
                             break;
                         case "useantialias"
                             this.m_EditorConfig.UseAntiAlias = Convert.ToBoolean(node.InnerText);
                             break;
                         case "allowcaretbeyondeol"
                             this.m_EditorConfig.AllowCaretBeyondEOL = Convert.ToBoolean(node.InnerText);
                             break;
                         case "highlightcurrentline"
                             this.m_EditorConfig.HighlightCurrentLine = Convert.ToBoolean(node.InnerText);
                             break;
                         case "autoinsertbracket"
                             this.m_EditorConfig.AutoInsertBracket = Convert.ToBoolean(node.InnerText);
                             break;
                         case "tabindent"
                             this.m_EditorConfig.TabIndent = Convert.ToInt32(node.InnerText);
                             break;
                         case "verticalrulercol"
                             this.m_EditorConfig.VerticalRulerCol = Convert.ToInt32(node.InnerText);
                             break;
                         case "indentstyle"
                             this.m_EditorConfig.IndentStyle = node.InnerText;
                             break;
                         case "bracketmatchingstyle"
                             this.m_EditorConfig.BracketMatchingStyle = node.InnerText;
                             break;
                         case "font"
                             string[] font = node.InnerText.Split(';');
                             Font f = new Font(font[0], Convert.ToSingle(font[1]));
                             this.m_EditorConfig.EditorFont = f;
                             break;
                     }
                 }
                 foreach (XmlNode node in nodes[0].ChildNodes)
                 {
                     switch (node.Name.ToLower())
                     {
                         case "showeol"
                             this.m_EditorConfig.ShowEOL = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showinvalidlines"
                             this.m_EditorConfig.ShowInvalidLines = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showspaces"
                             this.m_EditorConfig.ShowSpaces = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showtabs"
                             this.m_EditorConfig.ShowTabs = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showmatchbracket"
                             this.m_EditorConfig.ShowMatchingBracket = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showlinenumbers"
                             this.m_EditorConfig.ShowLineNumbers = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showhruler"
                             this.m_EditorConfig.ShowHRuler = Convert.ToBoolean(node.InnerText);
                             break;
                         case "showvruler"
                             this.m_EditorConfig.ShowVRuler = Convert.ToBoolean(node.InnerText);
                             break;
                         case "enablecodefolding"
                             this.m_EditorConfig.EnableCodeFolding = Convert.ToBoolean(node.InnerText);
                             break;
                         case "converttabs"
                             this.m_EditorConfig.ConvertTabs = Convert.ToBoolean(node.InnerText);
                             break;
                         case "useantialias"
                             this.m_EditorConfig.UseAntiAlias = Convert.ToBoolean(node.InnerText);
                             break;
                         case "allowcaretbeyondeol"
                             this.m_EditorConfig.AllowCaretBeyondEOL = Convert.ToBoolean(node.InnerText);
                             break;
                         case "highlightcurrentline"
                             this.m_EditorConfig.HighlightCurrentLine = Convert.ToBoolean(node.InnerText);
                             break;
                         case "autoinsertbracket"
                             this.m_EditorConfig.AutoInsertBracket = Convert.ToBoolean(node.InnerText);
                             break;
                         case "tabindent"
                             this.m_EditorConfig.TabIndent = Convert.ToInt32(node.InnerText);
                             break;
                         case "verticalrulercol"
                             this.m_EditorConfig.VerticalRulerCol = Convert.ToInt32(node.InnerText);
                             break;
                         case "indentstyle"
                             this.m_EditorConfig.IndentStyle = node.InnerText;
                             break;
                         case "bracketmatchingstyle"
                             this.m_EditorConfig.BracketMatchingStyle = node.InnerText;
                             break;
                         case "font"
                             string[] font = node.InnerText.Split(';');
                             Font f = new Font(font[0], Convert.ToSingle(font[1]));
                             this.m_EditorConfig.EditorFont = f;
                             break;
                     }
                 }
                 #endregion
             }
 
             // Get Application Config...
             nodes = xDoc.GetElementsByTagName("Application");
             if (nodes.Count == 1)
             {
                 #region -= Parse Application Config =-
                 foreach (XmlNode n in nodes[0].ChildNodes)
                 {
                     switch (n.Name.ToLower())
                     {
                         case "top"
                             if (!reload)
                             {
                                 this.Top = Convert.ToInt32(n.InnerText);
                             }
                             break;
                         case "left"
                             if (!reload)
                             {
                                 this.Left = Convert.ToInt32(n.InnerText);
 
                                 // Re-Position if off Screen...
                                 int w = 0;
                                 foreach (Screen screen in Screen.AllScreens)
                                 {
                                     w += screen.Bounds.Width;
                                 }
                                 foreach (Screen screen in Screen.AllScreens)
                                 {
                                     w += screen.Bounds.Width;
                                 }
                                 if (this.Left > w)
                                 {
                                     this.Left = this.Left - w;
                                 }
                             }
                             break;
                         case "width"
                             if (!reload)
                             {
                                 this.Width = Convert.ToInt32(n.InnerText);
                             }
                             break;
                         case "height"
                             if (!reload)
                             {
                                 this.Height = Convert.ToInt32(n.InnerText);
                             }
                             break;
                         case "saveonexit"
                             this.m_SaveonExit = Convert.ToBoolean(n.InnerText);
                             break;
                         case "recentfilecount"
                             this.m_RecentFileCount = Convert.ToInt32(n.InnerText);
                             break;
                         case "recentprojectcount"
                             this.m_RecentProjectCount = Convert.ToInt32(n.InnerText);
                             break;
                     }
                 }
                 foreach (XmlNode n in nodes[0].ChildNodes)
                 {
                     switch (n.Name.ToLower())
                     {
                         case "top"
                             if (!reload)
                             {
                                 this.Top = Convert.ToInt32(n.InnerText);
                             }
                             break;
                         case "left"
                             if (!reload)
                             {
                                 this.Left = Convert.ToInt32(n.InnerText);
 
                                 // Re-Position if off Screen...
                                 int w = 0;
                                 foreach (Screen screen in Screen.AllScreens)
                                 {
                                     w += screen.Bounds.Width;
                                 }
                                 if (this.Left > w)
                                 {
                                     this.Left = this.Left - w;
                                 }
                             }
                             break;
                         case "width"
                             if (!reload)
                             {
                                 this.Width = Convert.ToInt32(n.InnerText);
                             }
                             break;
                         case "height"
                             if (!reload)
                             {
                                 this.Height = Convert.ToInt32(n.InnerText);
                             }
                             break;
                         case "saveonexit"
                             this.m_SaveonExit = Convert.ToBoolean(n.InnerText);
                             break;
                         case "recentfilecount"
                             this.m_RecentFileCount = Convert.ToInt32(n.InnerText);
                             break;
                         case "recentprojectcount"
                             this.m_RecentProjectCount = Convert.ToInt32(n.InnerText);
                             break;
                     }
                 }
                 #endregion
             }
 
             if (!reload)
             {
                 nodes = xDoc.GetElementsByTagName("RecentProjects");
                 if (nodes.Count == 1)
                 {
                     #region -= Parse Recent Projects =-
                     foreach (XmlNode n in nodes[0].ChildNodes)
                     {
                         ToolStripMenuItem tsmi = new ToolStripMenuItem();
                         foreach (XmlNode nC in n.ChildNodes)
                         {
                             if (nC.Name.ToLower() == "name")
                             {
                                 tsmi.Text = nC.InnerText;
                             }
                             if (nC.Name.ToLower() == "file")
                             {
                                 tsmi.Name = nC.InnerText;
                             }
                         }
                         foreach (XmlNode nC in n.ChildNodes)
                         {
                             if (nC.Name.ToLower() == "name")
                             {
                                 tsmi.Text = nC.InnerText;
                             }
                             if (nC.Name.ToLower() == "file")
                             {
                                 tsmi.Name = nC.InnerText;
                             }
                         }
 
                         tsmi.Click += new EventHandler(ReopenProject);
                         this.mnuProjectReopen.DropDownItems.Add(tsmi);
                     }
                     foreach (XmlNode n in nodes[0].ChildNodes)
                     {
                         ToolStripMenuItem tsmi = new ToolStripMenuItem();
                         foreach (XmlNode nC in n.ChildNodes)
                         {
                             if (nC.Name.ToLower() == "name")
                             {
                                 tsmi.Text = nC.InnerText;
                             }
                             if (nC.Name.ToLower() == "file")
                             {
                                 tsmi.Name = nC.InnerText;
                             }
                         }
 
                         tsmi.Click += new EventHandler(ReopenProject);
                         this.mnuProjectReopen.DropDownItems.Add(tsmi);
                     }
                     #endregion
                 }
 
                 nodes = xDoc.GetElementsByTagName("RecentFiles");
                 if (nodes.Count == 1)
                 {
                     #region -= Parse Recent Files =-
                     foreach (XmlNode n in nodes[0].ChildNodes)
                     {
                         ToolStripMenuItem tsmi = new ToolStripMenuItem(n.InnerText);
 
                         tsmi.Click += new EventHandler(ReopenFile);
                         this.mnuFileOpenRecent.DropDownItems.Add(tsmi);
                     }
                     foreach (XmlNode n in nodes[0].ChildNodes)
                     {
                         ToolStripMenuItem tsmi = new ToolStripMenuItem(n.InnerText);
 
                         tsmi.Click += new EventHandler(ReopenFile);
                         this.mnuFileOpenRecent.DropDownItems.Add(tsmi);
                     }
                     #endregion
                 }
             }
 
             if (reload)
             {
                 for (int a = 0; a < this.DockMain.Contents.Count; a++)
                 {
                     if (this.DockMain.Contents[a].GetType() == typeof(Editor))
                     {
                         ((Editor)this.DockMain.Contents[a]).SetupEditor(this.m_EditorConfig);
                     }
                 }
                 for (int a = 0; a < this.DockMain.Contents.Count; a++)
                 {
                     if (this.DockMain.Contents[a].GetType() == typeof(Editor))
                     {
                         ((Editor)this.DockMain.Contents[a]).SetupEditor(this.m_EditorConfig);
                     }
                 }
 
                 foreach (IPeterPlugin plugin in this.m_Plugins)
                 {
                     plugin.ApplyOptions();
                 }
                 foreach (IPeterPlugin plugin in this.m_Plugins)
                 {
                     plugin.ApplyOptions();
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="362" endline="372"><![CDATA[
 
         #endregion
 
         #region -= Properties =-
 
         /// <summary>
         /// Gets the path the Application started in...
         /// </summary>
         public string ApplicationExeStartPath
         {
             get { return Path.GetDirectoryName(Application.ExecutablePath); }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="373" endline="380"><![CDATA[
         }
 
         /// <summary>
         /// Gets the Active Tab Interface...
         /// </summary>
         private IPeterPluginTab ActiveTab
         {
             get { return (IPeterPluginTab)this.m_ActiveContent; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="381" endline="396"><![CDATA[
         }
 
         /// <summary>
         /// Gets the Active Editor...
         /// </summary>
         public Editor ActiveEditor
         {
             get
             {
                 if (this.m_ActiveContent.GetType() == typeof(Editor))
                 {
                     return (Editor)this.m_ActiveContent;
                 }
 
                 return null;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="397" endline="404"><![CDATA[
         }
 
         /// <summary>
         /// Gets the Active Content...
         /// </summary>
         public IDockContent ActiveContent
         {
             get { return this.m_ActiveContent; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="405" endline="412"><![CDATA[
         }
 
         /// <summary>
         /// Gets the Type for a Editor in string format (typeof(Editor))...
         /// </summary>
         public string EditorType
         {
             get { return typeof(Editor).ToString(); }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="413" endline="420"><![CDATA[
         }
 
         /// <summary>
         /// Gets the Location of the Application Config File...
         /// </summary>
         public string ConfigFile
         {
             get { return this.m_ConfigFile; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="421" endline="428"><![CDATA[
         }
 
         /// <summary>
         /// Gets the location of the Dock Config File...
         /// </summary>
         public string DockConfigFile
         {
             get { return this.m_DockConfigFile; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="429" endline="446"><![CDATA[
         }
 
         #endregion
 
         #region -= Add Dock Content =-
 
         /// <summary>
         /// Adds the given Dock Content to the form...
         /// </summary>
         /// <param name="content">Content to Add.</param>
         public void AddDockContent(DockContent content)
         {
             if (this.CheckContent(content))
             {
                 content.Show(this.DockMain);
                 content.TabPageContextMenuStrip = this.ctxTab;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="447" endline="460"><![CDATA[
 
         /// <summary>
         /// Adds the given Dock Content to the form...
         /// </summary>
         /// <param name="content">Content to Add.</param>
         /// <param name="addTo">Content to Add new Tab to.</param>
         public void AddDockContent(DockContent content, IDockContent addTo)
         {
             if (this.CheckContent(content))
             {
                 content.Show(addTo.DockHandler.Pane, addTo);
                 content.TabPageContextMenuStrip = this.ctxTab;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="461" endline="474"><![CDATA[
 
         /// <summary>
         /// Adds the given Dock Content to the form...
         /// </summary>
         /// <param name="content">Content to Add.</param>
         /// <param name="state">State of Content</param>
         public void AddDockContent(DockContent content, DockState state)
         {
             if (this.CheckContent(content))
             {
                 content.Show(this.DockMain, state);
                 content.TabPageContextMenuStrip = this.ctxTab;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="475" endline="488"><![CDATA[
 
         /// <summary>
         /// Adds the given Dock Content to the form...
         /// </summary>
         /// <param name="content">Content to Add.</param>
         /// <param name="floatingRec">Floating Rectangle</param>
         public void AddDockContent(DockContent content, Rectangle floatingRec)
         {
             if (this.CheckContent(content))
             {
                 content.Show(this.DockMain, floatingRec);
                 content.TabPageContextMenuStrip = this.ctxTab;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="489" endline="510"><![CDATA[
 
         /// <summary>
         /// Checks the given content to see if it implements the IPeterPluginTab Interface...
         /// </summary>
         /// <param name="content">DockContent</param>
         /// <returns>True or False</returns>
         private bool CheckContent(DockContent content)
         {
             Type[] types = content.GetType().GetInterfaces();
             foreach (Type t in types)
             {
                 if (t == typeof(IPeterPluginTab))
                 {
                     return true;
                 }
             }
             foreach (Type t in types)
             {
                 if (t == typeof(IPeterPluginTab))
                 {
                     return true;
                 }
             }
 
             MessageBox.Show("Unable to Add '" + content.GetType().ToString() + ".' It does not Implement the IPeterPluginTab Interface",
                 "Peter", MessageBoxButtons.OK, MessageBoxIcon.Error);
 
             return false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="511" endline="612"><![CDATA[
 
         #endregion
 
         #region -= Get Content =-
 
         /// <summary>
         /// Sets up the Content from last Session...
         /// </summary>
         /// <param name="contentString">Content String</param>
         /// <returns>IDockContent</returns>
         private IDockContent GetContent(string contentString)
         {
             // Find Results...
             if (contentString == typeof(FindResults).ToString())
             {
                 this.m_FindControl.Results.TabPageContextMenuStrip = this.ctxTab;
                 return this.m_FindControl.Results;
             }
 
             // Command Prompt...
             if (contentString == typeof(CommandPrompt).ToString())
             {
                 CommandPrompt cmd = new CommandPrompt();
                 cmd.Icon = Icon.FromHandle(((Bitmap)this.GetInternalImage("cmd")).GetHicon());
                 cmd.TabPageContextMenuStrip = this.ctxTab;
                 return cmd;
             }
 
             // File Difference...
             if (contentString == typeof(FileDifference).ToString())
             {
                 FileDifference diff = this.GetNewFileDifference();
                 diff.TabPageContextMenuStrip = this.ctxTab;
                 return diff;
             }
 
             // Code Structure...
             if (contentString == typeof(ctrlCodeStructure).ToString())
             {
                 return this.m_CodeStructure;
             }
 
             // Editor...
             string[] pSplit = contentString.Split('|');
             if (pSplit.Length == 5)
             {
                 if (pSplit[0] == typeof(Editor).ToString())
                 {
                     if (File.Exists(pSplit[2]))
                     {
                         Editor e = this.CreateNewEditor(pSplit[1]);
                         e.LoadFile(pSplit[2]);
                         this.UpdateRecentFileList(pSplit[2]);
                         // We Should'nt need to check for Duplicates...
                         e.Icon = Common.GetFileIcon(pSplit[2], false);
                         e.ScrollTo(Convert.ToInt32(pSplit[3]));
                         e.Project = pSplit[4];
                         return e;
                     }
                     return this.CreateNewEditor(pSplit[1]);
                 }
             }
 
             if (pSplit.Length == 2)
             {
                 // File Explorer
                 if (pSplit[0] == typeof(ctrlFileExplorer).ToString())
                 {
                     ctrlFileExplorer fe = new ctrlFileExplorer(this);
                     fe.Icon = Icon.FromHandle(((Bitmap)this.GetInternalImage("FEIcon")).GetHicon());
                     fe.LoadTree(pSplit[1]);
                     fe.TabPageContextMenuStrip = this.ctxTab;
                     return fe;
                 }
 
                 // Project Manager...
                 if (pSplit[0] == typeof(ProjectManager).ToString())
                 {
                     string[] projs = pSplit[1].Split(';');
                     foreach (string proj in projs)
                     {
                         this.OpenProject(proj);
                     }
                     foreach (string proj in projs)
                     {
                         this.OpenProject(proj);
                     }
                     return this.m_ProjMan;
                 }
             }
 
             // Plugin...
             foreach (IPeterPlugin plugin in this.m_Plugins)
             {
                 if (plugin.CheckContentString(contentString))
                 {
                     DockContent dc = (DockContent)plugin.GetContent(contentString);
                     dc.TabPageContextMenuStrip = this.ctxTab;
                     return dc;
                 }
             }
             foreach (IPeterPlugin plugin in this.m_Plugins)
             {
                 if (plugin.CheckContentString(contentString))
                 {
                     DockContent dc = (DockContent)plugin.GetContent(contentString);
                     dc.TabPageContextMenuStrip = this.ctxTab;
                     return dc;
                 }
             }
 
             // If we return null, the program will crash, so just create an editor...
             this.m_NewCount++;
             return this.CreateNewEditor("New" + Convert.ToString(this.m_NewCount - 1));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="613" endline="628"><![CDATA[
 
         #endregion
 
         #region -= Plugins =-
 
         /// <summary>
         /// Loads the Plugins in the Plugin Directory...
         /// </summary>
         private void LoadPlugins()
         {
             string[] files = Directory.GetFiles(Path.GetDirectoryName(Application.ExecutablePath) + "\\" + PLUGIN_FOLDER, "*.dll");
             foreach (string file in files)
             {
                 this.LoadPlugin(file);
             }
             foreach (string file in files)
             {
                 this.LoadPlugin(file);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="629" endline="689"><![CDATA[
 
         /// <summary>
         /// Loads a Plugin...
         /// </summary>
         /// <param name="pluginPath">Full Path to Plugin</param>
         /// <returns>True if Plugin Loaded, otherwise false</returns>
         public bool LoadPlugin(string pluginPath)
         {
             Assembly asm;
 
             if (!File.Exists(pluginPath))
             {
                 return false;
             }
 
             asm = Assembly.LoadFile(pluginPath);
             if (asm != null)
             {
                 foreach (Type type in asm.GetTypes())
                 {
                     if (type.IsAbstract)
                         continue;
                     object[] attrs = type.GetCustomAttributes(typeof(PeterPluginAttribute), true);
                     if (attrs.Length > 0)
                     {
                         IPeterPlugin plugin = Activator.CreateInstance(type) as IPeterPlugin;
                         plugin.Host = this;
                         if (plugin.HasMenu)
                         {
                             this.mnuPlugins.DropDownItems.Add(plugin.GetMenu());
                         }
 
                         if (plugin.HasTabMenu)
                         {
                             this.ctxTab.Items.Add(new ToolStripSeparator());
                             foreach (ToolStripMenuItem tsmi in plugin.GetTabMenu())
                             {
                                 this.ctxTab.Items.Add(tsmi);
                             }
                             foreach (ToolStripMenuItem tsmi in plugin.GetTabMenu())
                             {
                                 this.ctxTab.Items.Add(tsmi);
                             }
                         }
 
                         if (plugin.HasContextMenu)
                         {
                             this.ctxEditor.Items.Add(new ToolStripSeparator());
                             foreach (ToolStripMenuItem tsmi in plugin.GetContextMenu())
                             {
                                 this.ctxEditor.Items.Add(tsmi);
                             }
                             foreach (ToolStripMenuItem tsmi in plugin.GetContextMenu())
                             {
                                 this.ctxEditor.Items.Add(tsmi);
                             }
                         }
                         this.m_Plugins.Add(plugin);
                         plugin.Start();
                     }
                 }
                 foreach (Type type in asm.GetTypes())
                 {
                     if (type.IsAbstract)
                         continue;
                     object[] attrs = type.GetCustomAttributes(typeof(PeterPluginAttribute), true);
                     if (attrs.Length > 0)
                     {
                         IPeterPlugin plugin = Activator.CreateInstance(type) as IPeterPlugin;
                         plugin.Host = this;
                         if (plugin.HasMenu)
                         {
                             this.mnuPlugins.DropDownItems.Add(plugin.GetMenu());
                         }
 
                         if (plugin.HasTabMenu)
                         {
                             this.ctxTab.Items.Add(new ToolStripSeparator());
                             foreach (ToolStripMenuItem tsmi in plugin.GetTabMenu())
                             {
                                 this.ctxTab.Items.Add(tsmi);
                             }
                         }
 
                         if (plugin.HasContextMenu)
                         {
                             this.ctxEditor.Items.Add(new ToolStripSeparator());
                             foreach (ToolStripMenuItem tsmi in plugin.GetContextMenu())
                             {
                                 this.ctxEditor.Items.Add(tsmi);
                             }
                         }
                         this.m_Plugins.Add(plugin);
                         plugin.Start();
                     }
                 }
 
                 return true;
             }
             else
             {
                 return false;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="690" endline="752"><![CDATA[
 
         #endregion
 
         #region -= Active Content Changed =-
 
         /// <summary>
         /// Occurs when the Active Contents has Changed...
         /// </summary>
         /// <param name="sender">Content</param>
         /// <param name="e">Events</param>
         private void DockMain_ActiveContentChanged(object sender, EventArgs e)
         {
             this.mnuHighlighting.Enabled = false;
             this.bookMarksToolStripMenuItem.Enabled = false;
             this.mnuCode.Enabled = false;
 
             if (this.DockMain.ActiveContent != null)
             {
                 // Set the Active content...
                 this.m_ActiveContent = this.DockMain.ActiveContent;
 
                 if (this.DockMain.ActiveContent.GetType() == typeof(Editor))
                 {
                     Editor edit = (Editor)this.DockMain.ActiveContent;
                     this.RemoveHighlightChecks();
                     this.mnuHighlighting.Enabled = true;
                     this.mnuCode.Enabled = true;
                     this.bookMarksToolStripMenuItem.Enabled = true;
                     for (int a = 0; a < this.mnuHighlighting.DropDown.Items.Count; a++)
                     {
                         ToolStripMenuItem tsmi = (ToolStripMenuItem)this.mnuHighlighting.DropDown.Items[a];
                         if (tsmi.Text == edit.Highlighting)
                         {
                             tsmi.Checked = true;
                             break;
                         }
                     }
                     for (int a = 0; a < this.mnuHighlighting.DropDown.Items.Count; a++)
                     {
                         ToolStripMenuItem tsmi = (ToolStripMenuItem)this.mnuHighlighting.DropDown.Items[a];
                         if (tsmi.Text == edit.Highlighting)
                         {
                             tsmi.Checked = true;
                             break;
                         }
                     }
                     edit.UpdateCaretPos();
                     this.m_CodeStructure.ActiveContentChanged(this.DockMain.ActiveContent);
                 }
                 else
                 {
                     if (this.DockMain.ActiveDocument == null || this.DockMain.ActiveDocument.GetType() != typeof(Editor))
                     {
                         this.UpdateCaretPos(0, 0, 0, null);
                         this.m_CodeStructure.Clear();
                     }
                 }
 
                 foreach (IPeterPlugin plugin in this.m_Plugins)
                 {
                     plugin.ActiveContentChanged(this.DockMain.ActiveContent);
                 }
                 foreach (IPeterPlugin plugin in this.m_Plugins)
                 {
                     plugin.ActiveContentChanged(this.DockMain.ActiveContent);
                 }
 
                 this.UpdateToolBar();
             }
             else if (this.DockMain.ActiveDocument == null)
             {
                 this.UpdateCaretPos(0, 0, 0, null);
                 this.m_CodeStructure.Clear();
             }
             this.UpdateTitleBar();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="753" endline="774"><![CDATA[
 
         /// <summary>
         /// Updates the Title Bar of the Application
         /// </summary>
         public void UpdateTitleBar()
         {
             if (this.ActiveContent != null)
             {
                 if (this.ActiveContent.GetType() == typeof(Editor))
                 {
                     this.Text = ((DockContent)this.ActiveContent).TabText + " - Peter";
                 }
                 else if (this.DockMain.ActiveDocument == null || this.DockMain.ActiveDocument.GetType() != typeof(Editor))
                 {
                     this.Text = "Peter";
                 }
             }
             else
             {
                 this.Text = "Peter";
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="775" endline="782"><![CDATA[
 
         void DockMain_ActiveDocumentChanged(object sender, EventArgs e)
         {
             /*if (this.DockMain.ActiveDocument != null)
             {
                 this.Text = ((DockContent)this.DockMain.ActiveDocument).TabText + " - Peter";
             }*/
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="783" endline="792"><![CDATA[
 
         void DockMain_ContentRemoved(object sender, DockContentEventArgs e)
         {
             Type type = e.Content.GetType().GetInterface("IPeterPluginTab", true);//.GetInterfaces();
             if (type != null)
             {
                 ((IPeterPluginTab)e.Content).CloseTab();
             }
             this.UpdateTitleBar();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="793" endline="824"><![CDATA[
 
         #endregion
 
         #region -= Highlighting =-
 
         /// <summary>
         /// Loads the Highlighting Files...
         /// </summary>
         private void LoadHighlighting()
         {
             string path = Path.GetDirectoryName(Application.ExecutablePath) + "\\" + SCHEME_FOLDER;
             if (Directory.Exists(path))
             {
                 HighlightingManager.Manager.AddSyntaxModeFileProvider(new FileSyntaxModeProvider(path));
 
                 ICollection keys = HighlightingManager.Manager.HighlightingDefinitions.Keys;
                 string[] keyArray = new string[keys.Count];
                 keys.CopyTo(keyArray, 0);
                 Array.Sort(keyArray);
                 this.mnuHighlighting.DropDownItems.Clear();
                 foreach (string key in keyArray)
                 {
                     ToolStripMenuItem tsi = new ToolStripMenuItem(key);
                     tsi.Click += new EventHandler(Highlighter_Click);
                     this.mnuHighlighting.DropDown.Items.Add(tsi);
                 }
                 foreach (string key in keyArray)
                 {
                     ToolStripMenuItem tsi = new ToolStripMenuItem(key);
                     tsi.Click += new EventHandler(Highlighter_Click);
                     this.mnuHighlighting.DropDown.Items.Add(tsi);
                 }
             }
             else
             {
                 MessageBox.Show("Unable to Load Highlighting Schemes!", "Peter", MessageBoxButtons.OK, MessageBoxIcon.Error);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="825" endline="836"><![CDATA[
 
         /// <summary>
         /// Removes all the Check from the Highlighting Menu...
         /// </summary>
         private void RemoveHighlightChecks()
         {
             for (int a = 0; a < this.mnuHighlighting.DropDown.Items.Count; a++)
             {
                 ToolStripMenuItem tsmi = (ToolStripMenuItem)this.mnuHighlighting.DropDown.Items[a];
                 tsmi.Checked = false;
             }
             for (int a = 0; a < this.mnuHighlighting.DropDown.Items.Count; a++)
             {
                 ToolStripMenuItem tsmi = (ToolStripMenuItem)this.mnuHighlighting.DropDown.Items[a];
                 tsmi.Checked = false;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="837" endline="856"><![CDATA[
 
         /// <summary>
         /// Highlighting menu selection...
         /// </summary>
         /// <param name="sender">Highlighting Menu ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void Highlighter_Click(object sender, EventArgs e)
         {
             this.RemoveHighlightChecks();
             if (this.ActiveContent != null)
             {
                 if (this.ActiveContent.GetType() == typeof(Editor))
                 {
                     ToolStripMenuItem tsmi = sender as ToolStripMenuItem;
                     tsmi.Checked = true;
                     Editor edit = (Editor)this.ActiveContent;
                     edit.Highlighting = tsmi.Text;
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="857" endline="873"><![CDATA[
 
         #endregion
 
         #region -= Drag N Drop =-
 
         /// <summary>
         /// Enables files to be dropped in the dock window...
         /// </summary>
         /// <param name="sender">DockPanel</param>
         /// <param name="e">Events</param>
         private void DockMain_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop, false) == true)
             {
                 e.Effect = DragDropEffects.All;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="874" endline="887"><![CDATA[
 
         /// <summary>
         /// Grabs the files dropped in the Dock Window...
         /// </summary>
         /// <param name="sender">DockPanel</param>
         /// <param name="e">Events</param>
         private void DockMain_DragDrop(object sender, DragEventArgs e)
         {
             string[] files = (string[])e.Data.GetData(DataFormats.FileDrop);
             foreach (string file in files)
             {
                 this.CreateEditor(file, Path.GetFileName(file));
             }
             foreach (string file in files)
             {
                 this.CreateEditor(file, Path.GetFileName(file));
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="888" endline="901"><![CDATA[
 
         #endregion
 
         #region -= New Document =-
 
         /// <summary>
         /// Creates a new blank editor...
         /// </summary>
         public void NewDocument()
         {
             this.m_NewCount++;
             Editor e = this.CreateNewEditor("New" + this.m_NewCount.ToString());
             e.Show(this.DockMain);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="902" endline="919"><![CDATA[
 
         #endregion
 
         #region -= Open =-
 
         /// <summary>
         /// Displays the Open file Dialog to get files to edit...
         /// </summary>
         private void Open()
         {
             if (this.ofdMain.ShowDialog() == DialogResult.OK)
             {
                 foreach (string file in this.ofdMain.FileNames)
                 {
                     this.CreateEditor(file, Path.GetFileName(file));
                 }
                 foreach (string file in this.ofdMain.FileNames)
                 {
                     this.CreateEditor(file, Path.GetFileName(file));
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="920" endline="940"><![CDATA[
 
         #endregion
 
         #region -= Save =-
 
         /// <summary>
         /// Save the Current Pane...
         /// </summary>
         private void Save()
         {
             IPeterPluginTab tab = this.ActiveTab;
             if (tab.FileName == null)
             {
                 this.SaveAs(tab);
             }
             else
             {
                 tab.Save();
             }
             this.UpdateTitleBar();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="941" endline="953"><![CDATA[
 
         /// <summary>
         /// Saves the Given Content As...
         /// </summary>
         /// <param name="tab">Content to Save</param>
         public void SaveAs(IPeterPluginTab tab)
         {
             if (this.sfdMain.ShowDialog() == DialogResult.OK)
             {
                 tab.SaveAs(this.sfdMain.FileName);
             }
             this.UpdateTitleBar();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="954" endline="973"><![CDATA[
 
         /// <summary>
         /// Saves all of the Contents...
         /// </summary>
         private void SaveAll()
         {
             for (int a = 0; a < this.DockMain.Contents.Count; a++)
             {
                 IPeterPluginTab tab = (IPeterPluginTab)this.DockMain.Contents[a];
 
                 if (tab.FileName == null)
                 {
                     this.SaveAs(tab);
                 }
                 else
                 {
                     tab.Save();
                 }
             }
             for (int a = 0; a < this.DockMain.Contents.Count; a++)
             {
                 IPeterPluginTab tab = (IPeterPluginTab)this.DockMain.Contents[a];
 
                 if (tab.FileName == null)
                 {
                     this.SaveAs(tab);
                 }
                 else
                 {
                     tab.Save();
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="974" endline="985"><![CDATA[
 
         #endregion
 
         #region -= Edit =-
 
         /// <summary>
         /// Clipboard Cut Action...
         /// </summary>
         private void Cut()
         {
             this.ActiveTab.Cut();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="986" endline="993"><![CDATA[
 
         /// <summary>
         /// Clipboard Copy Action...
         /// </summary>
         private void Copy()
         {
             this.ActiveTab.Copy();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="994" endline="1001"><![CDATA[
 
         /// <summary>
         /// Clipboard Paste Action...
         /// </summary>
         private void Paste()
         {
             this.ActiveTab.Paste();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1002" endline="1009"><![CDATA[
 
         /// <summary>
         /// Clipboard Delete Action...
         /// </summary>
         private void Delete()
         {
             this.ActiveTab.Delete();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1010" endline="1017"><![CDATA[
 
         /// <summary>
         /// Select All Action...
         /// </summary>
         private void SelectAll()
         {
             this.ActiveTab.SelectAll();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1018" endline="1025"><![CDATA[
 
         /// <summary>
         /// Edit Undo Action...
         /// </summary>
         private void Undo()
         {
             this.ActiveTab.Undo();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1026" endline="1033"><![CDATA[
 
         /// <summary>
         /// Edit Redo Action...
         /// </summary>
         private void Redo()
         {
             this.ActiveTab.Redo();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1034" endline="1047"><![CDATA[
 
         #endregion
 
         #region -= Create Editor =-
 
         /// <summary>
         /// Creates a new Editor with the given file...
         /// </summary>
         /// <param name="fileName">File to load in Editor.</param>
         /// <param name="tabName">Name of Tab.</param>
         public void CreateEditor(string fileName, string tabName)
         {
             this.CreateEditor(fileName, tabName, Common.GetFileIcon(fileName, false));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1048" endline="1058"><![CDATA[
 
         /// <summary>
         /// Creates a new Editor with the given file...
         /// </summary>
         /// <param name="fileName">File to load in Editor.</param>
         /// <param name="tabName">Name of Tab.</param>
         /// <param name="image">Icon for Tab.</param>
         public void CreateEditor(string fileName, string tabName, Icon image)
         {
             this.CreateEditor(fileName, tabName, image, null);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1059" endline="1131"><![CDATA[
 
         /// <summary>
         /// Creates a new Editor with the given file...
         /// </summary>
         /// <param name="fileName">File to load in Editor.</param>
         /// <param name="tabName">Name of Tab.</param>
         /// <param name="image">Icon for Tab.</param>
         public void CreateEditor(string fileName, string tabName, Icon image, IDockContent addToContent)
         {
             try
             {
                 if (File.Exists(fileName))
                 {
                     // Add to Recent Files...
                     this.UpdateRecentFileList(fileName);
 
                     // Let the plugins try to load the file first...
                     foreach (IPeterPlugin plugin in this.m_Plugins)
                     {
                         if (plugin.AbleToLoadFiles)
                         {
                             if (plugin.LoadFile(fileName))
                             {
                                 return;
                             }
                         }
                     }
                     foreach (IPeterPlugin plugin in this.m_Plugins)
                     {
                         if (plugin.AbleToLoadFiles)
                         {
                             if (plugin.LoadFile(fileName))
                             {
                                 return;
                             }
                         }
                     }
 
                     // No plugins want the file, we can load it...
                     if (!this.IsFileOpen(fileName))
                     {
                         Editor e = this.CreateNewEditor(tabName);
                         e.ShowIcon = true;
                         e.Icon = image;
                         e.LoadFile(fileName);
                         if (addToContent == null)
                         {
                             if (this.DockMain.ActiveDocumentPane != null)
                             {
                                 e.Show(this.DockMain.ActiveDocumentPane, null);
                             }
                             else
                             {
                                 e.Show(this.DockMain);
                             }
                         }
                         else
                         {
                             e.Show(addToContent.DockHandler.Pane, null);
                         }
                     }
                     else
                     {
                         for (int a = this.DockMain.Contents.Count - 1; a >= 0; a--)
                         {
                             IPeterPluginTab tab = (IPeterPluginTab)this.DockMain.Contents[a];
                             if (tab.FileName == fileName)
                             {
                                 this.DockMain.Contents[a].DockHandler.Show();
                             }
                         }
                         for (int a = this.DockMain.Contents.Count - 1; a >= 0; a--)
                         {
                             IPeterPluginTab tab = (IPeterPluginTab)this.DockMain.Contents[a];
                             if (tab.FileName == fileName)
                             {
                                 this.DockMain.Contents[a].DockHandler.Show();
                             }
                         }
                     }
                 }
                 else
                 {
                     MessageBox.Show(fileName + " does not Exist", "Peter", MessageBoxButtons.OK, MessageBoxIcon.Error);
                 }
             }
             catch (IOException ex)
             {
                 MessageBox.Show(ex.Message, "Peter", MessageBoxButtons.OK, MessageBoxIcon.Error);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1132" endline="1150"><![CDATA[
 
         /// <summary>
         /// Gets the Editor object for a particular file
         /// </summary>
         /// <param name="fileName">The name of the file</param>
         /// <returns>Returns an Editor object corresponding to the given file name</returns>
         public Editor GetEditor (string fileName)
         {
             for (int a = this.DockMain.Contents.Count - 1; a >= 0; a--)
             {
                 IPeterPluginTab tab = (IPeterPluginTab)this.DockMain.Contents[a];
                 if (tab.FileName == fileName)
                 {
                     return (Editor)tab;
                 }
             }
             for (int a = this.DockMain.Contents.Count - 1; a >= 0; a--)
             {
                 IPeterPluginTab tab = (IPeterPluginTab)this.DockMain.Contents[a];
                 if (tab.FileName == fileName)
                 {
                     return (Editor)tab;
                 }
             }
 
             return null;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1151" endline="1168"><![CDATA[
 
         /// <summary>
         /// Checks to see if a file is alread open...
         /// </summary>
         /// <param name="file">File to check.</param>
         /// <returns>True if open, else false</returns>
         private bool IsFileOpen(string file)
         {
             for (int a = 0; a < this.DockMain.Contents.Count; a++)
             {
                 IPeterPluginTab tab = (IPeterPluginTab)this.DockMain.Contents[a];
                 if (file.Equals(tab.FileName, StringComparison.CurrentCultureIgnoreCase))
                 {
                     return true;
                 }
             }
             for (int a = 0; a < this.DockMain.Contents.Count; a++)
             {
                 IPeterPluginTab tab = (IPeterPluginTab)this.DockMain.Contents[a];
                 if (file.Equals(tab.FileName, StringComparison.CurrentCultureIgnoreCase))
                 {
                     return true;
                 }
             }
             return false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1169" endline="1220"><![CDATA[
 
         private void UpdateRecentFileList(string filePath)
         {
             // Add Menu Item if Needed...
             for (int a = 0; a < this.mnuFileOpenRecent.DropDownItems.Count; a++)
             {
                 if (this.mnuFileOpenRecent.DropDownItems[a].Text == filePath)
                 {
                     // File is already in list...
                     return;
                 }
             }
             for (int a = 0; a < this.mnuFileOpenRecent.DropDownItems.Count; a++)
             {
                 if (this.mnuFileOpenRecent.DropDownItems[a].Text == filePath)
                 {
                     // File is already in list...
                     return;
                 }
             }
 
             ToolStripMenuItem tsmi = new ToolStripMenuItem(filePath);
             tsmi.Click += new EventHandler(ReopenFile);
             this.mnuFileOpenRecent.DropDownItems.Add(tsmi);
 
             // Update Config file...
             bool inList = false;
             int count = 0;
             XmlDocument xDoc = new XmlDocument();
             xDoc.Load(this.m_ConfigFile);
             XmlNodeList recent = xDoc.GetElementsByTagName("RecentFiles");
             if (recent.Count == 1)
             {
                 XmlNode recentNode = recent[0];
                 foreach (XmlNode n in recentNode.ChildNodes)
                 {
                     count++;
                     if (n.InnerText == this.ofdMain.FileName)
                     {
                         inList = true;
                         break;
                     }
                 }
                 foreach (XmlNode n in recentNode.ChildNodes)
                 {
                     count++;
                     if (n.InnerText == this.ofdMain.FileName)
                     {
                         inList = true;
                         break;
                     }
                 }
 
                 if (!inList)
                 {
                     if (count == this.m_RecentFileCount)
                     {
                         // Remove the First Node...
                         recentNode.RemoveChild(recentNode.ChildNodes[0]);
                     }
 
                     // Add the new file...
                     XmlNode newFileNode = xDoc.CreateNode(XmlNodeType.Element, "file", null);
                     newFileNode.InnerText = filePath;
                     recentNode.AppendChild(newFileNode);
                     xDoc.Save(this.m_ConfigFile);
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1221" endline="1240"><![CDATA[
 
         #endregion
 
         #region -= Create New Editor =-
 
         /// <summary>
         /// Creates a new Editor with the given tab Name...
         /// </summary>
         /// <param name="tabName">Name to put on tab.</param>
         /// <returns>Newly created Editor.</returns>
         private Editor CreateNewEditor(string tabName)
         {
             Editor e = new Editor(tabName, this);
             e.Host = this;
             e.TabPageContextMenuStrip = this.ctxTab;
             e.SetContextMenuStrip(this.ctxEditor);
             e.SetupEditor(this.m_EditorConfig);
 
             return e;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1241" endline="1255"><![CDATA[
 
         #endregion
 
         #region -= Get File Icon =-
 
         /// <summary>
         /// Gets the Shell Icon for the given file...
         /// </summary>
         /// <param name="filePath">Path to File.</param>
         /// <param name="linkOverlay">Link Overlay or not.</param>
         /// <returns>Shell Icon for File.</returns>
         public Icon GetFileIcon(string filePath, bool linkOverlay)
         {
             return Common.GetFileIcon(filePath, linkOverlay);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1256" endline="1270"><![CDATA[
 
         #endregion
 
         #region -= Get Internal Image =-
 
         /// <summary>
         /// Gets an Image from the InternalImages resource file...
         /// </summary>
         /// <param name="imageName">Name of Image</param>
         /// <returns>Image</returns>
         public Image GetInternalImage(string imageName)
         {
             System.Resources.ResourceManager mngr = new System.Resources.ResourceManager("Peter.InternalImages", this.GetType().Assembly);
             return (Image)mngr.GetObject(imageName);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1271" endline="1283"><![CDATA[
 
         #endregion
 
         #region -= Trace =-
 
         /// <summary>
         /// Writes the given text in the status bar...
         /// </summary>
         /// <param name="text">Text to Write.</param>
         public void Trace(string text)
         {
             this.sslMain.Text = text;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1284" endline="1297"><![CDATA[
 
         #endregion
 
         #region -= Tool Bar =-
 
         /// <summary>
         /// Creates a new Blank Editor...
         /// </summary>
         /// <param name="sender">ToolStripButton</param>
         /// <param name="e">Events</param>
         private void tsbNew_Click(object sender, EventArgs e)
         {
             this.NewDocument();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1298" endline="1307"><![CDATA[
 
         /// <summary>
         /// Opens a Documnet...
         /// </summary>
         /// <param name="sender">ToolStripButton</param>
         /// <param name="e">Events</param>
         private void tsbOpen_Click(object sender, EventArgs e)
         {
             this.Open();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1308" endline="1317"><![CDATA[
 
         /// <summary>
         /// Save the Current Document...
         /// </summary>
         /// <param name="sender">ToolStripButton</param>
         /// <param name="e">Events</param>
         private void tsbSave_Click(object sender, EventArgs e)
         {
             this.Save();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1318" endline="1327"><![CDATA[
 
         /// <summary>
         /// Saves all of the Open Documents...
         /// </summary>
         /// <param name="sender">ToolStripButton</param>
         /// <param name="e">Events</param>
         private void tsbSaveAll_Click(object sender, EventArgs e)
         {
             this.SaveAll();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1328" endline="1337"><![CDATA[
 
         /// <summary>
         /// Clipboard Cut Action...
         /// </summary>
         /// <param name="sender">ToolStripButton</param>
         /// <param name="e">Events</param>
         private void tsbCut_Click(object sender, EventArgs e)
         {
             this.Cut();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1338" endline="1347"><![CDATA[
 
         /// <summary>
         /// Clipboard Copy Action...
         /// </summary>
         /// <param name="sender">ToolStripButton</param>
         /// <param name="e">Events</param>
         private void tsbCopy_Click(object sender, EventArgs e)
         {
             this.Copy();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1348" endline="1357"><![CDATA[
 
         /// <summary>
         /// Clipboard Paste Action...
         /// </summary>
         /// <param name="sender">ToolStripButton</param>
         /// <param name="e">Events</param>
         private void tsbPaste_Click(object sender, EventArgs e)
         {
             this.Paste();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1358" endline="1367"><![CDATA[
 
         /// <summary>
         /// Edit Undo Action...
         /// </summary>
         /// <param name="sender">ToolStripButton</param>
         /// <param name="e">Events</param>
         private void tsbUndo_Click(object sender, EventArgs e)
         {
             this.Undo();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1368" endline="1377"><![CDATA[
 
         /// <summary>
         /// Edit Redo Action...
         /// </summary>
         /// <param name="sender">ToolStripButton</param>
         /// <param name="e">Events</param>
         private void tsbRedo_Click(object sender, EventArgs e)
         {
             this.Redo();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1378" endline="1387"><![CDATA[
 
         /// <summary>
         /// Prints the Active Content...
         /// </summary>
         /// <param name="sender">ToolStripButton</param>
         /// <param name="e">Events</param>
         private void tsbPrint_Click(object sender, EventArgs e)
         {
             this.ActiveTab.Print();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1388" endline="1402"><![CDATA[
 
         #endregion
 
         #region -= File Menu =-
 
         /// <summary>
         /// Show the file Difference Dialog...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuFileDifference_Click(object sender, EventArgs e)
         {
 
             this.AddDockContent(this.GetNewFileDifference(), DockState.Document);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1403" endline="1425"><![CDATA[
 
         /// <summary>
         /// Creates a new Difference Content...
         /// </summary>
         /// <returns>New Difference Content.</returns>
         private FileDifference GetNewFileDifference()
         {
             string fileList = "";
             string selectedFile = (this.ActiveTab != null) ? (!string.IsNullOrEmpty(this.ActiveTab.FileName)) ? this.ActiveTab.FileName 
             for (int a = 0; a < this.DockMain.Contents.Count; a++)
             {
                 IPeterPluginTab tab = (IPeterPluginTab)this.DockMain.Contents[a];
                 if (!string.IsNullOrEmpty(tab.FileName))
                 {
                     fileList += tab.FileName + ";";
                 }
             }
             for (int a = 0; a < this.DockMain.Contents.Count; a++)
             {
                 IPeterPluginTab tab = (IPeterPluginTab)this.DockMain.Contents[a];
                 if (!string.IsNullOrEmpty(tab.FileName))
                 {
                     fileList += tab.FileName + ";";
                 }
             }
 
             FileDifference diff = new FileDifference(fileList.Split(';'), selectedFile);
             diff.Icon = Icon.FromHandle(((Bitmap)this.GetInternalImage("Diff")).GetHicon());
 
             return diff;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1426" endline="1435"><![CDATA[
 
         /// <summary>
         /// Creates a new Blank Editor...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuFileNew_Click(object sender, EventArgs e)
         {
             this.NewDocument();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1436" endline="1445"><![CDATA[
 
         /// <summary>
         /// Opens a Documnet...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuFileOpen_Click(object sender, EventArgs e)
         {
             this.Open();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1446" endline="1455"><![CDATA[
 
         /// <summary>
         /// Save the Current Document...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuFileSave_Click(object sender, EventArgs e)
         {
             this.Save();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1456" endline="1465"><![CDATA[
 
         /// <summary>
         /// Save the Current Document As...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuFileSaveAs_Click(object sender, EventArgs e)
         {
             this.SaveAs((IPeterPluginTab)this.ActiveContent);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1466" endline="1475"><![CDATA[
 
         /// <summary>
         /// Saves all of the Open Documents...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuFileSaveAll_Click(object sender, EventArgs e)
         {
             this.SaveAll();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1476" endline="1485"><![CDATA[
 
         /// <summary>
         /// Exits the Program
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuFileExit_Click(object sender, EventArgs e)
         {
             this.Close();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1486" endline="1496"><![CDATA[
 
         /// <summary>
         /// Reopens the Given File...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         void ReopenFile(object sender, EventArgs e)
         {
             ToolStripMenuItem tsmi = sender as ToolStripMenuItem;
             this.CreateEditor(tsmi.Text, Path.GetFileName(tsmi.Text));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1497" endline="1510"><![CDATA[
 
         #endregion
 
         #region -= Edit Menu =-
 
         /// <summary>
         /// Edit Undo Action...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuEditUndo_Click(object sender, EventArgs e)
         {
             this.Undo();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1511" endline="1520"><![CDATA[
 
         /// <summary>
         /// Edit Redo Action...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuEditRedo_Click(object sender, EventArgs e)
         {
             this.Redo();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1521" endline="1530"><![CDATA[
 
         /// <summary>
         /// Clipboard Cut Action...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuEditCut_Click(object sender, EventArgs e)
         {
             this.Cut();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1531" endline="1540"><![CDATA[
 
         /// <summary>
         /// Clipboard Copy Action...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuEditCopy_Click(object sender, EventArgs e)
         {
             this.Copy();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1541" endline="1550"><![CDATA[
 
         /// <summary>
         /// Clipboard Paste Action...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuEditPaste_Click(object sender, EventArgs e)
         {
             this.Paste();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1551" endline="1560"><![CDATA[
 
         /// <summary>
         /// Duplicates the current selection...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void duplicateToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.ActiveTab.Duplicate();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1561" endline="1570"><![CDATA[
 
         /// <summary>
         /// Clipboard Delete Action...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuEditDelete_Click(object sender, EventArgs e)
         {
             this.Delete();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1571" endline="1580"><![CDATA[
 
         /// <summary>
         /// Selects All of the Text in the Current Document...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuEditSelectAll_Click(object sender, EventArgs e)
         {
             this.SelectAll();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1581" endline="1594"><![CDATA[
 
         #endregion
 
         #region -= Editor Context Menu =-
 
         /// <summary>
         /// Edit Undo Action...
         /// </summary>
         /// <param name="sender">ToolStirpMenuItem</param>
         /// <param name="e">Events</param>
         private void ctxUndo_Click(object sender, EventArgs e)
         {
             this.Undo();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1595" endline="1604"><![CDATA[
 
         /// <summary>
         /// Edit Redo Action...
         /// </summary>
         /// <param name="sender">ToolStirpMenuItem</param>
         /// <param name="e">Events</param>
         private void ctxRedo_Click(object sender, EventArgs e)
         {
             this.Redo();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1605" endline="1614"><![CDATA[
 
         /// <summary>
         /// Clipboard Cut Action...
         /// </summary>
         /// <param name="sender">ToolStirpMenuItem</param>
         /// <param name="e">Events</param>
         private void ctxCut_Click(object sender, EventArgs e)
         {
             this.Cut();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1615" endline="1624"><![CDATA[
 
         /// <summary>
         /// Clipboard Copy Action...
         /// </summary>
         /// <param name="sender">ToolStirpMenuItem</param>
         /// <param name="e">Events</param>
         private void ctxCopy_Click(object sender, EventArgs e)
         {
             this.Copy();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1625" endline="1634"><![CDATA[
 
         /// <summary>
         /// Clipboard Paste Action...
         /// </summary>
         /// <param name="sender">ToolStirpMenuItem</param>
         /// <param name="e">Events</param>
         private void ctxPaste_Click(object sender, EventArgs e)
         {
             this.Paste();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1635" endline="1644"><![CDATA[
 
         /// <summary>
         /// Clipboard Delete Action...
         /// </summary>
         /// <param name="sender">ToolStirpMenuItem</param>
         /// <param name="e">Events</param>
         private void ctxDelete_Click(object sender, EventArgs e)
         {
             this.Delete();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1645" endline="1654"><![CDATA[
 
         /// <summary>
         /// Selects All Text in the Current Document...
         /// </summary>
         /// <param name="sender">ToolStirpMenuItem</param>
         /// <param name="e">Events</param>
         private void ctxSelectAll_Click(object sender, EventArgs e)
         {
             this.SelectAll();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1655" endline="1670"><![CDATA[
 
         /// <summary>
         /// Action before Editor Menu Opens...
         /// </summary>
         /// <param name="sender">Editor Context Menu</param>
         /// <param name="e">Events</param>
         private void ctxEditor_Opening(object sender, CancelEventArgs e)
         {
             this.ctxCut.Enabled = ((this.ActiveTab.Selection.Length > 0) && this.ActiveTab.AbleToCut);
             this.ctxCopy.Enabled = ((this.ActiveTab.Selection.Length > 0) && this.ActiveTab.AbleToCopy);
             this.ctxDelete.Enabled = ((this.ActiveTab.Selection.Length > 0) && this.ActiveTab.AbleToDelete);
             this.ctxPaste.Enabled = (Clipboard.ContainsText() && this.ActiveTab.AbleToPaste);
             this.ctxRedo.Enabled = this.ActiveTab.AbleToRedo;
             this.ctxUndo.Enabled = this.ActiveTab.AbleToUndo;
             this.ctxSelectAll.Enabled = this.ActiveTab.AbleToSelectAll;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1671" endline="1697"><![CDATA[
 
         /// <summary>
         /// Action before Edit Menu Opens...
         /// </summary>
         /// <param name="sender">Edit Menu</param>
         /// <param name="e">Events</param>
         private void mnuEdit_DropDownOpening(object sender, EventArgs e)
         {
             if (this.ActiveContent != null)
             {
                 this.mnuEditCut.Enabled = ((this.ActiveTab.Selection.Length > 0) && this.ActiveTab.AbleToCut);
                 this.mnuEditCopy.Enabled = ((this.ActiveTab.Selection.Length > 0) && this.ActiveTab.AbleToCopy);
                 this.mnuEditDelete.Enabled = ((this.ActiveTab.Selection.Length > 0) && this.ActiveTab.AbleToDelete);
                 this.mnuEditPaste.Enabled = this.ActiveTab.AbleToPaste;
                 this.mnuEditRedo.Enabled = this.ActiveTab.AbleToRedo;
                 this.mnuEditUndo.Enabled = this.ActiveTab.AbleToUndo;
                 this.mnuEditSelectAll.Enabled = this.ActiveTab.AbleToSelectAll;
             }
             else
             {
                 this.mnuEditCut.Enabled = this.mnuEditCopy.Enabled = this.mnuEditDelete.Enabled = false;
                 this.mnuEditPaste.Enabled = false;
                 this.mnuEditRedo.Enabled = false;
                 this.mnuEditUndo.Enabled = false;
                 this.mnuEditSelectAll.Enabled = false;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1698" endline="1714"><![CDATA[
 
         /// <summary>
         /// Action before File Menu Opens...
         /// </summary>
         /// <param name="sender">File Menu</param>
         /// <param name="e">Events</param>
         private void fileToolStripMenuItem_DropDownOpening(object sender, EventArgs e)
         {
             if (this.ActiveTab != null)
             {
                 this.mnuFileSave.Enabled = this.mnuFileSaveAs.Enabled = this.ActiveTab.AbleToSave;
             }
             else
             {
                 this.mnuFileSave.Enabled = this.mnuFileSaveAs.Enabled = false;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1715" endline="1728"><![CDATA[
 
         #endregion
 
         #region -= Tab Context Menu =-
 
         /// <summary>
         /// Saves the Current Document...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.Save();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1729" endline="1738"><![CDATA[
 
         /// <summary>
         /// Closes the Current Document...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void ctsClose_Click(object sender, EventArgs e)
         {
             this.ActiveTab.CloseTab();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1739" endline="1758"><![CDATA[
 
         /// <summary>
         /// Closes all but the Current Document...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void ctxCloseAllBut_Click(object sender, EventArgs e)
         {
             for (int a = this.DockMain.Contents.Count - 1; a >= 0; a--)
             {
                 if (this.DockMain.Contents[a].DockHandler.DockState == DockState.Document)
                 {
                     IPeterPluginTab tab = (IPeterPluginTab)this.DockMain.Contents[a];
                     if (tab != this.ActiveTab)
                     {
                         tab.CloseTab();
                     }
                 }
             }
             for (int a = this.DockMain.Contents.Count - 1; a >= 0; a--)
             {
                 if (this.DockMain.Contents[a].DockHandler.DockState == DockState.Document)
                 {
                     IPeterPluginTab tab = (IPeterPluginTab)this.DockMain.Contents[a];
                     if (tab != this.ActiveTab)
                     {
                         tab.CloseTab();
                     }
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1759" endline="1771"><![CDATA[
 
         /// <summary>
         /// Copys the path of the Current Document...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void copyPathToolStripMenuItem_Click(object sender, EventArgs e)
         {
             if (this.ActiveTab.FileName != null && this.ActiveTab.FileName != string.Empty)
             {
                 Clipboard.SetText(this.ActiveTab.FileName);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1772" endline="1785"><![CDATA[
 
         /// <summary>
         /// Opens the Folder containing the Current Document...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void openFolderToolStripMenuItem_Click(object sender, EventArgs e)
         {
             if (this.ActiveTab.FileName != null && this.ActiveTab.FileName != string.Empty)
             {
                 System.Diagnostics.Process.Start("explorer.exe",
                     Path.GetDirectoryName(this.ActiveTab.FileName));
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1786" endline="1796"><![CDATA[
 
         /// <summary>
         /// Event Before Tab Context Menu is opened
         /// </summary>
         /// <param name="sender">Tab Context Menu Strip</param>
         /// <param name="e">Events</param>
         private void ctxTab_Opening(object sender, CancelEventArgs e)
         {
             this.copyPathToolStripMenuItem.Enabled = 
                 this.openFolderToolStripMenuItem.Enabled = (this.ActiveTab.FileName != null);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1797" endline="1873"><![CDATA[
 
         #endregion
 
         #region -= On Closing =-
 
         /// <summary>
         /// Intercepts the Closing Action to do some clean up items...
         /// </summary>
         /// <param name="e">Cancel Events</param>
         protected override void OnClosing(CancelEventArgs e)
         {
             for (int a = this.DockMain.Contents.Count - 1; a >= 0; a--)
             {
                 IPeterPluginTab tab = (IPeterPluginTab)this.DockMain.Contents[a];
                 if (tab.AbleToSave && tab.NeedsSaving)
                 {
                     e.Cancel = !tab.CloseTab();
                 }
             }
             for (int a = this.DockMain.Contents.Count - 1; a >= 0; a--)
             {
                 IPeterPluginTab tab = (IPeterPluginTab)this.DockMain.Contents[a];
                 if (tab.AbleToSave && tab.NeedsSaving)
                 {
                     e.Cancel = !tab.CloseTab();
                 }
             }
 
             if (!e.Cancel)
             {
                 // Save Dock Layout...
                 if (this.m_SaveonExit)
                 {
                     this.DockMain.SaveAsXml(this.m_DockConfigFile);
                 }
                 else
                 {
                     if (File.Exists(this.m_DockConfigFile))
                     {
                         File.Delete(this.m_DockConfigFile);
                     }
                 }
 
                 // Save Location...
                 if (File.Exists(this.m_ConfigFile) && this.WindowState != FormWindowState.Minimized)
                 {
                     // Load Config File...
                     XmlDocument xDoc = new XmlDocument();
                     xDoc.Load(this.m_ConfigFile);
                     XmlNodeList nodes = xDoc.GetElementsByTagName("Application");
                     if (nodes.Count == 1)
                     {
                         foreach (XmlNode n in nodes[0].ChildNodes)
                         {
                             switch (n.Name.ToLower())
                             {
                                 case "top"
                                     n.InnerText = this.Top.ToString();
                                     break;
                                 case "left"
                                     n.InnerText = this.Left.ToString();
                                     break;
                                 case "width"
                                     n.InnerText = this.Width.ToString();
                                     break;
                                 case "height"
                                     n.InnerText = this.Height.ToString();
                                     break;
                                 case "saveonexit"
                                     n.InnerText = this.m_SaveonExit.ToString();
                                     break;
                             }
                         }
                         foreach (XmlNode n in nodes[0].ChildNodes)
                         {
                             switch (n.Name.ToLower())
                             {
                                 case "top"
                                     n.InnerText = this.Top.ToString();
                                     break;
                                 case "left"
                                     n.InnerText = this.Left.ToString();
                                     break;
                                 case "width"
                                     n.InnerText = this.Width.ToString();
                                     break;
                                 case "height"
                                     n.InnerText = this.Height.ToString();
                                     break;
                                 case "saveonexit"
                                     n.InnerText = this.m_SaveonExit.ToString();
                                     break;
                             }
                         }
                     }
                     xDoc.Save(this.m_ConfigFile);
                 }
 
                 foreach (IPeterPlugin plugin in this.m_Plugins)
                 {
                     plugin.Close();
                 }
                 foreach (IPeterPlugin plugin in this.m_Plugins)
                 {
                     plugin.Close();
                 }
             }
 
             base.OnClosing(e);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1874" endline="1888"><![CDATA[
 
         #endregion
 
         #region -= Update Tool Bar =-
 
         /// <summary>
         /// Updates the Buttons on the tool bar...
         /// </summary>
         public void UpdateToolBar()
         {
             this.tsbSave.Enabled = this.ActiveTab.AbleToSave;
             this.tsbCut.Enabled = this.ActiveTab.AbleToCut;
             this.tsbCopy.Enabled = this.ActiveTab.AbleToCopy;
             this.tsbPaste.Enabled = this.ActiveTab.AbleToPaste;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1889" endline="1905"><![CDATA[
 
         #endregion
 
         #region -= Book Mark Menu =-
 
         /// <summary>
         /// Toggles a book mark on the active editor...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuBookMarkToggle_Click(object sender, EventArgs e)
         {
             if (this.ActiveEditor != null)
             {
                 this.ActiveEditor.ToggleMark();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1906" endline="1918"><![CDATA[
 
         /// <summary>
         /// Removes all book marks on the active editor...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuBookMarkRemoveAll_Click(object sender, EventArgs e)
         {
             if (this.ActiveEditor != null)
             {
                 this.ActiveEditor.RemoveAllMarks();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1919" endline="1931"><![CDATA[
 
         /// <summary>
         /// Goes to the next book mark on the active editor...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuBookMarkNext_Click(object sender, EventArgs e)
         {
             if (this.ActiveEditor != null)
             {
                 this.ActiveEditor.GotoMark(true);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1932" endline="1944"><![CDATA[
 
         /// <summary>
         /// Goes to the Previous book mark on the active editor...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuBookMarkPrevious_Click(object sender, EventArgs e)
         {
             if (this.ActiveEditor != null)
             {
                 this.ActiveEditor.GotoMark(false);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1945" endline="1959"><![CDATA[
 
         #endregion
 
         #region -= Help Menu =-
 
         /// <summary>
         /// Shows the About Form...
         /// </summary>
         /// <param name="sender">ToolStipMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuHelpAbout_Click(object sender, EventArgs e)
         {
             SplashScreen ss = new SplashScreen(true);
             ss.ShowDialog();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1960" endline="1975"><![CDATA[
 
         #endregion
 
         #region -= Find/Replace =-
 
         /// <summary>
         /// Activates the Find Dialog...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuSearchFind_Click(object sender, EventArgs e)
         {
             // Set Dialog for Find...
             this.ShowFindDialog();
             this.m_FindControl.SetFind(false);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1976" endline="1985"><![CDATA[
 
         /// <summary>
         /// Finds the Next Occurance of the given Pattern
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuSearchFindNext_Click(object sender, EventArgs e)
         {
             this.FindNext(false);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1986" endline="1990"><![CDATA[
 
         private void findPreviousToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.FindNext(true);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="1991" endline="2002"><![CDATA[
 
         /// <summary>
         /// Finds the Next Occurance of the given Pattern
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void findInFilesToolStripMenuItem_Click(object sender, EventArgs e)
         {
             // Set Dialog for Find...
             this.ShowFindDialog();
             this.m_FindControl.SetFind(true);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2003" endline="2013"><![CDATA[
 
         /// <summary>
         /// Finds the Next Occurance of the given Pattern
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuSearchReplace_Click(object sender, EventArgs e)
         {
             this.ShowFindDialog();
             this.m_FindControl.SetReplace(false);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2014" endline="2023"><![CDATA[
 
         /// <summary>
         /// Finds the Next Occurance of the given Pattern
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void replaceNextToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.ReplaceNext();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2024" endline="2034"><![CDATA[
 
         /// <summary>
         /// Finds the Next Occurance of the given Pattern
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void replaceInFilesToolStripMenuItem_Click(object sender, EventArgs e)
         {
             this.ShowFindDialog();
             this.m_FindControl.SetReplace(true);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2035" endline="2049"><![CDATA[
 
         /// <summary>
         /// Activates the Find Next Method...
         /// </summary>
         /// <param name="sender">ToolStripButton</param>
         /// <param name="e">Events</param>
         private void tsbFind_Click(object sender, EventArgs e)
         {
             if (!string.IsNullOrEmpty(this.txtFindNext.Text))
             {
                 this.m_FindControl.SetFind(false);
                 this.m_FindControl.FindText = this.txtFindNext.Text;
                 this.FindNext(false);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2050" endline="2062"><![CDATA[
 
         /// <summary>
         /// Check for enter being pressing in find box...
         /// </summary>
         /// <param name="sender">ToolStripTextBox</param>
         /// <param name="e">Events</param>
         void txtFindNext_KeyDown(object sender, KeyEventArgs e)
         {
             if (e.KeyCode == Keys.Enter)
             {
                 tsbFind_Click(null, null);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2063" endline="2078"><![CDATA[
 
         /// <summary>
         /// Makes the find Dialog Visible...
         /// </summary>
         private void ShowFindDialog()
         {
             // Grab the Selection...
             if(this.ActiveTab != null)
                 if (this.ActiveTab.Selection.Length > 0)
                     this.m_FindControl.FindText = this.ActiveTab.Selection;
 
             if (!this.m_FindControl.Visible)
             {
                 this.m_FindControl.Show(this);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2079" endline="2091"><![CDATA[
 
         /// <summary>
         /// Finds the Next Occurance of the given Pattern in the Active Document...
         /// </summary>
         public bool FindNext(bool findUp)
         {
             if (this.ActiveContent != null)
             {
                 IPeterPluginTab tab = (IPeterPluginTab)this.ActiveContent;
                 return tab.FindNext(this.m_FindControl.GetRegEx(), findUp);
             }
             return false;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2092" endline="2106"><![CDATA[
 
         /// <summary>
         /// Finds the given Pattern in all of the Open Files...
         /// </summary>
         public void FindInOpenFiles()
         {
             for (int a = 0; a < this.DockMain.Contents.Count; a++)
             {
                 IPeterPluginTab tab = (IPeterPluginTab)this.DockMain.Contents[a];
                 if (!string.IsNullOrEmpty(tab.FileName))
                 {
                     this.m_FindControl.FindInFile(new FileInfo(tab.FileName), this.m_FindControl.FindText, this.m_FindControl.GetRegEx());
                 }
             }
             for (int a = 0; a < this.DockMain.Contents.Count; a++)
             {
                 IPeterPluginTab tab = (IPeterPluginTab)this.DockMain.Contents[a];
                 if (!string.IsNullOrEmpty(tab.FileName))
                 {
                     this.m_FindControl.FindInFile(new FileInfo(tab.FileName), this.m_FindControl.FindText, this.m_FindControl.GetRegEx());
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2107" endline="2118"><![CDATA[
 
         /// <summary>
         /// Replaces the Next Occurance of the given Pattern in the Active Document...
         /// </summary>
         public void ReplaceNext()
         {
             if (this.ActiveContent != null)
             {
                 IPeterPluginTab tab = (IPeterPluginTab)this.ActiveContent;
                 tab.ReplaceNext(this.m_FindControl.GetRegEx(), this.m_FindControl.ReplaceText, this.m_FindControl.FindUp);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2119" endline="2130"><![CDATA[
 
         /// <summary>
         /// Replaces all the Occurance of the given Pattern in the Active Document...
         /// </summary>
         public void ReplaceAll()
         {
             if (this.ActiveContent != null)
             {
                 IPeterPluginTab tab = (IPeterPluginTab)this.ActiveContent;
                 tab.ReplaceAll(this.m_FindControl.GetRegEx(), this.m_FindControl.ReplaceText);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2131" endline="2142"><![CDATA[
 
         /// <summary>
         /// Replaces all the Occurance of the given Pattern in all the Documents...
         /// </summary>
         public void ReplaceInOpenFiles()
         {
             for (int a = 0; a < this.DockMain.Contents.Count; a++)
             {
                 IPeterPluginTab tab = (IPeterPluginTab)this.DockMain.Contents[a];
                 tab.ReplaceAll(this.m_FindControl.GetRegEx(), this.m_FindControl.ReplaceText);
             }
             for (int a = 0; a < this.DockMain.Contents.Count; a++)
             {
                 IPeterPluginTab tab = (IPeterPluginTab)this.DockMain.Contents[a];
                 tab.ReplaceAll(this.m_FindControl.GetRegEx(), this.m_FindControl.ReplaceText);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2143" endline="2154"><![CDATA[
 
         /// <summary>
         /// Marks all occurances of the given Pattern in the active Document...
         /// </summary>
         public void MarkAll()
         {
             if (this.ActiveContent != null)
             {
                 IPeterPluginTab tab = (IPeterPluginTab)this.ActiveContent;
                 tab.MarkAll(this.m_FindControl.GetRegEx());
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2155" endline="2169"><![CDATA[
 
         #endregion
 
         #region -= Select Word =-
 
         /// <summary>
         /// Selects text at the offset with the give length...
         /// </summary>
         /// <param name="line">Line text is on.</param>
         /// <param name="offset">Offset Text is At.</param>
         /// <param name="wordLeng">Length of Text.</param>
         public void SelectWord(int line, int offset, int wordLeng)
         {
             this.ActiveTab.SelectWord(line, offset, wordLeng);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2170" endline="2190"><![CDATA[
 
         #endregion
 
         #region -= Project Menu =-
 
         /// <summary>
         /// Shows the project manager...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuProjectShow_Click(object sender, EventArgs e)
         {
             if (this.m_ProjMan.DockState == DockState.Unknown)
             {
                 this.m_ProjMan.Show(this.DockMain, DockState.DockLeft);
             }
             else
             {
                 this.m_ProjMan.Show();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2191" endline="2207"><![CDATA[
 
         /// <summary>
         /// Opens a project...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuProjectOpen_Click(object sender, EventArgs e)
         {
             this.ofdMain.Multiselect = false;
             this.ofdMain.Filter = "Peter Project File (*.pproj)|*.pproj";
             if (this.ofdMain.ShowDialog() == DialogResult.OK)
             {
                 OpenProject(this.ofdMain.FileName);
             }
             this.ofdMain.Multiselect = true;
             this.ofdMain.Filter = "";
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2208" endline="2284"><![CDATA[
 
         /// <summary>
         /// Opens the given project...
         /// </summary>
         /// <param name="fileName">Path to project file.</param>
         private void OpenProject(string fileName)
         {
             // Is this a project file...
             if (Path.GetExtension(fileName).ToLower() == ".pproj")
             {
                 this.mnuProjectShow_Click(null, null);
                 // Load a Project...
                 string proj = this.m_ProjMan.LoadFile(fileName);
 
                 if (proj == null)
                 {
                     // The project was already open...
                     return;
                 }
 
                 // Add Menu Item if Needed...
                 if (!this.mnuProjectReopen.DropDownItems.ContainsKey(fileName))
                 {
                     ToolStripMenuItem tsmi = new ToolStripMenuItem(proj);
                     tsmi.Click += new EventHandler(ReopenProject);
                     //tsmi.Tag = fileName;
                     tsmi.Name = fileName;
 
                     this.mnuProjectReopen.DropDownItems.Add(tsmi);
                 }
 
                 // Update Config file...
                 bool inList = false;
                 int count = 0;
                 XmlDocument xDoc = new XmlDocument();
                 xDoc.Load(this.m_ConfigFile);
                 XmlNodeList recent = xDoc.GetElementsByTagName("RecentProjects");
                 if (recent.Count == 1)
                 {
                     XmlNode recentNode = recent[0];
                     foreach (XmlNode n in recentNode.ChildNodes)
                     {
                         count++;
                         foreach (XmlNode nC in n.ChildNodes)
                         {
                             if (nC.InnerText == fileName)
                             {
                                 inList = true;
                                 break;
                             }
                         }
                         foreach (XmlNode nC in n.ChildNodes)
                         {
                             if (nC.InnerText == fileName)
                             {
                                 inList = true;
                                 break;
                             }
                         }
 
                         if (inList) break;
                     }
                     foreach (XmlNode n in recentNode.ChildNodes)
                     {
                         count++;
                         foreach (XmlNode nC in n.ChildNodes)
                         {
                             if (nC.InnerText == fileName)
                             {
                                 inList = true;
                                 break;
                             }
                         }
 
                         if (inList) break;
                     }
 
                     if (!inList)
                     {
                         if (count == this.m_RecentProjectCount)
                         {
                             // Remove the First Node...
                             recentNode.RemoveChild(recentNode.ChildNodes[0]);
                         }
 
                         // Add the new project...
                         XmlNode newProjectNode = xDoc.CreateNode(XmlNodeType.Element, "project", null);
                         XmlNode newFileNode = xDoc.CreateNode(XmlNodeType.Element, "file", null);
                         newFileNode.InnerText = fileName;
                         XmlNode newNameNode = xDoc.CreateNode(XmlNodeType.Element, "name", null);
                         newNameNode.InnerText = proj;
                         newProjectNode.AppendChild(newNameNode);
                         newProjectNode.AppendChild(newFileNode);
                         recentNode.AppendChild(newProjectNode);
                         xDoc.Save(this.m_ConfigFile);
                     }
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2285" endline="2297"><![CDATA[
 
         /// <summary>
         /// Reopens a project...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         void ReopenProject(object sender, EventArgs e)
         {
             ToolStripMenuItem tsmi = sender as ToolStripMenuItem;
             this.mnuProjectShow_Click(null, null);
             // Load a Project...
             string proj = this.m_ProjMan.LoadFile(tsmi.Name);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2298" endline="2316"><![CDATA[
 
         /// <summary>
         /// Creates a new Project...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuProjectNew_Click(object sender, EventArgs e)
         {
             Project prj = new Project();
             prj.ShowDialog();
             if (prj.ProjectFile != null)
             {
                 this.OpenProject(prj.ProjectFile);
             }
             if (!prj.IsDisposed)
             {
                 prj.Close();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2317" endline="2338"><![CDATA[
 
         #endregion
 
         #region -= Options =-
 
         /// <summary>
         /// Shows the Options Dialog...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuOptions_Click(object sender, EventArgs e)
         {
             Options frm = new Options(this);
             foreach (IPeterPlugin plugin in this.m_Plugins)
             {
                 if (plugin.OptionPanel != null)
                 {
                     frm.AddOptionPanel(plugin.OptionPanel, plugin.PluginImage);
                 }
             }
             foreach (IPeterPlugin plugin in this.m_Plugins)
             {
                 if (plugin.OptionPanel != null)
                 {
                     frm.AddOptionPanel(plugin.OptionPanel, plugin.PluginImage);
                 }
             }
             frm.ShowDialog();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2339" endline="2354"><![CDATA[
 
         #endregion
 
         #region -= Run Menu =-
 
         /// <summary>
         /// Starts a command Prompt...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuRunCMD_Click(object sender, EventArgs e)
         {
             CommandPrompt cmd = new CommandPrompt();
             cmd.Icon = Icon.FromHandle(((Bitmap)this.GetInternalImage("cmd")).GetHicon());
             this.AddDockContent(new CommandPrompt(), DockState.DockBottom);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2355" endline="2364"><![CDATA[
 
         /// <summary>
         /// Runs a given command...
         /// </summary>
         /// <param name="command">Command to Run.</param>
         public void RunCommand(string command)
         {
             CommandPrompt cmd = this.GetCMD();
             cmd.RunCommand(command);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2365" endline="2375"><![CDATA[
 
         /// <summary>
         /// Runs the given Script in the given Directory...
         /// </summary>
         /// <param name="script">Script to Run (Commands are separated by new lines).</param>
         /// <param name="workingDir">Directory to run script.</param>
         public void RunScript(string script, string workingDir)
         {
             CommandPrompt cmd = this.GetCMD();
             cmd.RunScript(script, workingDir);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2376" endline="2400"><![CDATA[
 
         /// <summary>
         /// Finds an open Command Prompt, if none creates one.
         /// </summary>
         /// <returns>CommandPrompt</returns>
         public CommandPrompt GetCMD()
         {
             CommandPrompt cmd = null;
             foreach (IDockContent dc in this.DockMain.Contents)
             {
                 if (dc.GetType() == typeof(CommandPrompt))
                 {
                     cmd = (CommandPrompt)dc;
                     cmd.Show();
                     break;
                 }
             }
             foreach (IDockContent dc in this.DockMain.Contents)
             {
                 if (dc.GetType() == typeof(CommandPrompt))
                 {
                     cmd = (CommandPrompt)dc;
                     cmd.Show();
                     break;
                 }
             }
             if (cmd == null)
             {
                 this.mnuRunCMD_Click(null, null);
                 cmd = (CommandPrompt)this.DockMain.Contents[this.DockMain.Contents.Count - 1];
             }
 
             return cmd;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2401" endline="2416"><![CDATA[
 
         #endregion
 
         #region -= Tools Menu =-
 
         /// <summary>
         /// Creates a new File Explorer...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void mnuToolsFileExplorer_Click(object sender, EventArgs e)
         {
             ctrlFileExplorer fe = new ctrlFileExplorer(this);
             fe.Icon = Icon.FromHandle(((Bitmap)this.GetInternalImage("FEIcon")).GetHicon());
             this.AddDockContent(fe, DockState.DockLeft);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2417" endline="2429"><![CDATA[
 
         /// <summary>
         /// Shows the Code Structure...
         /// </summary>
         /// <param name="sender">ToolStripMenuItem</param>
         /// <param name="e">Events</param>
         private void tsmiCodeStructure_Click (object sender, EventArgs e)
         {
             if (this.m_CodeStructure.VisibleState == DockState.Unknown)
             {
                 this.AddDockContent(this.m_CodeStructure, DockState.DockRight);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2430" endline="2439"><![CDATA[
 
         #endregion
 
         #region -= Code Menu =-
 
         private void mnuCodeLineComment_Click(object sender, EventArgs e)
         {
             string text = this.ActiveEditor.GetText();
             text.Split('\n');
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2440" endline="2493"><![CDATA[
 
         private void xMLToolStripMenuItem_Click (object sender, EventArgs e)
         {
             if (this.ActiveEditor != null)
             {
                 //will hold formatted xml
                 StringBuilder sb = new StringBuilder();
                 //does the formatting
                 XmlTextWriter xtw = null;
                 try
                 {
                     /*
                     & - &amp; 
                     < - &lt; 
                     > - &gt; 
                     " - &quot; 
                     ' - &#39; 
                     */
                     string xml = this.ActiveEditor.GetText();
                     xml = xml.Replace("&", "&amp;");
 
                     //load unformatted xml into a dom
                     XmlDocument xd = new XmlDocument();
                     xd.LoadXml(xml);
 
                     //pumps the formatted xml into the StringBuilder above
                     StringWriter sw = new StringWriter(sb);
 
                     //point the xtw at the StringWriter
                     xtw = new XmlTextWriter(sw);
 
                     //we want the output formatted
                     xtw.Formatting = Formatting.Indented;
                     xtw.Indentation = 4;
 
                     //get the dom to dump its contents into the xtw 
                     xd.WriteTo(xtw);
                 }
                 catch (Exception ex)
                 {
                     MessageBox.Show(this, "Error while parsing XML.\n" + ex.Message, "Peter", MessageBoxButtons.OK, MessageBoxIcon.Error);
                 }
                 finally
                 {
                     //clean up even if error
                     if (xtw != null)
                         xtw.Close();
                 }
 
                 //return the formatted xml
                 if(!string.IsNullOrEmpty(sb.ToString()))
                     this.ActiveEditor.SetTextChanged(sb.ToString().Replace("&amp;", "&"));
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2494" endline="2517"><![CDATA[
 
         #endregion
 
         protected override void WndProc(ref Message m)
         {
             switch (m.Msg)
             {
                 case WM_COPYDATA
                     CopyDataStruct str = (CopyDataStruct)Marshal.PtrToStructure(m.LParam, typeof(CopyDataStruct));
                     string[] files = str.lpData.Split('|');
                     foreach (string file in files)
                     {
                         if (!string.IsNullOrEmpty(file))
                         {
                             if (File.Exists(file))
                             {
                                 this.CreateEditor(file, Path.GetFileName(file), Common.GetFileIcon(file, false));
                             }
                         }
                     }
                     foreach (string file in files)
                     {
                         if (!string.IsNullOrEmpty(file))
                         {
                             if (File.Exists(file))
                             {
                                 this.CreateEditor(file, Path.GetFileName(file), Common.GetFileIcon(file, false));
                             }
                         }
                     }
                     break;
             }
             base.WndProc(ref m);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2518" endline="2542"><![CDATA[
 
         /// <summary>
         /// Updates the Status Bar's Caret Info...
         /// </summary>
         /// <param name="offset">Offset of Caret.</param>
         /// <param name="line">Line Carret is on.</param>
         /// <param name="col">Column Carret is at.</param>
         /// <param name="mode">Mode of Carret.</param>
         public void UpdateCaretPos(int offset, int line, int col, string mode)
         {
             if (string.IsNullOrEmpty(mode))
             {
                 this.sslLine.Text = "";
                 this.sslOther.Text = "";
                 this.sslInsert.Text = "";
                 this.sslColumn.Text = "";
             }
             else
             {
                 this.sslLine.Text = "Line
                 this.sslOther.Text = mode;
                 this.sslInsert.Text = "Offset
                 this.sslColumn.Text = "Column
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Forms\MainForm.cs" startline="2543" endline="2553"><![CDATA[
 
         /// <summary>
         /// Looks up the given word in the given project...
         /// </summary>
         /// <param name="word">Word to look up.</param>
         /// <param name="project">Project to look in.</param>
         /// <returns>Any information if found.</returns>
         public string LookUpProject (string word, string project)
         {
             return this.m_ProjMan.LookUp(word, project);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="17" endline="25"><![CDATA[
         public VBCodeInfo()
         {
             this.m_Imports = new ArrayList();
             this.m_NameSpaces = new ArrayList();
             this.m_Fields = new ArrayList();
             this.m_Methods = new ArrayList();
             this.m_Properties = new ArrayList();
             this.m_Constructors = new ArrayList();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="26" endline="32"><![CDATA[
 
         /// <summary>
         /// Gets or Sets the List of 'Imports ...' in the code...
         /// </summary>
         public ArrayList Imports
         {
             get { return this.m_Imports; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="33" endline="34"><![CDATA[
 
             set { this.m_Imports = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="35" endline="42"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets the List of 'namespace ...' in the code...
         /// </summary>
         public ArrayList NameSpaces
         {
             get { return this.m_NameSpaces; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="43" endline="44"><![CDATA[
 
             set { this.m_NameSpaces = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="45" endline="52"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets the List of Fields in the code...
         /// </summary>
         public ArrayList Fields
         {
             get { return this.m_Fields; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="53" endline="54"><![CDATA[
 
             set { this.m_Fields = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="55" endline="62"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets the List of Methods in the code...
         /// </summary>
         public ArrayList Methods
         {
             get { return this.m_Methods; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="63" endline="64"><![CDATA[
 
             set { this.m_Methods = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="65" endline="72"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets the List of Properties in the code...
         /// </summary>
         public ArrayList Properties
         {
             get { return this.m_Properties; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="73" endline="74"><![CDATA[
 
             set { this.m_Properties = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="75" endline="82"><![CDATA[
         }
 
         /// <summary>
         /// Gets or Sets the List of Constructors in the code...
         /// </summary>
         public ArrayList Constructors
         {
             get { return this.m_Constructors; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="83" endline="84"><![CDATA[
 
             set { this.m_Constructors = value; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="26" endline="30"><![CDATA[
         {
             DirectoryInfo dir1 = (DirectoryInfo)x;
             DirectoryInfo dir2 = (DirectoryInfo)y;
             return dir1.Name.CompareTo(dir2.Name);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="31" endline="43"><![CDATA[
     }
 
     /// <summary>Provides IComparer by comparing file names</summary>
     /// <remarks>It is assumed that each object passed into Compare is an instance of
     /// <see cref="T
     public class cFileSorter 
     {
         public int Compare(object x, object y)
         {
             FileInfo file1 = (FileInfo)x;
             FileInfo file2 = (FileInfo)y;
             return file1.Name.CompareTo(file2.Name);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="89" endline="89"><![CDATA[
         public override System.Drawing.Color BackColor { get { return V_BackColor; } set { V_BackColor = value; this.Refresh(); } }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="90" endline="93"><![CDATA[
 
         /// <summary>This feature will paint the group title background to the specified color if PaintGroupBox is set to true.</summary>
         [Category("Appearance"), Description("This feature will paint the group title background to the specified color if PaintGroupBox is set to true.")]
         public System.Drawing.Color CustomGroupBoxColor { get { return V_CustomGroupBoxColor; } set { V_CustomGroupBoxColor = value; this.Refresh(); } }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="94" endline="97"><![CDATA[
 
         /// <summary>This feature will paint the group title background to the CustomGroupBoxColor.</summary>
         [Category("Appearance"), Description("This feature will paint the group title background to the CustomGroupBoxColor.")]
         public bool PaintGroupBox { get { return V_PaintGroupBox; } set { V_PaintGroupBox = value; this.Refresh(); } }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="98" endline="101"><![CDATA[
 
         /// <summary>This feature can add a 16 x 16 image to the group title bar.</summary>
         [Category("Appearance"), Description("This feature can add a 16 x 16 image to the group title bar.")]
         public System.Drawing.Image GroupImage { get { return V_GroupImage; } set { V_GroupImage = value; this.Refresh(); } }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="102" endline="105"><![CDATA[
 
         /// <summary>This feature will change the control's shadow color.</summary>
         [Category("Appearance"), Description("This feature will change the control's shadow color.")]
         public System.Drawing.Color ShadowColor { get { return V_ShadowColor; } set { V_ShadowColor = value; this.Refresh(); } }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="106" endline="111"><![CDATA[
 
         /// <summary>This feature will change the size of the shadow border.</summary>
         [Category("Appearance"), Description("This feature will change the size of the shadow border.")]
         public int ShadowThickness
         {
             get { return V_ShadowThickness; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="112" endline="125"><![CDATA[
             set
             {
                 if (value > 10)
                 {
                     V_ShadowThickness = 10;
                 }
                 else
                 {
                     if (value < 1) { V_ShadowThickness = 1; }
                     else { V_ShadowThickness = value; }
                 }
 
                 this.Refresh();
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="126" endline="131"><![CDATA[
         }
 
 
         /// <summary>This feature will change the group control color. This color can also be used in combination with BackgroundGradientColor for a gradient paint.</summary>
         [Category("Appearance"), Description("This feature will change the group control color. This color can also be used in combination with BackgroundGradientColor for a gradient paint.")]
         public System.Drawing.Color BackgroundColor { get { return V_BackgroundColor; } set { V_BackgroundColor = value; this.Refresh(); } }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="132" endline="135"><![CDATA[
 
         /// <summary>This feature can be used in combination with BackgroundColor to create a gradient background.</summary>
         [Category("Appearance"), Description("This feature can be used in combination with BackgroundColor to create a gradient background.")]
         public System.Drawing.Color BackgroundGradientColor { get { return V_BackgroundGradientColor; } set { V_BackgroundGradientColor = value; this.Refresh(); } }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="136" endline="139"><![CDATA[
 
         /// <summary>This feature turns on background gradient painting.</summary>
         [Category("Appearance"), Description("This feature turns on background gradient painting.")]
         public GroupBoxGradientMode BackgroundGradientMode { get { return V_BackgroundGradientMode; } set { V_BackgroundGradientMode = value; this.Refresh(); } }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="140" endline="145"><![CDATA[
 
         /// <summary>This feature will round the corners of the control.</summary>
         [Category("Appearance"), Description("This feature will round the corners of the control.")]
         public int RoundCorners
         {
             get { return V_RoundCorners; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="146" endline="159"><![CDATA[
             set
             {
                 if (value > 25)
                 {
                     V_RoundCorners = 25;
                 }
                 else
                 {
                     if (value < 1) { V_RoundCorners = 1; }
                     else { V_RoundCorners = value; }
                 }
 
                 this.Refresh();
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="160" endline="164"><![CDATA[
         }
 
         /// <summary>This feature will add a group title to the control.</summary>
         [Category("Appearance"), Description("This feature will add a group title to the control.")]
         public string GroupTitle { get { return V_GroupTitle; } set { V_GroupTitle = value; this.Refresh(); } }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="165" endline="168"><![CDATA[
 
         /// <summary>This feature will allow you to change the color of the control's border.</summary>
         [Category("Appearance"), Description("This feature will allow you to change the color of the control's border.")]
         public System.Drawing.Color BorderColor { get { return V_BorderColor; } set { V_BorderColor = value; this.Refresh(); } }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="169" endline="174"><![CDATA[
 
         /// <summary>This feature will allow you to set the control's border size.</summary>
         [Category("Appearance"), Description("This feature will allow you to set the control's border size.")]
         public float BorderThickness
         {
             get { return V_BorderThickness; }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="175" endline="187"><![CDATA[
             set
             {
                 if (value > 3)
                 {
                     V_BorderThickness = 3;
                 }
                 else
                 {
                     if (value < 1) { V_BorderThickness = 1; }
                     else { V_BorderThickness = value; }
                 }
                 this.Refresh();
             }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="188" endline="192"><![CDATA[
         }
 
         /// <summary>This feature will allow you to turn on control shadowing.</summary>
         [Category("Appearance"), Description("This feature will allow you to turn on control shadowing.")]
         public bool ShadowControl { get { return V_ShadowControl; } set { V_ShadowControl = value; this.Refresh(); } }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="54" endline="203"><![CDATA[
         private System.ComponentModel.Container components = null;
         private int V_RoundCorners = 10;
         private string V_GroupTitle = "The Grouper";
         private System.Drawing.Color V_BorderColor = Color.Black;
         private float V_BorderThickness = 1;
         private bool V_ShadowControl = false;
         private System.Drawing.Color V_BackgroundColor = Color.White;
         private System.Drawing.Color V_BackgroundGradientColor = Color.White;
         private GroupBoxGradientMode V_BackgroundGradientMode = GroupBoxGradientMode.None;
         private System.Drawing.Color V_ShadowColor = Color.DarkGray;
         private int V_ShadowThickness = 3;
         private System.Drawing.Image V_GroupImage = null;
         private System.Drawing.Color V_CustomGroupBoxColor = Color.White;
         private bool V_PaintGroupBox = false;
         private System.Drawing.Color V_BackColor = Color.Transparent;
 
         #endregion
 
         #region Constants
 
         /// <summary>The sweep angle of the arc.</summary>
         public const int SweepAngle = 90;
 
         /// <summary>The minimum control height.</summary>
         public const int MinControlHeight = 32;
 
         /// <summary>The minimum control width.</summary>
         public const int MinControlWidth = 96;
 
         #endregion
 
         #region Properties
 
         /// <summary>This feature will paint the background color of the control.</summary>
         [Category("Appearance"), Description("This feature will paint the background color of the control.")]
         public override System.Drawing.Color BackColor { get { return V_BackColor; } set { V_BackColor = value; this.Refresh(); } }
 
         /// <summary>This feature will paint the group title background to the specified color if PaintGroupBox is set to true.</summary>
         [Category("Appearance"), Description("This feature will paint the group title background to the specified color if PaintGroupBox is set to true.")]
         public System.Drawing.Color CustomGroupBoxColor { get { return V_CustomGroupBoxColor; } set { V_CustomGroupBoxColor = value; this.Refresh(); } }
 
         /// <summary>This feature will paint the group title background to the CustomGroupBoxColor.</summary>
         [Category("Appearance"), Description("This feature will paint the group title background to the CustomGroupBoxColor.")]
         public bool PaintGroupBox { get { return V_PaintGroupBox; } set { V_PaintGroupBox = value; this.Refresh(); } }
 
         /// <summary>This feature can add a 16 x 16 image to the group title bar.</summary>
         [Category("Appearance"), Description("This feature can add a 16 x 16 image to the group title bar.")]
         public System.Drawing.Image GroupImage { get { return V_GroupImage; } set { V_GroupImage = value; this.Refresh(); } }
 
         /// <summary>This feature will change the control's shadow color.</summary>
         [Category("Appearance"), Description("This feature will change the control's shadow color.")]
         public System.Drawing.Color ShadowColor { get { return V_ShadowColor; } set { V_ShadowColor = value; this.Refresh(); } }
 
         /// <summary>This feature will change the size of the shadow border.</summary>
         [Category("Appearance"), Description("This feature will change the size of the shadow border.")]
         public int ShadowThickness
         {
             get { return V_ShadowThickness; }
             set
             {
                 if (value > 10)
                 {
                     V_ShadowThickness = 10;
                 }
                 else
                 {
                     if (value < 1) { V_ShadowThickness = 1; }
                     else { V_ShadowThickness = value; }
                 }
 
                 this.Refresh();
             }
         }
 
 
         /// <summary>This feature will change the group control color. This color can also be used in combination with BackgroundGradientColor for a gradient paint.</summary>
         [Category("Appearance"), Description("This feature will change the group control color. This color can also be used in combination with BackgroundGradientColor for a gradient paint.")]
         public System.Drawing.Color BackgroundColor { get { return V_BackgroundColor; } set { V_BackgroundColor = value; this.Refresh(); } }
 
         /// <summary>This feature can be used in combination with BackgroundColor to create a gradient background.</summary>
         [Category("Appearance"), Description("This feature can be used in combination with BackgroundColor to create a gradient background.")]
         public System.Drawing.Color BackgroundGradientColor { get { return V_BackgroundGradientColor; } set { V_BackgroundGradientColor = value; this.Refresh(); } }
 
         /// <summary>This feature turns on background gradient painting.</summary>
         [Category("Appearance"), Description("This feature turns on background gradient painting.")]
         public GroupBoxGradientMode BackgroundGradientMode { get { return V_BackgroundGradientMode; } set { V_BackgroundGradientMode = value; this.Refresh(); } }
 
         /// <summary>This feature will round the corners of the control.</summary>
         [Category("Appearance"), Description("This feature will round the corners of the control.")]
         public int RoundCorners
         {
             get { return V_RoundCorners; }
             set
             {
                 if (value > 25)
                 {
                     V_RoundCorners = 25;
                 }
                 else
                 {
                     if (value < 1) { V_RoundCorners = 1; }
                     else { V_RoundCorners = value; }
                 }
 
                 this.Refresh();
             }
         }
 
         /// <summary>This feature will add a group title to the control.</summary>
         [Category("Appearance"), Description("This feature will add a group title to the control.")]
         public string GroupTitle { get { return V_GroupTitle; } set { V_GroupTitle = value; this.Refresh(); } }
 
         /// <summary>This feature will allow you to change the color of the control's border.</summary>
         [Category("Appearance"), Description("This feature will allow you to change the color of the control's border.")]
         public System.Drawing.Color BorderColor { get { return V_BorderColor; } set { V_BorderColor = value; this.Refresh(); } }
 
         /// <summary>This feature will allow you to set the control's border size.</summary>
         [Category("Appearance"), Description("This feature will allow you to set the control's border size.")]
         public float BorderThickness
         {
             get { return V_BorderThickness; }
             set
             {
                 if (value > 3)
                 {
                     V_BorderThickness = 3;
                 }
                 else
                 {
                     if (value < 1) { V_BorderThickness = 1; }
                     else { V_BorderThickness = value; }
                 }
                 this.Refresh();
             }
         }
 
         /// <summary>This feature will allow you to turn on control shadowing.</summary>
         [Category("Appearance"), Description("This feature will allow you to turn on control shadowing.")]
         public bool ShadowControl { get { return V_ShadowControl; } set { V_ShadowControl = value; this.Refresh(); } }
 
         #endregion
 
         #region Constructor
 
         /// <summary>This method will construct a new GroupBox control.</summary>
         public Grouper ()
         {
             InitializeStyles();
             InitializeGroupBox();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="204" endline="215"><![CDATA[
 
 
         #endregion
 
         #region DeConstructor
 
         /// <summary>This method will dispose of the GroupBox control.</summary>
         protected override void Dispose (bool disposing)
         {
             if (disposing) { if (components != null) { components.Dispose(); } }
             base.Dispose(disposing);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="216" endline="231"><![CDATA[
 
 
         #endregion
 
         #region Initialization
 
         /// <summary>This method will initialize the controls custom styles.</summary>
         private void InitializeStyles ()
         {
             //Set the control styles----------------------------------
             this.SetStyle(ControlStyles.DoubleBuffer, true);
             this.SetStyle(ControlStyles.AllPaintingInWmPaint, true);
             this.SetStyle(ControlStyles.UserPaint, true);
             this.SetStyle(ControlStyles.SupportsTransparentBackColor, true);
             //--------------------------------------------------------
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="232" endline="242"><![CDATA[
 
 
         /// <summary>This method will initialize the GroupBox control.</summary>
         private void InitializeGroupBox ()
         {
             components = new System.ComponentModel.Container();
             this.Resize += new EventHandler(GroupBox_Resize);
             this.DockPadding.All = 20;
             this.Name = "GroupBox";
             this.Size = new System.Drawing.Size(368, 288);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="243" endline="255"><![CDATA[
 
 
         #endregion
 
         #region Protected Methods
 
         /// <summary>Overrides the OnPaint method to paint control.</summary>
         /// <param name="e">The paint event arguments.</param>
         protected override void OnPaint (PaintEventArgs e)
         {
             PaintBack(e.Graphics);
             PaintGroupText(e.Graphics);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="256" endline="370"><![CDATA[
 
         #endregion
 
         #region Private Methods
 
         /// <summary>This method will paint the group title.</summary>
         /// <param name="g">The paint event graphics object.</param>
         private void PaintGroupText (System.Drawing.Graphics g)
         {
             //Check if string has something-------------
             if (this.GroupTitle == string.Empty) { return; }
             //------------------------------------------
 
             //Set Graphics smoothing mode to Anit-Alias-- 
             g.SmoothingMode = SmoothingMode.AntiAlias;
             //-------------------------------------------
 
             //Declare Variables------------------
             SizeF StringSize = g.MeasureString(this.GroupTitle, this.Font);
             Size StringSize2 = StringSize.ToSize();
             if (this.GroupImage != null) { StringSize2.Width += 18; }
             int ArcWidth = this.RoundCorners;
             int ArcHeight = this.RoundCorners;
             int ArcX1 = 20;
             int ArcX2 = (StringSize2.Width + 34) - (ArcWidth + 1);
             int ArcY1 = 0;
             int ArcY2 = 24 - (ArcHeight + 1);
             System.Drawing.Drawing2D.GraphicsPath path = new System.Drawing.Drawing2D.GraphicsPath();
             System.Drawing.Brush BorderBrush = new SolidBrush(this.BorderColor);
             System.Drawing.Pen BorderPen = new Pen(BorderBrush, this.BorderThickness);
             System.Drawing.Drawing2D.LinearGradientBrush BackgroundGradientBrush = null;
             System.Drawing.Brush BackgroundBrush = (this.PaintGroupBox) ? new SolidBrush(this.CustomGroupBoxColor) 
             System.Drawing.SolidBrush TextColorBrush = new SolidBrush(this.ForeColor);
             System.Drawing.SolidBrush ShadowBrush = null;
             System.Drawing.Drawing2D.GraphicsPath ShadowPath = null;
             //-----------------------------------
 
             //Check if shadow is needed----------
             if (this.ShadowControl)
             {
                 ShadowBrush = new SolidBrush(this.ShadowColor);
                 ShadowPath = new System.Drawing.Drawing2D.GraphicsPath();
                 ShadowPath.AddArc(ArcX1 + (this.ShadowThickness - 1), ArcY1 + (this.ShadowThickness - 1), ArcWidth, ArcHeight, 180, Grouper.SweepAngle); // Top Left
                 ShadowPath.AddArc(ArcX2 + (this.ShadowThickness - 1), ArcY1 + (this.ShadowThickness - 1), ArcWidth, ArcHeight, 270, Grouper.SweepAngle); //Top Right
                 ShadowPath.AddArc(ArcX2 + (this.ShadowThickness - 1), ArcY2 + (this.ShadowThickness - 1), ArcWidth, ArcHeight, 360, Grouper.SweepAngle); //Bottom Right
                 ShadowPath.AddArc(ArcX1 + (this.ShadowThickness - 1), ArcY2 + (this.ShadowThickness - 1), ArcWidth, ArcHeight, 90, Grouper.SweepAngle); //Bottom Left
                 ShadowPath.CloseAllFigures();
 
                 //Paint Rounded Rectangle------------
                 g.FillPath(ShadowBrush, ShadowPath);
                 //-----------------------------------
             }
             //-----------------------------------
 
             //Create Rounded Rectangle Path------
             path.AddArc(ArcX1, ArcY1, ArcWidth, ArcHeight, 180, Grouper.SweepAngle); // Top Left
             path.AddArc(ArcX2, ArcY1, ArcWidth, ArcHeight, 270, Grouper.SweepAngle); //Top Right
             path.AddArc(ArcX2, ArcY2, ArcWidth, ArcHeight, 360, Grouper.SweepAngle); //Bottom Right
             path.AddArc(ArcX1, ArcY2, ArcWidth, ArcHeight, 90, Grouper.SweepAngle); //Bottom Left
             path.CloseAllFigures();
             //-----------------------------------
 
             //Check if Gradient Mode is enabled--
             if (this.PaintGroupBox)
             {
                 //Paint Rounded Rectangle------------
                 g.FillPath(BackgroundBrush, path);
                 //-----------------------------------
             }
             else
             {
                 if (this.BackgroundGradientMode == GroupBoxGradientMode.None)
                 {
                     //Paint Rounded Rectangle------------
                     g.FillPath(BackgroundBrush, path);
                     //-----------------------------------
                 }
                 else
                 {
                     BackgroundGradientBrush = new LinearGradientBrush(new Rectangle(0, 0, this.Width, this.Height), this.BackgroundColor, this.BackgroundGradientColor, (LinearGradientMode)this.BackgroundGradientMode);
 
                     //Paint Rounded Rectangle------------
                     g.FillPath(BackgroundGradientBrush, path);
                     //-----------------------------------
                 }
             }
             //-----------------------------------
 
             //Paint Borded-----------------------
             g.DrawPath(BorderPen, path);
             //-----------------------------------
 
             //Paint Text-------------------------
             int CustomStringWidth = (this.GroupImage != null) ? 44 
             g.DrawString(this.GroupTitle, this.Font, TextColorBrush, CustomStringWidth, 5);
             //-----------------------------------
 
             //Draw GroupImage if there is one----
             if (this.GroupImage != null)
             {
                 g.DrawImage(this.GroupImage, 28, 4, 16, 16);
             }
             //-----------------------------------
 
             //Destroy Graphic Objects------------
             if (path != null) { path.Dispose(); }
             if (BorderBrush != null) { BorderBrush.Dispose(); }
             if (BorderPen != null) { BorderPen.Dispose(); }
             if (BackgroundGradientBrush != null) { BackgroundGradientBrush.Dispose(); }
             if (BackgroundBrush != null) { BackgroundBrush.Dispose(); }
             if (TextColorBrush != null) { TextColorBrush.Dispose(); }
             if (ShadowBrush != null) { ShadowBrush.Dispose(); }
             if (ShadowPath != null) { ShadowPath.Dispose(); }
             //-----------------------------------
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="371" endline="452"><![CDATA[
 
 
         /// <summary>This method will paint the control.</summary>
         /// <param name="g">The paint event graphics object.</param>
         private void PaintBack (System.Drawing.Graphics g)
         {
             //Set Graphics smoothing mode to Anit-Alias-- 
             g.SmoothingMode = SmoothingMode.AntiAlias;
             //-------------------------------------------
 
             //Declare Variables------------------
             int ArcWidth = this.RoundCorners * 2;
             int ArcHeight = this.RoundCorners * 2;
             int ArcX1 = 0;
             int ArcX2 = (this.ShadowControl) ? (this.Width - (ArcWidth + 1)) - this.ShadowThickness 
             int ArcY1 = 10;
             int ArcY2 = (this.ShadowControl) ? (this.Height - (ArcHeight + 1)) - this.ShadowThickness 
             System.Drawing.Drawing2D.GraphicsPath path = new System.Drawing.Drawing2D.GraphicsPath();
             System.Drawing.Brush BorderBrush = new SolidBrush(this.BorderColor);
             System.Drawing.Pen BorderPen = new Pen(BorderBrush, this.BorderThickness);
             System.Drawing.Drawing2D.LinearGradientBrush BackgroundGradientBrush = null;
             System.Drawing.Brush BackgroundBrush = new SolidBrush(this.BackgroundColor);
             System.Drawing.SolidBrush ShadowBrush = null;
             System.Drawing.Drawing2D.GraphicsPath ShadowPath = null;
             //-----------------------------------
 
             //Check if shadow is needed----------
             if (this.ShadowControl)
             {
                 ShadowBrush = new SolidBrush(this.ShadowColor);
                 ShadowPath = new System.Drawing.Drawing2D.GraphicsPath();
                 ShadowPath.AddArc(ArcX1 + this.ShadowThickness, ArcY1 + this.ShadowThickness, ArcWidth, ArcHeight, 180, Grouper.SweepAngle); // Top Left
                 ShadowPath.AddArc(ArcX2 + this.ShadowThickness, ArcY1 + this.ShadowThickness, ArcWidth, ArcHeight, 270, Grouper.SweepAngle); //Top Right
                 ShadowPath.AddArc(ArcX2 + this.ShadowThickness, ArcY2 + this.ShadowThickness, ArcWidth, ArcHeight, 360, Grouper.SweepAngle); //Bottom Right
                 ShadowPath.AddArc(ArcX1 + this.ShadowThickness, ArcY2 + this.ShadowThickness, ArcWidth, ArcHeight, 90, Grouper.SweepAngle); //Bottom Left
                 ShadowPath.CloseAllFigures();
 
                 //Paint Rounded Rectangle------------
                 g.FillPath(ShadowBrush, ShadowPath);
                 //-----------------------------------
             }
             //-----------------------------------
 
             //Create Rounded Rectangle Path------
             path.AddArc(ArcX1, ArcY1, ArcWidth, ArcHeight, 180, Grouper.SweepAngle); // Top Left
             path.AddArc(ArcX2, ArcY1, ArcWidth, ArcHeight, 270, Grouper.SweepAngle); //Top Right
             path.AddArc(ArcX2, ArcY2, ArcWidth, ArcHeight, 360, Grouper.SweepAngle); //Bottom Right
             path.AddArc(ArcX1, ArcY2, ArcWidth, ArcHeight, 90, Grouper.SweepAngle); //Bottom Left
             path.CloseAllFigures();
             //-----------------------------------
 
             //Check if Gradient Mode is enabled--
             if (this.BackgroundGradientMode == GroupBoxGradientMode.None)
             {
                 //Paint Rounded Rectangle------------
                 g.FillPath(BackgroundBrush, path);
                 //-----------------------------------
             }
             else
             {
                 BackgroundGradientBrush = new LinearGradientBrush(new Rectangle(0, 0, this.Width, this.Height), this.BackgroundColor, this.BackgroundGradientColor, (LinearGradientMode)this.BackgroundGradientMode);
 
                 //Paint Rounded Rectangle------------
                 g.FillPath(BackgroundGradientBrush, path);
                 //-----------------------------------
             }
             //-----------------------------------
 
             //Paint Borded-----------------------
             g.DrawPath(BorderPen, path);
             //-----------------------------------
 
             //Destroy Graphic Objects------------
             if (path != null) { path.Dispose(); }
             if (BorderBrush != null) { BorderBrush.Dispose(); }
             if (BorderPen != null) { BorderPen.Dispose(); }
             if (BackgroundGradientBrush != null) { BackgroundGradientBrush.Dispose(); }
             if (BackgroundBrush != null) { BackgroundBrush.Dispose(); }
             if (ShadowBrush != null) { ShadowBrush.Dispose(); }
             if (ShadowPath != null) { ShadowPath.Dispose(); }
             //-----------------------------------
         }
]]></source>
<source file="C:\Users\faa634\Desktop\others\peter\trunk\Peter\Parsers\VBParser\VBCodeInfo.cs" startline="453" endline="461"><![CDATA[
 
 
         /// <summary>This method fires when the GroupBox resize event occurs.</summary>
         /// <param name="sender">The object the sent the event.</param>
         /// <param name="e">The event arguments.</param>
         private void GroupBox_Resize (object sender, EventArgs e)
         {
             this.Refresh();
         }
]]></source>
</source_elements></project>
