<clones  nfragments="2226" ngroups="5">
<clone_group groupid="0" nfragments="2210" Csharpe_files="29" vb_files="2181" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="1328" endline="1337">
<![CDATA[
 
     ''' <summary>
     ''' Creates a new symbol token of the specified symbol.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function NewToken(ByVal Symbol As KS) As Token
         Return Token.CreateSymbolToken(GetCurrentLocation, Symbol)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MemberCache.vb" startline="503" endline="513">
<![CDATA[
 
     ''' <summary>
     ''' Looks up the name in the flattened cache.
     ''' Looks case-insensitively
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function LookupFlattened(ByVal Name As String) As MemberCacheEntry
         Return LookupFlattened(Name, MemberVisibility.All)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="815" endline="821">
<![CDATA[
     End Property
 
     ReadOnly Property DefinedParametersTypes() As Mono.Cecil.TypeReference()
         Get
             If m_DefinedParametersTypes Is Nothing Then m_DefinedParametersTypes = Helper.GetTypes(DefinedParameters)
             Return m_DefinedParametersTypes
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="261" endline="269">
<![CDATA[
 
     ''' <summary>
     ''' Shows the message with the specified location and parameters
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function ShowMessageNoLocation(ByVal Message As Messages, ByVal ParamArray Parameters() As String) As Boolean
         Dim Location As Span = Nothing
         Return ShowMessage(False, New Message(Compiler, Message, Parameters, Location))
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="247" endline="258">
<![CDATA[
 
     ''' <summary>
     ''' Eats the current token if if coincides, if not shows a 
     ''' message "Expected
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Diagnostics.DebuggerHidden()> Function AcceptIfNotError(ByVal Special As KS, Optional ByVal GotoNewline As Boolean = False) As Boolean
         Return AcceptIfNotError(Special, Messages.VBNC90019, GotoNewline, Enums.strSpecial(Special))
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MemberCache.vb" startline="514" endline="524">
<![CDATA[
 
     ''' <summary>
     ''' Looks up the name in the cache.
     ''' Looks case-insensitively
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function Lookup(ByVal Name As String, ByVal Visibility As MemberVisibility) As MemberCacheEntry
         Return Lookup(Name, Visibility, False)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="253" endline="260">
<![CDATA[
 
     ''' <summary>
     ''' Shows the message with the specified location and parameters
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function ShowMessage(ByVal Message As Messages, ByVal Location As Span, ByVal ParamArray Parameters() As String) As Boolean
         Return ShowMessage(False, New Message(Compiler, Message, Parameters, Location))
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="270" endline="277">
<![CDATA[
 
     ''' <summary>
     ''' Shows the multiline message with the specified location and parameters.
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function ShowMessage(ByVal Message() As Messages, ByVal Location As Span, ByVal ParamArray Parameters()() As String) As Boolean
         Return ShowMessage(False, New Message(Compiler, Message, Parameters, Location))
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="278" endline="285">
<![CDATA[
 
     ''' <summary>
     ''' Saves the message with the specified location and parameters.
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Function SaveMessage(ByVal Message As Messages, ByVal Location As Span, ByVal ParamArray Parameters() As String) As Boolean
         Return ShowMessage(True, New Message(Compiler, Message, Parameters, Location))
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MemberCache.vb" startline="494" endline="502">
<![CDATA[
 
     Public Function LookupFlattened(ByVal Name As String, ByVal Visibility As MemberVisibility) As MemberCacheEntry
         Dim result As MemberCacheEntry = Nothing
 
         Load(Name, Visibility)
 
         m_FlattenedCacheInsensitive(Visibility).TryGetValue(Name, result)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4420" endline="4427">
<![CDATA[
 
     Shared Function IsAccessible(ByVal Context As BaseObject, ByVal Caller As Mono.Cecil.TypeReference, ByVal Method As Mono.Cecil.MethodReference) As Boolean
         If Caller Is Nothing Then
             Return Helper.IsAccessible(Context, CecilHelper.FindDefinition(Method).Attributes, Method.DeclaringType)
         Else
             Return Helper.IsAccessible(Context, CecilHelper.FindDefinition(Method).Attributes, Method.DeclaringType, Caller)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="331" endline="340">
<![CDATA[
     ''' <summary>
     ''' GotoNewline defaults to false for this overload.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <param name="Message"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptIfNotError(ByVal Special As KS, ByVal Message As Messages, ByVal ParamArray MessageParameters() As String) As Boolean
         Return AcceptIfNotError(Special, Message, False, MessageParameters)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MemberCache.vb" startline="483" endline="493">
<![CDATA[
 
     ''' <summary>
     ''' Looks up the name in the flattened cache.
     ''' Looks case-insensitively
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function LookupFlattened(ByVal Name As String, ByVal From As Mono.Cecil.TypeReference) As MemberCacheEntry
         Return LookupFlattened(Name, Helper.GetVisibility(Compiler, From, m_Type))
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="808" endline="814">
<![CDATA[
     End Property
 
     ReadOnly Property DefinedParameters() As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Get
             If m_DefinedParameters Is Nothing Then m_DefinedParameters = Helper.GetParameters(Compiler, Member)
             Return m_DefinedParameters
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\VoidClassification.vb" startline="81" endline="94">
<![CDATA[
 End Class
 
 Public Class LoadElementExpression
     Inherits CompilerGeneratedExpression
 
     Private m_Local As Mono.Cecil.Cil.VariableDefinition
     Private m_Index As Integer
 
     Sub New(ByVal Parent As ParsedObject, ByVal Local As Mono.Cecil.Cil.VariableDefinition, ByVal Index As Integer)
         MyBase.New(Parent, Nothing, Local.VariableType)
         MyBase.m_Delegate = New CompilerGeneratedExpression.GenerateCodeDelegate(AddressOf GenerateCodeInternal)
         m_Local = Local
         m_Index = Index
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="259" endline="269">
<![CDATA[
 
     ''' <summary>
     ''' Eats the current tokens if if coincides, if not shows a 
     ''' message "Expected
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Diagnostics.DebuggerHidden()> Function AcceptIfNotError(ByVal Special1 As KS, ByVal Special2 As KS, Optional ByVal GotoNewline As Boolean = False) As Boolean
         Return AcceptIfNotError(Special1, Messages.VBNC90019, GotoNewline, Enums.strSpecial(Special1)) AndAlso AcceptIfNotError(Special2, Messages.VBNC90019, GotoNewline, Enums.strSpecial(Special2))
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="163" endline="170">
<![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal [Property] As Mono.Cecil.PropertyReference, ByVal InstanceExpression As Expression, ByVal Parameters As ArgumentList)
         MyBase.New(Classifications.PropertyAccess, Parent)
         m_Property = [Property]
         m_InstanceExpression = InstanceExpression
         m_Parameters = Parameters
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="170" endline="176">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Value As Expression)
         Me.New(DirectCast(Parent, ParsedObject))
         m_Type = Value.ExpressionType
         m_Value = Value
         'Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\AbstractMediaHandler.vb" startline="102" endline="108">
<![CDATA[
 
     Public Overridable Function Join(ByVal InFiles() As String, _
     ByVal OutFile As String) As Boolean
         mOutFile = OutFile
         DeleteFile(mOutFile)
         mJoinFiles = InFiles
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AliasClause.vb" startline="117" endline="123">
<![CDATA[
 
     Sub Init(ByVal IsAssembly As Boolean, ByVal IsModule As Boolean, ByVal SimpleTypeName As SimpleTypeName, ByVal AttributeArguments As AttributeArguments)
         m_IsAssembly = IsAssembly
         m_IsModule = IsModule
         m_SimpleTypeName = SimpleTypeName
         m_AttributeArguments = AttributeArguments
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\OperatorDeclaration.vb" startline="55" endline="61">
<![CDATA[
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As TypeName)
         MyBase.New(Parent)
 
         m_ParameterIdentifier = New ParameterIdentifier(Me, Name)
         m_TypeName = ParameterType
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="36" endline="42">
<![CDATA[
     End Property
 
     Sub New(ByVal Compiler As Compiler, ByVal Attributes As Attributes, ByVal [Namespace] As String, ByVal BaseType As IType)
         MyBase.New(Compiler, Attributes)
         m_Namespace = [Namespace]
         m_BaseType = BaseType
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\AssignStatements\MidAssignStatement.vb" startline="37" endline="43">
<![CDATA[
 
     Sub Init(ByVal Target As Expression, ByVal Start As Expression, ByVal Length As Expression, ByVal Source As Expression)
         m_Target = Target
         m_Start = Start
         m_Length = Length
         m_Source = Source
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="76" endline="82">
<![CDATA[
 
     Sub Init(ByVal Identifier As Identifier, ByVal ArrayNameModifier As ArrayNameModifier, ByVal TypeName As TypeName, ByVal Expression As Expression)
         m_Identifier = Identifier
         m_ArrayNameModifier = ArrayNameModifier
         m_TypeName = TypeName
         m_Expression = Expression
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\EventAccessorDeclarations.vb" startline="48" endline="54">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Identifier As Identifier, ByVal ImplementsClause As MemberImplementsClause)
         MyBase.Init(Modifiers, Identifier.Name)
 
         m_Identifier = Identifier
         m_ImplementsClause = ImplementsClause
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\CaseClauses.vb" startline="58" endline="65">
<![CDATA[
 
     Shadows Sub Init(ByVal Variable As Identifier, ByVal TypeName As NonArrayTypeName, ByVal [When] As Expression, ByVal Block As CodeBlock)
         MyBase.Init(Block)
 
         m_Variable = Variable
         m_TypeName = TypeName
         m_When = [When]
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\CaseClauses.vb" startline="66" endline="112">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_When IsNot Nothing Then
             Dim EndWhen, DoWhenComparison As Label
             EndWhen = Emitter.DefineLabel(Info)
             DoWhenComparison = Emitter.DefineLabel(Info)
 
             Emitter.EmitBeginExceptionFilter(Info)
             'Check if the exception object is of type System.Exception.
             Emitter.EmitIsInst(Info, Compiler.TypeCache.System_Object, Compiler.TypeCache.System_Exception)
             Emitter.EmitDup(Info)
             'If True, do the comparison
             Emitter.EmitBranchIfTrue(Info, DoWhenComparison, Compiler.TypeCache.System_Exception)
             'Otherwise load a false value and go to the end of the filter.
             Emitter.EmitPop(Info, Compiler.TypeCache.System_Exception)
             Emitter.EmitLoadValue(Info, False)
             Emitter.EmitBranch(Info, EndWhen)
 
             'Do the when clause.
             Emitter.MarkLabel(Info, DoWhenComparison)
             Emitter.EmitPop(Info, Compiler.TypeCache.System_Exception)
             result = m_When.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean)) AndAlso result
             Emitter.MarkLabel(Info, EndWhen)
             Emitter.EmitBeginCatch(Info, Nothing)
         Else
             Helper.Assert(m_ExceptionType IsNot Nothing)
             Emitter.EmitBeginCatch(Info, m_ExceptionType)
         End If
 
         If m_VariableDeclaration Is Nothing Then
             If m_ExceptionType Is Nothing Then
                 Emitter.EmitPop(Info, Compiler.TypeCache.System_Object)
             Else
                 Emitter.EmitPop(Info, m_ExceptionType)
             End If
         Else
             result = m_VariableDeclaration.GenerateCode(Info) AndAlso result
             Emitter.EmitIsInst(Info, Compiler.TypeCache.System_Object, m_ExceptionType)
             Emitter.EmitStoreVariable(Info, m_VariableDeclaration.LocalBuilder)
         End If
         result = CodeBlock.GenerateCode(Info) AndAlso result
 
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="60" endline="67">
<![CDATA[
 
     Shadows Sub Init(ByVal LoopControlVariable As LoopControlVariable, ByVal InExpression As Expression, ByVal NextExpression As Expression, ByVal Block As CodeBlock)
         MyBase.Init(Block)
 
         m_LoopControlVariable = LoopControlVariable
         m_InExpression = InExpression
         m_NextExpression = NextExpression
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\CaseRangeExpression.vb" startline="84" endline="90">
<![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal EventInfo As Mono.Cecil.EventReference, Optional ByVal InstanceExpression As Expression = Nothing)
         MyBase.new(Classifications.EventAccess, Parent)
         m_EventInfo = EventInfo
         m_InstanceExpression = InstanceExpression
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="73" endline="81">
<![CDATA[
 
     Shadows Sub Init(ByVal Condition As Expression, ByVal FalseCode As CodeBlock, ByVal TrueCode As CodeBlock, ByVal OneLiner As Boolean, ByVal ElseIfs As BaseObjects(Of ElseIfStatement))
         MyBase.Init(TrueCode)
 
         m_Condition = Condition
         m_FalseCode = FalseCode
         m_ElseIfs = ElseIfs
         m_OneLiner = OneLiner
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\OnErrorStatement.vb" startline="39" endline="45">
<![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal IsResumeNext As Boolean, ByVal Label As Token, ByVal IsGotoMinusOne As Boolean, ByVal IsGotoZero As Boolean)
         MyBase.New(Parent)
         m_IsResumeNext = IsResumeNext
         m_Label = Label
         m_IsGotoMinusOne = IsGotoMinusOne
         m_IsGotoZero = IsGotoZero
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\MethodGroupToValueExpression.vb" startline="33" endline="39">
<![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal ns As [Namespace])
         MyBase.New(Parent)
         If ns Is Nothing Then Throw New InternalException(Me)
         m_NS = ns
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Compiler.vb" startline="83" endline="94">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Create a new define with the specified values.
     ''' </summary>
     Sub New(ByVal Compiler As Compiler, ByVal Symbol As String, ByVal Value As String)
         Me.m_Symbol = Symbol
         Me.m_Value = Value
         Me.m_Compiler = Compiler
 
         Parse()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MemberCache.vb" startline="109" endline="118">
<![CDATA[
 
     ''' <summary>
     ''' Create a new message with the specified data.
     ''' </summary>
     Sub New(ByVal Compiler As Compiler, ByVal Message As Messages(), ByVal Parameters()() As String, ByVal Location As Span)
         Me.m_Compiler = Compiler
         Me.m_Message = Message
         Me.m_Location = Location
         Me.m_Parameters = Parameters
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\BoundList.vb" startline="46" endline="52">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Identifier As Identifier, ByVal TypeName As TypeName, ByVal ConstantExpression As Expression)
         MyBase.Init(Modifiers, Identifier.Name)
         m_Identifier = Identifier
         m_TypeName = TypeName
         m_ConstantExpression = ConstantExpression
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\OperatorDeclaration.vb" startline="73" endline="81">
<![CDATA[
     End Property
 
     Sub Init(ByVal Attributes As Attributes, ByVal Modifiers As Modifiers, ByVal ParameterIdentifier As ParameterIdentifier, ByVal TypeName As TypeName, ByVal ConstantExpression As Expression)
         m_CustomAttributes = Attributes
         m_Modifiers = Modifiers
         m_ParameterIdentifier = ParameterIdentifier
         m_TypeName = TypeName
         m_ConstantExpression = ConstantExpression
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="41" endline="47">
<![CDATA[
 
     Shadows Sub Init(ByVal EnumIndex As Integer, ByVal Identifier As Identifier, ByVal ConstantExpression As Expression)
         MyBase.Init(Nothing, Identifier.Identifier)
         m_EnumIndex = EnumIndex
         m_Identifier = Identifier
         m_ConstantExpression = ConstantExpression
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\OperatorDeclaration.vb" startline="48" endline="54">
<![CDATA[
 
     Sub New(ByVal Parent As ParameterList, ByVal Name As String, ByVal ParameterType As Mono.Cecil.TypeReference)
         MyBase.New(Parent)
 
         m_ParameterIdentifier = New ParameterIdentifier(Me, Name)
         m_TypeName = New TypeName(Me, ParameterType)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\CaseRangeExpression.vb" startline="78" endline="92">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="InstanceExpression">May be Nothing</param>
     ''' <param name="TypeArguments">May be Nothing</param>
     ''' <remarks></remarks>
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Name As String)
         MyBase.New(Classifications.LateBoundAccess, Parent)
         m_InstanceExpression = InstanceExpression
         m_Name = Name
         m_TypeArguments = TypeArguments
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="163" endline="170">
<![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal [Property] As Mono.Cecil.PropertyReference, ByVal InstanceExpression As Expression, ByVal Parameters As ArgumentList)
         MyBase.New(Classifications.PropertyAccess, Parent)
         m_Property = [Property]
         m_InstanceExpression = InstanceExpression
         m_Parameters = Parameters
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="48" endline="55">
<![CDATA[
 
     Shadows Sub Init(ByVal Identifier As String, ByVal TypeParameters As TypeParameters, ByVal ParameterList As ParameterList, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As Mono.Cecil.TypeReference, ByVal Location As Span)
         MyBase.Init(Identifier, TypeParameters, ParameterList)
 
         m_ReturnTypeAttributes = ReturnTypeAttributes
         m_ReturnType = TypeName
         MyBase.Location = Location
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="56" endline="63">
<![CDATA[
 
     Shadows Sub Init(ByVal Identifier As String, ByVal TypeParameters As TypeParameters, ByVal ParameterList As ParameterList, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As TypeName, ByVal Location As Span)
         MyBase.Init(Identifier, TypeParameters, ParameterList)
 
         m_ReturnTypeAttributes = ReturnTypeAttributes
         m_TypeName = TypeName
         MyBase.Location = Location
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="64" endline="71">
<![CDATA[
 
     Shadows Sub Init(ByVal Identifier As Identifier, ByVal TypeParameters As TypeParameters, ByVal ParameterList As ParameterList, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As TypeName, ByVal Location As Span)
         MyBase.Init(Identifier, TypeParameters, ParameterList)
 
         m_ReturnTypeAttributes = ReturnTypeAttributes
         m_TypeName = TypeName
         MyBase.Location = Location
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="146" endline="152">
<![CDATA[
 
     Public Sub New(ByVal FileIndex As UShort, ByVal StartLine As UInteger, ByVal StartColumn As Byte, Optional ByVal EndColumn As Byte = 0)
         m_EndColumn = EndColumn
         m_FileIndex = FileIndex + 1US
         m_Line = StartLine
         m_Column = StartColumn
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="189" endline="204">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns nothing if the resolved method isn't a methodinfo.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property ResolvedMethodInfo() As Mono.Cecil.MethodReference
         Get
             If SuccessfullyResolved = False Then Throw New InternalException(Me)
             If TypeOf m_Group(0) Is Mono.Cecil.MethodReference Then
                 Return DirectCast(m_Group(0), Mono.Cecil.MethodReference)
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="162" endline="171">
<![CDATA[
     End Property
 
     Sub Init(ByVal OptionCompare As OptionCompareStatement, ByVal OptionStrict As OptionStrictStatement, ByVal OptionExplicit As OptionExplicitStatement, ByVal OptionInfer As OptionInferStatement, ByVal [Imports] As ImportsClauses)
         m_OptionCompare = OptionCompare
         m_OptionStrict = OptionStrict
         m_OptionExplicit = OptionExplicit
         m_OptionInfer = OptionInfer
         m_Imports = [Imports]
         Helper.AssertNotNothing(m_Imports)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\EventHandlesList.vb" startline="52" endline="60">
<![CDATA[
 
     Sub Init(ByVal First As Expression, ByVal Second As IdentifierOrKeyword)
         m_First = First
         m_Second = Second
 
         m_Expression = New MemberAccessExpression(Me)
         m_Expression.Init(m_First, m_Second)
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="130" endline="139">
<![CDATA[
 
     Shadows Sub Init(ByVal LoopControlVariable As LoopControlVariable, ByVal LoopStartExpression As Expression, ByVal LoopEndExpression As Expression, ByVal LoopStepExpression As Expression, ByVal NextExpressionList As ExpressionList, ByVal Block As CodeBlock)
         MyBase.Init(Block)
 
         m_LoopControlVariable = LoopControlVariable
         m_LoopStartExpression = LoopStartExpression
         m_LoopEndExpression = LoopEndExpression
         m_LoopStepExpression = LoopStepExpression
         m_NextExpressionList = NextExpressionList
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeImplementsClauses.vb" startline="123" endline="129">
<![CDATA[
     End Property
 
     Sub New(ByVal Name As ConstructedTypeName, ByVal FromWhere As BaseObject, Optional ByVal TypeArgumentCount As Integer = 0)
     Private m_FoundObjects As New Generic.List(Of Object)
 
     Private Name As ParsedObject
     Private FromWhere As BaseObject
     Private m_IsImportsResolution As Boolean
     Private m_Qualifier As TypeNameResolutionInfo
     Private m_TypeArgumentCount As Integer
     Private m_IsAttributeTypeName As Boolean
 
 
     Property IsAttributeTypeName() As Boolean
         Get
             Return m_IsAttributeTypeName
         End Get
         Set(ByVal value As Boolean)
             m_IsAttributeTypeName = value
         End Set
     End Property
 
     ''' <summary>
     ''' Returns true if the resolved object is the "Global" keyword.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property IsGlobal() As Boolean
         Get
             Return m_FoundObjects.Count = 1 AndAlso ((TypeOf m_FoundObjects(0) Is Token AndAlso DirectCast(m_FoundObjects(0), Token).Equals(KS.Global)) OrElse (TypeOf m_FoundObjects(0) Is GlobalExpression))
         End Get
     End Property
 
     Public ReadOnly Property FoundOnlyOneObject() As Boolean
         Get
             Return m_FoundObjects.Count = 1
         End Get
     End Property
 
     Function FoundAsType() As Mono.Cecil.TypeReference 'Descriptor
         Dim found As Object = FoundObject
         If TypeOf found Is IType Then
             Return DirectCast(found, IType).CecilType
             'ElseIf TypeOf found Is Type Then
             '    Return DirectCast(found, Type)
             'ElseIf TypeOf found Is TypeDescriptor Then
             '    Return DirectCast(found, TypeDescriptor)
         ElseIf TypeOf found Is TypeParameter Then
             Return DirectCast(found, TypeParameter).CecilBuilder
         ElseIf TypeOf found Is Mono.Cecil.TypeReference Then
             Return DirectCast(found, Mono.Cecil.TypeReference)
         Else
             Throw New InternalException("")
         End If
     End Function
 
     Function FoundIsType() As Boolean
         Dim found As Object = FoundObject
         Return TypeOf found Is IType OrElse TypeOf found Is Type OrElse TypeOf found Is Mono.Cecil.TypeReference
     End Function
 
     Function FoundIs(Of Type)() As Boolean
         If FoundOnlyOneObject Then
             Return TypeOf FoundObject Is Type
         Else
             Throw New InternalException("")
         End If
     End Function
 
     Function FoundAs(Of Type)() As Type
         Return CType(CObj(FoundObject), Type)
     End Function
 
     ReadOnly Property FoundObject() As Object
         Get
             If FoundOnlyOneObject = False Then
                 Throw New InternalException("")
             Else
                 Return m_FoundObjects(0)
             End If
         End Get
     End Property
 
     Public ReadOnly Property FoundObjects() As Generic.List(Of Object)
         Get
             Return m_FoundObjects
         End Get
     End Property
 
     Property IsImportsResolution() As Boolean
         Get
             Return m_IsImportsResolution
         End Get
         Set(ByVal value As Boolean)
             m_IsImportsResolution = value
         End Set
     End Property
 
     Property TypeArgumentCount() As Integer
         Get
             Return m_TypeArgumentCount
         End Get
         Set(ByVal value As Integer)
             m_TypeArgumentCount = value
         End Set
     End Property
 
     Sub New(ByVal Name As ConstructedTypeName, ByVal FromWhere As BaseObject, Optional ByVal TypeArgumentCount As Integer = 0)
         Me.Name = Name
         Me.FromWhere = FromWhere
         Me.TypeArgumentCount = TypeArgumentCount
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\LateBoundAccessToValueExpression.vb" startline="30" endline="38">
<![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal Field As Mono.Cecil.FieldReference, Optional ByVal InstanceExpression As Expression = Nothing)
         MyBase.New(Parent)
 
         m_Field = Field
         m_InstanceExpression = InstanceExpression
         Me.Classification = New ValueClassification(Me, m_Field.FieldType)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="44" endline="56">
<![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim tp As TypeDeclaration
         tp = Me.FindFirstParent(Of TypeDeclaration)()
         m_ExpressionType = tp.CecilType
 
         '        Classification = New ValueClassification(Me, m_ExpressionType)
         'SPECBUG
         Classification = New VariableClassification(Me, Me, m_ExpressionType)
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\SubSignature.vb" startline="82" endline="91">
<![CDATA[
 
     Sub Init(ByVal Identifier As Identifier, ByVal TypeParameters As TypeParameters, ByVal ParameterList As ParameterList)
         m_Identifier = Identifier
         m_TypeParameters = TypeParameters
         If ParameterList Is Nothing Then
             m_ParameterList = New ParameterList(Me)
         Else
             m_ParameterList = ParameterList
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="63" endline="69">
<![CDATA[
 
     Sub Init(ByVal Modifiers As Modifiers, ByVal Name As String)
         m_Modifiers = Modifiers
         m_Name = Name
 
         If m_Name Is Nothing Then Throw New InternalException(Me.Location.ToString(Compiler))
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="81" endline="90">
<![CDATA[
 
     Sub Init(ByVal Identifier As Identifier, ByVal IsNew As Boolean, ByVal TypeName As NonArrayTypeName, ByVal ArgumentList As ArgumentList, ByVal VariableInitializer As VariableInitializer, ByVal IsVariableDeclaration As Boolean, ByVal VariableDeclaration As LocalVariableDeclaration)
         m_Identifier = Identifier
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_ArgumentList = ArgumentList
         m_VariableInitializer = VariableInitializer
         m_IsVariableDeclaration = IsVariableDeclaration
         m_VariableDeclaration = VariableDeclaration
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\TryCastExpression.vb" startline="59" endline="66">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal DelegateType As Mono.Cecil.TypeReference, ByVal AddressOfExpression As AddressOfExpression)
         MyBase.New(Parent)
 
         m_IsDelegateCreationExpression = True
         m_ResolvedType = DelegateType
         m_ArgumentList = New ArgumentList(Me, AddressOfExpression)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="379" endline="386">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal variable As VariableDeclaration, Optional ByVal InstanceExpression As Expression = Nothing)
         MyBase.New(Classifications.Variable, Parent)
         m_Variable = variable
         m_LocalVariable = TryCast(m_Variable, LocalVariableDeclaration)
         m_TypeVariable = TryCast(m_Variable, TypeVariableDeclaration)
         m_InstanceExpression = InstanceExpression
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Infos\ExpressionResolveInfo.vb" startline="39" endline="45">
<![CDATA[
 
     Sub New(ByVal Compiler As Compiler, Optional ByVal SkipFunctionReturnVariable As Boolean = False, Optional ByVal CanFail As Boolean = False, Optional ByVal CanBeImplicitSimpleName As Boolean = True)
     Private m_Bits As New Collections.BitArray(32)
     Private Const c_SkipFunctionReturnVariable As Integer = 0
     Private Const c_CanFail As Integer = 1
     Private Const c_CanBeLateCall As Integer = 2
     Private Const c_CanBeImplicitSimpleName As Integer = 3
     Private Const c_EventResolution As Integer = 4
 
     Public Compiler As Compiler
 
     Private Shared DefaultInfo As ResolveInfo
 
     Shared Function [Default](ByVal Compiler As Compiler) As ResolveInfo
         If DefaultInfo Is Nothing OrElse Compiler Is DefaultInfo.Compiler = False Then
             DefaultInfo = New ResolveInfo(Compiler)
         End If
 
         Return DefaultInfo
     End Function
 
     Sub New(ByVal Compiler As Compiler, Optional ByVal SkipFunctionReturnVariable As Boolean = False, Optional ByVal CanFail As Boolean = False, Optional ByVal CanBeImplicitSimpleName As Boolean = True)
         Me.SkipFunctionReturnVariable = SkipFunctionReturnVariable
         Me.CanFail = CanFail
         Me.CanBeImplicitSimpleName = CanBeImplicitSimpleName
         Me.Compiler = Compiler
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ExternalSubDeclaration.vb" startline="46" endline="54">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal CharsetModifier As KS, ByVal LibraryClause As LibraryClause, ByVal AliasClause As AliasClause, ByVal Signature As SubSignature)
         MyBase.Init(Modifiers, Signature, Nothing)
         Modifiers = Modifiers.AddModifier(KS.Shared)
         m_CharsetModifier = CharsetModifier
         m_Identifier = Identifier
         m_LibraryClause = LibraryClause
         m_AliasClause = AliasClause
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="45" endline="55">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
     Private m_HandledEvents As New Generic.List(Of Mono.Cecil.EventReference)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = VariableIdentifier
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="443" endline="453">
<![CDATA[
 
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Method As MethodDeclaration)
         MyBase.New(Classifications.MethodGroup, Parent)
         m_Group = New Generic.List(Of Mono.Cecil.MemberReference)
         m_Group.Add(Method.CecilBuilder)
         m_Resolved = True
         m_InstanceExpression = InstanceExpression
         m_TypeArguments = TypeArguments
         Me.MethodDeclaration = Method
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MyGenerator.vb" startline="58" endline="64">
<![CDATA[
 
     Sub New(ByVal Parent As BaseObject, ByVal Name As String, ByVal [Global] As Boolean)
         MyBase.New(Parent)
         If Name = "" AndAlso [Global] = False Then Throw New ArgumentNullException("Name")
         m_Name = Name
         m_Global = [Global]
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="56" endline="66">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
     Private m_HandledEvents As New Generic.List(Of Mono.Cecil.EventReference)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = VariableIdentifier
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = New VariableIdentifier(Me, VariableIdentifier)
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\SubSignature.vb" startline="72" endline="81">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Name As String, ByVal Parameters As Mono.Cecil.TypeReference())
         MyBase.New(Parent)
         m_Identifier = New Identifier(Me, Name, Nothing, TypeCharacters.Characters.None)
         If Parameters Is Nothing Then
             m_ParameterList = New ParameterList(Me)
         Else
             m_ParameterList = New ParameterList(Me, Parameters)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ExternalSubDeclaration.vb" startline="37" endline="45">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal CharsetModifier As KS, ByVal Identifier As Identifier, ByVal LibraryClause As LibraryClause, ByVal AliasClause As AliasClause, ByVal ParameterList As ParameterList)
         MyBase.Init(Modifiers, New SubSignature(Me, Identifier.Name, ParameterList), Nothing)
         Modifiers = Modifiers.AddModifier(KS.Shared)
         m_CharsetModifier = CharsetModifier
         m_Identifier = Identifier
         m_LibraryClause = LibraryClause
         m_AliasClause = AliasClause
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="62" endline="71">
<![CDATA[
 
     ''' <summary>
     ''' Adds a modifier to the list if the modifier isn't there already.
     ''' </summary>
     ''' <param name="Modifier"></param>
     ''' <remarks></remarks>
     Public Function AddModifiers(ByVal Modifier As ModifierMasks) As Modifiers
         m_ModifierMask = m_ModifierMask Or Modifier
         Return Me
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="51" endline="61">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Adds a modifier to the list if the modifier isn't there already.
     ''' </summary>
     ''' <param name="Modifier"></param>
     ''' <remarks></remarks>
     Public Function AddModifier(ByVal Modifier As KS) As Modifiers
         m_ModifierMask = m_ModifierMask Or KSToMask(Modifier)
         Return Me
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\AbstractMediaHandler.vb" startline="84" endline="101">
<![CDATA[
     End Property
 
     Public MustOverride ReadOnly Property Extension(Optional ByVal _
         LongForm As Boolean = False) As String
 
     Public MustOverride ReadOnly Property IsSupported(ByVal Feature As String) As Boolean
 
 #End Region
 
 #Region "   Save and Join Commands "
 
     Public Overridable Function Save(ByVal Filename As String, _
     ByVal Segments As Segment(), _
 Optional ByVal Mode As Mode = Mode.SaveSelected) As Boolean
         mOutFile = Filename
         DeleteFile(mOutFile)
         mSegments = Segments
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\ASFhandler.vb" startline="50" endline="58">
<![CDATA[
 
     Public Overrides Function Join(ByVal InFiles() As String, _
     ByVal OutFile As String) As Boolean
         MyBase.Join(InFiles, OutFile)
 
         RunConverter(GetFileJoinCommand)
         Return OutFileCheck()
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\RMhandler.vb" startline="42" endline="50">
<![CDATA[
 
     Public Overrides Function Join(ByVal InFiles() As String, _
     ByVal OutFile As String) As Boolean
         MyBase.Join(InFiles, OutFile)
 
         RunConverter(GetFileJoinCommand)
         Return OutFileCheck()
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" startline="50" endline="61">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Initializing constructor.
     ''' </summary>
     ''' <param name="LeftSide"></param>
     ''' <remarks></remarks>
     Sub New(ByVal Parent As ParsedObject, Optional ByVal LeftSide As Boolean = False, Optional ByVal IsInTypeOf As Boolean = False)
         m_IsLeftSide = LeftSide
         m_IsInTypeOf = IsInTypeOf
         m_Parent = Parent
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="64" endline="73">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Creates a new resource with the specified values.
     ''' </summary>
     Sub New(ByVal Filename As String, ByVal Identifier As String, Optional ByVal [Public] As Boolean = True)
         Me.m_Filename = Filename
         Me.m_Identifier = Identifier
         Me.m_Public = [Public]
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\AssignStatements\AddAssignStatement.vb" startline="44" endline="50">
<![CDATA[
 
     Sub Init(ByVal LSide As Expression, ByVal RSide As Expression)
         m_LSide = LSide
         m_RSide = RSide
         m_LSide.Parent = Me
         m_RSide.Parent = Me
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\VoidClassification.vb" startline="31" endline="37">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal CodeGenerator As GenerateCodeDelegate, ByVal ExpressionType As Mono.Cecil.TypeReference)
         MyBase.new(Parent)
         m_Delegate = CodeGenerator
         m_ExpressionType = ExpressionType
         MyBase.Classification = New ValueClassification(Me)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="346" endline="353">
<![CDATA[
 
     Protected Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression)
         MyBase.New(Parent)
         m_LeftExpression = LExp
         m_LeftExpression.Parent = Me
         m_RightExpression = RExp
         m_RightExpression.Parent = Me
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\VoidClassification.vb" startline="47" endline="59">
<![CDATA[
     End Property
 End Class
 
 Public Class LoadLocalExpression
     Inherits CompilerGeneratedExpression
 
     Private m_Local As Mono.Cecil.Cil.VariableDefinition
     
     Sub New(ByVal Parent As ParsedObject, ByVal Local As Mono.Cecil.Cil.VariableDefinition)
         MyBase.New(Parent, Nothing, Local.VariableType)
         MyBase.m_Delegate = New CompilerGeneratedExpression.GenerateCodeDelegate(AddressOf GenerateCodeInternal)
         m_Local = Local
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\MPGhandler.vb" startline="48" endline="57">
<![CDATA[
 
     Public Overrides Function Join(ByVal InFiles() As String, _
     ByVal OutFile As String) As Boolean
         MyBase.Join(InFiles, OutFile)
 
         If mIsAudio Then SafeHarborMsg()
         RunConverter(GetFileJoinCommand)
         Return OutFileCheck()
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="47" endline="53">
<![CDATA[
 
     Sub Init(ByVal Identifier As Identifier, ByVal ArrayNameModifier As ArrayNameModifier)
         m_Identifier = Identifier
         m_ArrayNameModifier = ArrayNameModifier
 
         If Identifier.Identifier Is Nothing Then Throw New InternalException("No identifier
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="598" endline="611">
<![CDATA[
 
     Private Function IsIdentifierCharacter(ByVal chr As Char) As Boolean
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         Return IsUnderscoreCharacter(chr) OrElse _
                 IsAlphaCharacter(chr) OrElse _
                 IsNumericCharacter(chr) OrElse _
                 IsCombiningCharacter(chr) OrElse _
                 IsFormattingCharacter(chr)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="454" endline="463">
<![CDATA[
 
     Private Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Parameters() As Expression)
         MyBase.new(Classifications.MethodGroup, Parent)
         m_InstanceExpression = InstanceExpression
         m_CallingType = Parent.FindFirstParent(Of TypeDeclaration)()
         m_Parameters = Parameters
         m_TypeArguments = TypeArguments
         'Helper.Assert(m_CallingType IsNot Nothing)
         Helper.Assert(m_InstanceExpression Is Nothing OrElse m_InstanceExpression.IsResolved)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ExternalFunctionDeclaration.vb" startline="35" endline="42">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal CharsetModifier As KS, ByVal Identifier As Identifier, ByVal LibraryClause As LibraryClause, ByVal AliasClause As AliasClause, ByVal ParameterList As ParameterList, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As TypeName)
 
         Dim mySignature As New FunctionSignature(Me)
         mySignature.Init(Identifier, Nothing, ParameterList, ReturnTypeAttributes, TypeName, Me.Location)
 
         MyBase.Init(Modifiers, CharsetModifier, LibraryClause, AliasClause, mySignature)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MyGenerator.vb" startline="45" endline="57">
<![CDATA[
 
     Sub New(ByVal Parent As BaseObject, ByVal Previous As [Namespace], ByVal Name As String)
         MyBase.New(Parent)
         If Previous Is Nothing Then Throw New ArgumentNullException("Namespace")
 
         If TypeOf Previous Is GlobalNamespace Then
             m_Name = Name
             m_Global = True
         Else
             m_Name = Previous.Name & "." & Name
             m_Global = Previous.Global
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="67" endline="78">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Identifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As NonArrayTypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
     Private m_HandledEvents As New Generic.List(Of Mono.Cecil.EventReference)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As VariableIdentifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = VariableIdentifier
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal VariableIdentifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As TypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(Modifiers, VariableIdentifier.Name)
         m_VariableIdentifier = New VariableIdentifier(Me, VariableIdentifier)
         m_IsNew = IsNew
         m_TypeName = TypeName
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Identifier As Identifier, _
     ByVal IsNew As Boolean, ByVal TypeName As NonArrayTypeName, ByVal VariableInitializer As VariableInitializer, ByVal ArgumentList As ArgumentList)
         MyBase.New(Parent)
         MyBase.Init(New Modifiers(), Identifier.Name)
 
         m_VariableIdentifier = New VariableIdentifier(Me, Identifier)
         m_IsNew = IsNew
         m_TypeName = New TypeName(Me, TypeName)
         m_VariableInitializer = VariableInitializer
         m_ArgumentList = ArgumentList
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\ASFhandler.vb" startline="34" endline="49">
<![CDATA[
     End Property
 
     Public Overrides Function Save(ByVal Filename As String, _
     ByVal Segments As Segment(), _
     Optional ByVal Mode As Mode = AbstractMediaHandler.Mode.SaveSelected) As Boolean
         MyBase.Save(Filename, Segments, Mode)
 
         RunConverter(GetSaveCommand(Mode))
 
         If Mode = AbstractMediaHandler.Mode.SaveSeparate Then
             Return FileCount(Filename) >= mSegments.Length
         Else
             Return OutFileCheck()
         End If
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\MPGhandler.vb" startline="32" endline="47">
<![CDATA[
     End Property
 
     Public Overrides Function Save(ByVal Filename As String, _
     ByVal Segments As Segment(), _
     Optional ByVal Mode As Mode = AbstractMediaHandler.Mode.SaveSelected) As Boolean
         MyBase.Save(Filename, Segments)
 
         RunConverter(GetSaveCommand(Mode))
 
         If Mode = AbstractMediaHandler.Mode.SaveSeparate Then
             Return FileCount(Filename) >= mSegments.Length
         Else
             Return OutFileCheck()
         End If
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeCache.vb" startline="389" endline="400">
<![CDATA[
 
     Protected Overrides Sub InitOptimizations()
         If Helper.IsOnMono Then
             System_MonoType = Me.GetType(mscorlib, "System.MonoType")
         Else
             System_RuntimeType = Me.GetType(mscorlib, "System.RuntimeType")
             System_Reflection_Emit_TypeBuilderInstantiation = Me.GetType(mscorlib, "System.Reflection.Emit.TypeBuilderInstantiation")
             System_Reflection_Emit_SymbolType = Me.GetType(mscorlib, "System.Reflection.Emit.SymbolType")
         End If
         System_Reflection_Emit_TypeBuilder = Me.GetType(mscorlib, "System.Reflection.Emit.TypeBuilder")
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MemberCache.vb" startline="525" endline="541">
<![CDATA[
 
     ''' <summary>
     ''' Looks up the name in the cache.
     ''' Looks case-insensitively
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function Lookup(ByVal Name As String, ByVal Visibility As MemberVisibility, ByVal PreventLoad As Boolean) As MemberCacheEntry
         Dim cache_insensitive As MemberCacheEntries = Nothing
         Dim result As MemberCacheEntry = Nothing
 
         If Not PreventLoad Then Load(Name, Visibility)
 
         m_CacheInsensitive(Visibility).TryGetValue(Name, result)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="471" endline="477">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Parameters() As Expression, ByVal Methods As Mono.Collections.Generic.Collection(Of Mono.Cecil.MethodReference))
         Me.new(Parent, InstanceExpression, TypeArguments, Parameters)
         SetMethods(Methods)
         Helper.Assert(Methods.Count > 0)
         Helper.Assert(m_InstanceExpression Is Nothing OrElse m_InstanceExpression.IsResolved)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="478" endline="484">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Parameters() As Expression, ByVal Methods As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference))
         Me.new(Parent, InstanceExpression, TypeArguments, Parameters)
         SetMethods(Methods)
         Helper.Assert(Methods.Count > 0)
         Helper.Assert(m_InstanceExpression Is Nothing OrElse m_InstanceExpression.IsResolved)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="464" endline="470">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal TypeArguments As TypeArgumentList, ByVal Parameters() As Expression, ByVal ParamArray Methods As Mono.Cecil.MemberReference())
         Me.New(Parent, InstanceExpression, TypeArguments, Parameters)
         SetMethods(New Generic.List(Of Mono.Cecil.MemberReference)(Methods))
         Helper.Assert(Methods.Length > 0)
         Helper.Assert(m_InstanceExpression Is Nothing OrElse m_InstanceExpression.IsResolved)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\RMhandler.vb" startline="26" endline="41">
<![CDATA[
     End Property
 
     Public Overrides Function Save(ByVal Filename As String, _
     ByVal Segments As Segment(), _
     Optional ByVal Mode As Mode = AbstractMediaHandler.Mode.SaveSelected) As Boolean
         MyBase.Save(Filename, Segments)
 
         If Mode = AbstractMediaHandler.Mode.SaveSeparate Then
             CreatePieces(False)
             Return FileCount(Filename) >= mSegments.Length
         Else
             CreatePieces(True)
             Return OutFileCheck()
         End If
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\TryCastExpression.vb" startline="32" endline="45">
<![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression)
         MyBase.new(Parent)
 
         Dim refType As ByReferenceType = TryCast(Expression.ExpressionType, ByReferenceType)
 
         If refType Is Nothing Then Throw New InternalException
 
         m_Expression = Expression
         m_ExpressionType = refType.ElementType
 
         Classification = New VariableClassification(Me, Expression, m_ExpressionType)
 
         If MyBase.ResolveExpression(ResolveInfo.Default(Parent.Compiler)) = False Then Helper.ErrorRecoveryNotImplemented(Me.Location)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\CachedExpression.vb" startline="30" endline="43">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Local Is Nothing Then
             result = m_Expression.GenerateCode(Info.Clone(Me, True, False, m_Expression.ExpressionType)) AndAlso result
             m_Local = Emitter.DeclareLocal(Info, m_Expression.ExpressionType)
             Emitter.EmitStoreVariable(Info, m_Local)
         End If
 
         Emitter.EmitLoadVariable(Info, m_Local)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="105" endline="120">
<![CDATA[
     End Property
 
     Sub Init(ByVal InitialGroup As Generic.List(Of Mono.Cecil.MemberReference), ByVal Arguments As ArgumentList, ByVal TypeArguments As TypeArgumentList)
         m_Candidates = New Generic.List(Of MemberCandidate)(InitialGroup.Count)
         For i As Integer = 0 To InitialGroup.Count - 1
             Dim member As Mono.Cecil.MemberReference = InitialGroup(i)
             m_Candidates.Add(New MemberCandidate(Me, member))
         Next
 
         m_InitialCandidates = m_Candidates.ToArray()
 
         m_Arguments = Arguments
         m_TypeArguments = TypeArguments
         m_Caller = Parent.FindTypeParent()
         m_Name = InitialGroup(0).Name
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="50" endline="64">
<![CDATA[
     End Property
 #End If
 
     ''' <summary>
     ''' Adds the constant to the collection. 
     ''' If the constant already exists, it is replaced.
     ''' </summary>
     ''' <param name="Constant"></param>
     ''' <remarks></remarks>
     Public Shadows Sub Add(ByVal Constant As ConditionalConstant)
         If MyBase.ContainsKey(Constant.Name) Then
             MyBase.Remove(Constant.Name)
         End If
         MyBase.Add(Constant.Name, Constant)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="140" endline="146">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Variable As VariableDeclaration)
         MyBase.New(Classifications.Value, Parent)
         Helper.Assert(Variable IsNot Nothing)
         m_Classification = New VariableClassification(Me.Parent, Variable)
         m_Type = DirectCast(m_Classification, VariableClassification).Type
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\SubSignature.vb" startline="62" endline="71">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Name As String, ByVal Parameters As ParameterList)
         MyBase.New(Parent)
         m_Identifier = New Identifier(Me, Name, Nothing, TypeCharacters.Characters.None)
         If Parameters Is Nothing Then
             m_ParameterList = New ParameterList(Me)
         Else
             m_ParameterList = Parameters
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MyGenerator.vb" startline="35" endline="41">
<![CDATA[
     End Property
 
     ReadOnly Property Code() As System.Text.StringBuilder
         Get
             If m_Code Is Nothing Then m_Code = New System.Text.StringBuilder()
             Return m_Code
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MyGenerator.vb" startline="42" endline="48">
<![CDATA[
     End Property
 
     ReadOnly Property ProjectCode() As System.Text.StringBuilder
         Get
             If m_ProjectCode Is Nothing Then m_ProjectCode = New System.Text.StringBuilder
             Return m_ProjectCode
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="822" endline="828">
<![CDATA[
     End Property
 
     ReadOnly Property ReturnType As TypeReference
         Get
             If m_ReturnType Is Nothing Then m_ReturnType = Helper.GetReturnType(m_Member)
             Return m_ReturnType
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\Main.vb" startline="164" endline="176">
<![CDATA[
     End Property
 
     '*********************** Segments element ***********************
     <XmlElement(Type
   EditorBrowsable(EditorBrowsableState.Advanced)> _
   Public __Segments As Segments
 
     <XmlIgnore()> _
     Public Property Segments() As Segments
         Get
             If __Segments Is Nothing Then __Segments = New Segments
             Segments = __Segments
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\Main.vb" startline="233" endline="244">
<![CDATA[
 
     '*********************** Segment element ***********************
     <XmlElement(Type
   EditorBrowsable(EditorBrowsableState.Advanced)> _
   Public __SegmentCollection As SegmentCollection
 
     <XmlIgnore()> _
     Public Property SegmentCollection() As SegmentCollection
         Get
             If __SegmentCollection Is Nothing Then __SegmentCollection = New SegmentCollection
             SegmentCollection = __SegmentCollection
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\DotAccessExpression.vb" startline="286" endline="297">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Call StartResolve to enable check for recursive resolving.
     ''' Call EndResolve when finished resolving.
     ''' </summary>
     ''' <remarks></remarks>
     Protected Sub EndResolve(ByVal result As Boolean)
         If Not m_Resolving Then Throw New InternalException(Me)
         m_Resolving = False
         m_Resolved = result
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="242" endline="254">
<![CDATA[
 
     ''' <summary>
     ''' Create a new EmitInfo copying the values from the specified info.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <remarks></remarks>
     Private Sub New(ByVal Info As EmitInfo)
         Me.m_DesiredType = Info.m_DesiredType
         Me.m_IsExplicitConversion = Info.m_IsExplicitConversion
         Me.m_IsRHS = Info.m_IsRHS
         Me.m_Method = Info.m_Method
         Me.m_RHSExpression = Info.m_RHSExpression
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MemberCache.vb" startline="96" endline="108">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Create a new message with the specified data.
     ''' </summary>
     ''' <param name="Message"></param>
     ''' <remarks></remarks>
     Sub New(ByVal Compiler As Compiler, ByVal Message As Messages, ByVal Location As Span)
         Me.m_Compiler = Compiler
         Me.m_Message = New Messages() {Message}
         Me.m_Location = Location
         Me.m_Parameters = New String()() {}
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\SubSignature.vb" startline="113" endline="121">
<![CDATA[
 
     Sub CloneTo(ByVal ClonedSignature As SubSignature)
         ClonedSignature.m_Identifier = m_Identifier
         ClonedSignature.m_TypeParameters = m_TypeParameters
         If m_ParameterList IsNot Nothing Then
             ClonedSignature.m_ParameterList = m_ParameterList.Clone(ClonedSignature)
             ClonedSignature.m_ParameterList.Parent = ClonedSignature
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="197" endline="206">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal Members As Mono.Collections.Generic.Collection(Of Mono.Cecil.PropertyDefinition))
         MyBase.New(Classifications.PropertyGroup, Parent)
         m_InstanceExpression = InstanceExpression
 
         m_Members = New Mono.Collections.Generic.Collection(Of Mono.Cecil.PropertyReference)(Members.Count)
         For i As Integer = 0 To Members.Count - 1
             m_Members.Add(Members(i))
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="38" endline="46">
<![CDATA[
     Public Overrides Function GetConstant(ByRef result As Object, ByVal ShowError As Boolean) As Boolean
         If ReclassifiedClassification IsNot Nothing Then
             Return ReclassifiedClassification.GetConstant(result, ShowError)
         ElseIf m_Value IsNot Nothing Then
             Return m_Value.GetConstant(result, ShowError)
         Else
             Return MyBase.GetConstant(result, ShowError)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\DotAccessExpression.vb" startline="34" endline="51">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Automatically resolved.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="Expression"></param>
     ''' <remarks></remarks>
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression)
         MyBase.new(Parent)
         m_Expression = Expression
         m_ExpressionType = Parent.Compiler.TypeManager.MakeByRefType(Parent, Expression.ExpressionType)
 
         If MyBase.ResolveExpression(ResolveInfo.Default(Parent.Compiler)) = False Then
             Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Throw New InternalException(Me)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="262" endline="277">
<![CDATA[
 
     ''' <summary>
     ''' Create a new code file with the specified filename.
     ''' </summary>
     ''' <param name="FileName"></param>
     ''' <remarks></remarks>
     Sub New(ByVal FileName As String, ByVal RelativePath As String, ByVal Parent As BaseObject)
         MyBase.New(Parent)
     Private m_ConditionalConstants As New Generic.List(Of ConditionalConstants)
     Private m_ConditionalConstantsLines As New Generic.List(Of UInteger)
 
     Private m_Code As String
 
     Public ReadOnly Property SymbolDocument() As Mono.Cecil.Cil.Document
         Get
             If m_SymbolDocument Is Nothing Then
                 m_SymbolDocument = New Mono.Cecil.Cil.Document(System.IO.Path.Combine(m_RelativePath.Replace("<"c, "["c).Replace(">"c, "]"c), m_FileName.Replace("<"c, "["c).Replace(">"c, "]"c)))
                 m_SymbolDocument.Language = Cil.DocumentLanguage.Basic
                 m_SymbolDocument.LanguageVendor = Cil.DocumentLanguageVendor.Microsoft
                 m_SymbolDocument.Type = Cil.DocumentType.Text
             End If
             Return m_SymbolDocument
         End Get
     End Property
 
     Sub AddConditionalConstants(ByVal Line As UInteger, ByVal Constants As ConditionalConstants)
         m_ConditionalConstants.Add(Constants.Clone)
         m_ConditionalConstantsLines.Add(Line)
     End Sub
 
     Function GetConditionalConstants(ByVal Line As UInteger) As ConditionalConstants
         If m_ConditionalConstantsLines.Count = 0 Then Return Nothing
 
         'If the first #const is after the line, no constants in this file at the line
         If m_ConditionalConstantsLines(0) > Line Then Return Nothing
 
         For i As Integer = 0 To m_ConditionalConstantsLines.Count - 1
             'If the current #const is after the line, the previous one corresponds to the line
             If m_ConditionalConstantsLines(i) > Line Then
                 Return m_ConditionalConstants(i - 1)
             End If
         Next
 
         'If no constants are after the line, the last is the one.
         Return m_ConditionalConstants(m_ConditionalConstants.Count - 1)
     End Function
 
     Private Shared ReadOnly Property UTF8Throw() As System.Text.Encoding
         Get
             ' Use no preamble to let StreamReader use a non-throwing decoder
             ' when UTF-8 byte order mark found.
             If m_UTF8Throw Is Nothing Then m_UTF8Throw = New System.Text.UTF8Encoding(False, True)
             Return m_UTF8Throw
         End Get
     End Property
 
     Property RelativePath() As String
         Get
             Return m_RelativePath
         End Get
         Set(ByVal value As String)
             m_RelativePath = value
         End Set
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Return m_Imports.ResolveCode(Info)
     End Function
 
     ReadOnly Property OptionExplicit() As OptionExplicitStatement
         Get
             Return m_OptionExplicit
         End Get
     End Property
 
     ReadOnly Property OptionStrict() As OptionStrictStatement
         Get
             Return m_OptionStrict
         End Get
     End Property
 
     ReadOnly Property OptionCompare() As OptionCompareStatement
         Get
             Return m_OptionCompare
         End Get
     End Property
 
     ReadOnly Property OptionInfer As OptionInferStatement
         Get
             Return m_OptionInfer
         End Get
     End Property
 
     Sub Init(ByVal OptionCompare As OptionCompareStatement, ByVal OptionStrict As OptionStrictStatement, ByVal OptionExplicit As OptionExplicitStatement, ByVal OptionInfer As OptionInferStatement, ByVal [Imports] As ImportsClauses)
         m_OptionCompare = OptionCompare
         m_OptionStrict = OptionStrict
         m_OptionExplicit = OptionExplicit
         m_OptionInfer = OptionInfer
         m_Imports = [Imports]
         Helper.AssertNotNothing(m_Imports)
     End Sub
 
     ''' <summary>
     ''' The state of the Option Explicit flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionExplicitOn() As Boolean
         Get
             If m_OptionExplicit Is Nothing Then
                 Return Compiler.CommandLine.OptionExplicit = CommandLine.OptionExplicitTypes.On
             Else
                 Return m_OptionExplicit.IsOn
             End If
         End Get
     End Property
 
     ''' <summary>
     ''' The state of the Option Strict flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionStrictOn() As Boolean
         Get
             If m_OptionStrict Is Nothing Then
                 Return Compiler.CommandLine.OptionStrict = CommandLine.OptionStrictTypes.On
             Else
                 Return m_OptionStrict.IsOn
             End If
         End Get
     End Property
 
     ''' <summary>
     ''' The state of the Option Compare flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionCompareBinary() As Boolean
         Get
             If m_OptionCompare Is Nothing Then
                 Return Compiler.CommandLine.OptionCompare = CommandLine.OptionCompareTypes.Binary
             Else
                 Return m_OptionCompare.IsBinary
             End If
         End Get
     End Property
 
     Public Shadows ReadOnly Property IsOptionInferOn As Boolean
         Get
             If m_OptionInfer Is Nothing Then
                 Return Compiler.CommandLine.OptionInfer = CommandLine.OptionInferTypes.On
             Else
                 Return m_OptionInfer.IsOn
             End If
         End Get
     End Property
 
     ''' <summary>
     ''' The state of the Option Compare flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionCompareText() As Boolean
         Get
             Return Not IsOptionCompareBinary
         End Get
     End Property
 
     ''' <summary>
     ''' The imports clauses this file has.
     ''' </summary>
     ReadOnly Property [Imports]() As ImportsClauses
         Get
             Return m_Imports
         End Get
     End Property
 
     ''' <summary>
     ''' Compare one CodeFile to another based on filename.
     ''' </summary>
     ''' <param name="value"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Overrides Function Equals(ByVal value As Object) As Boolean
         Dim file As CodeFile = TryCast(value, CodeFile)
         If file IsNot Nothing Then
             If file Is Me Then
                 Return True
             Else
                 Return Microsoft.VisualBasic.Strings.StrComp(m_FileName, file.FileName, Microsoft.VisualBasic.CompareMethod.Text) = 0
             End If
         Else
             Return False
         End If
     End Function
 
     ''' <summary>
     ''' Create a new code file with the specified filename.
     ''' </summary>
     ''' <param name="FileName"></param>
     ''' <remarks></remarks>
     Sub New(ByVal FileName As String, ByVal RelativePath As String, ByVal Parent As BaseObject)
         MyBase.New(Parent)
         'Try to get the absolute path for all files.
         If FileName Is Nothing OrElse FileName.IndexOfAny(System.IO.Path.GetInvalidFileNameChars()) >= 0 Then
             m_FileName = FileName
         Else
             m_FileName = IO.Path.GetFullPath(FileName)
         End If
         m_RelativePath = RelativePath
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="1557" endline="1563">
<![CDATA[
 
     Public Sub New(ByVal Compiler As Compiler)
         MyBase.New(Compiler)
     Private m_PeekedChars As New Generic.Queue(Of Char)
     Private m_Reader As System.IO.StreamReader
 
     Private m_StringBuilder(127) As Char
     Private m_StringBuilderLength As Integer
 
     ''' <summary>
     ''' If any tokens has been found on this line.
     ''' Reset by IncLine, set by NewToken
     ''' </summary>
     ''' <remarks></remarks>
     Private m_TokensSeenOnLine As Integer
 
     Private m_Files As Generic.Queue(Of CodeFile)
 
     'Data about the current token
     Private m_LastWasNewline As Boolean
     Private m_Current As Token
     Private m_CurrentTypeCharacter As TypeCharacters.Characters
     Private m_CurrentData As Object
     Private m_Peeked As Token?
 
 #Region "Conditional Compilation"
     'Data related to conditional compilation
     Private m_ProjectConstants As New ConditionalConstants
     Private m_CurrentConstants As ConditionalConstants
     Private m_Evaluator As New ConditionalExpression(Me)
 
     ''' <summary>
     ''' 0 if condition is false and has never been true
     ''' 1 if condition is true
     ''' -1 if condition has been true
     ''' </summary>
     ''' <remarks></remarks>
     Private m_ConditionStack As New Generic.List(Of Integer)
 
     Private m_Methods As New Generic.Dictionary(Of Mono.Cecil.MethodReference, Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute))
 
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
             If Helper.CompareType(Compiler.TypeCache.System_Diagnostics_ConditionalAttribute, attrib.AttributeType) = False Then
                 Continue For
             End If
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
 
     ''' <summary>
     ''' Checks if the specified symbol is defined at the specified location.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <param name="Location"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsDefinedAtLocation(ByVal Symbol As String, ByVal Location As Span) As Boolean
         Dim constants As ConditionalConstants
 
         constants = Location.File(Compiler).GetConditionalConstants(Location.Line)
 
         If constants IsNot Nothing AndAlso constants.ContainsKey(Symbol) Then
             Return constants(Symbol).IsDefined
         End If
 
         If m_ProjectConstants.ContainsKey(Symbol) Then
             Return m_ProjectConstants(Symbol).IsDefined
         End If
 
         Return False
     End Function
 
     ReadOnly Property IfdOut() As Boolean
         Get
             For i As Integer = 0 To m_ConditionStack.Count - 1
                 If Not m_ConditionStack(i) > 0 Then Return True
             Next
             Return False
         End Get
     End Property
 
     ReadOnly Property CurrentConstants() As ConditionalConstants
         Get
             Return m_CurrentConstants
         End Get
     End Property
 
     Private Sub LoadProjectConstants()
         'Set the project level defines
         Dim Constant As ConditionalConstant
         For Each def As Define In Compiler.CommandLine.Define
             Constant = New ConditionalConstant(def.Symbol, def.ObjectValue)
             m_ProjectConstants.Add(Constant)
         Next
 
         ResetCurrentConstants()
     End Sub
 
     Private Sub ResetCurrentConstants()
         m_CurrentConstants = New ConditionalConstants(m_ProjectConstants)
     End Sub
 
 #Region "Const"
     Private Sub ParseConst()
         Dim name As String
         Dim value As Object = Nothing
 
         If m_Current <> KS.Const Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Const'")
             Me.EatLine(False)
             Return
         End If
 
         Me.NextUnconditionally()
 
         If m_Current.IsIdentifier = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, m_Current.Location)
             Me.EatLine(False)
             Return
         End If
         name = m_Current.Identifier
         Me.NextUnconditionally()
 
         If m_Current <> KS.Equals Then
             Compiler.Report.ShowMessage(Messages.VBNC30249, m_Current.Location)
             Return
         End If
         Me.NextUnconditionally()
 
         m_Evaluator.Parse(value)
 
         If Me.IfdOut = False Then
             m_CurrentConstants.Add(New ConditionalConstant(name, value))
             GetLocation.File(Compiler).AddConditionalConstants(GetLocation.Line, m_CurrentConstants)
         End If
 
         ParseEndOfLine()
     End Sub
 #End Region
 
 #Region "If"
     Private Sub ParseIf()
         Dim theExpression As ConditionalExpression
         Dim expression As Object = Nothing
 
         If Not m_Current = KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         theExpression = New ConditionalExpression(Me)
         If Not theExpression.Parse(expression) Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If CBool(expression) Then
             m_ConditionStack.Add(1)
         Else
             m_ConditionStack.Add(0)
         End If
     End Sub
 
     Private Sub ParseElseIf()
         If Not CheckEmtpyStack(Messages.VBNC30014) Then Return
 
         Dim theExpression As New ConditionalExpression(Me)
         Dim expression As Object = Nothing
 
         If m_Current <> KS.ElseIf Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ElseIf'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If theExpression.Parse(expression) = False Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 0 AndAlso CBool(expression) Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         End If
     End Sub
 
     Private Sub ParseElse()
         If m_Current <> KS.Else Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Else'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 0 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         End If
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndIf()
         If m_Current <> KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         m_ConditionStack.RemoveAt(m_ConditionStack.Count - 1)
         ParseEndOfLine()
     End Sub
 
     Private Function CheckEmtpyStack(Optional ByVal Msg As Messages = Messages.VBNC30013) As Boolean
         If m_ConditionStack.Count > 0 Then Return True
 
         Compiler.Report.ShowMessage(Msg, GetCurrentLocation)
         EatLine(False)
 
         Return False
     End Function
 #End Region
 
 #Region "Region"
     Private Sub ParseRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
 
         'Save the location of the #Region token to use as the location of any missing string literal
         Dim regionLoc As Span = GetCurrentLocation()
 
         Me.NextUnconditionally()
 
         If Not m_Current.IsStringLiteral Then
             Compiler.Report.ShowMessage(Messages.VBNC30217, regionLoc)
             EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 #End Region
 
 #Region "External Source"
     Private Sub ParseExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.LParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected '('")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsStringLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected string literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.Comma Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ','")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsIntegerLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected integer literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.RParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ')'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 #End Region
 
     Private Sub ParseEndOfLine()
         If m_Current.IsEndOfLine = False Then
             Helper.AddError(Me.Compiler, GetCurrentLocation, "Expected end of line")
             EatLine(False)
             Return
         End If
         'Me.NextUnconditionally()
     End Sub
 
     Private Sub ParseEnd()
         If m_Current <> KS.End Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'End'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current = KS.If Then
             ParseEndIf()
         ElseIf m_Current.Equals("ExternalSource") Then
             ParseEndExternalSource()
         ElseIf m_Current.Equals("Region") Then
             ParseEndRegion()
         Else
             Helper.AddError(Me, "'End' what?")
             Me.EatLine(False)
             Return
         End If
     End Sub
 
     Public Function [Next]() As Token
         Do
             NextUnconditionally()
 
             If m_Current.IsEndOfCode Then
                 Return m_Current
             End If
 
             If m_Current.IsEndOfFile Then
                 ResetCurrentConstants()
                 Return m_Current
             End If
 
             If TokensSeenOnLine = 1 AndAlso m_Current = KS.Numeral Then
 
                 Me.NextUnconditionally()
 
                 If m_Current.IsEndOfFile Then
                     ResetCurrentConstants()
                     Return m_Current
                 ElseIf m_Current.IsEndOfLine Then
                     EatLine(True)
                     Return Me.Next()
                 End If
 
                 If m_Current = KS.If Then
                     ParseIf()
                 ElseIf m_Current = KS.Else Then
                     ParseElse()
                 ElseIf m_Current = KS.ElseIf Then
                     ParseElseIf()
                 ElseIf m_Current = KS.Const Then
                     ParseConst()
                 ElseIf m_Current.Equals("ExternalSource") Then
                     ParseExternalSource()
                 ElseIf m_Current.Equals("Region") Then
                     ParseRegion()
                 ElseIf m_Current = KS.End Then
                     ParseEnd()
                 Else
                     Compiler.Report.ShowMessage(Messages.VBNC30248, GetCurrentLocation())
                     EatLine(False)
                 End If
             ElseIf IfdOut Then
                 If m_Current.IsEndOfLine = False Then EatLine(False)
                 Continue Do
             Else
                 If m_Current.IsEndOfLineOnly AndAlso m_LastWasNewline Then
                     Continue Do
                 End If
                 m_LastWasNewline = m_Current.IsEndOfLineOnly
                 Return m_Current
             End If
         Loop While m_Current.IsEndOfCode = False AndAlso m_Current.IsEndOfFile = False
         Return m_Current
     End Function
 #End Region
 
 #Region "StringBuilder"
     Private Property StringBuilderLength As Integer
         Get
             Return m_StringBuilderLength
         End Get
         Set(ByVal value As Integer)
             m_StringBuilderLength = value
         End Set
     End Property
 
     Private Sub StringBuilderAppend(ByVal c As Char)
         m_StringBuilderLength += 1
         If m_StringBuilder Is Nothing Then
             ReDim m_StringBuilder(31)
         End If
         If m_StringBuilder.Length < m_StringBuilderLength Then
             Dim tmp(Math.Max(m_StringBuilder.Length * 2 - 1, m_StringBuilderLength)) As Char
             m_StringBuilder.CopyTo(tmp, 0)
             m_StringBuilder = tmp
         End If
         m_StringBuilder(m_StringBuilderLength - 1) = c
     End Sub
 
     Private Function StringBuilderToString() As String
         Dim result As String
         result = New String(m_StringBuilder, 0, m_StringBuilderLength)
         m_StringBuilderLength = 0
         Return result
     End Function
 #End Region
 
     Private Structure Data
         Public Type As TokenType
         Public Symbol As KS
         Public Data As Object
         Public TypeCharacter As TypeCharacters.Characters
 
         Public Sub Clear()
             Type = vbnc.TokenType.None
             Symbol = KS.None
             Data = Nothing
             TypeCharacter = TypeCharacters.Characters.None
         End Sub
     End Structure
 
     ReadOnly Property TokensSeenOnLine() As Integer
         Get
             Return m_TokensSeenOnLine
         End Get
     End Property
 
     ReadOnly Property TotalLineCount() As UInteger
         Get
             Return m_TotalLineCount
         End Get
     End Property
 
     ReadOnly Property TotalCharCount() As Integer
         Get
             Return m_TotalCharCount
         End Get
     End Property
 
     Private Function IsNewLine() As Boolean
         Return IsNewLine(CurrentChar)
     End Function
 
     Public Shared Function IsNewLine(ByVal chr As Char) As Boolean
         Return chr = nlA OrElse chr = nlD OrElse chr = nl2028 OrElse chr = nl2029 OrElse chr = nl0
     End Function
 
     Private Function IsUnderscoreCharacter(ByVal chr As Char) As Boolean
         'UnderscoreCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.ConnectorPunctuation
     End Function
 
     Private Function IsIdentifierCharacter(ByVal chr As Char) As Boolean
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         Return IsUnderscoreCharacter(chr) OrElse _
                 IsAlphaCharacter(chr) OrElse _
                 IsNumericCharacter(chr) OrElse _
                 IsCombiningCharacter(chr) OrElse _
                 IsFormattingCharacter(chr)
     End Function
 
     Private Function IsNumericCharacter(ByVal chr As Char) As Boolean
         'NumericCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.DecimalDigitNumber 'Nd
     End Function
 
     Private Function IsOperatorCharacter(ByVal chr As Char) As Boolean
         'Operator 
         Return chr = "&"c OrElse _
                 chr = "*"c OrElse _
                 chr = "+"c OrElse _
                 chr = "-"c OrElse _
                 chr = "/"c OrElse _
                 chr = "\"c OrElse _
                 chr = "^"c OrElse _
                 chr = "<"c OrElse _
                 chr = "="c OrElse _
                 chr = ">"c
         chr = "
     End Function
 
     Private Function IsSeparatorCharacter(ByVal chr As Char) As Boolean
         'Separator 
         Return chr = "("c OrElse _
                 chr = ")"c OrElse _
                 chr = "{"c OrElse _
                 chr = "}"c OrElse _
                 chr = "!"c OrElse _
                 chr = "#"c OrElse _
                 chr = ","c OrElse _
                 chr = "."c OrElse _
                 chr = "
     End Function
 
     Private Function IsCombiningCharacter(ByVal chr As Char) As Boolean
         'CombiningCharacter 
         Select Case Char.GetUnicodeCategory(chr)
             Case Globalization.UnicodeCategory.NonSpacingMark 'Mn
                 Return True
             Case Globalization.UnicodeCategory.SpacingCombiningMark 'Mc
                 Return True
             Case Else
                 Return False
         End Select
     End Function
 
     Private Function IsFormattingCharacter(ByVal chr As Char) As Boolean
         'FormattingCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.Format 'Cf
     End Function
 
     Private Function IsAlphaCharacter(ByVal chr As Char) As Boolean
         'AlphaCharacter 
         Select Case Char.GetUnicodeCategory(chr) 'Alpha Character
             Case Globalization.UnicodeCategory.UppercaseLetter 'Lu
                 Return True
             Case Globalization.UnicodeCategory.LowercaseLetter 'Ll
                 Return True
             Case Globalization.UnicodeCategory.TitlecaseLetter  'Lt
                 Return True
             Case Globalization.UnicodeCategory.ModifierLetter 'Lm
                 Return True
             Case Globalization.UnicodeCategory.OtherLetter 'Lo
                 Return True
             Case Globalization.UnicodeCategory.LetterNumber 'Nl
                 Return True
             Case Else
                 Return False
         End Select
     End Function
 
     Private Function IsLineContinuation() As Boolean
         If Not (CurrentChar() = " "c AndAlso PeekChar() = "_"c) Then Return False
 
         Dim i As Integer = 2
         Do Until IsNewLine(PeekChars(i))
             If IsWhiteSpace(PeekChars(i)) = False Then Return False
             i += 1
         Loop
 
         Return True
     End Function
 
     Shared Function IsWhiteSpace(ByVal chr As Char) As Boolean
         Return chr = nlTab OrElse Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.SpaceSeparator
     End Function
 
     Private Function IsWhiteSpace() As Boolean
         Return IsWhiteSpace(CurrentChar())
     End Function
 
     Private Function IsComment(ByVal chr As Char) As Boolean
         Return chr = COMMENTCHAR1 OrElse chr = COMMENTCHAR2 OrElse chr = COMMENTCHAR3
     End Function
 
     Private Function IsComment() As Boolean
         Return IsComment(CurrentChar)
     End Function
 
     ''' <summary>
     ''' Eat all characters until the newline character(s). Optionally eat the newline character(s) as well
     ''' </summary>
     ''' <param name="NewLineCharAlso"></param>
     ''' <remarks></remarks>
     Private Sub EatLine(ByVal NewLineCharAlso As Boolean)
         'LineTerminator 
         '  < Unicode carriage return character (0x000D) > |
         '  < Unicode line feed character (0x000A) > |
         '  < Unicode carriage return character > < Unicode line feed character > |
         '  < Unicode line separator character (0x2028) > |
         '  < Unicode paragraph separator character (0x2029) >
 
         Dim ch As Char = m_CurrentChar
         Do Until IsNewLine(ch)
             ch = NextChar()
         Loop
 
         If NewLineCharAlso Then
             EatNewLine()
         End If
     End Sub
 
     Private Sub EatNewLine()
         Select Case CurrentChar()
             Case nlD
                 NextChar()
                 If CurrentChar() = nlA Then
                     NextChar()
                 End If
                 IncLine()
             Case nlA, nl2029, nl2028
                 NextChar()
                 IncLine()
             Case nl0
                 IncLine()
             Case Else
                 Throw New InternalException("Current character is not a new line.")
         End Select
     End Sub
 
     Public Shared Function IsSingleNewLine(ByVal chr1 As Char, ByVal chr2 As Char) As Boolean
         Return Not (chr1 = nlD AndAlso chr2 = nlA)
     End Function
 
     Private Sub EatComment()
         Select Case CurrentChar()
             Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'Traditional VB comment
                 EatLine(False) 'do not eat newline, it needs to be added as a token
                 Return
             Case Else
                 REM is taken care of some other place.
                 'Function should never be called if not a comment
                 Throw New InternalException("EatComment called with no comment.")
         End Select
     End Sub
 
     Private Sub EatWhiteSpace()
         While IsWhiteSpace()
             If IsLineContinuation() Then
                 EatLine(True)
             Else
                 NextChar()
             End If
         End While
     End Sub
 
     Private Function GetDate() As Token
         Helper.Assert(CurrentChar() = "#"c, "GetDate called without a date!")
 
         EatWhiteSpace()
 
         Dim Count As Integer
         'Date value
         Dim bCont As Boolean = True
         StringBuilderLength = 0
         Do
             Count += 1
             Dim ch As Char = NextChar()
             If (IsNewLine()) Then
                 Compiler.Report.ShowMessage(Messages.VBNC90000, GetCurrentLocation())
                 bCont = False
             Else
                 Select Case ch
                     Case nl0
                         Compiler.Report.ShowMessage(Messages.VBNC90001, GetCurrentLocation())
                         bCont = False
                     Case "#"c
                         NextChar() 'The ending #
                         bCont = False
                 End Select
             End If
             If bCont Then StringBuilderAppend(ch)
         Loop While bCont
 
         Return Token.CreateDateToken(GetCurrentLocation, CDate(StringBuilderToString))
     End Function
 
     Private Function CanStartIdentifier() As Boolean
         Return CanStartIdentifier(CurrentChar)
     End Function
 
     Private Function CanStartIdentifier(ByVal chr As Char) As Boolean
         Return IsAlphaCharacter(chr) OrElse IsUnderscoreCharacter(chr)
     End Function
 
     Private Function GetEscapedIdentifier() As Token
         'EscapedIdentifier  
         Helper.Assert(CurrentChar() = "["c)
         NextChar()
         Dim id As Token
         id = GetIdentifier(True)
         If CurrentChar() = "]"c = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30034, GetCurrentLocation)
         Else
             NextChar()
         End If
         Return id
     End Function
 
     Private Function GetIdentifier(Optional ByVal Escaped As Boolean = False) As Token
         Dim bValid As Boolean = False
         Dim ch As Char
 
         'Identifier  
         '	NonEscapedIdentifier  [  TypeCharacter  ]  |
         '	Keyword  TypeCharacter  |
         '	EscapedIdentifier
         '
         'NonEscapedIdentifier  
         'EscapedIdentifier  
         '
         'IdentifierName 
 
         'IdentifierStart 
         '   AlphaCharacter |
         '   UnderscoreCharacter IdentifierCharacter 
 
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         StringBuilderLength = 0
 
         ch = CurrentChar()
         StringBuilderAppend(ch)
         If IsAlphaCharacter(ch) Then
             bValid = True
         ElseIf IsUnderscoreCharacter(ch) Then
             ch = NextChar()
             StringBuilderAppend(ch)
             bValid = IsIdentifierCharacter(ch)
         End If
 
         If Not bValid Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, Me.GetCurrentLocation(), CStr(ch))
             Return Nothing
         Else
             Do While IsIdentifierCharacter(NextChar)
                 StringBuilderAppend(CurrentChar)
             Loop
         End If
 
         'The type character ! presents a special problem in that it can be used both as a type character and 
         'as a separator in the language. To remove ambiguity, a ! character is a type character as long as 
         'the character that follows it cannot start an identifier. If it can, then the ! character is a separator, 
         'not a type character.
         Dim typecharacter As TypeCharacters.Characters
         Dim canstartidentifier As Boolean = Me.IsLastChar = False AndAlso (IsAlphaCharacter(PeekChar) OrElse IsUnderscoreCharacter(PeekChar))
         If TypeCharacters.IsTypeCharacter(CurrentChar, typecharacter) AndAlso (canstartidentifier = False OrElse typecharacter <> TypeCharacters.Characters.SingleTypeCharacter) Then
             NextChar()
             m_CurrentTypeCharacter = typecharacter
             Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
         Else
             Dim keyword As KS
             If Escaped = False AndAlso Token.IsKeyword(m_StringBuilder, m_StringBuilderLength, keyword) Then
                 Return Token.CreateKeywordToken(GetCurrentLocation, keyword)
             Else
                 m_CurrentTypeCharacter = typecharacter
                 Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
             End If
         End If
     End Function
 
     Private Function GetString() As Token
         Dim bEndOfString As Boolean = False
         StringBuilderLength = 0
         Do
             Select Case NextChar()
                 Case nl27, nl201C, nl201D
                     'If " followed by a ", output one "
                     Dim nc As Char = NextChar()
                     If nc = nl27 OrElse nc = nl201C OrElse nc = nl201D Then
                         StringBuilderAppend(nc)
                     Else
                         bEndOfString = True
                     End If
                 Case nlA, nlD, nl2028, nl2029
                     Compiler.Report.ShowMessage(Messages.VBNC30648, GetCurrentLocation)
                     bEndOfString = True
                 Case Else
                     If m_EndOfFile Then
                         Compiler.Report.ShowMessage(Messages.VBNC30648, GetCurrentLocation)
                         'PreviousChar() 'Step back
                         bEndOfString = True
                     Else
                         StringBuilderAppend(CurrentChar())
                     End If
 
             End Select
         Loop While bEndOfString = False
         If CurrentChar() = "C"c OrElse CurrentChar() = "c"c Then
             'Is a char type character
             NextChar()
             If StringBuilderLength <> 1 Then
                 Compiler.Report.ShowMessage(Messages.VBNC30004, GetCurrentLocation())
                 Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
             Else
                 Return Token.CreateCharToken(GetCurrentLocation, m_StringBuilder(0))
             End If
         Else
             Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
         End If
     End Function
 
     Private Function GetNumber() As Token
         Dim Base As IntegerBase
         Dim bReal As Boolean
         Dim bE As Boolean
         Static Builder As New Text.StringBuilder
         Builder.Length = 0
 
         'First find the type of the number
         Select Case CurrentChar()
             Case "."c, "0"c To "9"c 'Decimal
                 Base = IntegerBase.Decimal
             Case "&"c
                 Select Case NextChar()
 #If EXTENDED Then
                     Case "b"c, "B"c 'Binary
                         Base = IntegerBase.Binary
 #End If
                     Case "d"c, "D"c 'Decimal
                         Base = IntegerBase.Decimal
                     Case "h"c, "H"c 'Hex
                         Base = IntegerBase.Hex
                     Case "o"c, "O"c 'Octal
                         Base = IntegerBase.Octal
                     Case Else
                         Throw New InternalException(GetCurrentLocation.ToString(Compiler)) 'Should never get here, this function should only be called with the correct specifiers.
                 End Select
                 NextChar()
             Case Else
                 Throw New InternalException("Invalid character
         End Select
 
         Dim ch As Char = CurrentChar()
         ' Then start the parsing
         Select Case Base
             Case IntegerBase.Decimal
                 While Me.IsNumericCharacter(ch)
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
                 If ch = "."c Then
                     If Me.IsNumericCharacter(Me.PeekChar) Then
                         Builder.Append(ch)
                         bReal = True
                         ch = NextChar()
                         While Me.IsNumericCharacter(ch)
                             Builder.Append(ch)
                             ch = NextChar()
                         End While
                     End If
                 End If
                 If ch = "E"c OrElse ch = "e"c Then
                     bE = True
                     bReal = True
                     Builder.Append(ch)
                     ch = NextChar()
                     If ch = "+"c OrElse ch = "-"c Then
                         Builder.Append(ch)
                         ch = NextChar()
                     End If
                     While Me.IsNumericCharacter(ch)
                         Builder.Append(ch)
                         ch = NextChar()
                     End While
                 End If
 #If EXTENDED Then
             Case IntegerBase.Binary
                 While ((ch >= "0"c) AndAlso (ch <= "1"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
 #End If
             Case IntegerBase.Hex
                 While (((ch >= "0"c) AndAlso (ch <= "9"c)) OrElse _
                   ((ch >= "a"c) AndAlso (ch <= "f"c)) OrElse _
                   ((ch >= "A"c) AndAlso (ch <= "F"c)))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case IntegerBase.Octal
                 While ((ch >= "0"c) AndAlso (ch <= "7"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
 
         'Find the type character, if any
         Dim strType As String = ""
         Dim typeOfNumber As BuiltInDataTypes
         Dim typeCharacter As LiteralTypeCharacters_Characters = LiteralTypeCharacters_Characters.None
 
         Dim test As String
         test = CurrentChar()
         If test = "U" OrElse test = "u" Then test &= PeekChar()
         typeCharacter = LiteralTypeCharacters.GetTypeCharacter(test)
         If typeCharacter <> LiteralTypeCharacters_Characters.None Then
             NextChar()
             If test.Length = 2 Then NextChar()
             typeOfNumber = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
         End If
 
         If typeCharacter <> LiteralTypeCharacters_Characters.None AndAlso LiteralTypeCharacters.IsIntegral(typeCharacter) = False AndAlso Base <> IntegerBase.Decimal Then
             Compiler.Report.ShowMessage(Messages.VBNC90002, Me.GetCurrentLocation(), KS.Decimal.ToString)
         End If
 
         ' Found the string of the number
         Dim strResult As String = Builder.ToString
         Dim IntegerValue As ULong
 
         Select Case Base
             Case IntegerBase.Decimal
                 Try
                     Dim tp As BuiltInDataTypes
                     If typeCharacter = LiteralTypeCharacters_Characters.None Then
                         If bReal Then
                             tp = BuiltInDataTypes.Double
                         Else
                             tp = BuiltInDataTypes.Integer
                         End If
                     Else
                         tp = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
                     End If
                     Select Case tp
                         Case BuiltInDataTypes.Decimal
                             GetNumber = Token.CreateDecimalToken(GetCurrentLocation, Decimal.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Double
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, Double.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Single
                             GetNumber = Token.CreateSingleToken(GetCurrentLocation, Single.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Integer, BuiltInDataTypes.Long, BuiltInDataTypes.Short, BuiltInDataTypes.UInteger, BuiltInDataTypes.ULong, BuiltInDataTypes.UShort
                             If bReal Then
                                 Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                                 IntegerValue = 0
                             Else
                                 'Try to parse the result
                                 IntegerValue = ULong.Parse(strResult, Helper.USCulture)
                             End If
                             'Check if value is out of range for data type.
                             Dim bOutOfRange As Boolean
                             'TODO
                             Select Case tp
                                 Case BuiltInDataTypes.Integer
                                     If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Long
                                     If IntegerValue > Long.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Short
                                     If IntegerValue > Short.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UInteger
                                     If IntegerValue > UInteger.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.ULong 'Not necessary
                                     '    If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UShort
                                     If IntegerValue > UShort.MaxValue Then bOutOfRange = True
                                 Case Else
                                     Throw New InternalException("")
                             End Select
                             If bOutOfRange AndAlso typeCharacter <> LiteralTypeCharacters_Characters.None Then
                                 Compiler.Report.ShowMessage(Messages.VBNC30439, GetCurrentLocation(), typeCharacter.ToString)
                             End If
                             GetNumber = GetIntegralToken(ULong.Parse(strResult, Helper.USCulture), Base, typeCharacter)
                         Case Else
                             Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                     End Select
                 Catch ex As System.OverflowException
                     Compiler.Report.ShowMessage(Messages.VBNC30036, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90005, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 End Try
 #If EXTENDED Then
             Case IntegerBase.Binary
                 Try
                     IntegerValue = Helper.BinToInt(strResult)
                     IntegerValue = ConvertNonDecimalBits(IntegerValue, typeCharacter)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, "binary")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
 #End If
             Case IntegerBase.Hex
                 Try
                     'Console.WriteLine("Hex
                     IntegerValue = Helper.HexToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, Me.GetCurrentLocation, "hexadecimal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case IntegerBase.Octal
                 Try
                     IntegerValue = Helper.OctToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, GetCurrentLocation(), "octal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
     End Function
 
     Private Function GetIntegralToken(ByVal Value As ULong, ByVal Base As IntegerBase, ByVal TypeCharacter As LiteralTypeCharacters_Characters) As Token
         Dim case_type As BuiltInDataTypes
         'TODO
         If TypeCharacter = LiteralTypeCharacters_Characters.None Then
             If Value > Integer.MaxValue Then
                 case_type = BuiltInDataTypes.Long
             Else
                 case_type = BuiltInDataTypes.Integer
             End If
         Else
             case_type = LiteralTypeCharacters.GetBuiltInType(TypeCharacter)
         End If
 
         Select Case case_type
             Case BuiltInDataTypes.Integer
                 Return Token.CreateInt32Token(GetCurrentLocation, ExtractInt(Value, Base))
             Case BuiltInDataTypes.UInteger
                 Return Token.CreateUInt32Token(GetCurrentLocation, ExtractUInt(Value, Base))
             Case BuiltInDataTypes.Long
                 Return Token.CreateInt64Token(GetCurrentLocation, ExtractLong(Value, Base))
             Case BuiltInDataTypes.ULong
                 Return Token.CreateUInt64Token(GetCurrentLocation, ExtractULong(Value, Base))
             Case BuiltInDataTypes.Short
                 Return Token.CreateInt16Token(GetCurrentLocation, ExtractShort(Value, Base))
             Case BuiltInDataTypes.UShort
                 Return Token.CreateUInt16Token(GetCurrentLocation, ExtractUShort(Value, Base))
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
 
     Private Function ExtractInt(ByVal Value As ULong, ByVal Base As IntegerBase) As Integer
         Select Case Base
             Case IntegerBase.Decimal
                 Return CInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Integer.MaxValue Then
                     Return CInt(Integer.MinValue + (CUInt(Value) - Integer.MaxValue - 1))
                 Else
                     Return CInt(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractUInt(ByVal Value As ULong, ByVal Base As IntegerBase) As UInteger
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUInt(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractShort(ByVal Value As ULong, ByVal Base As IntegerBase) As Short
         Select Case Base
             Case IntegerBase.Decimal
                 Return CShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Short.MaxValue Then
                     Return CShort(Short.MinValue + (CUShort(Value) - Short.MaxValue - 1))
                 Else
                     Return CShort(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractUShort(ByVal Value As ULong, ByVal Base As IntegerBase) As UShort
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUShort(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractLong(ByVal Value As ULong, ByVal Base As IntegerBase) As Long
         Select Case Base
             Case IntegerBase.Decimal
                 Return CLng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Long.MaxValue Then
                     Return CLng(Long.MinValue + (Value - Long.MaxValue - 1))
                 Else
                     Return CLng(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractULong(ByVal Value As ULong, ByVal Base As IntegerBase) As ULong
         Select Case Base
             Case IntegerBase.Decimal
                 Return CULng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CULng(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Function GetCurrentLocation() As Span
         Return New Span(m_CodeFileIndex, m_CurrentLine, m_CurrentColumn)
     End Function
 
     ReadOnly Property CurrentLocation() As Span
         Get
             Return GetCurrentLocation()
         End Get
     End Property
 
     Private ReadOnly Property CurrentChar() As Char
         Get
             Return m_CurrentChar
         End Get
     End Property
 
     Private Function NextChar() As Char
         If m_CurrentColumn < 255 Then m_CurrentColumn += CByte(1)
         m_TotalCharCount += 1
 
         m_PreviousChar = m_CurrentChar
         If m_PeekedChars.Count > 0 Then
             m_CurrentChar = m_PeekedChars.Dequeue
         Else
             If m_Reader.EndOfStream Then
                 m_CurrentChar = nl0
             Else
                 If m_Reader.EndOfStream Then
                     m_EndOfFile = True
                     m_CurrentChar = nl0
                 Else
                     m_CurrentChar = Convert.ToChar(m_Reader.Read())
                 End If
             End If
         End If
 
         Return m_CurrentChar
     End Function
 
     Private ReadOnly Property PreviousChar() As Char
         Get
             Return m_PreviousChar
         End Get
     End Property
 
     Private Function PeekChar() As Char
         If m_PeekedChars.Count = 0 Then
             If m_Reader.EndOfStream Then Return nl0
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         End If
         Return m_PeekedChars.Peek()
     End Function
 
     Private Function PeekChars(ByVal Chars As Integer) As Char
         Do Until m_PeekedChars.Count >= Chars
             If m_Reader.EndOfStream Then Return nlA
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         Loop
         Return m_PeekedChars.ToArray()(Chars - 1)
     End Function
 
     ''' <summary>
     ''' Returns true if the current character is the last character in the scanner.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function IsLastChar() As Boolean
         Return m_Reader.EndOfStream
     End Function
 
     ''' <summary>
     ''' Next line!
     ''' </summary>
     ''' <remarks></remarks>
     Private Sub IncLine()
         m_CurrentLine += 1UI
         m_CurrentColumn = 1
         m_TokensSeenOnLine = 0
     End Sub
 
     ''' <summary>
     ''' Creates a new symbol token of the specified symbol.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function NewToken(ByVal Symbol As KS) As Token
         Return Token.CreateSymbolToken(GetCurrentLocation, Symbol)
     End Function
 
     Private Function GetNextToken() As Token
         Dim Result As Token = Nothing
         Do
             Select Case CurrentChar()
                 Case nl27, nl201C, nl201D 'String Literal
                     Result = GetString()
                 Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'VB Comment
                     EatComment()
                 Case nlD, nlA, nl2028, nl2029 'New line
 
                     'Keep the current line of the end of line token to the current line so we get better
                     'location info for errors and warnings
                     Result = Token.CreateEndOfLineToken(GetCurrentLocation)
                     EatNewLine()
 
                 Case nl0 'End of file
                     Result = Token.CreateEndOfFileToken(GetCurrentLocation)
                 Case "
                     NextChar()
                     Result = NewToken(KS.Colon)
                 Case ","c ',
                     NextChar()
                     Result = NewToken(KS.Comma)
                 Case "."c
                     If PeekChar() >= "0"c AndAlso PeekChar() <= "9"c Then
                         Result = GetNumber()
                     Else
                         NextChar()
                         Result = NewToken(KS.Dot)
                     End If
                 Case "0"c To "9"c
                     Result = GetNumber()
                 Case "("c
                     NextChar()
                     Result = NewToken(KS.LParenthesis)
                 Case ")"c
                     NextChar()
                     Result = NewToken(KS.RParenthesis)
                 Case "["c
                     Result = GetEscapedIdentifier()
                 Case "{"c
                     NextChar()
                     Result = NewToken(KS.LBrace)
                 Case "}"c
                     NextChar()
                     Result = NewToken(KS.RBrace)
                 Case ">"c
                     NextChar()
                     EatWhiteSpace()
                     'If CurrentChar() = "<"c Then
                     '    NextChar()
                     '    Result = NewToken(KS.NotEqual)
                     'Else
                     If CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.GE)
                     ElseIf CurrentChar() = ">"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftRightAssign)
                         Else
                             Result = NewToken(KS.ShiftRight)
                         End If
                     Else
                         Result = NewToken(KS.GT)
                     End If
                 Case "<"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = ">"c) Then
                         NextChar()
                         Result = NewToken(KS.NotEqual)
                     ElseIf CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.LE)
                     ElseIf CurrentChar() = "<"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftLeftAssign)
                         Else
                             Result = NewToken(KS.ShiftLeft)
                         End If
                     Else
                         Result = NewToken(KS.LT)
                     End If
                 Case "="c
                     NextChar()
                     Result = NewToken(KS.Equals)
                 Case "!"c
                     NextChar()
                     Result = NewToken(KS.Exclamation)
                 Case "?"c
                     NextChar()
                     Result = NewToken(KS.Interrogation)
                 Case "&"c
                     Select Case PeekChar()
 #If EXTENDED Then
                         Case "b"c, "B"c, "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #Else
                         Case "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #End If
                             Result = GetNumber()
                         Case Else 'Not a number, but operator
                             NextChar()
                             EatWhiteSpace()
                             If CurrentChar() = "="c Then
                                 Result = NewToken(KS.ConcatAssign)
                                 NextChar()
                             Else
                                 Result = NewToken(KS.Concat)
                             End If
                     End Select
                 Case "*"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MultAssign)
                     Else
                         Result = NewToken(KS.Mult)
                     End If
                 Case "+"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.AddAssign)
                     Else
                         Result = NewToken(KS.Add)
                     End If
                 Case "-"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MinusAssign)
                     Else
                         Result = NewToken(KS.Minus)
                     End If
                 Case "^"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.PowerAssign)
                     Else
                         Result = NewToken(KS.Power)
                     End If
                 Case "\"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.IntDivAssign)
                     Else
                         Result = NewToken(KS.IntDivision)
                     End If
                 Case "#"c
                     'Type characters are already scanned when they appear after a literal. 
                     'If scanning gets here, it is not a type character.
                     If m_TokensSeenOnLine = 0 Then
                         Result = NewToken(KS.Numeral)
                         NextChar()
                     Else
                         Result = GetDate()
                     End If
                 Case "/"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.RealDivAssign)
                     Else
                         Result = NewToken(KS.RealDivision)
                     End If
                 Case " "c 'Space
                     NextChar()
                     If (CurrentChar() = "_"c) Then '
                         Dim i As Integer = 1
                         Do While IsWhiteSpace(PeekChars(i))
                             i += 1
                         Loop
                         If IsNewLine(PeekChars(i)) Then
                             NextChar()
                             EatWhiteSpace()
                             EatNewLine()
                         End If
                     End If
                 Case nlTab ' Tab character
                     NextChar()
                 Case Else
                     If IsWhiteSpace() Then
                         NextChar()
                     ElseIf CanStartIdentifier() Then
                         Result = GetIdentifier()
                         If Result.IsKeyword AndAlso Result.Equals(KS.[REM]) Then
                             EatLine(False)
                             Result = Nothing
                         End If
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30037, GetCurrentLocation())
                         EatLine(False)
                     End If
             End Select
         Loop While Token.IsSomething(Result) = False
 
         If Result.IsEndOfLine = False Then
             m_TokensSeenOnLine += 1
         Else
             m_TokensSeenOnLine = 0
         End If
 
         Return Result
     End Function
 
     Public Sub New(ByVal Compiler As Compiler)
         MyBase.New(Compiler)
         m_Files = New Generic.Queue(Of CodeFile)(Compiler.CommandLine.Files)
         NextFile()
         LoadProjectConstants()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\AbstractMediaHandler.vb" startline="42" endline="49">
<![CDATA[
     Protected Sub New(ByRef Parent As frmMain, ByVal InputFile As String, Optional ByVal IsAudio As Boolean = False)
     Friend mOptions As New NameValueCollection
     Friend mIsAudio As Boolean
 
     Public Enum Mode As Integer
         SaveSelected = 1
         DeleteSelected = 2
         SaveSeparate = 3
     End Enum
 
 #End Region
 
 #Region "   Constructors and Properties "
 
     Protected Sub New(ByRef Parent As frmMain, ByVal InputFile As String, Optional ByVal IsAudio As Boolean = False)
         mIsAudio = IsAudio
         mInFile = InputFile
         mParent = Parent
         ProcessCaller = New ProcessCaller(mParent)
         AddHandler ProcessCaller.StdErrReceived, AddressOf mParent.MessageRecd
         AddHandler ProcessCaller.StdOutReceived, AddressOf mParent.MessageRecd
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmDiagnostics.vb" startline="12" endline="18">
<![CDATA[
     Dim SrvcCntrl As New ServiceControllerEx.ServiceControllerEx
 
     Dim S1 As String = "Windows service is optimized, no action required"
     Dim S2 As String = "Start the Windows service and set to Automatic startup"
     Dim S3 As String = "Stop the Windows service and set to Manual startup"
     Dim S4 As String = "Set the Windows service to Manual startup"
     Dim S5 As String = "Windows service not found"
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="41" endline="49">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' A new resource list.
     ''' </summary>	
     Sub New(ByVal Compiler As Compiler, ByVal LinkedResources As Boolean)
         m_Compiler = Compiler
         m_IsLinkedResources = LinkedResources
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="51" endline="57">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Arguments As Generic.List(Of Argument))
         MyBase.New(Parent)
     Private m_Arguments As New BaseObjects(Of Argument)(Me)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal ParamArray Expressions() As Expression)
         MyBase.New(Parent)
         If Expressions IsNot Nothing Then
             For Each item As Expression In Expressions
                 m_Arguments.Add(New PositionalArgument(Me, m_Arguments.Count, item))
             Next
         End If
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal Arguments As Generic.List(Of Argument))
         MyBase.New(Parent)
         If Arguments IsNot Nothing Then
             m_Arguments.AddRange(Arguments)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="133" endline="139">
<![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal LExp As Expression, ByVal RExp As Expression, ByVal Keyword As KS)
         MyBase.New(Parent, LExp, RExp)
         m_Keyword = Keyword
         Helper.Assert(m_Keyword = KS.Is OrElse m_Keyword = KS.IsNot)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MemberCache.vb" startline="63" endline="69">
<![CDATA[
     Sub New(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference)
     Public m_CacheInsensitive(MemberVisibility.All) As MemberCacheEntries
     Public m_FlattenedCacheInsensitive(MemberVisibility.All) As MemberCacheEntries
     Private m_ShadowedInterfaceMembers As Generic.List(Of Mono.Cecil.MemberReference)
     Private m_Type As Mono.Cecil.TypeReference
     Private m_Types As List(Of Mono.Cecil.TypeReference)
     Private m_Members As List(Of Mono.Collections.Generic.Collection(Of MemberReference))
     Private m_Bases As List(Of MemberCache)
     Private m_LoadedNames(MemberVisibility.All) As System.Collections.Generic.HashSet(Of String)
     Private m_LoadedAll(MemberVisibility.All) As Boolean
 
     Sub New(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference)
         m_Compiler = Compiler
         m_Type = Type
 
         Compiler.TypeManager.MemberCache.Add(Type, Me)
         ClearAll()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="105" endline="116">
<![CDATA[
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal [Namespace] As String, ByVal Name As Identifier)
         MyBase.New(Parent)
     Private m_Members As New MemberDeclarations(Me)
     Private m_Namespace As String
     Private m_Name As Identifier
 
     Private m_DefaultInstanceConstructor As ConstructorDeclaration
     Private m_DefaultSharedConstructor As ConstructorDeclaration
     Private m_StaticVariables As Generic.List(Of LocalVariableDeclaration)
     Private m_Serializable As Boolean
     Private m_AddedCompareTextAttribute As Boolean
 
     'Information collected during define phase.
     Private m_CecilType As Mono.Cecil.TypeDefinition
 
     Private m_FullName As String
 
     Private m_AddHandlers As New Generic.List(Of AddOrRemoveHandlerStatement)
     Private m_MyGroupField As TypeVariableDeclaration
 
     Property MyGroupField() As TypeVariableDeclaration
         Get
             Return m_MyGroupField
         End Get
         Set(ByVal value As TypeVariableDeclaration)
             m_MyGroupField = value
         End Set
     End Property
 
     Property Serializable() As Boolean
         Get
             Return m_Serializable
         End Get
         Set(ByVal value As Boolean)
             If m_CecilType IsNot Nothing Then m_CecilType.IsSerializable = value
             m_Serializable = value
         End Set
     End Property
 
     ReadOnly Property DescriptiveType() As String
         Get
             If TypeOf Me Is ClassDeclaration Then
                 Return "class"
             ElseIf TypeOf Me Is ModuleDeclaration Then
                 Return "module"
             ElseIf TypeOf Me Is EnumDeclaration Then
                 Return "enum"
             ElseIf TypeOf Me Is StructureDeclaration Then
                 Return "structure"
             ElseIf TypeOf Me Is DelegateDeclaration Then
                 Return "delegate"
             ElseIf TypeOf Me Is InterfaceDeclaration Then
                 Return "interface"
             Else
                 Return "type"
             End If
         End Get
     End Property
 
     ReadOnly Property AddHandlers() As Generic.List(Of AddOrRemoveHandlerStatement)
         Get
             Return m_AddHandlers
         End Get
     End Property
 
     Sub New(ByVal Parent As ParsedObject, ByVal [Namespace] As String, ByVal Name As Identifier)
         MyBase.New(Parent)
 
         m_Namespace = [Namespace]
         m_Name = Name
         MyBase.Name = Name.Name
 
         Helper.Assert(m_Namespace IsNot Nothing)
         Helper.Assert(m_Name IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Index.vb" startline="79" endline="88">
<![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub New(ByVal Obj As BaseObject, ByVal strMsg As String)
         MyBase.new()
         m_Message = "There has been an internal error in the compiler
         If Obj IsNot Nothing Then
             m_Message &= " caused by the line
         End If
 StopOnInternalException()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\AssignStatements\PowerAssignStatement.vb" startline="32" endline="39">
<![CDATA[
     End Property
 #End If
 
     Protected Overloads Overrides Function ResolveStatement(ByVal LSide As Expression, ByVal RSide As Expression) As Expression
         Dim result As Expression = New ExponentExpression(Me, LSide, RSide)
         result = ConversionExpression.GetTypeConversion(Me, result, LSide.ExpressionType)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\VoidClassification.vb" startline="107" endline="115">
<![CDATA[
 End Class
 
 Public Class ValueOnStackExpression
     Inherits CompilerGeneratedExpression
 
     Sub New(ByVal Parent As ParsedObject, ByVal ExpressionType As Mono.Cecil.TypeReference)
         MyBase.New(Parent, Nothing, ExpressionType)
         MyBase.m_Delegate = New CompilerGeneratedExpression.GenerateCodeDelegate(AddressOf GenerateCodeInternal)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="47" endline="53">
<![CDATA[
 
     Public Sub New(ByVal Compiler As Compiler, ByVal TokenReader As Scanner)
     Private m_ShowErrors As Boolean = True
 
     Private ReadOnly Property ShowErrors() As Boolean
         Get
             Return m_ShowErrors
         End Get
     End Property
 
     Public ReadOnly Property Compiler() As Compiler
         Get
             Return m_Compiler
         End Get
     End Property
 
     Public Sub New(ByVal Compiler As Compiler)
         m_Compiler = Compiler
         tm = m_Compiler.tm
         Helper.Assert(tm IsNot Nothing)
     End Sub
 
     Public Sub New(ByVal Compiler As Compiler, ByVal TokenReader As Scanner)
         m_Compiler = Compiler
         tm = New tm(Compiler, TokenReader)
         tm.NextToken()
         Helper.Assert(tm IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4428" endline="4435">
<![CDATA[
 
     Shared Function IsAccessible(ByVal Context As BaseObject, ByVal Caller As Mono.Cecil.TypeReference, ByVal [Property] As Mono.Cecil.PropertyReference) As Boolean
         If Caller Is Nothing Then
             Return Helper.IsAccessible(Context, GetPropertyAccess([Property]), [Property].DeclaringType)
         Else
             Return Helper.IsAccessible(Context, GetPropertyAccess([Property]), [Property].DeclaringType, Caller)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="147" endline="154">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Variable As Mono.Cecil.FieldReference, ByVal InstanceExpression As Expression)
         MyBase.New(Classifications.Value, Parent)
         Helper.Assert(Variable IsNot Nothing)
         m_Classification = New VariableClassification(Me.Parent, Variable, InstanceExpression)
         m_Type = DirectCast(m_Classification, VariableClassification).Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="121" endline="130">
<![CDATA[
 
     Function GenerateCodeAsValue(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_Resolved)
 
         Helper.EmitArgumentsAndCallOrCallVirt(Info, m_InstanceExpression, New ArgumentList(Parent, m_Parameters), ResolvedMethod)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="393" endline="400">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal variable As Mono.Cecil.FieldReference, ByVal InstanceExpression As Expression)
         MyBase.New(Classifications.Variable, Parent)
         m_FieldInfo = variable
         m_InstanceExpression = InstanceExpression
         Helper.Assert(m_InstanceExpression Is Nothing OrElse m_InstanceExpression.IsResolved)
         Helper.Assert((Helper.IsShared(variable) AndAlso m_InstanceExpression Is Nothing) OrElse (Helper.IsShared(variable) = False AndAlso m_InstanceExpression IsNot Nothing))
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\SubSignature.vb" startline="51" endline="61">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Name As String, ByVal Parameters As Mono.Cecil.ParameterReference())
         MyBase.New(Parent)
         m_Identifier = New Identifier(Me, Name, Nothing, TypeCharacters.Characters.None)
         m_ParameterList = New ParameterList(Me)
         For i As Integer = 0 To Parameters.GetUpperBound(0)
             m_ParameterList.Add(Parameters(i).Name, Parameters(i).ParameterType)
         Next
         'Helper.Assert(m_Identifier IsNot Nothing)
         Helper.Assert(m_ParameterList IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="1564" endline="1573">
<![CDATA[
 
     Public Sub New(ByVal Compiler As Compiler, ByVal Code As String)
         MyBase.New(Compiler)
     Private m_PeekedChars As New Generic.Queue(Of Char)
     Private m_Reader As System.IO.StreamReader
 
     Private m_StringBuilder(127) As Char
     Private m_StringBuilderLength As Integer
 
     ''' <summary>
     ''' If any tokens has been found on this line.
     ''' Reset by IncLine, set by NewToken
     ''' </summary>
     ''' <remarks></remarks>
     Private m_TokensSeenOnLine As Integer
 
     Private m_Files As Generic.Queue(Of CodeFile)
 
     'Data about the current token
     Private m_LastWasNewline As Boolean
     Private m_Current As Token
     Private m_CurrentTypeCharacter As TypeCharacters.Characters
     Private m_CurrentData As Object
     Private m_Peeked As Token?
 
 #Region "Conditional Compilation"
     'Data related to conditional compilation
     Private m_ProjectConstants As New ConditionalConstants
     Private m_CurrentConstants As ConditionalConstants
     Private m_Evaluator As New ConditionalExpression(Me)
 
     ''' <summary>
     ''' 0 if condition is false and has never been true
     ''' 1 if condition is true
     ''' -1 if condition has been true
     ''' </summary>
     ''' <remarks></remarks>
     Private m_ConditionStack As New Generic.List(Of Integer)
 
     Private m_Methods As New Generic.Dictionary(Of Mono.Cecil.MethodReference, Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute))
 
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
             If Helper.CompareType(Compiler.TypeCache.System_Diagnostics_ConditionalAttribute, attrib.AttributeType) = False Then
                 Continue For
             End If
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
 
     ''' <summary>
     ''' Checks if the specified symbol is defined at the specified location.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <param name="Location"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsDefinedAtLocation(ByVal Symbol As String, ByVal Location As Span) As Boolean
         Dim constants As ConditionalConstants
 
         constants = Location.File(Compiler).GetConditionalConstants(Location.Line)
 
         If constants IsNot Nothing AndAlso constants.ContainsKey(Symbol) Then
             Return constants(Symbol).IsDefined
         End If
 
         If m_ProjectConstants.ContainsKey(Symbol) Then
             Return m_ProjectConstants(Symbol).IsDefined
         End If
 
         Return False
     End Function
 
     ReadOnly Property IfdOut() As Boolean
         Get
             For i As Integer = 0 To m_ConditionStack.Count - 1
                 If Not m_ConditionStack(i) > 0 Then Return True
             Next
             Return False
         End Get
     End Property
 
     ReadOnly Property CurrentConstants() As ConditionalConstants
         Get
             Return m_CurrentConstants
         End Get
     End Property
 
     Private Sub LoadProjectConstants()
         'Set the project level defines
         Dim Constant As ConditionalConstant
         For Each def As Define In Compiler.CommandLine.Define
             Constant = New ConditionalConstant(def.Symbol, def.ObjectValue)
             m_ProjectConstants.Add(Constant)
         Next
 
         ResetCurrentConstants()
     End Sub
 
     Private Sub ResetCurrentConstants()
         m_CurrentConstants = New ConditionalConstants(m_ProjectConstants)
     End Sub
 
 #Region "Const"
     Private Sub ParseConst()
         Dim name As String
         Dim value As Object = Nothing
 
         If m_Current <> KS.Const Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Const'")
             Me.EatLine(False)
             Return
         End If
 
         Me.NextUnconditionally()
 
         If m_Current.IsIdentifier = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, m_Current.Location)
             Me.EatLine(False)
             Return
         End If
         name = m_Current.Identifier
         Me.NextUnconditionally()
 
         If m_Current <> KS.Equals Then
             Compiler.Report.ShowMessage(Messages.VBNC30249, m_Current.Location)
             Return
         End If
         Me.NextUnconditionally()
 
         m_Evaluator.Parse(value)
 
         If Me.IfdOut = False Then
             m_CurrentConstants.Add(New ConditionalConstant(name, value))
             GetLocation.File(Compiler).AddConditionalConstants(GetLocation.Line, m_CurrentConstants)
         End If
 
         ParseEndOfLine()
     End Sub
 #End Region
 
 #Region "If"
     Private Sub ParseIf()
         Dim theExpression As ConditionalExpression
         Dim expression As Object = Nothing
 
         If Not m_Current = KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         theExpression = New ConditionalExpression(Me)
         If Not theExpression.Parse(expression) Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If CBool(expression) Then
             m_ConditionStack.Add(1)
         Else
             m_ConditionStack.Add(0)
         End If
     End Sub
 
     Private Sub ParseElseIf()
         If Not CheckEmtpyStack(Messages.VBNC30014) Then Return
 
         Dim theExpression As New ConditionalExpression(Me)
         Dim expression As Object = Nothing
 
         If m_Current <> KS.ElseIf Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ElseIf'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If theExpression.Parse(expression) = False Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 0 AndAlso CBool(expression) Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         End If
     End Sub
 
     Private Sub ParseElse()
         If m_Current <> KS.Else Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Else'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 0 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         End If
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndIf()
         If m_Current <> KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         m_ConditionStack.RemoveAt(m_ConditionStack.Count - 1)
         ParseEndOfLine()
     End Sub
 
     Private Function CheckEmtpyStack(Optional ByVal Msg As Messages = Messages.VBNC30013) As Boolean
         If m_ConditionStack.Count > 0 Then Return True
 
         Compiler.Report.ShowMessage(Msg, GetCurrentLocation)
         EatLine(False)
 
         Return False
     End Function
 #End Region
 
 #Region "Region"
     Private Sub ParseRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
 
         'Save the location of the #Region token to use as the location of any missing string literal
         Dim regionLoc As Span = GetCurrentLocation()
 
         Me.NextUnconditionally()
 
         If Not m_Current.IsStringLiteral Then
             Compiler.Report.ShowMessage(Messages.VBNC30217, regionLoc)
             EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 #End Region
 
 #Region "External Source"
     Private Sub ParseExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.LParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected '('")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsStringLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected string literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.Comma Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ','")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsIntegerLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected integer literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.RParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ')'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 
     Private Sub ParseEndExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
 #End Region
 
     Private Sub ParseEndOfLine()
         If m_Current.IsEndOfLine = False Then
             Helper.AddError(Me.Compiler, GetCurrentLocation, "Expected end of line")
             EatLine(False)
             Return
         End If
         'Me.NextUnconditionally()
     End Sub
 
     Private Sub ParseEnd()
         If m_Current <> KS.End Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'End'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current = KS.If Then
             ParseEndIf()
         ElseIf m_Current.Equals("ExternalSource") Then
             ParseEndExternalSource()
         ElseIf m_Current.Equals("Region") Then
             ParseEndRegion()
         Else
             Helper.AddError(Me, "'End' what?")
             Me.EatLine(False)
             Return
         End If
     End Sub
 
     Public Function [Next]() As Token
         Do
             NextUnconditionally()
 
             If m_Current.IsEndOfCode Then
                 Return m_Current
             End If
 
             If m_Current.IsEndOfFile Then
                 ResetCurrentConstants()
                 Return m_Current
             End If
 
             If TokensSeenOnLine = 1 AndAlso m_Current = KS.Numeral Then
 
                 Me.NextUnconditionally()
 
                 If m_Current.IsEndOfFile Then
                     ResetCurrentConstants()
                     Return m_Current
                 ElseIf m_Current.IsEndOfLine Then
                     EatLine(True)
                     Return Me.Next()
                 End If
 
                 If m_Current = KS.If Then
                     ParseIf()
                 ElseIf m_Current = KS.Else Then
                     ParseElse()
                 ElseIf m_Current = KS.ElseIf Then
                     ParseElseIf()
                 ElseIf m_Current = KS.Const Then
                     ParseConst()
                 ElseIf m_Current.Equals("ExternalSource") Then
                     ParseExternalSource()
                 ElseIf m_Current.Equals("Region") Then
                     ParseRegion()
                 ElseIf m_Current = KS.End Then
                     ParseEnd()
                 Else
                     Compiler.Report.ShowMessage(Messages.VBNC30248, GetCurrentLocation())
                     EatLine(False)
                 End If
             ElseIf IfdOut Then
                 If m_Current.IsEndOfLine = False Then EatLine(False)
                 Continue Do
             Else
                 If m_Current.IsEndOfLineOnly AndAlso m_LastWasNewline Then
                     Continue Do
                 End If
                 m_LastWasNewline = m_Current.IsEndOfLineOnly
                 Return m_Current
             End If
         Loop While m_Current.IsEndOfCode = False AndAlso m_Current.IsEndOfFile = False
         Return m_Current
     End Function
 #End Region
 
 #Region "StringBuilder"
     Private Property StringBuilderLength As Integer
         Get
             Return m_StringBuilderLength
         End Get
         Set(ByVal value As Integer)
             m_StringBuilderLength = value
         End Set
     End Property
 
     Private Sub StringBuilderAppend(ByVal c As Char)
         m_StringBuilderLength += 1
         If m_StringBuilder Is Nothing Then
             ReDim m_StringBuilder(31)
         End If
         If m_StringBuilder.Length < m_StringBuilderLength Then
             Dim tmp(Math.Max(m_StringBuilder.Length * 2 - 1, m_StringBuilderLength)) As Char
             m_StringBuilder.CopyTo(tmp, 0)
             m_StringBuilder = tmp
         End If
         m_StringBuilder(m_StringBuilderLength - 1) = c
     End Sub
 
     Private Function StringBuilderToString() As String
         Dim result As String
         result = New String(m_StringBuilder, 0, m_StringBuilderLength)
         m_StringBuilderLength = 0
         Return result
     End Function
 #End Region
 
     Private Structure Data
         Public Type As TokenType
         Public Symbol As KS
         Public Data As Object
         Public TypeCharacter As TypeCharacters.Characters
 
         Public Sub Clear()
             Type = vbnc.TokenType.None
             Symbol = KS.None
             Data = Nothing
             TypeCharacter = TypeCharacters.Characters.None
         End Sub
     End Structure
 
     ReadOnly Property TokensSeenOnLine() As Integer
         Get
             Return m_TokensSeenOnLine
         End Get
     End Property
 
     ReadOnly Property TotalLineCount() As UInteger
         Get
             Return m_TotalLineCount
         End Get
     End Property
 
     ReadOnly Property TotalCharCount() As Integer
         Get
             Return m_TotalCharCount
         End Get
     End Property
 
     Private Function IsNewLine() As Boolean
         Return IsNewLine(CurrentChar)
     End Function
 
     Public Shared Function IsNewLine(ByVal chr As Char) As Boolean
         Return chr = nlA OrElse chr = nlD OrElse chr = nl2028 OrElse chr = nl2029 OrElse chr = nl0
     End Function
 
     Private Function IsUnderscoreCharacter(ByVal chr As Char) As Boolean
         'UnderscoreCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.ConnectorPunctuation
     End Function
 
     Private Function IsIdentifierCharacter(ByVal chr As Char) As Boolean
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         Return IsUnderscoreCharacter(chr) OrElse _
                 IsAlphaCharacter(chr) OrElse _
                 IsNumericCharacter(chr) OrElse _
                 IsCombiningCharacter(chr) OrElse _
                 IsFormattingCharacter(chr)
     End Function
 
     Private Function IsNumericCharacter(ByVal chr As Char) As Boolean
         'NumericCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.DecimalDigitNumber 'Nd
     End Function
 
     Private Function IsOperatorCharacter(ByVal chr As Char) As Boolean
         'Operator 
         Return chr = "&"c OrElse _
                 chr = "*"c OrElse _
                 chr = "+"c OrElse _
                 chr = "-"c OrElse _
                 chr = "/"c OrElse _
                 chr = "\"c OrElse _
                 chr = "^"c OrElse _
                 chr = "<"c OrElse _
                 chr = "="c OrElse _
                 chr = ">"c
         chr = "
     End Function
 
     Private Function IsSeparatorCharacter(ByVal chr As Char) As Boolean
         'Separator 
         Return chr = "("c OrElse _
                 chr = ")"c OrElse _
                 chr = "{"c OrElse _
                 chr = "}"c OrElse _
                 chr = "!"c OrElse _
                 chr = "#"c OrElse _
                 chr = ","c OrElse _
                 chr = "."c OrElse _
                 chr = "
     End Function
 
     Private Function IsCombiningCharacter(ByVal chr As Char) As Boolean
         'CombiningCharacter 
         Select Case Char.GetUnicodeCategory(chr)
             Case Globalization.UnicodeCategory.NonSpacingMark 'Mn
                 Return True
             Case Globalization.UnicodeCategory.SpacingCombiningMark 'Mc
                 Return True
             Case Else
                 Return False
         End Select
     End Function
 
     Private Function IsFormattingCharacter(ByVal chr As Char) As Boolean
         'FormattingCharacter 
         Return Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.Format 'Cf
     End Function
 
     Private Function IsAlphaCharacter(ByVal chr As Char) As Boolean
         'AlphaCharacter 
         Select Case Char.GetUnicodeCategory(chr) 'Alpha Character
             Case Globalization.UnicodeCategory.UppercaseLetter 'Lu
                 Return True
             Case Globalization.UnicodeCategory.LowercaseLetter 'Ll
                 Return True
             Case Globalization.UnicodeCategory.TitlecaseLetter  'Lt
                 Return True
             Case Globalization.UnicodeCategory.ModifierLetter 'Lm
                 Return True
             Case Globalization.UnicodeCategory.OtherLetter 'Lo
                 Return True
             Case Globalization.UnicodeCategory.LetterNumber 'Nl
                 Return True
             Case Else
                 Return False
         End Select
     End Function
 
     Private Function IsLineContinuation() As Boolean
         If Not (CurrentChar() = " "c AndAlso PeekChar() = "_"c) Then Return False
 
         Dim i As Integer = 2
         Do Until IsNewLine(PeekChars(i))
             If IsWhiteSpace(PeekChars(i)) = False Then Return False
             i += 1
         Loop
 
         Return True
     End Function
 
     Shared Function IsWhiteSpace(ByVal chr As Char) As Boolean
         Return chr = nlTab OrElse Char.GetUnicodeCategory(chr) = Globalization.UnicodeCategory.SpaceSeparator
     End Function
 
     Private Function IsWhiteSpace() As Boolean
         Return IsWhiteSpace(CurrentChar())
     End Function
 
     Private Function IsComment(ByVal chr As Char) As Boolean
         Return chr = COMMENTCHAR1 OrElse chr = COMMENTCHAR2 OrElse chr = COMMENTCHAR3
     End Function
 
     Private Function IsComment() As Boolean
         Return IsComment(CurrentChar)
     End Function
 
     ''' <summary>
     ''' Eat all characters until the newline character(s). Optionally eat the newline character(s) as well
     ''' </summary>
     ''' <param name="NewLineCharAlso"></param>
     ''' <remarks></remarks>
     Private Sub EatLine(ByVal NewLineCharAlso As Boolean)
         'LineTerminator 
         '  < Unicode carriage return character (0x000D) > |
         '  < Unicode line feed character (0x000A) > |
         '  < Unicode carriage return character > < Unicode line feed character > |
         '  < Unicode line separator character (0x2028) > |
         '  < Unicode paragraph separator character (0x2029) >
 
         Dim ch As Char = m_CurrentChar
         Do Until IsNewLine(ch)
             ch = NextChar()
         Loop
 
         If NewLineCharAlso Then
             EatNewLine()
         End If
     End Sub
 
     Private Sub EatNewLine()
         Select Case CurrentChar()
             Case nlD
                 NextChar()
                 If CurrentChar() = nlA Then
                     NextChar()
                 End If
                 IncLine()
             Case nlA, nl2029, nl2028
                 NextChar()
                 IncLine()
             Case nl0
                 IncLine()
             Case Else
                 Throw New InternalException("Current character is not a new line.")
         End Select
     End Sub
 
     Public Shared Function IsSingleNewLine(ByVal chr1 As Char, ByVal chr2 As Char) As Boolean
         Return Not (chr1 = nlD AndAlso chr2 = nlA)
     End Function
 
     Private Sub EatComment()
         Select Case CurrentChar()
             Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'Traditional VB comment
                 EatLine(False) 'do not eat newline, it needs to be added as a token
                 Return
             Case Else
                 REM is taken care of some other place.
                 'Function should never be called if not a comment
                 Throw New InternalException("EatComment called with no comment.")
         End Select
     End Sub
 
     Private Sub EatWhiteSpace()
         While IsWhiteSpace()
             If IsLineContinuation() Then
                 EatLine(True)
             Else
                 NextChar()
             End If
         End While
     End Sub
 
     Private Function GetDate() As Token
         Helper.Assert(CurrentChar() = "#"c, "GetDate called without a date!")
 
         EatWhiteSpace()
 
         Dim Count As Integer
         'Date value
         Dim bCont As Boolean = True
         StringBuilderLength = 0
         Do
             Count += 1
             Dim ch As Char = NextChar()
             If (IsNewLine()) Then
                 Compiler.Report.ShowMessage(Messages.VBNC90000, GetCurrentLocation())
                 bCont = False
             Else
                 Select Case ch
                     Case nl0
                         Compiler.Report.ShowMessage(Messages.VBNC90001, GetCurrentLocation())
                         bCont = False
                     Case "#"c
                         NextChar() 'The ending #
                         bCont = False
                 End Select
             End If
             If bCont Then StringBuilderAppend(ch)
         Loop While bCont
 
         Return Token.CreateDateToken(GetCurrentLocation, CDate(StringBuilderToString))
     End Function
 
     Private Function CanStartIdentifier() As Boolean
         Return CanStartIdentifier(CurrentChar)
     End Function
 
     Private Function CanStartIdentifier(ByVal chr As Char) As Boolean
         Return IsAlphaCharacter(chr) OrElse IsUnderscoreCharacter(chr)
     End Function
 
     Private Function GetEscapedIdentifier() As Token
         'EscapedIdentifier  
         Helper.Assert(CurrentChar() = "["c)
         NextChar()
         Dim id As Token
         id = GetIdentifier(True)
         If CurrentChar() = "]"c = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30034, GetCurrentLocation)
         Else
             NextChar()
         End If
         Return id
     End Function
 
     Private Function GetIdentifier(Optional ByVal Escaped As Boolean = False) As Token
         Dim bValid As Boolean = False
         Dim ch As Char
 
         'Identifier  
         '	NonEscapedIdentifier  [  TypeCharacter  ]  |
         '	Keyword  TypeCharacter  |
         '	EscapedIdentifier
         '
         'NonEscapedIdentifier  
         'EscapedIdentifier  
         '
         'IdentifierName 
 
         'IdentifierStart 
         '   AlphaCharacter |
         '   UnderscoreCharacter IdentifierCharacter 
 
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         StringBuilderLength = 0
 
         ch = CurrentChar()
         StringBuilderAppend(ch)
         If IsAlphaCharacter(ch) Then
             bValid = True
         ElseIf IsUnderscoreCharacter(ch) Then
             ch = NextChar()
             StringBuilderAppend(ch)
             bValid = IsIdentifierCharacter(ch)
         End If
 
         If Not bValid Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, Me.GetCurrentLocation(), CStr(ch))
             Return Nothing
         Else
             Do While IsIdentifierCharacter(NextChar)
                 StringBuilderAppend(CurrentChar)
             Loop
         End If
 
         'The type character ! presents a special problem in that it can be used both as a type character and 
         'as a separator in the language. To remove ambiguity, a ! character is a type character as long as 
         'the character that follows it cannot start an identifier. If it can, then the ! character is a separator, 
         'not a type character.
         Dim typecharacter As TypeCharacters.Characters
         Dim canstartidentifier As Boolean = Me.IsLastChar = False AndAlso (IsAlphaCharacter(PeekChar) OrElse IsUnderscoreCharacter(PeekChar))
         If TypeCharacters.IsTypeCharacter(CurrentChar, typecharacter) AndAlso (canstartidentifier = False OrElse typecharacter <> TypeCharacters.Characters.SingleTypeCharacter) Then
             NextChar()
             m_CurrentTypeCharacter = typecharacter
             Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
         Else
             Dim keyword As KS
             If Escaped = False AndAlso Token.IsKeyword(m_StringBuilder, m_StringBuilderLength, keyword) Then
                 Return Token.CreateKeywordToken(GetCurrentLocation, keyword)
             Else
                 m_CurrentTypeCharacter = typecharacter
                 Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
             End If
         End If
     End Function
 
     Private Function GetString() As Token
         Dim bEndOfString As Boolean = False
         StringBuilderLength = 0
         Do
             Select Case NextChar()
                 Case nl27, nl201C, nl201D
                     'If " followed by a ", output one "
                     Dim nc As Char = NextChar()
                     If nc = nl27 OrElse nc = nl201C OrElse nc = nl201D Then
                         StringBuilderAppend(nc)
                     Else
                         bEndOfString = True
                     End If
                 Case nlA, nlD, nl2028, nl2029
                     Compiler.Report.ShowMessage(Messages.VBNC30648, GetCurrentLocation)
                     bEndOfString = True
                 Case Else
                     If m_EndOfFile Then
                         Compiler.Report.ShowMessage(Messages.VBNC30648, GetCurrentLocation)
                         'PreviousChar() 'Step back
                         bEndOfString = True
                     Else
                         StringBuilderAppend(CurrentChar())
                     End If
 
             End Select
         Loop While bEndOfString = False
         If CurrentChar() = "C"c OrElse CurrentChar() = "c"c Then
             'Is a char type character
             NextChar()
             If StringBuilderLength <> 1 Then
                 Compiler.Report.ShowMessage(Messages.VBNC30004, GetCurrentLocation())
                 Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
             Else
                 Return Token.CreateCharToken(GetCurrentLocation, m_StringBuilder(0))
             End If
         Else
             Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
         End If
     End Function
 
     Private Function GetNumber() As Token
         Dim Base As IntegerBase
         Dim bReal As Boolean
         Dim bE As Boolean
         Static Builder As New Text.StringBuilder
         Builder.Length = 0
 
         'First find the type of the number
         Select Case CurrentChar()
             Case "."c, "0"c To "9"c 'Decimal
                 Base = IntegerBase.Decimal
             Case "&"c
                 Select Case NextChar()
 #If EXTENDED Then
                     Case "b"c, "B"c 'Binary
                         Base = IntegerBase.Binary
 #End If
                     Case "d"c, "D"c 'Decimal
                         Base = IntegerBase.Decimal
                     Case "h"c, "H"c 'Hex
                         Base = IntegerBase.Hex
                     Case "o"c, "O"c 'Octal
                         Base = IntegerBase.Octal
                     Case Else
                         Throw New InternalException(GetCurrentLocation.ToString(Compiler)) 'Should never get here, this function should only be called with the correct specifiers.
                 End Select
                 NextChar()
             Case Else
                 Throw New InternalException("Invalid character
         End Select
 
         Dim ch As Char = CurrentChar()
         ' Then start the parsing
         Select Case Base
             Case IntegerBase.Decimal
                 While Me.IsNumericCharacter(ch)
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
                 If ch = "."c Then
                     If Me.IsNumericCharacter(Me.PeekChar) Then
                         Builder.Append(ch)
                         bReal = True
                         ch = NextChar()
                         While Me.IsNumericCharacter(ch)
                             Builder.Append(ch)
                             ch = NextChar()
                         End While
                     End If
                 End If
                 If ch = "E"c OrElse ch = "e"c Then
                     bE = True
                     bReal = True
                     Builder.Append(ch)
                     ch = NextChar()
                     If ch = "+"c OrElse ch = "-"c Then
                         Builder.Append(ch)
                         ch = NextChar()
                     End If
                     While Me.IsNumericCharacter(ch)
                         Builder.Append(ch)
                         ch = NextChar()
                     End While
                 End If
 #If EXTENDED Then
             Case IntegerBase.Binary
                 While ((ch >= "0"c) AndAlso (ch <= "1"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
 #End If
             Case IntegerBase.Hex
                 While (((ch >= "0"c) AndAlso (ch <= "9"c)) OrElse _
                   ((ch >= "a"c) AndAlso (ch <= "f"c)) OrElse _
                   ((ch >= "A"c) AndAlso (ch <= "F"c)))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case IntegerBase.Octal
                 While ((ch >= "0"c) AndAlso (ch <= "7"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
 
         'Find the type character, if any
         Dim strType As String = ""
         Dim typeOfNumber As BuiltInDataTypes
         Dim typeCharacter As LiteralTypeCharacters_Characters = LiteralTypeCharacters_Characters.None
 
         Dim test As String
         test = CurrentChar()
         If test = "U" OrElse test = "u" Then test &= PeekChar()
         typeCharacter = LiteralTypeCharacters.GetTypeCharacter(test)
         If typeCharacter <> LiteralTypeCharacters_Characters.None Then
             NextChar()
             If test.Length = 2 Then NextChar()
             typeOfNumber = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
         End If
 
         If typeCharacter <> LiteralTypeCharacters_Characters.None AndAlso LiteralTypeCharacters.IsIntegral(typeCharacter) = False AndAlso Base <> IntegerBase.Decimal Then
             Compiler.Report.ShowMessage(Messages.VBNC90002, Me.GetCurrentLocation(), KS.Decimal.ToString)
         End If
 
         ' Found the string of the number
         Dim strResult As String = Builder.ToString
         Dim IntegerValue As ULong
 
         Select Case Base
             Case IntegerBase.Decimal
                 Try
                     Dim tp As BuiltInDataTypes
                     If typeCharacter = LiteralTypeCharacters_Characters.None Then
                         If bReal Then
                             tp = BuiltInDataTypes.Double
                         Else
                             tp = BuiltInDataTypes.Integer
                         End If
                     Else
                         tp = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
                     End If
                     Select Case tp
                         Case BuiltInDataTypes.Decimal
                             GetNumber = Token.CreateDecimalToken(GetCurrentLocation, Decimal.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Double
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, Double.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Single
                             GetNumber = Token.CreateSingleToken(GetCurrentLocation, Single.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Integer, BuiltInDataTypes.Long, BuiltInDataTypes.Short, BuiltInDataTypes.UInteger, BuiltInDataTypes.ULong, BuiltInDataTypes.UShort
                             If bReal Then
                                 Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                                 IntegerValue = 0
                             Else
                                 'Try to parse the result
                                 IntegerValue = ULong.Parse(strResult, Helper.USCulture)
                             End If
                             'Check if value is out of range for data type.
                             Dim bOutOfRange As Boolean
                             'TODO
                             Select Case tp
                                 Case BuiltInDataTypes.Integer
                                     If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Long
                                     If IntegerValue > Long.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Short
                                     If IntegerValue > Short.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UInteger
                                     If IntegerValue > UInteger.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.ULong 'Not necessary
                                     '    If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UShort
                                     If IntegerValue > UShort.MaxValue Then bOutOfRange = True
                                 Case Else
                                     Throw New InternalException("")
                             End Select
                             If bOutOfRange AndAlso typeCharacter <> LiteralTypeCharacters_Characters.None Then
                                 Compiler.Report.ShowMessage(Messages.VBNC30439, GetCurrentLocation(), typeCharacter.ToString)
                             End If
                             GetNumber = GetIntegralToken(ULong.Parse(strResult, Helper.USCulture), Base, typeCharacter)
                         Case Else
                             Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                     End Select
                 Catch ex As System.OverflowException
                     Compiler.Report.ShowMessage(Messages.VBNC30036, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90005, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 End Try
 #If EXTENDED Then
             Case IntegerBase.Binary
                 Try
                     IntegerValue = Helper.BinToInt(strResult)
                     IntegerValue = ConvertNonDecimalBits(IntegerValue, typeCharacter)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, "binary")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
 #End If
             Case IntegerBase.Hex
                 Try
                     'Console.WriteLine("Hex
                     IntegerValue = Helper.HexToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, Me.GetCurrentLocation, "hexadecimal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case IntegerBase.Octal
                 Try
                     IntegerValue = Helper.OctToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, GetCurrentLocation(), "octal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
     End Function
 
     Private Function GetIntegralToken(ByVal Value As ULong, ByVal Base As IntegerBase, ByVal TypeCharacter As LiteralTypeCharacters_Characters) As Token
         Dim case_type As BuiltInDataTypes
         'TODO
         If TypeCharacter = LiteralTypeCharacters_Characters.None Then
             If Value > Integer.MaxValue Then
                 case_type = BuiltInDataTypes.Long
             Else
                 case_type = BuiltInDataTypes.Integer
             End If
         Else
             case_type = LiteralTypeCharacters.GetBuiltInType(TypeCharacter)
         End If
 
         Select Case case_type
             Case BuiltInDataTypes.Integer
                 Return Token.CreateInt32Token(GetCurrentLocation, ExtractInt(Value, Base))
             Case BuiltInDataTypes.UInteger
                 Return Token.CreateUInt32Token(GetCurrentLocation, ExtractUInt(Value, Base))
             Case BuiltInDataTypes.Long
                 Return Token.CreateInt64Token(GetCurrentLocation, ExtractLong(Value, Base))
             Case BuiltInDataTypes.ULong
                 Return Token.CreateUInt64Token(GetCurrentLocation, ExtractULong(Value, Base))
             Case BuiltInDataTypes.Short
                 Return Token.CreateInt16Token(GetCurrentLocation, ExtractShort(Value, Base))
             Case BuiltInDataTypes.UShort
                 Return Token.CreateUInt16Token(GetCurrentLocation, ExtractUShort(Value, Base))
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
 
     Private Function ExtractInt(ByVal Value As ULong, ByVal Base As IntegerBase) As Integer
         Select Case Base
             Case IntegerBase.Decimal
                 Return CInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Integer.MaxValue Then
                     Return CInt(Integer.MinValue + (CUInt(Value) - Integer.MaxValue - 1))
                 Else
                     Return CInt(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractUInt(ByVal Value As ULong, ByVal Base As IntegerBase) As UInteger
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUInt(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractShort(ByVal Value As ULong, ByVal Base As IntegerBase) As Short
         Select Case Base
             Case IntegerBase.Decimal
                 Return CShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Short.MaxValue Then
                     Return CShort(Short.MinValue + (CUShort(Value) - Short.MaxValue - 1))
                 Else
                     Return CShort(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractUShort(ByVal Value As ULong, ByVal Base As IntegerBase) As UShort
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUShort(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractLong(ByVal Value As ULong, ByVal Base As IntegerBase) As Long
         Select Case Base
             Case IntegerBase.Decimal
                 Return CLng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Long.MaxValue Then
                     Return CLng(Long.MinValue + (Value - Long.MaxValue - 1))
                 Else
                     Return CLng(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Private Function ExtractULong(ByVal Value As ULong, ByVal Base As IntegerBase) As ULong
         Select Case Base
             Case IntegerBase.Decimal
                 Return CULng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CULng(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
 
     Function GetCurrentLocation() As Span
         Return New Span(m_CodeFileIndex, m_CurrentLine, m_CurrentColumn)
     End Function
 
     ReadOnly Property CurrentLocation() As Span
         Get
             Return GetCurrentLocation()
         End Get
     End Property
 
     Private ReadOnly Property CurrentChar() As Char
         Get
             Return m_CurrentChar
         End Get
     End Property
 
     Private Function NextChar() As Char
         If m_CurrentColumn < 255 Then m_CurrentColumn += CByte(1)
         m_TotalCharCount += 1
 
         m_PreviousChar = m_CurrentChar
         If m_PeekedChars.Count > 0 Then
             m_CurrentChar = m_PeekedChars.Dequeue
         Else
             If m_Reader.EndOfStream Then
                 m_CurrentChar = nl0
             Else
                 If m_Reader.EndOfStream Then
                     m_EndOfFile = True
                     m_CurrentChar = nl0
                 Else
                     m_CurrentChar = Convert.ToChar(m_Reader.Read())
                 End If
             End If
         End If
 
         Return m_CurrentChar
     End Function
 
     Private ReadOnly Property PreviousChar() As Char
         Get
             Return m_PreviousChar
         End Get
     End Property
 
     Private Function PeekChar() As Char
         If m_PeekedChars.Count = 0 Then
             If m_Reader.EndOfStream Then Return nl0
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         End If
         Return m_PeekedChars.Peek()
     End Function
 
     Private Function PeekChars(ByVal Chars As Integer) As Char
         Do Until m_PeekedChars.Count >= Chars
             If m_Reader.EndOfStream Then Return nlA
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         Loop
         Return m_PeekedChars.ToArray()(Chars - 1)
     End Function
 
     ''' <summary>
     ''' Returns true if the current character is the last character in the scanner.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function IsLastChar() As Boolean
         Return m_Reader.EndOfStream
     End Function
 
     ''' <summary>
     ''' Next line!
     ''' </summary>
     ''' <remarks></remarks>
     Private Sub IncLine()
         m_CurrentLine += 1UI
         m_CurrentColumn = 1
         m_TokensSeenOnLine = 0
     End Sub
 
     ''' <summary>
     ''' Creates a new symbol token of the specified symbol.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function NewToken(ByVal Symbol As KS) As Token
         Return Token.CreateSymbolToken(GetCurrentLocation, Symbol)
     End Function
 
     Private Function GetNextToken() As Token
         Dim Result As Token = Nothing
         Do
             Select Case CurrentChar()
                 Case nl27, nl201C, nl201D 'String Literal
                     Result = GetString()
                 Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'VB Comment
                     EatComment()
                 Case nlD, nlA, nl2028, nl2029 'New line
 
                     'Keep the current line of the end of line token to the current line so we get better
                     'location info for errors and warnings
                     Result = Token.CreateEndOfLineToken(GetCurrentLocation)
                     EatNewLine()
 
                 Case nl0 'End of file
                     Result = Token.CreateEndOfFileToken(GetCurrentLocation)
                 Case "
                     NextChar()
                     Result = NewToken(KS.Colon)
                 Case ","c ',
                     NextChar()
                     Result = NewToken(KS.Comma)
                 Case "."c
                     If PeekChar() >= "0"c AndAlso PeekChar() <= "9"c Then
                         Result = GetNumber()
                     Else
                         NextChar()
                         Result = NewToken(KS.Dot)
                     End If
                 Case "0"c To "9"c
                     Result = GetNumber()
                 Case "("c
                     NextChar()
                     Result = NewToken(KS.LParenthesis)
                 Case ")"c
                     NextChar()
                     Result = NewToken(KS.RParenthesis)
                 Case "["c
                     Result = GetEscapedIdentifier()
                 Case "{"c
                     NextChar()
                     Result = NewToken(KS.LBrace)
                 Case "}"c
                     NextChar()
                     Result = NewToken(KS.RBrace)
                 Case ">"c
                     NextChar()
                     EatWhiteSpace()
                     'If CurrentChar() = "<"c Then
                     '    NextChar()
                     '    Result = NewToken(KS.NotEqual)
                     'Else
                     If CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.GE)
                     ElseIf CurrentChar() = ">"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftRightAssign)
                         Else
                             Result = NewToken(KS.ShiftRight)
                         End If
                     Else
                         Result = NewToken(KS.GT)
                     End If
                 Case "<"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = ">"c) Then
                         NextChar()
                         Result = NewToken(KS.NotEqual)
                     ElseIf CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.LE)
                     ElseIf CurrentChar() = "<"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftLeftAssign)
                         Else
                             Result = NewToken(KS.ShiftLeft)
                         End If
                     Else
                         Result = NewToken(KS.LT)
                     End If
                 Case "="c
                     NextChar()
                     Result = NewToken(KS.Equals)
                 Case "!"c
                     NextChar()
                     Result = NewToken(KS.Exclamation)
                 Case "?"c
                     NextChar()
                     Result = NewToken(KS.Interrogation)
                 Case "&"c
                     Select Case PeekChar()
 #If EXTENDED Then
                         Case "b"c, "B"c, "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #Else
                         Case "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #End If
                             Result = GetNumber()
                         Case Else 'Not a number, but operator
                             NextChar()
                             EatWhiteSpace()
                             If CurrentChar() = "="c Then
                                 Result = NewToken(KS.ConcatAssign)
                                 NextChar()
                             Else
                                 Result = NewToken(KS.Concat)
                             End If
                     End Select
                 Case "*"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MultAssign)
                     Else
                         Result = NewToken(KS.Mult)
                     End If
                 Case "+"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.AddAssign)
                     Else
                         Result = NewToken(KS.Add)
                     End If
                 Case "-"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MinusAssign)
                     Else
                         Result = NewToken(KS.Minus)
                     End If
                 Case "^"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.PowerAssign)
                     Else
                         Result = NewToken(KS.Power)
                     End If
                 Case "\"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.IntDivAssign)
                     Else
                         Result = NewToken(KS.IntDivision)
                     End If
                 Case "#"c
                     'Type characters are already scanned when they appear after a literal. 
                     'If scanning gets here, it is not a type character.
                     If m_TokensSeenOnLine = 0 Then
                         Result = NewToken(KS.Numeral)
                         NextChar()
                     Else
                         Result = GetDate()
                     End If
                 Case "/"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.RealDivAssign)
                     Else
                         Result = NewToken(KS.RealDivision)
                     End If
                 Case " "c 'Space
                     NextChar()
                     If (CurrentChar() = "_"c) Then '
                         Dim i As Integer = 1
                         Do While IsWhiteSpace(PeekChars(i))
                             i += 1
                         Loop
                         If IsNewLine(PeekChars(i)) Then
                             NextChar()
                             EatWhiteSpace()
                             EatNewLine()
                         End If
                     End If
                 Case nlTab ' Tab character
                     NextChar()
                 Case Else
                     If IsWhiteSpace() Then
                         NextChar()
                     ElseIf CanStartIdentifier() Then
                         Result = GetIdentifier()
                         If Result.IsKeyword AndAlso Result.Equals(KS.[REM]) Then
                             EatLine(False)
                             Result = Nothing
                         End If
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30037, GetCurrentLocation())
                         EatLine(False)
                     End If
             End Select
         Loop While Token.IsSomething(Result) = False
 
         If Result.IsEndOfLine = False Then
             m_TokensSeenOnLine += 1
         Else
             m_TokensSeenOnLine = 0
         End If
 
         Return Result
     End Function
 
     Public Sub New(ByVal Compiler As Compiler)
         MyBase.New(Compiler)
         m_Files = New Generic.Queue(Of CodeFile)(Compiler.CommandLine.Files)
         NextFile()
         LoadProjectConstants()
     End Sub
 
     Public Sub New(ByVal Compiler As Compiler, ByVal Code As String)
         MyBase.New(Compiler)
         m_Files = New Generic.Queue(Of CodeFile)()
         Dim cf As New CodeFile("<Internal>", "", Compiler, Code)
         m_Files.Enqueue(cf)
         Compiler.CommandLine.Files.Add(cf)
         NextFile()
         LoadProjectConstants()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="360" endline="372">
<![CDATA[
 
     ''' <summary>
     ''' A variable declaration which refers to the implicitly declared local variable
     ''' for methods with return values (functions and get properties)
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="method"></param>
     ''' <remarks></remarks>
     Sub New(ByVal Parent As ParsedObject, ByVal method As IMethod)
         MyBase.New(Classifications.Variable, Parent)
         Helper.Assert(TypeOf method Is FunctionDeclaration OrElse TypeOf method Is PropertyGetDeclaration)
         m_Method = method
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="89" endline="97">
<![CDATA[
 
     Function Resolve(ByVal DelegateType As Mono.Cecil.TypeReference, ByVal ShowErrors As Boolean) As Boolean
         Dim result As Boolean = True
 
         result = Classification.AsMethodPointerClassification.Resolve(DelegateType, ShowErrors) AndAlso result
         m_ExpressionType = DelegateType
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="40" endline="46">
<![CDATA[
     End Property
 
     Public Sub New(ByVal Compiler As Compiler)
     Private m_ShowErrors As Boolean = True
 
     Private ReadOnly Property ShowErrors() As Boolean
         Get
             Return m_ShowErrors
         End Get
     End Property
 
     Public ReadOnly Property Compiler() As Compiler
         Get
             Return m_Compiler
         End Get
     End Property
 
     Public Sub New(ByVal Compiler As Compiler)
         m_Compiler = Compiler
         tm = m_Compiler.tm
         Helper.Assert(tm IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="48" endline="59">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         m_Destination = Me.FindFirstParent(Of CodeBlock).FindLabel(m_GotoWhere)
         If m_Destination Is Nothing Then
             result = false
             Report.ShowMessage(Messages.VBNC30132, Me.Location, m_GotoWhere.Identifier)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="40" endline="47">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitBranchOrLeave(Info, m_Destination.GetLabel(Info), Me, m_Destination)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\AbstractMediaHandler.vb" startline="77" endline="83">
<![CDATA[
         Set(ByVal Value As String)
             If Len(mOptions.Item(Key)) = 0 Then
                 mOptions.Add(Key, Value)
             Else
                 mOptions.Item(Key) = Value
             End If
         End Set
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\VoidClassification.vb" startline="38" endline="45">
<![CDATA[
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         If m_Value IsNot Nothing Then
             Classification = New ValueClassification(Me, m_ExpressionType, m_Value)
         Else
             Classification = New ValueClassification(Me, m_ExpressionType, DBNull.Value)
         End If
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="884" endline="892">
<![CDATA[
 
 
     Shared Sub EmitConstrained(ByVal Info As EmitInfo, ByVal Type As Mono.Cecil.TypeReference)
         Dim OriginalType As Mono.Cecil.TypeReference = Type
 
         Type = Helper.GetTypeOrTypeBuilder(Info.Compiler, Type)
 
         Info.ILGen.Emit(OpCodes.Constrained, Type)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1900" endline="1910">
<![CDATA[
 
     ''' <summary>
     ''' Emits a box instruction, no checks are done.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <remarks></remarks>
     Shared Sub EmitBox(ByVal Info As EmitInfo, ByVal SourceType As Mono.Cecil.TypeReference)
         Dim OriginalDestinationType As Mono.Cecil.TypeReference = SourceType
         SourceType = Helper.GetTypeOrTypeBuilder(Info.Compiler, SourceType)
         Info.ILGen.Emit(OpCodes.Box, SourceType)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CodeFiles.vb" startline="684" endline="693">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' /codepage
     ''' </summary>
     ReadOnly Property Encoding() As System.Text.Encoding
         Get
             If m_Encoding Is Nothing Then m_Encoding = System.Text.Encoding.Default
             Return m_Encoding
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="70" endline="87">
<![CDATA[
 
     Sub Init(ByVal ArrayType As Mono.Cecil.TypeReference, ByVal ArrayBounds() As Expression, ByVal InitializerElements As Expression())
         m_ExpressionType = ArrayType
 
         If ArrayBounds IsNot Nothing Then
             m_ArrayNameModifier = New ArrayNameModifier(Me)
             Dim newSizes As New ArraySizeInitializationModifier(Me)
             Dim bounds As New BoundList(newSizes)
             bounds.Init(ArrayBounds)
             newSizes.Init(bounds, Nothing)
             m_ArrayNameModifier.Init(newSizes)
         End If
 
         If InitializerElements IsNot Nothing Then
             m_ArrayElementInitializer = New ArrayElementInitializer(Me)
             m_ArrayElementInitializer.Init(InitializerElements)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\OptionStrictStatement.vb" startline="102" endline="111">
<![CDATA[
 
     Private Function GenerateCodeForPreserve(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         result = m_Expression.GenerateCode(Info.Clone(Me, True, False, m_ArrayType)) AndAlso result
         Emitter.EmitCastClass(Info, Compiler.TypeCache.System_Array)
         result = GenerateCodeForNewArray(Info) AndAlso result
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Utils__CopyArray_Array_Array)
         Emitter.EmitCastClass(Info, m_ArrayType)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="461" endline="478">
<![CDATA[
 
     Protected Shared Function GenerateCodeForExpression(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo, ByRef expTypeCode As TypeCode, ByRef expType As TypeReference) As Boolean
         Dim result As Boolean = True
         Dim Expression As Expression = Conversion.Expression
 
         expType = Expression.ExpressionType
 
         result = Expression.Classification.GenerateCode(Info.Clone(Expression, expType)) AndAlso result
 
         If Conversion.ConversionMethod IsNot Nothing Then
             Emitter.EmitCall(Info, Conversion.ConversionMethod)
             expType = Conversion.ConversionMethod.ReturnType
         End If
 
         expTypeCode = Helper.GetTypeCode(Info.Compiler, expType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="64" endline="75">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Signature As SubSignature, ByVal Block As CodeBlock)
 
         'If vbnc.Modifiers.IsNothing(Modifiers) = False AndAlso Modifiers.Is(ModifierMasks.Shared) Then
         If Modifiers.Is(ModifierMasks.Shared) OrElse FindTypeParent.IsModule Then
             Signature.Init(New Identifier(Signature, SharedConstructorName, Signature.Location, TypeCharacters.Characters.None), Signature.TypeParameters, Signature.Parameters)
         Else
             Signature.Init(New Identifier(Signature, ConstructorName, Signature.Location, TypeCharacters.Characters.None), Signature.TypeParameters, Signature.Parameters)
         End If
 
         MyBase.Init(Modifiers, Signature, Block)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="189" endline="204">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns nothing if the resolved method isn't a methodinfo.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property ResolvedMethodInfo() As Mono.Cecil.MethodReference
         Get
             If SuccessfullyResolved = False Then Throw New InternalException(Me)
             If TypeOf m_Group(0) Is Mono.Cecil.MethodReference Then
                 Return DirectCast(m_Group(0), Mono.Cecil.MethodReference)
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="196" endline="202">
<![CDATA[
 
     Sub New(ByVal Classification As PropertyGroupClassification)
         Me.new(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="203" endline="209">
<![CDATA[
 
     Sub New(ByVal Classification As MethodGroupClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="210" endline="216">
<![CDATA[
 
     Sub New(ByVal Classification As MethodPointerClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="217" endline="223">
<![CDATA[
 
     Sub New(ByVal Classification As LateBoundAccessClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="224" endline="230">
<![CDATA[
 
     Sub New(ByVal Classification As PropertyAccessClassification)
         Me.New(Classification.Parent)
         m_Classification = Classification
         m_Type = Classification.Type
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="33" endline="39">
<![CDATA[
 
     Function GetTypes(ByVal [Namespace] As String) As TypeDictionary
         If Me.ContainsKey([Namespace]) = False Then
             Return Me.AddNamespace([Namespace])
         End If
         Return MyBase.Item([Namespace])
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="364" endline="371">
<![CDATA[
 
     Shared Sub EmitIsInst(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference, ByVal ToType As Mono.Cecil.TypeReference)
         Dim toOriginal As Mono.Cecil.TypeReference = ToType
 
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
         ToType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ToType)
         Info.ILGen.Emit(OpCodes.Isinst, ToType)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="86" endline="96">
<![CDATA[
 
     Sub Init(ByVal Attributes As Attributes)
         If m_Attributes Is Nothing Then
             m_Attributes = Attributes
         Else
             m_Attributes.AddRange(Attributes)
         End If
         m_TypeDeclarations = m_Members.GetSpecificMembers(Of TypeDeclaration).ToArray
 
         Helper.Assert(m_Members.Count = m_TypeDeclarations.Length)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="910" endline="929">
<![CDATA[
 
     ''' <summary>
     ''' Emits a callvirt instructions. 
     ''' Throws an exception if the method is a shared method.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Method"></param>
     ''' <remarks></remarks>
     Shared Sub EmitCallVirt(ByVal Info As EmitInfo, ByVal Method As Mono.Cecil.MethodReference)
         Dim OriginalMethod As Mono.Cecil.MethodReference = Method
         Dim mD As Mono.Cecil.MethodDefinition = CecilHelper.FindDefinition(Method)
 
         If mD IsNot Nothing Then
             Method = Helper.GetMethodOrMethodReference(Info.Compiler, Method)
             Method = SwitchVersionedMethods(Info, Method)
             Method = CecilHelper.MakeEmittable(Method)
         End If
 
         Info.ILGen.EmitCall(OpCodes.Callvirt, Method, Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\BaseObject.vb" startline="71" endline="88">
<![CDATA[
 
     ''' <summary>
     ''' Create a new base object with the specified Parent.
     ''' </summary>
     Protected Sub New(ByVal Parent As BaseObject, ByVal Location As Span)
         m_Parent = Parent
         Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         m_Location = Location
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
 
     Public Shared Sub ClearCache()
         m_Compiler = Nothing
     End Sub
 
     ''' <summary>
     ''' The location in the source of this object.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Friend Property Location() As Span Implements IBaseObject.Location
         Get
             If m_Location.HasFile = False AndAlso m_Location.Column = 0 AndAlso m_Location.Line = 0 AndAlso m_Parent IsNot Nothing Then
                 Return m_Parent.Location
             End If
             Return m_Location
         End Get
         Set(ByVal value As Span)
             m_Location = value
         End Set
     End Property
 
     ReadOnly Property File() As CodeFile
         Get
             Return Location.File(Compiler)
         End Get
     End Property
 
     Overridable ReadOnly Property FullName() As String Implements IBaseObject.FullName
         Get
             Dim nameable As INameable = TryCast(Me, INameable)
             Helper.Assert(nameable IsNot Nothing)
             Dim nstpparent As IBaseObject = Me.FindFirstParent(Of IType)()
             If TypeOf Me Is TypeParameter Then Return Nothing
             If nstpparent IsNot Nothing Then
                 If TypeOf nstpparent Is IType Then
                     Return nstpparent.FullName & "+" & nameable.Name
                 Else
                     Return nstpparent.FullName & "." & nameable.Name
                 End If
             Else
                 Return nameable.Name
             End If
         End Get
     End Property
 
     Friend Function FindTypeParent() As TypeDeclaration
         Return Me.FindFirstParent(Of TypeDeclaration)()
     End Function
 
     Friend Function FindMethod() As IBaseObject
         Dim found As IBaseObject
         found = FindFirstParent(Of IMethod)()
         If found Is Nothing Then found = FindFirstParent(Of PropertyDeclaration)()
         Return found
     End Function
 
     Function FindFirstParent_IType() As IType
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is IType Then
             Return CType(CObj(Parent), IType)
         Else
             Return Parent.FindFirstParent(Of IType)()
         End If
     End Function
 
     Function FindFirstParent(Of T)() As T
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T Then
             Return CType(CObj(Parent), T)
         Else
             Return Parent.FindFirstParent(Of T)()
         End If
     End Function
 
     Function FindFirstParent(Of T1, T2)() As IBaseObject
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T1 Then
             Return CType(CObj(Parent), IBaseObject)
         ElseIf TypeOf Parent Is T2 Then
             Return CType(CObj(Parent), IBaseObject)
         Else
             Return Parent.FindFirstParent(Of T1, T2)()
         End If
     End Function
 
     ''' <summary>
     ''' The parent of this type. Is nothing if this type is an assembly.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Public Property Parent() As BaseObject Implements IBaseObject.Parent
         Get
             Return m_Parent
         End Get
         Set(ByVal value As BaseObject)
             m_Parent = value
             Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         End Set
     End Property
 
     ReadOnly Property ParentAsParsedObject() As ParsedObject
         Get
             Return DirectCast(Me.Parent, ParsedObject)
         End Get
     End Property
 
     ''' <summary>
     ''' Get the current compiling assembly.
     ''' </summary>
     Friend Overridable ReadOnly Property Assembly() As AssemblyDeclaration Implements IBaseObject.Assembly
         Get
             If TypeOf Me Is AssemblyDeclaration Then
                 Return DirectCast(Me, AssemblyDeclaration)
             ElseIf TypeOf Me Is Compiler Then
                 Return DirectCast(Me, Compiler).theAss
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 Return m_Parent.Assembly
             End If
         End Get
     End Property
 
     Friend ReadOnly Property Report() As Report
         Get
             Return Compiler.Report
         End Get
     End Property
 
     ''' <summary>
     ''' Get the compiler compiling right now.
     ''' </summary>
     Overridable ReadOnly Property Compiler() As Compiler Implements IBaseObject.Compiler
         Get
             If m_Compiler IsNot Nothing Then
                 Return m_Compiler
             End If
 
             If TypeOf m_Parent Is Compiler Then
                 m_Compiler = DirectCast(m_Parent, Compiler)
             ElseIf TypeOf Me Is Compiler Then
                 m_Compiler = DirectCast(Me, vbnc.Compiler)
             ElseIf m_Parent Is Nothing Then
                 Return Nothing
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 m_Compiler = m_Parent.Compiler
             End If
 
             Return m_Compiler
         End Get
     End Property
 
 #If DEBUG Then
     ReadOnly Property ParentTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 result.Add(tmp.GetType.Name)
                 tmp = tmp.Parent
             Loop
 
             Return result.ToArray
         End Get
     End Property
     ReadOnly Property ParentLocationTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 'If tmp.HasLocation = False Then
                 '    result &= "(" & tmp.GetType.Name & ")
                 'Else
                 result.Add("(" & tmp.GetType.Name & ")
                 'End If
                 tmp = tmp.Parent
             Loop
 
             Return result.toarray
         End Get
     End Property
 #End If
 
     ''' <summary>
     ''' Get the token manager used for quick token management.
     ''' </summary>
     Friend Overridable ReadOnly Property tm() As tm
         Get
             Helper.Assert(Compiler IsNot Nothing)
             Return Compiler.tm
         End Get
     End Property
 
     Overridable Function ResolveCode(ByVal Info As ResolveInfo) As Boolean Implements IBaseObject.ResolveCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveInfo ignored for '" & Me.GetType.ToString & "'")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         'Return ResolveCode()
     End Function
 
     Friend Overridable Function GenerateCode(ByVal Info As EmitInfo) As Boolean Implements IBaseObject.GenerateCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement GenerateCode()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
 
     Public ReadOnly Property IsOptionInferOn As Boolean
         Get
             Return Location.File(Compiler).IsOptionInferOn
         End Get
     End Property
 
     ''' <summary>
     ''' Define = create a builder for the object.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Obsolete("Throws NotImplementedException() - The class you are using does not override this method!")> _
     Overridable Function Define() As Boolean Implements IBaseObject.Define
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement Define()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
 
     Private m_ObjectID As Integer = NewID()
         m_Parent = Parent
         Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         m_Location = Location
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\StdToolMgr.vb" startline="498" endline="521">
<![CDATA[
 
 #End Region
 
 #Region "   Slider drag and click "
 
     '============ Drag the Slider ==============
     Private Sub lplaypos_MouseDown(ByVal sender As Object, _
     ByVal e As System.Windows.Forms.MouseEventArgs) Handles lplayPos.MouseDown
         'if clicked inside the box
         If (e.X > mSliderPos) And (e.X < mSliderPos + mSliderW) Then
             mDragOn = True
             mMousePos = e.X
             mSliderSrt = mSliderPos
             Timer.Enabled = False
         Else
             Dim NewCurrPosition As Double
             NewCurrPosition = e.X * mPlayer.currentMedia.duration _
             / lplayPos.Width
             'If (NewCurrPosition > 0) And _
             '    (NewCurrPosition < mPlayer.currentMedia.duration) Then
             RaiseEvent SliderMoved(NewCurrPosition)
             'End If
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="442" endline="460">
<![CDATA[
 
     Protected Shared Function ValidateForNullable(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression, ByRef expTypeCode As TypeCode, ByRef expType As TypeReference) As Boolean
         Dim result As Boolean = True
         Dim ConversionMethod As MethodReference = Nothing
 
         expType = Conversion.Expression.ExpressionType
 
         If CecilHelper.IsNullable(expType) Then
             If SelectNarrowingConversionOperator(Info.Compiler, expType, Conversion.ExpressionType, ConversionMethod) = False Then
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Conversion.Expression.Location)
             End If
             expType = CecilHelper.GetNulledType(expType)
             Conversion.ConversionMethod = ConversionMethod
         End If
 
         expTypeCode = Helper.GetTypeCode(Info.Compiler, expType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="90" endline="104">
<![CDATA[
 
     Public Overrides Function CreateDefinition() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.CreateDefinition AndAlso result
 
         Helper.Assert(m_FieldBuilderCecil Is Nothing)
         m_FieldBuilderCecil = New Mono.Cecil.FieldDefinition(Name, Helper.GetAttributes(Compiler, Me), Helper.GetTypeOrTypeReference(Compiler, FieldType))
         DeclaringType.CecilType.Fields.Add(m_FieldBuilderCecil)
         m_FieldBuilderCecil.Attributes = Helper.GetAttributes(Compiler, Me)
         m_FieldBuilderCecil.Name = Name
         m_FieldBuilderCecil.IsStatic = Me.IsShared
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="62" endline="78">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         EndLabel = Emitter.DefineLabel(Info)
         m_NextIteration = Emitter.DefineLabel(Info)
 
         Emitter.MarkLabel(Info, m_NextIteration)
         result = m_Condition.GenerateCode(Info.Clone(Me, True, , Compiler.TypeCache.System_Boolean)) AndAlso result
         Emitter.EmitBranchIfFalse(Info, EndLabel)
         result = CodeBlock.GenerateCode(Info) AndAlso result
         Emitter.EmitBranch(Info, m_NextIteration)
         Emitter.MarkLabel(Info, EndLabel)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\AssignStatements\AddAssignStatement.vb" startline="145" endline="152">
<![CDATA[
 
     Overridable Function CreateTypeConversion() As Boolean
         Dim result As Boolean = True
 
         m_RSide = Helper.CreateTypeConversion(Me, m_RSide, m_LSide.ExpressionType, result)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\BaseObject.vb" startline="53" endline="70">
<![CDATA[
 
     ''' <summary>
     ''' Create a new base object with the specified Parent.
     ''' </summary>
     Protected Sub New(ByVal Parent As BaseObject)
         m_Parent = Parent
         'Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         If m_Parent IsNot Nothing AndAlso tm IsNot Nothing AndAlso tm.IsCurrentTokenValid Then m_Location = tm.CurrentLocation
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
 
     ''' <summary>
     ''' Create a new base object with the specified Parent.
     ''' </summary>
     Protected Sub New(ByVal Parent As BaseObject, ByVal Location As Span)
         m_Parent = Parent
         Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         m_Location = Location
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
 
     Public Shared Sub ClearCache()
         m_Compiler = Nothing
     End Sub
 
     ''' <summary>
     ''' The location in the source of this object.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Friend Property Location() As Span Implements IBaseObject.Location
         Get
             If m_Location.HasFile = False AndAlso m_Location.Column = 0 AndAlso m_Location.Line = 0 AndAlso m_Parent IsNot Nothing Then
                 Return m_Parent.Location
             End If
             Return m_Location
         End Get
         Set(ByVal value As Span)
             m_Location = value
         End Set
     End Property
 
     ReadOnly Property File() As CodeFile
         Get
             Return Location.File(Compiler)
         End Get
     End Property
 
     Overridable ReadOnly Property FullName() As String Implements IBaseObject.FullName
         Get
             Dim nameable As INameable = TryCast(Me, INameable)
             Helper.Assert(nameable IsNot Nothing)
             Dim nstpparent As IBaseObject = Me.FindFirstParent(Of IType)()
             If TypeOf Me Is TypeParameter Then Return Nothing
             If nstpparent IsNot Nothing Then
                 If TypeOf nstpparent Is IType Then
                     Return nstpparent.FullName & "+" & nameable.Name
                 Else
                     Return nstpparent.FullName & "." & nameable.Name
                 End If
             Else
                 Return nameable.Name
             End If
         End Get
     End Property
 
     Friend Function FindTypeParent() As TypeDeclaration
         Return Me.FindFirstParent(Of TypeDeclaration)()
     End Function
 
     Friend Function FindMethod() As IBaseObject
         Dim found As IBaseObject
         found = FindFirstParent(Of IMethod)()
         If found Is Nothing Then found = FindFirstParent(Of PropertyDeclaration)()
         Return found
     End Function
 
     Function FindFirstParent_IType() As IType
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is IType Then
             Return CType(CObj(Parent), IType)
         Else
             Return Parent.FindFirstParent(Of IType)()
         End If
     End Function
 
     Function FindFirstParent(Of T)() As T
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T Then
             Return CType(CObj(Parent), T)
         Else
             Return Parent.FindFirstParent(Of T)()
         End If
     End Function
 
     Function FindFirstParent(Of T1, T2)() As IBaseObject
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T1 Then
             Return CType(CObj(Parent), IBaseObject)
         ElseIf TypeOf Parent Is T2 Then
             Return CType(CObj(Parent), IBaseObject)
         Else
             Return Parent.FindFirstParent(Of T1, T2)()
         End If
     End Function
 
     ''' <summary>
     ''' The parent of this type. Is nothing if this type is an assembly.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Public Property Parent() As BaseObject Implements IBaseObject.Parent
         Get
             Return m_Parent
         End Get
         Set(ByVal value As BaseObject)
             m_Parent = value
             Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         End Set
     End Property
 
     ReadOnly Property ParentAsParsedObject() As ParsedObject
         Get
             Return DirectCast(Me.Parent, ParsedObject)
         End Get
     End Property
 
     ''' <summary>
     ''' Get the current compiling assembly.
     ''' </summary>
     Friend Overridable ReadOnly Property Assembly() As AssemblyDeclaration Implements IBaseObject.Assembly
         Get
             If TypeOf Me Is AssemblyDeclaration Then
                 Return DirectCast(Me, AssemblyDeclaration)
             ElseIf TypeOf Me Is Compiler Then
                 Return DirectCast(Me, Compiler).theAss
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 Return m_Parent.Assembly
             End If
         End Get
     End Property
 
     Friend ReadOnly Property Report() As Report
         Get
             Return Compiler.Report
         End Get
     End Property
 
     ''' <summary>
     ''' Get the compiler compiling right now.
     ''' </summary>
     Overridable ReadOnly Property Compiler() As Compiler Implements IBaseObject.Compiler
         Get
             If m_Compiler IsNot Nothing Then
                 Return m_Compiler
             End If
 
             If TypeOf m_Parent Is Compiler Then
                 m_Compiler = DirectCast(m_Parent, Compiler)
             ElseIf TypeOf Me Is Compiler Then
                 m_Compiler = DirectCast(Me, vbnc.Compiler)
             ElseIf m_Parent Is Nothing Then
                 Return Nothing
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 m_Compiler = m_Parent.Compiler
             End If
 
             Return m_Compiler
         End Get
     End Property
 
 #If DEBUG Then
     ReadOnly Property ParentTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 result.Add(tmp.GetType.Name)
                 tmp = tmp.Parent
             Loop
 
             Return result.ToArray
         End Get
     End Property
     ReadOnly Property ParentLocationTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 'If tmp.HasLocation = False Then
                 '    result &= "(" & tmp.GetType.Name & ")
                 'Else
                 result.Add("(" & tmp.GetType.Name & ")
                 'End If
                 tmp = tmp.Parent
             Loop
 
             Return result.toarray
         End Get
     End Property
 #End If
 
     ''' <summary>
     ''' Get the token manager used for quick token management.
     ''' </summary>
     Friend Overridable ReadOnly Property tm() As tm
         Get
             Helper.Assert(Compiler IsNot Nothing)
             Return Compiler.tm
         End Get
     End Property
 
     Overridable Function ResolveCode(ByVal Info As ResolveInfo) As Boolean Implements IBaseObject.ResolveCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveInfo ignored for '" & Me.GetType.ToString & "'")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         'Return ResolveCode()
     End Function
 
     Friend Overridable Function GenerateCode(ByVal Info As EmitInfo) As Boolean Implements IBaseObject.GenerateCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement GenerateCode()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
 
     Public ReadOnly Property IsOptionInferOn As Boolean
         Get
             Return Location.File(Compiler).IsOptionInferOn
         End Get
     End Property
 
     ''' <summary>
     ''' Define = create a builder for the object.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Obsolete("Throws NotImplementedException() - The class you are using does not override this method!")> _
     Overridable Function Define() As Boolean Implements IBaseObject.Define
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement Define()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
 
     Private m_ObjectID As Integer = NewID()
         m_Parent = Parent
         'Helper.Assert(Not (TypeOf m_Parent Is ClassDeclaration AndAlso TypeOf Me Is FunctionSignature))
         If m_Parent IsNot Nothing AndAlso tm IsNot Nothing AndAlso tm.IsCurrentTokenValid Then m_Location = tm.CurrentLocation
 #If DEBUG Then
         Helper.Assert(Parent IsNot Me)
         'Make sure there aren't any circular references.
         Dim tmp As IBaseObject = Parent
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
         Do While tmp IsNot Nothing
             tmp = tmp.Parent
             Helper.Assert(tmp IsNot Me)
         Loop
 #End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1572" endline="1591">
<![CDATA[
 
     Shared Function ApplyTypeArguments(ByVal Parent As ParsedObject, ByVal OpenParameter As Mono.Cecil.ParameterReference, ByVal TypeParameters As Mono.Collections.Generic.Collection(Of TypeReference), ByVal TypeArguments As Mono.Collections.Generic.Collection(Of TypeReference)) As Mono.Cecil.ParameterReference
         Dim result As Mono.Cecil.ParameterReference
 
         Helper.Assert(TypeParameters IsNot Nothing AndAlso TypeArguments IsNot Nothing)
         Helper.Assert(TypeParameters.Count = TypeArguments.Count)
 
         Dim paramType As Mono.Cecil.TypeReference
         paramType = ApplyTypeArguments(Parent, OpenParameter.ParameterType, TypeParameters, TypeArguments)
 
         If paramType Is OpenParameter.ParameterType Then
             result = OpenParameter
         Else
             result = Parent.Compiler.TypeManager.MakeGenericParameter(Parent, OpenParameter, paramType)
         End If
 
         Helper.Assert(result IsNot Nothing)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\StdToolMgr.vb" startline="177" endline="192">
<![CDATA[
 
     Private Sub CalculateValues()
 
         Dim curLeft As Double = (picSlider.Left + (picSlider.Width / 2)) - grpBar.Left
 
         mValue = CSng(((curLeft / grpBar.Width) * (mMax - mMin)) + mMin)
 
         If picSlider.Left = 0 Then
             mValue = mMin
         End If
 
         If mValue > mMax Then
             mValue = mMax
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="58" endline="74">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_WithExpression Is m_WithVariableExpression = False Then
             m_WithVariable = Emitter.DeclareLocal(Info, Helper.GetTypeOrTypeBuilder(Compiler, m_WithExpression.ExpressionType), "WithVariable" & Me.ObjectID.ToString)
             result = m_WithExpression.GenerateCode(Info.Clone(Me, True, False, m_WithVariable.VariableType)) AndAlso result
             Emitter.EmitStoreVariable(Info, m_WithVariable)
         End If
 
         result = CodeBlock.GenerateCode(Info) AndAlso result
 
         Emitter.FreeLocal(m_WithVariable)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CodeFiles.vb" startline="797" endline="810">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Create a new commandline parser!
     ''' </summary>
     ''' <remarks></remarks>
     Sub New(ByVal Compiler As Compiler)
     Private m_lstResponseFiles As New Specialized.StringCollection
 
     ''' <summary>
     ''' All files specified
     ''' </summary>s
     ''' <remarks></remarks>
     Private m_lstFileNames As CodeFiles
 
     ''' <summary>
     ''' A list of all the arguments parsed.
     ''' </summary>
     ''' <remarks></remarks>
     Private m_lstAllArgs As New Specialized.StringCollection
 
     ''' <summary>
     ''' The compiler used.
     ''' </summary>
     Private m_Compiler As Compiler
 
     ''' <summary>
     ''' The compiler used.
     ''' </summary>
     ReadOnly Property Compiler() As Compiler
         Get
             Return m_Compiler
         End Get
     End Property
 
 #Region "Properties"
 
     ' - OUTPUT FILE -
 
     ''' <summary>
     ''' /out
     ''' </summary>
     Private m_strOut As String
 
     ''' <summary>
     ''' /target
     ''' /target
     ''' /target
     ''' /target
     ''' </summary>
     Private m_strTarget As Targets
 
     ''' <summary>
     ''' /doc[+|-]               Generates XML documentation file.
     ''' /doc
     ''' </summary>
     ''' <remarks></remarks>
     Private m_strDoc As String
 
     ' - INPUT FILES -
 
     ''' <summary>
     ''' /addmodule
     ''' </summary>
     Private m_lstModules As New Specialized.StringCollection
 
     ''' <summary>
     ''' /recurse
     ''' </summary>
     Private m_lstRecurse As New Specialized.StringCollection
 
     ''' <summary>
     ''' /reference
     ''' </summary>
     Private m_lstReferences As New Specialized.StringCollection
 
     ' - RESOURCES -
 
     ''' <summary>
     ''' /linkresource
     ''' </summary>	
     Private m_lstLinkResources As Resources
 
     ''' <summary>
     ''' /resource
     ''' </summary>
     Private m_lstResources As Resources
 
     ''' <summary>
     ''' /win32icon
     ''' </summary>
     Private m_strWin32Icon As String
 
     ''' <summary>
     ''' /win32resource
     ''' </summary>
     Private m_strWin32Resource As String
 
     ' - CODE GENERATION -
 
     ''' <summary>
     ''' /optimize[+|-]          Enable optimizations.
     ''' </summary>
     Private m_bOptimize As Boolean
 
     ''' <summary>
     ''' /removeintchecks[+|-]   Remove integer checks. Default off.
     ''' </summary>
     Private m_bRemoveIntChecks As Boolean
 
     ''' <summary>
     ''' /debug[+|-]             Emit debugging information.
     '''/debug
     '''/debug
     ''' According to #81054 vbc doesn't emit debug info unless /debug is specified.
     ''' </summary>
     Private m_eDebugInfo As DebugTypes = DebugTypes.None
 
     ' - ERRORS AND WARNINGS -
 
     ''' <summary>
     ''' /nowarn                 Disable warnings.
     ''' </summary>
     Private m_bNoWarn As Boolean
 
     ''' <summary>
     ''' /warnaserror[+|-]       Treat warnings as errors.
     ''' </summary>
     Private m_bWarnAsError As Boolean
 
     ' - LANGUAGE -
 
     ''' <summary>
     ''' /define
     ''' </summary>
     Private m_lstDefine As New Defines
 
     ''' <summary>
     ''' /imports
     ''' </summary>
     Private m_lstImports As ImportsStatement
 
     ''' <summary>
     ''' /optionexplicit[+|-]    Require explicit declaration of variables.
     ''' </summary>
     Private m_eOptionExplicit As OptionExplicitTypes = OptionExplicitTypes.On
 
     ''' <summary>
     ''' /optionstrict[+|-]      Enforce strict language semantics.
     ''' </summary>
     Private m_eOptionStrict As OptionStrictTypes = OptionStrictTypes.Off
 
     ''' <summary>
     ''' /optioninfer[+|-]       Allow type inference of variables.
     ''' </summary>
     ''' <remarks></remarks>
     Private m_eOptionInfer As OptionInferTypes = OptionInferTypes.Off
 
     ''' <summary>
     ''' /rootnamespace
     ''' </summary>
     Private m_strRootNamespace As String
 
     ''' <summary>
     '''/optioncompare
     '''/optioncompare
     ''' </summary>
     Private m_eOptionCompare As OptionCompareTypes = OptionCompareTypes.Binary
 
     ' - MISCELLANEOUS -
 
     ''' <summary>
     ''' /help                   Display this usage message. (Short form
     ''' </summary>
     Private m_bHelp As Boolean
 
     ''' <summary>
     ''' /nologo                 Do not display compiler copyright banner.
     ''' </summary>
     Private m_bNoLogo As Boolean
 
     ''' <summary>
     ''' /quiet                  Quiet output mode. 
     ''' </summary>
     Private m_bQuiet As Boolean
 
     ''' <summary>
     ''' /verbose                Display verbose messages.
     ''' </summary>
     Private m_bVerbose As Boolean
 
     ''' <summary>
     ''' /noconfig               Disable the automatic inclusion of the vbnc.rsp response file.
     ''' </summary>
     Private m_bNoConfig As Boolean
 
     ''' <summary>
     ''' /nostdlib               Do not reference standard libraries (System.dll and vbnc.rsp)
     ''' </summary>
     ''' <remarks></remarks>
     Private m_bNoStdLib As Boolean
 
     ''' <summary>
     ''' /trace                  Output trace messages (vbnc extension)
     ''' </summary>
     ''' <remarks></remarks>
     Private m_bTrace As Boolean
 
     ' - ADVANCED -
 
     ''' <summary>
     ''' /baseaddress
     ''' </summary>
     Private m_strBaseAddress As String
 
     ''' <summary>
     ''' /bugreport
     ''' </summary>
     Private m_strBugReport As String
 
     ''' <summary>
     ''' /codepage
     ''' </summary>
     Private m_Encoding As System.Text.Encoding
 
     ''' <summary>
     ''' /delaysign[+|-]         Delay-sign the assembly using only the public portion of the strong name key.
     ''' </summary>
     Private m_bDelaySign As Boolean
 
     ''' <summary>
     ''' /keycontainer
     ''' </summary>
     Private m_strKeyContainer As String
 
     ''' <summary>
     ''' /keyfile
     ''' </summary>
     Private m_strKeyFile As String
 
     ''' <summary>
     ''' /libpath
     ''' </summary>
     Private m_lstLibPath As New Specialized.StringCollection
 
     ''' <summary>
     ''' /main
     ''' </summary>
     Private m_strMain As String
 
     ''' <summary>
     ''' /netcf                  Target the .NET Compact Framework.
     ''' </summary>
     Private m_bNetCF As Boolean
 
     ''' <summary>
     ''' /sdkpath
     ''' </summary>
     Private m_strSDKPath As String
 
     ''' <summary>
     ''' /utf8output[+|-]        Emit compiler output in UTF8 character encoding.
     ''' </summary>
     Private m_bUTF8Output As Boolean
 
     Private m_VBRuntime As String = "Microsoft.VisualBasic.dll"
 
     ''' <summary>
     ''' /vbversion
     ''' </summary>
     ''' <remarks></remarks>
     Private m_VBVersion As VBVersions = VBVersions.V8
     ' - OUTPUT FILE -
 
 
     ReadOnly Property VBVersion() As VBVersions
         Get
             Return m_VBVersion
         End Get
     End Property
 
     ''' <summary>
     ''' /out
     ''' </summary>
     ReadOnly Property Out() As String
         Get
             Return m_strOut
         End Get
     End Property
 
     ''' <summary>
     ''' /target
     ''' /target
     ''' /target
     ''' /target
     ''' </summary>
     ReadOnly Property Target() As Targets
         Get
             Return m_strTarget
         End Get
     End Property
 
     ' - INPUT FILES - 
 
     ''' <summary>
     ''' /addmodule
     ''' </summary>
     ReadOnly Property Modules() As Specialized.StringCollection
         Get
             Return m_lstModules
         End Get
     End Property
 
     ''' <summary>
     ''' /recurse
     ''' </summary>
     ReadOnly Property Recurse() As Specialized.StringCollection
         Get
             Return m_lstRecurse
         End Get
     End Property
 
     ''' <summary>
     ''' /reference
     ''' </summary>
     ReadOnly Property References() As Specialized.StringCollection
         Get
             Return m_lstReferences
         End Get
     End Property
 
     ' - RESOURCES -
 
     ''' <summary>
     ''' /linkresource
     ''' </summary>	
     ReadOnly Property LinkResources() As Resources
         Get
             Return m_lstLinkResources
         End Get
     End Property
 
     ''' <summary>
     ''' /resource
     ''' </summary>
     ReadOnly Property Resources() As Resources
         Get
             Return m_lstResources
         End Get
     End Property
 
     ''' <summary>
     ''' /win32icon
     ''' </summary>
     ReadOnly Property Win32Icon() As String
         Get
             Return m_strWin32Icon
         End Get
     End Property
 
     ''' <summary>
     ''' /win32resource
     ''' </summary>
     ReadOnly Property Win32Resource() As String
         Get
             Return m_strWin32Resource
         End Get
     End Property
 
     ' - CODE GENERATION -
 
     ''' <summary>
     ''' /optimize[+|-]          Enable optimizations.
     ''' </summary>
     ReadOnly Property Optimize() As Boolean
         Get
             Return m_bOptimize
         End Get
     End Property
 
     ''' <summary>
     ''' /removeintchecks[+|-]   Remove integer checks. Default off.
     ''' </summary>
     ReadOnly Property RemoveIntChecks() As Boolean
         Get
             Return m_bRemoveIntChecks
         End Get
     End Property
 
     ''' <summary>
     '''/debug
     '''/debug
     ''' </summary>
     ReadOnly Property DebugInfo() As DebugTypes
         Get
             Return m_eDebugInfo
         End Get
     End Property
 
     ' - ERRORS AND WARNINGS -
 
     ''' <summary>
     ''' /nowarn                 Disable warnings.
     ''' </summary>
     ReadOnly Property NoWarn() As Boolean
         Get
             Return m_bNoLogo
         End Get
     End Property
 
     ''' <summary>
     ''' /warnaserror[+|-]       Treat warnings as errors.
     ''' </summary>
     ReadOnly Property WarnAsError() As Boolean
         Get
             Return m_bWarnAsError
         End Get
     End Property
 
     ' - LANGUAGE -
 
     ''' <summary>
     ''' /define
     ''' </summary>
     ReadOnly Property Define() As Defines
         Get
             Return m_lstDefine
         End Get
     End Property
 
     ''' <summary>
     ''' /imports
     ''' </summary>
     ReadOnly Property [Imports]() As ImportsStatement
         Get
             Return m_lstImports
         End Get
     End Property
 
     ''' <summary>
     ''' /optionexplicit[+|-]    Require explicit declaration of variables.
     ''' </summary>
     ReadOnly Property OptionExplicit() As OptionExplicitTypes
         Get
             Return m_eOptionExplicit
         End Get
     End Property
 
     ''' <summary>
     ''' /optionstrict[+|-]      Enforce strict language semantics.
     ''' </summary>
     ReadOnly Property OptionStrict() As OptionStrictTypes
         Get
             Return m_eOptionStrict
         End Get
     End Property
 
     ''' <summary>
     ''' /rootnamespace
     ''' </summary>
     ReadOnly Property RootNamespace() As String
         Get
             Return m_strRootNamespace
         End Get
     End Property
 
     ''' <summary>
     '''/optioncompare
     '''/optioncompare
     ''' </summary>
     ReadOnly Property OptionCompare() As OptionCompareTypes
         Get
             Return m_eOptionCompare
         End Get
     End Property
 
     ''' <summary>
     ''' /optioninfer[+|-]       Allow type inference of variables.
     ''' </summary>
     ''' <remarks></remarks>
     ReadOnly Property OptionInfer As OptionInferTypes
         Get
             Return m_eOptionInfer
         End Get
     End Property
 
     ' - MISCELLANEOUS -
 
     ''' <summary>
     ''' /help                   Display this usage message. (Short form
     ''' </summary>
     ReadOnly Property Help() As Boolean
         Get
             Return m_bHelp
         End Get
     End Property
 
     ''' <summary>
     ''' /nologo                 Do not display compiler copyright banner.
     ''' </summary>
     ReadOnly Property NoLogo() As Boolean
         Get
             Return m_bNoLogo
         End Get
     End Property
 
     ''' <summary>
     ''' /quiet                  Quiet output mode. 
     ''' </summary>
     ReadOnly Property Quiet() As Boolean
         Get
             Return m_bQuiet
         End Get
     End Property
 
     ''' <summary>
     ''' /verbose                Display verbose messages.
     ''' </summary>
     ReadOnly Property Verbose() As Boolean
         Get
             Return m_bVerbose
         End Get
     End Property
 
     ''' <summary>
     ''' /noconfig               Disable the automatic inclusion of the vbnc.rsp response file.
     ''' </summary>
     ReadOnly Property NoConfig() As Boolean
         Get
             Return m_bNoConfig
         End Get
     End Property
 
     ''' <summary>
     ''' /nostdlib               Do not reference the standard libraries (vbnc.rsp and System.dll)
     ''' </summary>
     ReadOnly Property NoStdLib As Boolean
         Get
             Return m_bNoStdLib
         End Get
     End Property
 
     ''' <summary>
     ''' /trace                  Output trace messages (vbnc extension)
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property Trace As Boolean
         Get
             Return m_bTrace
         End Get
     End Property
 
     ReadOnly Property VBRuntime() As String
         Get
             Return m_VBRuntime
         End Get
     End Property
 
     ' - ADVANCED -
 
     ''' <summary>
     ''' /baseaddress
     ''' </summary>
     ReadOnly Property BaseAddress() As String
         Get
             Return m_strBaseAddress
         End Get
     End Property
 
     ''' <summary>
     ''' /bugreport
     ''' </summary>
     ReadOnly Property BugReport() As String
         Get
             Return m_strBugReport
         End Get
     End Property
 
     ''' <summary>
     ''' /codepage
     ''' </summary>
     ReadOnly Property Encoding() As System.Text.Encoding
         Get
             If m_Encoding Is Nothing Then m_Encoding = System.Text.Encoding.Default
             Return m_Encoding
         End Get
     End Property
 
     ''' <summary>
     ''' /delaysign[+|-]         Delay-sign the assembly using only the public portion of the strong name key.
     ''' </summary>
     ReadOnly Property DelaySign() As Boolean
         Get
             Return m_bDelaySign
         End Get
     End Property
 
     ''' <summary>
     ''' /keycontainer
     ''' </summary>
     ReadOnly Property KeyContainer() As String
         Get
             Return m_strKeyContainer
         End Get
     End Property
 
     ''' <summary>
     ''' /keyfile
     ''' </summary>
     ReadOnly Property KeyFile() As String
         Get
             Return m_strKeyFile
         End Get
     End Property
 
     ''' <summary>
     ''' /libpath
     ''' </summary>
     ReadOnly Property LibPath() As Specialized.StringCollection
         Get
             Return m_lstLibPath
         End Get
     End Property
 
     ''' <summary>
     ''' /main
     ''' </summary>
     ReadOnly Property Main() As String
         Get
             Return m_strMain
         End Get
     End Property
 
     ''' <summary>
     ''' /netcf                  Target the .NET Compact Framework.
     ''' </summary>
     ReadOnly Property NetCF() As Boolean
         Get
             Return m_bNetCF
         End Get
     End Property
 
     ''' <summary>
     ''' /sdkpath
     ''' </summary>
     ReadOnly Property SDKPath() As String
         Get
             Return m_strSDKPath
         End Get
     End Property
 
     ''' <summary>
     ''' /utf8output[+|-]        Emit compiler output in UTF8 character encoding.
     ''' </summary>
     ReadOnly Property UTF8Output() As Boolean
         Get
             Return m_bUTF8Output
         End Get
     End Property
 
     ''' <summary>
     ''' A list of all the response files specified on the command line.
     ''' </summary>
     ReadOnly Property ResponseFiles() As Specialized.StringCollection
         Get
             Return m_lstResponseFiles
         End Get
     End Property
 
 #End Region
 
     ReadOnly Property AllArgumentsAsArray() As String()
         Get
             Dim result(m_lstAllArgs.Count - 1) As String
             m_lstAllArgs.CopyTo(result, 0)
             Return result
         End Get
     End Property
 
     ''' <summary>
     ''' This property returns the files the commandline parser found on the commandline,
     ''' this includes expanded wildcards.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property Files() As CodeFiles
         Get
             Return m_lstFileNames
         End Get
     End Property
 
     ''' <summary>
     ''' Create a new commandline parser!
     ''' </summary>
     ''' <remarks></remarks>
     Sub New(ByVal Compiler As Compiler)
         m_Compiler = Compiler
         m_lstImports = New ImportsStatement(Compiler)
         m_lstImports.Init(New ImportsClauses(m_lstImports))
         m_lstFileNames = New CodeFiles(m_Compiler)
         m_lstResources = New Resources(m_Compiler, False)
         m_lstLinkResources = New Resources(m_Compiler, True)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="1574" endline="1597">
<![CDATA[
 
     Private Sub NextFile()
         m_TotalLineCount += m_CurrentLine
         'm_TotalCharCount += m_Code.Length
 
         m_CurrentLine = 1
         m_CurrentColumn = 1
         m_TokensSeenOnLine = 0
         m_CurrentChar = Nothing
         m_PreviousChar = Nothing
         m_EndOfFile = False
         m_PeekedChars.Clear()
 
         If m_Files.Count > 0 Then
             m_CodeFile = m_Files.Dequeue()
             m_CodeFileIndex = CUShort(Compiler.CommandLine.Files.IndexOf(m_CodeFile))
             m_Reader = m_CodeFile.CodeStream
             NextChar()
         Else
             m_CodeFile = Nothing
             'm_Code = Nothing
             m_Reader = Nothing
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="45" endline="65">
<![CDATA[
 
     Overloads Sub Init(ByVal Modifiers As Modifiers, ByVal Signature As FunctionSignature, Optional ByVal GetMethod As PropertyGetDeclaration = Nothing, Optional ByVal SetMethod As PropertySetDeclaration = Nothing, Optional ByVal MemberImplementsClause As MemberImplementsClause = Nothing)
         MyBase.Init(Modifiers, Signature.Name)
 
         m_Signature = Signature
 
         If Modifiers.Is(ModifierMasks.ReadOnly) = False AndAlso SetMethod Is Nothing Then
             SetMethod = New PropertySetDeclaration(Me)
             SetMethod.Init(Modifiers, Nothing, Nothing, Nothing)
         End If
         If Modifiers.Is(ModifierMasks.WriteOnly) = False AndAlso GetMethod Is Nothing Then
             GetMethod = New PropertyGetDeclaration(Me)
             GetMethod.Init(Modifiers, Nothing, Nothing)
         End If
 
         m_Get = GetMethod
         m_Set = SetMethod
         m_MemberImplementsClause = MemberImplementsClause
 
         Helper.Assert(m_Signature IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="72" endline="80">
<![CDATA[
     End Property
 
     ReadOnly Property ArgumentsTypesAsString() As String
         Get
             If m_ArgumentsTypesAsString Is Nothing Then
                 m_ArgumentsTypesAsString = "(" & m_Arguments.ArgumentsTypesAsString & ")"
             End If
             Return m_ArgumentsTypesAsString
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2977" endline="2986">
<![CDATA[
 
     Private Function ParseExpressionList(ByVal Parent As ParsedObject) As ExpressionList
         Dim result As New ExpressionList(Parent)
 
         If ParseList(Of Expression)(result, New ParseDelegate_Parent(Of Expression)(AddressOf ParseExpression), Parent) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5263" endline="5270">
<![CDATA[
 
     Private Function ParseRedimClauses(ByVal Parent As ReDimStatement) As RedimClauses
         Dim result As New RedimClauses(Parent)
         If ParseList(Of RedimClause)(result, New ParseDelegate_Parent(Of RedimClause)(AddressOf ParseRedimClause), Parent) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="230" endline="246">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property FullName() As String
         Get
             If m_FullName Is Nothing Then
                 If Me.IsNestedType Then
                     m_FullName = DeclaringType.FullName & "+" & Me.Name
                 Else
                     If m_Namespace <> "" Then
                         m_FullName = m_Namespace & "." & Me.Name
                     Else
                         m_FullName = Me.Name
                     End If
                 End If
             End If
             Return m_FullName
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\BooleanLiteralExpression.vb" startline="33" endline="49">
<![CDATA[
     Sub New(ByVal Parent As ParsedObject, ByVal Expression As Expression, ByVal DestinationType As Mono.Cecil.TypeReference)
         MyBase.new(Parent)
         m_DestinationType = DestinationType
         m_Expression = Expression
 
         Helper.Assert(m_DestinationType IsNot Nothing)
         Helper.Assert(m_Expression IsNot Nothing)
         Helper.Assert(m_Expression.IsResolved)
         Helper.Assert(TypeOf Expression Is BoxExpression = False)
 
         Classification = New ValueClassification(Me, m_DestinationType)
 
         If MyBase.ResolveExpression(ResolveInfo.Default(Compiler)) = False Then
             Helper.ErrorRecoveryNotImplemented(Me.Location)
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ConversionOperatorDeclaration.vb" startline="37" endline="56">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal [Operator] As Token, ByVal Operand As Operand, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As TypeName, ByVal Block As CodeBlock)
         Dim mySignature As New FunctionSignature(Me)
         Dim parameters As New ParameterList(Me)
 
         parameters.Add(New Parameter(parameters, Operand.Name, Operand.TypeName))
 
         If Modifiers.Is(ModifierMasks.Widening) Then
             mySignature.Init("op_Implicit", Nothing, parameters, ReturnTypeAttributes, TypeName, Me.Location)
         ElseIf Modifiers.Is(ModifierMasks.Narrowing) Then
             mySignature.Init("op_Explicit", Nothing, parameters, ReturnTypeAttributes, TypeName, Me.Location)
         Else
             Helper.AddError(Me)
         End If
 
         m_Operator = [Operator]
         m_Operand = Operand
 
         MyBase.Init(Modifiers, mySignature, Block)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="54" endline="72">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.GenerateCode(Info.Clone(Me, True, False, m_Expression.ExpressionType)) AndAlso result
         If CecilHelper.IsGenericParameter(m_Expression.ExpressionType) Then
             Emitter.EmitBox(Info, m_Expression.ExpressionType)
         End If
         Emitter.EmitIsInst(Info, m_Expression.ExpressionType, m_Type.ResolvedType)
 
         Emitter.EmitLoadNull(Info.Clone(Me, True, False, Compiler.TypeCache.System_Object))
         If m_Is Then
             Emitter.EmitNotEquals(Info, m_Type.ResolvedType)
         Else
             Emitter.EmitEquals(Info, m_Type.ResolvedType)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="134" endline="141">
<![CDATA[
 
     ReadOnly Property InstanceExpression() As Expression
         Get
             If m_InstanceExpression Is Nothing AndAlso m_Classification IsNot Nothing Then
                 m_InstanceExpression = m_Classification.InstanceExpression
             End If
             Return m_InstanceExpression
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="482" endline="498">
<![CDATA[
 
     ''' <summary>
     '''  Attributes 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributes(ByVal Parent As ParsedObject, ByRef Attributes As Attributes) As Boolean
         Dim result As Boolean = True
 
         While AttributeBlock.IsMe(tm)
             If Attributes Is Nothing Then Attributes = New Attributes(Parent)
             If ParseAttributeBlock(Parent, Attributes) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End While
         While AttributeBlock.IsMe(tm)
             If Attributes Is Nothing Then Attributes = New Attributes(Parent)
             If ParseAttributeBlock(Parent, Attributes) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End While
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="350" endline="359">
<![CDATA[
 
     Private Function ResolveLateBoundArrayInvocation(ByVal Context As ParsedObject) As Boolean
         Dim result As Boolean = True
 
         Classification = New LateBoundAccessClassification(Me, Expression, Nothing, Nothing)
 
         m_IsLateBoundArray = True
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\dshowUtil.vb" startline="88" endline="107">
<![CDATA[
 
     Private Overloads Function ShowInfo(ByVal Filename As String, ByVal BuildKeysList As Boolean) As Boolean
         mConverter = "flvtool2"
 
         mInfo = ReturnOutput(" -P " & Chr(34) & Filename & Chr(34))
         If BuildKeysList Then
             If BuildKeyFrameList() = False Then
                 If MsgBox(mTranslator.LangText(111), MsgBoxStyle.YesNo) = MsgBoxResult.Yes Then
                     ReturnOutput(" -U " & Chr(34) & Filename & Chr(34))
                     mInfo = ReturnOutput(" -P " & Chr(34) & Filename & Chr(34))
                     Return BuildKeyFrameList()
                 Else
                     Return False
                 End If
             End If
         End If
 
         mConverter = "MovicaCmd@@@.cmd"
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="270" endline="280">
<![CDATA[
 
     ''' <summary>
     ''' If the current token is not the specified keyword / symbol, then a
     ''' InternalException is thrown. (In which case it doesn't return,
     ''' so this is not a function).
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <remarks></remarks>
     Sub AcceptIfNotInternalError(ByVal Special As KS)
         If Not Accept(Special) Then Throw New InternalException("Location
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3537" endline="3552">
<![CDATA[
 
     ''' <summary>
     ''' VariableIdentifiers  
     '''	            VariableIdentifier  |
     '''	            VariableIdentifiers  ,  VariableIdentifier
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseVariableIdentifiers(ByVal Parent As ParsedObject) As VariableIdentifiers
         Dim result As New VariableIdentifiers(Parent)
 
         If ParseList(Of VariableIdentifier)(result, New ParseDelegate_Parent(Of VariableIdentifier)(AddressOf ParseVariableIdentifier), Parent) = False Then
             tm.GotoNewline(True)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\AssignStatements\CompoundAssignmentStatement.vb" startline="73" endline="90">
<![CDATA[
 
     Public NotOverridable Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveStatement(Info) AndAlso result
 
         If result = False Then Return result
 
         result = CheckIndexedStatement(Info, TryCast(LSide, InvocationOrIndexExpression)) AndAlso result
 
         m_CompoundExpression = ResolveStatement(LSide, RSide)
 
         result = m_CompoundExpression.ResolveExpression(Info) AndAlso result
 
         m_CompoundExpression = Helper.CreateTypeConversion(Me, m_CompoundExpression, LSide.ExpressionType, result)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="79" endline="85">
<![CDATA[
 
     Protected Sub Rename(ByVal Name As String)
         m_Name = Name
         If MemberDescriptor IsNot Nothing Then
             MemberDescriptor.Name = m_Name
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AliasClause.vb" startline="258" endline="264">
<![CDATA[
 
     Sub AddInitializer(ByVal Expression As Expression)
         Dim init As New VariableInitializer(Me)
         init.Init(Expression)
         m_VariableInitializerList.Add(init)
         If SetElements() = False Then Throw New InternalException(Me)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\DotAccessExpression.vb" startline="404" endline="414">
<![CDATA[
 
     Function ReclassifyMethodPointerToValueExpression(ByVal DelegateType As Mono.Cecil.TypeReference) As Expression
         Dim result As Expression = Nothing
 
         Helper.Assert(Classification.IsMethodPointerClassification)
         Helper.Assert(TypeOf Me Is AddressOfExpression)
 
         result = New DelegateOrObjectCreationExpression(Me, DelegateType, DirectCast(Me, AddressOfExpression))
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3346" endline="3357">
<![CDATA[
 
     Private Function ParseNot(ByVal Info As ExpressionParseInfo) As Expression
         Dim result As UnaryNotExpression
 
         If tm.CurrentToken = KS.Not Then
             result = ParseUnaryNotExpression(Info)
         Else
             Return ParseComparison(Info)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1070" endline="1081">
<![CDATA[
     ''' <summary>
     ''' Creates a new array and the new array reference is loaded at the top of the stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ElementType"></param>
     ''' <param name="Elements"></param>
     ''' <remarks></remarks>
     Shared Sub CreateArray(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference, ByVal Elements As Integer)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         EmitLoadValue(Info.Clone(Info.Context, True, False, Info.Compiler.TypeCache.System_Int32), Elements)
         EmitNewArr(Info, ElementType)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\VoidClassification.vb" startline="95" endline="106">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Info.IsRHS)
 
         Emitter.EmitLoadVariable(Info, m_Local)
         Emitter.EmitLoadI4Value(Info, m_Index)
         Emitter.EmitLoadElement(Info, m_Local.VariableType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="134" endline="148">
<![CDATA[
     End Property
 
     Friend Function DefineLocalVariable(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Me.IsStaticVariable Then Return result
 
         Helper.Assert(IsLocalVariable)
 
         If m_LocalBuilder Is Nothing Then
             m_LocalBuilder = Emitter.DeclareLocal(Info, VariableTypeOrTypeBuilder, Me.Name)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\VariableToValueExpression.vb" startline="30" endline="45">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         m_ExpressionType = m_Variable.Type
 
         If m_ExpressionType IsNot Nothing AndAlso CecilHelper.IsByRef(m_ExpressionType) Then
             m_ExpressionType = CecilHelper.GetElementType(m_ExpressionType)
         End If
 
         result = m_ExpressionType IsNot Nothing AndAlso result
 
         Me.Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="47" endline="61">
<![CDATA[
 
     Shared Function DeclareLocal(ByVal Info As EmitInfo, ByVal Type As Mono.Cecil.TypeReference, Optional ByVal Name As String = "") As Mono.Cecil.Cil.VariableDefinition
         Dim result As Mono.Cecil.Cil.VariableDefinition
         Helper.Assert(Info IsNot Nothing)
         Helper.Assert(Info.ILGen IsNot Nothing)
 
         Type = Helper.GetTypeOrTypeReference(Info.Compiler, Type)
         result = Info.ILGen.DeclareLocal(Type)
 
         If Name <> String.Empty AndAlso Info.Compiler.EmittingDebugInfo Then
             result.Name = Name
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="1115" endline="1134">
<![CDATA[
 
 
     ''' <summary>
     ''' TypeArgumentList 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeArgumentList(ByVal Parent As ParsedObject) As TypeArgumentList
         Dim result As New TypeArgumentList(Parent)
 
         tm.AcceptIfNotInternalError(KS.LParenthesis)
         tm.AcceptIfNotInternalError(KS.Of)
 
         If ParseList(Of TypeName)(result, New ParseDelegate_Parent(Of TypeName)(AddressOf ParseTypeName), Parent) = False Then
             Return Nothing
         End If
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="174" endline="188">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal InstanceExpression As Expression, ByVal Members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference))
         MyBase.New(Classifications.PropertyGroup, Parent)
         m_InstanceExpression = InstanceExpression
 
         m_Members = New Mono.Collections.Generic.Collection(Of Mono.Cecil.PropertyReference)(Members.Count)
         For i As Integer = 0 To Members.Count - 1
             Dim tmp As Mono.Cecil.PropertyReference = TryCast(Members(i), Mono.Cecil.PropertyReference)
             If tmp IsNot Nothing Then
                 m_Members.Add(tmp)
             Else
                 Throw New InternalException(Me)
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\BoundList.vb" startline="244" endline="260">
<![CDATA[
 
     Public Overrides Function CreateDefinition() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.CreateDefinition AndAlso result
 
         Helper.Assert(m_FieldBuilderCecil Is Nothing)
         m_FieldBuilderCecil = New Mono.Cecil.FieldDefinition(Name, 0, Nothing)
         m_FieldBuilderCecil.Annotations.Add(Compiler, Me)
         DeclaringType.CecilType.Fields.Add(m_FieldBuilderCecil)
 
         m_FieldBuilderCecil.HasDefault = True
         m_FieldBuilderCecil.Name = Name
         m_FieldBuilderCecil.Attributes = Helper.GetAttributes(Compiler, Me)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="1263" endline="1286">
<![CDATA[
     End Property
 
     Private Function NextChar() As Char
         If m_CurrentColumn < 255 Then m_CurrentColumn += CByte(1)
         m_TotalCharCount += 1
 
         m_PreviousChar = m_CurrentChar
         If m_PeekedChars.Count > 0 Then
             m_CurrentChar = m_PeekedChars.Dequeue
         Else
             If m_Reader.EndOfStream Then
                 m_CurrentChar = nl0
             Else
                 If m_Reader.EndOfStream Then
                     m_EndOfFile = True
                     m_CurrentChar = nl0
                 Else
                     m_CurrentChar = Convert.ToChar(m_Reader.Read())
                 End If
             End If
         End If
 
         Return m_CurrentChar
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Index.vb" startline="72" endline="78">
<![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub New(ByVal InnerException As Exception)
         MyBase.New("", InnerException)
         m_Message = "There has been an internal error in the compiler
 StopOnInternalException()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="67" endline="75">
<![CDATA[
 
     Function ReplaceAndVerifyArguments(ByVal NewArguments As ArgumentList, ByVal Method As Mono.Cecil.MethodReference, ByVal ShowErrors As Boolean) As Boolean
         Dim result As Boolean = True
 
         ReplaceArguments(NewArguments)
         result = VerifyArguments(Method, ShowErrors) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="76" endline="84">
<![CDATA[
 
     Function ReplaceAndVerifyArguments(ByVal NewArguments As ArgumentList, ByVal Method As Mono.Cecil.PropertyReference, ByVal ShowErrors As Boolean) As Boolean
         Dim result As Boolean = True
 
         ReplaceArguments(NewArguments)
         result = VerifyArguments(Method, ShowErrors) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="131" endline="145">
<![CDATA[
 
     ''' <summary>
     ''' Reclassifies the method group to a value, at the same time the method
     ''' group might be resolved using an empty argument list.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Function ReclassifyToValue() As ValueClassification
         Dim result As ValueClassification
         If m_Resolved = False Then
             Me.ResolveGroup(New ArgumentList(Me.Parent))
         End If
         result = New ValueClassification(Me)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\LateBoundAccessToValueExpression.vb" startline="44" endline="54">
<![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If Me.Classification IsNot Nothing Then
             Me.Classification = New ValueClassification(Me, m_Field.FieldType)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1667" endline="1680">
<![CDATA[
 
     ''' <summary>
     ''' Loads the value of the parameter.
     ''' Gets the value of byref parameters, not the passed-in address.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Variable"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadVariable(ByVal Info As EmitInfo, ByVal Variable As Mono.Cecil.ParameterDefinition)
         EmitLoadParameter(Info, Variable)
         If CecilHelper.IsByRef(Variable.ParameterType) AndAlso CecilHelper.IsByRef(Info.DesiredType) = False Then
             EmitLoadIndirect(Info, Variable.ParameterType)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\OperatorDeclaration.vb" startline="105" endline="111">
<![CDATA[
         Set(ByVal value As Object)
             If TypeConverter.ConvertTo(Me, value, ParameterType, value, True) = False Then
                 Throw New NotImplementedException
             End If
             If value Is DBNull.Value Then value = Nothing
             m_ParameterBuilderCecil.Constant = value
         End Set
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MyGenerator.vb" startline="73" endline="81">
<![CDATA[
 
     Shared Operator &(ByVal ns As [Namespace], ByVal str As String) As [Namespace]
         If ns Is Nothing Then Throw New InternalException("")
         If TypeOf ns Is GlobalNamespace Then
             Return New [Namespace](ns.Parent, str, True)
         Else
             Return New [Namespace](ns.Parent, ns, str)
         End If
     End Operator
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="325" endline="343">
<![CDATA[
 
     Public Shared Function EmitLateIndexGet(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification) As Boolean
         Dim result As Boolean = True
         Dim arguments As Mono.Cecil.Cil.VariableDefinition = Nothing
 
         'We need to emit a call to LateIndexGet
 
         '1 - the instance expression
         result = LateBoundAccess.InstanceExpression.GenerateCode(Info) AndAlso result
 
         '2 - The arguments
         '5 - ArgumentNames
         EmitArguments(Info, LateBoundAccess, arguments)
 
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_NewLateBinding__LateIndexGet_Object_Array_Array)
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="102" endline="115">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_IsVariableDeclaration Then
             result = m_VariableDeclaration.GenerateCode(Info.Clone(Me, True, False, UsingVariableType)) AndAlso result
             UsingVariable = m_VariableDeclaration.LocalBuilder
         Else
             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\dshowUtil.vb" startline="38" endline="55">
<![CDATA[
     End Property
 
     Public Overrides Function Save(ByVal Filename As String, _
     ByVal Segments As Segment(), _
     Optional ByVal Mode As Mode = AbstractMediaHandler.Mode.SaveSelected) As Boolean
         MyBase.Save(Filename, Segments)
 
         If Mode = AbstractMediaHandler.Mode.SaveSeparate Then
             CreatePieces(False)
 
             If FileCount(Filename) >= mSegments.Length Then Return True
         Else
             CreatePieces(True)
 
             Return OutFileCheck()
         End If
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="42" endline="50">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal ParamArray Expressions() As Expression)
         MyBase.New(Parent)
     Private m_Arguments As New BaseObjects(Of Argument)(Me)
 
     Sub New(ByVal Parent As ParsedObject)
         MyBase.New(Parent)
     End Sub
 
     Sub New(ByVal Parent As ParsedObject, ByVal ParamArray Expressions() As Expression)
         MyBase.New(Parent)
         If Expressions IsNot Nothing Then
             For Each item As Expression In Expressions
                 m_Arguments.Add(New PositionalArgument(Me, m_Arguments.Count, item))
             Next
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="866" endline="877">
<![CDATA[
 
     Shared Sub EmitCallOrCallVirt(ByVal Info As EmitInfo, ByVal Method As Mono.Cecil.MethodReference)
         Helper.Assert(Method IsNot Nothing)
         Dim mD As Mono.Cecil.MethodDefinition = CecilHelper.FindDefinition(Method)
         If mD Is Nothing AndAlso TypeOf Method.DeclaringType Is Mono.Cecil.ArrayType AndAlso (Method.Name = "Get" OrElse Method.Name = "Set") Then
             EmitCall(Info, Method)
         ElseIf mD.IsStatic OrElse CecilHelper.IsValueType(Method.DeclaringType) Then
             EmitCall(Info, Method)
         Else
             EmitCallVirt(Info, Method)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\dshowUtil.vb" startline="56" endline="78">
<![CDATA[
 
     Public Overrides Function Join(ByVal InFiles() As String, _
     ByVal OutFile As String) As Boolean
         MyBase.Join(InFiles, OutFile)
 
         Dim jw As IO.StreamWriter = New IO.StreamWriter(System.AppDomain.CurrentDomain.BaseDirectory & "MovicaJoin.@@@", False)
         jw.WriteLine(mOutFile)
         For i As Integer = 0 To InFiles.Length - 1
             jw.WriteLine(InFiles(i))
         Next
         jw.Close()
 
         mConverter = "flvjoin "
         RunConverter("MovicaJoin.@@@")
 
         'Update metadata for flv players; Movica would allow seek even without this
         mConverter = "flvtool2 "
         RunConverter(" -U " & Chr(34) & mOutFile & Chr(34))
         mConverter = "MovicaCmd@@@.cmd"
 
         Return OutFileCheck()
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\VoidClassification.vb" startline="60" endline="80">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_Local IsNot Nothing)
 
         If Info.IsRHS Then
             If CecilHelper.IsByRef(Info.DesiredType) Then
                 Emitter.EmitLoadVariableLocation(Info, m_Local)
             Else
                 Emitter.EmitLoadVariable(Info, m_Local)
             End If
         Else
             If Info.RHSExpression IsNot Nothing Then
                 result = Info.RHSExpression.GenerateCode(Info.Clone(Me, True, , m_Local.VariableType)) AndAlso result
             End If
             Emitter.EmitStoreVariable(Info, m_Local)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="66" endline="79">
<![CDATA[
     End Property
 
     Function PeekToken(Optional ByVal Jump As Integer = 1) As Token
         Helper.Assert(Jump >= -1)
         If Jump = -1 Then Return m_Previous
         If Jump = 0 Then Return CurrentToken()
         If m_TokenList.Count = 0 Then
             m_TokenList.Add(CurrentToken)
         End If
         For i As Integer = m_TokenList.Count To m_CurrentIndex + Jump
             m_TokenList.Add(m_Reader.Next())
         Next
         Return m_TokenList(m_CurrentIndex + Jump)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="372" endline="392">
<![CDATA[
 
     Shared Sub EmitValueTypeToObjectConversion(ByVal Info As EmitInfo, ByVal FromType As Mono.Cecil.TypeReference, ByVal ToType As Mono.Cecil.TypeReference)
         ToType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ToType)
         'Dim FromType As Type = Info.Stack.Peek
         Dim FromTP, ToTP As TypeCode
 
         FromTP = Helper.GetTypeCode(Info.Compiler, FromType)
         ToTP = Helper.GetTypeCode(Info.Compiler, ToType)
 
         Helper.Assert(ToTP = TypeCode.Object)
 
         If CecilHelper.IsByRef(ToType) AndAlso Helper.CompareType(CecilHelper.GetElementType(ToType), FromType) Then
             Dim localvar As Mono.Cecil.Cil.VariableDefinition = DeclareLocal(Info, FromType)
             Emitter.EmitStoreVariable(Info, localvar)
             Emitter.EmitLoadVariableLocation(Info, localvar)
         ElseIf Helper.IsEnum(Info.Compiler, CecilHelper.FindDefinition(FromType).BaseType) AndAlso Helper.CompareType(ToType, Info.Compiler.TypeCache.System_Enum) Then
 
         Else
             Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="1508" endline="1536">
<![CDATA[
 
     ''' <summary>
     ''' Parses a type declaration. Returns nothing if no type declaration was found.
     ''' Parses only one typedeclaration.
     ''' Type declaration = Class, Module, Structure, Enum, Delegate, Interface declaration.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="Namespace"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseTypeDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As TypeDeclaration
         Dim result As TypeDeclaration
         If ClassDeclaration.IsMe(tm) Then
             result = ParseClassDeclaration(Parent, Attributes, [Namespace])
         ElseIf EnumDeclaration.IsMe(tm) Then
             result = ParseEnumDeclaration(Parent, Attributes, [Namespace])
         ElseIf StructureDeclaration.IsMe(tm) Then
             result = ParseStructureDeclaration(Parent, Attributes, [Namespace])
         ElseIf InterfaceDeclaration.IsMe(tm) Then
             result = ParseInterfaceDeclaration(Parent, Attributes, [Namespace])
         ElseIf DelegateDeclaration.IsMe(tm) Then
             result = ParseDelegateDeclaration(Parent, Attributes, [Namespace])
         ElseIf ModuleDeclaration.IsMe(tm) Then
             result = ParseModuleDeclaration(Parent, Attributes, [Namespace])
         Else
             result = Nothing
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="107" endline="116">
<![CDATA[
     End Property
 
     ReadOnly Property OperandTypeCode() As TypeCode
         Get
             Dim result As TypeCode
 
             result = TypeConverter.GetBinaryOperandType(Compiler, Me.Keyword, LeftType, RightType)
 
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AliasClause.vb" startline="97" endline="105">
<![CDATA[
     End Property
 
     ReadOnly Property AttributeArguments() As AttributeArguments
         Get
             If m_AttributeArguments Is Nothing Then
                 m_AttributeArguments = New AttributeArguments(Me)
             End If
             Return m_AttributeArguments
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AttributeArguments.vb" startline="51" endline="58">
<![CDATA[
 
     ReadOnly Property PositionalArgumentList() As AttributePositionalArgumentList
         Get
             If m_AttributePositionalArgumentList Is Nothing Then
                 m_AttributePositionalArgumentList = New AttributePositionalArgumentList(Me)
             End If
             Return m_AttributePositionalArgumentList
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AttributeArguments.vb" startline="59" endline="67">
<![CDATA[
     End Property
 
     ReadOnly Property VariablePropertyInitializerList() As VariablePropertyInitializerList
         Get
             If m_VariablePropertyInitializerList Is Nothing Then
                 m_VariablePropertyInitializerList = New VariablePropertyInitializerList(Me)
             End If
             Return m_VariablePropertyInitializerList
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeParameter.vb" startline="109" endline="117">
<![CDATA[
     End Property
 
     Property TypeParameterConstraints() As TypeParameterConstraints
         Get
             If m_TypeParameterConstraints Is Nothing Then
                 m_TypeParameterConstraints = New TypeParameterConstraints(Me)
             End If
             Return m_TypeParameterConstraints
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\StdToolMgr.vb" startline="362" endline="370">
<![CDATA[
 #End Region
 
 #Region "   Start and End "
 
     Private Sub Me_Load()
         SetToolbarMode(False)
         mPen = New Pen(mPenColor, mPenWide)
         Draw()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="116" endline="124">
<![CDATA[
 
     Function GetRestorablePoint() As RestorablePoint
         m_RestorePoints += 1
         If m_TokenList.Count = 0 Then
             m_TokenList.Add(CurrentToken)
         End If
         'Console.WriteLine(" Creating restore point
         Return New RestorablePoint(m_CurrentIndex)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4026" endline="4041">
<![CDATA[
 
     Private Function ParseImplementsClause(ByVal Parent As ParsedObject) As MemberImplementsClause
         Dim result As New MemberImplementsClause(Parent)
 
         Dim m_ImplementsList As New MemberImplementsList(Parent)
 
         tm.AcceptIfNotInternalError(KS.Implements)
 
         If ParseList(Of InterfaceMemberSpecifier)(m_ImplementsList, New ParseDelegate_Parent(Of InterfaceMemberSpecifier)(AddressOf ParseInterfaceMemberSpecifier), Parent) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_ImplementsList)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\MRUbuffer.vb" startline="51" endline="57">
<![CDATA[
     End Property
 
     Public Function ShortName(ByVal Text As String) As String
         If Text.Length < MaxLen Then Return Text
         Dim RtLen As Integer = Text.Length - InStrRev(Text, "\")
         Return Text.Substring(0, 3) & ".." & Text.Substring(Text.Length - Math.Max(RtLen + 1, MaxLen - 5))
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="48" endline="59">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         m_Destination = Me.FindFirstParent(Of CodeBlock).FindLabel(m_GotoWhere)
         If m_Destination Is Nothing Then
             result = false
             Report.ShowMessage(Messages.VBNC30132, Me.Location, m_GotoWhere.Identifier)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="375" endline="392">
<![CDATA[
 
     Public Shared Function EmitLateIndexSet(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification) As Boolean
         Dim result As Boolean = True
         Dim arguments As Mono.Cecil.Cil.VariableDefinition = Nothing
 
         'We need to emit a call to LateIndexSet
 
         '1 - the instance expression
         result = LateBoundAccess.InstanceExpression.GenerateCode(Info.Clone(Info.Context, True, False, LateBoundAccess.InstanceExpression.ExpressionType)) AndAlso result
 
         '2 - The arguments
         '3 - ArgumentNames
         EmitArguments(Info, LateBoundAccess, arguments)
 
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_NewLateBinding__LateIndexSet_Object_Array_Array)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ErrorStatement.vb" startline="36" endline="46">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_ErrNumber.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Int32)) AndAlso result
         Emitter.EmitConversion(m_ErrNumber.ExpressionType, Compiler.TypeCache.System_Int32, Info)
         Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__CreateProjectError_Int32)
         Emitter.EmitThrow(Info)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\RMhandler.vb" startline="26" endline="41">
<![CDATA[
     End Property
 
     Public Overrides Function Save(ByVal Filename As String, _
     ByVal Segments As Segment(), _
     Optional ByVal Mode As Mode = AbstractMediaHandler.Mode.SaveSelected) As Boolean
         MyBase.Save(Filename, Segments)
 
         If Mode = AbstractMediaHandler.Mode.SaveSeparate Then
             CreatePieces(False)
             Return FileCount(Filename) >= mSegments.Length
         Else
             CreatePieces(True)
             Return OutFileCheck()
         End If
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="63" endline="78">
<![CDATA[
 
     Public Overrides Function CreateDefinition() As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_ValueField Is Nothing)
 
         result = MyBase.CreateDefinition() AndAlso result
 
         TypeAttributes = TypeAttributes Or Mono.Cecil.TypeAttributes.Sealed
         BaseType = Compiler.TypeCache.System_Enum
 
         m_ValueField = New Mono.Cecil.FieldDefinition(EnumTypeMemberName, Mono.Cecil.FieldAttributes.Public Or Mono.Cecil.FieldAttributes.SpecialName Or Mono.Cecil.FieldAttributes.RTSpecialName, Nothing)
         CecilType.Fields.Add(m_ValueField)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="45" endline="59">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Expression As Expression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info.IsRHS Then
             result = Expression.GenerateCode(Info.Clone(Expression, True, False, Expression.ExpressionType)) AndAlso result
             If CecilHelper.IsValueType(Expression.ExpressionType) OrElse CecilHelper.IsGenericParameter(Expression.ExpressionType) Then
                 Emitter.EmitBox(Info, Expression.ExpressionType)
             End If
         Else
             Throw New InternalException(Expression)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="531" endline="544">
<![CDATA[
     End Property
 
     Private Sub StringBuilderAppend(ByVal c As Char)
         m_StringBuilderLength += 1
         If m_StringBuilder Is Nothing Then
             ReDim m_StringBuilder(31)
         End If
         If m_StringBuilder.Length < m_StringBuilderLength Then
             Dim tmp(Math.Max(m_StringBuilder.Length * 2 - 1, m_StringBuilderLength)) As Char
             m_StringBuilder.CopyTo(tmp, 0)
             m_StringBuilder = tmp
         End If
         m_StringBuilder(m_StringBuilderLength - 1) = c
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="66" endline="87">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.String
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_String__Concat_String_String)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__ConcatenateObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="23" endline="70">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim opType As TypeCode = MyBase.OperandTypeCode
 
         ValidateBeforeGenerateCode(Info)
 
         Select Case opType
             Case TypeCode.Boolean, TypeCode.Object
                 If opType = TypeCode.Object Then
                     Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 End If
 
                 Dim loadfalse, loadtrue, endexp As Label
                 loadfalse = Emitter.DefineLabel(Info)
                 loadtrue = Emitter.DefineLabel(Info)
                 endexp = Emitter.DefineLabel(Info)
 
                 result = m_LeftExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfFalse(Info, loadfalse)
 
                 result = m_RightExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 Emitter.MarkLabel(Info, loadfalse) '
                 Emitter.EmitLoadValue(Info, False) 'Load false value
                 Emitter.EmitBranch(Info, endexp)
 
                 Emitter.MarkLabel(Info, loadtrue)
                 Emitter.EmitLoadValue(Info, True) 'Load true value
 
                 Emitter.MarkLabel(Info, endexp) 'The end of the expression
                
                 If opType = TypeCode.Object Then
                     Emitter.EmitBox(Info, Compiler.TypeCache.System_Boolean)
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="88" endline="104">
<![CDATA[
 
     Public Shared Sub EmitArrayCreation(ByVal Parent As ParsedObject, ByVal Info As EmitInfo, ByVal ArrayType As Mono.Cecil.TypeReference, ByVal asim As ArraySizeInitializationModifier)
         Dim Ranks As Integer = asim.BoundList.Expressions.Length
         For i As Integer = 0 To Ranks - 1
             Dim litexp As New ConstantExpression(Parent, 1, Parent.Compiler.TypeCache.System_Int32)
             Dim exp As Expression
 
             exp = New BinaryAddExpression(Parent, asim.BoundList.Expressions(i), litexp)
             exp = New CIntExpression(Parent, exp)
 
             If exp.ResolveExpression(ResolveInfo.Default(Info.Compiler)) = False Then Throw New InternalException(Parent)
             If exp.GenerateCode(Info.Clone(Parent, True)) = False Then Throw New InternalException(Parent)
 
             'Emitter.EmitConversion(exp.ExpressionType, Parent.Compiler.TypeCache.System_Int32, Info)
         Next
         EmitArrayConstructor(Info, ArrayType, Ranks)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\BoundList.vb" startline="154" endline="177">
<![CDATA[
 
     Function GetConstant(ByRef result As Object, ByVal ShowErrors As Boolean) As Boolean
         If m_ConstantExpression Is Nothing Then
             If ShowErrors Then Show30059()
             Return False
         End If
 
         If m_ConstantExpression.IsResolved = False Then
             If Not m_ConstantExpression.ResolveExpression(ResolveInfo.Default(Compiler)) Then
                 If ShowErrors Then Show30059()
                 Return False
             End If
         End If
 
         If m_ConstantExpression.GetConstant(result, ShowErrors) = False Then Return False
 
         If m_TypeName Is Nothing Then
             m_TypeName = New TypeName(Me, m_ConstantExpression.ExpressionType)
         Else
             Return TypeConverter.ConvertTo(m_ConstantExpression, result, m_TypeName.ResolvedType, result, ShowErrors)
         End If
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="169" endline="178">
<![CDATA[
 
     Protected Overrides Sub EmitStore(ByVal Info As EmitInfo)
         If m_LocalBuilder IsNot Nothing Then
             Emitter.EmitStoreVariable(Info, m_LocalBuilder)
         ElseIf FieldBuilder IsNot Nothing Then
             Emitter.EmitStoreField(Info, FieldBuilder)
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\AboutBox.cs" startline="8" endline="26">
<![CDATA[
         private System.ComponentModel.IContainer components = null;
         public AboutBox()
         {
             InitializeComponent();
 
             //  Initialize the AboutBox to display the product information from the assembly information.
             //  Change assembly information settings for your application through either
             //  - Project->Properties->Application->Assembly Information
             //  - AssemblyInfo.cs
             this.Text = String.Format("About {0}", AssemblyTitle);
             this.labelProductName.Text = AssemblyProduct;
             this.labelVersion.Text = String.Format("Version {0}", AssemblyVersion);
             this.labelCopyright.Text = AssemblyCopyright;
             this.labelCompanyName.Text = AssemblyCompany;
             this.textBoxDescription.Text = AssemblyDescription;
         }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\DotAccessExpression.vb" startline="52" endline="59">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Classification = New ValueClassification(Me, m_ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\MethodGroupToValueExpression.vb" startline="44" endline="54">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Dim tpparent As IType = Me.FindFirstParent(Of IType)()
         m_ExpressionType = tpparent.BaseType
 
         Classification = New ValueClassification(Me, m_ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4815" endline="4831">
<![CDATA[
 
     ''' <summary>
     ''' VariableMemberDeclaration  
     ''' </summary>
     Private Function ParseTypeVariableMemberDeclaration(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo) As Generic.List(Of TypeVariableDeclaration)
         Dim result As Generic.List(Of TypeVariableDeclaration)
 
         Dim m_VariableModifiers As Modifiers
 
         m_VariableModifiers = ParseModifiers(ModifierMasks.VariableModifiers)
 
         result = ParseTypeVariableDeclarators(Parent, m_VariableModifiers, Info)
 
         tm.AcceptNewLine(GotoNewline
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="1342" endline="1352">
<![CDATA[
 
     Private Function ParseBuiltinTypeName(ByVal Parent As ParsedObject) As BuiltInTypeName
         Dim m_Typename As KS
 
         If vbnc.BuiltInTypeName.IsBuiltInTypeName(tm) = False Then Throw New InternalException(Parent)
 
         m_Typename = tm.CurrentToken.Keyword
         tm.NextToken()
 
         Return New BuiltInTypeName(Parent, m_Typename)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="226" endline="239">
<![CDATA[
 
     ''' <summary>
     ''' ImportsClauses  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseImportsClauses(ByVal Parent As ImportsStatement) As ImportsClauses
         Dim result As New ImportsClauses(Parent)
 
         If ParseList(Of ImportsClause)(result, New ParseDelegate_Parent(Of ImportsClause)(AddressOf ParseImportsClause), result) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="303" endline="320">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <param name="Message"></param>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Diagnostics.DebuggerHidden()> Function AcceptIfNotError(ByVal Special As KS, ByVal Message As Messages, ByVal GotoNewline As Boolean, ByVal MessageParameters() As String) As Boolean
         If Accept(Special) Then
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Compiler.Report.ShowMessage(Message, CurrentLocation, MessageParameters)
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3175" endline="3188">
<![CDATA[
 
     Private Function ParseUnaryPlusMinus(ByVal Info As ExpressionParseInfo) As Expression
         Dim result As UnaryExpression
 
         If tm.CurrentToken = KS.Add Then
             result = ParseUnaryPlusExpression(Info)
         ElseIf tm.CurrentToken = KS.Minus Then
             result = ParseUnaryMinusExpression(Info)
         Else
             Return ParseExponent(Info)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4109" endline="4121">
<![CDATA[
 
     Private Function ParseConstantDeclarations(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal Modifiers As Modifiers) As Generic.List(Of ConstantDeclaration)
         Dim result As New Generic.List(Of ConstantDeclaration)
 
         Do
             Dim newCD As ConstantDeclaration = Nothing
             newCD = ParseConstantDeclaration(Parent, New ParseAttributableInfo(Parent.Compiler, Attributes), Modifiers)
             If newCD Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Add(newCD)
         Loop While tm.Accept(KS.Comma)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4087" endline="4108">
<![CDATA[
 
     ''' <summary>
     ''' ConstantMemberDeclaration  
     ''' </summary>
     ''' <remarks>
     ''' </remarks>
     Private Function ParseConstantMemberDeclarations(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo) As Generic.List(Of ConstantDeclaration)
         Dim result As New Generic.List(Of ConstantDeclaration)
 
         Dim m_Modifiers As Modifiers
 
         m_Modifiers = ParseModifiers(ModifierMasks.ConstantModifiers)
 
         tm.AcceptIfNotInternalError(KS.Const)
         m_Modifiers.AddModifiers(ModifierMasks.Const)
 
         result = ParseConstantDeclarations(Parent, Info.Attributes, m_Modifiers)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1480" endline="1489">
<![CDATA[
 
     Shared Sub ApplyTypeArguments(ByVal Context As BaseObject, ByVal Members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference), ByVal TypeArguments As TypeArgumentList)
         If TypeArguments Is Nothing OrElse TypeArguments.Count = 0 Then Return
 
         For i As Integer = Members.Count - 1 To 0 Step -1
             Members(i) = ApplyTypeArguments(Context, Members(i), TypeArguments)
             If Members(i) Is Nothing Then Members.RemoveAt(i)
         Next
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="56" endline="71">
<![CDATA[
     End Property
 
     Public Overrides Function CreateDefinition() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.CreateDefinition AndAlso result
 
         Helper.Assert(m_FieldBuilderCecil Is Nothing)
         m_FieldBuilderCecil = New Mono.Cecil.FieldDefinition(Name, Mono.Cecil.FieldAttributes.Public Or Mono.Cecil.FieldAttributes.Static Or Mono.Cecil.FieldAttributes.Literal Or Mono.Cecil.FieldAttributes.HasDefault, Parent.CecilType)
         m_FieldBuilderCecil.Annotations.Add(Compiler, Me)
         Parent.CecilType.Fields.Add(m_FieldBuilderCecil)
         m_FieldBuilderCecil.Name = Name
         m_FieldBuilderCecil.IsLiteral = True
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="92" endline="111">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Store the stack value into the loop control variable.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function EmitStoreVariable(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Helper.Assert(Info.RHSExpression IsNot Nothing)
         If m_Declaration IsNot Nothing Then
             Helper.Assert(m_Declaration.LocalBuilder IsNot Nothing)
             result = Info.RHSExpression.Classification.GenerateCode(Info.Clone(Me, True, False, m_Declaration.LocalBuilder.VariableType)) AndAlso result
             Emitter.EmitStoreVariable(Info, m_Declaration.LocalBuilder)
         Else
             result = m_Expression.GenerateCode(Info) AndAlso result
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\EventHandlerDeclaration.vb" startline="32" endline="57">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal HandlerType As KS, ByVal EventName As Identifier, ByVal Parameters As ParameterList, ByVal Code As CodeBlock)
 
         m_HandlerType = HandlerType
 
         Dim prefix As String
         Dim name As String
         Select Case m_HandlerType
             Case KS.AddHandler
                 prefix = "add_"
             Case KS.RemoveHandler
                 prefix = "remove_"
             Case KS.RaiseEvent
                 prefix = "raise_"
             Case Else
                 Throw New InternalException(Me)
         End Select
         name = prefix & EventName.Name
 
         Dim mySignature As SubSignature
 
         mySignature = New SubSignature(Me)
         mySignature.Init(New Identifier(mySignature, name, EventName.Location, EventName.TypeCharacter), Nothing, Parameters)
 
         MyBase.Init(Modifiers, mySignature, Code)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="6382" endline="6409">
<![CDATA[
 
     ''' <summary>
     ''' Parses enum members.
     ''' Never returns nothing.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseEnumMembers(ByVal Parent As EnumDeclaration) As Boolean
         Dim newConst As EnumMemberDeclaration
         Dim constAttributes As Attributes
 
         Do Until tm.CurrentToken.Equals(KS.End, KS.Enum)
             constAttributes = Nothing
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(Parent, constAttributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             newConst = ParseEnumMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, constAttributes), Parent.Members.Count)
             If newConst Is Nothing Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 Return False
             End If
             Parent.Members.Add(newConst)
         Loop
         Do Until tm.CurrentToken.Equals(KS.End, KS.Enum)
             constAttributes = Nothing
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(Parent, constAttributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             newConst = ParseEnumMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, constAttributes), Parent.Members.Count)
             If newConst Is Nothing Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 Return False
             End If
             Parent.Members.Add(newConst)
         Loop
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\EventAccessorDeclarations.vb" startline="202" endline="222">
<![CDATA[
 
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_AddMethod.CecilBuilder IsNot Nothing)
         Helper.Assert(m_RemoveMethod.CecilBuilder IsNot Nothing)
 
         'm_Builder.SetAddOnMethod(m_AddMethod.MethodBuilder)
         'm_Builder.SetRemoveOnMethod(m_RemoveMethod.MethodBuilder)
         'If m_RaiseMethod IsNot Nothing Then m_Builder.SetRaiseMethod(m_RaiseMethod.MethodBuilder)
 
         result = DefineOverrides() AndAlso result
         result = MyBase.GenerateCode(Info) AndAlso result
 
         m_CecilBuilder.AddMethod = m_AddMethod.CecilBuilder
         m_CecilBuilder.RemoveMethod = m_RemoveMethod.CecilBuilder
         If m_RaiseMethod IsNot Nothing Then m_CecilBuilder.InvokeMethod = m_RaiseMethod.CecilBuilder
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryNotExpression.vb" startline="46" endline="70">
<![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
         result = Expression.GenerateCode(expInfo) AndAlso result
 
         Select Case Me.OperandTypeCode
 
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, Compiler.TypeCache.System_Boolean)
                 Emitter.EmitEquals(Info, Compiler.TypeCache.System_Boolean)
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64
                 Emitter.EmitNot(Info, OperandType)
             Case TypeCode.Object
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__NotObject_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5372" endline="5399">
<![CDATA[
     ''' <summary>
     ''' WhileStatement  
     '''	   "While" BooleanExpression  StatementTerminator
     '''	         [  Block  ]
     '''	   "End" "While" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseWhileStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As WhileStatement
         Dim result As New WhileStatement(Parent)
 
         Dim m_Condition As Expression
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.While)
         m_Condition = ParseExpression(result)
         If m_Condition Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.While) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Condition, m_Code)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5400" endline="5429">
<![CDATA[
 
     ''' <summary>
     ''' WithStatement  
     '''	   "With" Expression  StatementTerminator
     '''	        [  Block  ]
     '''	   "End" "With" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseWithStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As WithStatement
         Dim result As New WithStatement(Parent)
 
         Dim m_WithExpression As Expression
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.With)
 
         m_WithExpression = ParseExpression(result)
         If m_WithExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         m_Code = ParseCodeBlock(result, IsOneLiner)
 
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.End, KS.With) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Code, m_WithExpression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5544" endline="5573">
<![CDATA[
 
     ''' <summary>
     '''SyncLockStatement  
     '''	"SyncLock" Expression  StatementTerminator
     '''	   [  Block  ]
     '''	"End" "SyncLock" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSyncLockStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As SyncLockStatement
         Dim result As New SyncLockStatement(Parent)
 
         Dim m_Lock As Expression
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.SyncLock)
 
         m_Lock = ParseExpression(result)
         If m_Lock Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.End, KS.SyncLock) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Lock, m_Code)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="174" endline="191">
<![CDATA[
 
     Private Function EmitLoadAddressCounter(ByVal Info As EmitInfo, ByVal Data As LoopCounterData) As Boolean
         Dim result As Boolean = True
         Select Case Data.Type
             Case LoopCounterTypes.Array
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Case LoopCounterTypes.Field
                 If Data.InstanceExpression IsNot Nothing Then
                     result = Data.InstanceExpression.GenerateCode(Info.Clone(Me, Data.InstanceExpression.ExpressionType)) AndAlso result
                 End If
                 Emitter.EmitLoadVariableLocation(Info, Data.FieldInfo)
             Case LoopCounterTypes.Local
                 Emitter.EmitLoadVariableLocation(Info, Data.LocalBuilder)
             Case Else
                 Throw New InternalException("Unknown LoopCounterType
         End Select
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="192" endline="209">
<![CDATA[
 
     Private Function EmitLoadCounter(ByVal Info As EmitInfo, ByVal Data As LoopCounterData) As Boolean
         Dim result As Boolean = True
         Select Case Data.Type
             Case LoopCounterTypes.Array
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Case LoopCounterTypes.Field
                 If Data.InstanceExpression IsNot Nothing Then
                     result = Data.InstanceExpression.GenerateCode(Info.Clone(Me, Data.InstanceExpression.ExpressionType)) AndAlso result
                 End If
                 Emitter.EmitLoadVariable(Info, Data.FieldInfo)
             Case LoopCounterTypes.Local
                 Emitter.EmitLoadVariable(Info, Data.LocalBuilder)
             Case Else
                 Throw New InternalException("Unknown LoopCounterType
         End Select
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2532" endline="2539">
<![CDATA[
 
     Shared Function GetPropertyOrPropertyBuilder(ByVal Compiler As Compiler, ByVal [Property] As Mono.Cecil.PropertyReference) As Mono.Cecil.PropertyReference
         If Compiler.Assembly.IsDefinedHere([Property]) Then
             Return [Property]
         Else
             Return [Property]
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="125" endline="131">
<![CDATA[
 
     Sub RestoreToPoint(ByVal Point As RestorablePoint)
         m_CurrentIndex = Point.Index
         Current = m_TokenList(m_CurrentIndex)
         'Console.WriteLine(" Restored to
         IgnoreRestoredPoint()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="38" endline="54">
<![CDATA[
 
     ''' <summary>
     ''' Loops up the namespace of the specified namespace.
     ''' Returns nothing if nothing is found.
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Default Overloads ReadOnly Property Item(ByVal Name As String) As [Namespace]
         Get
             If ContainsKey(Name) Then
                 Return m_Hashed(Name)
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="126" endline="139">
<![CDATA[
     End Property
 
     Function GetTypesByNamespaceAndName(ByVal [Namespace] As String, ByVal Name As String) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim result As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim key As String = String.Concat([Namespace], "?", Name)
         If m_TypesByNamespaceAndName.ContainsKey(key) Then
             result = m_TypesByNamespaceAndName(key)
         Else
             result = New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
             Helper.FilterByName(TypesByNamespace([Namespace]), Name, result)
             m_TypesByNamespaceAndName.Add(key, result)
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="112" endline="145">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Condition.ResolveExpression(Info) AndAlso result
         result = CodeBlock.ResolveCode(Info) AndAlso result
         If m_FalseCode IsNot Nothing Then result = m_FalseCode.ResolveCode(Info) AndAlso result
         If m_ElseIfs IsNot Nothing Then result = m_ElseIfs.ResolveCode(Info) AndAlso result
 
         If result = False Then Return result
 
         If m_Condition.Classification.IsValueClassification Then
             'nothing to do
         ElseIf m_Condition.Classification.CanBeValueClassification Then
             m_Condition = m_Condition.ReclassifyToValueExpression
             result = m_Condition.ResolveExpression(ResolveInfo.Default(Compiler)) AndAlso result
 
             If result = False Then
                 Helper.AddError(Me)
                 Return result
             End If
         Else
             Helper.AddError(Me, "Each expression in an If...Then...Else statement must be classified as a value and be implicitly convertible to Boolean")
         End If
 
         m_Condition = Helper.CreateTypeConversion(Me, m_Condition, Compiler.TypeCache.System_Boolean, result)
 
         If result = False Then
             Helper.AddError(Me)
             Return result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\InterfaceDeclaration.vb" startline="41" endline="55">
<![CDATA[
 
     Private Function AddAttribute() As Boolean
         Dim result As Boolean = True
         Dim newAttrib As Attribute
 
         If Compiler.TypeCache.MS_VB_CS_StandardModuleAttribute Is Nothing Then Return True
 
         newAttrib = New Attribute(Me, Compiler.TypeCache.MS_VB_CS_StandardModuleAttribute)
         result = newAttrib.ResolveCode(ResolveInfo.Default(Compiler)) AndAlso result
 
         If MyBase.CustomAttributes Is Nothing Then MyBase.CustomAttributes = New Attributes(Me)
         MyBase.CustomAttributes.Add(newAttrib)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="80" endline="99">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_WithExpression.ResolveExpression(Info) AndAlso result
 
         If result Then
             If CecilHelper.IsValueType(m_WithExpression.ExpressionType) AndAlso m_WithExpression.Classification.IsVariableClassification Then
                 m_WithVariableExpression = m_WithExpression
             Else
                 m_WithVariableExpression = New CompilerGeneratedExpression(Me, New CompilerGeneratedExpression.GenerateCodeDelegate(AddressOf GenerateVariableCode), m_WithExpression.ExpressionType)
                 result = m_WithVariableExpression.ResolveExpression(Info) AndAlso result
             End If
         End If
 
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="45" endline="51">
<![CDATA[
 
     Friend Sub ChangeQualifiedIdentifier(ByVal qi As QualifiedIdentifier)
         Helper.Assert(IsQualifiedIdentifier)
         'Helper.Assert(AsQualifiedIdentifier.Second IsNot Nothing)
         Helper.Assert(AsQualifiedIdentifier.First Is qi)
         m_TypeName = qi
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Index.vb" startline="61" endline="71">
<![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub New(ByVal Obj As ExpressionClassification)
         MyBase.new()
         If Obj IsNot Nothing Then
             m_Message = "There has been an internal error in the compiler caused by the line
         Else
             m_Message = "There has been an internal error in the compiler."
         End If
         StopOnInternalException()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="401" endline="414">
<![CDATA[
 
     ''' <summary>
     ''' Creates a variable classification for an array access.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="Arguments"></param>
     ''' <remarks></remarks>
     Sub New(ByVal Parent As ParsedObject, ByVal ArrayVariableExpression As Expression, ByVal Arguments As ArgumentList)
         MyBase.New(Classifications.Variable, Parent)
         m_ArrayVariable = ArrayVariableExpression
         m_Arguments = Arguments
         Helper.Assert(ArrayVariable IsNot Nothing)
         Helper.Assert(Arguments IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="155" endline="162">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Constant As ConstantDeclaration)
         MyBase.New(Classifications.Value, Parent)
         Helper.Assert(Constant IsNot Nothing)
         m_Constant = Constant
         m_Type = Constant.FieldType
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\LateBoundAccessToValueExpression.vb" startline="36" endline="43">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Emitter.EmitLoadMe(Info, Me.FindFirstParent(Of IType).CecilType)
         If CecilHelper.IsValueType(Info.DesiredType) AndAlso CecilHelper.IsByRef(Info.DesiredType) = False Then
             Emitter.EmitLoadObject(Info, Info.DesiredType)
         End If
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\DotAccessExpression.vb" startline="40" endline="48">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitLoadToken(Info, m_TypeName.ResolvedType)
         Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.System_Type__GetTypeFromHandle_RuntimeTypeHandle)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4832" endline="4848">
<![CDATA[
 
     ''' <summary>
     ''' VariableMemberDeclaration  
     ''' </summary>
     Private Function ParseLocalVariableMemberDeclaration(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo) As Generic.List(Of LocalVariableDeclaration)
         Dim result As Generic.List(Of LocalVariableDeclaration)
 
         Dim m_VariableModifiers As Modifiers
 
         m_VariableModifiers = ParseModifiers(ModifierMasks.VariableModifiers)
 
         result = ParseLocalVariableDeclarators(Parent, m_VariableModifiers, Info)
 
         If tm.FindNewLineAndShowError() = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\CachedExpression.vb" startline="49" endline="63">
<![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Expression.IsResolved = False Then
             result = m_Expression.ResolveExpression(Info)
         Else
             result = True
         End If
 
         Classification = New ValueClassification(Me, Me.ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\TryCastExpression.vb" startline="51" endline="61">
<![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.GenerateCode(Info.Clone(Me, True, False, m_Expression.ExpressionType)) AndAlso result
 
         Emitter.EmitLoadIndirect(Info, m_Expression.ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\MethodGroupToValueExpression.vb" startline="71" endline="80">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_MethodGroup.Resolved)
 
         Helper.EmitArgumentsAndCallOrCallVirt(Info, m_MethodGroup.InstanceExpression, m_MethodGroup.FinalArguments, Helper.GetMethodOrMethodReference(Compiler, m_MethodGroup.ResolvedMethod))
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="254" endline="265">
<![CDATA[
     End Property
 
     Private Sub SetMethods(ByVal lst As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference))
         m_Group = New Generic.List(Of Mono.Cecil.MemberReference)
         For i As Integer = 0 To lst.Count - 1
             Dim member As Mono.Cecil.MemberReference = lst(i)
             m_Group.Add(member)
         Next
 #If DEBUG Then
         m_OriginalGroup = New Generic.List(Of Mono.Cecil.MemberReference)(m_Group)
 #End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="266" endline="276">
<![CDATA[
 
     Private Sub SetMethods(ByVal lst As Generic.IList(Of Mono.Cecil.MemberReference))
         m_Group = New Generic.List(Of Mono.Cecil.MemberReference)
         For i As Integer = 0 To lst.Count - 1
             Dim member As Mono.Cecil.MemberReference = lst(i)
             m_Group.Add(member)
         Next
 #If DEBUG Then
         m_OriginalGroup = New Generic.List(Of Mono.Cecil.MemberReference)(m_Group)
 #End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="277" endline="287">
<![CDATA[
 
     Private Sub SetMethods(ByVal lst As Generic.IList(Of Mono.Cecil.MethodReference))
         m_Group = New Generic.List(Of Mono.Cecil.MemberReference)
         For i As Integer = 0 To lst.Count - 1
             Dim member As Mono.Cecil.MemberReference = lst(i)
             m_Group.Add(member)
         Next
 #If DEBUG Then
         m_OriginalGroup = New Generic.List(Of Mono.Cecil.MemberReference)(m_Group)
 #End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="1301" endline="1308">
<![CDATA[
 
     Private Function PeekChars(ByVal Chars As Integer) As Char
         Do Until m_PeekedChars.Count >= Chars
             If m_Reader.EndOfStream Then Return nlA
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         Loop
         Do Until m_PeekedChars.Count >= Chars
             If m_Reader.EndOfStream Then Return nlA
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         Loop
         Return m_PeekedChars.ToArray()(Chars - 1)
     End Function
]]>
</clone_fragment>
<clone_fragment file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="90" endline="99">
<![CDATA[
 
     Public Overloads Function isSplitCharacter(ByVal start As Integer, ByVal current As Integer, ByVal ende As Integer, ByVal cc() As Char, ByVal ck() As PdfChunk) As Boolean Implements SplitCharacter.isSplitCharacter
         Dim c As Char
         If ck Is Nothing Then
             c = cc(current)
         Else
             c = ck(Math.Min(current, ck.Length - 1)).getUnicodeEquivalent(cc(current))
         End If
         isSplitCharacter = (c = ".")
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="541" endline="559">
<![CDATA[
 
     ''' <summary>
     ''' AttributeList  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributeList(ByVal Parent As ParsedObject, ByVal Attributes As Attributes) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Attributes IsNot Nothing)
 
         Do
             Dim Attribute As Attribute
             Attribute = ParseAttribute(Parent)
             If Attribute Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Attributes.Add(Attribute)
         Loop While tm.Accept(KS.Comma)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\CallStatement.vb" startline="74" endline="86">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim casestmt As CaseStatement = Me.FindFirstParent(Of CaseStatement)()
         Dim selectstmt As SelectStatement = Me.FindFirstParent(Of SelectStatement)()
 
         result = m_ComparisonExpression.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean)) AndAlso result
 
         Emitter.EmitBranchIfTrue(Info, casestmt.StartCode)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="644" endline="660">
<![CDATA[
 
     ''' <summary>
     ''' Parses lists of type List 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseList(Of T As ParsedObject)(ByVal List As BaseList(Of T), ByVal ParseMethod As ParseDelegate_Parent(Of T), ByVal Parent As ParsedObject) As Boolean
         Helper.Assert(List IsNot Nothing, "List was nothing, tm.CurrentToken=" & tm.CurrentLocation.ToString(Compiler))
         Do
             Dim newObject As T
             newObject = ParseMethod(Parent)
             If newObject Is Nothing Then
                 Return False
             End If
             List.Add(newObject)
         Loop While tm.Accept(KS.Comma)
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="170" endline="186">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Skips tokens until a newline is found.
     ''' Returns if CodeEnd of EndOfFile found.
     ''' </summary>
     ''' <param name="EatNewLine">Eat the newline character?</param>
     ''' <param name="ReportError">Report the error "End of line expected."? (Always shown if this paramter is true.</param>
     ''' <remarks></remarks>
     Sub GotoNewline(ByVal EatNewLine As Boolean, Optional ByVal ReportError As Boolean = False)
         If ReportError Then Compiler.Report.ShowMessage(Messages.VBNC90018, CurrentLocation)
 
         Do Until CurrentToken.IsEndOfLine
             NextToken()
         Loop
         Do Until CurrentToken.IsEndOfLine
             NextToken()
         Loop
         If EatNewLine AndAlso CurrentToken.IsEndOfFile = False Then NextToken()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\AbstractMediaHandler.vb" startline="333" endline="342">
<![CDATA[
 
     Protected Function FileCount(ByVal Outfile As String, Optional ByVal Pattern As String = "*") As Integer
         Try
             Dim fi As New IO.FileInfo(AddDefaultPathIfNeeded(Outfile))
             If Pattern = "*" Then Pattern = StripPath(StripExtension(Outfile)) & "*"
             Return fi.Directory.GetFiles(Pattern).Length
         Catch ex As Exception
             Return -1
         End Try
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="510" endline="529">
<![CDATA[
 
     ''' <summary>
     ''' If the type is an enum type returns the base (integral type),
     ''' otherwise returns the same type.
     ''' </summary>
     ''' <param name="tp"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetIntegralType(ByVal Compiler As Compiler, ByVal tp As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Helper.Assert(tp IsNot Nothing, "tp Is Nothing")
         If Helper.IsEnum(Compiler, tp) Then
             Dim field As Mono.Cecil.FieldDefinition
             field = CecilHelper.FindField(CecilHelper.FindDefinition(tp).Fields, EnumDeclaration.EnumTypeMemberName)
             Helper.Assert(field IsNot Nothing, "field '" & EnumDeclaration.EnumTypeMemberName & "' Is Nothing of Type '" & tp.FullName & "'")
             Return field.FieldType
         Else
             Helper.Assert(IsIntegralType(tp))
             Return tp
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeImplementsClauses.vb" startline="36" endline="45">
<![CDATA[
     Sub New(ByVal Parent As ParsedObject, Optional ByVal NonArrayTypeName As NonArrayTypeName = Nothing, Optional ByVal ArrayTypeName As ArrayTypeName = Nothing)
         MyBase.New(Parent)
         If NonArrayTypeName IsNot Nothing AndAlso ArrayTypeName IsNot Nothing Then
             Throw New ArgumentException("Both NonArrayTypeName and ArrayTypeName cannot be specified.")
         ElseIf NonArrayTypeName IsNot Nothing Then
             Init(NonArrayTypeName)
         ElseIf ArrayTypeName IsNot Nothing Then
             Init(ArrayTypeName)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3012" endline="3031">
<![CDATA[
     ''' <summary>
     ''' GetTypeExpression 
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseGetTypeExpression(ByVal Parent As ParsedObject) As GetTypeExpression
         Dim result As New GetTypeExpression(Parent)
 
         tm.AcceptIfNotInternalError(KS.GetType)
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Dim m_TypeName As GetTypeTypeName
         m_TypeName = ParseGetTypeTypeName(result)
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_TypeName)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\CaseClauses.vb" startline="45" endline="60">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim falseLabel As Label = Emitter.DefineLabel(Info)
 
         result = m_Condition.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean)) AndAlso result
         Emitter.EmitBranchIfFalse(Info, falseLabel)
 
         result = CodeBlock.GenerateCode(Info) AndAlso result
         Emitter.EmitBranch(Info, ParentAsIfStatement.EndLabel)
 
         Emitter.MarkLabel(Info, falseLabel)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="820" endline="845">
<![CDATA[
 
     ''' <summary>
     ''' ArrayElementInitializer  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArrayElementInitializer(ByVal Parent As ParsedObject) As ArrayElementInitializer
         Dim result As New ArrayElementInitializer(Parent)
 
         Dim m_VariableInitializerList As VariableInitializerList
 
         m_VariableInitializerList = New VariableInitializerList(result)
 
         tm.AcceptIfNotInternalError(KS.LBrace)
         If tm.Accept(KS.RBrace) = False Then
 
             If ParseList(Of VariableInitializer)(m_VariableInitializerList, New ParseDelegate_Parent(Of VariableInitializer)(AddressOf ParseVariableInitializer), result) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             If tm.AcceptIfNotError(KS.RBrace) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_VariableInitializerList)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1561" endline="1572">
<![CDATA[
 
     Shared Sub EmitLoadVariable(ByVal Info As EmitInfo, ByVal Variable As VariableClassification)
         If Variable.LocalBuilder IsNot Nothing Then
             EmitLoadVariable(Info, Variable.LocalBuilder)
         ElseIf Variable.FieldInfo IsNot Nothing Then
             EmitLoadVariable(Info, Variable.FieldInfo)
         ElseIf Variable.ParameterInfo IsNot Nothing Then
             EmitLoadVariable(Info, Variable.ParameterInfo)
         Else
             Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1825" endline="1836">
<![CDATA[
 
     Shared Sub EmitStoreVariable(ByVal Info As EmitInfo, ByVal Variable As VariableClassification)
         If Variable.LocalBuilder IsNot Nothing Then
             EmitStoreVariable(Info, Variable.LocalBuilder)
         ElseIf Variable.FieldInfo IsNot Nothing Then
             EmitStoreField(Info, Variable.FieldInfo)
         ElseIf Variable.ParameterInfo IsNot Nothing Then
             EmitStoreVariable(Info, Variable.ParameterInfo)
         Else
             Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\StdToolMgr.vb" startline="522" endline="536">
<![CDATA[
 
     Private Sub lplaypos_MouseUp(ByVal sender As Object, _
     ByVal e As System.Windows.Forms.MouseEventArgs) Handles lplayPos.MouseUp
         mDragOn = False
         If mSliderSrt <> mSliderPos Then
             mSliderSrt = mSliderPos
             Dim NewCurrPosition As Double
             NewCurrPosition = (mSliderSrt + 3) * mPlayer.currentMedia.duration _
             / lplayPos.Width
             If mPlayer.playState = WMPLib.WMPPlayState.wmppsPlaying Then
                 Timer.Enabled = True
             End If
             RaiseEvent SliderMoved(NewCurrPosition)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmManual.vb" startline="438" endline="459">
<![CDATA[
 
     Private Sub Check_Service(ByVal Name As String, ByVal Cntrl As System.Windows.Forms.ComboBox)
 
         Try
             SrvcCntrl.ServiceName = (Name)
             Dim ChkSrvc As Boolean = SrvcCntrl.CanPauseAndContinue
         Catch ex As InvalidOperationException
             Cntrl.Enabled = False
             Cntrl.Items.Add("Service not found")
             Cntrl.SelectedIndex = 3
             Exit Sub
         End Try
 
         If Service_Startup(Name) = 2 Then
             Cntrl.SelectedIndex = 0
         ElseIf Service_Startup(Name) = 3 Then
             Cntrl.SelectedIndex = 1
         ElseIf Service_Startup(Name) = 4 Then
             Cntrl.SelectedIndex = 2
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ReturnStatement.vb" startline="32" endline="48">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim isSub As Boolean
 
         isSub = Info.Method.Signature.ReturnType Is Nothing OrElse Helper.CompareType(Info.Method.Signature.ReturnType, Compiler.TypeCache.System_Void)
         If isSub Then
             Helper.Assert(m_Expression Is Nothing)
         Else
             Helper.Assert(m_Expression IsNot Nothing)
             result = m_Expression.GenerateCode(Info.Clone(Me, True, , Info.Method.Signature.ReturnType)) AndAlso result
         End If
 
         Emitter.EmitRetOrLeave(Info, Me, Not isSub)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3851" endline="3872">
<![CDATA[
 
 
     ''' <summary>
     ''' TypeParameters  
     ''' CHANGED
     ''' </summary>
     ''' <remarks></remarks>
     ''' 
     Private Function ParseTypeParameters(ByVal Parent As ParsedObject) As TypeParameters
         Dim result As New TypeParameters(Parent)
 
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptIfNotError(KS.Of) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If ParseList(Of TypeParameter)(result.Parameters, New ParseDelegate_Parent(Of TypeParameter)(AddressOf ParseTypeParameter), result.Parameters) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="39" endline="62">
<![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Boolean
                 Emitter.EmitAnd(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__AndObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="23" endline="70">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim opType As TypeCode = MyBase.OperandTypeCode
 
         ValidateBeforeGenerateCode(Info)
 
         Select Case opType
             Case TypeCode.Boolean, TypeCode.Object
                 If opType = TypeCode.Object Then
                     Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 End If
 
                 Dim loadfalse, loadtrue, endexp As Label
                 loadfalse = Emitter.DefineLabel(Info)
                 loadtrue = Emitter.DefineLabel(Info)
                 endexp = Emitter.DefineLabel(Info)
 
                 result = m_LeftExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfFalse(Info, loadfalse)
 
                 result = m_RightExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 Emitter.MarkLabel(Info, loadfalse) '
                 Emitter.EmitLoadValue(Info, False) 'Load false value
                 Emitter.EmitBranch(Info, endexp)
 
                 Emitter.MarkLabel(Info, loadtrue)
                 Emitter.EmitLoadValue(Info, True) 'Load true value
 
                 Emitter.MarkLabel(Info, endexp) 'The end of the expression
                
                 If opType = TypeCode.Object Then
                     Emitter.EmitBox(Info, Compiler.TypeCache.System_Boolean)
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="39" endline="62">
<![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Boolean
                 Emitter.EmitAnd(Info, OperandType)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__AndObject_Object_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="23" endline="70">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim opType As TypeCode = MyBase.OperandTypeCode
 
         ValidateBeforeGenerateCode(Info)
 
         Select Case opType
             Case TypeCode.Boolean, TypeCode.Object
                 If opType = TypeCode.Object Then
                     Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 End If
 
                 Dim loadfalse, loadtrue, endexp As Label
                 loadfalse = Emitter.DefineLabel(Info)
                 loadtrue = Emitter.DefineLabel(Info)
                 endexp = Emitter.DefineLabel(Info)
 
                 result = m_LeftExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfFalse(Info, loadfalse)
 
                 result = m_RightExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 Emitter.MarkLabel(Info, loadfalse) '
                 Emitter.EmitLoadValue(Info, False) 'Load false value
                 Emitter.EmitBranch(Info, endexp)
 
                 Emitter.MarkLabel(Info, loadtrue)
                 Emitter.EmitLoadValue(Info, True) 'Load true value
 
                 Emitter.MarkLabel(Info, endexp) 'The end of the expression
                
                 If opType = TypeCode.Object Then
                     Emitter.EmitBox(Info, Compiler.TypeCache.System_Boolean)
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="514" endline="532">
<![CDATA[
 
     Public Overridable Function CreateImplicitSharedConstructors() As Boolean
         Dim result As Boolean = True
 
         If Not NeedsSharedConstructor Then Return result
         If DefaultSharedConstructor IsNot Nothing Then Return result
 
         Me.FindDefaultConstructors()
 
         If DefaultSharedConstructor IsNot Nothing Then Return result
 
         DefaultSharedConstructor = New ConstructorDeclaration(Me)
         DefaultSharedConstructor.Init(New Modifiers(ModifierMasks.Shared), New SubSignature(DefaultSharedConstructor, ConstructorDeclaration.SharedConstructorName, New ParameterList(DefaultSharedConstructor)), New CodeBlock(DefaultSharedConstructor))
         Members.Add(DefaultSharedConstructor)
         result = DefaultSharedConstructor.CreateDefinition AndAlso result
         BeforeFieldInit = True
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="23" endline="70">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim opType As TypeCode = MyBase.OperandTypeCode
 
         ValidateBeforeGenerateCode(Info)
 
         Select Case opType
             Case TypeCode.Boolean, TypeCode.Object
                 If opType = TypeCode.Object Then
                     Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 End If
 
                 Dim loadfalse, loadtrue, endexp As Label
                 loadfalse = Emitter.DefineLabel(Info)
                 loadtrue = Emitter.DefineLabel(Info)
                 endexp = Emitter.DefineLabel(Info)
 
                 result = m_LeftExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfFalse(Info, loadfalse)
 
                 result = m_RightExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 Emitter.MarkLabel(Info, loadfalse) '
                 Emitter.EmitLoadValue(Info, False) 'Load false value
                 Emitter.EmitBranch(Info, endexp)
 
                 Emitter.MarkLabel(Info, loadtrue)
                 Emitter.EmitLoadValue(Info, True) 'Load true value
 
                 Emitter.MarkLabel(Info, endexp) 'The end of the expression
                
                 If opType = TypeCode.Object Then
                     Emitter.EmitBox(Info, Compiler.TypeCache.System_Boolean)
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="286" endline="325">
<![CDATA[
 
     ''' <summary>
     ''' Shows the specified message. Can optionally save it (not show it)
     ''' to show it later with ShowSavedMessages()
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Private Function ShowMessage(ByVal SaveIt As Boolean, ByVal Message As Message) As Boolean
         Dim isOnlyWarning As Boolean = False
 
         isOnlyWarning = Message.Level <= MessageLevel.Warning
 
         If SaveIt Then
             m_SavedMessages.Add(Message)
         Else
             m_Messages.Add(Message)
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Always, Message.ToString())
             m_MessageCount(Message.Level) += 1
             If m_MessageCount(MessageLevel.Error) > MAXERRORS Then
                 Throw New TooManyErrorsException()
             End If
         End If
 
 #If TRACEMESSAGES Then
         Console.WriteLine(Environment.StackTrace)
 #End If
 
 #If STOPONERROR Then
         If Helper.IsDebugging AndAlso Message.Level = MessageLevel.Error Then
             Helper.Stop()
         ElseIf Helper.IsBootstrapping Then
             Throw New InternalException(Message.ToString)
         End If
 #ElseIf STOPONWARNING Then
         If Debugger.IsAttached AndAlso Message.Level = MessageLevel.Warning Then
             Helper.Stop()
         End If
 #End If
 
         Return isOnlyWarning
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4795" endline="4813">
<![CDATA[
 
     Shared Function ShowClassificationError(ByVal Compiler As Compiler, ByVal Location As Span, ByVal ActualClassification As ExpressionClassification, ByVal Expected As String) As Boolean
         Select Case ActualClassification.Classification
             Case ExpressionClassification.Classifications.Type
                 Dim tp As Mono.Cecil.TypeReference = ActualClassification.AsTypeClassification.Type
                 Return Compiler.Report.ShowMessage(Messages.VBNC30691, Location, tp.Name, tp.Namespace)
             Case ExpressionClassification.Classifications.Value
                 Dim vC As ValueClassification = ActualClassification.AsValueClassification
                 Dim constant As Object = Nothing
                 If vC.GetConstant(constant, False) Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC30074, Location)
                 Else
                     Helper.AddError(Compiler, Location, "Expected " & Expected & " got " & ActualClassification.Classification.ToString())
                 End If
             Case Else
                 Helper.AddError(Compiler, Location, "Expected " & Expected & " got " & ActualClassification.Classification.ToString())
         End Select
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\CaseClauses.vb" startline="73" endline="95">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim selectparent As SelectStatement = Me.FindFirstParent(Of SelectStatement)()
 
         EndLabel = Emitter.DefineLabel(Info)
         m_StartCode = Emitter.DefineLabel(Info)
 
         If m_IsElse = False Then
             For i As Integer = 0 To m_Clauses.Count - 1
                 Dim clause As CaseClause = m_Clauses.Item(i)
                 result = clause.GenerateCode(Info) AndAlso result
             Next
             Emitter.EmitBranch(Info, EndLabel)
         End If
         Emitter.MarkLabel(Info, m_StartCode)
         result = CodeBlock.GenerateCode(Info) AndAlso result
         Emitter.EmitBranch(Info, selectparent.EndLabel)
         Emitter.MarkLabel(Info, EndLabel)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MemberCache.vb" startline="385" endline="411">
<![CDATA[
 
     Private Sub FlattenWith(ByVal Name As String, ByVal MemberCache As MemberCache, ByVal Visibility As MemberVisibility)
         Dim cache_entries As MemberCacheEntries = Nothing
 
         'Console.WriteLine("{0} FlattenWith
 
         cache_entries = m_FlattenedCacheInsensitive(Visibility)
         If cache_entries Is Nothing Then
             cache_entries = New MemberCacheEntries()
             m_FlattenedCacheInsensitive(Visibility) = cache_entries
         End If
 
         AddToFlattenedCache(cache_entries, Name, MemberCache, m_CacheInsensitive(Visibility), Visibility)
 
         Dim cache2 As MemberCacheEntries
         cache2 = MemberCache.m_FlattenedCacheInsensitive(Visibility)
 
         If Name Is Nothing Then
             For Each cache As MemberCacheEntry In cache2.Values
                 AddToCache(cache, Visibility, cache_entries)
             Next
         Else
             Dim entry As MemberCacheEntry = Nothing
             If Not cache2.TryGetValue(Name, entry) Then Return
             AddToCache(cache2(Name), Visibility, cache_entries)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="24" endline="38">
<![CDATA[
         Get
             Dim result As Mono.Cecil.TypeReference
             Dim lType, rType As Mono.Cecil.TypeReference
 
             lType = Me.LeftType
             rType = Me.RightType
 
             If Helper.CompareType(lType, rType) AndAlso Helper.IsEnum(Compiler, lType) Then
                 result = lType
             Else
                 result = MyBase.ExpressionType()
             End If
 
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3161" endline="3174">
<![CDATA[
 
     Private Function ParseExponent(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseIdentifier(Info)
 
         While tm.Accept(KS.Power)
             tm.AcceptNewLine()
             rSide = ParseIdentifier(Info)
             lSide = New ExponentExpression(Info.Parent, lSide, rSide)
         End While
         While tm.Accept(KS.Power)
             tm.AcceptNewLine()
             rSide = ParseIdentifier(Info)
             lSide = New ExponentExpression(Info.Parent, lSide, rSide)
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3212" endline="3225">
<![CDATA[
 
     Private Function ParseIntDiv(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseMultDiv(Info)
 
         While tm.Accept(KS.IntDivision)
             tm.AcceptNewLine()
             rSide = ParseMultDiv(Info)
             lSide = New IntDivisionExpression(Info.Parent, lSide, rSide)
         End While
         While tm.Accept(KS.IntDivision)
             tm.AcceptNewLine()
             rSide = ParseMultDiv(Info)
             lSide = New IntDivisionExpression(Info.Parent, lSide, rSide)
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3226" endline="3239">
<![CDATA[
 
     Private Function ParseMod(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseIntDiv(Info)
 
         While tm.Accept(KS.Mod)
             tm.AcceptNewLine()
             rSide = ParseIntDiv(Info)
             lSide = New ModExpression(Info.Parent, lSide, rSide)
         End While
         While tm.Accept(KS.Mod)
             tm.AcceptNewLine()
             rSide = ParseIntDiv(Info)
             lSide = New ModExpression(Info.Parent, lSide, rSide)
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3264" endline="3277">
<![CDATA[
 
     Private Function ParseConcat(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParsePlusMinus(Info)
 
         While tm.Accept(KS.Concat)
             tm.AcceptNewLine()
             rSide = ParsePlusMinus(Info)
             lSide = New ConcatExpression(Info.Parent, lSide, rSide)
         End While
         While tm.Accept(KS.Concat)
             tm.AcceptNewLine()
             rSide = ParsePlusMinus(Info)
             lSide = New ConcatExpression(Info.Parent, lSide, rSide)
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5061" endline="5069">
<![CDATA[
 
     Private Function ParseResumeStatement(ByVal Parent As ParsedObject) As ResumeStatement
         Dim m_IsResumeNext As Boolean
 
         tm.AcceptIfNotInternalError(KS.Resume)
         m_IsResumeNext = tm.Accept(KS.Next)
 
         Return New ResumeStatement(Parent, m_IsResumeNext)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\MethodGroupToValueExpression.vb" startline="59" endline="67">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveExpression(info) AndAlso result
         Classification = m_Expression.Classification
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\PositionalArgument.vb" startline="46" endline="57">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         m_ExpressionType = m_PropertyAccess.Type
 
         result = m_ExpressionType IsNot Nothing AndAlso result
 
         Me.Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="205" endline="211">
<![CDATA[
         Set(ByVal value As Mono.Cecil.MethodAttributes)
             If (value And Mono.Cecil.MethodAttributes.MemberAccessMask) = 0 Then
                 m_CecilBuilder.Attributes = value Or m_CecilBuilder.Attributes
             Else
                 m_CecilBuilder.Attributes = value Or (m_CecilBuilder.Attributes And Not Mono.Cecil.MethodAttributes.MemberAccessMask)
             End If
         End Set
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Compiler.vb" startline="256" endline="269">
<![CDATA[
 
     Function Compile(ByVal CommandLine As String()) As Integer
         'Try
         If m_CommandLine.Parse(CommandLine) = False Then
             If m_CommandLine.NoLogo = False Then
                 ShowLogo()
             End If
             If Report.ShowSavedMessages() = False Then
                 ShowHelp()
             End If
             Return 1
         End If
         Return Compile()
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ReturnStatement.vb" startline="40" endline="52">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Exception Is Nothing Then
             Info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Rethrow)
         Else
             result = m_Exception.GenerateCode(Info.Clone(Me, True, False, m_Exception.ExpressionType)) AndAlso result
             Emitter.EmitThrow(Info)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="125" endline="145">
<![CDATA[
 
     ''' <summary>
     ''' Emits the array constructor.
     ''' The number of elements for each rank must be emitted already.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ArrayType"></param>
     ''' <param name="Ranks"></param>
     ''' <remarks></remarks>
     Public Shared Sub EmitArrayConstructor(ByVal Info As EmitInfo, ByVal ArrayType As Mono.Cecil.TypeReference, ByVal Ranks As Integer)
         If Ranks <= 1 Then
             Emitter.EmitNewArr(Info, CecilHelper.GetElementType(ArrayType))
         Else
             Dim minfo As Mono.Cecil.MethodReference
             minfo = New Mono.Cecil.MethodReference(".ctor", ArrayType, Info.Compiler.TypeCache.System_Void, True, False, Mono.Cecil.MethodCallingConvention.Default)
             For i As Integer = 1 To Ranks
                 minfo.Parameters.Add(New Mono.Cecil.ParameterDefinition(Info.Compiler.TypeCache.System_Int32))
             Next
             Emitter.EmitNew(Info, minfo)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="1715" endline="1744">
<![CDATA[
 
     ''' <summary>
     ''' InterfaceEventMemberDeclaration  
     '''	[  Attributes  ]  [  InterfaceEventModifiers+  ]  "Event"  Identifier  ParametersOrType  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInterfaceEventMemberDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As InterfaceEventMemberDeclaration
         Dim result As New InterfaceEventMemberDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_ParametersOrType As ParametersOrType
 
 
         m_Modifiers = ParseModifiers(ModifierMasks.InterfaceEventModifiers)
 
         tm.AcceptIfNotInternalError(KS.Event)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_ParametersOrType = ParseParametersOrType(result)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Identifier, m_ParametersOrType, Nothing)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5005" endline="5031">
<![CDATA[
 
 
     ''' <summary>
     ''' LabelDeclarationStatement  
     ''' LabelName  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseLabelDeclarationStatement(ByVal Parent As ParsedObject) As LabelDeclarationStatement
         Dim m_Label As Token
 
         If tm.CurrentToken.IsIdentifier OrElse tm.CurrentToken.IsIntegerLiteral Then
             m_Label = tm.CurrentToken
             tm.NextToken()
         Else
             Throw New InternalException(Parent)
         End If
 
         If tm.CurrentToken.Equals(KS.Colon) = False Then
             Throw New InternalException(Parent)
         End If
 
         If tm.PeekToken.IsEndOfLineOnly Then
             tm.NextToken()
         End If
 
         Return New LabelDeclarationStatement(Parent, m_Label)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="46" endline="52">
<![CDATA[
 
     Sub AddInheritsClause(ByVal Clause As NonArrayTypeName)
         If m_InheritsClauses Is Nothing Then
             m_InheritsClauses = New Generic.List(Of NonArrayTypeName)
         End If
         m_InheritsClauses.Add(Clause)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\SubSignature.vb" startline="106" endline="112">
<![CDATA[
 
     Overridable Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As SubSignature
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New SubSignature(NewParent)
         CloneTo(result)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\AbstractMediaHandler.vb" startline="67" endline="76">
<![CDATA[
     End Property
 
     Public Property Options(ByVal Key As String) As String
         Get
             If mOptions.Item(Key) Is Nothing Then
                 Return ""
             Else
                 Return mOptions.Item(Key)
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\DotAccessExpression.vb" startline="60" endline="164">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim refInfo As EmitInfo = Info.Clone(Me, Me.ExpressionType)
 
         Select Case m_Expression.Classification.Classification
             Case ExpressionClassification.Classifications.Variable
                 Dim varC As VariableClassification = m_Expression.Classification.AsVariableClassification
 
                 If varC.InstanceExpression IsNot Nothing Then
                     Dim desiredType As Mono.Cecil.TypeReference
                     desiredType = varC.InstanceExpression.ExpressionType
                     If CecilHelper.IsValueType(desiredType) AndAlso CecilHelper.IsByRef(desiredType) = False Then
                         desiredType = CecilHelper.MakeByRefType(desiredType)
                     End If
                     result = varC.InstanceExpression.GenerateCode(Info.Clone(Me, desiredType)) AndAlso result
                     'result = varC.InstanceExpression.GenerateCode(refInfo) AndAlso result
                 End If
 
                 If varC.LocalBuilder IsNot Nothing Then
                     Emitter.EmitLoadVariableLocation(refInfo, varC.LocalBuilder)
                 ElseIf varC.ParameterInfo IsNot Nothing Then
                     Emitter.EmitLoadVariableLocation(refInfo, varC.ParameterInfo)
                 ElseIf varC.FieldInfo IsNot Nothing Then
                     If varC.FieldDefinition.IsLiteral Then
                         Dim local As Mono.Cecil.Cil.VariableDefinition
                         local = Emitter.DeclareLocal(Info, varC.FieldInfo.FieldType)
                         Emitter.EmitLoadVariable(Info, varC.FieldInfo)
                         Emitter.EmitStoreVariable(Info, local)
                         Emitter.EmitLoadVariableLocation(refInfo, local)
                     Else
                         Emitter.EmitLoadVariableLocation(refInfo, varC.FieldInfo)
                     End If
                 ElseIf varC.ArrayVariable IsNot Nothing Then
                     Dim arrtype As Mono.Cecil.TypeReference = varC.ArrayVariable.ExpressionType
                     Dim elementtype As Mono.Cecil.TypeReference = CecilHelper.GetElementType(arrtype)
                     Dim isnonprimitivevaluetype As Boolean = CecilHelper.IsPrimitive(Compiler, elementtype) = False AndAlso CecilHelper.IsValueType(elementtype)
 
                     result = varC.ArrayVariable.GenerateCode(Info.Clone(Me, True, False, arrtype)) AndAlso result
 
                     Dim methodtypes As New Generic.List(Of Mono.Cecil.TypeReference)
 
                     Dim elementInfo As EmitInfo = Info.Clone(Me, True, False, Compiler.TypeCache.System_Int32)
                     For i As Integer = 0 To varC.Arguments.Count - 1
                         result = varC.Arguments(i).GenerateCode(elementInfo) AndAlso result
                         Emitter.EmitConversion(varC.Arguments(i).Expression.ExpressionType, Compiler.TypeCache.System_Int32, Info)
                         methodtypes.Add(Compiler.TypeCache.System_Int32)
                     Next
 
                     Dim rInfo As EmitInfo = Info.Clone(Me, True, False, elementtype)
                     methodtypes.Add(elementtype)
 
                     If CecilHelper.GetArrayRank(arrtype) = 1 Then
                         If isnonprimitivevaluetype Then
                             Emitter.EmitLoadElementAddress(Info, elementtype, arrtype)
                             'result = Info.RHSExpression.Classification.GenerateCode(rInfo) AndAlso result
                             'Emitter.EmitStoreObject(Info, elementtype)
                         Else
                             Emitter.EmitLoadElementAddress(Info, elementtype, arrtype)
                             'result = Info.RHSExpression.Classification.GenerateCode(rInfo) AndAlso result
                             'Emitter.EmitStoreElement(Info, elementtype, arrtype)
                         End If
                     Else
                         Dim method As Mono.Cecil.MethodReference = ArrayElementInitializer.GetAddressMethod(Compiler, arrtype)
                         Emitter.EmitCallVirt(Info, method)
                     End If
                 ElseIf varC.Expression IsNot Nothing Then
                     If TypeOf varC.Expression Is MeExpression Then
                         Dim local As Mono.Cecil.Cil.VariableDefinition
                         local = Emitter.DeclareLocal(Info, varC.Expression.ExpressionType)
                         Emitter.EmitLoadMe(Info, varC.Expression.ExpressionType)
                         Emitter.EmitStoreVariable(Info, local)
                         Emitter.EmitLoadVariableLocation(refInfo, local)
                     ElseIf TypeOf varC.Expression Is GetRefExpression AndAlso varC.Expression IsNot Me Then
                         result = varC.Expression.GenerateCode(Info) AndAlso result
                     Else
                         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
                     End If
                 ElseIf varC.Method IsNot Nothing Then
                     If varC.Method.DefaultReturnVariable Is Nothing Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
                     Else
                         Emitter.EmitLoadVariableLocation(refInfo, varC.Method.DefaultReturnVariable)
                     End If
                 Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
                 End If
             Case ExpressionClassification.Classifications.Value
                 result = m_Expression.GenerateCode(Info.Clone(Me, m_Expression.ExpressionType)) AndAlso result
 
                 Dim local As Mono.Cecil.Cil.VariableDefinition
                 local = Emitter.DeclareLocal(Info, m_Expression.ExpressionType)
                 Emitter.EmitStoreVariable(Info, local)
                 Emitter.EmitLoadVariableLocation(Info, local)
             Case ExpressionClassification.Classifications.PropertyAccess
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             Case ExpressionClassification.Classifications.MethodPointer
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             Case Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="335" endline="349">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The filename to report to the user in errors.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property FileNameToReport() As String
         Get
             If m_FileName.IndexOfAny(System.IO.Path.GetInvalidFileNameChars) >= 0 Then
                 Return m_FileName
             End If
             Return System.IO.Path.Combine(m_RelativePath, System.IO.Path.GetFileName(m_FileName))
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\StdToolMgr.vb" startline="456" endline="464">
<![CDATA[
 
     Private Sub lplaypos_Paint(ByVal sender As Object, _
 ByVal e As System.Windows.Forms.PaintEventArgs) Handles lplayPos.Paint
 
         Dim gr As Graphics = e.Graphics
         gr.DrawImageUnscaled(mBitMap, 0, 0)
         gr.DrawRectangle(mPen, mSliderPos, 2, mSliderW, lplayPos.Height - 6)
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="72" endline="87">
<![CDATA[
 
     ''' <summary>
     ''' The returned object will always be a function signature.
     ''' </summary>
     ''' <param name="NewParent"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overrides Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As SubSignature
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New FunctionSignature(NewParent)
         MyBase.CloneTo(result)
         If m_ReturnTypeAttributes IsNot Nothing Then result.m_ReturnTypeAttributes = m_ReturnTypeAttributes.clone(result)
         result.m_ReturnType = m_ReturnType
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="489" endline="502">
<![CDATA[
 
     Private Function CreateLabelForCurrentInstruction(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         If UpmostBlock.HasResume Then
             Dim index As Integer
             Dim lbl As Label = Emitter.DefineLabel(Info)
             UpmostBlock.UnstructuredExceptionLabels.Add(lbl)
             index = UpmostBlock.UnstructuredExceptionLabels.IndexOf(lbl)
             Emitter.MarkLabel(Info, lbl)
             Emitter.EmitLoadI4Value(Info, index)
             Emitter.EmitStoreVariable(Info, UpmostBlock.VB_CurrentInstruction)
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ParameterList.vb" startline="70" endline="80">
<![CDATA[
 
     ReadOnly Property AsParameterInfo() As Mono.Cecil.ParameterDefinition()
         Get
             If m_ParameterInfos Is Nothing Then
                 ReDim m_ParameterInfos(Me.Count - 1)
                 For i As Integer = 0 To Count - 1
                     m_ParameterInfos(i) = Me(i).CecilBuilder
                 Next
             End If
             Return m_ParameterInfos
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2104" endline="2112">
<![CDATA[
 
     Shared Function GenerateCodeCollection(ByVal Collection As IList, ByVal Info As EmitInfo, ByVal Types As Mono.Cecil.TypeReference()) As Boolean
         Dim result As Boolean = True
         Helper.Assert(Collection.Count = Types.Length)
         For i As Integer = 0 To Collection.Count - 1
             result = DirectCast(Collection(i), IBaseObject).GenerateCode(Info.Clone(Info.Context, Info.IsRHS, Info.IsExplicitConversion, Types(i))) AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\MRUbuffer.vb" startline="9" endline="23">
<![CDATA[
     Private mEnabled As Boolean
 
     Public Sub Add(ByVal Value As String)
         If Not mEnabled Then Exit Sub
         If Array.IndexOf(mList, Value) = -1 Then
             'move up items
             Dim i As Integer
             For i = mList.Length - 1 To 1 Step -1
                 mList(i) = mList(i - 1)
             Next
             'add the new item
             mList(0) = Value
             mLen = Math.Min(Count, mLen + 1)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="143" endline="157">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Creates a new default report.
     ''' </summary>
     ''' <remarks></remarks>
     Sub New(ByVal Compiler As Compiler)
     Private m_MessageCount(MessageLevel.Error) As Integer
 
     ''' <summary>
     ''' The max number of errors before quit compiling.
     ''' </summary>
     ''' <remarks></remarks>
     Const MAXERRORS As Integer = 100
 
     ''' <summary>
     ''' The resource manager for this report.
     ''' </summary>
     ''' <remarks></remarks>
     Private Shared m_Resources As ResourceManager
 
     ''' <summary>
     ''' A list of all the errors / warnings shown.
     ''' Messages are not added until they are shown
     ''' (if they are saved).
     ''' </summary>
     ''' <remarks></remarks>
     Private m_Messages As New ArrayList
 
     ''' <summary>
     ''' A list of all the saved errors / warnings to show.
     ''' </summary>
     ''' <remarks></remarks>
     Private m_SavedMessages As New ArrayList
 
     ''' <summary>
     ''' The executing compiler.
     ''' </summary>
     Private m_Compiler As Compiler
 
 
     Enum ReportLevels
         ''' <summary>
         ''' Always show the message.
         ''' </summary>
         ''' <remarks></remarks>
         Always
         ''' <summary>
         ''' Only show if verbose
         ''' </summary>
         ''' <remarks></remarks>
         Verbose
         ''' <summary>
         ''' Only show in debug builds
         ''' </summary>
         ''' <remarks></remarks>
         Debug
     End Enum
 
     Private m_ReportLevel As ReportLevels = ReportLevels.Debug
     Private m_Listeners As New Generic.List(Of Diagnostics.TraceListener)
 
     ''' <summary>
     ''' The listeners who will receive text output.
     ''' A console writer is here by default.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property Listeners() As Generic.List(Of Diagnostics.TraceListener)
         Get
             Return m_Listeners
         End Get
     End Property
 
     Sub Write(ByVal Level As ReportLevels, Optional ByVal Value As String = "")
         If Level <= m_ReportLevel Then
             Write(Value)
         End If
     End Sub
 
     Sub Write(Optional ByVal Value As String = "")
         For Each d As Diagnostics.TraceListener In m_Listeners
             d.Write(Value)
         Next
         Console.Write(Value)
     End Sub
 
     Sub Indent()
         For Each d As Diagnostics.TraceListener In m_Listeners
             d.IndentLevel += 1
         Next
     End Sub
 
     Sub Unindent()
         For Each d As Diagnostics.TraceListener In m_Listeners
             d.IndentLevel -= 1
         Next
     End Sub
 
     Sub WriteLine(ByVal Level As ReportLevels, Optional ByVal Value As String = "")
         Write(Level, Value & VB.vbNewLine)
     End Sub
 
     Sub WriteLine(Optional ByVal Value As String = "")
         Write(Value & VB.vbNewLine)
     End Sub
 
     ''' <summary>
     ''' The executing compiler.
     ''' </summary>
     ReadOnly Property Compiler() As Compiler
         Get
             Return m_Compiler
         End Get
     End Property
 
     ''' <summary>
     ''' Creates a new default report.
     ''' </summary>
     ''' <remarks></remarks>
     Sub New(ByVal Compiler As Compiler)
         m_Compiler = Compiler
         'm_Listeners.Add(New System.Diagnostics.TextWriterTraceListener(Console.Out))
 #If DEBUG Then
         For Each i As Diagnostics.TraceListener In System.Diagnostics.Debug.Listeners
             m_Listeners.Add(i)
         Next
 #End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeImplementsClauses.vb" startline="149" endline="168">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If Me.IsArrayTypeName Then
             result = Me.AsArrayTypeName.ResolveTypeReferences AndAlso result
             m_ResolvedType = Me.AsArrayTypeName.ResolvedType
         ElseIf Me.IsNonArrayTypeName Then
             result = Me.AsNonArrayTypeName.ResolveTypeReferences AndAlso result
             m_ResolvedType = Me.AsNonArrayTypeName.ResolvedType
         ElseIf m_ResolvedType Is Nothing Then
             Throw New InternalException(Me)
         End If
 
         If result = False Then Return result
 
         Helper.Assert(m_ResolvedType IsNot Nothing)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="105" endline="132">
<![CDATA[
 
     ''' <summary>
     ''' Adds a namespace and all its variants
     ''' (i.e. for System.Xml it adds System and System.Xml)
     ''' </summary>
     ''' <param name="ns"></param>
     ''' <param name="IsGlobal"></param>
     ''' <remarks></remarks>
     Sub AddAllNamespaces(ByVal Parent As BaseObject, ByVal ns As String, ByVal IsGlobal As Boolean)
         If ns = String.Empty Then Return
 
         If Me.ContainsKey(ns) Then Return
 
         Add(Parent, ns, IsGlobal)
 
         Dim idx As Integer = ns.LastIndexOf("."c)
         If idx < 0 Then Return
 
         Dim tmp As String = ns
         Do
             tmp = tmp.Substring(0, idx)
             If Me.ContainsKey(tmp) Then Return
 
             Add(Parent, tmp, IsGlobal)
 
             idx = tmp.LastIndexOf("."c)
         Loop While idx >= 0
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3189" endline="3211">
<![CDATA[
 
     Private Function ParseMultDiv(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseUnaryPlusMinus(Info)
 
         While tm.CurrentToken.Equals(KS.Mult, KS.RealDivision)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             tm.AcceptNewLine()
             rSide = ParseUnaryPlusMinus(Info)
             If op = KS.Mult Then
                 lSide = New MultExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.RealDivision Then
                 lSide = New RealDivisionExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.Mult, KS.RealDivision)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             tm.AcceptNewLine()
             rSide = ParseUnaryPlusMinus(Info)
             If op = KS.Mult Then
                 lSide = New MultExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.RealDivision Then
                 lSide = New RealDivisionExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3240" endline="3263">
<![CDATA[
 
     Private Function ParsePlusMinus(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseMod(Info)
 
         While tm.CurrentToken.Equals(KS.Add, KS.Minus)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             tm.AcceptNewLine()
             rSide = ParseMod(Info)
             If op = KS.Add Then
                 lSide = New BinaryAddExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Minus Then
                 lSide = New BinarySubExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.Add, KS.Minus)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             tm.AcceptNewLine()
             rSide = ParseMod(Info)
             If op = KS.Add Then
                 lSide = New BinaryAddExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Minus Then
                 lSide = New BinarySubExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
 
         Return lSide
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3278" endline="3300">
<![CDATA[
 
     Private Function ParseBitshift(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseConcat(Info)
 
         While tm.CurrentToken.Equals(KS.ShiftRight, KS.ShiftLeft)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             tm.AcceptNewLine()
             rSide = ParseConcat(Info)
             If op = KS.ShiftRight Then
                 lSide = New RShiftExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.ShiftLeft Then
                 lSide = New LShiftExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.ShiftRight, KS.ShiftLeft)
             Dim op As KS
             op = tm.CurrentToken.Symbol
             tm.NextToken()
             tm.AcceptNewLine()
             rSide = ParseConcat(Info)
             If op = KS.ShiftRight Then
                 lSide = New RShiftExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.ShiftLeft Then
                 lSide = New LShiftExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3358" endline="3380">
<![CDATA[
 
     Private Function ParseAnd_AndAlso(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseNot(Info)
 
         While tm.CurrentToken.Equals(KS.And, KS.AndAlso)
             Dim op As KS
             op = tm.CurrentToken.Keyword
             tm.NextToken()
             tm.AcceptNewLine()
             rSide = ParseNot(Info)
             If op = KS.And Then
                 lSide = New AndExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.AndAlso Then
                 lSide = New AndAlsoExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.And, KS.AndAlso)
             Dim op As KS
             op = tm.CurrentToken.Keyword
             tm.NextToken()
             tm.AcceptNewLine()
             rSide = ParseNot(Info)
             If op = KS.And Then
                 lSide = New AndExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.AndAlso Then
                 lSide = New AndAlsoExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" startline="163" endline="192">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The complete name for this qualified identifier.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property Name() As String
         Get
             If m_Name Is Nothing Then
                 m_Name = String.Empty
                 If m_First IsNot Nothing Then
                     Dim id As Identifier = TryCast(m_First, Identifier)
                     Dim qid As QualifiedIdentifier = TryCast(m_First, QualifiedIdentifier)
                     If id IsNot Nothing Then
                         m_Name = id.Name
                     ElseIf qid IsNot Nothing Then
                         m_Name = qid.Name
                     Else
                         m_Name = m_First.ToString
                     End If
                 Else
                     Throw New InternalException(Me)
                 End If
                 If Token.IsSomething(m_Second) Then
                     m_Name = m_Name & "." & m_Second.ToString
                 End If
             End If
             Return m_Name
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5805" endline="5842">
<![CDATA[
 
     ''' <summary>
     ''' ElseIfStatement  
     '''	   "ElseIf" BooleanExpression  [  Then  ]  StatementTerminator
     '''	        [  Block  ]
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseElseIfStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As ElseIfStatement
         Dim result As New ElseIfStatement(Parent)
 
         Dim m_Condition As Expression
         Dim m_Code As CodeBlock
 
         If tm.Accept(KS.Else) Then
             'This is not in the spec, but MS is accepting it anyway.
             'See test Bugs/aspnet2.vb for a test case.
             tm.AcceptIfNotInternalError(KS.If)
         Else
             tm.AcceptIfNotInternalError(KS.ElseIf)
         End If
         m_Condition = ParseExpression(result)
         If m_Condition Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         'ElseIf cannot be a oneliner...
         tm.Accept(KS.Then) '"Then" is not required.
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If IsOneLiner Then
             Helper.AddError(Compiler, tm.CurrentLocation)
             'TODO
         End If
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Code, m_Condition)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="23" endline="70">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim opType As TypeCode = MyBase.OperandTypeCode
 
         ValidateBeforeGenerateCode(Info)
 
         Select Case opType
             Case TypeCode.Boolean, TypeCode.Object
                 If opType = TypeCode.Object Then
                     Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 End If
 
                 Dim loadfalse, loadtrue, endexp As Label
                 loadfalse = Emitter.DefineLabel(Info)
                 loadtrue = Emitter.DefineLabel(Info)
                 endexp = Emitter.DefineLabel(Info)
 
                 result = m_LeftExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfFalse(Info, loadfalse)
 
                 result = m_RightExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 Emitter.MarkLabel(Info, loadfalse) '
                 Emitter.EmitLoadValue(Info, False) 'Load false value
                 Emitter.EmitBranch(Info, endexp)
 
                 Emitter.MarkLabel(Info, loadtrue)
                 Emitter.EmitLoadValue(Info, True) 'Load true value
 
                 Emitter.MarkLabel(Info, endexp) 'The end of the expression
                
                 If opType = TypeCode.Object Then
                     Emitter.EmitBox(Info, Compiler.TypeCache.System_Boolean)
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="23" endline="70">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim opType As TypeCode = MyBase.OperandTypeCode
 
         ValidateBeforeGenerateCode(Info)
 
         Select Case opType
             Case TypeCode.Boolean, TypeCode.Object
                 If opType = TypeCode.Object Then
                     Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 End If
 
                 Dim loadfalse, loadtrue, endexp As Label
                 loadfalse = Emitter.DefineLabel(Info)
                 loadtrue = Emitter.DefineLabel(Info)
                 endexp = Emitter.DefineLabel(Info)
 
                 result = m_LeftExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfFalse(Info, loadfalse)
 
                 result = m_RightExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 Emitter.MarkLabel(Info, loadfalse) '
                 Emitter.EmitLoadValue(Info, False) 'Load false value
                 Emitter.EmitBranch(Info, endexp)
 
                 Emitter.MarkLabel(Info, loadtrue)
                 Emitter.EmitLoadValue(Info, True) 'Load true value
 
                 Emitter.MarkLabel(Info, endexp) 'The end of the expression
                
                 If opType = TypeCode.Object Then
                     Emitter.EmitBox(Info, Compiler.TypeCache.System_Boolean)
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="23" endline="70">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim opType As TypeCode = MyBase.OperandTypeCode
 
         ValidateBeforeGenerateCode(Info)
 
         Select Case opType
             Case TypeCode.Boolean, TypeCode.Object
                 If opType = TypeCode.Object Then
                     Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 End If
 
                 Dim loadfalse, loadtrue, endexp As Label
                 loadfalse = Emitter.DefineLabel(Info)
                 loadtrue = Emitter.DefineLabel(Info)
                 endexp = Emitter.DefineLabel(Info)
 
                 result = m_LeftExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfFalse(Info, loadfalse)
 
                 result = m_RightExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 Emitter.MarkLabel(Info, loadfalse) '
                 Emitter.EmitLoadValue(Info, False) 'Load false value
                 Emitter.EmitBranch(Info, endexp)
 
                 Emitter.MarkLabel(Info, loadtrue)
                 Emitter.EmitLoadValue(Info, True) 'Load true value
 
                 Emitter.MarkLabel(Info, endexp) 'The end of the expression
                
                 If opType = TypeCode.Object Then
                     Emitter.EmitBox(Info, Compiler.TypeCache.System_Boolean)
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3762" endline="3798">
<![CDATA[
 
     ''' <summary>
     ''' Tries to parse a sub signature. Returns false if not successful.
     ''' SubSignature  
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="m_Identifier">Output parameter, must be nothing on entry.</param>
     ''' <param name="m_TypeParameters">Output parameter, must be nothing on entry.</param>
     ''' <param name="m_ParameterList">Input/Output parameter, must not be nothing on entry.</param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseSubSignature(ByVal Parent As ParsedObject, ByRef m_Identifier As Identifier, ByRef m_TypeParameters As TypeParameters, ByVal m_ParameterList As ParameterList) As Boolean
         Dim result As Boolean = True
 
         'Helper.Assert(m_Identifier Is Nothing)
         Helper.Assert(m_TypeParameters Is Nothing)
         Helper.Assert(m_ParameterList IsNot Nothing)
 
         m_Identifier = ParseIdentifier(Parent)
         result = m_Identifier IsNot Nothing AndAlso result
 
         If vbnc.TypeParameters.IsMe(tm) Then
             m_TypeParameters = ParseTypeParameters(Parent)
         End If
         If tm.Accept(KS.LParenthesis) Then
             If tm.Accept(KS.RParenthesis) = False Then
                 If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
                 result = tm.AcceptIfNotError(KS.RParenthesis) AndAlso result
             End If
         End If
 
         'Helper.Assert(m_Identifier IsNot Nothing)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="937" endline="958">
<![CDATA[
     End Property
 
     Private Sub CollectGenericParameters(ByVal Type As GenericInstanceType, ByVal Find As Mono.Collections.Generic.Collection(Of GenericParameter), ByRef collected As Generic.List(Of GenericParameter))
         Dim elementType As GenericInstanceType
 
         If Type Is Nothing Then Return
 
         If Type.HasGenericArguments Then
             For i As Integer = 0 To Find.Count - 1
                 If Type.GenericArguments.Contains(Find(i)) Then
                     If collected Is Nothing Then collected = New Generic.List(Of GenericParameter)
                     If collected.Contains(Find(i)) Then Continue For
                     collected.Add(Find(i))
                 End If
             Next
         End If
 
         elementType = TryCast(Type.GetElementType(), GenericInstanceType)
         If elementType IsNot Nothing AndAlso elementType IsNot Type Then
             CollectGenericParameters(elementType, Find, collected)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="4461" endline="4487">
<![CDATA[
 
     Private mAudioMaxPos As Double
     Private mAudioMinPos As Double
     Private Const mAudioDet As Integer = 10     'the width of the detail window
 
     Private Sub DrawWavePosition()
 
         Dim p As New Pen(Color.Red)
 
         Dim Dur As Double = mAudioWF.FramesToRender / 100
         Dim Curr As Double = mPlayer.Ctlcontrols.currentPosition
 
         If (Curr > mAudioMaxPos) Or (Curr < mAudioMinPos) Then
             mAudioMaxPos = Math.Min(Dur, Curr + mAudioDet)
             mAudioMinPos = Math.Max(0, mAudioMaxPos - mAudioDet)
             picAudioDetail.BackgroundImage = mAudioWF.CreateBitmap(picAudioDetail.Width, picAudioDetail.Height, _
             mAudioWF.Position2Frames(mAudioMinPos), mAudioWF.Position2Frames(mAudioMaxPos), True)
         End If
 
         DrawPos(picAudioSumm, p, Curr / Dur)
         DrawPos(picAudioDetail, p, (Curr - mAudioMinPos) / (mAudioMaxPos - mAudioMinPos))
 
         If Not p Is Nothing Then
             p.Dispose()
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5880" endline="5919">
<![CDATA[
 
     ''' <summary>
     ''' CaseStatement  
     '''	   "Case" CaseClauses  StatementTerminator
     '''	        [  Block  ]
     ''' CaseElseStatement  
     '''	   "Case" "Else" StatementTerminator
     '''	   [  Block  ]
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseCaseStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As CaseStatement
         Dim result As New CaseStatement(Parent)
 
         Dim m_IsElse As Boolean
         Dim m_Clauses As CaseClauses
         Dim m_Block As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.Case)
         If tm.Accept(KS.Else) Then
             m_IsElse = True
             m_Clauses = Nothing
         Else
             m_Clauses = New CaseClauses(result)
             If ParseList(Of CaseClause)(m_Clauses, New ParseDelegate_Parent(Of CaseClause)(AddressOf ParseCaseClause), result) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End If
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         End If
 
         m_Block = ParseCodeBlock(result, IsOneLiner)
         If m_Block Is Nothing Then
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         End If
 
         result.Init(m_IsElse, m_Clauses, m_Block)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3727" endline="3761">
<![CDATA[
 
     ''' <summary>
     ''' PropertyGetDeclaration  
     '''	[  Attributes  ]  [  AccessModifier  ]  Get  LineTerminator
     '''	[  Block  ]
     '''	End  Get  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParsePropertyGetMember(ByVal Parent As PropertyDeclaration, ByVal Info As ParseAttributableInfo, ByVal ParentSignature As FunctionSignature, ByVal ParentImplements As MemberImplementsClause, ByVal ParentModifiers As ModifierMasks) As PropertyGetDeclaration
         Dim result As New PropertyGetDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_Block As CodeBlock
 
         m_Modifiers = ParseModifiers(ModifierMasks.AccessModifiers)
         If m_Modifiers.Empty = False Then
             m_Modifiers.AddModifiers(ParentModifiers And (Not ModifierMasks.AccessModifiers))
         Else
             m_Modifiers.AddModifiers(ParentModifiers)
         End If
 
         tm.AcceptIfNotInternalError(KS.Get)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Block = ParseCodeBlock(result, False)
         If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Get) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, ParentImplements, m_Block)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\AssignStatements\CompoundAssignmentStatement.vb" startline="91" endline="101">
<![CDATA[
 
     Friend NotOverridable Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         'result = m_CompoundExpression.GenerateCode(Info.Clone(True, False, LSide.ExpressionType)) AndAlso result
 
         Dim lInfo As EmitInfo = Info.Clone(Me, m_CompoundExpression)
         result = LSide.Classification.GenerateCode(lInfo) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2181" endline="2188">
<![CDATA[
 
 
     <Diagnostics.DebuggerHidden()> Shared Function AddError(ByVal Compiler As Compiler, ByVal Location As Span, Optional ByVal Message As String = Nothing) As Boolean
         If Message Is Nothing Then
             Message = "<no message written yet>"
         End If
         Return Compiler.Report.ShowMessage(Messages.VBNC99999, Location, Message)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="90" endline="107">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Dim lst As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
 
         lst = Compiler.TypeManager.GetCache(m_ResolvedType).LookupFlattenedMembers(m_2.Name)
         'If lst.Count = 0 AndAlso m_ResolvedType.IsInterface Then
         '    lst.AddRange(Compiler.TypeManager.GetCache(m_ResolvedType).LookupMembersFlattened(m_2.Name))
         'End If
         m_ResolvedMember = MethodGroupClassification.ResolveInterfaceGroup(lst, Me.FindFirstParent(Of IMember))
         If m_ResolvedMember Is Nothing Then
             Helper.AddError(Me, "Implemented method has not the same signature as the interface method")
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="688" endline="701">
<![CDATA[
 
     Private Function ParseIdentifierOrKeyword(ByVal Parent As ParsedObject) As IdentifierOrKeyword
         Dim result As IdentifierOrKeyword
 
         If tm.CurrentToken.IsIdentifierOrKeyword Then
             result = New IdentifierOrKeyword(Parent, tm.CurrentToken)
             tm.NextToken()
         Else
             Helper.AddError(Compiler, tm.CurrentLocation)
             result = Nothing
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\MainForm.cs" startline="281" endline="293">
<![CDATA[
 
 		private void SetupContextMenu()
 		{
 			//view context menu
 			fobViewContextMenu = new ContextMenu();
 			MenuItem authorizeMenuItem = new MenuItem("Authorize Fob");
 			MenuItem unauthorizeFobMenuItem = new MenuItem("Unauthorize Fob");
 			authorizeMenuItem.Click += new EventHandler(authorizeMenuItem_Click);
 			unauthorizeFobMenuItem.Click += new EventHandler(unauthorizeFobMenuItem_Click);
 			fobViewContextMenu.MenuItems.Add(authorizeMenuItem);
 			fobViewContextMenu.MenuItems.Add(unauthorizeFobMenuItem);
 			keyFobView.ContextMenu = fobViewContextMenu;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\TryCastExpression.vb" startline="30" endline="43">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = Expression.GenerateCode(Info.Clone(Me, ExpressionType)) AndAlso result
 
         If CecilHelper.IsGenericParameter(Expression.ExpressionType) Then
             Emitter.EmitBox(Info, Expression.ExpressionType)
         End If
 
         Emitter.EmitIsInst(Info, Expression.ExpressionType, ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AliasClause.vb" startline="211" endline="224">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ResolvedType Is Nothing Then
             Helper.Assert(m_SimpleTypeName IsNot Nothing, "SimpleTypeName Is Nothing
             result = m_SimpleTypeName.ResolveTypeReferences(True) AndAlso result
             m_ResolvedType = m_SimpleTypeName.ResolvedType
         End If
         result = m_ResolvedType IsNot Nothing AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5574" endline="5590">
<![CDATA[
 
     Private Function ParseDoStatementCondition(ByVal Parent As ParsedObject, ByRef IsWhile As Boolean) As Expression
         Dim result As Expression = Nothing
 
         If tm.Accept(KS.While) Then
             IsWhile = True
             result = ParseExpression(Parent)
         ElseIf tm.Accept(KS.Until) Then
             IsWhile = False
             result = ParseExpression(Parent)
         Else
             Throw New InternalException(result)
         End If
         If result Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4539" endline="4564">
<![CDATA[
 
     ''' <summary>
     ''' InterfaceSubDeclaration  
     ''' [  Attributes  ]  [  InterfaceProcedureModifier+  ]  "Sub" SubSignature  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInterfaceSubDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As InterfaceSubDeclaration
         Dim result As New InterfaceSubDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As SubSignature = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.InterfaceProcedureModifiers)
 
         tm.AcceptIfNotInternalError(KS.Sub)
 
         m_Signature = ParseSubSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\BoundList.vb" startline="42" endline="54">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_Expressions.Length - 1
             result = m_Expressions(i).ResolveExpression(Info) AndAlso result
             If result Then
                 m_Expressions(i) = Helper.CreateTypeConversion(Me, m_Expressions(i), Compiler.TypeCache.System_Int32, result)
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3907" endline="3929">
<![CDATA[
 
 #End Region
 
 #Region "   Process events and RTF updates "
 
     Public Sub MessageRecd(ByVal sender As Object, _
     ByVal ea As AsyncOps.DataReceivedEventArgs)
         If ea.Type = "S" Then
             If ea.Text Is Nothing Then
                 UpdateRTF(StrStd.ToString, modMain.MessageType.AsUsual)
                 StrStd.Length = 0
             Else
                 BufferOutput(ea.Text, False)
             End If
         Else
             If ea.Text Is Nothing Then
                 UpdateRTF(StrErr.ToString, modMain.MessageType.Failure)
                 StrErr.Length = 0
             Else
                 BufferOutput(ea.Text, True)
             End If
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MyGenerator.vb" startline="90" endline="104">
<![CDATA[
 
     Function StartsWith(ByVal str As String) As Boolean
         Helper.Assert(m_Name IsNot Nothing AndAlso m_Name <> "")
         Helper.Assert(str IsNot Nothing AndAlso str <> "")
         If str.Length <= m_Name.Length Then
             If m_Global AndAlso IsGlobal(str) Then
                 str = RemoveGlobal(str)
                 Return Helper.CompareName(str, m_Name.Substring(0, str.Length))
             Else
                 Return Helper.CompareName(str, m_Name.Substring(0, str.Length))
             End If
         Else
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="98" endline="119">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If Classification IsNot Nothing Then Return True
 
         result = m_Expression.ResolveExpression(New ResolveInfo(Info.Compiler, True)) AndAlso result
 
         If result = False Then Return False
 
         If m_Expression.Classification.IsMethodGroupClassification Then
             Dim mpClassification As MethodPointerClassification
             mpClassification = New MethodPointerClassification(Me, m_Expression.Classification.AsMethodGroupClassification)
             Classification = mpClassification
 
             m_ExpressionType = Info.Compiler.TypeCache.DelegateUnresolvedType
         Else
             Helper.AddError(Me, Me.Location.ToString(Compiler))
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="1778" endline="1814">
<![CDATA[
 
     ''' <summary>
     ''' RegularEventMemberDeclaration  
     ''' 	[  Attributes  ]  [  EventModifiers+  ]  "Event"  Identifier  ParametersOrType  [  ImplementsClause  ] StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseRegularEventDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As RegularEventDeclaration
         Dim result As New RegularEventDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_ParametersOrType As ParametersOrType
         Dim m_ImplementsClause As MemberImplementsClause
 
         m_Modifiers = ParseModifiers(ModifierMasks.EventModifiers)
 
         tm.AcceptIfNotInternalError(KS.Event)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_ParametersOrType = ParseParametersOrType(result)
 
         If MemberImplementsClause.IsMe(tm) Then
             m_ImplementsClause = ParseImplementsClause(result)
             If m_ImplementsClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_ImplementsClause = Nothing
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Identifier, m_ParametersOrType, m_ImplementsClause)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ReturnStatement.vb" startline="49" endline="71">
<![CDATA[
 
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Expression IsNot Nothing Then
             result = m_Expression.ResolveExpression(info) AndAlso result
             If result AndAlso m_Expression.Classification.IsValueClassification = False Then
                 m_Expression = m_Expression.ReclassifyToValueExpression
                 result = m_Expression.ResolveExpression(Info) AndAlso result
             End If
         End If
 
         If result = False Then Return result
 
         If m_Expression IsNot Nothing Then
             Dim method As IMethod
             method = Me.FindFirstParent(Of IMethod)()
             m_Expression = Helper.CreateTypeConversion(Me, m_Expression, method.Signature.ReturnType, result)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ResumeStatement.vb" startline="32" endline="69">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim ResumeOK As Label = Emitter.DefineLabel(Info)
 
         Dim block As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
         Dim lastblock As CodeBlock = block
         Do Until lastblock Is Nothing
             block = lastblock
             lastblock = block.FindFirstParent(Of CodeBlock)()
         Loop
         Do Until lastblock Is Nothing
             block = lastblock
             lastblock = block.FindFirstParent(Of CodeBlock)()
         Loop
 
         'Clear the error.
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__ClearProjectError)
 
         'Test if the code is in an exception handler
         Emitter.EmitLoadVariable(Info, block.VB_ResumeTarget)
         Emitter.EmitBranchIfTrue(Info, ResumeOK)
 
         'If code is not in an exception handler raise an error
         Emitter.EmitLoadI4Value(Info, -2146828268)
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__CreateProjectError_Int32)
         Emitter.EmitThrow(Info)
 
         Emitter.MarkLabel(Info, ResumeOK)
         'Load the instruction switch index
         Emitter.EmitLoadVariable(Info, block.VB_CurrentInstruction)
         'Increment the instruction pointer if it is a Resume Next statement
         If m_IsResumeNext Then
             Emitter.EmitLoadI4Value(Info, 1)
             Emitter.EmitAdd(Info, Compiler.TypeCache.System_Int32)
         End If
         'If everything is ok, jump to the instruction switch (adding one to the instruction if necessary)
         Emitter.EmitLeave(Info, block.UnstructuredResumeHandler)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="69" endline="89">
<![CDATA[
 
     Public Overrides Function CreateDefinition() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.CreateDefinition AndAlso result
 
         Helper.Assert(m_CecilBuilder Is Nothing)
         m_CecilBuilder = New Mono.Cecil.MethodDefinition(Name, 0, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Void))
         m_CecilBuilder.Annotations.Add(Compiler, Me)
         m_CecilBuilder.Name = Name
         m_CecilBuilder.HasThis = Not Me.IsShared
         m_CecilBuilder.DeclaringType = DeclaringType.CecilType
 
         DeclaringType.CecilType.Methods.Add(CecilBuilder)
 
         If m_Signature IsNot Nothing Then result = m_Signature.CreateDefinition AndAlso result
 
         MethodAttributes = Helper.GetAttributes(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="6333" endline="6381">
<![CDATA[
 
     ''' <summary>
     ''' DelegateDeclaration  
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" MethodSignature  StatementTerminator
     ''' MethodSignature  
     ''' 
     ''' LAMESPEC
     ''' [  Attributes  ]  [  TypeModifier+  ]  "Delegate" FunctionOrSub MethodSignature  StatementTerminator
     ''' FunctionOrSub 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDelegateDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As DelegateDeclaration
         Dim result As DelegateDeclaration
 
         Dim Modifiers As Modifiers
         Dim m_Signature As SubSignature
         Dim isSub As Boolean
 
         Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Delegate)
 
         If tm.Accept(KS.Function) Then
             isSub = False
         ElseIf tm.Accept(KS.Sub) Then
             isSub = True
         Else
             Throw New InternalException(Parent)
         End If
 
         If isSub Then
             m_Signature = ParseSubSignature(Parent)
         Else
             m_Signature = ParseFunctionSignature(Parent)
         End If
 
         result = New DelegateDeclaration(Parent, [Namespace], m_Signature)
 
         m_Signature.Parent = result
 
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
         result.Modifiers = Modifiers
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2363" endline="2387">
<![CDATA[
 
     Private Sub Timer_Tick(ByVal sender As Object, _
 ByVal e As System.EventArgs) Handles Timer.Tick
 
         If mIsAudio Then DrawWavePosition()
         If mPlaySelected Then
             If mPlayer.Ctlcontrols.currentPosition >= mPlaySegments(mPlaySelIndex).Finish Then
                 If UBound(mPlaySegments) > mPlaySelIndex Then
                     mPlaySelIndex += 1
                     mPlayer.Ctlcontrols.currentPosition = mPlaySegments(mPlaySelIndex).Start
                 Else
                     If mRepeatPlay Then
                         mPlaySelIndex = 0
                         mPlayer.Ctlcontrols.currentPosition = _
                             mPlaySegments(mPlaySelIndex).Start
                     Else
                         mPlayer.Ctlcontrols.stop()
                         mPlaySelected = False
                         Timer.Enabled = False
                     End If
                 End If
             End If
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="124" endline="150">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Event.ResolveExpression(Info) AndAlso result
         result = m_EventHandler.ResolveExpression(info) AndAlso result
 
         If result = False Then Return result
 
         Dim delegatetp As Mono.Cecil.TypeReference = m_Event.Classification.AsEventAccess.Type
 
         If m_EventHandler.Classification.IsMethodPointerClassification Then
             'result = m_EventHandler.Classification.AsMethodPointerClassification.Resolve(delegatetp) AndAlso result
             m_EventHandler = m_EventHandler.ReclassifyMethodPointerToValueExpression(delegatetp)
             result = m_EventHandler.ResolveExpression(Info) AndAlso result
             'result = Helper.VerifyValueClassification(m_EventHandler, Info) AndAlso result
         ElseIf m_EventHandler.Classification.IsValueClassification = False AndAlso m_EventHandler.Classification.CanBeValueClassification Then
             m_EventHandler = m_EventHandler.ReclassifyToValueExpression()
             result = m_EventHandler.ResolveExpression(Info) AndAlso result
         End If
 
         Helper.Assert(m_EventHandler.Classification.IsValueClassification)
 
         Compiler.Helper.AddCheck("The first argument must be an expression that is classified as an event access and the second argument must be an expression that is classified as a value. ")
         Compiler.Helper.AddCheck("The second argument's type must be the delegate type associated with the event access.")
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="46" endline="74">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         result = m_LeftExpression.GenerateCode(expInfo) AndAlso result
         result = m_RightExpression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Byte, TypeCode.SByte, TypeCode.Boolean
                 Emitter.EmitAddOrAddOvf(Info, OperandType)
             Case TypeCode.Double, TypeCode.Single
                 Emitter.EmitAdd(Info, OperandType)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Add_Decimal_Decimal)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__AddObject_Object_Object)
             Case TypeCode.String
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_String__Concat_String_String)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="545" endline="551">
<![CDATA[
 
     Private Function StringBuilderToString() As String
         Dim result As String
         result = New String(m_StringBuilder, 0, m_StringBuilderLength)
         m_StringBuilderLength = 0
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Index.vb" startline="62" endline="78">
<![CDATA[
 
     ''' <summary>
     ''' Looks an list of all TypeBase objects which has the specified Name. 
     '''	If no TypeBase found, returns nothing
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <value></value>
     ''' <remarks></remarks>
     Shadows ReadOnly Property Item(ByVal Name As String) As Generic.List(Of INameable)
         Get
             'Name = Name.ToLower
             If m_lstCollections.ContainsKey(Name) Then
                 Return m_lstCollections.Item(Name).Values
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="274" endline="283">
<![CDATA[
 
     Public Function DeclareLocal(ByVal localType As Mono.Cecil.TypeReference) As Mono.Cecil.Cil.VariableDefinition
         Helper.Assert(Helper.IsEmittableMember(Compiler, localType))
         Log("DeclareLocal({0})", localType.ToString)
         Dim local As Mono.Cecil.Cil.VariableDefinition
         local = New Mono.Cecil.Cil.VariableDefinition(localType)
         m_CilBody.Variables.Add(local)
         m_CilBody.InitLocals = True
         Return local
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="1292" endline="1300">
<![CDATA[
     End Property
 
     Private Function PeekChar() As Char
         If m_PeekedChars.Count = 0 Then
             If m_Reader.EndOfStream Then Return nl0
             m_PeekedChars.Enqueue(Convert.ToChar(m_Reader.Read))
         End If
         Return m_PeekedChars.Peek()
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4799" endline="4814">
<![CDATA[
 
     ''' <summary>
     ''' LocalDeclarationStatement  
     ''' </summary>
     Private Function ParseLocalDeclarationStatement(ByVal Parent As CodeBlock) As Generic.List(Of LocalVariableDeclaration)
         Dim result As Generic.List(Of LocalVariableDeclaration)
 
         Dim m_Modifiers As Modifiers
 
         m_Modifiers = ParseModifiers(ModifierMasks.LocalModifiers)
 
         result = ParseLocalVariableDeclarators(Parent, m_Modifiers, New ParseAttributableInfo(Compiler, Nothing))
         If result Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="330" endline="338">
<![CDATA[
 
     Private Function CheckEmtpyStack(Optional ByVal Msg As Messages = Messages.VBNC30013) As Boolean
         If m_ConditionStack.Count > 0 Then Return True
 
         Compiler.Report.ShowMessage(Msg, GetCurrentLocation)
         EatLine(False)
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="360" endline="371">
<![CDATA[
 
     Public Overridable Function DefineTypeHierarchy() As Boolean
         Dim result As Boolean = True
 
         If BaseType Is Nothing Then
             If Me.IsInterface = False Then
                 m_CecilType.BaseType = Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Void)
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="285" endline="302">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <param name="Message"></param>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptIfNotError(ByVal Special As KS, ByVal Message As Messages, Optional ByVal GotoNewline As Boolean = False) As Boolean
         If Accept(Special) Then
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Compiler.Report.ShowMessage(Message, CurrentLocation)
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="368" endline="380">
<![CDATA[
     End Property
 
     Function VerifyGroup(ByVal Arguments As ArgumentList, ByVal ShowErrors As Boolean) As Boolean
         Dim result As Boolean = True
 
         If IsLateBound = False Then
             result = Arguments.ReplaceAndVerifyArguments(FinalArguments, ResolvedMethod, ShowErrors) AndAlso result
         End If
 
         result = VerifyConstraints(ShowErrors) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1868" endline="1880">
<![CDATA[
 
     Shared Sub EmitStoreVariable(ByVal Info As EmitInfo, ByVal Variable As Mono.Cecil.ParameterDefinition)
         Dim position As Integer = GetParameterPosition(Info, Variable)
         If CecilHelper.IsByRef(Variable.ParameterType) Then
             If CecilHelper.IsGenericParameter(CecilHelper.GetElementType(Variable.ParameterType)) Then
                 EmitStoreObject(Info, CecilHelper.GetElementType(Variable.ParameterType))
             Else
                 EmitStoreIndirect(Info, Variable.ParameterType)
             End If
         Else
             Info.ILGen.Emit(OpCodes.Starg, position)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="220" endline="234">
<![CDATA[
 
     Private Function EmitStoreCounter(ByVal Info As EmitInfo, ByVal Data As LoopCounterData) As Boolean
         Dim result As Boolean = True
         Select Case Data.Type
             Case LoopCounterTypes.Array
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Case LoopCounterTypes.Field
                 Emitter.EmitStoreField(Info, Data.FieldInfo)
             Case LoopCounterTypes.Local
                 Emitter.EmitStoreVariable(Info, Data.LocalBuilder)
             Case Else
                 Throw New InternalException("Unknown LoopCounterType
         End Select
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="399" endline="411">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Compiler.Report.Trace("{0}
 
         result = MyBase.ResolveCode(Info) AndAlso result
         Compiler.VerifyConsistency(result, Location)
         result = m_Members.ResolveCode(Info) AndAlso result
         'vbnc.Helper.Assert(result = (Compiler.Report.Errors = 0))
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AliasClause.vb" startline="124" endline="136">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Attribute
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New Attribute(NewParent)
         result.m_IsAssembly = m_IsAssembly
         result.m_IsModule = m_IsModule
         If m_SimpleTypeName IsNot Nothing Then result.m_SimpleTypeName = m_SimpleTypeName
         If m_AttributeArguments IsNot Nothing Then result.m_AttributeArguments = m_AttributeArguments
         result.m_ResolvedType = m_ResolvedType
         result.m_ResolvedTypeConstructor = m_ResolvedTypeConstructor
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1805" endline="1820">
<![CDATA[
 
     Shared Sub EmitLoadVariable(ByVal Info As EmitInfo, ByVal Variable As Mono.Cecil.FieldReference)
         Dim fD As Mono.Cecil.FieldDefinition = CecilHelper.FindDefinition(Variable)
 
         Variable = Emitter.GetFieldRef(Variable)
         Variable = Helper.GetFieldOrFieldReference(Info.Compiler, Variable)
         If fD.IsStatic Then
             If fD.IsLiteral Then
                 Emitter.EmitLoadValue(Info.Clone(Info.Context, True, False, Variable.FieldType), fD.Constant)
             Else
                 Info.ILGen.Emit(OpCodes.Ldsfld, Variable)
             End If
         Else
             Info.ILGen.Emit(OpCodes.Ldfld, Variable)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\PropertyGroupToPropertyAccessExpression.vb" startline="45" endline="64">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_PropertyGroup.IsResolved = False OrElse m_PropertyGroup.ResolvedProperty Is Nothing Then
             result = m_PropertyGroup.ResolveGroup(New ArgumentList(Me)) AndAlso result
         End If
 
         If result = False Then
             Return False
         End If
 
         m_ExpressionType = m_PropertyGroup.ResolvedProperty.PropertyType
 
         result = m_ExpressionType IsNot Nothing AndAlso result
 
         Me.Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\MPGhandler.vb" startline="132" endline="145">
<![CDATA[
 
     Public Overloads Overrides Function Split(ByVal Filename As String, _
     ByVal Pieces As Short, Optional ByVal MediaDuration As Double = 0) As Boolean
         MyBase.Split(Filename, Pieces)
 
         If mIsAudio Then SafeHarborMsg()
 
         'mpgtx -166 matrix-trailer.mpg -b mychunk  -- pieces; mychunk output name
         RunConverter("-" & Trim(CStr(Pieces)) & " " & Chr(34) & mInFile & Chr(34) & _
         " -f -b " & Chr(34) & AddDefaultPathIfNeeded(StripExtension(mOutFile)) & Chr(34))
 
         Return FileCount(Filename) >= Pieces
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="50" endline="65">
<![CDATA[
 
     Sub Init(ByVal [Event] As Expression, ByVal EventHandler As MethodDeclaration, ByVal IsAddHandler As Boolean, ByVal InstanceExpression As Expression)
         Dim result As Boolean = True
         m_Event = [Event]
         m_IsAddHandler = IsAddHandler
 
         Dim o As Object = CType(CecilHelper.FindDefinition(m_Event.Classification.AsEventAccess.EventType), Mono.Cecil.TypeDefinition).Methods(0).Parameters
 
         Dim eventInfo As Mono.Cecil.EventReference = m_Event.Classification.AsEventAccess.EventInfo
         Dim objCreation As New DelegateOrObjectCreationExpression(Me)
         Dim methodPointer As New AddressOfExpression(Me)
         methodPointer.Init(EventHandler, InstanceExpression)
         objCreation.Init(eventInfo.EventType, New ArgumentList(objCreation, methodPointer))
         result = objCreation.ResolveExpression(ResolveInfo.Default(Compiler)) AndAlso result
         m_EventHandler = objCreation
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryPlusExpression.vb" startline="34" endline="56">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
         result = Expression.GenerateCode(expInfo) AndAlso result
 
         Select Case OperandTypeCode
             Case TypeCode.Decimal
             Case TypeCode.Single, TypeCode.Double
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__PlusObject_Object)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="443" endline="463">
<![CDATA[
 
     Private Sub ParseEnd()
         If m_Current <> KS.End Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'End'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current = KS.If Then
             ParseEndIf()
         ElseIf m_Current.Equals("ExternalSource") Then
             ParseEndExternalSource()
         ElseIf m_Current.Equals("Region") Then
             ParseEndRegion()
         Else
             Helper.AddError(Me, "'End' what?")
             Me.EatLine(False)
             Return
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="50" endline="72">
<![CDATA[
     End Property
 
     Function CreateAliasExpression(ByVal SharedExpression As Expression, ByRef result As Expression) As Boolean
         Dim sne As SimpleNameExpression = TryCast(SharedExpression, SimpleNameExpression)
         Dim mae As MemberAccessExpression
         Dim maeIE As MemberAccessExpression
 
         If TypeOf SharedExpression.Parent Is Is_IsNotExpression Then
             Dim fieldLoad As New LoadFieldExpression(SharedExpression, DirectCast(m_Type.Annotations(Compiler), TypeDeclaration).MyGroupField.FieldBuilder, m_Group.DefaultInstanceAlias)
             result = fieldLoad
         Else
             If sne IsNot Nothing Then
                 maeIE = New MemberAccessExpression(SharedExpression.Parent)
                 maeIE.Init(Expression, New IdentifierOrKeyword(SharedExpression.Parent, Token.CreateIdentifierToken(sne.Location, sne.Identifier.Identifier)))
             Else
                 mae = TryCast(SharedExpression, MemberAccessExpression)
                 maeIE = New MemberAccessExpression(SharedExpression.Parent)
                 maeIE.Init(Expression, mae.SecondExpression)
             End If
             result = maeIE
         End If
         Return result.ResolveExpression(ResolveInfo.Default(SharedExpression.Compiler))
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\StdToolMgr.vb" startline="150" endline="176">
<![CDATA[
 
     Private Sub picSlider_MouseMove(ByVal sender As System.Object, _
     ByVal e As System.Windows.Forms.MouseEventArgs) Handles picSlider.MouseMove
 
         If (e.Button = Windows.Forms.MouseButtons.Left) Then
             Dim Pos As Integer = picSlider.Left + e.X
             ' make sure the picture is still on the screen
             If Pos > 0 Then
                 If Pos > (Me.Width - picSlider.Width) Then
                     ' too far right, butt it up against the wall
                     Pos = (Me.Width - picSlider.Width)
                 End If
                 picSlider.Left = Pos
             Else
                 ' off the screen to the left, so place at edge of screen
                 picSlider.Left = 0
             End If
 
             ' calculate the value
             CalculateValues()
             ToolTip.SetToolTip(picSlider, CStr(mValue) + mUnit)
 
             ' raise an event saying a slider has moved
             RaiseEvent SliderMoved(Me, mValue)
 
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3906" endline="3932">
<![CDATA[
 
     ''' <summary>
     ''' TypeParameterConstraints  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeParameterConstraints(ByVal Parent As ParsedObject) As TypeParameterConstraints
         Dim result As New TypeParameterConstraints(Parent)
 
         tm.AcceptIfNotInternalError(KS.As)
 
         Dim m_ConstraintList As New ConstraintList(result)
 
         If tm.Accept(KS.LBrace) Then
             If ParseList(Of Constraint)(m_ConstraintList, New ParseDelegate_Parent(Of Constraint)(AddressOf ParseConstraint), result) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.AcceptIfNotError(KS.RBrace) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             Dim tmpConstraint As Constraint = Nothing
             tmpConstraint = ParseConstraint(result)
             m_ConstraintList = New ConstraintList(result, tmpConstraint)
         End If
 
         result.Init(m_ConstraintList)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3381" endline="3405">
<![CDATA[
 
     Private Function ParseOr_OrElse_Xor(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseAnd_AndAlso(Info)
 
         While tm.CurrentToken.Equals(KS.Or, KS.OrElse, KS.Xor)
             Dim op As KS
             op = tm.CurrentToken.Keyword
             tm.NextToken()
             tm.AcceptNewLine()
             rSide = ParseAnd_AndAlso(Info)
             If op = KS.Or Then
                 lSide = New OrExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.OrElse Then
                 lSide = New OrElseExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Xor Then
                 lSide = New XOrExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.Or, KS.OrElse, KS.Xor)
             Dim op As KS
             op = tm.CurrentToken.Keyword
             tm.NextToken()
             tm.AcceptNewLine()
             rSide = ParseAnd_AndAlso(Info)
             If op = KS.Or Then
                 lSide = New OrExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.OrElse Then
                 lSide = New OrElseExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Xor Then
                 lSide = New XOrExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="1069" endline="1114">
<![CDATA[
 
     ''' <summary>
     ''' ConstructedTypeName 
     '''     QualifiedIdentifier  "("  "Of"  TypeArgumentList  ")"
     '''     ConstructedTypeName "." QualifiedIdentifier [LAMESPEC]
     '''     ConstructedTypeName "." QualifiedIdentifier "(" "Of" TypeArgumentList ")" [LAMESPEC]
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseConstructedTypeName(ByVal Parent As ParsedObject) As ConstructedTypeName
         Dim result As ConstructedTypeName
         Dim current As ConstructedTypeName
 
         Dim m_QualifiedIdentifier As QualifiedIdentifier
         Dim m_TypeArgumentList As TypeArgumentList
 
         current = Nothing
 
         Do
 
             If current Is Nothing Then
                 result = New ConstructedTypeName(Parent)
             Else
                 result = New ConstructedTypeName(current)
             End If
 
             m_QualifiedIdentifier = ParseQualifiedIdentifier(result)
             If m_QualifiedIdentifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             m_TypeArgumentList = Nothing
 
             If tm.Accept(KS.LParenthesis) Then
                 tm.AcceptIfNotError(KS.Of)
 
                 If ParseList(Of TypeName)(m_TypeArgumentList, New ParseDelegate_Parent(Of TypeName)(AddressOf ParseTypeName), Parent) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
 
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             result.Init(current, m_QualifiedIdentifier, m_TypeArgumentList)
 
             current = result
         Loop While tm.Accept(KS.Dot)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\AssignStatements\MidAssignStatement.vb" startline="93" endline="117">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Target.ResolveExpression(Info) AndAlso result
         result = m_Start.ResolveExpression(info) AndAlso result
         If m_Length IsNot Nothing Then result = m_Length.ResolveExpression(Info) AndAlso result
         result = m_Source.ResolveExpression(info) AndAlso result
 
         If Not m_Target.Classification.IsVariableClassification AndAlso Not m_Target.Classification.IsPropertyAccessClassification Then
             If m_Target.Classification.CanBePropertyAccessClassification Then
                 m_Target = m_Target.ReclassifyToPropertyAccessExpression()
                 result = m_Target.ResolveExpression(Info) AndAlso result
             Else
                 result = False
             End If
         End If
 
         Compiler.Helper.AddCheck("The first argument is the target of the assignment and must be classified as a variable or a property access whose type is implicitly convertible to and from String. ")
         Compiler.Helper.AddCheck("The second parameter is the 1-based start position that corresponds to where the assignment should begin in the target string and must be classified as a value whose type must be implicitly convertible to Integer")
         Compiler.Helper.AddCheck("The optional third parameter is the number of characters from the right-side value to assign into the target string and must be classified as a value whose type is implicitly convertible to Integer")
         Compiler.Helper.AddCheck("The right side is the source string and must be classified as a value whose type is implicitly convertible to String.")
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" startline="25" endline="47">
<![CDATA[
     Sub New(ByVal Parent As EventDeclaration, ByVal Modifiers As Modifiers, ByVal HandlerType As KS, ByVal EventName As Identifier)
         MyBase.new(Parent)
 
         Dim Code As ImplicitCodeBlock
         If (Parent.Modifiers.Is(ModifierMasks.MustOverride) OrElse DeclaringType.IsInterface) Then
             Code = Nothing
         Else
             Select Case HandlerType
                 Case KS.AddHandler
                     Code = New ImplicitCodeBlock(Me, New ImplicitCodeBlock.CodeGenerator(AddressOf CreateAddHandlerCode))
                 Case KS.RemoveHandler
                     Code = New ImplicitCodeBlock(Me, New ImplicitCodeBlock.CodeGenerator(AddressOf CreateRemoveHandlerCode))
                 Case KS.RaiseEvent
                     Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                     Code = Nothing
                 Case Else
                     Throw New InternalException(Me)
             End Select
         End If
 
         MyBase.Init(Modifiers, HandlerType, EventName, New ParameterList(Me), Code)
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4765" endline="4798">
<![CDATA[
 
     ''' <summary>
     ''' ConstantDeclarator  
     ''' TODO
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseConstantDeclaration(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo, ByVal Modifiers As Modifiers) As ConstantDeclaration
         Dim result As New ConstantDeclaration(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_TypeName As TypeName = Nothing
         Dim m_ConstantExpression As Expression = Nothing
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.Accept(KS.As) Then
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         If tm.AcceptIfNotError(KS.Equals) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         tm.AcceptNewLine()
 
         m_ConstantExpression = ParseExpression(result)
         If m_ConstantExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(Modifiers, m_Identifier, m_TypeName, m_ConstantExpression)
 
         'Don't parse a StatementTerminator as the VB spec says.
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\OptionStrictStatement.vb" startline="68" endline="101">
<![CDATA[
 
     Private Function GenerateCodeForNewArray(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim rankTypes() As Mono.Cecil.TypeReference = Helper.CreateArray(Of Mono.Cecil.TypeReference)(Compiler.TypeCache.System_Int32, m_Rank)
 
         Helper.Assert(m_Rank >= 1)
 
         If m_Rank = 1 Then
             result = m_ArraySizeInitModifier.BoundList.Expressions(0).GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Int32)) AndAlso result
             Emitter.EmitNewArr(Info, m_ElementType)
         Else
             'Dim ctor As ConstructorInfo
             'ctor = m_ArrayType.GetConstructor(BindingFlags.Instance Or BindingFlags.Public, Nothing, Nothing, rankTypes, Nothing)
             'ctor = Compiler.TypeCache.Array.GetConstructor(BindingFlags.Instance Or BindingFlags.NonPublic Or BindingFlags.Public, Nothing, Type.EmptyTypes, Nothing)
             ''ctor = Compiler.TypeCache.Array.GetConstructor(BindingFlags.Instance Or BindingFlags.NonPublic Or BindingFlags.Public, Nothing, rankTypes, Nothing)
             'Helper.Assert(ctor IsNot Nothing)
             'Emitter.EmitNew(Info, ctor)
 
             Dim ElementType As Mono.Cecil.TypeReference
             Dim ArrayType As Mono.Cecil.TypeReference
 
             ElementType = Helper.GetTypeOrTypeBuilder(Compiler, CecilHelper.GetElementType(m_ArrayType))
             ArrayType = Helper.GetTypeOrTypeBuilder(Compiler, m_ArrayType)
 
             Emitter.EmitLoadToken(Info, ElementType)
             Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.System_Type__GetTypeFromHandle_RuntimeTypeHandle)
 
             result = Helper.EmitIntegerArray(Info, m_ArraySizeInitModifier.BoundList.Expressions) AndAlso result
             Emitter.EmitCall(Info, Compiler.TypeCache.System_Array__CreateInstance)
 
             Emitter.EmitCastClass(Info, ArrayType)
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Compiler.vb" startline="300" endline="326">
<![CDATA[
 
     Private Function Compile_CreateAssemblyAndModuleBuilders() As Boolean
         Dim kind As Mono.Cecil.ModuleKind
         Select Case CommandLine.Target
             Case vbnc.CommandLine.Targets.Console
                 kind = Mono.Cecil.ModuleKind.Console
             Case vbnc.CommandLine.Targets.Library
                 kind = Mono.Cecil.ModuleKind.Dll
             Case vbnc.CommandLine.Targets.Module
                 Report.ShowMessage(Messages.VBNC99999, Span.CommandLineSpan, "Compiling modules (-target
                 kind = Mono.Cecil.ModuleKind.NetModule
                 Return False
             Case vbnc.CommandLine.Targets.Winexe
                 kind = Mono.Cecil.ModuleKind.Windows
             Case Else
                 kind = Mono.Cecil.ModuleKind.Console
         End Select
 
         Dim an As AssemblyNameDefinition = New AssemblyNameDefinition("dummy", New Version())
         AssemblyBuilderCecil = AssemblyDefinition.CreateAssembly(an, IO.Path.GetFileNameWithoutExtension(OutFileName), kind)
         ModuleBuilderCecil = AssemblyBuilderCecil.MainModule
         ModuleBuilderCecil.Name = IO.Path.GetFileName(OutFileName)
         ModuleBuilderCecil.Runtime = TypeManager.Corlib.MainModule.Runtime
         ModuleBuilderCecil.AssemblyResolver = AssemblyResolver
         If CommandLine.Verbose Then Report.WriteLine(String.Format("Using runtime version
         Return Compiler.Report.Errors = 0
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\ImportsClause.vb" startline="136" endline="153">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The namespace or type that is imported.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property Name() As String
         Get
             If IsQualifiedIdentifier Then
                 Return AsQualifiedIdentifier.Name
             ElseIf IsConstructedTypeName Then
                 Return AsConstructedTypeName.Name
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="82" endline="93">
<![CDATA[
     End Property
 
     ReadOnly Property Name() As String
         Get
             If IsConstructedTypeName Then
                 Return AsConstructedTypeName.Name
             ElseIf Me.IsSimpleTypeName Then
                 Return AsSimpleTypeName.Name
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="168" endline="177">
<![CDATA[
 
     Overrides Function ToString() As String
         If IsConstructedTypeName Then
             Return AsConstructedTypeName.Name
         ElseIf IsSimpleTypeName Then
             Return AsSimpleTypeName.Name
         Else
             Throw New InternalException(Me)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="111" endline="122">
<![CDATA[
     End Property
 
     ReadOnly Property Name() As String
         Get
             If IsBuiltInTypeName Then
                 Return AsBuiltInTypeName.Name
             ElseIf IsQualifiedIdentifier Then
                 Return AsQualifiedIdentifier.Name
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" startline="235" endline="243">
<![CDATA[
 
     Private Function EmitStringToCharArray(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = Expression.GenerateCode(Info.Clone(Info.Context, Compiler.TypeCache.System_String)) AndAlso result
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToCharArrayRankOne_String)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AliasClause.vb" startline="50" endline="59">
<![CDATA[
 
     Function CreateArrayType(ByVal OriginalType As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         If Me.IsArraySizeInitializationModifier Then
             Return Me.AsArraySizeInitializationModifier.CreateArrayType(OriginalType)
         ElseIf Me.IsArrayTypeModifiers Then
             Return Me.AsArrayTypeModifiers.CreateArrayType(OriginalType)
         Else
             Throw New InternalException(Me)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="43" endline="52">
<![CDATA[
 
     Public Overrides Function CreateDefinition() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.CreateDefinition AndAlso result
         TypeAttributes = Helper.getTypeAttributeScopeFromScope(Me.Modifiers, Me.IsNestedType) Or Mono.Cecil.TypeAttributes.SequentialLayout Or Mono.Cecil.TypeAttributes.Sealed
         MyBase.BaseType = Compiler.TypeCache.System_ValueType
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2522" endline="2531">
<![CDATA[
 
     Shared Function GetFieldOrFieldReference(ByVal Compiler As Compiler, ByVal field As Mono.Cecil.FieldReference) As Mono.Cecil.FieldReference
         If field.Annotations.Contains("MemberInReflection") Then
             Return DirectCast(field.Annotations("MemberInReflection"), Mono.Cecil.FieldReference)
         ElseIf Compiler.AssemblyBuilderCecil Is field.DeclaringType.Module.Assembly Then
             Return field
         Else
             Return Compiler.AssemblyBuilderCecil.MainModule.Import(field)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="316" endline="329">
<![CDATA[
 
     Private Sub ParseEndIf()
         If m_Current <> KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         m_ConditionStack.RemoveAt(m_ConditionStack.Count - 1)
         ParseEndOfLine()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ReturnStatement.vb" startline="55" endline="89">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim lockType As Mono.Cecil.TypeReference = Helper.GetTypeOrTypeBuilder(Compiler, m_Lock.ExpressionType)
 
         Dim lockVariable As Mono.Cecil.Cil.VariableDefinition
         lockVariable = Emitter.DeclareLocal(Info, lockType)
 
         result = m_Lock.GenerateCode(Info.Clone(Me, True, False, lockType)) AndAlso result
         Emitter.EmitStoreVariable(Info, lockVariable)
 
         If Helper.CompareType(Compiler.TypeCache.System_Object, lockVariable.VariableType) Then
             Emitter.EmitLoadVariable(Info, lockVariable)
             Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ObjectFlowControl__CheckForSyncLockOnValueType_Object)
         End If
 
         Dim endException As Label
         endException = Emitter.EmitBeginExceptionBlock(Info)
         'Enter the lock
         Emitter.EmitLoadVariable(Info, lockVariable)
         Emitter.EmitCall(Info, Compiler.TypeCache.System_Threading_Monitor__Enter_Object)
 
         'Emit the code
         result = CodeBlock.GenerateCode(Info) AndAlso result
         Info.ILGen.BeginFinallyBlock()
 
         'Exit the lock
         Emitter.EmitLoadVariable(Info, lockVariable)
         Emitter.EmitCall(Info, Compiler.TypeCache.System_Threading_Monitor__Exit_Object)
 
         Info.ILGen.EndExceptionBlock()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\VariableExpression.vb" startline="35" endline="58">
<![CDATA[
 
     Shared Function Emit(ByVal Info As EmitInfo, ByVal LocalBuilder As Mono.Cecil.Cil.VariableDefinition) As Boolean
         Dim result As Boolean = True
 
         If Info.IsRHS Then
             Emitter.EmitLoadVariable(Info, LocalBuilder)
         Else
             Dim rInfo As EmitInfo = Info.Clone(Info.Context, True, False, LocalBuilder.VariableType)
 
             Helper.Assert(Info.RHSExpression IsNot Nothing, "RHSExpression Is Nothing!")
             Helper.Assert(Info.RHSExpression.Classification.IsValueClassification OrElse Info.RHSExpression.Classification.CanBeValueClassification)
             result = Info.RHSExpression.Classification.GenerateCode(rInfo) AndAlso result
 
             Emitter.EmitConversion(Info.RHSExpression.ExpressionType, LocalBuilder.VariableType, Info)
 
             If Helper.CompareType(LocalBuilder.VariableType, Info.Compiler.TypeCache.System_Object) AndAlso Helper.CompareType(Info.RHSExpression.ExpressionType, Info.Compiler.TypeCache.System_Object) Then
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
             End If
 
             Emitter.EmitStoreVariable(Info, LocalBuilder)
         End If
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\LateBoundAccessToValueExpression.vb" startline="55" endline="66">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_InstanceExpression IsNot Nothing Then
             result = m_InstanceExpression.GenerateCode(Info) AndAlso result
         End If
 
         Emitter.EmitLoadVariable(Info, m_Field)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="210" endline="219">
<![CDATA[
 
     Private Function EmitStoreCounterInstanceExpression(ByVal Info As EmitInfo, ByVal Data As LoopCounterData) As Boolean
         Dim result As Boolean = True
 
         If Data.InstanceExpression IsNot Nothing Then
             result = Data.InstanceExpression.GenerateCode(Info.Clone(Me, Data.InstanceExpression.ExpressionType)) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="151" endline="162">
<![CDATA[
     End Property
 
     ReadOnly Property Type() As Mono.Cecil.TypeReference
         Get
             If m_Property Is Nothing Then
                 Helper.Assert(m_Classification IsNot Nothing)
                 Helper.Assert(m_Classification.IsResolved)
                 m_Property = m_Classification.ResolvedProperty
             End If
             Helper.Assert(m_Property IsNot Nothing)
             Return m_Property.PropertyType
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeImplementsClauses.vb" startline="223" endline="234">
<![CDATA[
 
     Private Function ResolveQualifiedName(ByVal Qualifier As TypeNameResolutionInfo, ByVal R1 As String, ByVal R2 As String, ByVal TypeArgumentCount As Integer) As Boolean
         Dim result As Boolean = True
 
         result = ResolveQualifiedNameInternal(Qualifier, R1, R2 Is Nothing, TypeArgumentCount) AndAlso result
 
         If result = False AndAlso R2 IsNot Nothing Then
             result = ResolveQualifiedNameInternal(Qualifier, R2, True, TypeArgumentCount) 'AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="300" endline="309">
<![CDATA[
 
     Friend Overloads Function GenerateCode(ByVal Info As EmitInfo, ByVal Types() As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean = True
         Helper.Assert(Types.Length = Me.Count)
 
         For i As Integer = 0 To Count - 1
             result = Item(i).GenerateCode(Info.Clone(Me, True, False, Types(i)), Nothing) AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="336" endline="357">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = DefineOverrides() AndAlso result
         result = MyBase.GenerateCode(Info) AndAlso result
 
         If Me.IsPropertyHandlesHandler Then
             result = GeneratePropertyHandlers() AndAlso result
         ElseIf Me.HasMethodBody Then
             Helper.Assert(m_Code IsNot Nothing)
 
             'Create the default return variable
             If Me.HasReturnValue Then
                 m_DefaultReturnVariable = Emitter.DeclareLocal(Info, ReturnType)
             End If
 
             result = m_Code.GenerateCode(Me) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="171" endline="184">
<![CDATA[
 
 
     ''' <summary>
     ''' Searches for the type with the specified name.
     ''' </summary>
     ''' <param name="Name">The type's name to search for. Not case-sensitive.</param>
     ''' <param name="OnlyCreatedTypes">Specifes whether to search in all types, or only in types compiled now.</param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Function [GetType](ByVal Name As String, ByVal OnlyCreatedTypes As Boolean) As Generic.List(Of Mono.Cecil.TypeReference)
         Dim result As New Generic.List(Of Mono.Cecil.TypeReference)
         result.AddRange(Me.GetType(Name, Types, OnlyCreatedTypes))
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="242" endline="253">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns true if the method group has successfully been resolved.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property SuccessfullyResolved() As Boolean
         Get
             Return m_Resolved AndAlso (m_Group.Count = 1 OrElse m_Resolver.IsLateBound)
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="930" endline="936">
<![CDATA[
     End Property
 
     ReadOnly Property ParamArrayParameter() As Mono.Cecil.ParameterDefinition
         Get
             If IsParamArray = False Then Return Nothing
             Return m_DefinedParameters(m_DefinedParameters.Count - 1)
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="108" endline="117">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_1.ResolveTypeReferences AndAlso result
 
         m_ResolvedType = m_1.ResolvedType
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="45" endline="53">
<![CDATA[
 
     ReadOnly Property Constants() As Generic.List(Of EnumMemberDeclaration)
         Get
             If m_Constants Is Nothing Then
                 m_Constants = Members.GetSpecificMembers(Of EnumMemberDeclaration)()
                 Helper.Assert(m_Constants.Count = Members.Count)
             End If
             Return m_Constants
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="65" endline="72">
<![CDATA[
         Get
             If m_CilBody Is Nothing Then
                 Helper.Assert(m_Method IsNot Nothing)
                 Helper.Assert(m_Method.CecilBuilder IsNot Nothing)
                 m_CilBody = m_Method.CecilBuilder.Body
             End If
             Return m_CilBody
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\AbstractMediaHandler.vb" startline="79" endline="87">
<![CDATA[
 
     Public Function isValid(ByVal ToolName As String) As Boolean
         Dim Tool As ToolSpec = DirectCast(mList(FindToolIndex(ToolName)), ToolSpec)
         Dim Check1, Check2 As Boolean
         mDshowList.GetList()
         Check1 = mDshowList.isFilterAvailable(Tool.Filter)
         Check2 = (Tool.Path.Required = False) Or (New IO.FileInfo(Tool.Path.Value).Exists)
         Return (Check1 And Check2)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\MethodGroupToValueExpression.vb" startline="48" endline="63">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info.IsRHS Then
             If Me.Classification.IsValueClassification Then
                 result = m_Expression.GenerateCode(Info) AndAlso result
             Else
                 Throw New InternalException(Me)
             End If
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="1195" endline="1216">
<![CDATA[
 
     ''' <summary>
     ''' ArrayTypeModifier  
     ''' RankList  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArrayTypeModifier(ByVal Parent As ParsedObject) As ArrayTypeModifier
         Dim result As New ArrayTypeModifier(Parent)
 
         tm.AcceptIfNotInternalError(KS.LParenthesis)
 
         Dim m_Ranks As Integer
         Do
             m_Ranks += 1
         Loop While tm.Accept(KS.Comma)
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Ranks)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="141" endline="152">
<![CDATA[
     End Property
 
     ReadOnly Property FieldInfo() As Mono.Cecil.FieldReference
         Get
             If m_TypeVariable IsNot Nothing AndAlso m_TypeVariable.FieldBuilder IsNot Nothing Then
                 Return m_TypeVariable.FieldBuilder
             ElseIf m_LocalVariable IsNot Nothing AndAlso m_LocalVariable.FieldBuilder IsNot Nothing Then
                 Return m_LocalVariable.FieldBuilder
             Else
                 Return m_FieldInfo
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\LateBoundAccessToValueExpression.vb" startline="58" endline="74">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info.IsRHS Then
             Helper.Assert(Me.Classification.IsValueClassification)
             If Me.Classification.CanBeValueClassification Then
                 result = Me.Classification.GenerateCode(Info) AndAlso result
             Else
                 Throw New InternalException(Me)
             End If
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="129" endline="140">
<![CDATA[
     End Property
 
     ReadOnly Property FieldDefinition() As Mono.Cecil.FieldDefinition
         Get
             If m_TypeVariable IsNot Nothing AndAlso m_TypeVariable.FieldBuilder IsNot Nothing Then
                 Return m_TypeVariable.FieldBuilder
             ElseIf m_LocalVariable IsNot Nothing AndAlso m_LocalVariable.FieldBuilder IsNot Nothing Then
                 Return m_LocalVariable.FieldBuilder
             Else
                 Return CecilHelper.FindDefinition(m_FieldInfo)
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="104" endline="120">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_Resolved)
 
         If Info.IsRHS Then
             result = GenerateCodeAsValue(Info) AndAlso result
         ElseIf Info.IsLHS Then
             Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MyGenerator.vb" startline="105" endline="111">
<![CDATA[
 
     Overloads Function Equals(ByVal A As String, ByVal B As String) As Boolean
         If A.Length + B.Length + 1 <> m_Name.Length Then Return False
         If m_Name.StartsWith(A, Helper.StringComparison) = False Then Return False
         If m_Name.EndsWith(B, Helper.StringComparison) = False Then Return False
         Return m_Name(A.Length) = "."c
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Compiler.vb" startline="940" endline="962">
<![CDATA[
 
     Function FindMainClass(ByRef Result As TypeDeclaration) As Boolean
         'Dim mainClasses As ArrayList
         Dim mainClass As TypeDeclaration
 
         If CommandLine.Main = "" Then
             Result = Nothing
             Return True
         End If
 
         mainClass = theAss.FindType(CommandLine.Main)
 
         If mainClass Is Nothing Then
             Report.ShowMessage(Messages.VBNC90013, Span.CommandLineSpan, CommandLine.Main, "0")
             Result = Nothing
             Return False
         End If
 
         'Result = DirectCast(mainClasses(0), TypeDescriptor)
         Result = mainClass
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="339" endline="362">
<![CDATA[
 #End Region
 
 #Region "Region"
     Private Sub ParseRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
 
         'Save the location of the #Region token to use as the location of any missing string literal
         Dim regionLoc As Span = GetCurrentLocation()
 
         Me.NextUnconditionally()
 
         If Not m_Current.IsStringLiteral Then
             Compiler.Report.ShowMessage(Messages.VBNC30217, regionLoc)
             EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="967" endline="980">
<![CDATA[
 
     Public Shared Function CreateNullableType(ByVal Context As BaseObject, ByVal Type As TypeReference, ByRef result As TypeReference) As Boolean
         If CecilHelper.IsValueType(Type) = False Then
             Dim gp As GenericParameter = TryCast(Type, GenericParameter)
             If gp Is Nothing OrElse gp.HasNotNullableValueTypeConstraint = False Then
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC33101, Context.Location, Helper.ToString(Context.Compiler, Type))
             End If
         End If
 
         Dim git As New GenericInstanceType(Context.Compiler.TypeCache.System_Nullable1)
         git.GenericArguments.Add(Type)
         result = git
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="73" endline="91">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveExpression(Info) AndAlso result
         result = m_Type.ResolveTypeReferences AndAlso result
 
         Classification = New ValueClassification(Me)
 
         If m_Expression.Classification.IsValueClassification Then
         ElseIf m_Expression.Classification.CanBeValueClassification Then
             m_Expression = m_Expression.ReclassifyToValueExpression()
             result = m_Expression.ResolveExpression(Info) AndAlso result
         Else
             result = Helper.AddError(Me) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="235" endline="266">
<![CDATA[
 #End Region
 
 #Region "If"
     Private Sub ParseIf()
         Dim theExpression As ConditionalExpression
         Dim expression As Object = Nothing
 
         If Not m_Current = KS.If Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'If'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         theExpression = New ConditionalExpression(Me)
         If Not theExpression.Parse(expression) Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If CBool(expression) Then
             m_ConditionStack.Add(1)
         Else
             m_ConditionStack.Add(0)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="121" endline="148">
<![CDATA[
     ''' <summary>
     ''' OptionCompareStatement  
     ''' CompareOption  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOptionCompareStatement(ByVal Parent As BaseObject) As OptionCompareStatement
         Dim result As New OptionCompareStatement(Parent)
 
         Dim m_IsBinary As Boolean
 
         tm.AcceptIfNotInternalError(KS.Option)
         tm.AcceptIfNotInternalError("Compare")
 
         If tm.Accept("Text") Then
             m_IsBinary = False
         ElseIf tm.Accept("Binary") Then
             m_IsBinary = True
         Else
             Compiler.Report.ShowMessage(Messages.VBNC30207, tm.CurrentLocation)
             tm.GotoNewline(False)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_IsBinary)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="111" endline="129">
<![CDATA[
     End Property
 
     ReadOnly Property Type() As Mono.Cecil.TypeReference
         Get
             If m_ResolvedProperty IsNot Nothing Then
                 Return m_ResolvedProperty.PropertyType
             ElseIf m_Members IsNot Nothing Then
                 If m_Members.Count = 1 Then
                     m_ResolvedProperty = m_Members(0)
                     Return m_Members(0).PropertyType
                 Else
                     Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
                 End If
             Else
                 Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             End If
             Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             Return Nothing
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="298" endline="315">
<![CDATA[
 
     Private Sub ParseElse()
         If m_Current <> KS.Else Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Else'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If Not CheckEmtpyStack() Then Return
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 0 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         End If
         ParseEndOfLine()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\CallStatement.vb" startline="61" endline="83">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Target.Classification.IsLateBoundClassification Then
             result = m_Target.GenerateCode(Info) AndAlso result
 
             Return result
         End If
 
         Helper.Assert(m_Target.Classification.IsValueClassification OrElse m_Target.Classification.IsVoidClassification)
 
         If IsExcluded() Then Return result
 
         result = m_Target.GenerateCode(Info.Clone(Me, True)) AndAlso result
         If m_Target.Classification.IsValueClassification Then
             If Helper.CompareType(m_Target.Classification.AsValueClassification.Type, Compiler.TypeCache.System_Void) = False Then
                 Emitter.EmitPop(Info, m_Target.ExpressionType)
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeImplementsClauses.vb" startline="479" endline="520">
<![CDATA[
 
     Private Function CheckOutermostNamespace(ByVal R As String, ByVal TypeArgumentCount As Integer) As Boolean
         '---------------------------------------------------------------------------------------------------------
         '* (...)
         '**	If R matches the name of an accessible type or nested namespace in the current namespace, then the
         '** unqualified name refers to that type or nested namespace.
         '*
         '**	If the namespace contains one or more accessible standard modules, and R matches the name of an 
         '** accessible nested type in exactly one standard module, then the unqualified name refers to that nested type
         '*
         '** If R matches the name of accessible nested types in more than one standard module, a compile-time 
         '** error occurs.
         '--------------------------------------------------------------------------------------------------------- 
 
         '**	If R matches the name of an accessible type or nested namespace in the current namespace, then the
         '** unqualified name refers to that type or nested namespace.
         Dim types As TypeDictionary = Nothing
         Dim modules As TypeList
         Dim foundType As Mono.Cecil.TypeReference
 
         Dim RName As String = Helper.CreateGenericTypename(R, TypeArgumentCount)
         foundType = FromWhere.Compiler.TypeManager.TypesByNamespace("").Item(RName)
         If foundType IsNot Nothing Then
             m_FoundObjects.Add(foundType)
         End If
         If TypeArgumentCount = 0 AndAlso FromWhere.Compiler.TypeManager.Namespaces.IsNamespace(R, True) Then
             m_FoundObjects.Add(FromWhere.Compiler.TypeManager.Namespaces.Item(R))
         End If
 
         If m_FoundObjects.Count > 0 Then Return True
 
         '**	If the namespace contains one or more accessible standard modules, and R matches the name of an 
         '** accessible nested type in exactly one standard module, then the unqualified name refers to that nested type
 
         If types Is Nothing Then Return False 'There are no types (nor modules) in the outermost namespace.
 
         modules = FromWhere.Compiler.TypeManager.GetModulesByNamespace("").ToTypeList
 
         If CheckModules(modules, R, TypeArgumentCount) Then Return True
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="87" endline="93">
<![CDATA[
 
     Shared Function EmitBeginExceptionBlock(ByVal Info As EmitInfo) As Label
         Helper.Assert(Info.InExceptionFilter = False)
         Dim result As Label
         result = Info.ILGen.BeginExceptionBlock
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="12" endline="20">
<![CDATA[
     Public Sub New()
         MyBase.New()
 
         'This call is required by the Windows Form Designer.
         InitializeComponent()
 
         'Add any initialization after the InitializeComponent() call
 
     End Sub
 
     'Form overrides dispose to clean up the component list.
     Protected Overloads Overrides Sub Dispose(ByVal disposing As Boolean)
         If disposing Then
             If Not (components Is Nothing) Then
                 components.Dispose()
             End If
         End If
         MyBase.Dispose(disposing)
     End Sub
 
     'Required by the Windows Form Designer
     Private components As System.ComponentModel.IContainer
 
     'NOTE
     'It can be modified using the Windows Form Designer.  
     'Do not modify it using the code editor.
     Friend WithEvents MainMenu1 As System.Windows.Forms.MainMenu
     Friend WithEvents MenuItem1 As System.Windows.Forms.MenuItem
     Friend WithEvents mnuOpen As System.Windows.Forms.MenuItem
     Friend WithEvents mnuExit As System.Windows.Forms.MenuItem
     Friend WithEvents mnuSave As System.Windows.Forms.MenuItem
     Friend WithEvents dlgOpenFile As System.Windows.Forms.OpenFileDialog
     Friend WithEvents dlgSaveFile As System.Windows.Forms.SaveFileDialog
     Friend WithEvents mainTabs As System.Windows.Forms.TabControl
     Friend WithEvents tabPlayer As System.Windows.Forms.TabPage
     Friend WithEvents tabTrace As System.Windows.Forms.TabPage
     Friend WithEvents mPlayer As AxWMPLib.AxWindowsMediaPlayer
     Friend WithEvents rtfTrace As System.Windows.Forms.RichTextBox
     Friend WithEvents panSegments As System.Windows.Forms.Panel
     Friend WithEvents lvPositions As System.Windows.Forms.ListView
     Friend WithEvents colStart As System.Windows.Forms.ColumnHeader
     Friend WithEvents colEnd As System.Windows.Forms.ColumnHeader
     Friend WithEvents MenuItem2 As System.Windows.Forms.MenuItem
     Friend WithEvents MenuItem3 As System.Windows.Forms.MenuItem
     Friend WithEvents tabJoin As System.Windows.Forms.TabPage
     Friend WithEvents cSort As System.Windows.Forms.ToolBarButton
     Friend WithEvents cJoin As System.Windows.Forms.ToolBarButton
     Friend WithEvents cClear As System.Windows.Forms.ToolBarButton
     Friend WithEvents cRemove As System.Windows.Forms.ToolBarButton
     Friend WithEvents chkAuto As System.Windows.Forms.CheckBox
     Friend WithEvents cOpen As System.Windows.Forms.ToolBarButton
     Friend WithEvents lvFiles As System.Windows.Forms.ListView
     Friend WithEvents ColumnHeader1 As System.Windows.Forms.ColumnHeader
     Friend WithEvents ImageList1 As System.Windows.Forms.ImageList
     Friend WithEvents MenuItem4 As System.Windows.Forms.MenuItem
     Friend WithEvents MenuItem5 As System.Windows.Forms.MenuItem
     Friend WithEvents mnuSaveX As System.Windows.Forms.MenuItem
     Friend WithEvents MenuItem6 As System.Windows.Forms.MenuItem
     Friend WithEvents mnuHelp As System.Windows.Forms.MenuItem
     Friend WithEvents Splitter1 As System.Windows.Forms.Splitter
     Friend WithEvents MenuItem7 As System.Windows.Forms.MenuItem
     Friend WithEvents mnuPlaySel As System.Windows.Forms.MenuItem
     Friend WithEvents Timer As System.Windows.Forms.Timer
     Friend WithEvents mnuPlayUns As System.Windows.Forms.MenuItem
     Friend WithEvents MenuItem8 As System.Windows.Forms.MenuItem
     Friend WithEvents mnuTestSeg As System.Windows.Forms.MenuItem
     Friend WithEvents SegMenu As System.Windows.Forms.ContextMenu
     Friend WithEvents MenuItem9 As System.Windows.Forms.MenuItem
     Friend WithEvents MenuItem10 As System.Windows.Forms.MenuItem
     Friend WithEvents MenuItem11 As System.Windows.Forms.MenuItem
     Friend WithEvents Helper As System.Windows.Forms.HelpProvider
     Friend WithEvents MPcontrols As Editor.ucMPcontrols
     Friend WithEvents chkDel As System.Windows.Forms.CheckBox
     Friend WithEvents mnuCheckUpdate As System.Windows.Forms.MenuItem
     Friend WithEvents tabSplit As System.Windows.Forms.TabPage
     Friend WithEvents GroupBox1 As System.Windows.Forms.GroupBox
     Friend WithEvents radTime As System.Windows.Forms.RadioButton
     Friend WithEvents radPieces As System.Windows.Forms.RadioButton
     Friend WithEvents radSize As System.Windows.Forms.RadioButton
     Friend WithEvents cSplit As System.Windows.Forms.Button
     Friend WithEvents Label1 As System.Windows.Forms.Label
     Friend WithEvents Label2 As System.Windows.Forms.Label
     Friend WithEvents Label3 As System.Windows.Forms.Label
     Friend WithEvents Label4 As System.Windows.Forms.Label
     Friend WithEvents numSec As System.Windows.Forms.NumericUpDown
     Friend WithEvents numMin As System.Windows.Forms.NumericUpDown
     Friend WithEvents numHr As System.Windows.Forms.NumericUpDown
     Friend WithEvents numPcs As System.Windows.Forms.NumericUpDown
     Friend WithEvents Label5 As System.Windows.Forms.Label
     Friend WithEvents cbSize As System.Windows.Forms.ComboBox
     Friend WithEvents tFile2Split As System.Windows.Forms.TextBox
     Friend WithEvents Label6 As System.Windows.Forms.Label
     Friend WithEvents tSplitName As System.Windows.Forms.TextBox
     Friend WithEvents cSplitBrw As System.Windows.Forms.Button
     Friend WithEvents Label7 As System.Windows.Forms.Label
     Friend WithEvents cUp As System.Windows.Forms.ToolBarButton
     Friend WithEvents cDn As System.Windows.Forms.ToolBarButton
     Friend WithEvents PanelFine As System.Windows.Forms.Panel
     Friend WithEvents cStrtFrRev As System.Windows.Forms.Button
     Friend WithEvents cStrtFrFwd As System.Windows.Forms.Button
     Friend WithEvents cEndFrFwd As System.Windows.Forms.Button
     Friend WithEvents cEndFrRev As System.Windows.Forms.Button
     Friend WithEvents Label9 As System.Windows.Forms.Label
     Friend WithEvents mnuInfo As System.Windows.Forms.MenuItem
     Friend WithEvents ToolTips As System.Windows.Forms.ToolTip
     Friend WithEvents FineResolution As Editor.ucSlider
     Friend WithEvents lSize As System.Windows.Forms.Label
     Friend WithEvents cInfo As System.Windows.Forms.ToolBarButton
     Friend WithEvents tbJoin As System.Windows.Forms.ToolBar
     Friend WithEvents CheckBox1 As System.Windows.Forms.CheckBox
     Friend WithEvents tbTrace As System.Windows.Forms.ToolBar
     Friend WithEvents tcClearTrace As System.Windows.Forms.ToolBarButton
     Friend WithEvents tcSaveTrace As System.Windows.Forms.ToolBarButton
     Friend WithEvents panStatus As System.Windows.Forms.Panel
     Friend WithEvents picStat As System.Windows.Forms.PictureBox
     Friend WithEvents lMsgStat As System.Windows.Forms.Label
     Friend WithEvents MenuItem13 As System.Windows.Forms.MenuItem
     Friend WithEvents mnuSaveMask As System.Windows.Forms.MenuItem
     Friend WithEvents MenuItem14 As System.Windows.Forms.MenuItem
     Friend WithEvents Label11 As System.Windows.Forms.Label
     Friend WithEvents tbPositions As System.Windows.Forms.ToolBar
     Friend WithEvents cSaveMask As System.Windows.Forms.ToolBarButton
     Friend WithEvents cPlaySelected As System.Windows.Forms.ToolBarButton
     Friend WithEvents cPlayAll As System.Windows.Forms.ToolBarButton
     Friend WithEvents cOpenMask As System.Windows.Forms.ToolBarButton
     Friend WithEvents cPlayNotSelected As System.Windows.Forms.ToolBarButton
     Friend WithEvents mnuLoop As System.Windows.Forms.MenuItem
     Friend WithEvents cLoop As System.Windows.Forms.ToolBarButton
     Friend WithEvents tabSettings As System.Windows.Forms.TabPage
     Friend WithEvents chkFrameAccurate As System.Windows.Forms.CheckBox
     Friend WithEvents chkForceJoin As System.Windows.Forms.CheckBox
     Friend WithEvents lpanFineText As System.Windows.Forms.Label
     Friend WithEvents GroupBox2 As System.Windows.Forms.GroupBox
     Friend WithEvents GroupBox3 As System.Windows.Forms.GroupBox
     Friend WithEvents chkKeepMRU As System.Windows.Forms.CheckBox
     Friend WithEvents chkDialogView As System.Windows.Forms.CheckBox
     Friend WithEvents GroupBox4 As System.Windows.Forms.GroupBox
     Friend WithEvents Label8 As System.Windows.Forms.Label
     Friend WithEvents cbLang As System.Windows.Forms.ComboBox
     Friend WithEvents cTransleditor As System.Windows.Forms.Button
     Friend WithEvents LinkLabel1 As System.Windows.Forms.LinkLabel
     Friend WithEvents chkOnTop As System.Windows.Forms.CheckBox
     Friend WithEvents mnuImpSkip As System.Windows.Forms.MenuItem
     Friend WithEvents chkUpdate As System.Windows.Forms.CheckBox
     Friend WithEvents MenuItem12 As System.Windows.Forms.MenuItem
     Friend WithEvents mnuImpComskip As System.Windows.Forms.MenuItem
     Friend WithEvents MenuItem15 As System.Windows.Forms.MenuItem
     Friend WithEvents mnuSaveSepFiles As System.Windows.Forms.MenuItem
     Friend WithEvents tabTools As System.Windows.Forms.TabPage
     Friend WithEvents GroupBox5 As System.Windows.Forms.GroupBox
     Friend WithEvents GroupBox6 As System.Windows.Forms.GroupBox
     Friend WithEvents Label12 As System.Windows.Forms.Label
     Friend WithEvents cToolFind As System.Windows.Forms.Button
     Friend WithEvents tStdToolPath As System.Windows.Forms.TextBox
     Friend WithEvents linkToolURL As System.Windows.Forms.LinkLabel
     Friend WithEvents lblToolDesc As System.Windows.Forms.Label
     Friend WithEvents lbStdTools As System.Windows.Forms.ListBox
     Friend WithEvents cDetect As System.Windows.Forms.Button
     Friend WithEvents chkEnabled As System.Windows.Forms.CheckBox
     Friend WithEvents Label10 As System.Windows.Forms.Label
     Friend WithEvents MenuItem17 As System.Windows.Forms.MenuItem
     Friend WithEvents mnuDonate As System.Windows.Forms.MenuItem
     Friend WithEvents Panel1 As System.Windows.Forms.Panel
     Friend WithEvents statBar As System.Windows.Forms.StatusBar
     Friend WithEvents statMain As System.Windows.Forms.StatusBarPanel
     Friend WithEvents statDur As System.Windows.Forms.StatusBarPanel
     Friend WithEvents picStatus As System.Windows.Forms.PictureBox
     Friend WithEvents mnuDShow As System.Windows.Forms.MenuItem
     Friend WithEvents cDShow As System.Windows.Forms.Button
     Friend WithEvents statSel As System.Windows.Forms.StatusBarPanel
     Friend WithEvents panAudio As System.Windows.Forms.Panel
     Friend WithEvents picAudioDetail As System.Windows.Forms.PictureBox
     Friend WithEvents picAudioSumm As System.Windows.Forms.PictureBox
     Friend WithEvents mnuView As System.Windows.Forms.MenuItem
     Friend WithEvents mnuCompact As System.Windows.Forms.MenuItem
     Friend WithEvents mnuFullscreen As System.Windows.Forms.MenuItem
     Friend WithEvents chkBeep As System.Windows.Forms.CheckBox
     Friend WithEvents mnuUnload As System.Windows.Forms.MenuItem
     Friend WithEvents MenuItem16 As System.Windows.Forms.MenuItem
     <System.Diagnostics.DebuggerStepThrough()> Private Sub InitializeComponent()
         Me.components = New System.ComponentModel.Container
         Dim resources As System.ComponentModel.ComponentResourceManager = New System.ComponentModel.ComponentResourceManager(GetType(frmMain))
         Me.MainMenu1 = New System.Windows.Forms.MainMenu(Me.components)
         Me.MenuItem1 = New System.Windows.Forms.MenuItem
         Me.mnuOpen = New System.Windows.Forms.MenuItem
         Me.mnuSave = New System.Windows.Forms.MenuItem
         Me.mnuSaveX = New System.Windows.Forms.MenuItem
         Me.mnuSaveSepFiles = New System.Windows.Forms.MenuItem
         Me.MenuItem4 = New System.Windows.Forms.MenuItem
         Me.mnuSaveMask = New System.Windows.Forms.MenuItem
         Me.MenuItem17 = New System.Windows.Forms.MenuItem
         Me.MenuItem14 = New System.Windows.Forms.MenuItem
         Me.mnuUnload = New System.Windows.Forms.MenuItem
         Me.mnuExit = New System.Windows.Forms.MenuItem
         Me.MenuItem2 = New System.Windows.Forms.MenuItem
         Me.mnuInfo = New System.Windows.Forms.MenuItem
         Me.mnuDShow = New System.Windows.Forms.MenuItem
         Me.MenuItem3 = New System.Windows.Forms.MenuItem
         Me.MenuItem12 = New System.Windows.Forms.MenuItem
         Me.mnuImpSkip = New System.Windows.Forms.MenuItem
         Me.mnuImpComskip = New System.Windows.Forms.MenuItem
         Me.MenuItem15 = New System.Windows.Forms.MenuItem
         Me.MenuItem16 = New System.Windows.Forms.MenuItem
         Me.MenuItem7 = New System.Windows.Forms.MenuItem
         Me.mnuPlaySel = New System.Windows.Forms.MenuItem
         Me.mnuPlayUns = New System.Windows.Forms.MenuItem
         Me.MenuItem8 = New System.Windows.Forms.MenuItem
         Me.mnuTestSeg = New System.Windows.Forms.MenuItem
         Me.MenuItem13 = New System.Windows.Forms.MenuItem
         Me.mnuLoop = New System.Windows.Forms.MenuItem
         Me.mnuView = New System.Windows.Forms.MenuItem
         Me.mnuCompact = New System.Windows.Forms.MenuItem
         Me.mnuFullscreen = New System.Windows.Forms.MenuItem
         Me.MenuItem5 = New System.Windows.Forms.MenuItem
         Me.mnuHelp = New System.Windows.Forms.MenuItem
         Me.mnuCheckUpdate = New System.Windows.Forms.MenuItem
         Me.mnuDonate = New System.Windows.Forms.MenuItem
         Me.MenuItem6 = New System.Windows.Forms.MenuItem
         Me.dlgOpenFile = New System.Windows.Forms.OpenFileDialog
         Me.dlgSaveFile = New System.Windows.Forms.SaveFileDialog
         Me.mainTabs = New System.Windows.Forms.TabControl
         Me.tabPlayer = New System.Windows.Forms.TabPage
         Me.panAudio = New System.Windows.Forms.Panel
         Me.picAudioDetail = New System.Windows.Forms.PictureBox
         Me.picAudioSumm = New System.Windows.Forms.PictureBox
         Me.mPlayer = New AxWMPLib.AxWindowsMediaPlayer
         Me.tabJoin = New System.Windows.Forms.TabPage
         Me.chkDel = New System.Windows.Forms.CheckBox
         Me.chkAuto = New System.Windows.Forms.CheckBox
         Me.lvFiles = New System.Windows.Forms.ListView
         Me.ColumnHeader1 = New System.Windows.Forms.ColumnHeader
         Me.tbJoin = New System.Windows.Forms.ToolBar
         Me.cSort = New System.Windows.Forms.ToolBarButton
         Me.cRemove = New System.Windows.Forms.ToolBarButton
         Me.cClear = New System.Windows.Forms.ToolBarButton
         Me.cJoin = New System.Windows.Forms.ToolBarButton
         Me.cOpen = New System.Windows.Forms.ToolBarButton
         Me.cUp = New System.Windows.Forms.ToolBarButton
         Me.cDn = New System.Windows.Forms.ToolBarButton
         Me.cInfo = New System.Windows.Forms.ToolBarButton
         Me.ImageList1 = New System.Windows.Forms.ImageList(Me.components)
         Me.tabSplit = New System.Windows.Forms.TabPage
         Me.lSize = New System.Windows.Forms.Label
         Me.Label6 = New System.Windows.Forms.Label
         Me.cSplitBrw = New System.Windows.Forms.Button
         Me.tSplitName = New System.Windows.Forms.TextBox
         Me.cSplit = New System.Windows.Forms.Button
         Me.GroupBox1 = New System.Windows.Forms.GroupBox
         Me.cbSize = New System.Windows.Forms.ComboBox
         Me.numSec = New System.Windows.Forms.NumericUpDown
         Me.Label2 = New System.Windows.Forms.Label
         Me.radTime = New System.Windows.Forms.RadioButton
         Me.radPieces = New System.Windows.Forms.RadioButton
         Me.radSize = New System.Windows.Forms.RadioButton
         Me.Label3 = New System.Windows.Forms.Label
         Me.Label4 = New System.Windows.Forms.Label
         Me.numMin = New System.Windows.Forms.NumericUpDown
         Me.numHr = New System.Windows.Forms.NumericUpDown
         Me.numPcs = New System.Windows.Forms.NumericUpDown
         Me.Label5 = New System.Windows.Forms.Label
         Me.tFile2Split = New System.Windows.Forms.TextBox
         Me.Label1 = New System.Windows.Forms.Label
         Me.Label7 = New System.Windows.Forms.Label
         Me.tabTrace = New System.Windows.Forms.TabPage
         Me.panStatus = New System.Windows.Forms.Panel
         Me.lMsgStat = New System.Windows.Forms.Label
         Me.picStat = New System.Windows.Forms.PictureBox
         Me.CheckBox1 = New System.Windows.Forms.CheckBox
         Me.rtfTrace = New System.Windows.Forms.RichTextBox
         Me.tbTrace = New System.Windows.Forms.ToolBar
         Me.tcClearTrace = New System.Windows.Forms.ToolBarButton
         Me.tcSaveTrace = New System.Windows.Forms.ToolBarButton
         Me.tabSettings = New System.Windows.Forms.TabPage
         Me.GroupBox3 = New System.Windows.Forms.GroupBox
         Me.chkForceJoin = New System.Windows.Forms.CheckBox
         Me.chkKeepMRU = New System.Windows.Forms.CheckBox
         Me.chkDialogView = New System.Windows.Forms.CheckBox
         Me.chkBeep = New System.Windows.Forms.CheckBox
         Me.chkOnTop = New System.Windows.Forms.CheckBox
         Me.chkUpdate = New System.Windows.Forms.CheckBox
         Me.GroupBox2 = New System.Windows.Forms.GroupBox
         Me.chkFrameAccurate = New System.Windows.Forms.CheckBox
         Me.GroupBox4 = New System.Windows.Forms.GroupBox
         Me.LinkLabel1 = New System.Windows.Forms.LinkLabel
         Me.cTransleditor = New System.Windows.Forms.Button
         Me.Label8 = New System.Windows.Forms.Label
         Me.cbLang = New System.Windows.Forms.ComboBox
         Me.tabTools = New System.Windows.Forms.TabPage
         Me.GroupBox6 = New System.Windows.Forms.GroupBox
         Me.Label12 = New System.Windows.Forms.Label
         Me.GroupBox5 = New System.Windows.Forms.GroupBox
         Me.cDShow = New System.Windows.Forms.Button
         Me.tStdToolPath = New System.Windows.Forms.TextBox
         Me.Label10 = New System.Windows.Forms.Label
         Me.chkEnabled = New System.Windows.Forms.CheckBox
         Me.cDetect = New System.Windows.Forms.Button
         Me.cToolFind = New System.Windows.Forms.Button
         Me.linkToolURL = New System.Windows.Forms.LinkLabel
         Me.lblToolDesc = New System.Windows.Forms.Label
         Me.lbStdTools = New System.Windows.Forms.ListBox
         Me.panSegments = New System.Windows.Forms.Panel
         Me.lvPositions = New System.Windows.Forms.ListView
         Me.colStart = New System.Windows.Forms.ColumnHeader
         Me.colEnd = New System.Windows.Forms.ColumnHeader
         Me.SegMenu = New System.Windows.Forms.ContextMenu
         Me.MenuItem10 = New System.Windows.Forms.MenuItem
         Me.MenuItem9 = New System.Windows.Forms.MenuItem
         Me.MenuItem11 = New System.Windows.Forms.MenuItem
         Me.tbPositions = New System.Windows.Forms.ToolBar
         Me.cPlayAll = New System.Windows.Forms.ToolBarButton
         Me.cPlayNotSelected = New System.Windows.Forms.ToolBarButton
         Me.cPlaySelected = New System.Windows.Forms.ToolBarButton
         Me.cSaveMask = New System.Windows.Forms.ToolBarButton
         Me.cOpenMask = New System.Windows.Forms.ToolBarButton
         Me.cLoop = New System.Windows.Forms.ToolBarButton
         Me.Label11 = New System.Windows.Forms.Label
         Me.Splitter1 = New System.Windows.Forms.Splitter
         Me.Timer = New System.Windows.Forms.Timer(Me.components)
         Me.Helper = New System.Windows.Forms.HelpProvider
         Me.Panel1 = New System.Windows.Forms.Panel
         Me.statBar = New System.Windows.Forms.StatusBar
         Me.statMain = New System.Windows.Forms.StatusBarPanel
         Me.statSel = New System.Windows.Forms.StatusBarPanel
         Me.statDur = New System.Windows.Forms.StatusBarPanel
         Me.picStatus = New System.Windows.Forms.PictureBox
         Me.PanelFine = New System.Windows.Forms.Panel
         Me.Label9 = New System.Windows.Forms.Label
         Me.cEndFrRev = New System.Windows.Forms.Button
         Me.cEndFrFwd = New System.Windows.Forms.Button
         Me.cStrtFrFwd = New System.Windows.Forms.Button
         Me.cStrtFrRev = New System.Windows.Forms.Button
         Me.lpanFineText = New System.Windows.Forms.Label
         Me.ToolTips = New System.Windows.Forms.ToolTip(Me.components)
         Me.MPcontrols = New Editor.ucMPcontrols
         Me.FineResolution = New Editor.ucSlider
         Me.mainTabs.SuspendLayout()
         Me.tabPlayer.SuspendLayout()
         Me.panAudio.SuspendLayout()
         CType(Me.picAudioDetail, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.picAudioSumm, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.mPlayer, System.ComponentModel.ISupportInitialize).BeginInit()
         Me.tabJoin.SuspendLayout()
         Me.tabSplit.SuspendLayout()
         Me.GroupBox1.SuspendLayout()
         CType(Me.numSec, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.numMin, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.numHr, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.numPcs, System.ComponentModel.ISupportInitialize).BeginInit()
         Me.tabTrace.SuspendLayout()
         Me.panStatus.SuspendLayout()
         CType(Me.picStat, System.ComponentModel.ISupportInitialize).BeginInit()
         Me.tabSettings.SuspendLayout()
         Me.GroupBox3.SuspendLayout()
         Me.GroupBox2.SuspendLayout()
         Me.GroupBox4.SuspendLayout()
         Me.tabTools.SuspendLayout()
         Me.GroupBox6.SuspendLayout()
         Me.GroupBox5.SuspendLayout()
         Me.panSegments.SuspendLayout()
         Me.Panel1.SuspendLayout()
         CType(Me.statMain, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.statSel, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.statDur, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.picStatus, System.ComponentModel.ISupportInitialize).BeginInit()
         Me.PanelFine.SuspendLayout()
         Me.SuspendLayout()
         '
         'MainMenu1
         '
         Me.MainMenu1.MenuItems.AddRange(New System.Windows.Forms.MenuItem() {Me.MenuItem1, Me.MenuItem2, Me.MenuItem7, Me.mnuView, Me.MenuItem5})
         '
         'MenuItem1
         '
         Me.MenuItem1.Index = 0
         Me.MenuItem1.MenuItems.AddRange(New System.Windows.Forms.MenuItem() {Me.mnuOpen, Me.mnuSave, Me.mnuSaveX, Me.mnuSaveSepFiles, Me.MenuItem4, Me.mnuSaveMask, Me.MenuItem17, Me.MenuItem14, Me.mnuUnload, Me.mnuExit})
         Me.MenuItem1.Text = "&File"
         '
         'mnuOpen
         '
         Me.mnuOpen.Index = 0
         Me.mnuOpen.Shortcut = System.Windows.Forms.Shortcut.CtrlO
         Me.mnuOpen.Text = "&Open Movie File"
         '
         'mnuSave
         '
         Me.mnuSave.Index = 1
         Me.mnuSave.Shortcut = System.Windows.Forms.Shortcut.F7
         Me.mnuSave.Text = "Sa&ve Selected Parts"
         '
         'mnuSaveX
         '
         Me.mnuSaveX.Index = 2
         Me.mnuSaveX.Shortcut = System.Windows.Forms.Shortcut.ShiftF7
         Me.mnuSaveX.Text = "Save &Without Selected Parts"
         '
         'mnuSaveSepFiles
         '
         Me.mnuSaveSepFiles.Index = 3
         Me.mnuSaveSepFiles.Shortcut = System.Windows.Forms.Shortcut.F6
         Me.mnuSaveSepFiles.Text = "Save Selections as Se&parate files"
         '
         'MenuItem4
         '
         Me.MenuItem4.Index = 4
         Me.MenuItem4.Text = "-"
         '
         'mnuSaveMask
         '
         Me.mnuSaveMask.Index = 5
         Me.mnuSaveMask.Shortcut = System.Windows.Forms.Shortcut.CtrlM
         Me.mnuSaveMask.Text = "&Save Selections as MoviClips"
         '
         'MenuItem17
         '
         Me.MenuItem17.Index = 6
         Me.MenuItem17.Text = "-"
         '
         'MenuItem14
         '
         Me.MenuItem14.Index = 7
         Me.MenuItem14.Text = "-"
         '
         'mnuUnload
         '
         Me.mnuUnload.Index = 8
         Me.mnuUnload.Shortcut = System.Windows.Forms.Shortcut.CtrlW
         Me.mnuUnload.Text = "&Unload Movie"
         '
         'mnuExit
         '
         Me.mnuExit.Index = 9
         Me.mnuExit.Shortcut = System.Windows.Forms.Shortcut.CtrlX
         Me.mnuExit.Text = "E&xit"
         '
         'MenuItem2
         '
         Me.MenuItem2.Index = 1
         Me.MenuItem2.MenuItems.AddRange(New System.Windows.Forms.MenuItem() {Me.mnuInfo, Me.mnuDShow, Me.MenuItem3, Me.MenuItem12, Me.mnuImpSkip, Me.mnuImpComskip, Me.MenuItem15, Me.MenuItem16})
         Me.MenuItem2.Text = "&Tools"
         '
         'mnuInfo
         '
         Me.mnuInfo.Enabled = False
         Me.mnuInfo.Index = 0
         Me.mnuInfo.Shortcut = System.Windows.Forms.Shortcut.CtrlI
         Me.mnuInfo.Text = "Show &Information on Movie"
         '
         'mnuDShow
         '
         Me.mnuDShow.Index = 1
         Me.mnuDShow.Text = "Show directShow filters"
         '
         'MenuItem3
         '
         Me.MenuItem3.Index = 2
         Me.MenuItem3.Shortcut = System.Windows.Forms.Shortcut.CtrlZ
         Me.MenuItem3.Text = "&Test"
         Me.MenuItem3.Visible = False
         '
         'MenuItem12
         '
         Me.MenuItem12.Index = 3
         Me.MenuItem12.Text = "-"
         '
         'mnuImpSkip
         '
         Me.mnuImpSkip.Enabled = False
         Me.mnuImpSkip.Index = 4
         Me.mnuImpSkip.Text = "Import SmartSkip file"
         '
         'mnuImpComskip
         '
         Me.mnuImpComskip.Enabled = False
         Me.mnuImpComskip.Index = 5
         Me.mnuImpComskip.Text = "Import Comskip file"
         '
         'MenuItem15
         '
         Me.MenuItem15.Index = 6
         Me.MenuItem15.Text = "-"
         '
         'MenuItem16
         '
         Me.MenuItem16.Enabled = False
         Me.MenuItem16.Index = 7
         Me.MenuItem16.Text = "Run Comskip"
         Me.MenuItem16.Visible = False
         '
         'MenuItem7
         '
         Me.MenuItem7.Index = 2
         Me.MenuItem7.MenuItems.AddRange(New System.Windows.Forms.MenuItem() {Me.mnuPlaySel, Me.mnuPlayUns, Me.MenuItem8, Me.mnuTestSeg, Me.MenuItem13, Me.mnuLoop})
         Me.MenuItem7.Text = "&Play"
         '
         'mnuPlaySel
         '
         Me.mnuPlaySel.Index = 0
         Me.mnuPlaySel.Shortcut = System.Windows.Forms.Shortcut.CtrlP
         Me.mnuPlaySel.Text = "Play All &Selected Parts"
         '
         'mnuPlayUns
         '
         Me.mnuPlayUns.Index = 1
         Me.mnuPlayUns.Shortcut = System.Windows.Forms.Shortcut.CtrlShiftP
         Me.mnuPlayUns.Text = "Play Parts &Not Selected"
         '
         'MenuItem8
         '
         Me.MenuItem8.Index = 2
         Me.MenuItem8.Text = "-"
         '
         'mnuTestSeg
         '
         Me.mnuTestSeg.Index = 3
         Me.mnuTestSeg.Shortcut = System.Windows.Forms.Shortcut.CtrlT
         Me.mnuTestSeg.Text = "Play Highligh&ted Part(s)"
         '
         'MenuItem13
         '
         Me.MenuItem13.Index = 4
         Me.MenuItem13.Text = "-"
         '
         'mnuLoop
         '
         Me.mnuLoop.Index = 5
         Me.mnuLoop.Shortcut = System.Windows.Forms.Shortcut.CtrlL
         Me.mnuLoop.Text = "Play in Loop"
         '
         'mnuView
         '
         Me.mnuView.Index = 3
         Me.mnuView.MenuItems.AddRange(New System.Windows.Forms.MenuItem() {Me.mnuCompact, Me.mnuFullscreen})
         Me.mnuView.Text = "&View"
         '
         'mnuCompact
         '
         Me.mnuCompact.Index = 0
         Me.mnuCompact.Text = "Compact Mode"
         '
         'mnuFullscreen
         '
         Me.mnuFullscreen.Index = 1
         Me.mnuFullscreen.Text = "Full Screen"
         '
         'MenuItem5
         '
         Me.MenuItem5.Index = 4
         Me.MenuItem5.MenuItems.AddRange(New System.Windows.Forms.MenuItem() {Me.mnuHelp, Me.mnuCheckUpdate, Me.mnuDonate, Me.MenuItem6})
         Me.MenuItem5.Text = "&Help"
         '
         'mnuHelp
         '
         Me.mnuHelp.Index = 0
         Me.mnuHelp.Shortcut = System.Windows.Forms.Shortcut.F1
         Me.mnuHelp.Text = "&Help"
         '
         'mnuCheckUpdate
         '
         Me.mnuCheckUpdate.Index = 1
         Me.mnuCheckUpdate.Text = "&Check for updates"
         '
         'mnuDonate
         '
         Me.mnuDonate.Index = 2
         Me.mnuDonate.Text = "Donate"
         '
         'MenuItem6
         '
         Me.MenuItem6.Index = 3
         Me.MenuItem6.Text = "&About Movica"
         '
         'dlgOpenFile
         '
         Me.dlgOpenFile.Title = "Select video file"
         '
         'dlgSaveFile
         '
         Me.dlgSaveFile.Title = "Select Output file"
         '
         'mainTabs
         '
         Me.mainTabs.Controls.Add(Me.tabPlayer)
         Me.mainTabs.Controls.Add(Me.tabJoin)
         Me.mainTabs.Controls.Add(Me.tabSplit)
         Me.mainTabs.Controls.Add(Me.tabTrace)
         Me.mainTabs.Controls.Add(Me.tabSettings)
         Me.mainTabs.Controls.Add(Me.tabTools)
         Me.mainTabs.Dock = System.Windows.Forms.DockStyle.Fill
         Me.mainTabs.Location = New System.Drawing.Point(0, 0)
         Me.mainTabs.Name = "mainTabs"
         Me.mainTabs.SelectedIndex = 0
         Me.mainTabs.Size = New System.Drawing.Size(594, 413)
         Me.mainTabs.TabIndex = 5
         '
         'tabPlayer
         '
         Me.tabPlayer.BackColor = System.Drawing.Color.Black
         Me.tabPlayer.BackgroundImage = CType(resources.GetObject("tabPlayer.BackgroundImage"), System.Drawing.Image)
         Me.tabPlayer.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Center
         Me.tabPlayer.Controls.Add(Me.panAudio)
         Me.tabPlayer.Controls.Add(Me.mPlayer)
         Me.tabPlayer.Controls.Add(Me.MPcontrols)
         Me.tabPlayer.Location = New System.Drawing.Point(4, 22)
         Me.tabPlayer.Name = "tabPlayer"
         Me.tabPlayer.Size = New System.Drawing.Size(586, 387)
         Me.tabPlayer.TabIndex = 0
         Me.tabPlayer.Text = "Player"
         '
         'panAudio
         '
         Me.panAudio.BackColor = System.Drawing.Color.Black
         Me.panAudio.Controls.Add(Me.picAudioDetail)
         Me.panAudio.Controls.Add(Me.picAudioSumm)
         Me.panAudio.Dock = System.Windows.Forms.DockStyle.Fill
         Me.panAudio.Location = New System.Drawing.Point(0, 0)
         Me.panAudio.Name = "panAudio"
         Me.panAudio.Size = New System.Drawing.Size(586, 331)
         Me.panAudio.TabIndex = 4
         Me.panAudio.Visible = False
         '
         'picAudioDetail
         '
         Me.picAudioDetail.BackColor = System.Drawing.Color.White
         Me.picAudioDetail.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Center
         Me.picAudioDetail.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.picAudioDetail.Dock = System.Windows.Forms.DockStyle.Fill
         Me.picAudioDetail.Location = New System.Drawing.Point(0, 0)
         Me.picAudioDetail.Margin = New System.Windows.Forms.Padding(0)
         Me.picAudioDetail.Name = "picAudioDetail"
         Me.picAudioDetail.Size = New System.Drawing.Size(586, 245)
         Me.picAudioDetail.TabIndex = 5
         Me.picAudioDetail.TabStop = False
         Me.ToolTips.SetToolTip(Me.picAudioDetail, "The next release will show detailed waveform views of the audio here")
         '
         'picAudioSumm
         '
         Me.picAudioSumm.BackColor = System.Drawing.Color.White
         Me.picAudioSumm.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Stretch
         Me.picAudioSumm.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.picAudioSumm.Dock = System.Windows.Forms.DockStyle.Bottom
         Me.picAudioSumm.Location = New System.Drawing.Point(0, 245)
         Me.picAudioSumm.Name = "picAudioSumm"
         Me.picAudioSumm.Size = New System.Drawing.Size(586, 86)
         Me.picAudioSumm.TabIndex = 4
         Me.picAudioSumm.TabStop = False
         '
         'mPlayer
         '
         Me.mPlayer.Dock = System.Windows.Forms.DockStyle.Fill
         Me.mPlayer.Enabled = True
         Me.mPlayer.Location = New System.Drawing.Point(0, 0)
         Me.mPlayer.Name = "mPlayer"
         Me.mPlayer.OcxState = CType(resources.GetObject("mPlayer.OcxState"), System.Windows.Forms.AxHost.State)
         Me.mPlayer.Size = New System.Drawing.Size(586, 331)
         Me.mPlayer.TabIndex = 1
         Me.mPlayer.TabStop = False
         Me.mPlayer.Visible = False
         '
         'tabJoin
         '
         Me.tabJoin.Controls.Add(Me.chkDel)
         Me.tabJoin.Controls.Add(Me.chkAuto)
         Me.tabJoin.Controls.Add(Me.lvFiles)
         Me.tabJoin.Controls.Add(Me.tbJoin)
         Me.tabJoin.Location = New System.Drawing.Point(4, 22)
         Me.tabJoin.Name = "tabJoin"
         Me.tabJoin.Size = New System.Drawing.Size(586, 387)
         Me.tabJoin.TabIndex = 2
         Me.tabJoin.Text = "Join"
         Me.tabJoin.UseVisualStyleBackColor = True
         '
         'chkDel
         '
         Me.chkDel.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.chkDel.BackColor = System.Drawing.SystemColors.Control
         Me.chkDel.Location = New System.Drawing.Point(248, 3)
         Me.chkDel.Name = "chkDel"
         Me.chkDel.Size = New System.Drawing.Size(184, 25)
         Me.chkDel.TabIndex = 2
         Me.chkDel.Text = "Delete after joining"
         Me.chkDel.UseVisualStyleBackColor = False
         '
         'chkAuto
         '
         Me.chkAuto.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.chkAuto.BackColor = System.Drawing.SystemColors.Control
         Me.chkAuto.Checked = True
         Me.chkAuto.CheckState = System.Windows.Forms.CheckState.Checked
         Me.chkAuto.Location = New System.Drawing.Point(440, 3)
         Me.chkAuto.Name = "chkAuto"
         Me.chkAuto.Size = New System.Drawing.Size(136, 25)
         Me.chkAuto.TabIndex = 2
         Me.chkAuto.Text = "Auto detect parts"
         Me.chkAuto.UseVisualStyleBackColor = False
         '
         'lvFiles
         '
         Me.lvFiles.Columns.AddRange(New System.Windows.Forms.ColumnHeader() {Me.ColumnHeader1})
         Me.lvFiles.Dock = System.Windows.Forms.DockStyle.Fill
         Me.lvFiles.FullRowSelect = True
         Me.lvFiles.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.None
         Me.lvFiles.Location = New System.Drawing.Point(0, 28)
         Me.lvFiles.Name = "lvFiles"
         Me.lvFiles.Size = New System.Drawing.Size(586, 359)
         Me.lvFiles.TabIndex = 1
         Me.lvFiles.UseCompatibleStateImageBehavior = False
         Me.lvFiles.View = System.Windows.Forms.View.Details
         '
         'ColumnHeader1
         '
         Me.ColumnHeader1.Width = 495
         '
         'tbJoin
         '
         Me.tbJoin.Buttons.AddRange(New System.Windows.Forms.ToolBarButton() {Me.cSort, Me.cRemove, Me.cClear, Me.cJoin, Me.cOpen, Me.cUp, Me.cDn, Me.cInfo})
         Me.tbJoin.DropDownArrows = True
         Me.tbJoin.ImageList = Me.ImageList1
         Me.tbJoin.Location = New System.Drawing.Point(0, 0)
         Me.tbJoin.Name = "tbJoin"
         Me.tbJoin.ShowToolTips = True
         Me.tbJoin.Size = New System.Drawing.Size(586, 28)
         Me.tbJoin.TabIndex = 0
         '
         'cSort
         '
         Me.cSort.ImageIndex = 1
         Me.cSort.Name = "cSort"
         Me.cSort.Tag = "Sort"
         Me.cSort.ToolTipText = "Sort the list"
         '
         'cRemove
         '
         Me.cRemove.ImageIndex = 5
         Me.cRemove.Name = "cRemove"
         Me.cRemove.Tag = "Remove"
         Me.cRemove.ToolTipText = "Remove the items from the list"
         '
         'cClear
         '
         Me.cClear.ImageIndex = 0
         Me.cClear.Name = "cClear"
         Me.cClear.Tag = "Clear"
         Me.cClear.ToolTipText = "Clear list"
         '
         'cJoin
         '
         Me.cJoin.ImageIndex = 3
         Me.cJoin.Name = "cJoin"
         Me.cJoin.Tag = "Join"
         Me.cJoin.ToolTipText = "Join files in the list"
         '
         'cOpen
         '
         Me.cOpen.ImageIndex = 4
         Me.cOpen.Name = "cOpen"
         Me.cOpen.Tag = "Open"
         Me.cOpen.ToolTipText = "Select file to join"
         '
         'cUp
         '
         Me.cUp.ImageIndex = 6
         Me.cUp.Name = "cUp"
         Me.cUp.Tag = "Up"
         Me.cUp.ToolTipText = "Move highlighted files up"
         '
         'cDn
         '
         Me.cDn.ImageIndex = 7
         Me.cDn.Name = "cDn"
         Me.cDn.Tag = "Dn"
         Me.cDn.ToolTipText = "Move highlighted files down"
         '
         'cInfo
         '
         Me.cInfo.ImageIndex = 10
         Me.cInfo.Name = "cInfo"
         Me.cInfo.Tag = "Info"
         Me.cInfo.ToolTipText = "Show information on files"
         '
         'ImageList1
         '
         Me.ImageList1.ImageStream = CType(resources.GetObject("ImageList1.ImageStream"), System.Windows.Forms.ImageListStreamer)
         Me.ImageList1.TransparentColor = System.Drawing.Color.White
         Me.ImageList1.Images.SetKeyName(0, "")
         Me.ImageList1.Images.SetKeyName(1, "")
         Me.ImageList1.Images.SetKeyName(2, "")
         Me.ImageList1.Images.SetKeyName(3, "")
         Me.ImageList1.Images.SetKeyName(4, "")
         Me.ImageList1.Images.SetKeyName(5, "")
         Me.ImageList1.Images.SetKeyName(6, "")
         Me.ImageList1.Images.SetKeyName(7, "")
         Me.ImageList1.Images.SetKeyName(8, "")
         Me.ImageList1.Images.SetKeyName(9, "")
         Me.ImageList1.Images.SetKeyName(10, "")
         Me.ImageList1.Images.SetKeyName(11, "")
         Me.ImageList1.Images.SetKeyName(12, "")
         Me.ImageList1.Images.SetKeyName(13, "")
         Me.ImageList1.Images.SetKeyName(14, "")
         Me.ImageList1.Images.SetKeyName(15, "")
         Me.ImageList1.Images.SetKeyName(16, "")
         Me.ImageList1.Images.SetKeyName(17, "")
         '
         'tabSplit
         '
         Me.tabSplit.Controls.Add(Me.lSize)
         Me.tabSplit.Controls.Add(Me.Label6)
         Me.tabSplit.Controls.Add(Me.cSplitBrw)
         Me.tabSplit.Controls.Add(Me.tSplitName)
         Me.tabSplit.Controls.Add(Me.cSplit)
         Me.tabSplit.Controls.Add(Me.GroupBox1)
         Me.tabSplit.Controls.Add(Me.tFile2Split)
         Me.tabSplit.Controls.Add(Me.Label1)
         Me.tabSplit.Controls.Add(Me.Label7)
         Me.tabSplit.Location = New System.Drawing.Point(4, 22)
         Me.tabSplit.Name = "tabSplit"
         Me.tabSplit.Size = New System.Drawing.Size(586, 387)
         Me.tabSplit.TabIndex = 3
         Me.tabSplit.Text = "Split"
         Me.tabSplit.UseVisualStyleBackColor = True
         '
         'lSize
         '
         Me.lSize.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.lSize.Font = New System.Drawing.Font("Microsoft Sans Serif", 11.25!, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.lSize.Location = New System.Drawing.Point(24, 235)
         Me.lSize.Name = "lSize"
         Me.lSize.Size = New System.Drawing.Size(136, 24)
         Me.lSize.TabIndex = 5
         Me.lSize.Text = "0 kb"
         Me.lSize.TextAlign = System.Drawing.ContentAlignment.MiddleCenter
         '
         'Label6
         '
         Me.Label6.Location = New System.Drawing.Point(8, 173)
         Me.Label6.Name = "Label6"
         Me.Label6.Size = New System.Drawing.Size(104, 40)
         Me.Label6.TabIndex = 5
         Me.Label6.Text = "Name for split files"
         Me.Label6.TextAlign = System.Drawing.ContentAlignment.MiddleCenter
         '
         'cSplitBrw
         '
         Me.cSplitBrw.Enabled = False
         Me.cSplitBrw.Location = New System.Drawing.Point(464, 181)
         Me.cSplitBrw.Name = "cSplitBrw"
         Me.cSplitBrw.Size = New System.Drawing.Size(56, 22)
         Me.cSplitBrw.TabIndex = 4
         Me.cSplitBrw.Text = "Browse"
         '
         'tSplitName
         '
         Me.tSplitName.Location = New System.Drawing.Point(120, 181)
         Me.tSplitName.Name = "tSplitName"
         Me.tSplitName.Size = New System.Drawing.Size(336, 20)
         Me.tSplitName.TabIndex = 3
         '
         'cSplit
         '
         Me.cSplit.Enabled = False
         Me.cSplit.Location = New System.Drawing.Point(16, 269)
         Me.cSplit.Name = "cSplit"
         Me.cSplit.Size = New System.Drawing.Size(504, 32)
         Me.cSplit.TabIndex = 2
         Me.cSplit.Text = "&Split the file"
         '
         'GroupBox1
         '
         Me.GroupBox1.Controls.Add(Me.cbSize)
         Me.GroupBox1.Controls.Add(Me.numSec)
         Me.GroupBox1.Controls.Add(Me.Label2)
         Me.GroupBox1.Controls.Add(Me.radTime)
         Me.GroupBox1.Controls.Add(Me.radPieces)
         Me.GroupBox1.Controls.Add(Me.radSize)
         Me.GroupBox1.Controls.Add(Me.Label3)
         Me.GroupBox1.Controls.Add(Me.Label4)
         Me.GroupBox1.Controls.Add(Me.numMin)
         Me.GroupBox1.Controls.Add(Me.numHr)
         Me.GroupBox1.Controls.Add(Me.numPcs)
         Me.GroupBox1.Controls.Add(Me.Label5)
         Me.GroupBox1.Location = New System.Drawing.Point(8, 48)
         Me.GroupBox1.Name = "GroupBox1"
         Me.GroupBox1.Size = New System.Drawing.Size(512, 120)
         Me.GroupBox1.TabIndex = 1
         Me.GroupBox1.TabStop = False
         Me.GroupBox1.Text = "Select splitting method"
         '
         'cbSize
         '
         Me.cbSize.Location = New System.Drawing.Point(128, 84)
         Me.cbSize.Name = "cbSize"
         Me.cbSize.Size = New System.Drawing.Size(72, 21)
         Me.cbSize.Sorted = True
         Me.cbSize.TabIndex = 7
         '
         'numSec
         '
         Me.numSec.Location = New System.Drawing.Point(273, 24)
         Me.numSec.Maximum = New Decimal(New Integer() {60, 0, 0, 0})
         Me.numSec.Minimum = New Decimal(New Integer() {1, 0, 0, 0})
         Me.numSec.Name = "numSec"
         Me.numSec.Size = New System.Drawing.Size(40, 20)
         Me.numSec.TabIndex = 5
         Me.numSec.Value = New Decimal(New Integer() {1, 0, 0, 0})
         '
         'Label2
         '
         Me.Label2.Location = New System.Drawing.Point(162, 27)
         Me.Label2.Name = "Label2"
         Me.Label2.Size = New System.Drawing.Size(16, 23)
         Me.Label2.TabIndex = 2
         Me.Label2.Text = "hr"
         '
         'radTime
         '
         Me.radTime.Checked = True
         Me.radTime.Location = New System.Drawing.Point(16, 24)
         Me.radTime.Name = "radTime"
         Me.radTime.Size = New System.Drawing.Size(104, 24)
         Me.radTime.TabIndex = 0
         Me.radTime.TabStop = True
         Me.radTime.Text = "Play Duration"
         '
         'radPieces
         '
         Me.radPieces.Location = New System.Drawing.Point(16, 53)
         Me.radPieces.Name = "radPieces"
         Me.radPieces.Size = New System.Drawing.Size(104, 24)
         Me.radPieces.TabIndex = 0
         Me.radPieces.Text = "Pieces"
         '
         'radSize
         '
         Me.radSize.Location = New System.Drawing.Point(16, 84)
         Me.radSize.Name = "radSize"
         Me.radSize.Size = New System.Drawing.Size(104, 24)
         Me.radSize.TabIndex = 0
         Me.radSize.Text = "Size"
         '
         'Label3
         '
         Me.Label3.Location = New System.Drawing.Point(237, 26)
         Me.Label3.Name = "Label3"
         Me.Label3.Size = New System.Drawing.Size(24, 23)
         Me.Label3.TabIndex = 2
         Me.Label3.Text = "min"
         '
         'Label4
         '
         Me.Label4.Location = New System.Drawing.Point(318, 27)
         Me.Label4.Name = "Label4"
         Me.Label4.Size = New System.Drawing.Size(35, 23)
         Me.Label4.TabIndex = 2
         Me.Label4.Text = "sec"
         '
         'numMin
         '
         Me.numMin.Location = New System.Drawing.Point(194, 24)
         Me.numMin.Maximum = New Decimal(New Integer() {60, 0, 0, 0})
         Me.numMin.Name = "numMin"
         Me.numMin.Size = New System.Drawing.Size(40, 20)
         Me.numMin.TabIndex = 4
         '
         'numHr
         '
         Me.numHr.Location = New System.Drawing.Point(128, 24)
         Me.numHr.Maximum = New Decimal(New Integer() {4, 0, 0, 0})
         Me.numHr.Name = "numHr"
         Me.numHr.Size = New System.Drawing.Size(32, 20)
         Me.numHr.TabIndex = 3
         '
         'numPcs
         '
         Me.numPcs.Location = New System.Drawing.Point(128, 53)
         Me.numPcs.Maximum = New Decimal(New Integer() {50, 0, 0, 0})
         Me.numPcs.Minimum = New Decimal(New Integer() {2, 0, 0, 0})
         Me.numPcs.Name = "numPcs"
         Me.numPcs.Size = New System.Drawing.Size(40, 20)
         Me.numPcs.TabIndex = 6
         Me.numPcs.Value = New Decimal(New Integer() {2, 0, 0, 0})
         '
         'Label5
         '
         Me.Label5.Location = New System.Drawing.Point(204, 90)
         Me.Label5.Name = "Label5"
         Me.Label5.Size = New System.Drawing.Size(35, 23)
         Me.Label5.TabIndex = 2
         Me.Label5.Text = "kb"
         '
         'tFile2Split
         '
         Me.tFile2Split.Location = New System.Drawing.Point(8, 16)
         Me.tFile2Split.Name = "tFile2Split"
         Me.tFile2Split.ReadOnly = True
         Me.tFile2Split.Size = New System.Drawing.Size(512, 20)
         Me.tFile2Split.TabIndex = 0
         '
         'Label1
         '
         Me.Label1.Location = New System.Drawing.Point(168, 205)
         Me.Label1.Name = "Label1"
         Me.Label1.Size = New System.Drawing.Size(352, 64)
         Me.Label1.TabIndex = 2
         Me.Label1.Text = "Note
             "ries of the peices may not co-incide with those inferred from the settings above" & _
             "."
         Me.Label1.TextAlign = System.Drawing.ContentAlignment.MiddleCenter
         '
         'Label7
         '
         Me.Label7.Location = New System.Drawing.Point(8, 217)
         Me.Label7.Name = "Label7"
         Me.Label7.Size = New System.Drawing.Size(160, 16)
         Me.Label7.TabIndex = 5
         Me.Label7.Text = "Estimated file size"
         Me.Label7.TextAlign = System.Drawing.ContentAlignment.MiddleCenter
         '
         'tabTrace
         '
         Me.tabTrace.Controls.Add(Me.panStatus)
         Me.tabTrace.Controls.Add(Me.CheckBox1)
         Me.tabTrace.Controls.Add(Me.rtfTrace)
         Me.tabTrace.Controls.Add(Me.tbTrace)
         Me.tabTrace.Location = New System.Drawing.Point(4, 22)
         Me.tabTrace.Name = "tabTrace"
         Me.tabTrace.Size = New System.Drawing.Size(586, 387)
         Me.tabTrace.TabIndex = 1
         Me.tabTrace.Text = "Trace"
         Me.tabTrace.UseVisualStyleBackColor = True
         '
         'panStatus
         '
         Me.panStatus.BackColor = System.Drawing.SystemColors.Info
         Me.panStatus.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.panStatus.Controls.Add(Me.lMsgStat)
         Me.panStatus.Controls.Add(Me.picStat)
         Me.panStatus.Location = New System.Drawing.Point(96, 5)
         Me.panStatus.Name = "panStatus"
         Me.Helper.SetShowHelp(Me.panStatus, True)
         Me.panStatus.Size = New System.Drawing.Size(232, 20)
         Me.panStatus.TabIndex = 2
         '
         'lMsgStat
         '
         Me.lMsgStat.Dock = System.Windows.Forms.DockStyle.Fill
         Me.lMsgStat.Font = New System.Drawing.Font("Microsoft Sans Serif", 8.25!, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.lMsgStat.Location = New System.Drawing.Point(16, 0)
         Me.lMsgStat.Name = "lMsgStat"
         Me.lMsgStat.Size = New System.Drawing.Size(212, 16)
         Me.lMsgStat.TabIndex = 1
         Me.lMsgStat.Text = "Status of last operation"
         Me.lMsgStat.TextAlign = System.Drawing.ContentAlignment.MiddleLeft
         '
         'picStat
         '
         Me.picStat.Dock = System.Windows.Forms.DockStyle.Left
         Me.picStat.Location = New System.Drawing.Point(0, 0)
         Me.picStat.Name = "picStat"
         Me.picStat.Size = New System.Drawing.Size(16, 16)
         Me.picStat.TabIndex = 0
         Me.picStat.TabStop = False
         '
         'CheckBox1
         '
         Me.CheckBox1.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CheckBox1.BackColor = System.Drawing.SystemColors.Control
         Me.CheckBox1.Checked = True
         Me.CheckBox1.CheckState = System.Windows.Forms.CheckState.Checked
         Me.CheckBox1.Enabled = False
         Me.CheckBox1.Location = New System.Drawing.Point(408, 8)
         Me.CheckBox1.Name = "CheckBox1"
         Me.CheckBox1.Size = New System.Drawing.Size(160, 16)
         Me.CheckBox1.TabIndex = 0
         Me.CheckBox1.Text = "Show detailed results"
         Me.CheckBox1.UseVisualStyleBackColor = False
         '
         'rtfTrace
         '
         Me.rtfTrace.DetectUrls = False
         Me.rtfTrace.Dock = System.Windows.Forms.DockStyle.Fill
         Me.rtfTrace.Location = New System.Drawing.Point(0, 28)
         Me.rtfTrace.Name = "rtfTrace"
         Me.rtfTrace.ReadOnly = True
         Me.rtfTrace.Size = New System.Drawing.Size(586, 359)
         Me.rtfTrace.TabIndex = 0
         Me.rtfTrace.Text = "Output from converter shown here"
         '
         'tbTrace
         '
         Me.tbTrace.Buttons.AddRange(New System.Windows.Forms.ToolBarButton() {Me.tcClearTrace, Me.tcSaveTrace})
         Me.tbTrace.ButtonSize = New System.Drawing.Size(23, 22)
         Me.tbTrace.DropDownArrows = True
         Me.tbTrace.ImageList = Me.ImageList1
         Me.tbTrace.Location = New System.Drawing.Point(0, 0)
         Me.tbTrace.Name = "tbTrace"
         Me.tbTrace.ShowToolTips = True
         Me.tbTrace.Size = New System.Drawing.Size(586, 28)
         Me.tbTrace.TabIndex = 1
         '
         'tcClearTrace
         '
         Me.tcClearTrace.ImageIndex = 0
         Me.tcClearTrace.Name = "tcClearTrace"
         Me.tcClearTrace.Tag = "Clear"
         Me.tcClearTrace.ToolTipText = "Clear the log displayed below"
         '
         'tcSaveTrace
         '
         Me.tcSaveTrace.ImageIndex = 11
         Me.tcSaveTrace.Name = "tcSaveTrace"
         Me.tcSaveTrace.Tag = "Save"
         Me.tcSaveTrace.ToolTipText = "Save the log shown below"
         '
         'tabSettings
         '
         Me.tabSettings.Controls.Add(Me.GroupBox3)
         Me.tabSettings.Controls.Add(Me.GroupBox2)
         Me.tabSettings.Controls.Add(Me.GroupBox4)
         Me.tabSettings.Location = New System.Drawing.Point(4, 22)
         Me.tabSettings.Name = "tabSettings"
         Me.tabSettings.Size = New System.Drawing.Size(586, 387)
         Me.tabSettings.TabIndex = 4
         Me.tabSettings.Text = "Advanced"
         Me.tabSettings.UseVisualStyleBackColor = True
         '
         'GroupBox3
         '
         Me.GroupBox3.Controls.Add(Me.chkForceJoin)
         Me.GroupBox3.Controls.Add(Me.chkKeepMRU)
         Me.GroupBox3.Controls.Add(Me.chkDialogView)
         Me.GroupBox3.Controls.Add(Me.chkBeep)
         Me.GroupBox3.Controls.Add(Me.chkOnTop)
         Me.GroupBox3.Controls.Add(Me.chkUpdate)
         Me.GroupBox3.Location = New System.Drawing.Point(16, 15)
         Me.GroupBox3.Name = "GroupBox3"
         Me.GroupBox3.Size = New System.Drawing.Size(552, 165)
         Me.GroupBox3.TabIndex = 2
         Me.GroupBox3.TabStop = False
         Me.GroupBox3.Text = "General"
         '
         'chkForceJoin
         '
         Me.chkForceJoin.Location = New System.Drawing.Point(8, 15)
         Me.chkForceJoin.Name = "chkForceJoin"
         Me.chkForceJoin.Size = New System.Drawing.Size(538, 30)
         Me.chkForceJoin.TabIndex = 0
         Me.chkForceJoin.Text = "Force joining of incompatible files. As the name suggests the results will be unp" & _
             "redictable."
         '
         'chkKeepMRU
         '
         Me.chkKeepMRU.Location = New System.Drawing.Point(8, 114)
         Me.chkKeepMRU.Name = "chkKeepMRU"
         Me.chkKeepMRU.Size = New System.Drawing.Size(538, 23)
         Me.chkKeepMRU.TabIndex = 0
         Me.chkKeepMRU.Text = "Keep history"
         '
         'chkDialogView
         '
         Me.chkDialogView.Checked = True
         Me.chkDialogView.CheckState = System.Windows.Forms.CheckState.Checked
         Me.chkDialogView.Location = New System.Drawing.Point(8, 41)
         Me.chkDialogView.Name = "chkDialogView"
         Me.chkDialogView.Size = New System.Drawing.Size(538, 23)
         Me.chkDialogView.TabIndex = 0
         Me.chkDialogView.Text = "Show thumbnails when selecting video files"
         '
         'chkBeep
         '
         Me.chkBeep.Location = New System.Drawing.Point(8, 90)
         Me.chkBeep.Name = "chkBeep"
         Me.chkBeep.Size = New System.Drawing.Size(538, 23)
         Me.chkBeep.TabIndex = 0
         Me.chkBeep.Text = "Beep when done"
         '
         'chkOnTop
         '
         Me.chkOnTop.Location = New System.Drawing.Point(8, 66)
         Me.chkOnTop.Name = "chkOnTop"
         Me.chkOnTop.Size = New System.Drawing.Size(538, 23)
         Me.chkOnTop.TabIndex = 0
         Me.chkOnTop.Text = "Keep Movica window on top when playing"
         '
         'chkUpdate
         '
         Me.chkUpdate.Location = New System.Drawing.Point(8, 138)
         Me.chkUpdate.Name = "chkUpdate"
         Me.chkUpdate.Size = New System.Drawing.Size(538, 23)
         Me.chkUpdate.TabIndex = 0
         Me.chkUpdate.Text = "Check for updates at startup"
         '
         'GroupBox2
         '
         Me.GroupBox2.Controls.Add(Me.chkFrameAccurate)
         Me.GroupBox2.Location = New System.Drawing.Point(16, 186)
         Me.GroupBox2.Name = "GroupBox2"
         Me.GroupBox2.Size = New System.Drawing.Size(552, 62)
         Me.GroupBox2.TabIndex = 1
         Me.GroupBox2.TabStop = False
         Me.GroupBox2.Text = "Windows Media (.wmv / .asf)"
         '
         'chkFrameAccurate
         '
         Me.chkFrameAccurate.Location = New System.Drawing.Point(8, 22)
         Me.chkFrameAccurate.Name = "chkFrameAccurate"
         Me.chkFrameAccurate.Size = New System.Drawing.Size(512, 32)
         Me.chkFrameAccurate.TabIndex = 0
         Me.chkFrameAccurate.Text = "Enable frame accurate editing (This does not work on all files; turn this option " & _
             "off if your edit is not successful)"
         '
         'GroupBox4
         '
         Me.GroupBox4.Controls.Add(Me.LinkLabel1)
         Me.GroupBox4.Controls.Add(Me.cTransleditor)
         Me.GroupBox4.Controls.Add(Me.Label8)
         Me.GroupBox4.Controls.Add(Me.cbLang)
         Me.GroupBox4.Location = New System.Drawing.Point(16, 256)
         Me.GroupBox4.Name = "GroupBox4"
         Me.GroupBox4.Size = New System.Drawing.Size(552, 104)
         Me.GroupBox4.TabIndex = 3
         Me.GroupBox4.TabStop = False
         Me.GroupBox4.Text = "Language"
         '
         'LinkLabel1
         '
         Me.LinkLabel1.Location = New System.Drawing.Point(392, 72)
         Me.LinkLabel1.Name = "LinkLabel1"
         Me.LinkLabel1.Size = New System.Drawing.Size(100, 23)
         Me.LinkLabel1.TabIndex = 3
         Me.LinkLabel1.TabStop = True
         Me.LinkLabel1.Text = "Send it to Movica"
         Me.ToolTips.SetToolTip(Me.LinkLabel1, "email your translations for addition in the next version")
         '
         'cTransleditor
         '
         Me.cTransleditor.Location = New System.Drawing.Point(232, 72)
         Me.cTransleditor.Name = "cTransleditor"
         Me.cTransleditor.Size = New System.Drawing.Size(152, 24)
         Me.cTransleditor.TabIndex = 2
         Me.cTransleditor.Text = "Edit Languages"
         '
         'Label8
         '
         Me.Label8.Location = New System.Drawing.Point(232, 24)
         Me.Label8.Name = "Label8"
         Me.Label8.Size = New System.Drawing.Size(248, 48)
         Me.Label8.TabIndex = 1
         Me.Label8.Text = "Please do not laugh too hard at the translations. Help me by sending me your tran" & _
             "slations. Use button below to edit."
         '
         'cbLang
         '
         Me.cbLang.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.cbLang.Location = New System.Drawing.Point(8, 32)
         Me.cbLang.Name = "cbLang"
         Me.cbLang.Size = New System.Drawing.Size(192, 21)
         Me.cbLang.TabIndex = 0
         '
         'tabTools
         '
         Me.tabTools.Controls.Add(Me.GroupBox6)
         Me.tabTools.Controls.Add(Me.GroupBox5)
         Me.tabTools.Location = New System.Drawing.Point(4, 22)
         Me.tabTools.Name = "tabTools"
         Me.tabTools.Padding = New System.Windows.Forms.Padding(3)
         Me.tabTools.Size = New System.Drawing.Size(586, 387)
         Me.tabTools.TabIndex = 5
         Me.tabTools.Text = "Add Tools"
         Me.tabTools.ToolTipText = "Add support for more tools"
         Me.tabTools.UseVisualStyleBackColor = True
         '
         'GroupBox6
         '
         Me.GroupBox6.Controls.Add(Me.Label12)
         Me.GroupBox6.Location = New System.Drawing.Point(6, 230)
         Me.GroupBox6.Name = "GroupBox6"
         Me.GroupBox6.Size = New System.Drawing.Size(574, 156)
         Me.GroupBox6.TabIndex = 1
         Me.GroupBox6.TabStop = False
         Me.GroupBox6.Text = "Any command-line tool"
         '
         'Label12
         '
         Me.Label12.AutoSize = True
         Me.Label12.Location = New System.Drawing.Point(13, 30)
         Me.Label12.Name = "Label12"
         Me.Label12.Size = New System.Drawing.Size(86, 13)
         Me.Label12.TabIndex = 0
         Me.Label12.Text = "Still working on it"
         '
         'GroupBox5
         '
         Me.GroupBox5.Controls.Add(Me.cDShow)
         Me.GroupBox5.Controls.Add(Me.tStdToolPath)
         Me.GroupBox5.Controls.Add(Me.Label10)
         Me.GroupBox5.Controls.Add(Me.chkEnabled)
         Me.GroupBox5.Controls.Add(Me.cDetect)
         Me.GroupBox5.Controls.Add(Me.cToolFind)
         Me.GroupBox5.Controls.Add(Me.linkToolURL)
         Me.GroupBox5.Controls.Add(Me.lblToolDesc)
         Me.GroupBox5.Controls.Add(Me.lbStdTools)
         Me.GroupBox5.Location = New System.Drawing.Point(6, 6)
         Me.GroupBox5.Name = "GroupBox5"
         Me.GroupBox5.Size = New System.Drawing.Size(574, 218)
         Me.GroupBox5.TabIndex = 0
         Me.GroupBox5.TabStop = False
         Me.GroupBox5.Text = "Standard tools"
         '
         'cDShow
         '
         Me.cDShow.Location = New System.Drawing.Point(174, 183)
         Me.cDShow.Name = "cDShow"
         Me.cDShow.Size = New System.Drawing.Size(387, 22)
         Me.cDShow.TabIndex = 8
         Me.cDShow.Text = "List filters"
         Me.cDShow.UseVisualStyleBackColor = True
         '
         'tStdToolPath
         '
         Me.tStdToolPath.Location = New System.Drawing.Point(206, 157)
         Me.tStdToolPath.Name = "tStdToolPath"
         Me.tStdToolPath.ReadOnly = True
         Me.tStdToolPath.Size = New System.Drawing.Size(300, 20)
         Me.tStdToolPath.TabIndex = 3
         '
         'Label10
         '
         Me.Label10.AutoSize = True
         Me.Label10.Location = New System.Drawing.Point(171, 160)
         Me.Label10.Name = "Label10"
         Me.Label10.Size = New System.Drawing.Size(29, 13)
         Me.Label10.TabIndex = 7
         Me.Label10.Text = "Path"
         '
         'chkEnabled
         '
         Me.chkEnabled.AutoSize = True
         Me.chkEnabled.Location = New System.Drawing.Point(174, 20)
         Me.chkEnabled.Name = "chkEnabled"
         Me.chkEnabled.Size = New System.Drawing.Size(98, 17)
         Me.chkEnabled.TabIndex = 6
         Me.chkEnabled.Text = "Enable this tool"
         Me.chkEnabled.UseVisualStyleBackColor = True
         '
         'cDetect
         '
         Me.cDetect.Enabled = False
         Me.cDetect.Location = New System.Drawing.Point(513, 16)
         Me.cDetect.Name = "cDetect"
         Me.cDetect.Size = New System.Drawing.Size(49, 47)
         Me.cDetect.TabIndex = 5
         Me.cDetect.Text = "Auto Detect"
         Me.cDetect.UseVisualStyleBackColor = True
         '
         'cToolFind
         '
         Me.cToolFind.Enabled = False
         Me.cToolFind.Location = New System.Drawing.Point(512, 156)
         Me.cToolFind.Name = "cToolFind"
         Me.cToolFind.Size = New System.Drawing.Size(50, 20)
         Me.cToolFind.TabIndex = 4
         Me.cToolFind.Text = "&Browse"
         Me.cToolFind.UseVisualStyleBackColor = True
         '
         'linkToolURL
         '
         Me.linkToolURL.AutoSize = True
         Me.linkToolURL.Location = New System.Drawing.Point(171, 134)
         Me.linkToolURL.Name = "linkToolURL"
         Me.linkToolURL.Size = New System.Drawing.Size(59, 13)
         Me.linkToolURL.TabIndex = 2
         Me.linkToolURL.TabStop = True
         Me.linkToolURL.Text = "LinkLabel2"
         '
         'lblToolDesc
         '
         Me.lblToolDesc.Location = New System.Drawing.Point(174, 45)
         Me.lblToolDesc.Name = "lblToolDesc"
         Me.lblToolDesc.Size = New System.Drawing.Size(332, 82)
         Me.lblToolDesc.TabIndex = 1
         Me.lblToolDesc.Text = "Label10"
         '
         'lbStdTools
         '
         Me.lbStdTools.DisplayMember = "DisplayName"
         Me.lbStdTools.FormattingEnabled = True
         Me.lbStdTools.Location = New System.Drawing.Point(14, 20)
         Me.lbStdTools.Name = "lbStdTools"
         Me.lbStdTools.Size = New System.Drawing.Size(151, 186)
         Me.lbStdTools.Sorted = True
         Me.lbStdTools.TabIndex = 0
         '
         'panSegments
         '
         Me.panSegments.Controls.Add(Me.lvPositions)
         Me.panSegments.Controls.Add(Me.tbPositions)
         Me.panSegments.Controls.Add(Me.Label11)
         Me.panSegments.Dock = System.Windows.Forms.DockStyle.Right
         Me.panSegments.Location = New System.Drawing.Point(597, 0)
         Me.panSegments.Name = "panSegments"
         Me.panSegments.Size = New System.Drawing.Size(139, 413)
         Me.panSegments.TabIndex = 6
         '
         'lvPositions
         '
         Me.lvPositions.Columns.AddRange(New System.Windows.Forms.ColumnHeader() {Me.colStart, Me.colEnd})
         Me.lvPositions.ContextMenu = Me.SegMenu
         Me.lvPositions.Dock = System.Windows.Forms.DockStyle.Fill
         Me.lvPositions.FullRowSelect = True
         Me.lvPositions.HideSelection = False
         Me.lvPositions.Location = New System.Drawing.Point(0, 44)
         Me.lvPositions.Name = "lvPositions"
         Me.lvPositions.Size = New System.Drawing.Size(139, 369)
         Me.lvPositions.TabIndex = 4
         Me.lvPositions.UseCompatibleStateImageBehavior = False
         Me.lvPositions.View = System.Windows.Forms.View.Details
         '
         'colStart
         '
         Me.colStart.Text = "Start"
         Me.colStart.Width = 67
         '
         'colEnd
         '
         Me.colEnd.Text = "End"
         Me.colEnd.Width = 68
         '
         'SegMenu
         '
         Me.SegMenu.MenuItems.AddRange(New System.Windows.Forms.MenuItem() {Me.MenuItem10, Me.MenuItem9, Me.MenuItem11})
         '
         'MenuItem10
         '
         Me.MenuItem10.Index = 0
         Me.MenuItem10.Text = "&Delete"
         '
         'MenuItem9
         '
         Me.MenuItem9.Index = 1
         Me.MenuItem9.Text = "&Copy"
         '
         'MenuItem11
         '
         Me.MenuItem11.Index = 2
         Me.MenuItem11.Text = "&Paste"
         '
         'tbPositions
         '
         Me.tbPositions.Appearance = System.Windows.Forms.ToolBarAppearance.Flat
         Me.tbPositions.Buttons.AddRange(New System.Windows.Forms.ToolBarButton() {Me.cPlayAll, Me.cPlayNotSelected, Me.cPlaySelected, Me.cSaveMask, Me.cOpenMask, Me.cLoop})
         Me.tbPositions.ButtonSize = New System.Drawing.Size(22, 22)
         Me.tbPositions.DropDownArrows = True
         Me.tbPositions.ImageList = Me.ImageList1
         Me.tbPositions.Location = New System.Drawing.Point(0, 16)
         Me.tbPositions.Name = "tbPositions"
         Me.tbPositions.ShowToolTips = True
         Me.tbPositions.Size = New System.Drawing.Size(139, 28)
         Me.tbPositions.TabIndex = 6
         '
         'cPlayAll
         '
         Me.cPlayAll.ImageIndex = 14
         Me.cPlayAll.Name = "cPlayAll"
         Me.cPlayAll.Tag = "Play"
         Me.cPlayAll.ToolTipText = "Play all the selected parts. Closest thing to a proof test [Ctrl + P]"
         '
         'cPlayNotSelected
         '
         Me.cPlayNotSelected.ImageIndex = 15
         Me.cPlayNotSelected.Name = "cPlayNotSelected"
         Me.cPlayNotSelected.Tag = "PlayNotSelected"
         Me.cPlayNotSelected.ToolTipText = "Plays all those parts of the movie that are not selected [Shift + Ctrl + P]"
         '
         'cPlaySelected
         '
         Me.cPlaySelected.ImageIndex = 16
         Me.cPlaySelected.Name = "cPlaySelected"
         Me.cPlaySelected.Tag = "PlaySelected"
         Me.cPlaySelected.ToolTipText = "Play just the highlighted parts from the list below [Ctrl + T]"
         '
         'cSaveMask
         '
         Me.cSaveMask.ImageIndex = 11
         Me.cSaveMask.Name = "cSaveMask"
         Me.cSaveMask.Tag = "Save"
         Me.cSaveMask.ToolTipText = "Save the parts as a MoviClip (er..cliplist?) [Ctrl + M]"
         '
         'cOpenMask
         '
         Me.cOpenMask.ImageIndex = 4
         Me.cOpenMask.Name = "cOpenMask"
         Me.cOpenMask.Tag = "Open"
         Me.cOpenMask.ToolTipText = "Open a MoviClip"
         '
         'cLoop
         '
         Me.cLoop.ImageIndex = 17
         Me.cLoop.Name = "cLoop"
         Me.cLoop.Style = System.Windows.Forms.ToolBarButtonStyle.ToggleButton
         Me.cLoop.Tag = "ToggleRepeat"
         Me.cLoop.ToolTipText = "Repeat play (Ctrl + L)"
         '
         'Label11
         '
         Me.Label11.Dock = System.Windows.Forms.DockStyle.Top
         Me.Label11.Location = New System.Drawing.Point(0, 0)
         Me.Label11.Name = "Label11"
         Me.Label11.Size = New System.Drawing.Size(139, 16)
         Me.Label11.TabIndex = 5
         Me.Label11.Text = "Selected Parts"
         Me.Label11.TextAlign = System.Drawing.ContentAlignment.MiddleCenter
         '
         'Splitter1
         '
         Me.Splitter1.Dock = System.Windows.Forms.DockStyle.Right
         Me.Splitter1.Location = New System.Drawing.Point(594, 0)
         Me.Splitter1.Name = "Splitter1"
         Me.Splitter1.Size = New System.Drawing.Size(3, 413)
         Me.Splitter1.TabIndex = 8
         Me.Splitter1.TabStop = False
         '
         'Timer
         '
         '
         'Panel1
         '
         Me.Panel1.Controls.Add(Me.statBar)
         Me.Panel1.Controls.Add(Me.picStatus)
         Me.Panel1.Dock = System.Windows.Forms.DockStyle.Bottom
         Me.Panel1.Location = New System.Drawing.Point(0, 429)
         Me.Panel1.Name = "Panel1"
         Me.Helper.SetShowHelp(Me.Panel1, True)
         Me.Panel1.Size = New System.Drawing.Size(736, 22)
         Me.Panel1.TabIndex = 9
         '
         'statBar
         '
         Me.statBar.Location = New System.Drawing.Point(22, 0)
         Me.statBar.Name = "statBar"
         Me.statBar.Panels.AddRange(New System.Windows.Forms.StatusBarPanel() {Me.statMain, Me.statSel, Me.statDur})
         Me.statBar.ShowPanels = True
         Me.statBar.Size = New System.Drawing.Size(714, 22)
         Me.statBar.TabIndex = 3
         '
         'statMain
         '
         Me.statMain.AutoSize = System.Windows.Forms.StatusBarPanelAutoSize.Spring
         Me.statMain.Name = "statMain"
         Me.statMain.Text = "Status displayed here"
         Me.statMain.Width = 617
         '
         'statSel
         '
         Me.statSel.AutoSize = System.Windows.Forms.StatusBarPanelAutoSize.Contents
         Me.statSel.MinWidth = 40
         Me.statSel.Name = "statSel"
         Me.statSel.Width = 40
         '
         'statDur
         '
         Me.statDur.AutoSize = System.Windows.Forms.StatusBarPanelAutoSize.Contents
         Me.statDur.MinWidth = 40
         Me.statDur.Name = "statDur"
         Me.statDur.Width = 40
         '
         'picStatus
         '
         Me.picStatus.BackgroundImageLayout = System.Windows.Forms.ImageLayout.None
         Me.picStatus.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.picStatus.Dock = System.Windows.Forms.DockStyle.Left
         Me.picStatus.Image = CType(resources.GetObject("picStatus.Image"), System.Drawing.Image)
         Me.picStatus.ImageLocation = ""
         Me.picStatus.InitialImage = Nothing
         Me.picStatus.Location = New System.Drawing.Point(0, 0)
         Me.picStatus.Name = "picStatus"
         Me.picStatus.Padding = New System.Windows.Forms.Padding(2)
         Me.picStatus.Size = New System.Drawing.Size(22, 22)
         Me.picStatus.TabIndex = 1
         Me.picStatus.TabStop = False
         Me.picStatus.Visible = False
         '
         'PanelFine
         '
         Me.PanelFine.Controls.Add(Me.FineResolution)
         Me.PanelFine.Controls.Add(Me.Label9)
         Me.PanelFine.Controls.Add(Me.cEndFrRev)
         Me.PanelFine.Controls.Add(Me.cEndFrFwd)
         Me.PanelFine.Controls.Add(Me.cStrtFrFwd)
         Me.PanelFine.Controls.Add(Me.cStrtFrRev)
         Me.PanelFine.Controls.Add(Me.lpanFineText)
         Me.PanelFine.Dock = System.Windows.Forms.DockStyle.Bottom
         Me.PanelFine.Location = New System.Drawing.Point(0, 413)
         Me.PanelFine.Name = "PanelFine"
         Me.PanelFine.Size = New System.Drawing.Size(736, 16)
         Me.PanelFine.TabIndex = 3
         '
         'Label9
         '
         Me.Label9.BackColor = System.Drawing.SystemColors.ControlDark
         Me.Label9.Dock = System.Windows.Forms.DockStyle.Left
         Me.Label9.Location = New System.Drawing.Point(48, 0)
         Me.Label9.Name = "Label9"
         Me.Label9.Size = New System.Drawing.Size(72, 16)
         Me.Label9.TabIndex = 16
         Me.Label9.Text = "  Granularity"
         Me.Label9.TextAlign = System.Drawing.ContentAlignment.MiddleCenter
         Me.ToolTips.SetToolTip(Me.Label9, "Please use the slider to set the granularity of the fine tuning arrow buttons")
         '
         'cEndFrRev
         '
         Me.cEndFrRev.BackColor = System.Drawing.SystemColors.ControlDark
         Me.cEndFrRev.Dock = System.Windows.Forms.DockStyle.Right
         Me.cEndFrRev.FlatStyle = System.Windows.Forms.FlatStyle.Popup
         Me.cEndFrRev.ImageIndex = 9
         Me.cEndFrRev.ImageList = Me.ImageList1
         Me.cEndFrRev.Location = New System.Drawing.Point(688, 0)
         Me.cEndFrRev.Name = "cEndFrRev"
         Me.cEndFrRev.Size = New System.Drawing.Size(24, 16)
         Me.cEndFrRev.TabIndex = 14
         Me.ToolTips.SetToolTip(Me.cEndFrRev, "Move end point earlier")
         Me.cEndFrRev.UseVisualStyleBackColor = False
         '
         'cEndFrFwd
         '
         Me.cEndFrFwd.BackColor = System.Drawing.SystemColors.ControlDark
         Me.cEndFrFwd.Dock = System.Windows.Forms.DockStyle.Right
         Me.cEndFrFwd.FlatStyle = System.Windows.Forms.FlatStyle.Popup
         Me.cEndFrFwd.ImageIndex = 8
         Me.cEndFrFwd.ImageList = Me.ImageList1
         Me.cEndFrFwd.Location = New System.Drawing.Point(712, 0)
         Me.cEndFrFwd.Name = "cEndFrFwd"
         Me.cEndFrFwd.Size = New System.Drawing.Size(24, 16)
         Me.cEndFrFwd.TabIndex = 13
         Me.ToolTips.SetToolTip(Me.cEndFrFwd, "Move end point later")
         Me.cEndFrFwd.UseVisualStyleBackColor = False
         '
         'cStrtFrFwd
         '
         Me.cStrtFrFwd.BackColor = System.Drawing.SystemColors.ControlDark
         Me.cStrtFrFwd.Dock = System.Windows.Forms.DockStyle.Left
         Me.cStrtFrFwd.FlatStyle = System.Windows.Forms.FlatStyle.Popup
         Me.cStrtFrFwd.ImageIndex = 8
         Me.cStrtFrFwd.ImageList = Me.ImageList1
         Me.cStrtFrFwd.Location = New System.Drawing.Point(24, 0)
         Me.cStrtFrFwd.Name = "cStrtFrFwd"
         Me.cStrtFrFwd.Size = New System.Drawing.Size(24, 16)
         Me.cStrtFrFwd.TabIndex = 12
         Me.ToolTips.SetToolTip(Me.cStrtFrFwd, "Move starting point later")
         Me.cStrtFrFwd.UseVisualStyleBackColor = False
         '
         'cStrtFrRev
         '
         Me.cStrtFrRev.BackColor = System.Drawing.SystemColors.ControlDark
         Me.cStrtFrRev.Dock = System.Windows.Forms.DockStyle.Left
         Me.cStrtFrRev.FlatStyle = System.Windows.Forms.FlatStyle.Popup
         Me.cStrtFrRev.ImageIndex = 9
         Me.cStrtFrRev.ImageList = Me.ImageList1
         Me.cStrtFrRev.Location = New System.Drawing.Point(0, 0)
         Me.cStrtFrRev.Name = "cStrtFrRev"
         Me.cStrtFrRev.Size = New System.Drawing.Size(24, 16)
         Me.cStrtFrRev.TabIndex = 11
         Me.ToolTips.SetToolTip(Me.cStrtFrRev, "Move starting point earlier")
         Me.cStrtFrRev.UseVisualStyleBackColor = False
         '
         'lpanFineText
         '
         Me.lpanFineText.Dock = System.Windows.Forms.DockStyle.Fill
         Me.lpanFineText.Location = New System.Drawing.Point(0, 0)
         Me.lpanFineText.Name = "lpanFineText"
         Me.lpanFineText.Size = New System.Drawing.Size(736, 16)
         Me.lpanFineText.TabIndex = 18
         Me.lpanFineText.Text = "The fine tuning controls will be available here when you highlight a particular s" & _
             "election from the right on the 'Player' tab."
         Me.lpanFineText.TextAlign = System.Drawing.ContentAlignment.MiddleCenter
         '
         'MPcontrols
         '
         Me.MPcontrols.BackColor = System.Drawing.SystemColors.Control
         Me.MPcontrols.DisplayMode = Editor.ucMPcontrols.MPCDisplayMode.Normal
         Me.MPcontrols.Dock = System.Windows.Forms.DockStyle.Bottom
         Me.MPcontrols.Location = New System.Drawing.Point(0, 331)
         Me.MPcontrols.Margin = New System.Windows.Forms.Padding(0)
         Me.MPcontrols.Mute = False
         Me.MPcontrols.Name = "MPcontrols"
         Me.MPcontrols.Padding = New System.Windows.Forms.Padding(3, 3, 3, 0)
         Me.MPcontrols.Size = New System.Drawing.Size(586, 56)
         Me.MPcontrols.TabIndex = 2
         Me.MPcontrols.Volume = 0
         '
         'FineResolution
         '
         Me.FineResolution.BackColor = System.Drawing.SystemColors.ControlDark
         Me.FineResolution.Dock = System.Windows.Forms.DockStyle.Bottom
         Me.FineResolution.Location = New System.Drawing.Point(120, 0)
         Me.FineResolution.Maximum = 1.0!
         Me.FineResolution.Minimum = 0.01!
         Me.FineResolution.Name = "FineResolution"
         Me.FineResolution.Padding = New System.Windows.Forms.Padding(2)
         Me.FineResolution.Size = New System.Drawing.Size(568, 16)
         Me.FineResolution.TabIndex = 15
         Me.ToolTips.SetToolTip(Me.FineResolution, "Please use the slider to set the granularity of the fine tuning arrow buttons")
         Me.FineResolution.Value = 0.15!
         '
         'frmMain
         '
         Me.AllowDrop = True
         Me.AutoScaleBaseSize = New System.Drawing.Size(5, 13)
         Me.BackColor = System.Drawing.SystemColors.Control
         Me.BackgroundImageLayout = System.Windows.Forms.ImageLayout.None
         Me.ClientSize = New System.Drawing.Size(736, 451)
         Me.Controls.Add(Me.mainTabs)
         Me.Controls.Add(Me.Splitter1)
         Me.Controls.Add(Me.panSegments)
         Me.Controls.Add(Me.PanelFine)
         Me.Controls.Add(Me.Panel1)
         Me.DoubleBuffered = True
         Me.Icon = CType(resources.GetObject("$this.Icon"), System.Drawing.Icon)
         Me.KeyPreview = True
         Me.Menu = Me.MainMenu1
         Me.MinimumSize = New System.Drawing.Size(600, 485)
         Me.Name = "frmMain"
         Me.Text = "Movica"
         Me.mainTabs.ResumeLayout(False)
         Me.tabPlayer.ResumeLayout(False)
         Me.panAudio.ResumeLayout(False)
         CType(Me.picAudioDetail, System.ComponentModel.ISupportInitialize).EndInit()
         CType(Me.picAudioSumm, System.ComponentModel.ISupportInitialize).EndInit()
         CType(Me.mPlayer, System.ComponentModel.ISupportInitialize).EndInit()
         Me.tabJoin.ResumeLayout(False)
         Me.tabJoin.PerformLayout()
         Me.tabSplit.ResumeLayout(False)
         Me.tabSplit.PerformLayout()
         Me.GroupBox1.ResumeLayout(False)
         CType(Me.numSec, System.ComponentModel.ISupportInitialize).EndInit()
         CType(Me.numMin, System.ComponentModel.ISupportInitialize).EndInit()
         CType(Me.numHr, System.ComponentModel.ISupportInitialize).EndInit()
         CType(Me.numPcs, System.ComponentModel.ISupportInitialize).EndInit()
         Me.tabTrace.ResumeLayout(False)
         Me.tabTrace.PerformLayout()
         Me.panStatus.ResumeLayout(False)
         CType(Me.picStat, System.ComponentModel.ISupportInitialize).EndInit()
         Me.tabSettings.ResumeLayout(False)
         Me.GroupBox3.ResumeLayout(False)
         Me.GroupBox2.ResumeLayout(False)
         Me.GroupBox4.ResumeLayout(False)
         Me.tabTools.ResumeLayout(False)
         Me.GroupBox6.ResumeLayout(False)
         Me.GroupBox6.PerformLayout()
         Me.GroupBox5.ResumeLayout(False)
         Me.GroupBox5.PerformLayout()
         Me.panSegments.ResumeLayout(False)
         Me.panSegments.PerformLayout()
         Me.Panel1.ResumeLayout(False)
         CType(Me.statMain, System.ComponentModel.ISupportInitialize).EndInit()
         CType(Me.statSel, System.ComponentModel.ISupportInitialize).EndInit()
         CType(Me.statDur, System.ComponentModel.ISupportInitialize).EndInit()
         CType(Me.picStatus, System.ComponentModel.ISupportInitialize).EndInit()
         Me.PanelFine.ResumeLayout(False)
         Me.ResumeLayout(False)
 
     End Sub
 
 #End Region
 
 #Region "   WinAPI declares "
 
     Private Structure SHFILEOPSTRUCT
         Dim hwnd As Integer
         Dim wFunc As Integer
         Dim pFrom As String
         Dim pTo As String
         Dim fFlags As Short
         Dim fAnyOperationsAborted As Boolean
         Dim hNameMappings As Integer
         Dim lpszProgressTitle As String
     End Structure
 
     Private Const FO_DELETE As Short = &H3S
     Private Const FOF_ALLOWUNDO As Short = &H40S
     Private Const FOF_NOCONFIRMATION As Short = &H10S
 
     Private Declare Function SHFileOperation Lib "shell32.dll" Alias _
       "SHFileOperationA" (ByRef lpFileOp As SHFILEOPSTRUCT) As Integer
 
 #End Region
 
 #Region "   Constants and Variables "
 
     Private mFileLoaded As Boolean
     Private mSliderMoving As Boolean
     Private mInFile As String
     Private mHandler As AbstractMediaHandler
     Private mFrameAdjPossible As Boolean
     Private mSelStrt, mSelStop As Double
     Private mOneSidedSelection As Boolean
     Private mItems As ListViewItem()                    'Holds items during cut-paste
     Private mTypes As New MediaTypes
     Private mFFwd As Boolean
     Private mFRev As Boolean
     Private mAllowListIndexChange As Boolean = True     'Some event model workaround
     Private mPlaySelected As Boolean = False
     Private mPlaySelIndex As Integer = 0
     Private mPlaySegments As Segment()
     Private mMaskFile As Boolean
     Private mMaskFilename As String
     Private mRepeatPlay As Boolean
     Private mPlayMuted As Boolean
     Private mSuspendPlayerRefresh As Boolean
     Private mStdToolMgr As New StdToolMgr
     Private mnuArr(0) As MenuItem
     Private mSelsDirty As Boolean                       'To track the selection list changes
 
     Private mAudioWF As WaveForm
     Private mIsAudio As Boolean
     Private mDisplayControl As Windows.Forms.Control = mPlayer
 
     Private Const mReactTime As Double = 0.15
 
     Private mOpenFileExtender As New cOpenFileDialogExt
 
 #End Region
 
 #Region "   Load and unload "
 
     Private Sub frmMain_Load(ByVal sender As Object, _
 ByVal e As System.EventArgs) Handles MyBase.Load
 
         DisplayFineControls(False)
         mPlayer.uiMode = "none"
         mPlayer.stretchToFit = True
         MPcontrols.Player = mPlayer
         MPcontrols.Volume = mPlayer.settings.volume
 
         'If CheckUpdate(True, True) Then Me.Close()
 
         LoadSettings()
 
         Dim CmdArgs As String() = Environment.GetCommandLineArgs()
         If CmdArgs.Length > 1 Then
             'Add check later to see that param /play is being passed
             Try
                 If String.Compare(Trim(CmdArgs(1)), "/play", False) = 0 Then
                     LoadMask(CmdArgs(2))
                 ElseIf String.Compare(Trim(CmdArgs(1)), "/edit", False) = 0 Then
                     Dim Filename As String = CmdArgs(2)
                     If isValidExtension(Filename) Then
                         OpenFile(Filename)
                     End If
                 End If
             Catch ex As Exception
                 'do nothing - ignore pranks ;)
             End Try
         End If
 
         mOpenFileExtender.DialogViewType = cOpenFileDialogExt.DialogViewTypes.Thumbnails
 
     End Sub
 
     Private Sub LoadSettings()
 
         Select Case mSettings.GetSetting("View", "SelectedTab")
             Case "tabJoin"
                 mainTabs.SelectedTab = tabJoin
             Case "tabSplit"
                 mainTabs.SelectedTab = tabSplit
             Case Else
                 mainTabs.SelectedTab = tabPlayer
         End Select
 
         If mSettings.GetSetting("Joining", "AutoDetect") = "True" Then
             chkAuto.Checked = True
         End If
 
         If mSettings.GetSetting("Advanced", "KeepHistory") = "True" Then
             chkKeepMRU.Checked = True
         End If
 
         If mSettings.GetSetting("Advanced", "FrameAccurate", "True") = "True" Then
             chkFrameAccurate.Checked = True
         End If
 
         If mSettings.GetSetting("View", "DialogView") = "Default" Then
             chkDialogView.Checked = False
         End If
 
         If mSettings.GetSetting("View", "WindowState") = "Maximized" Then
             Me.WindowState = FormWindowState.Maximized
         End If
 
         MPcontrols.VolBar.Value = CInt(mSettings.GetSetting("Player", "Volume", "50"))
 
         If mSettings.GetSetting("Player", "Mute") = "True" Then
             mPlayMuted = True
             MPcontrols.Mute = True
         End If
 
         If mSettings.GetSetting("Player", "OnTop", "True") = "True" Then
             chkOnTop.Checked = True
         End If
 
         If mSettings.GetSetting("Advanced", "CheckUpdate") = "True" Then
             chkUpdate.Checked = True
         End If
 
         If mSettings.GetSetting("Advanced", "BeepWhenDone") = "True" Then
             chkBeep.Checked = True
         End If
 
         LoadLangList()
 
     End Sub
 
     Private Function DirtyCheck() As Boolean
 
         If mSelsDirty Then
             If mMaskFile Then
                 If MsgBox(Replace(mTranslator.LangText(119), "{1}", mMaskFilename), MsgBoxStyle.YesNo) = MsgBoxResult.Yes Then
                     SaveMask(True)
                 End If
             Else
                 If MsgBox(mTranslator.LangText(127), MsgBoxStyle.YesNo) = MsgBoxResult.No Then
                     Return True
                 End If
             End If
         End If
 
     End Function
 
     Private Sub frmMain_Closing(ByVal sender As Object, _
     ByVal e As System.ComponentModel.CancelEventArgs) Handles MyBase.Closing
 
         If DirtyCheck() Then
             e.Cancel = True
         Else
             mSettings.SaveSetting("Joining", "AutoDetect", chkAuto.Checked.ToString)
             mSettings.SaveSetting("Joining", "AutoDelete", chkDel.Checked.ToString)
             mSettings.SaveSetting("Advanced", "KeepHistory", chkKeepMRU.Checked.ToString)
             mSettings.SaveSetting("Advanced", "CheckUpdate", chkUpdate.Checked.ToString)
             mSettings.SaveSetting("Advanced", "FrameAccurate", chkFrameAccurate.Checked.ToString)
             mSettings.SaveSetting("Advanced", "BeepWhenDone", chkBeep.Checked.ToString)
             mSettings.SaveSetting("Player", "Mute", MPcontrols.cMute.Pushed.ToString)
             mSettings.SaveSetting("Player", "Volume", MPcontrols.VolBar.Value.ToString)
             mSettings.SaveSetting("Player", "OnTop", chkOnTop.Checked.ToString)
             If Not chkDialogView.Checked Then
                 mSettings.SaveSetting("View", "DialogView", "Default")
             End If
             mSettings.SaveSetting("View", "WindowState", Me.WindowState.ToString)
             mSettings.SaveSetting("View", "SelectedTab", mainTabs.SelectedTab.Name)
             SaveToolMgr()
         End If
 
     End Sub
 
     Protected Overrides Sub WndProc(ByRef m As Message)
         MyBase.WndProc(m)
         mOpenFileExtender.WndProc(m)
     End Sub
 
 #End Region
 
 #Region "   Menu items "
 
     Private Sub mnuOpen_Click(ByVal sender As System.Object, _
 ByVal e As System.EventArgs) Handles mnuOpen.Click
 
         If mainTabs.SelectedTab Is tabJoin Then
             OpenFilesForJoining()
         Else
             Dim Filter As String = mStdToolMgr.ValidExtenstions(True)
             Filter = Replace(Filter, ".", "*.")
             Filter = Replace(Filter, "|", ";")
 
             dlgOpenFile.Filter = "Supported Media Files|" & Filter    '*.wmv;*.asf;*.mpg;*.mpeg;*.avi;*.rm";*.flv;*.mp3;*.wma
             dlgOpenFile.Multiselect = False
             If chkDialogView.Checked Then mOpenFileExtender.Enabled = True
 
             If dlgOpenFile.ShowDialog() = Windows.Forms.DialogResult.OK Then
                 Me.Refresh()
                 If Len(dlgOpenFile.FileName) > 0 Then
                     mMaskFile = False
                     OpenFile(dlgOpenFile.FileName)
                 End If
             End If
 
             mOpenFileExtender.Enabled = False
         End If
 
     End Sub
 
     Private Sub OpenFile(ByVal Filename As String, Optional ByVal MaskName As String = "")
 
         Waiting(True)
         Dim fi As New FileInfo(Filename)
         If UCase(fi.Extension) = ".MOVICLIP" Then
             LoadMask(Filename)
             Exit Sub
         End If
 
         mFileLoaded = False
         mInFile = Filename
 
         statMain.Text = mTranslator.LangText(96)
         Try
             If CreateHandler(fi.Extension) Then
                 mPlayer.URL = mInFile
                 mMRU.Add(Filename)
             End If
         Catch ex As Exception
             Debug.WriteLine(mTranslator.LangText(112) & vbCrLf & ex.Message)
             If Len(MaskName) > 0 Then lvPositions.Items.Clear()
             mPlayer.URL = ""
             Waiting(False)
             Exit Sub
         End Try
 
         UpdateTitle(fi.Name, MaskName)
         tFile2Split.Text = Trim(fi.Name)
         mainTabs.SelectedTab = tabPlayer
 
         UpdateEditorOptions(fi.Extension)
 
     End Sub
 
     Private Sub UpdateTitle(ByVal Movie As String, Optional ByVal Mask As String = "")
         Me.Text = "Movica - [" & Movie
         If Len(Mask) > 0 Then Me.Text += " 
         Me.Text += "]"
     End Sub
 
     Private Sub mnuInfo_Click(ByVal sender As System.Object, _
 ByVal e As System.EventArgs) Handles mnuInfo.Click
         If Not mHandler Is Nothing Then
             mHandler.ShowInfo()
             mainTabs.SelectedTab = tabTrace
         End If
     End Sub
 
     Private Sub mnuExit_Click(ByVal sender As System.Object, _
 ByVal e As System.EventArgs) Handles mnuExit.Click
 
         If MsgBox(mTranslator.LangText(118), _
         MsgBoxStyle.YesNo, "Exit ?") = MsgBoxResult.Yes Then
             Me.Close()
         End If
 
     End Sub
 
     Private Sub mnuSave_Click(ByVal sender As System.Object, _
         ByVal e As System.EventArgs) Handles mnuSave.Click
         SaveOutput()
     End Sub
 
     Private Sub mnuSaveX_Click(ByVal sender As System.Object, _
 ByVal e As System.EventArgs) Handles mnuSaveX.Click
         SaveOutput(AbstractMediaHandler.Mode.DeleteSelected)
     End Sub
 
     Private Sub mSaveSepFiles_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles mnuSaveSepFiles.Click
         SaveOutput(AbstractMediaHandler.Mode.SaveSeparate)
     End Sub
 
     Private Sub SaveOutput(Optional ByVal _
         Mode As AbstractMediaHandler.Mode = AbstractMediaHandler.Mode.SaveSelected)
 
         If Not FinishTheList() Then Exit Sub
 
         UpdateHandlerOptions()
 
         dlgSaveFile.InitialDirectory = dlgOpenFile.InitialDirectory
         dlgSaveFile.DefaultExt = mHandler.Extension
         dlgSaveFile.FileName = ""
         dlgSaveFile.Filter = mHandler.Extension(True) + " |*" + mHandler.Extension
 
         If dlgSaveFile.ShowDialog() = Windows.Forms.DialogResult.OK Then
             Me.Refresh()
 
             Dim Filename As String = dlgSaveFile.FileName
             If Filename = mHandler.InputFile Then
                 MsgBox("Output cannot be the same as the input file")
                 Exit Sub
             End If
 
             Dim CutterPath As String
             CutterPath = System.AppDomain.CurrentDomain.BaseDirectory
 
             If Len(Filename) > 0 Then
 
                 mainTabs.SelectedTab = tabTrace
                 statMain.Text = mTranslator.LangText(72)
                 rtfTrace.Clear()
 
                 Try
                     Dim Segments As Segment() = GetSegmentArray(Mode)
 
                     If mHandler.Save(Filename, Segments, Mode) Then
                         UpdateRTF(mTranslator.LangText(87) & vbCrLf & vbCrLf, _
                             modMain.MessageType.Success)
                         ShowProcessStat(modMain.MessageType.Success)
                     Else
                         UpdateRTF(vbCrLf & "Conversion Failed !!" & vbCrLf & vbCrLf, _
                             modMain.MessageType.Failure)
                         ShowProcessStat(modMain.MessageType.Failure)
                     End If
                 Catch ex As Exception
                     MsgBox(ex.Message)
                 End Try
 
                 mSelsDirty = False
                 statMain.Text = mTranslator.LangText(23)
                 If chkBeep.Checked Then Beep()
 
             End If
         End If
 
     End Sub
 
     Private Function GetSegmentArray(ByVal Mode As AbstractMediaHandler.Mode) _
         As Segment()
 
         If lvPositions.Items.Count = 0 Then Return Nothing
 
         Dim Segments(lvPositions.Items.Count - 1) As Segment
 
         Select Case Mode
             Case AbstractMediaHandler.Mode.DeleteSelected
                 'Start from zero if the entry does not start from zero
                 Dim Offset As Integer = 1
                 If MinToSec(lvPositions.Items(0).Text) > 0 Then
                     ReDim Segments(lvPositions.Items.Count)
                     Segments(0) = New Segment
                     Segments(0).Start = 0
                     Segments(0).Finish = MinToSec(lvPositions.Items(0).Text)
                     Offset = 0
                 End If
                 Dim i As Integer
                 For i = 1 To lvPositions.Items.Count - 1
                     Segments(i - Offset) = New Segment
                     Segments(i - Offset).Start = MinToSec(lvPositions.Items(i - 1).SubItems(1).Text)
                     Segments(i - Offset).Finish = MinToSec(lvPositions.Items(i).Text)
                 Next
                 If lvPositions.Items(i - 1).SubItems(1).Text = SecToMin(Math.Round(mPlayer.currentMedia.duration, 3)) Then
                     'The tail piece is not needed
                     ReDim Preserve Segments(lvPositions.Items.Count - 1)
                 Else
                     Segments(i - Offset) = New Segment
                     Segments(i - Offset).Start = MinToSec(lvPositions.Items(i - 1).SubItems(1).Text)
                     Segments(i - Offset).Finish = Math.Round(mPlayer.currentMedia.duration, 3)
                 End If
             Case Else
                 For i As Integer = 0 To lvPositions.Items.Count - 1
                     Segments(i) = New Segment
                     Segments(i).Start = MinToSec(lvPositions.Items(i).Text)
                     Segments(i).Finish = MinToSec(lvPositions.Items(i).SubItems(1).Text)
                 Next
         End Select
 
         Return Segments
 
     End Function
 
     Private Function FinishTheList() As Boolean
 
         Dim Last As Integer = lvPositions.Items.Count - 1
         If Last < 0 Then Exit Function
 
         If lvPositions.Items(Last).SubItems.Count = 1 Then
             Dim EndPos As String
             EndPos = SecToMin(Math.Round(mPlayer.currentMedia.duration, 3))
             lvPositions.Items(Last).SubItems.Add(EndPos)
         End If
         mPlayer.Ctlcontrols.pause()
 
         UpdateSelDur()
         Return True
 
     End Function
 
     Private Sub mnuHelp_Click(ByVal sender As System.Object, _
     ByVal e As System.EventArgs) Handles mnuHelp.Click
         ShowHelp()
     End Sub
 
     Public Sub ShowHelp()
         Help.ShowHelp(Me, "Movica.chm")
     End Sub
 
     Private Sub MenuItem6_Click(ByVal sender As System.Object, _
 ByVal e As System.EventArgs) Handles MenuItem6.Click
         Dim frm As New frmAbout
         If Me.TopMost Then frm.TopMost = True
         frm.ShowNormal()
         frm = Nothing
     End Sub
 
     Private Sub mnuCheckUpdate_Click(ByVal sender As System.Object, _
     ByVal e As System.EventArgs) Handles mnuCheckUpdate.Click
         CheckUpdate()
     End Sub
 
     Private Sub mnuImpSkip_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles mnuImpSkip.Click
 
         Dim lvItem As ListViewItem
         Dim SkipXml As New XmlDocument
         Dim TimeStr, TimeEnd As Double
         Dim MaxVal As Double = mPlayer.currentMedia.duration
         SkipXml.Load(mInFile & ".chapters.xml")
         If Not SkipXml Is Nothing Then
             lvPositions.Items.Clear()
             Try
                 lvItem = lvPositions.Items.Add(SecToMin(0))
                 For Each Seg As XmlNode In SkipXml.SelectNodes("cutlist/Region")
                     TimeStr = MinToSec(Seg.SelectSingleNode("start").Attributes.GetNamedItem("comment").InnerText)
                     TimeEnd = MinToSec(Seg.SelectSingleNode("end").Attributes.GetNamedItem("comment").InnerText)
 
                     'Validate
                     If (TimeStr > MaxVal) Or (TimeEnd > MaxVal) Then
                         MsgBox("This file has positions outside the extent of the movie." & vbCrLf & "Please check if you have the correct file", _
                         MsgBoxStyle.Exclamation, "Error in reading skip file")
                         Exit Try
                     End If
 
                     'Add item
                     If TimeStr > 0 Then
                         lvItem.SubItems.Add(SecToMin(TimeStr))
                         lvItem = lvPositions.Items.Add(SecToMin(TimeEnd))
                     Else
                         lvItem.Text = SecToMin(TimeEnd)
                     End If
                 Next
             Catch ex As Exception
                 Debug.WriteLine(ex.Message)
             End Try
 
             lvItem.SubItems.Add(SecToMin(MaxVal))
         End If
 
     End Sub
 
     Private Sub mnuImpComskip_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles mnuImpComskip.Click
 
         Dim sr As System.IO.StreamReader
         Dim Line As String, lvItem As ListViewItem
         Dim TimeStr, TimeEnd, FrameRate As Double
         Dim Temp As String()
         Dim MaxVal As Double = mPlayer.currentMedia.duration
 
         lvPositions.Items.Clear()
         Try
             sr = File.OpenText(StripExtention(mInFile) & ".txt")
             Line = Trim(sr.ReadLine)
             Temp = Split(Line, " ")
             FrameRate = Val(Temp(UBound(Temp))) / 100
             Line = sr.ReadLine
 
             lvItem = lvPositions.Items.Add(SecToMin(0))
             While sr.Peek <> -1
                 Line = sr.ReadLine()
                 Temp = Split(Line, Chr(9))
                 TimeStr = (Val(Temp(0)) - 1) / FrameRate
                 TimeEnd = (Val(Temp(1)) - 1) / FrameRate
 
                 'Validate
                 If (TimeStr > MaxVal) Or (TimeEnd > MaxVal) Then
                     MsgBox("This file has positions outside the extent of the movie." & vbCrLf & "Please check if you have the correct file", _
                     MsgBoxStyle.Exclamation, "Error in reading skip file")
                     Exit Try
                 End If
 
                 'Add item
                 If TimeStr > 0 Then
                     lvItem.SubItems.Add(SecToMin(TimeStr))
                     lvItem = lvPositions.Items.Add(SecToMin(TimeEnd))
                 Else
                     lvItem.Text = SecToMin(TimeEnd)
                 End If
             End While
         Catch ex As Exception
             MsgBox("Error reading the Comskip file", MsgBoxStyle.Exclamation, "Error reading the file")
         Finally
             sr.Close()
         End Try
         lvItem.SubItems.Add(SecToMin(MaxVal))
 
     End Sub
 
     Private Sub mnuDonate_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles mnuDonate.Click
         Process.Start("http
     End Sub
 
     Private Sub mnuUnload_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles mnuUnload.Click
         mPlayer.URL = ""
         SwitchVisual(True)
     End Sub
 
 #End Region
 
 #Region "   Playback "
 
     Private Sub mnuPlaySel_Click(ByVal sender As System.Object, _
     ByVal e As System.EventArgs) Handles mnuPlaySel.Click, mnuPlayUns.Click
 
         If lvPositions.Items.Count = 0 Then Exit Sub
         Dim MnuItem As MenuItem = DirectCast(sender, MenuItem)
 
         If MnuItem Is mnuPlaySel Then
             PlayAllSelected()
         Else
             PlayAllNotSelected()
         End If
 
     End Sub
 
     Private Sub PlayAllSelected()
         If lvPositions.Items.Count = 0 Then Exit Sub
         ReDim mPlaySegments(0)
         mPlaySegments = GetSegmentArray(AbstractMediaHandler.Mode.SaveSelected)
         PlaySelectedSegments()
     End Sub
 
     Private Sub PlayAllNotSelected()
         If lvPositions.Items.Count = 0 Then Exit Sub
         ReDim mPlaySegments(0)
         mPlaySegments = GetSegmentArray(AbstractMediaHandler.Mode.DeleteSelected)
         PlaySelectedSegments()
     End Sub
 
     Private Sub PlaySelectedSegments()
         mPlaySelected = True
         mPlaySelIndex = 0
         Timer.Enabled = True
 
         mPlayer.Ctlcontrols.currentPosition = mPlaySegments(0).Start
         mPlayer.Ctlcontrols.play()
     End Sub
 
     Private Sub mnuTestSeg_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles mnuTestSeg.Click
         TestSegment()
     End Sub
 
     Private Sub TestSegment()
         If lvPositions.Items.Count = 0 Then Exit Sub
         With lvPositions.SelectedItems
             If .Count = 0 Then Exit Sub
             ReDim mPlaySegments(.Count - 1)
             For i As Integer = 0 To .Count - 1
                 mPlaySegments(i) = New Segment
                 mPlaySegments(i).Start = MinToSec(.Item(i).Text)
                 mPlaySegments(i).Finish = MinToSec(.Item(i).SubItems(1).Text)
             Next
         End With
         PlaySelectedSegments()
     End Sub
 
     Private Sub Timer_Tick(ByVal sender As Object, _
 ByVal e As System.EventArgs) Handles Timer.Tick
 
         If mIsAudio Then DrawWavePosition()
         If mPlaySelected Then
             If mPlayer.Ctlcontrols.currentPosition >= mPlaySegments(mPlaySelIndex).Finish Then
                 If UBound(mPlaySegments) > mPlaySelIndex Then
                     mPlaySelIndex += 1
                     mPlayer.Ctlcontrols.currentPosition = mPlaySegments(mPlaySelIndex).Start
                 Else
                     If mRepeatPlay Then
                         mPlaySelIndex = 0
                         mPlayer.Ctlcontrols.currentPosition = _
                             mPlaySegments(mPlaySelIndex).Start
                     Else
                         mPlayer.Ctlcontrols.stop()
                         mPlaySelected = False
                         Timer.Enabled = False
                     End If
                 End If
             End If
         End If
 
     End Sub
 
     Private Sub mnuLoop_Click(ByVal sender As System.Object, _
     ByVal e As System.EventArgs) Handles mnuLoop.Click
         ToggleRepeatPlay()
     End Sub
 
     Private Sub ToggleRepeatPlay()
         If mnuLoop.Checked Then
             mRepeatPlay = False
             mnuLoop.Checked = False
             cLoop.Pushed = False
         Else
             mRepeatPlay = True
             mnuLoop.Checked = True
             cLoop.Pushed = True
         End If
     End Sub
 
     Private Sub mnuFullscreen_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles mnuFullscreen.Click
         If mPlayer.openState = WMPLib.WMPOpenState.wmposMediaOpen Then mPlayer.fullScreen = True
     End Sub
 
 #End Region
 
 #Region "   Player Controls "
 
     Private Sub Mpcontrols_ButtonPress(ByVal Name As String) _
     Handles MPcontrols.ButtonPress
 
         Select Case Name
             Case "cStop"
                 mPlayer.Ctlcontrols.stop()
                 Timer.Enabled = False
             Case "cPlay"
                 If mPlayer.playState = WMPLib.WMPPlayState.wmppsPlaying Then
                     mPlayer.Ctlcontrols.pause()
                 Else
                     mPlayer.Ctlcontrols.play()
                 End If
                 mDisplayControl.Focus()
             Case "cBegin"
                 mPlayer.Ctlcontrols.currentPosition = 0
             Case "cFRev"
                 ToggleFastReverse()
             Case "cFFwd"
                 ToggleFastForward()
             Case "cEnd"
                 mPlayer.Ctlcontrols.pause()
                 mPlayer.Ctlcontrols.currentPosition = mPlayer.currentMedia.duration
             Case "cSelStrt"
                 StartSelection()
             Case "cSelEnd"
                 EndSelection()
             Case "cMute"
                 mPlayMuted = MPcontrols.Mute
         End Select
 
     End Sub
 
     Private Sub Mpcontrols_VolumeChanged(ByVal Value As Integer) _
 Handles MPcontrols.VolumeChanged
         mPlayer.settings.volume = Value
         mPlayer.settings.mute = mPlayMuted
     End Sub
 
     Private Sub Mpcontrols_SliderMoved(ByVal Start As Double) _
     Handles MPcontrols.SliderMoved
         mPlayer.Ctlcontrols.currentPosition = Start
         If mPlayer.playState = WMPLib.WMPPlayState.wmppsPaused Then
             mPlayer.Ctlcontrols.play()
             mPlayer.Ctlcontrols.pause()
         End If
     End Sub
 
 #End Region
 
 #Region "   Drag and Drop "
 
     Private Sub frmMain_DragEnter(ByVal sender As Object, _
     ByVal e As System.Windows.Forms.DragEventArgs) _
     Handles MyBase.DragEnter
 
         If (e.Data.GetDataPresent(DataFormats.FileDrop)) Then
             e.Effect = DragDropEffects.Copy
         Else
             e.Effect = DragDropEffects.None
         End If
 
     End Sub
 
     Private Sub frmMain_DragDrop(ByVal sender As Object, _
     ByVal e As System.Windows.Forms.DragEventArgs) _
     Handles MyBase.DragDrop
 
         Dim arr As Array = DirectCast(e.Data.GetData(DataFormats.FileDrop), Array)
         Dim Filename As String
 
         If arr.GetLength(0) = 1 Then
             Filename = Convert.ToString(arr.GetValue(0))
             Try
                 If isValidExtension(Filename) Then
                     OpenFile(Filename)
                 End If
             Catch ex As Exception
                 MsgBox(ex.Message, MsgBoxStyle.Exclamation, "Invalid file format")
             End Try
         Else
             'TODO 
 
             'Clear join list
             lvFiles.Items.Clear()
             Dim j As Integer, ValidFile As String
             For i As Integer = 0 To UBound(arr)
                 Filename = Convert.ToString(arr.GetValue(i))
                 Try
                     If isValidExtension(Filename) Then
                         lvFiles.Items.Add(Filename)
                         j += 1
                         ValidFile = Filename
                     End If
                 Catch ex As Exception
                     MsgBox(ex.Message, MsgBoxStyle.Exclamation, "Invalid file format")
                 End Try
             Next
             If j > 1 Then
                 mainTabs.SelectedTab = tabJoin
             ElseIf j = 1 Then
                 mMaskFile = False
                 OpenFile(ValidFile)
             Else
                 lvFiles.Items.Clear()
                 statMain.Text = mTranslator.LangText(49)
             End If
         End If
 
     End Sub
 
     Private Function isValidExtension(ByVal Filename As String, _
     Optional ByVal TestExt As String = ".mpg") As Boolean
 
         Dim fi As New FileInfo(Filename)
         Dim Ext As String = LCase(fi.Extension)
 
         If isValidExtenstionSlave(mStdToolMgr.ValidExtenstions(True), Ext) Then
             mMaskFile = (Ext = ".moviclip")
             Return True
         ElseIf isValidExtenstionSlave(".rm|.flv", Ext) Then
             Throw New ArgumentException("Configuration required for " + Filename + vbCrLf + _
             vbCrLf + "Files with extension '" + Ext + "' are supported but require external tools" + _
             vbCrLf + "See the Tools tab to learn more")
         Else
             Throw New ArgumentException("Error in reading file " + Filename + vbCrLf + _
             vbCrLf + "Files with extension '" + Ext + "' are not supported" + _
             vbCrLf + "Only .avi, .wmv, .asf, .mpg, .mpeg, .rm, .flv, .wma, .mp3 and .moviclip files are supported")
         End If
 
     End Function
 
     Private Function isValidExtenstionSlave(ByVal ExtStr As String, ByVal Ext As String) As Boolean
         Dim extArr As String() = Split(ExtStr, "|")
         For i As Integer = 0 To UBound(extArr)
             If Ext = extArr(i) Then Return True
         Next
     End Function
 
 #End Region
 
 #Region "   Keyboard shortcuts "
 
     Private Sub frmMain_KeyUp(ByVal sender As Object, _
     ByVal e As System.Windows.Forms.KeyEventArgs) Handles MyBase.KeyUp
 
         If Not mFileLoaded Then Exit Sub
 
         Select Case e.KeyCode
 
             Case Keys.Home     'Keys.Home
                 'Start selection
                 StartSelection()
 
             Case Keys.End     'Keys.End - end Selection
                 'End Selection
                 EndSelection()
 
             Case Keys.Delete    'Keys.Delete
                 If e.Control Then           'Control Delete
                     If lvPositions.Items.Count = 0 Then Exit Sub
                     lvPositions.Items.RemoveAt(lvPositions.Items.Count - 1)
                 End If
 
             Case Keys.Space     'Keys.Space
                 If mPlayer.playState <> 2 Then
                     mPlayer.Ctlcontrols.pause()
                 Else
                     mPlayer.Ctlcontrols.play()
                 End If
                 mDisplayControl.Focus()
 
             Case Keys.Left        'Left Arrow
                 If e.Control Then           'Control Left Arrow
                     mPlayer.Ctlcontrols.currentPosition -= 2
                 End If
 
             Case Keys.Right        'Right Arrow
                 If e.Control Then           'Control Right Arrow
                     mPlayer.Ctlcontrols.currentPosition += 2
                 End If
 
             Case Keys.Up        'Up Arrow
                 If e.Control Then
                     'Control+Up = Increase speed
                     ToggleFastForward()
                 ElseIf e.Alt Then
                     'change tuner resolution - coarser
                     If lvPositions.SelectedItems.Count = 1 Then
                         With FineResolution
                             Dim NewRes As Single = .Value
                             NewRes += CSng(0.01)
                             If NewRes <= .Maximum Then .Value = NewRes
                         End With
                     End If
                 Else
                     'Change volume
                     If mPlayer.playState = WMPLib.WMPPlayState.wmppsPlaying Then MPcontrols.IncreaseVolume()
                 End If
 
             Case Keys.Down       'Down Arrow
                 If e.Control Then
                     'Control+Down = Decrease speed
                     ToggleFastReverse()
                 ElseIf e.Alt Then
                     'change tuner resolution - finer
                     If lvPositions.SelectedItems.Count = 1 Then
                         With FineResolution
                             Dim NewRes As Single = .Value
                             NewRes -= CSng(0.01)
                             If NewRes >= .Minimum Then .Value = NewRes
                         End With
                     End If
                 Else
                     'Change volume
                     If mPlayer.playState = WMPLib.WMPPlayState.wmppsPlaying Then MPcontrols.DecreaseVolume()
                 End If
 
             Case Keys.Enter
                 If e.Alt Then
                     mPlayer.fullScreen = True
                 End If
 
         End Select
 
     End Sub
 
     Private Sub frmMain_KeyDown(ByVal sender As Object, ByVal e As System.Windows.Forms.KeyEventArgs) Handles MyBase.KeyDown
 
         If Not mFileLoaded Then Exit Sub
 
         Select Case e.KeyCode
             Case Keys.Left, Keys.Right
                 mSuspendPlayerRefresh = True
             Case Else
                 mSuspendPlayerRefresh = False
         End Select
 
     End Sub
 
 #End Region
 
 #Region "   Media Player events "
 
     'Private Sub mPlayer_MouseMoveEvent(ByVal sender As Object, ByVal e As AxWMPLib._WMPOCXEvents_MouseMoveEvent) Handles mPlayer.MouseMoveEvent
     '    If mPlayer.fullScreen Then
     '        'If e.fY > 0.8 * Me.Height Then mPlayer.fullScreen = False
     '    End If
     'End Sub
 
     Private Sub mPlayer_OpenStateChange(ByVal sender As Object, _
     ByVal e As AxWMPLib._WMPOCXEvents_OpenStateChangeEvent) _
     Handles mPlayer.OpenStateChange
 
         Select Case mPlayer.openState
             Case WMPLib.WMPOpenState.wmposMediaOpen
                 ResetFastButtons()
                 statMain.Text = mTranslator.LangText(44)
                 statDur.Text = mTranslator.LangText(121) & "
                 mDisplayControl.Focus()
                 mFileLoaded = True
                 mPlayer.settings.mute = mPlayMuted
                 Waiting(False)
 
                 ReDim mItems(0)
                 MPcontrols.SetToolbarMode(True)
                 If Not mMaskFile Then
                     lvPositions.Items.Clear()
 
                     'Simulate the pressing of the home key to create first entry
                     Dim evnt As New AxWMPLib._WMPOCXEvents_KeyUpEvent(36, 0)
                     mPlayer_KeyUpEvent(mPlayer, evnt)
                 Else
                     PlayAllSelected()
                 End If
 
                 UpdateSelDur()
 
                 If Not mainTabs.SelectedTab Is tabPlayer Then
                     mPlayer.Ctlcontrols.stop()
                 Else
                     Timer.Enabled = mIsAudio        'For the time being starting the timer only for waveform display
                 End If
 
             Case WMPLib.WMPOpenState.wmposMediaChanging
                 statMain.Text = mTranslator.LangText(18)
                 If mPlayer.URL = "" Then
                     lvPositions.Items.Clear()
                 End If
                 MPcontrols.SetToolbarMode(False)
 
             Case Else
                 MPcontrols.SetToolbarMode(False)
 
         End Select
 
     End Sub
 
     Private Sub mPlayer_KeyUpEvent(ByVal sender As System.Object, _
     ByVal e As AxWMPLib._WMPOCXEvents_KeyUpEvent) Handles mPlayer.KeyUpEvent
 
         If Not mFileLoaded Then Exit Sub
 
         Select Case e.nKeyCode
 
             Case 36     'Keys.Home
                 'Start selection
                 StartSelection()
 
             Case 35     'Keys.End - end Selection
                 'End Selection
                 EndSelection()
 
             Case 46     'Keys.Delete
                 If e.nShiftState = 2 Then           'Control Delete
                     If lvPositions.Items.Count = 0 Then Exit Sub
                     lvPositions.Items.RemoveAt(lvPositions.Items.Count - 1)
                 End If
 
             Case 32     'Keys.Space
                 If mPlayer.playState <> 2 Then
                     mPlayer.Ctlcontrols.pause()
                 Else
                     mPlayer.Ctlcontrols.play()
                 End If
 
             Case 37         'Left Arrow
                 If e.nShiftState = 2 Then           'Control Left Arrow
                     mPlayer.Ctlcontrols.currentPosition -= 2
                 End If
 
             Case 39         'Right Arrow
                 If e.nShiftState = 2 Then           'Control Right Arrow
                     mPlayer.Ctlcontrols.currentPosition += 2
                 End If
 
             Case 38         'Up Arrow
                 If e.nShiftState = 2 Then
                     'Control+Up = Increase speed
                     ToggleFastForward()
                 Else
                     'Change volume
                     If mPlayer.playState = WMPLib.WMPPlayState.wmppsPlaying Then MPcontrols.IncreaseVolume()
                 End If
 
             Case 40         'Down Arrow
                 If e.nShiftState = 2 Then
                     'Control+Down = Decrease speed
                     ToggleFastReverse()
                 Else
                     'Change volume
                     If mPlayer.playState = WMPLib.WMPPlayState.wmppsPlaying Then MPcontrols.DecreaseVolume()
                 End If
 
         End Select
     End Sub
 
     Private Sub mPlayer_PlayStateChange(ByVal sender As Object, _
     ByVal e As AxWMPLib._WMPOCXEvents_PlayStateChangeEvent) _
     Handles mPlayer.PlayStateChange
 
         With mPlayer
             Select Case .playState
                 Case WMPLib.WMPPlayState.wmppsStopped
                     'Stop fast play when stopped
                     ' Don't bother when player is paused
                     mFFwd = False
                     mFRev = False
                     .settings.rate = 1
                     FinishTheList()
                     lvPositions.Select()
 
                     mPlaySelected = False       'Restore player to ordinary control
                     Timer.Enabled = False       'Disable timer
                     Me.TopMost = False          'Form is not top most
                 Case WMPLib.WMPPlayState.wmppsPlaying
                     If chkOnTop.Checked Then
                         Me.TopMost = True
                     Else
                         Me.TopMost = False
                     End If
                 Case Else
                     Me.TopMost = False
             End Select
         End With
 
     End Sub
 
     Private Sub Player_MediaError(ByVal sender As System.Object, _
     ByVal e As AxWMPLib._WMPOCXEvents_MediaErrorEvent) Handles mPlayer.MediaError
         Dim errSource As WMPLib.IWMPMedia2 = DirectCast(e.pMediaObject, WMPLib.IWMPMedia2)
         Dim errorItem As WMPLib.IWMPErrorItem = errSource.Error
         Dim errorDesc As String = errorItem.errorDescription
         Dim errorStr As String = "Error " + errorItem.errorCode.ToString("X") + _
             " in " + errSource.sourceURL + vbCrLf + errorDesc
         MessageBox.Show(errorStr, "Player Error")
         lvPositions.Items.Clear()
         statSel.Text = ""
         statDur.Text = ""
         Waiting(False)
     End Sub
 
     Private Sub mPlayer_PositionChange(ByVal sender As Object, ByVal e As AxWMPLib._WMPOCXEvents_PositionChangeEvent) _
     Handles mPlayer.PositionChange
         DrawWavePosition()
     End Sub
 
 #End Region
 
 #Region "   Tabs - General "
 
     Private Sub mainTabs_SelectedIndexChanged(ByVal sender As Object, _
     ByVal e As System.EventArgs) Handles mainTabs.SelectedIndexChanged
 
         Select Case mainTabs.SelectedIndex
             Case 0
                 panSegments.Width = 140
                 If Safe2ShowTuner() Then DisplayFineControls(True)
             Case 1
                 panSegments.Width = 0
                 DisplayFineControls(False)
             Case 2
                 mPlayer.Ctlcontrols.pause()
                 panSegments.Width = 0
                 DisplayFineControls(False)
             Case 3
                 panSegments.Width = 0
                 lvFiles.Columns(0).Width = lvFiles.Width
                 DisplayFineControls(False)
             Case 4
                 panSegments.Width = 0
                 DisplayFineControls(False)
             Case 5
                 panSegments.Width = 0
                 DisplayFineControls(False)
                 RenderStdToolList()
         End Select
     End Sub
 
 #End Region
 
 #Region "   Tabs - Joining "
 
     Private Sub ToolBar1_ButtonClick(ByVal sender As System.Object, ByVal e As System.Windows.Forms.ToolBarButtonClickEventArgs) Handles tbJoin.ButtonClick
 
         Select Case DirectCast(e.Button.Tag, String)
             Case "Open"
                 OpenFilesForJoining()
 
             Case "Join"
                 If lvFiles.Items.Count = 0 Then Exit Sub
 
                 Dim fi As New FileInfo(lvFiles.Items(0).Text)
                 mInFile = fi.FullName
                 If Not CreateHandler(fi.Extension) Then Exit Sub
                 mPlayer.URL = ""
 
                 UpdateHandlerOptions()
 
                 dlgSaveFile.InitialDirectory = dlgOpenFile.InitialDirectory
                 dlgSaveFile.DefaultExt = mHandler.Extension
                 dlgSaveFile.FileName = ""
                 dlgSaveFile.Filter = mHandler.Extension(True) + " |*" + mHandler.Extension
 
                 If dlgSaveFile.ShowDialog() = Windows.Forms.DialogResult.OK Then
                     Me.Refresh()
                     Dim Filename As String = dlgSaveFile.FileName
 
                     Dim Temp As String()
                     With lvFiles
                         ReDim Temp(.Items.Count - 1)
                         For i As Integer = 0 To .Items.Count - 1
                             Temp(i) = .Items(i).Text
                         Next
 
                         statMain.Text = Replace(mTranslator.LangText(38), "{%1}", CStr(.Items.Count))
                         'statMain.Text = "Joining " + CStr(.Items.Count) + " files. Please wait..."
 
                         mainTabs.SelectedTab = tabTrace
                         rtfTrace.SelectedText = vbCrLf
 
                         If chkKeepMRU.Checked Then rtfTrace.Clear()
 
                         If mHandler.Join(Temp, Filename) Then
                             UpdateRTF(vbCrLf & "Success!!" & vbCrLf, _
                                 modMain.MessageType.Success)
                             ShowProcessStat(modMain.MessageType.Success)
                             If chkDel.Checked Then
                                 'Send all the files to the recycle bin
                                 For i As Integer = 0 To lvFiles.Items.Count - 1
                                     TrashFile(Temp(i))
                                 Next
                             End If
                         Else
                             UpdateRTF(vbCrLf + "Joining Failed !!" & vbCrLf, _
                                 modMain.MessageType.Failure)
                             ShowProcessStat(modMain.MessageType.Failure)
                         End If
                     End With
                     statMain.Text = mTranslator.LangText(23)
                     If chkBeep.Checked Then Beep()
                 End If
 
             Case "Remove"
                 If lvFiles.Items.Count = 0 Then Exit Sub
                 'Dim DoomedItems As ListView.SelectedListViewItemCollection
                 'DoomedItems = lvFiles.SelectedItems
                 For Each Item As ListViewItem In lvFiles.SelectedItems
                     lvFiles.Items.Remove(Item)
                 Next
 
             Case "Sort"
                 Dim TempIn As String()
                 With lvFiles
                     ReDim TempIn(.Items.Count - 1)
                     For i As Integer = 0 To .Items.Count - 1
                         TempIn(i) = .Items(i).Text
                     Next
                     Array.Sort(TempIn)
                     .Items.Clear()
                     For i As Integer = 0 To UBound(TempIn)
                         .Items.Add(TempIn(i))
                     Next
                 End With
 
             Case "Clear"
                 lvFiles.Items.Clear()
 
             Case "Up"
                 'Move files up
                 If lvFiles.Items.Count = 0 Then Exit Sub
                 If lvFiles.SelectedItems.Count = 0 Then Exit Sub
                 MoveItemsUp(lvFiles)
 
             Case "Dn"
                 'Move files down
                 If lvFiles.Items.Count = 0 Then Exit Sub
                 If lvFiles.SelectedItems.Count = 0 Then Exit Sub
                 MoveItemsDn(lvFiles)
 
             Case "Info"
                 With lvFiles
                     If .Items.Count = 0 Then Exit Sub
                     Dim fi As New FileInfo(lvFiles.Items(0).Text)
                     If Not CreateHandler(fi.Extension) Then Exit Sub
                     mainTabs.SelectedTab = tabTrace
                     mHandler.ShowInfo(GetSelectedFilenames)
                 End With
         End Select
 
     End Sub
 
     Private Sub UpdateToolbar(ByVal Enable As Boolean)
         If Enable Then
             cSort.Enabled = True
             cRemove.Enabled = True
             cClear.Enabled = True
             cJoin.Enabled = True
             cUp.Enabled = True
             cDn.Enabled = True
             cInfo.Enabled = True
         Else
             cSort.Enabled = False
             cRemove.Enabled = False
             cClear.Enabled = False
             cJoin.Enabled = False
             cUp.Enabled = False
             cDn.Enabled = False
             cInfo.Enabled = False
         End If
     End Sub
 
     Private Sub OpenFilesForJoining()
 
         With dlgOpenFile
             Dim Filter As String = mStdToolMgr.ValidExtenstions(True)
             Filter = Replace(Filter, ".", "*.")
             Filter = Replace(Filter, "|", ";")
 
             .Filter = "Supported Media Files|" & Filter
             .Multiselect = True
             If chkDialogView.Checked Then mOpenFileExtender.Enabled = True
 
             If .ShowDialog() = Windows.Forms.DialogResult.OK Then
                 If Len(.FileName) > 0 Then
                     'Rajat check for compatible extensions and file exists
                     If .FileNames.Length > 1 Then
                         For i As Integer = 0 To .FileNames.GetUpperBound(0)
                             If File.Exists(.FileNames(i)) Then
                                 lvFiles.Items.Add(.FileNames(i))
                             End If
                         Next
                     Else
                         If File.Exists(.FileName) Then
                             lvFiles.Items.Add(.FileName)
                             If chkAuto.Checked Then
                                 Dim Matches As String() = FindLikeFiles(.FileName)
                                 If Not Matches Is Nothing Then
                                     For i As Integer = 0 To UBound(Matches)
                                         lvFiles.Items.Add(Matches(i))
                                     Next
                                 End If
                             End If
                         End If
                     End If
                 End If
             End If
             mOpenFileExtender.Enabled = False
         End With
 
     End Sub
 
     Private Function GetSelectedFilenames() As String()
         Dim Temp As String()
         With lvFiles
             If .SelectedItems.Count = 0 Then
                 ReDim Temp(.Items.Count - 1)
                 For i As Integer = 0 To UBound(Temp)
                     Temp(i) = .Items(i).Text
                 Next
             Else
                 ReDim Temp(.SelectedItems.Count - 1)
                 For i As Integer = 0 To UBound(Temp)
                     Temp(i) = .SelectedItems(i).Text
                 Next
             End If
         End With
         Return Temp
     End Function
 
     Private Function FindLikeFiles(ByVal Filename As String) As String()
 
         Dim Temp As String()
         Dim fi As New FileInfo(Filename)
         Dim di As DirectoryInfo = fi.Directory
 
         Dim Template As String = fi.Name
         Template = Template.Remove(Template.Length - fi.Extension.Length, _
             fi.Extension.Length)
 
         Dim Started As Boolean, CharVal As Integer
         For i As Integer = Template.Length - 1 To 0 Step -1
             CharVal = Asc(Template.Chars(i))
             If (CharVal < 58) AndAlso (CharVal > 47) Then
                 Started = True
             End If
             If Started Then
                 If (CharVal > 57) Or (CharVal < 48) Then
                     Template = Template.Remove(i, Template.Length - i)
                     Exit For
                 End If
             End If
         Next
 
         Dim mfi As FileInfo, mfis As FileInfo()
         mfis = di.GetFiles(Template + "*")
         Dim MediaGrp As MediaTypes.Format = mTypes.FindFormat(fi.Extension)
 
         Dim j As Integer
         If mfis.Length > 1 Then
             ReDim Temp(mfis.Length - 2)
             For Each mfi In mfis
                 If mfi.FullName <> Filename Then
                     If mTypes.ExtSupported(MediaGrp, mfi.Extension) Then
                         Temp(j) = mfi.FullName
                         j += 1
                     End If
                 End If
             Next
         End If
 
         If j > 0 Then ReDim Preserve Temp(j - 1)
 
         Return Temp
 
     End Function
 
 #End Region
 
 #Region "   Positions List "
 
     Private Sub lvPositions_KeyDown(ByVal sender As System.Object, _
     ByVal e As System.Windows.Forms.KeyEventArgs) _
     Handles lvPositions.KeyDown, lvFiles.KeyUp
 
         Dim lvControl As ListView
         lvControl = DirectCast(sender, ListView)
 
         With lvControl
             If .Items.Count = 0 Then Exit Sub
             If .SelectedItems.Count = 0 Then Exit Sub
 
             mAllowListIndexChange = True
 
             Select Case e.KeyCode
                 Case Keys.Delete
                     DeleteSelected()
 
                 Case Keys.F11
                     'move up
                     MoveItemsUp(lvControl)
 
                 Case Keys.F12
                     'move down
                     MoveItemsDn(lvControl)
 
                 Case Keys.C
                     'Copy
                     If e.Control Then
                         CopySelected()
                     End If
 
                 Case Keys.V
                     'Paste
                     If e.Control Then
                         PasteSelected()
                     End If
 
                 Case Keys.Left
                     'Need to jump around the bug with index change
                     'Doing this instead of keeping last index to avoid problems with delete
                     If e.Control Then Exit Sub
                     mAllowListIndexChange = False
 
                     If e.Shift Then         'Shift means right slider
                         DoFrameAdjustment(False, False)
                     Else
                         DoFrameAdjustment(True, False)
                     End If
 
                 Case Keys.Right
                     'Need to jump around the bug with index change
                     'Doing this instead of keeping last index to avoid problems with delete
                     If e.Control Then Exit Sub
                     mAllowListIndexChange = False
 
                     If e.Shift Then         'Shift means right slider
                         DoFrameAdjustment(False, True)
                     Else
                         DoFrameAdjustment(True, True)
                         'Debug.WriteLine(GetAsyncKeyState(39))
                     End If
 
             End Select
         End With
 
     End Sub
 
     Private Sub DoFrameAdjustment(ByVal ChangeStart As Boolean, _
 ByVal Forward As Boolean)
 
         If lvPositions.SelectedItems.Count <> 1 Then Exit Sub
 
         Dim StepValue As Integer, Position, NewPosition As Double
 
         If Forward Then
             StepValue = 1
         Else
             StepValue = -1
         End If
 
         lvSelectionInit()
 
         If ChangeStart Then
             Position = mSelStrt
         Else
             If mOneSidedSelection Then Exit Sub
             Position = mSelStop
         End If
 
         mPlayer.Ctlcontrols.currentPosition = Position
         NewPosition = Position + StepValue * FineResolution.Value
 
         With lvPositions.SelectedItems(0)
             If ChangeStart Then
                 If NewPosition >= mSelStop Then Exit Sub
                 .SubItems(0).Text = SecToMin(Math.Round(NewPosition, 3))
             Else
                 If NewPosition <= MinToSec(.SubItems(0).Text) Then Exit Sub
                 If NewPosition >= mPlayer.currentMedia.duration Then Exit Sub
                 .SubItems(1).Text = SecToMin(Math.Round(NewPosition, 3))
             End If
         End With
 
         mPlayer.Ctlcontrols.currentPosition = NewPosition
         mSelsDirty = True
         UpdateSelDur()
 
     End Sub
 
     'To accomodate the fast adjustment of video
     Private Sub lvPositions_KeyUp(ByVal sender As Object, ByVal e As System.Windows.Forms.KeyEventArgs) _
     Handles lvPositions.KeyUp
 
         If lvPositions.SelectedItems.Count <> 1 Then Exit Sub
         If e.KeyCode = Keys.Space Then
             TestSegment()
         Else
             MPcontrols.RefreshPositions()
         End If
 
     End Sub
 
     Private Sub MoveItemsUp(ByVal lvControl As ListView)
 
         With lvControl
             Dim NumSelected As Integer = .SelectedIndices.Count
             If .SelectedIndices.Contains(0) Then Exit Sub
 
             Dim Jump2 As Integer = .SelectedIndices.Item(NumSelected - 1) + 1
 
             For i As Integer = .SelectedIndices.Count - 1 To 0 Step -1
                 If i > 0 Then
                     'There is another selected item
                     If .SelectedIndices.Item(i - 1) = .SelectedIndices.Item(i) - 1 Then
                         'Contiguous item; check next item
                     Else
                         JumpItem(lvControl, .Items(.SelectedIndices.Item(i) - 1), Jump2)
                         Jump2 = .SelectedIndices.Item(i - 1) + 1
                     End If
                 Else
                     'This is the last selected item
                     JumpItem(lvControl, .Items(.SelectedIndices.Item(i) - 1), Jump2)
                 End If
             Next
         End With
         mSelsDirty = True
 
     End Sub
 
     Private Sub MoveItemsDn(ByVal lvControl As ListView)
         With lvControl
             Dim NumSelected As Integer = .SelectedIndices.Count
             If .SelectedIndices.Contains(.Items.Count - 1) Then Exit Sub
 
             Dim Jump2 As Integer = .SelectedIndices.Item(0)
             For i As Integer = 0 To .SelectedIndices.Count - 1
                 If i < NumSelected - 1 Then
                     'There is another selected item
                     If .SelectedIndices.Item(i + 1) = .SelectedIndices.Item(i) + 1 Then
                         'Contiguous item; check next item
                     Else
                         JumpItem(lvControl, .Items(.SelectedIndices.Item(i) + 1), Jump2)
                         Jump2 = .SelectedIndices.Item(i + 1)
                     End If
                 Else
                     'This is the last selected item
                     JumpItem(lvControl, .Items(.SelectedIndices.Item(i) + 1), Jump2)
                 End If
             Next
         End With
         mSelsDirty = True
 
     End Sub
 
     Private Sub lvPositions_SelectedIndexChanged(ByVal sender As Object, _
 ByVal e As System.EventArgs) Handles lvPositions.SelectedIndexChanged
 
         If Not mAllowListIndexChange Then Exit Sub
 
         If lvPositions.SelectedItems.Count = 1 Then
             lvSelectionInit()
             mPlayer.Ctlcontrols.currentPosition = mSelStrt
             mPlayer.Ctlcontrols.pause()
             MPcontrols.RefreshPositions()
         Else
             DisplayFineControls(False)
         End If
         Timer.Enabled = False
 
     End Sub
 
     Private Sub lvSelectionInit()
 
         With lvPositions.SelectedItems(0)
             mSelStrt = MinToSec(.Text)
             If .SubItems.Count = 1 Then
                 mSelStop = mPlayer.currentMedia.duration
                 mOneSidedSelection = True
             Else
                 mSelStop = MinToSec(.SubItems(1).Text)
                 mOneSidedSelection = False
             End If
         End With
 
         DisplayFineControls(True)
 
     End Sub
 
     Private Sub lvPositions_GotFocus(ByVal sender As Object, _
     ByVal e As System.EventArgs) Handles lvPositions.GotFocus, lvFiles.GotFocus
 
         Dim ListView As ListView = DirectCast(sender, ListView)
         If ListView.Items.Count = 0 Then Exit Sub
         If ListView.SelectedIndices.Count = 0 Then
             ListView.Items(0).Selected = True
         End If
 
     End Sub
 
     Private Sub SegMenu_Popup(ByVal sender As Object, ByVal e As System.EventArgs) Handles SegMenu.Popup
         If mItems(0) Is Nothing Then
             MenuItem11.Enabled = False
         Else
             MenuItem11.Enabled = True
         End If
         If lvPositions.SelectedItems.Count = 0 Then
             MenuItem9.Enabled = False
             MenuItem10.Enabled = False
         Else
             MenuItem9.Enabled = True
             MenuItem10.Enabled = True
         End If
     End Sub
 
     'Copy
     Private Sub MenuItem9_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles MenuItem9.Click
         If lvPositions.SelectedItems.Count = 0 Then Exit Sub
         CopySelected()
     End Sub
 
     'Delete
     Private Sub MenuItem10_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles MenuItem10.Click
         If lvPositions.SelectedItems.Count = 0 Then Exit Sub
         DeleteSelected()
     End Sub
 
     'Paste
     Private Sub MenuItem11_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles MenuItem11.Click
         PasteSelected()
     End Sub
 
     Private Sub DeleteSelected()
         With lvPositions
             Dim Segment As ListViewItem
             For Each Segment In .SelectedItems
                 .Items.Remove(Segment)
             Next
         End With
         UpdateSelDur()
         mSelsDirty = True
     End Sub
 
     Private Sub CopySelected()
         With lvPositions
             ReDim mItems(.SelectedItems.Count - 1)
             For i As Integer = 0 To .SelectedItems.Count - 1
                 mItems(i) = .SelectedItems(i)
             Next
         End With
     End Sub
 
     Private Sub PasteSelected()
         If mItems(0) Is Nothing Then Exit Sub
         Dim CopyTo As Integer, TempItem As ListViewItem
 
         With lvPositions
             If .SelectedItems.Count = 0 Then
                 CopyTo = .Items.Count - 1
             Else
                 CopyTo = .SelectedItems(0).Index
             End If
             For i As Integer = 1 To mItems.Length
                 TempItem = DirectCast(mItems(i - 1).Clone, ListViewItem)
                 .Items.Insert(CopyTo + i, TempItem)
             Next
         End With
         UpdateSelDur()
         mSelsDirty = True
     End Sub
 
 #End Region
 
 #Region "   Fine Slider events "
 
     Private Sub cStrtFrRev_Click(ByVal sender As System.Object, _
 ByVal e As System.EventArgs) Handles cStrtFrRev.Click
         DoFrameAdjustment(True, False)
     End Sub
 
     Private Sub cStrtFrFwd_Click(ByVal sender As System.Object, _
     ByVal e As System.EventArgs) Handles cStrtFrFwd.Click
         DoFrameAdjustment(True, True)
     End Sub
 
     Private Sub cEndFrRev_Click(ByVal sender As System.Object, _
     ByVal e As System.EventArgs) Handles cEndFrRev.Click
         DoFrameAdjustment(False, False)
     End Sub
 
     Private Sub cEndFrFwd_Click(ByVal sender As System.Object, _
     ByVal e As System.EventArgs) Handles cEndFrFwd.Click
         DoFrameAdjustment(False, True)
     End Sub
 
     Private Sub DisplayFineControls(ByVal Show As Boolean)
         Label9.Visible = Show
         FineResolution.Visible = Show
         cStrtFrFwd.Visible = Show
         cStrtFrRev.Visible = Show
         cEndFrFwd.Visible = Show
         cEndFrRev.Visible = Show
     End Sub
 
     Private Function Safe2ShowTuner() As Boolean
 
         Select Case lvPositions.SelectedItems.Count
             Case 0, Is > 1
                 Return False
             Case 1
                 If lvPositions.SelectedItems(0).SubItems.Count = 1 Then Return False
         End Select
         Return True
 
     End Function
 
 #End Region
 
 #Region "   Utility and Worker Functions "
 
     Private Sub JumpItem(ByVal lvControl As ListView, _
         ByVal Item As ListViewItem, ByVal Jump2Pos As Integer)
 
         With lvControl
             Dim TempItem As ListViewItem = DirectCast(Item.Clone, ListViewItem)
             .Items.Insert(Jump2Pos, TempItem)
             .Items.Remove(Item)
         End With
 
     End Sub
 
     Private Function CreateHandler(ByVal Extension As String) As Boolean
 
         Timer.Enabled = False
         Try
             'Create a handler instance based on extension
             Select Case LCase(Extension)
                 Case ".mpg", ".mpeg"
                     mHandler = New MPGhandler(Me, mInFile)
                     mIsAudio = False
                 Case ".wmv", ".asf"
                     mHandler = New ASFhandler(Me, mInFile)
                     mIsAudio = False
                 Case ".avi"
                     mHandler = New AVIhandler(Me, mInFile)
                     mIsAudio = False
                 Case ".rm"
                     mHandler = New RMhandler(Me, mInFile)
                     mIsAudio = False
                 Case ".flv"
                     mHandler = New FLVhandler(Me, mInFile)
                     mIsAudio = False
                 Case ".mp3"
                     mHandler = New MPGhandler(Me, mInFile, True)
                     mIsAudio = True
                 Case ".wma"
                     mHandler = New ASFhandler(Me, mInFile, True)
                     mIsAudio = True
                 Case Else
                     MsgBox("Filetype not supported
                     mPlayer.URL = ""
                     mHandler = Nothing
                     SwitchVisual(True)
                     Return False
             End Select
         Catch ex As Exception
             MsgBox(ex.Message)
         End Try
 
         SwitchVisual(False)
         Return True
 
     End Function
 
     Private Function SecToMin(ByVal Sec As Double) As String
 
         Dim TempDt As Date
         TempDt = Date.FromOADate(Sec / 86400)    '24 * 60 * 60
         If Sec >= 3600 Then
             Return TempDt.ToString("HH
         Else
             Return TempDt.ToString("mm
         End If
 
     End Function
 
     Private Function MinToSec(ByVal Min As String) As Double
 
         Dim Temp As String()
 
         Temp = Split(Min, "
 
         Select Case UBound(Temp)
             Case 0
                 Return Val(Temp(0))
             Case 1
                 Return (Val(Temp(0)) * 60) + Val(Temp(1))
             Case 2
                 Return (Val(Temp(0)) * 3600) + (Val(Temp(1)) * 60) + Val(Temp(2))
         End Select
 
     End Function
 
     Private Function TrashFile(ByRef sPath As String) As Boolean
         Dim FileOp As SHFILEOPSTRUCT
         If Not File.Exists(sPath) Then
             MsgBox("Could not find " & sPath & "." & vbCrLf _
             & "Please verify the path.")
             Return True
         End If
         With FileOp
             .wFunc = FO_DELETE
             .pFrom = sPath & vbNullChar
             .pTo = vbNullChar
             .fFlags = FOF_NOCONFIRMATION Or FOF_ALLOWUNDO
             .lpszProgressTitle = "Sending " & sPath & " to the Recycle Bin"
         End With
         Try
             SHFileOperation(FileOp)
         Catch ex As Exception
             MsgBox(ex.Message)
         End Try
     End Function
 
     Private Sub ToggleFastForward()
 
         'Pause the player and reset other buttons
         mPlayer.Ctlcontrols.pause()
         mFRev = False
         MPcontrols.cFRev.Pushed = False
 
         'Start it again
         If mFFwd Then
             mFFwd = False
             mPlayer.settings.rate = 1
         Else
             mFFwd = True
             mPlayer.settings.rate = 2
         End If
         mPlayer.Ctlcontrols.play()
         MPcontrols.cFFwd.Pushed = mFFwd
 
     End Sub
 
     Private Sub ToggleFastReverse()
 
         'Pause the player and reset other buttons
         mPlayer.Ctlcontrols.pause()
         mFFwd = False
         MPcontrols.cFFwd.Pushed = False
 
         'Start it again
         mPlayer.Ctlcontrols.pause()
         If mFRev Then
             mFRev = False
             mPlayer.settings.rate = 1
         Else
             mFRev = True
             mPlayer.settings.rate = -2
         End If
         mPlayer.Ctlcontrols.play()
         MPcontrols.cFRev.Pushed = mFRev
 
     End Sub
 
     Private Sub ResetFastButtons()
         mFFwd = False
         mFRev = False
         MPcontrols.cFFwd.Pushed = False
         MPcontrols.cFRev.Pushed = False
     End Sub
 
     Private Sub StartSelection()
 
         Dim CurrPos As Double
         CurrPos = Math.Round(mPlayer.Ctlcontrols.currentPosition, 3)
 
         'Debug.Write(CurrPos)
         'Debug.WriteLine(Timer.Enabled)
 
         Dim Last As Integer = lvPositions.Items.Count - 1
 
         With lvPositions
             If Last < 0 Then
                 'Create new item; because first entry
                 Dim NewItem As New ListViewItem
                 If CurrPos < mReactTime Then
                     NewItem.Text = "0"
                 Else
                     NewItem.Text = SecToMin(CurrPos - mReactTime)
                 End If
                 lvPositions.Items.Add(NewItem)
             ElseIf .Items(Last).SubItems.Count > 1 Then
                 'Create new item; because end exists
                 Dim NewItem As New ListViewItem
                 If CurrPos < mReactTime Then
                     NewItem.Text = "0"
                 Else
                     NewItem.Text = SecToMin(CurrPos - mReactTime)
                 End If
                 lvPositions.Items.Add(NewItem)
             Else
                 'Change start
                 If CurrPos < mReactTime Then
                     .Items(Last).Text = "0"
                 Else
                     .Items(Last).Text = SecToMin(CurrPos - mReactTime)
                 End If
             End If
         End With
         mSelsDirty = True
 
     End Sub
 
     Private Sub EndSelection()
 
         Dim CurrPos As Double
         CurrPos = Math.Round(mPlayer.Ctlcontrols.currentPosition, 3)
 
         'Debug.Write(CurrPos)
         'Debug.WriteLine(Timer.Enabled)
 
         Dim Last As Integer = lvPositions.Items.Count - 1
         If Last < 0 Then Exit Sub
 
         With lvPositions.Items(Last)
             If CurrPos - mReactTime <= MinToSec(.Text) Then Exit Sub
             If .SubItems.Count = 1 Then
                 'Add End
                 .SubItems.Add(SecToMin(CurrPos - mReactTime))
             Else
                 'Change End
                 .SubItems(1).Text = SecToMin(CurrPos - mReactTime)
             End If
         End With
 
         UpdateSelDur()
         mSelsDirty = True
 
     End Sub
 
     Private Sub UpdateSelDur()
         If lvPositions.Items.Count = 0 Then Exit Sub
         Dim Sel As Double
         With lvPositions
             For i As Integer = 0 To .Items.Count - 1
                 If .Items(i).SubItems.Count = 1 Then Exit For
                 Sel += MinToSec(.Items(i).SubItems(1).Text) - MinToSec(.Items(i).Text)
             Next
         End With
 
         statSel.Text = mTranslator.LangText(120) & "
     End Sub
 
     Private Sub UpdateHandlerOptions()
         If mHandler Is Nothing Then Exit Sub
         mHandler.Options("FrameAccurate") = CStr(chkFrameAccurate.Checked)
         mHandler.Options("ForceJoin") = CStr(chkForceJoin.Checked)
     End Sub
 
     Private Function StripExtention(ByVal Filename As String) As String
         Dim ExtStrt As Integer = InStrRev(Filename, ".")
         Return Filename.Substring(0, ExtStrt - 1)
     End Function
 
     Private Sub Waiting(ByVal State As Boolean)
         picStatus.Visible = State
         Me.Refresh()
     End Sub
 
 #End Region
 
 #Region "   Tabs - Splitting "
 
     Private Sub UpdateEditorOptions(ByVal Extension As String)
 
         Dim EditingSupported As Boolean
         If mHandler Is Nothing Then
             EditingSupported = False
             radSize.Enabled = False
             tSplitName.Text = ""
             cSplitBrw.Enabled = False
         Else
             EditingSupported = mHandler.IsSupported("Editing")
             radSize.Enabled = mHandler.IsSupported("SizeSplit")
             tSplitName.Text = mHandler.GetSplitName(tFile2Split.Text)
             cSplitBrw.Enabled = True
         End If
 
         mnuSave.Enabled = EditingSupported
         mnuSaveX.Enabled = EditingSupported
         mnuSaveSepFiles.Enabled = EditingSupported
         mnuInfo.Enabled = EditingSupported
         cbSize.Enabled = radSize.Enabled
         cSplit.Enabled = EditingSupported
 
         Select Case LCase(Extension)
             Case ".wmv", ".asf"
                 mnuImpSkip.Enabled = CheckForSkipFile("SmartSkip")
                 mnuImpComskip.Enabled = False
             Case ".mpg", ".mpeg"
                 mnuImpSkip.Enabled = CheckForSkipFile("SmartSkip")
                 mnuImpComskip.Enabled = CheckForSkipFile("Comskip")
             Case Else
                 mnuImpSkip.Enabled = False
                 mnuImpComskip.Enabled = False
         End Select
     End Sub
 
     Private Function CheckForSkipFile(ByVal Type As String) As Boolean
 
         Dim SkipFilename As String
         Select Case Type
             Case "Comskip"
                 SkipFilename = StripExtention(mInFile) & ".txt"
             Case "SmartSkip"
                 SkipFilename = mInFile & ".chapters.xml"
         End Select
 
         Try
             Dim fi As New FileInfo(SkipFilename)
             Return fi.Exists
         Catch ex As Exception
             'do nothing
         End Try
 
     End Function
 
     Private Sub cSplit_Click(ByVal sender As System.Object, _
     ByVal e As System.EventArgs) Handles cSplit.Click
 
         Dim SplitName As String
         If mFileLoaded = False Then Exit Sub
         If Len(Trim(tSplitName.Text)) = 0 Then
             MsgBox("Please specify name for split parts")
             Exit Sub
         Else
             SplitName = Trim(tSplitName.Text)
         End If
 
         'Validation
         If radTime.Checked Then
             Dim Duration As Double
             Duration = numHr.Value * 3600 + numMin.Value * 60 + numSec.Value
             If Duration > mPlayer.currentMedia.duration Then
                 MsgBox("Duration cannot be greater than media play time")
                 Exit Sub
             End If
             If Duration <= 0 Then
                 MsgBox("Duration should be at least 1 second !!")
                 Exit Sub
             End If
         End If
 
         If radPieces.Checked Then
             If numPcs.Value <= 1 Then
                 MsgBox("Number of parts required should be more than 1")
                 Exit Sub
             End If
         End If
 
         If radSize.Checked Then
             Dim Value As Integer = CInt(Val(cbSize.Text))
             If Value <= 0 Then
                 MsgBox("Please use non-zero numeric values")
                 Exit Sub
             End If
             AddToList(Value)
         End If
 
         'Running the split
         mainTabs.SelectedTab = tabTrace
         rtfTrace.SelectedText = vbCrLf
         statMain.Text = mTranslator.LangText(72)
         If chkKeepMRU.Checked Then rtfTrace.Clear()
 
         Dim Result As Boolean
         If radTime.Checked Then
             Dim Duration As Double
             Duration = numHr.Value * 3600 + numMin.Value * 60 + numSec.Value
             Result = mHandler.Split(SplitName, Duration, mPlayer.currentMedia.duration)
         End If
         If radPieces.Checked Then
             Result = mHandler.Split(SplitName, CShort(numPcs.Value), _
             mPlayer.currentMedia.duration)
         End If
         If radSize.Checked Then
             Result = mHandler.Split(SplitName, CInt(Val(cbSize.Text)))
         End If
 
         If Result Then
             UpdateRTF(vbCrLf & "Success !" & vbCrLf, modMain.MessageType.Success)
             ShowProcessStat(modMain.MessageType.Success)
         Else
             UpdateRTF(vbCrLf & "Failure !" & vbCrLf, modMain.MessageType.Failure)
             ShowProcessStat(modMain.MessageType.Failure)
         End If
         statMain.Text = mTranslator.LangText(23)
         If chkBeep.Checked Then Beep()
 
     End Sub
 
     Private Sub AddToList(ByVal Value As Integer)
         For Each i As Object In cbSize.Items
             If DirectCast(i, Integer) = Value Then Exit Sub
         Next
         cbSize.Items.Add(Value)
         UpdateEstSize()
     End Sub
 
     Private Sub cSplitBrw_Click(ByVal sender As System.Object, _
     ByVal e As System.EventArgs) Handles cSplitBrw.Click
 
         dlgSaveFile.InitialDirectory = dlgOpenFile.InitialDirectory
         dlgSaveFile.DefaultExt = mHandler.Extension
         dlgSaveFile.FileName = mHandler.GetSplitName(tFile2Split.Text)
         dlgSaveFile.Filter = mHandler.Extension(True) + " |*" + mHandler.Extension
 
         If dlgSaveFile.ShowDialog() = Windows.Forms.DialogResult.OK Then
             tSplitName.Text = dlgSaveFile.FileName
         End If
 
     End Sub
 
     Private Sub numPick_Enter(ByVal sender As Object, _
     ByVal e As System.EventArgs) _
     Handles numHr.Enter, numMin.Enter, numSec.Enter, numPcs.Enter
 
         Dim Ctl As Control = DirectCast(sender, Control)
         If Ctl Is numPcs Then
             radPieces.Checked = True
         Else
             radTime.Checked = True
         End If
 
     End Sub
 
     Private Sub cbSize_Enter(ByVal sender As Object, _
     ByVal e As System.EventArgs) Handles cbSize.Enter
         radSize.Checked = True
     End Sub
 
     Private Sub radTime_CheckedChanged(ByVal sender As System.Object, _
     ByVal e As System.EventArgs) Handles radTime.CheckedChanged, radPieces.CheckedChanged, radSize.CheckedChanged
         UpdateEstSize()
     End Sub
 
     Private Sub UpdateEstSize()
 
         If mHandler Is Nothing Then Exit Sub
         If mPlayer.openState <> WMPLib.WMPOpenState.wmposMediaOpen Then Exit Sub
 
         Dim fi As New FileInfo(mHandler.InputFile)
         Dim FileSize As Long = fi.Length
         Dim EstSize As Double
 
         If radTime.Checked Then
             Dim Duration As Double
             Duration = numHr.Value * 3600 + numMin.Value * 60 + numSec.Value
             If Duration > mPlayer.currentMedia.duration Then
                 EstSize = FileSize / 1024
             Else
                 EstSize = (Duration / mPlayer.currentMedia.duration) * (FileSize / 1024)
             End If
         End If
 
         If radPieces.Checked Then
             If numPcs.Value = 0 Then Exit Sub
             EstSize = (FileSize / numPcs.Value) / 1024
         End If
 
         If radSize.Checked Then
             If Len(cbSize.Text) = 0 Then
                 EstSize = 0
             Else
                 EstSize = Val(cbSize.Text)
                 If EstSize > FileSize / 1024 Then EstSize = FileSize / 1024
             End If
         End If
 
         lSize.Text = CStr(CInt(EstSize)) + " kb"
 
     End Sub
 
     Private Sub numHr_ValueChanged(ByVal sender As Object, _
     ByVal e As System.EventArgs) Handles numHr.ValueChanged, numMin.ValueChanged, numSec.ValueChanged, numPcs.ValueChanged
         UpdateEstSize()
     End Sub
 
     Private Sub cbSize_TextChanged(ByVal sender As Object, _
     ByVal e As System.EventArgs) Handles cbSize.TextChanged
         UpdateEstSize()
     End Sub
 
 #End Region
 
 #Region "   Process events and RTF updates "
 
     Public Sub MessageRecd(ByVal sender As Object, _
     ByVal ea As AsyncOps.DataReceivedEventArgs)
         If ea.Type = "S" Then
             If ea.Text Is Nothing Then
                 UpdateRTF(StrStd.ToString, modMain.MessageType.AsUsual)
                 StrStd.Length = 0
             Else
                 BufferOutput(ea.Text, False)
             End If
         Else
             If ea.Text Is Nothing Then
                 UpdateRTF(StrErr.ToString, modMain.MessageType.Failure)
                 StrErr.Length = 0
             Else
                 BufferOutput(ea.Text, True)
             End If
         End If
     End Sub
 
     Dim StrStd, StrErr As New System.Text.StringBuilder
         InitializeComponent()
 
         'Add any initialization after the InitializeComponent() call
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="342" endline="374">
<![CDATA[
 
     Sub SelectUsingTieBreak()
         'Otherwise, given any two members of the set, M and N, apply the following tie-breaking rules, in order
 
         '?	If M has fewer parameters from an expanded paramarray than N, eliminate N from the set. For example
         For i As Integer = 0 To m_Candidates.Count - 1
             If m_Candidates(i).IsRemoved("ParamArrayTieBreak") Then Continue For
 
             For j As Integer = i + 1 To m_Candidates.Count - 1
                 If m_Candidates(j).IsRemoved("ParamArrayTieBreak") Then Continue For
 
                 If m_Candidates(i).ParametersFromExpandedParamArray > m_Candidates(j).ParametersFromExpandedParamArray Then
                     m_Candidates(i).RemovedBy = "ParamArrayTieBreak"
                 ElseIf m_Candidates(i).ParametersFromExpandedParamArray < m_Candidates(j).ParametersFromExpandedParamArray Then
                     m_Candidates(j).RemovedBy = "ParamArrayTieBreak"
                 End If
             Next
         Next
 
         If CandidatesLeft <= 1 Then Return
 
         '7.1.	If M is defined in a more derived type than N, eliminate N from the set
         '7.2.	If M and N are extension methods and the target type of M is a class or structure and the target type of N is an interface, eliminate N from the set.
         '7.3.	If M and N are extension methods and the target type of M has fewer type parameters than the target type of N, eliminate N from the set.
         '7.4.	If M is less generic than N, eliminate N from the set.
         '7.5.	If M is not an extension method and N is, eliminate N from the set.
         '7.6.	If M and N are extension methods and M was found before N, eliminate N from the set.
         '7.7.	If M and N both required type inference to produce type arguments, and M did not require determining the dominant type for any of its type arguments (i.e. each the type arguments inferred to a single type), but N did, eliminate N from the set.
         '7.8.	If one or more arguments are AddressOf or lambda expressions, and all of the corresponding delegate types in M match exactly, but not all do in N, eliminate N from the set.
         '7.9.	If one or more arguments are AddressOf or lambda expressions, and all of the corresponding delegate types in M are widening conversions, but not all are in N, eliminate N from the set.
         '7.10.	If the overload resolution is being done to resolve the target of a delegate-creation expression from an AddressOf expression and M is a function, while N is a subroutine, eliminate N from the set.
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1595" endline="1609">
<![CDATA[
 
     ''' <summary>
     ''' Loads the address of the parameter.
     ''' Just loads the value if it is a byref parameter.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Variable"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadVariableLocation(ByVal Info As EmitInfo, ByVal Variable As Mono.Cecil.ParameterDefinition)
         If CecilHelper.IsByRef(Variable.ParameterType) Then
             EmitLoadParameter(Info, Variable)
         Else
             Info.ILGen.Emit(OpCodes.Ldarga, CShort(GetParameterPosition(Info, Variable)))
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\DotAccessExpression.vb" startline="49" endline="59">
<![CDATA[
 
     Public Overrides Function GetConstant(ByRef result As Object, ByVal ShowError As Boolean) As Boolean
         Dim attrib As Attribute = Me.FindFirstParent(Of Attribute)()
         If attrib Is Nothing Then
             If ShowError Then Show30059()
             Return False
         End If
 
         result = m_TypeName.ResolvedType
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="403" endline="418">
<![CDATA[
 
     ''' <summary>
     ''' Returns all the types within the specified namespace.
     ''' Never returns nothing and never throws an exception.
     ''' </summary>
     ''' <param name="Namespace"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetTypesByNamespace(ByVal [Namespace] As String) As TypeDictionary
         If [Namespace] Is Nothing Then [Namespace] = ""
         If m_CecilTypesByNamespace.ContainsKey([Namespace]) Then
             Return m_CecilTypesByNamespace([Namespace])
         Else
             Return New TypeDictionary()
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="860" endline="869">
<![CDATA[
     End Property
 
     ReadOnly Property IsAccessible() As Boolean
         Get
             If Resolver.Caller Is Nothing Then
                 Return Helper.IsAccessibleExternal(Compiler, m_Member)
             Else
                 Return Helper.IsAccessible(Compiler, Resolver.Caller.CecilType, m_Member)
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="1329" endline="1341">
<![CDATA[
 
     Private Function ParseIdentifier(ByVal Parent As ParsedObject) As Identifier
         Dim result As Identifier
 
         If tm.CurrentToken.IsIdentifier Then
             result = New Identifier(Parent, tm.CurrentToken.Identifier, tm.CurrentLocation, tm.CurrentTypeCharacter)
             tm.NextToken()
         Else
             result = Nothing
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="321" endline="330">
<![CDATA[
 
     <Diagnostics.DebuggerHidden()> Function AcceptIfNotError(ByVal Special As KS, ByVal Message As Messages, ByVal GotoNewline As Boolean, ByVal MessageParameter As String) As Boolean
         If Accept(Special) Then
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Compiler.Report.ShowMessage(Message, CurrentLocation, MessageParameter)
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="145" endline="167">
<![CDATA[
 
     ''' <summary>
     ''' Checks if the specified symbol is defined at the specified location.
     ''' </summary>
     ''' <param name="Symbol"></param>
     ''' <param name="Location"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsDefinedAtLocation(ByVal Symbol As String, ByVal Location As Span) As Boolean
         Dim constants As ConditionalConstants
 
         constants = Location.File(Compiler).GetConditionalConstants(Location.Line)
 
         If constants IsNot Nothing AndAlso constants.ContainsKey(Symbol) Then
             Return constants(Symbol).IsDefined
         End If
 
         If m_ProjectConstants.ContainsKey(Symbol) Then
             Return m_ProjectConstants(Symbol).IsDefined
         End If
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="220" endline="238">
<![CDATA[
 
     Public Function ConvertToDouble(ByRef result As Object, ByVal ShowError As Boolean) As Boolean
         Dim tpCode As TypeCode
 
         tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, result))
 
         Select Case tpCode
             Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, _
             TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal
                 result = CDbl(result) 'No range checking needed.
             Case TypeCode.DBNull
                 result = CDbl(0)
             Case Else
                 If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30060, Location, result.ToString, Helper.ToString(Expression, ExpressionType))
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="318" endline="336">
<![CDATA[
 
     Public Function ConvertToBoolean(ByRef result As Object, ByVal ShowError As Boolean) As Boolean
         Dim tpCode As TypeCode
 
         tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, result))
 
         Select Case tpCode
             Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, _
               TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal
                 result = CBool(result) 'No range checking needed.
             Case TypeCode.DBNull
                 result = CBool(Nothing)
             Case Else
                 If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30060, Location, result.ToString, Helper.ToString(Expression, ExpressionType))
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AliasClause.vb" startline="202" endline="221">
<![CDATA[
 
     Shared Function GetSetMethod(ByVal Compiler As Compiler, ByVal ArrayType As Mono.Cecil.TypeReference) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
         Dim ranks As Integer = CecilHelper.GetArrayRank(ArrayType)
         Dim methodtypes As Mono.Cecil.TypeReference() = Helper.CreateArray(Of Mono.Cecil.TypeReference)(Compiler.TypeCache.System_Int32, ranks + 1)
 
         methodtypes(ranks) = elementType
 
         ArrayType = Helper.GetTypeOrTypeBuilder(Compiler, ArrayType)
         elementType = Helper.GetTypeOrTypeBuilder(Compiler, elementType)
         result = New Mono.Cecil.MethodReference("Set", ArrayType, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Void), True, False, Mono.Cecil.MethodCallingConvention.Default)
 
         For i As Integer = 1 To ranks
             result.Parameters.Add(New Mono.Cecil.ParameterDefinition(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Int32)))
         Next
         result.Parameters.Add(New Mono.Cecil.ParameterDefinition(Helper.GetTypeOrTypeReference(Compiler, elementType)))
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="54" endline="79">
<![CDATA[
     End Property
 
     Public Overrides Function GetConstant(ByRef m_ConstantValue As Object, ByVal lvalue As Object, ByVal rvalue As Object) As Boolean
         If lvalue Is Nothing Then lvalue = 0
         If rvalue Is Nothing Then rvalue = 0
 
         Dim tlvalue, trvalue As Mono.Cecil.TypeReference
         Dim clvalue, crvalue As TypeCode
         tlvalue = CecilHelper.GetType(Compiler, lvalue)
         clvalue = Helper.GetTypeCode(Compiler, tlvalue)
         trvalue = CecilHelper.GetType(Compiler, rvalue)
         crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
         Helper.Assert(Compiler.TypeResolution.IsNumericType(tlvalue) AndAlso Compiler.TypeResolution.IsNumericType(trvalue))
 
         'An exponent operator always returns a double result.
         Select Case clvalue
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, _
              TypeCode.Int64, TypeCode.UInt64, TypeCode.Double, TypeCode.Single, TypeCode.Decimal
                 m_ConstantValue = Math.Pow(CDbl(lvalue), CDbl(rvalue))
             Case Else
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="310" endline="326">
<![CDATA[
 
     Friend Overloads Function GenerateCode(ByVal Info As EmitInfo, ByVal params As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(params.Count >= Me.Count)
 
         For i As Integer = 0 To Count - 1
             result = Item(i).GenerateCode(Info.Clone(Me, True, False, params(i).ParameterType), params(i)) AndAlso result
         Next
 
         For i As Integer = Count To params.Count - 1
             Helper.Assert(params(i).IsOptional)
             Emitter.EmitLoadValue(Info.Clone(Me, params(i).ParameterType), params(i).Constant)
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4272" endline="4307">
<![CDATA[
 
     ''' <summary>
     ''' Creates the expression that is to be emitted for an optional parameter.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="Parameter"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function GetOptionalValueExpression(ByVal Parent As ParsedObject, ByVal Parameter As Mono.Cecil.ParameterDefinition) As Expression
         Dim result As Expression
         If Helper.CompareType(Parameter.ParameterType, Parent.Compiler.TypeCache.System_Object) AndAlso Helper.IsOnMS AndAlso Parameter.Constant Is DBNull.Value Then
             'Mono hasn't implemented ParameterInfo.RawDefaultValue yet.
 
             'If an Object parameter does not specify a default value, then the expression 
             'System.Reflection.Missing.Value is used. 
             result = New LoadFieldExpression(Parent, Parent.Compiler.TypeCache.System_Reflection_Missing__Value)
         ElseIf Helper.CompareType(Parameter.ParameterType, Parent.Compiler.TypeCache.System_Int32) AndAlso CecilHelper.IsDefined(Parameter.CustomAttributes, Parent.Compiler.TypeCache.MS_VB_CS_OptionCompareAttribute) Then
             'If an optional Integer parameter 
             'has the Microsoft.VisualBasic.CompilerServices.OptionCompareAttribute attribute, 
             'then the literal 1 is supplied for text comparisons and the literal 0 otherwise
             Dim cExp As ConstantExpression
             If Parent.Location.File(Parent.Compiler).IsOptionCompareText Then
                 cExp = New ConstantExpression(Parent, 1I, Parent.Compiler.TypeCache.System_Int32)
             Else
                 cExp = New ConstantExpression(Parent, 0I, Parent.Compiler.TypeCache.System_Int32)
             End If
             result = cExp
         Else
             'If optional parameters remain, the default value 
             'specified in the optional parameter declaration is matched to the parameter. 
             Dim cExp As ConstantExpression
             cExp = New ConstantExpression(Parent, Parameter.Constant, Parameter.ParameterType)
             result = cExp
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="47" endline="78">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Loads the method pointer onto the evalation stack.
     ''' Creates a new delegate of the specified type.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_ResolvedMethod IsNot Nothing)
         Helper.Assert(m_DelegateType IsNot Nothing)
 
         If m_MethodGroup.InstanceExpression IsNot Nothing AndAlso CecilHelper.IsStatic(m_ResolvedMethod) = False Then
             result = m_MethodGroup.InstanceExpression.GenerateCode(Info.Clone(Parent, True, False, m_MethodGroup.InstanceExpression.ExpressionType)) AndAlso result
             Emitter.EmitDup(Info)
         Else
             Emitter.EmitLoadNull(Info.Clone(Parent, True, False, Compiler.TypeCache.System_Object))
         End If
 
         Emitter.EmitLoadVftn(Info, m_ResolvedMethod)
 
         Dim ctor As Mono.Cecil.MethodReference
         Dim dT As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(m_DelegateType)
         ctor = CecilHelper.FindConstructor(dT.Methods, False, New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_Object, Compiler.TypeCache.System_IntPtr})
         ctor = CecilHelper.GetCorrectMember(ctor, m_DelegateType)
         Emitter.EmitNew(Info, ctor)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Compiler.vb" startline="275" endline="299">
<![CDATA[
 
     Function Compile_CalculateOutputFilename() As Boolean
         If CommandLine.Out = "" Then
             'Get the first filename
             m_OutFilename = CommandLine.Files(0).FileName
             'Strip the extension
             m_OutFilename = m_OutFilename.Substring(0, m_OutFilename.Length - IO.Path.GetExtension(m_OutFilename).Length)
 
             If m_OutFilename.EndsWith(".") = False Then m_OutFilename &= "."
             'Put on the correct extension
             If CommandLine.Target = vbnc.CommandLine.Targets.Console OrElse CommandLine.Target = vbnc.CommandLine.Targets.Winexe Then
                 m_OutFilename &= "exe"
             ElseIf CommandLine.Target = vbnc.CommandLine.Targets.Library Then
                 m_OutFilename &= "dll"
             ElseIf CommandLine.Target = vbnc.CommandLine.Targets.Module Then
                 m_OutFilename &= "netmodule"
             Else
                 Throw New InternalException(Me)
             End If
         Else
             m_OutFilename = CommandLine.Out
         End If
         m_OutFilename = IO.Path.GetFullPath(m_OutFilename)
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\CaseClauses.vb" startline="81" endline="112">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         'If the Continue statement is not contained within the kind of block specified in the statement, a compile-time error occurs.
         Select Case m_ContinueWhat
             Case KS.While
                 m_ContainingStatement = Me.FindFirstParent(Of WhileStatement)()
                 If m_ContainingStatement Is Nothing Then
                     'Helper.AddCheck("error BC30784
                     Compiler.Report.ShowMessage(Messages.VBNC30784, Location)
                 End If
             Case KS.For
                 m_ContainingStatement = CType(Me.FindFirstParent(Of ForEachStatement, ForStatement)(), Statement)
                 If m_ContainingStatement Is Nothing Then
                     'Helper.AddError("error BC30783
                     Compiler.Report.ShowMessage(Messages.VBNC30783, Location)
                 End If
             Case KS.Do
                 m_ContainingStatement = Me.FindFirstParent(Of DoStatement)()
                 If m_ContainingStatement Is Nothing Then
                     'Helper.AddCheck("error BC30782
                     Compiler.Report.ShowMessage(Messages.VBNC30782, Location)
                 End If
             Case KS.Else
                 Throw New InternalException(Me)
         End Select
         result = m_ContainingStatement IsNot Nothing
 
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MemberCache.vb" startline="158" endline="184">
<![CDATA[
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <param name="Name">Load every member if Name is nothing</param>
     ''' <remarks></remarks>
     Private Sub Load(ByVal Name As String, ByVal Visibility As MemberVisibility)
         If m_LoadedAll(Visibility) Then
             Return
         ElseIf m_LoadedNames(Visibility) Is Nothing Then
             m_LoadedNames(Visibility) = New HashSet(Of String)(Helper.StringComparer)
         ElseIf Name IsNot Nothing AndAlso m_LoadedNames(Visibility).Contains(Name) Then
             Return
         End If
 
         If Name Is Nothing Then Clear(Visibility)
 
         If Name IsNot Nothing Then m_LoadedNames(Visibility).Add(Name)
 
         For i As Integer = 0 To m_Types.Count - 1
             Load(m_Types(i), m_Members(i), Name, Visibility)
         Next
 
         Flatten(Name, Visibility)
 
         If Name Is Nothing Then m_LoadedAll(Visibility) = True
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="55" endline="75">
<![CDATA[
 
     Public Function ConvertToSByte(ByRef result As Object, ByVal ShowError As Boolean) As Boolean
         Dim tpCode As TypeCode
 
         tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, result))
 
         Select Case tpCode
             Case TypeCode.SByte
                 result = CSByte(result) 'No range checking needed.
             Case TypeCode.Boolean, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                 If Compiler.TypeResolution.CheckNumericRange(result, result, ExpressionType) = False Then
                     If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                     Return False
                 End If
             Case Else
                 If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30060, Location, result.ToString, Helper.ToString(Expression, ExpressionType))
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="76" endline="96">
<![CDATA[
 
     Public Function ConvertToShort(ByRef result As Object, ByVal ShowError As Boolean) As Boolean
         Dim tpCode As TypeCode
 
         tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, result))
 
         Select Case tpCode
             Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16
                 result = CShort(result) 'No range checking needed.
             Case TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                 If Compiler.TypeResolution.CheckNumericRange(result, result, ExpressionType) = False Then
                     If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                     Return False
                 End If
             Case Else
                 If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30060, Location, result.ToString, Helper.ToString(Expression, ExpressionType))
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="97" endline="117">
<![CDATA[
 
     Public Function ConvertToUShort(ByRef result As Object, ByVal ShowError As Boolean) As Boolean
         Dim tpCode As TypeCode
 
         tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, result))
 
         Select Case tpCode
             Case TypeCode.Boolean, TypeCode.Byte, TypeCode.UInt16
                 result = CUShort(result) 'No range checking needed.
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.SByte, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                 If Compiler.TypeResolution.CheckNumericRange(result, result, ExpressionType) = False Then
                     If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                     Return False
                 End If
             Case Else
                 If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30060, Location, result.ToString, Helper.ToString(Expression, ExpressionType))
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="118" endline="137">
<![CDATA[
 
     Public Function ConvertToInt32(ByRef originalValue As Object, ByVal ShowError As Boolean) As Boolean
         Dim tpCode As TypeCode
 
         tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, originalValue))
         Select Case tpCode
             Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32
                 originalValue = CInt(originalValue) 'No range checking needed.
             Case TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                 If Compiler.TypeResolution.CheckNumericRange(originalValue, originalValue, ExpressionType) = False Then
                     If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                     Return False
                 End If
             Case Else
                 If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30060, Location, originalValue.ToString, Helper.ToString(Expression, ExpressionType))
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="138" endline="157">
<![CDATA[
 
     Public Function ConvertToUInt32(ByRef result As Object, ByVal ShowError As Boolean) As Boolean
         Dim tpCode As TypeCode
 
         tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, result))
         Select Case tpCode
             Case TypeCode.Boolean, TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32
                 result = CUInt(result) 'No range checking needed.
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                 If Compiler.TypeResolution.CheckNumericRange(result, result, ExpressionType) = False Then
                     If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                     Return False
                 End If
             Case Else
                 If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30060, Location, result.ToString, Helper.ToString(Expression, ExpressionType))
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="158" endline="178">
<![CDATA[
 
     Public Function ConvertToLong(ByRef result As Object, ByVal ShowError As Boolean) As Boolean
         Dim tpCode As TypeCode
 
         tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, result))
 
         Select Case tpCode
             Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt32
                 result = CLng(result) 'No range checking needed.
             Case TypeCode.UInt64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                 If Compiler.TypeResolution.CheckNumericRange(result, result, ExpressionType) = False Then
                     If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                     Return False
                 End If
             Case Else
                 If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30060, Location, result.ToString, Helper.ToString(Expression, ExpressionType))
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="179" endline="198">
<![CDATA[
 
     Public Function ConvertToULong(ByRef result As Object, ByVal ShowError As Boolean) As Boolean
         Dim tpCode As TypeCode
 
         tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, result))
         Select Case tpCode
             Case TypeCode.Boolean, TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 result = CULng(result) 'No range checking needed.
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.SByte, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.DBNull
                 If Compiler.TypeResolution.CheckNumericRange(result, result, ExpressionType) = False Then
                     If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                     Return False
                 End If
             Case Else
                 If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30060, Location, result.ToString, Helper.ToString(Expression, ExpressionType))
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="199" endline="219">
<![CDATA[
 
     Public Function ConvertToSingle(ByRef result As Object, ByVal ShowError As Boolean) As Boolean
         Dim tpCode As TypeCode
 
         tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, result))
 
         Select Case tpCode
             Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Decimal
                 result = CSng(result) 'No range checking needed.
             Case TypeCode.Double, TypeCode.DBNull
                 If Compiler.TypeResolution.CheckNumericRange(result, result, ExpressionType) = False Then
                     If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                     Return False
                 End If
             Case Else
                 If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30060, Location, result.ToString, Helper.ToString(Expression, ExpressionType))
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="23" endline="70">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim opType As TypeCode = MyBase.OperandTypeCode
 
         ValidateBeforeGenerateCode(Info)
 
         Select Case opType
             Case TypeCode.Boolean, TypeCode.Object
                 If opType = TypeCode.Object Then
                     Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 End If
 
                 Dim loadfalse, loadtrue, endexp As Label
                 loadfalse = Emitter.DefineLabel(Info)
                 loadtrue = Emitter.DefineLabel(Info)
                 endexp = Emitter.DefineLabel(Info)
 
                 result = m_LeftExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfFalse(Info, loadfalse)
 
                 result = m_RightExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 Emitter.MarkLabel(Info, loadfalse) '
                 Emitter.EmitLoadValue(Info, False) 'Load false value
                 Emitter.EmitBranch(Info, endexp)
 
                 Emitter.MarkLabel(Info, loadtrue)
                 Emitter.EmitLoadValue(Info, True) 'Load true value
 
                 Emitter.MarkLabel(Info, endexp) 'The end of the expression
                
                 If opType = TypeCode.Object Then
                     Emitter.EmitBox(Info, Compiler.TypeCache.System_Boolean)
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="23" endline="70">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim opType As TypeCode = MyBase.OperandTypeCode
 
         ValidateBeforeGenerateCode(Info)
 
         Select Case opType
             Case TypeCode.Boolean, TypeCode.Object
                 If opType = TypeCode.Object Then
                     Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 End If
 
                 Dim loadfalse, loadtrue, endexp As Label
                 loadfalse = Emitter.DefineLabel(Info)
                 loadtrue = Emitter.DefineLabel(Info)
                 endexp = Emitter.DefineLabel(Info)
 
                 result = m_LeftExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfFalse(Info, loadfalse)
 
                 result = m_RightExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 Emitter.MarkLabel(Info, loadfalse) '
                 Emitter.EmitLoadValue(Info, False) 'Load false value
                 Emitter.EmitBranch(Info, endexp)
 
                 Emitter.MarkLabel(Info, loadtrue)
                 Emitter.EmitLoadValue(Info, True) 'Load true value
 
                 Emitter.MarkLabel(Info, endexp) 'The end of the expression
                
                 If opType = TypeCode.Object Then
                     Emitter.EmitBox(Info, Compiler.TypeCache.System_Boolean)
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="31" endline="54">
<![CDATA[
     End Property
 
     Public Function ConvertToByte(ByRef result As Object, ByVal ShowError As Boolean) As Boolean
         Dim tpCode As TypeCode
 
         tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, result))
 
         Select Case tpCode
             Case TypeCode.Boolean, TypeCode.Byte
                 result = CByte(result) 'No range checking needed.
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal
                 If Compiler.TypeResolution.CheckNumericRange(result, result, ExpressionType) = False Then
                     If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30439, Location, Helper.ToString(Expression, ExpressionType))
                     Return False
                 End If
             Case TypeCode.DBNull
                 result = CByte(0)
             Case Else
                 If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30060, Location, result.ToString, Helper.ToString(Expression, ExpressionType))
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Compiler.vb" startline="327" endline="363">
<![CDATA[
 
     Private Function Compile_Parse() As Boolean
         Dim result As Boolean = True
         Dim RootNamespace As String
 
         If CommandLine.RootNamespace = "" Then
             RootNamespace = "" '(IO.Path.GetFileNameWithoutExtension(m_OutFilename))
         Else
             RootNamespace = (CommandLine.RootNamespace)
         End If
 
         m_Scanner = New Scanner(Me)
         'm_ConditionalCompiler = New ConditionalCompiler(Me, m_Scanner)
         m_tm = New tm(Me, m_Scanner)
         m_Parser = New Parser(Me)
 
 
         Try
             theAss = New AssemblyDeclaration(Me)
             result = Parser.Parse(RootNamespace, theAss) AndAlso result
         Catch ex As TooManyErrorsException
             Throw
         Catch ex As vbncException
             Throw
         Catch ex As Exception
             If Token.IsSomething(tm.CurrentToken) Then
                 Report.ShowMessage(Messages.VBNC99999, tm.CurrentLocation, "vbnc crashed nearby this location in the source code.")
             End If
             Throw
         End Try
 
         m_tm = Nothing
 
         VerifyConsistency(result, "Parse")
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\BoundList.vb" startline="65" endline="91">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ConstantExpression IsNot Nothing Then result = m_ConstantExpression.ResolveTypeReferences AndAlso result
 
         If m_TypeName IsNot Nothing Then
             result = m_TypeName.ResolveTypeReferences AndAlso result
             If m_Identifier.HasTypeCharacter Then
                 result = Helper.AddError(Me, "Type character and type name is not allowed")
             End If
         ElseIf m_Identifier.HasTypeCharacter Then
             m_TypeName = New TypeName(Me, TypeCharacters.TypeCharacterToType(Compiler, m_Identifier.TypeCharacter))
         Else
             m_TypeName = New TypeName(Me, m_ConstantExpression.ExpressionType)
         End If
 
         m_FieldBuilderCecil.FieldType = Helper.GetTypeOrTypeReference(Compiler, m_TypeName.ResolvedType)
 
         If Helper.CompareType(m_TypeName.ResolvedType, Compiler.TypeCache.System_Decimal) Then
             m_RequiresSharedInitialization = True
         ElseIf Helper.CompareType(m_TypeName.ResolvedType, Compiler.TypeCache.System_DateTime) Then
             m_RequiresSharedInitialization = True
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\StdToolMgr.vb" startline="537" endline="558">
<![CDATA[
 
     Private Sub lplaypos_MouseMove(ByVal sender As Object, _
     ByVal e As System.Windows.Forms.MouseEventArgs) Handles lplayPos.MouseMove
 
         If mDragOn Then
             mSliderPos = mSliderSrt + e.X - mMousePos
             If mSliderPos <= 0 Then mSliderPos = 0
             If mSliderPos >= lplayPos.Width Then mSliderPos = lplayPos.Width - 3
             Dim gr As Graphics = lplayPos.CreateGraphics
             gr.Clear(Color.Beige)
             gr.DrawImageUnscaled(mBitMap, 0, 0)
             gr.DrawRectangle(mPen, mSliderPos, 2, mSliderW, lplayPos.Height - 6)
         ElseIf mGraphOn Then
             Dim gr As Graphics = lplayPos.CreateGraphics
             gr.Clear(Color.Beige)
             gr.DrawImageUnscaled(mBitMap, 0, 0)
             gr.DrawRectangle(mPen, mSliderPos, 2, mSliderW, lplayPos.Height - 6)
             mPen.Color = Color.Blue
             gr.DrawLine(mPen, e.X, 0, e.X, lplayPos.Height)
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\MainForm.cs" startline="380" endline="417">
<![CDATA[
 
 		private void pm_PresenceNotification(object sender, PresenceNotificationEventArgs e)
 		{
 			string authorizationStatus = "Unauthorized";
 			if(e.KeyFob.IsAuthorized) { authorizationStatus = "Authorized"; }
 
 			switch(e.NotificationType)
 			{
 				case PresenceNotificationType.Discovered
                     notifyIcon.ShowBalloonTip(2,this.Text, String.Format("Discovered {0} KeyFob ({1}).", authorizationStatus, e.KeyFob.SerialNumber), ToolTipIcon.Info);
 					break;
 				case PresenceNotificationType.NotPresent
                     notifyIcon.ShowBalloonTip(2,this.Text, String.Format("{0} KeyFob ({1}) is no longer detected.", authorizationStatus, e.KeyFob.SerialNumber), ToolTipIcon.Info);
 					break;
 				case PresenceNotificationType.Returned
                     notifyIcon.ShowBalloonTip(2,this.Text, String.Format("{0} KeyFob ({1}) has returned.", authorizationStatus, e.KeyFob.SerialNumber), ToolTipIcon.Info);
 					break;
 				case PresenceNotificationType.Heartbeat
 					//TODO
                     notifyIcon.Icon = heartbeatIcon;
 					lastHeartbeatIconChange = DateTime.Now.Ticks;
 					break;
 			}
 
 			if(e.NotificationType != PresenceNotificationType.Heartbeat)
 			{
 				UpdateFobView(this, null);
 			}
 
 			if(e.KeyFob.IsAuthorized &&
 				(e.NotificationType == PresenceNotificationType.Discovered ||
 				e.NotificationType == PresenceNotificationType.Returned))
 			{
 				this.lockingEnabled = true;
 			}
 
 			pluginManager.HandlePresenceNotification(e);
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="160" endline="186">
<![CDATA[
     End Property
 
     Public Overrides Function CreateDefinition() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.CreateDefinition AndAlso result
 
         Helper.Assert(m_CecilBuilder Is Nothing)
         m_CecilBuilder = New Mono.Cecil.PropertyDefinition(Name, 0, Helper.GetTypeOrTypeReference(Compiler, Me.Signature.ReturnType))
         m_CecilBuilder.Annotations.Add(Compiler, Me)
         DeclaringType.CecilType.Properties.Add(m_CecilBuilder)
         m_CecilBuilder.Name = Me.Name
 
         If m_Signature IsNot Nothing Then result = m_Signature.CreateDefinition AndAlso result
 
         If m_Get IsNot Nothing Then
             result = m_Get.CreateDefinition AndAlso result
             m_CecilBuilder.GetMethod = m_Get.CecilBuilder
         End If
 
         If m_Set IsNot Nothing Then
             result = m_Set.CreateDefinition AndAlso result
             m_CecilBuilder.SetMethod = m_Set.CecilBuilder
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="419" endline="426">
<![CDATA[
 
     Function MakeGenericField(ByVal Parent As ParsedObject, ByVal OpenField As Mono.Cecil.FieldReference, ByVal TypeParameters As Mono.Cecil.TypeReference(), ByVal TypeArguments() As Mono.Cecil.TypeReference, ByVal ClosedType As Mono.Cecil.TypeReference) As Mono.Cecil.FieldReference
         Dim result As Mono.Cecil.FieldReference
 
         result = New Mono.Cecil.FieldReference(OpenField.Name, OpenField.FieldType, ClosedType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MyGenerator.vb" startline="82" endline="89">
<![CDATA[
 
     Shared Operator &(ByVal str As String, ByVal ns As [Namespace]) As [Namespace]
         If ns.Global Then
             Throw New InternalException("")
         Else
             Return New [Namespace](ns.Parent, str & "." & ns.ToString, False)
         End If
     End Operator
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\PropertyGroupToPropertyAccessExpression.vb" startline="65" endline="76">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim method As Mono.Cecil.MethodReference
 
         method = CecilHelper.FindDefinition(m_PropertyGroup.ResolvedProperty).GetMethod
         method = CecilHelper.GetCorrectMember(method, m_PropertyGroup.ResolvedProperty.DeclaringType)
 
         result = Helper.EmitArgumentsAndCallOrCallVirt(Info, m_PropertyGroup.InstanceExpression, m_PropertyGroup.Parameters, method) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\RMhandler.vb" startline="36" endline="48">
<![CDATA[
     End Property
 
     Public Sub SaveSetting(ByVal Category As String, ByVal Name As String, ByVal Value As String)
         If mDoc Is Nothing Then Exit Sub
         Try
             Dim CatNode, ValNode As XmlNode
             CatNode = GetOrCreateNode(mDoc.DocumentElement, Category)
             ValNode = GetOrCreateNode(CatNode, Name)
             ValNode.InnerText = Value
         Catch ex As Exception
             'Cannot save setting
         End Try
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="816" endline="829">
<![CDATA[
 
     Private Function GetEscapedIdentifier() As Token
         'EscapedIdentifier  
         Helper.Assert(CurrentChar() = "["c)
         NextChar()
         Dim id As Token
         id = GetIdentifier(True)
         If CurrentChar() = "]"c = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30034, GetCurrentLocation)
         Else
             NextChar()
         End If
         Return id
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="329" endline="353">
<![CDATA[
 
     ''' <summary>
     ''' Load the type into the various lists.
     ''' </summary>
     ''' <param name="Type"></param>
     ''' <remarks></remarks>
     Private Sub LoadType(ByVal Type As Mono.Cecil.TypeDefinition)
         'Add the type to the list of all types.
         Me.Types.Add(Type)
 
         'Add the namespace to the list of all namespaces.
         Me.Namespaces.AddAllNamespaces(Compiler, Type.Namespace, True)
 
         'Add the type to the list of types by namespace.
         m_CecilTypesByNamespace.AddType(Type)
 
         'If it is a module add it to the list of all modules and to the list of modules by namespace.
         If Helper.IsModule(Compiler, Type) Then
             m_CecilModuleTypes.Add(Type)
             m_CecilModulesByNamespace.AddType(Type)
         Else
             Helper.Assert(Type.Annotations(Compiler) Is Nothing OrElse Not TypeOf Type.Annotations(Compiler) Is ModuleDeclaration)
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5199" endline="5222">
<![CDATA[
 
     ''' <summary>
     '''ContinueStatement  
     '''ContinueKind  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseContinueStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As ContinueStatement
         Dim result As New ContinueStatement(Parent)
 
         Dim m_ContinueWhat As KS
 
         tm.AcceptIfNotInternalError(KS.Continue)
         If tm.CurrentToken.Equals(KS.Do, KS.For, KS.While) Then
             m_ContinueWhat = tm.CurrentToken.Keyword
             tm.NextToken()
         Else
             Compiler.Report.ShowMessage(Messages.VBNC30781, tm.CurrentLocation)
             Return Nothing
         End If
 
         result.Init(m_ContinueWhat)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AliasClause.vb" startline="88" endline="101">
<![CDATA[
 
     Function SetElements() As Boolean
         Dim result As Boolean = True
         m_Elements = New Generic.List(Of Integer)
         If m_VariableInitializerList IsNot Nothing Then
             If m_VariableInitializerList.List.ToArray.Length > 0 Then
                 If m_VariableInitializerList.List.ToArray()(0).IsArrayElementInitializer Then
                     m_Elements.AddRange(m_VariableInitializerList.List.ToArray()(0).AsArrayElementInitializer.Elements)
                 End If
                 m_Elements.Insert(0, m_VariableInitializerList.List.ToArray.Length)
             End If
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="82" endline="123">
<![CDATA[
 
     Friend Overloads Function GenerateCode(ByVal Info As EmitInfo, ByVal IsAddHandler As Boolean) As Boolean
         Dim result As Boolean = True
 
         Dim handler As Mono.Cecil.MethodReference
 
         '1 - Load the instance expression of the event (m_Event)
         '    (first argument to the add/remove method - the this pointer)
         '2 - Create the delegate to call when the event is fired.
         '    (second argument to the add/remove method).
         '2.1 - Load the instance expression of the eventhandler (m_EventHandler)
         '      (first argument to the delegate constructor).
         '2.2 - Load the method pointer of the eventhandler (m_EventHandler)
         '      (second argument to the delegate constructor).
         '2.2.1 - Load the instance expression of the eventhandler (m_EventHandler)
         '        (the argument of the load method pointer instruction)
         '2.2.2 - Call the method pointer creation instruction.
         '2.3 - Call the delegate's constructor.
         '3 - Call the add/remove method
 
         Helper.Assert(m_Event.Classification.IsEventAccessClassification)
         Helper.Assert(m_EventHandler.Classification.IsValueClassification)
 
         Dim evt As Mono.Cecil.EventDefinition = CecilHelper.FindDefinition(m_Event.Classification.AsEventAccess.EventInfo)
 
         If IsAddHandler Then
             handler = evt.AddMethod
         Else
             handler = evt.RemoveMethod
         End If
 
         If Helper.IsShared(handler) = False Then
             result = m_Event.Classification.AsEventAccess.GenerateCode(Info) AndAlso result
         End If
         result = m_EventHandler.Classification.GenerateCode(Info.Clone(Me, True, False, m_EventHandler.ExpressionType)) AndAlso result
 
         Helper.Assert(handler IsNot Nothing)
 
         Emitter.EmitCallOrCallVirt(Info, handler)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="344" endline="374">
<![CDATA[
 
     Public Shared Function EmitLateSet(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification) As Boolean
         Dim result As Boolean = True
         Dim arguments As Mono.Cecil.Cil.VariableDefinition = Nothing
 
         'We need to emit a call to LateSet
 
         '1 - the instance expression
         result = LateBoundAccess.InstanceExpression.GenerateCode(Info.Clone(Info.Context, True, False, LateBoundAccess.InstanceExpression.ExpressionType)) AndAlso result
 
         '2 - Type ??? - haven't found an example where this isn't nothing yet
         Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type))
 
         '3 - The member name
         Emitter.EmitLoadValue(Info, LateBoundAccess.Name)
 
         '4 - The arguments
         '5 - ArgumentNames
         EmitArguments(Info, LateBoundAccess, arguments)
 
         '6 - TypeArguments
         If LateBoundAccess.TypeArguments IsNot Nothing Then
             Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, LateBoundAccess.Parent.Location)
         Else
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type_Array))
         End If
 
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_NewLateBinding__LateSet_Object_Type_String_Array_Array_Array)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\dshowUtil.vb" startline="203" endline="229">
<![CDATA[
 
     Public Function UpdateAvailable(ByVal UpdateMsg As String, _
     Optional ByVal VersionAvailable As String = "", _
     Optional ByVal NewAdditions As String = "") As Boolean
         Label2.Text = UpdateMsg
         If Len(VersionAvailable) > 0 Then
             LinkLabel1.Text = mText(2) + VersionAvailable
             Label2.Font = New Font("Arial", 12, FontStyle.Bold)
             Label2.ForeColor = Color.Green
             chkRemind.Visible = True
             If mSettings.GetSetting("Preferences", "VersionIgnored") = VersionAvailable Then
                 chkRemind.Checked = True
             End If
             'tAck.Visible = False
             tAck.Text = "What's New" & vbCrLf & vbCrLf & NewAdditions & vbCrLf & vbCrLf & _
             "Visit the Movica homepage for more details (the link below)"
         Else
             LoadAck()
         End If
         Me.ShowDialog()
         If chkRemind.Checked Then
             mSettings.SaveSetting("Preferences", "VersionIgnored", VersionAvailable)
         Else
             mSettings.SaveSetting("Preferences", "VersionIgnored", "")
         End If
         Return mUpdateRequested
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="239" endline="259">
<![CDATA[
 
     Public Function ConvertToDecimal(ByRef result As Object, ByVal ShowError As Boolean) As Boolean
         Dim tpCode As TypeCode
 
         tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, result))
 
         Select Case tpCode
             Case TypeCode.Boolean, TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Decimal
                 result = CDec(result) 'No range checking needed.
             Case TypeCode.Single, TypeCode.Double, TypeCode.DBNull
                 If Compiler.TypeResolution.CheckNumericRange(result, result, ExpressionType) = False Then
                     If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30439, Expression.Location, ExpressionType.ToString)
                     Return False
                 End If
             Case Else
                 If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30060, Expression.Location, result.ToString, ExpressionType.ToString)
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="82" endline="111">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim startFalse As Label = Emitter.DefineLabel(Info)
         EndLabel = Emitter.DefineLabel(Info)
 
         result = m_Condition.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean)) AndAlso result
 
         Emitter.EmitBranchIfFalse(Info, startFalse)
         'True code
         result = CodeBlock.GenerateCode(Info) AndAlso result
         Emitter.EmitBranch(Info, EndLabel)
 
         'False code
         Emitter.MarkLabel(Info, startFalse)
         If m_ElseIfs IsNot Nothing Then
             For Each eif As ElseIfStatement In m_ElseIfs
                 result = eif.GenerateCode(Info) AndAlso result
             Next
         End If
 
         If m_FalseCode IsNot Nothing Then
             result = m_FalseCode.GenerateCode(Info) AndAlso result
         End If
         Emitter.MarkLabel(Info, EndLabel)
 
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="430" endline="481">
<![CDATA[
 
     Private Function ParseAssemblyDeclaration(ByVal RootNamespace As String, ByVal assembly As AssemblyDeclaration) As Boolean
         Dim result As Boolean = True
 
         Dim iLastLocation As Span
 
         Dim AssemblyAttributes As New Attributes(assembly)
 
         tm.NextToken() 'Goto the first token
 
         Do Until tm.CurrentToken.IsEndOfCode
 #If EXTENDEDDEBUG Then
             Dim iFileCount, iTotalFiles As Integer
             iFileCount += 1
             iTotalFiles = Me.Compiler.CommandLine.Files.Count
             Me.Compiler.Report.WriteLine(Report.ReportLevels.Debug, "Parsing file " & tm.CurrentToken.Location.File.FileName & " (" & iFileCount & " of " & iTotalFiles & " files)")
 #End If
             iLastLocation = tm.CurrentLocation
 
             While tm.AcceptNewLine
 
             End While
             While tm.AcceptNewLine
 
             End While
             '[  OptionStatement+  ]
             '[  ImportsStatement+  ]
 
             If Me.ParseFileHeader(tm.CurrentLocation.File(Compiler), assembly) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             ''	[  AttributesStatement+  ]
             'If vbnc.Attributes.IsMe(tm) Then
             '    If Me.ParseAttributes(result, AssemblyAttributes) = False Then
             '        Helper.ErrorRecoveryNot    Implemented()
             '    End If
             'End If
 
             '	[  NamespaceMemberDeclaration+  ]
             result = ParseAssemblyMembers(assembly, RootNamespace) AndAlso result
 
             While tm.AcceptNewLine
 
             End While
             While tm.AcceptNewLine
 
             End While
             tm.AcceptEndOfFile()
             If iLastLocation.Equals(tm.CurrentLocation) Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC30203, tm.CurrentLocation) AndAlso result
                 tm.GotoNewline(False)
             End If
         Loop
         Do Until tm.CurrentToken.IsEndOfCode
 #If EXTENDEDDEBUG Then
             Dim iFileCount, iTotalFiles As Integer
             iFileCount += 1
             iTotalFiles = Me.Compiler.CommandLine.Files.Count
             Me.Compiler.Report.WriteLine(Report.ReportLevels.Debug, "Parsing file " & tm.CurrentToken.Location.File.FileName & " (" & iFileCount & " of " & iTotalFiles & " files)")
 #End If
             iLastLocation = tm.CurrentLocation
 
             While tm.AcceptNewLine
 
             End While
             '[  OptionStatement+  ]
             '[  ImportsStatement+  ]
 
             If Me.ParseFileHeader(tm.CurrentLocation.File(Compiler), assembly) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             ''	[  AttributesStatement+  ]
             'If vbnc.Attributes.IsMe(tm) Then
             '    If Me.ParseAttributes(result, AssemblyAttributes) = False Then
             '        Helper.ErrorRecoveryNot    Implemented()
             '    End If
             'End If
 
             '	[  NamespaceMemberDeclaration+  ]
             result = ParseAssemblyMembers(assembly, RootNamespace) AndAlso result
 
             While tm.AcceptNewLine
 
             End While
             tm.AcceptEndOfFile()
             If iLastLocation.Equals(tm.CurrentLocation) Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC30203, tm.CurrentLocation) AndAlso result
                 tm.GotoNewline(False)
             End If
         Loop
 
         assembly.Init(AssemblyAttributes)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="257" endline="294">
<![CDATA[
 
     Private Function GenerateUnstructuredStart(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         EndMethodLabel = Emitter.DefineLabel(Info)
         m_InternalExceptionLocation = Emitter.DefineLabel(Info)
         UnstructuredResumeNextHandler = Emitter.DefineLabel(Info)
         UnstructuredResumeHandler = Emitter.DefineLabel(Info)
         UnstructuredSwitchHandlerEnd = Emitter.DefineLabel(Info)
 
         VB_ActiveHandler = Emitter.DeclareLocal(Info, Compiler.TypeCache.System_Int32, "VB$ActiveHandler")
         VB_ActiveHandlerLabel = Emitter.DefineLabel(Info)
         VB_ResumeTarget = Emitter.DeclareLocal(Info, Compiler.TypeCache.System_Int32, "VB$ResumeTarget")
 
         EndUnstructuredExceptionHandler = Emitter.EmitBeginExceptionBlock(Info)
         UnstructuredExceptionLabels = New Generic.List(Of Label)
         UnstructuredExceptionHandlers = New Generic.List(Of Label)
 
         'Handler 0
         UnstructuredExceptionHandlers.Add(m_InternalExceptionLocation)
         UnstructuredExceptionHandlers.Add(UnstructuredResumeNextHandler)
         UnstructuredExceptionHandlers.Add(UnstructuredResumeHandler)
 
         'At entry to the method, the exception-handler location and the exception are both set to Nothing. 
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__ClearProjectError)
 
         UnstructuredExceptionLabels.Add(UnstructuredSwitchHandlerEnd) 'index 0
         If Me.HasResume Then
             VB_CurrentInstruction = Emitter.DeclareLocal(Info, Compiler.TypeCache.System_Int32, "VB$CurrentStatement")
             ResumeNextExceptionHandler = Emitter.DefineLabel(Info)
 
             UnstructuredExceptionLabels.Add(ResumeNextExceptionHandler) 'index 1
         Else
             UnstructuredExceptionLabels.Add(UnstructuredSwitchHandlerEnd) 'index 1
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="267" endline="297">
<![CDATA[
 
     Private Sub ParseElseIf()
         If Not CheckEmtpyStack(Messages.VBNC30014) Then Return
 
         Dim theExpression As New ConditionalExpression(Me)
         Dim expression As Object = Nothing
 
         If m_Current <> KS.ElseIf Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ElseIf'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If theExpression.Parse(expression) = False Then
             EatLine(False)
             Return
         End If
 
         If m_Current = KS.Then Then
             Me.NextUnconditionally()
         End If
 
         ParseEndOfLine()
 
         If m_ConditionStack(m_ConditionStack.Count - 1) = 1 Then
             m_ConditionStack(m_ConditionStack.Count - 1) = -1
         ElseIf m_ConditionStack(m_ConditionStack.Count - 1) = 0 AndAlso CBool(expression) Then
             m_ConditionStack(m_ConditionStack.Count - 1) = 1
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="198" endline="234">
<![CDATA[
 
 #Region "Const"
     Private Sub ParseConst()
         Dim name As String
         Dim value As Object = Nothing
 
         If m_Current <> KS.Const Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Const'")
             Me.EatLine(False)
             Return
         End If
 
         Me.NextUnconditionally()
 
         If m_Current.IsIdentifier = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, m_Current.Location)
             Me.EatLine(False)
             Return
         End If
         name = m_Current.Identifier
         Me.NextUnconditionally()
 
         If m_Current <> KS.Equals Then
             Compiler.Report.ShowMessage(Messages.VBNC30249, m_Current.Location)
             Return
         End If
         Me.NextUnconditionally()
 
         m_Evaluator.Parse(value)
 
         If Me.IfdOut = False Then
             m_CurrentConstants.Add(New ConditionalConstant(name, value))
             GetLocation.File(Compiler).AddConditionalConstants(GetLocation.Line, m_CurrentConstants)
         End If
 
         ParseEndOfLine()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\DotAccessExpression.vb" startline="169" endline="194">
<![CDATA[
 
     Friend NotOverridable Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim constant As Object = Nothing
 
         Try
             If GetConstant(constant, False) Then
                 If Helper.CompareType(Me.ExpressionType, Compiler.TypeCache.Nothing) Then
                     Emitter.EmitLoadValue(Info, constant)
                 ElseIf Info.DesiredType IsNot Nothing AndAlso CecilHelper.IsByRef(Info.DesiredType) Then
                     Emitter.EmitLoadValueAddress(Info, constant)
                 Else
                     Emitter.EmitLoadValue(Info.Clone(Me, Me.ExpressionType), constant)
                 End If
             ElseIf TypeOf Me.Classification Is MethodGroupClassification Then
                 result = Me.Classification.AsMethodGroupClassification.GenerateCode(Info) AndAlso result
             Else
                 result = GenerateCodeInternal(Info) AndAlso result
             End If
         Catch ex As Exception
             Compiler.Report.ShowMessage(Messages.VBNC99999, Me.Location, "Internal compiler error close to this location")
             Throw
         End Try
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\UnaryExpressions\Expressions.vb" startline="34" endline="41">
<![CDATA[
     End Property
 
     Shadows Function ToArray() As Expression()
         Dim result As Expression()
         ReDim result(Count - 1)
         Array.Copy(MyBase.ToArray, result, Count)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\BaseObject.vb" startline="93" endline="105">
<![CDATA[
 
     ''' <summary>
     ''' The location in the source of this object.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     Friend Property Location() As Span Implements IBaseObject.Location
         Get
             If m_Location.HasFile = False AndAlso m_Location.Column = 0 AndAlso m_Location.Line = 0 AndAlso m_Parent IsNot Nothing Then
                 Return m_Parent.Location
             End If
             Return m_Location
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="496" endline="502">
<![CDATA[
 
     Function IsSignedIntegralType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Return Helper.CompareType(Type, Compiler.TypeCache.System_SByte) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_Int16) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_Int32) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_Int64)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="503" endline="509">
<![CDATA[
 
     Function IsUnsignedIntegralType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Return Helper.CompareType(Type, Compiler.TypeCache.System_Byte) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_UInt16) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_UInt32) OrElse _
          Helper.CompareType(Type, Compiler.TypeCache.System_UInt64)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="925" endline="941">
<![CDATA[
 
     ''' <summary>
     ''' Checks if the specified type is a VB Module.
     ''' </summary>
     ''' <param name="type"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function IsModule(ByVal Compiler As Compiler, ByVal type As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean
         Dim annotation As Object = type.Annotations(Compiler)
 
         If annotation IsNot Nothing AndAlso TypeOf annotation Is ModuleDeclaration Then Return True
 
         result = CecilHelper.IsClass(type) AndAlso Compiler.TypeCache.MS_VB_CS_StandardModuleAttribute IsNot Nothing AndAlso CecilHelper.IsDefined(CecilHelper.FindDefinition(type).CustomAttributes, Compiler.TypeCache.MS_VB_CS_StandardModuleAttribute)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5148" endline="5167">
<![CDATA[
 
 
     ''' <summary>
     ''' GotoStatement  
     ''' LabelName 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseGotoStatement(ByVal Parent As ParsedObject) As GotoStatement
         Dim m_GotoWhere As Token
 
         tm.AcceptIfNotInternalError(KS.GoTo)
         If tm.CurrentToken.IsIdentifier OrElse tm.CurrentToken.IsIntegerLiteral Then
             m_GotoWhere = tm.CurrentToken
             tm.NextToken()
         Else
             Return Nothing
         End If
 
         Return New GotoStatement(Parent, m_GotoWhere)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="418" endline="432">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Expression.IsResolved = False Then
             result = m_Expression.ResolveExpression(Info) AndAlso result
         End If
 
         If result = False Then Return result
 
         result = Helper.VerifyValueClassification(m_Expression, Info) AndAlso result
         Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5843" endline="5879">
<![CDATA[
 
     ''' <summary>
     ''' SelectStatement  
     '''	   "Select" [ "Case" ]  Expression  StatementTerminator
     '''	        [  CaseStatement+  ]
     '''	        [  CaseElseStatement  ]
     '''	   "End" "Select" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSelectStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As SelectStatement
         Dim result As New SelectStatement(Parent)
 
         Dim m_Test As Expression
         Dim m_Cases As BaseObjects(Of CaseStatement)
 
         tm.AcceptIfNotInternalError(KS.Select)
 
         tm.Accept(KS.Case) '"Case" is not required
 
         m_Test = ParseExpression(result)
         If m_Test Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Cases = New BaseObjects(Of CaseStatement)(result)
         While tm.CurrentToken = KS.Case
             Dim newCase As CaseStatement
             newCase = ParseCaseStatement(result, IsOneLiner)
             m_Cases.Add(newCase)
         End While
         While tm.CurrentToken = KS.Case
             Dim newCase As CaseStatement
             newCase = ParseCaseStatement(result, IsOneLiner)
             m_Cases.Add(newCase)
         End While
 
         If tm.Accept(KS.End, KS.Select) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Test, m_Cases)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="6558" endline="6600">
<![CDATA[
 
     ''' <summary>
     ''' ModuleDeclaration  
     '''	[  Attributes  ]  [  TypeModifier+  ]  "Module"  Identifier  StatementTerminator
     '''	[  ModuleMemberDeclaration+  ]
     '''	"End" "Module" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseModuleDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As ModuleDeclaration
         Dim result As ModuleDeclaration
 
         Dim m_Modifiers As Modifiers
         Dim m_Name As Identifier
 
         m_Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Module)
 
         m_Name = ParseIdentifier()
         If m_Name Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result = New ModuleDeclaration(Parent, [Namespace], m_Name)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If ParseTypeMembers(result) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Module) = False Then
             tm.GotoNewline(False)
         End If
         If tm.AcceptEndOfStatement(, True) = False Then
             tm.GotoNewline(True)
         End If
 
         If result.CustomAttributes IsNot Nothing Then
             result.CustomAttributes.AddRange(Attributes)
         Else
             result.CustomAttributes = Attributes
         End If
         result.Modifiers = m_Modifiers
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\BoundList.vb" startline="194" endline="226">
<![CDATA[
 
     Public Function DefineConstant() As Boolean
         Dim result As Boolean = True
         Dim constant As Object = Nothing
 
         Helper.Assert(m_TypeName IsNot Nothing)
 
         If m_ConstantExpression Is Nothing Then
             Helper.AddError(Me, "No constant expression.")
             Return False
         End If
 
         result = m_ConstantExpression.ResolveExpression(ResolveInfo.Default(Parent.Compiler)) AndAlso result
 
         If Not GetConstant(constant, True) Then Return False
 
         If m_RequiresSharedInitialization Then
             m_FieldBuilderCecil.Constant = Nothing
         ElseIf constant Is DBNull.Value Then
             m_FieldBuilderCecil.Constant = Nothing
         Else
             m_FieldBuilderCecil.Constant = constant
         End If
         m_FieldBuilderCecil.HasConstant = Not m_RequiresSharedInitialization
 
         If constant IsNot Nothing AndAlso constant IsNot DBNull.Value Then
             CreateConstantAttribute(Compiler, constant, m_FieldBuilderCecil.CustomAttributes)
         End If
 
         m_FieldBuilderCecil.Attributes = Helper.GetAttributes(Compiler, Me)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="166" endline="181">
<![CDATA[
 
     ''' <summary>
     ''' A label to just before the last ret instruction of the method.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property EndOfMethodLabel() As Label
         Get
             If m_EndOfMethodLabel.HasValue Then
                 Return m_EndOfMethodLabel.Value
             Else
                 Helper.Assert(Me IsNot UpmostBlock)
                 Return Me.UpmostBlock.EndOfMethodLabel
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ReturnStatement.vb" startline="79" endline="88">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Catches.ResolveCode(Info) AndAlso result
         If m_FinallyBlock IsNot Nothing Then result = m_FinallyBlock.ResolveCode(Info) AndAlso result
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="105" endline="124">
<![CDATA[
 
 
     ''' <summary>
     ''' Creates an array of the specified type and number of elements (and ranks)
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="arraytype"></param>
     ''' <param name="Elements"></param>
     ''' <remarks></remarks>
     Public Shared Sub EmitArrayCreation(ByVal Info As EmitInfo, ByVal ArrayType As Mono.Cecil.TypeReference, ByVal Elements As Generic.List(Of Integer))
         Dim count As Integer = If(Elements Is Nothing, 0, Elements.Count)
         If count = 0 Then
             Emitter.EmitLoadI4Value(Info, 0)
         Else
             For i As Integer = 0 To Elements.Count - 1
                 Emitter.EmitLoadI4Value(Info, Elements(i))
             Next
         End If
         EmitArrayConstructor(Info, ArrayType, count)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="141" endline="151">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveCode(Info) AndAlso result
         result = MyBase.ResolveCode(info) AndAlso result
 
         Helper.Assert(m_ReturnType IsNot Nothing OrElse Compiler.Report.Errors > 0)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1244" endline="1273">
<![CDATA[
 
     Overloads Shared Function EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As ULong) As Boolean
         Helper.Assert(Info.DesiredType IsNot Nothing)
 
         Dim DesiredTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, Info.DesiredType)
         Dim tmp As EmitInfo = Info
 
         'If Value <= Integer.MaxValue AndAlso Value >= Integer.MinValue Then
         '    Helper.NotImplemented() 'Return EmitLoadValue(Info, CInt(Value))
         'ElseIf Value <= Long.MaxValue AndAlso Value >= Long.MinValue Then
         '    Return EmitLoadValue(Info, CLng(Value))
         'End If
 
         Select Case DesiredTypeCode
             Case TypeCode.Single
                 EmitLoadValue(tmp, CSng(Value))
                 Return True
             Case TypeCode.Double
                 EmitLoadValue(tmp, CDbl(Value))
                 Return True
             Case TypeCode.Decimal
                 EmitLoadValue(tmp, CDec(Value))
                 Return True
             Case TypeCode.Int64, TypeCode.UInt64
                 EmitLoadI8Value(Info, Value)
                 Return True
         End Select
         Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="124" endline="149">
<![CDATA[
     End Property
 
     Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         Dim stn As SimpleTypeName = TryCast(m_TypeName, SimpleTypeName)
         Dim ctn As ConstructedTypeName = TryCast(m_TypeName, ConstructedTypeName)
 
         If stn IsNot Nothing Then
             result = stn.ResolveTypeReferences AndAlso result
             m_ResolvedType = stn.ResolvedType
         ElseIf ctn IsNot Nothing Then
             result = ctn.ResolveTypeReferences AndAlso result
             m_ResolvedType = ctn.ResolvedType
         Else
             Throw New InternalException(Me)
         End If
 
         If m_IsNullable Then
             result = CecilHelper.CreateNullableType(Me, m_ResolvedType, m_ResolvedType) AndAlso result
         End If
 
         Helper.Assert(m_ResolvedType IsNot Nothing OrElse result = False)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="415" endline="440">
<![CDATA[
 
     ReadOnly Property Type() As Mono.Cecil.TypeReference
         Get
             Dim result As Mono.Cecil.TypeReference
             If m_ExpressionType IsNot Nothing Then
                 result = m_ExpressionType
             ElseIf m_Method IsNot Nothing Then
                 result = m_Method.Signature.ReturnType
             ElseIf m_Variable IsNot Nothing Then
                 result = m_Variable.VariableType
             ElseIf m_FieldInfo IsNot Nothing Then
                 If Helper.IsEnum(Compiler, m_FieldInfo.DeclaringType) Then
                     result = m_FieldInfo.DeclaringType
                 Else
                     result = m_FieldInfo.FieldType
                 End If
             ElseIf m_Parameter IsNot Nothing Then
                 result = m_Parameter.ParameterType
             ElseIf m_ArrayVariable IsNot Nothing Then
                 result = CecilHelper.GetElementType(m_ArrayVariable.ExpressionType)
             Else
                 Throw New InternalException(Me)
             End If
             Helper.Assert(result IsNot Nothing)
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2399" endline="2411">
<![CDATA[
 
     Private Function ParseUnaryNotExpression(ByVal Info As ExpressionParseInfo) As UnaryNotExpression
         Dim result As New UnaryNotExpression(Info.Parent)
 
         Dim m_Expression As Expression
         tm.AcceptIfNotInternalError(KS.Not)
 
         m_Expression = ParseComparison(Info)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="132" endline="139">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal EnumVariable As EnumMemberDeclaration)
         MyBase.New(Classifications.Value, Parent)
         Helper.Assert(EnumVariable IsNot Nothing)
         m_EnumVariable = EnumVariable
         m_Type = m_EnumVariable.FindFirstParent(Of EnumDeclaration).EnumConstantType
         Helper.Assert(m_Type IsNot Nothing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4478" endline="4499">
<![CDATA[
 
     ''' <summary>
     ''' HandlesClause  
     ''' LAMESPEC
     ''' HandlesClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseHandlesClause(ByVal Parent As ParsedObject) As HandlesClause
         Dim result As New HandlesClause(Parent)
 
         Dim m_List As New EventHandlesList(result)
 
         tm.AcceptIfNotInternalError(KS.Handles)
 
         If ParseList(Of EventMemberSpecifier)(m_List, New ParseDelegate_Parent(Of EventMemberSpecifier)(AddressOf ParseEventMemberSpecifier), result) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_List)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\MethodGroupToValueExpression.vb" startline="73" endline="87">
<![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveExpression(Info) AndAlso result
 
         If result = False Then Return result
 
         result = Helper.VerifyValueClassification(m_Expression, Info) AndAlso result
 
         Classification = New ValueClassification(Me, Me.ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="427" endline="454">
<![CDATA[
 
     ''' <summary>
     ''' Creates a closed method of an open generic method.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="OpenMethod"></param>
     ''' <param name="TypeParameters"></param>
     ''' <param name="TypeArguments"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function MakeGenericMethod(ByVal Parent As ParsedObject, ByVal OpenMethod As Mono.Cecil.MethodReference, ByVal TypeParameters As Mono.Collections.Generic.Collection(Of TypeReference), ByVal TypeArguments As Mono.Collections.Generic.Collection(Of TypeReference)) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim genM As Mono.Cecil.GenericInstanceMethod
 
         result = CecilHelper.GetCorrectMember(OpenMethod, TypeArguments)
 
         If OpenMethod.GenericParameters.Count = 0 Then Return result
 
         Helper.Assert(OpenMethod.GenericParameters.Count = TypeArguments.Count)
 
         genM = New Mono.Cecil.GenericInstanceMethod(result)
         genM.OriginalMethod = CecilHelper.FindDefinition(OpenMethod)
         For i As Integer = 0 To OpenMethod.GenericParameters.Count - 1
             genM.GenericArguments.Add(Helper.GetTypeOrTypeReference(Parent.Compiler, TypeArguments(i)))
         Next
 
         Return genM
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AliasClause.vb" startline="222" endline="238">
<![CDATA[
 
     Shared Function GetAddressMethod(ByVal Compiler As Compiler, ByVal ArrayType As Mono.Cecil.TypeReference) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
         Dim ranks As Integer = CecilHelper.GetArrayRank(ArrayType)
         Dim methodtypes As Mono.Cecil.TypeReference() = Helper.CreateArray(Of Mono.Cecil.TypeReference)(Compiler.TypeCache.System_Int32, ranks)
 
         ArrayType = Helper.GetTypeOrTypeBuilder(Compiler, ArrayType)
         elementType = Helper.GetTypeOrTypeBuilder(Compiler, elementType)
         result = New Mono.Cecil.MethodReference("Address", ArrayType, CecilHelper.MakeByRefType(elementType), True, False, Mono.Cecil.MethodCallingConvention.Default)
 
         For i As Integer = 1 To ranks
             result.Parameters.Add(New Mono.Cecil.ParameterDefinition(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Int32)))
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4983" endline="5004">
<![CDATA[
 
     Private Function ParseInterfacePropertyMemberDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As InterfacePropertyMemberDeclaration
         Dim result As New InterfacePropertyMemberDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As FunctionSignature = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.InterfacePropertyModifier)
 
         tm.AcceptIfNotInternalError(KS.Property)
 
         m_Signature = ParseFunctionSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         result.Signature = m_Signature
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, Nothing)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmAuto.vb" startline="154" endline="175">
<![CDATA[
 
     Private Function ServiceStatus(ByVal Name As String) As String
 
         Try
             SrvcCntrl.ServiceName = (Name)
             Dim ChkSrvc As Boolean = SrvcCntrl.CanPauseAndContinue
         Catch ex As InvalidOperationException
             ServiceStatus = (Name & "
             Exit Function
         End Try
 
         If Service_Startup(Name) = 2 Then
             ServiceStatus = (SrvcCntrl.DisplayName & "
         ElseIf Service_Startup(Name) = 3 Then
             ServiceStatus = (SrvcCntrl.DisplayName & "
         ElseIf Service_Startup(Name) = 4 Then
             ServiceStatus = (SrvcCntrl.DisplayName & "
         Else
             ServiceStatus = (SrvcCntrl.DisplayName & "
         End If
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="1382" endline="1401">
<![CDATA[
 
     Public Shared Function AreSame(ByVal a As TypeReference, ByVal b As TypeReference) As Boolean
         While TypeOf a Is TypeSpecification OrElse TypeOf b Is TypeSpecification
             If a.GetType IsNot b.GetType Then
                 Return False
             End If
             a = DirectCast(a, TypeSpecification).ElementType
             b = DirectCast(b, TypeSpecification).ElementType
         End While
         While TypeOf a Is TypeSpecification OrElse TypeOf b Is TypeSpecification
             If a.GetType IsNot b.GetType Then
                 Return False
             End If
             a = DirectCast(a, TypeSpecification).ElementType
             b = DirectCast(b, TypeSpecification).ElementType
         End While
         If TypeOf a Is GenericParameter OrElse TypeOf b Is GenericParameter Then
             If a.GetType IsNot b.GetType Then
                 Return False
             End If
             Dim pa As GenericParameter = DirectCast(a, GenericParameter)
             Dim pb As GenericParameter = DirectCast(b, GenericParameter)
 
             Return pa.Position = pb.Position
         End If
         Return Helper.CompareNameOrdinal(a.FullName, b.FullName)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="298" endline="317">
<![CDATA[
 
     Public Function ConvertToString(ByRef result As Object, ByVal ShowError As Boolean) As Boolean
         Dim tpCode As TypeCode
 
         If result Is Nothing Then Return True
 
         tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, result))
 
         Select Case tpCode
             Case TypeCode.Char, TypeCode.String
                 result = CStr(result)
             Case TypeCode.DBNull
                 result = DBNull.Value
             Case Else
                 If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30060, Location, result.ToString, Helper.ToString(Expression, ExpressionType))
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="912" endline="934">
<![CDATA[
 
     Private Sub Profile_Diagnostics(ByVal Name As String, ByVal Setting As String)
 
         Try
             SrvcCntrl.ServiceName = (Name)
             Dim ChkSrvc As Boolean = SrvcCntrl.CanPauseAndContinue
         Catch ex As InvalidOperationException
             Exit Sub
         End Try
 
         If My.Settings(Setting) = 1 Then
             If SrvcCntrl.Status = ServiceProcess.ServiceControllerStatus.Running And Service_Startup(Name) = 2 Then
             Else
                 Problem = CByte(Problem + 1)
             End If
         ElseIf My.Settings(Setting) = 2 Then
             If Service_Startup(Name) = 3 OrElse Service_Startup(Name) = 4 Then
             Else
                 Problem = CByte(Problem + 1)
             End If
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="217" endline="228">
<![CDATA[
 
     Private Function BeginExceptionBlockCecil() As Mono.Cecil.Cil.Instruction
         Log("BeginExceptionBlock")
         Dim block As New TryBlock
         CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Nop)
         block.Start = CilBody.Instructions.Count
         block.EndBlock = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         If m_ExceptionBlocks Is Nothing Then m_ExceptionBlocks = New Generic.Stack(Of TryBlock)
         m_ExceptionBlocks.Push(block)
         CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Nop)
         Return block.EndBlock
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\MainForm.cs" startline="294" endline="309">
<![CDATA[
 
 		private void SetupPluginContextMenu()
 		{
 			//view context menu
 			pluginListViewContextMenu = new ContextMenu();
 			configurePluginMenuItem = new MenuItem("Configure Plugin");
 			enablePluginMenuItem = new MenuItem("Enabled");
 			
 			configurePluginMenuItem.Click += new EventHandler(configurePluginMenuItem_Click);
 			enablePluginMenuItem.Click += new EventHandler(enablePluginMenuItem_Click);
             pluginListViewContextMenu.Popup += new EventHandler(pluginListViewContextMenu_Popup);
 			
 			pluginListViewContextMenu.MenuItems.Add(configurePluginMenuItem);
 			pluginListViewContextMenu.MenuItems.Add(enablePluginMenuItem);
 			pluginListView.ContextMenu = pluginListViewContextMenu;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="80" endline="108">
<![CDATA[
 
     Sub NextToken()
         If m_RestorePoints > 0 Then
             m_CurrentIndex += 1
             Helper.Assert(m_CurrentIndex <= m_TokenList.Count)
             If m_CurrentIndex = m_TokenList.Count Then
                 Current = m_Reader.Next
                 m_TokenList.Add(Current)
             Else
                 Current = m_TokenList(m_CurrentIndex)
             End If
         ElseIf m_TokenList.Count > 0 Then
             'Peeked items.
             m_CurrentIndex += 1
             Helper.Assert(m_CurrentIndex <= m_TokenList.Count)
             If m_CurrentIndex = m_TokenList.Count Then
 #If DEBUG Then
                 'Console.WriteLine("Reached a total of " & m_TokenList.Count.ToString & " tokens in restorable list")
 #End If
                 Current = m_Reader.Next
                 m_TokenList.Clear()
                 m_CurrentIndex = 0
             Else
                 Current = m_TokenList(m_CurrentIndex)
             End If
         Else
             Current = m_Reader.Next()
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmProfiles.vb" startline="38" endline="64">
<![CDATA[
 
     Private Sub FrmProfiles_KeyDown(ByVal sender As Object, ByVal e As System.Windows.Forms.KeyEventArgs) Handles Me.KeyDown
 
         If e.KeyData = Keys.F5 Then
             Call Check_Profiles()
             e.Handled = True
         ElseIf e.Control And e.KeyCode = Keys.P Then
             BtnPreview.PerformClick()
             e.Handled = True
         ElseIf e.Control And e.KeyCode = Keys.A Then
             BtnApply.PerformClick()
             e.Handled = True
         ElseIf e.Control And e.KeyCode = Keys.V Then
             BtnValidate.PerformClick()
             e.Handled = True
         ElseIf e.Control And e.KeyCode = Keys.E Then
             BtnEdit.PerformClick()
             e.Handled = True
         ElseIf e.KeyData = Keys.Delete Then
             BtnDelete.PerformClick()
             e.Handled = True
         ElseIf e.Control And e.KeyCode = Keys.I Then
             BtnImport.PerformClick()
             e.Handled = True
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmSrvcMngr.vb" startline="55" endline="81">
<![CDATA[
 
     Private Sub FrmSrvcMngr_KeyDown(ByVal sender As Object, ByVal e As System.Windows.Forms.KeyEventArgs) Handles Me.KeyDown
 
         If e.KeyData = Keys.F5 Then
             Call Load_Services()
             e.Handled = True
         ElseIf e.Control And e.KeyCode = Keys.A Then
             BtnStart.PerformClick()
             e.Handled = True
         ElseIf e.Control And e.KeyCode = Keys.O Then
             BtnStop.PerformClick()
             e.Handled = True
         ElseIf e.KeyData = Keys.Delete Then
             BtnDelete.PerformClick()
             e.Handled = True
         ElseIf e.Control And e.KeyCode = Keys.S Then
             BtnSearch.PerformClick()
             e.Handled = True
         ElseIf e.Control And e.KeyCode = Keys.E Then
             BtnExport.PerformClick()
             e.Handled = True
         ElseIf e.Control And e.KeyCode = Keys.C Then
             BtnSnapshot.PerformClick()
             e.Handled = True
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="23" endline="70">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim opType As TypeCode = MyBase.OperandTypeCode
 
         ValidateBeforeGenerateCode(Info)
 
         Select Case opType
             Case TypeCode.Boolean, TypeCode.Object
                 If opType = TypeCode.Object Then
                     Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 End If
 
                 Dim loadfalse, loadtrue, endexp As Label
                 loadfalse = Emitter.DefineLabel(Info)
                 loadtrue = Emitter.DefineLabel(Info)
                 endexp = Emitter.DefineLabel(Info)
 
                 result = m_LeftExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfFalse(Info, loadfalse)
 
                 result = m_RightExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 Emitter.MarkLabel(Info, loadfalse) '
                 Emitter.EmitLoadValue(Info, False) 'Load false value
                 Emitter.EmitBranch(Info, endexp)
 
                 Emitter.MarkLabel(Info, loadtrue)
                 Emitter.EmitLoadValue(Info, True) 'Load true value
 
                 Emitter.MarkLabel(Info, endexp) 'The end of the expression
                
                 If opType = TypeCode.Object Then
                     Emitter.EmitBox(Info, Compiler.TypeCache.System_Boolean)
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MemberCache.vb" startline="93" endline="128">
<![CDATA[
 #End If
 
     Public Sub ClearAll()
         Dim tG As Mono.Cecil.GenericParameter
 
         If m_Types Is Nothing Then
             m_Types = New List(Of Mono.Cecil.TypeReference)
         Else
             m_Types.Clear()
         End If
 
         tG = TryCast(m_Type, Mono.Cecil.GenericParameter)
         If tG IsNot Nothing Then
             If tG.Constraints.Count = 0 Then
                 m_Types.Add(Compiler.TypeCache.System_Object)
             Else
                 m_Types.AddRange(tG.Constraints)
             End If
         Else
             m_Types.Add(m_Type)
         End If
 
         If m_Members Is Nothing Then
             m_Members = New List(Of Mono.Collections.Generic.Collection(Of MemberReference))
         Else
             m_Members.Clear()
         End If
         For i As Integer = 0 To m_Types.Count - 1
             m_Members.Add(CecilHelper.GetMembers(m_Types(i)))
         Next
 
         For i As Integer = 0 To MemberVisibility.All - 1
             Clear(CType(i, MemberVisibility))
         Next
         m_Bases = Nothing
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\InterfaceDeclaration.vb" startline="60" endline="75">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_InterfaceBases IsNot Nothing Then
             result = m_InterfaceBases.ResolveTypeReferences AndAlso result
             For i As Integer = 0 To m_InterfaceBases.Bases.Length - 1
                 AddInterface(m_InterfaceBases.Bases(i).ResolvedType)
             Next
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\MRUbuffer.vb" startline="24" endline="32">
<![CDATA[
 
     Public ReadOnly Property List() As String()
         Get
             If mLen = 0 Then Return Nothing
             Dim Temp(mLen - 1) As String
             Array.Copy(mList, Temp, mLen)
             Array.Sort(Temp)
             Return Temp
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="52" endline="61">
<![CDATA[
     End Property
 
     Public Overrides ReadOnly Property AsString() As String
         Get
             If m_TypeArgumentList Is Nothing OrElse m_TypeArgumentList.Count = 0 Then
                 Return m_Identifier.Identifier
             Else
                 Return m_Identifier.Identifier & "(Of <type arguments>)"
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\CaseRangeExpression.vb" startline="50" endline="66">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Loads the instance expression onto the evaluation stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_InstanceExpression IsNot Nothing Then
             result = m_InstanceExpression.GenerateCode(Info.Clone(Parent, True, False, m_InstanceExpression.ExpressionType)) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="260" endline="272">
<![CDATA[
 
     Public Function ConvertToDate(ByRef result As Object, ByVal ShowError As Boolean) As Boolean
         Dim tpCode As TypeCode
 
         tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, result))
 
         If Not TypeOf result Is Date Then
             If ShowError Then Show30059()
             Return False
         End If
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\MPGhandler.vb" startline="63" endline="69">
<![CDATA[
 
     Friend Overloads Overrides Sub ShowInfo(ByVal Filenames As String())
         If mIsAudio Then SafeHarborMsg()
         For i As Integer = 0 To UBound(Filenames)
             RunConverter("-i " + Chr(34) + Filenames(i) + Chr(34))
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="129" endline="147">
<![CDATA[
 
     ''' <summary>
     ''' This creates the variable.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Declaration IsNot Nothing Then
             result = m_Declaration.DefineLocalVariable(Info) AndAlso result
             result = m_Declaration.GenerateCode(Info) AndAlso result
         Else
             'm_LoopVariableBuilder()
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\CustomEventDeclaration.vb" startline="54" endline="67">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Type IsNot Nothing Then
             result = m_Type.ResolveTypeReferences AndAlso result
             EventType = m_Type.ResolvedType
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="148" endline="158">
<![CDATA[
 
     ReadOnly Property VariableType() As Mono.Cecil.TypeReference
         Get
             If m_Expression IsNot Nothing Then
                 Return m_Expression.ExpressionType
             ElseIf m_TypeName IsNot Nothing Then
                 Return m_TypeName.ResolvedType
             Else
                 Return m_Declaration.VariableType
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\CaseClauses.vb" startline="96" endline="106">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Clauses IsNot Nothing Then
             result = m_Clauses.ResolveStatements(Info) AndAlso result
         End If
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" startline="190" endline="201">
<![CDATA[
     End Property
 
     Public Overrides Function CreateDefinition() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.CreateDefinition AndAlso result
 
         TypeAttributes = Helper.getTypeAttributeScopeFromScope(Modifiers, IsNestedType) Or Mono.Cecil.TypeAttributes.Sealed
         If m_Signature IsNot Nothing Then result = m_Signature.CreateDefinition AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\SubSignature.vb" startline="149" endline="160">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_ParameterList IsNot Nothing)
 
         result = m_ParameterList.ResolveCode(info) AndAlso result
         If m_TypeParameters IsNot Nothing Then result = m_TypeParameters.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4565" endline="4590">
<![CDATA[
 
     ''' <summary>
     ''' InterfaceFunctionDeclaration  
     '''	[  Attributes  ]  [  InterfaceProcedureModifier+  ] "Function" FunctionSignature  StatementTerminator
     '''
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInterfaceFunctionDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As InterfaceFunctionDeclaration
         Dim result As New InterfaceFunctionDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As FunctionSignature = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.InterfaceProcedureModifiers)
 
         tm.AcceptIfNotInternalError(KS.Function)
 
         m_Signature = ParseFunctionSignature(result)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4241" endline="4259">
<![CDATA[
 
     Overloads Shared Function ToString(ByVal Context As BaseObject, ByVal Member As Mono.Cecil.MemberReference) As String
         Dim methodReference As MethodReference
         Dim propertyReference As PropertyReference
         Dim typeReference As TypeReference
 
         methodReference = TryCast(Member, MethodReference)
         If methodReference IsNot Nothing Then Return ToString(Context, methodReference)
 
         propertyReference = TryCast(Member, PropertyReference)
         If propertyReference IsNot Nothing Then Return ToString(Context, propertyReference)
 
         typeReference = TryCast(Member, TypeReference)
         If typeReference IsNot Nothing Then Return ToString(Context, DirectCast(Member, TypeReference))
 
         Context.Compiler.Report.ShowMessage(Messages.VBNC99997, Context.Location)
 
         Return String.Empty
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="469" endline="490">
<![CDATA[
 
     Private Function ResolveReclassifyToValueThenIndex() As Boolean
         Dim result As Boolean = True
         Dim tmpExp As Expression
         Dim oldExp As Expression
 
         tmpExp = m_Expression.ReclassifyToValueExpression
         result = tmpExp.ResolveExpression(ResolveInfo.Default(Parent.Compiler)) AndAlso result
 
         If result = False Then
             Helper.AddError(Me)
             Return False
         End If
 
         oldExp = m_Expression
         m_Expression = tmpExp
         result = ResolveIndexInvocation(Me, m_Expression.ExpressionType) AndAlso result
 
         Helper.StopIfDebugging(result = False)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="292" endline="313">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         result = m_Signature.ResolveTypeReferences AndAlso result
         If result = False Then Return result
 
         ReturnType = m_Signature.ReturnType
 
         If m_Code IsNot Nothing Then result = m_Code.ResolveTypeReferences AndAlso result
 
         If IsExternalDeclaration Then
             MethodImplAttributes = Mono.Cecil.MethodImplAttributes.IL Or Mono.Cecil.MethodImplAttributes.PreserveSig
         Else
             MethodImplAttributes = Mono.Cecil.MethodImplAttributes.IL
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="149" endline="174">
<![CDATA[
 
     ''' <summary>
     ''' OptionStrictStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOptionInferStatement(ByVal Parent As BaseObject) As OptionInferStatement
         Dim result As New OptionInferStatement(Parent)
 
         Dim m_Off As Boolean
 
         tm.AcceptIfNotInternalError(KS.Option)
         tm.AcceptIfNotInternalError("Infer")
 
         If tm.Accept(KS.On) Then
             m_Off = False
         ElseIf tm.Accept("Off") Then
             m_Off = True
         ElseIf Not tm.AcceptEndOfStatement() Then
             Compiler.Report.ShowMessage(Messages.VBNC30620, tm.CurrentLocation)
             tm.GotoNewline(False)
         End If
 
         result.Init(m_Off)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="175" endline="201">
<![CDATA[
 
 
     ''' <summary>
     ''' OptionStrictStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOptionStrictStatement(ByVal Parent As BaseObject) As OptionStrictStatement
         Dim result As New OptionStrictStatement(Parent)
 
         Dim m_Off As Boolean
 
         tm.AcceptIfNotInternalError(KS.Option)
         tm.AcceptIfNotInternalError("Strict")
 
         If tm.Accept(KS.On) Then
             m_Off = False
         ElseIf tm.Accept("Off") Then
             m_Off = True
         ElseIf Not tm.AcceptEndOfStatement() Then
             Compiler.Report.ShowMessage(Messages.VBNC30620, tm.CurrentLocation)
             tm.GotoNewline(False)
         End If
 
         result.Init(m_Off)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="202" endline="225">
<![CDATA[
 
     ''' <summary>
     ''' OptionExplicitStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOptionExplicitStatement(ByVal Parent As BaseObject) As OptionExplicitStatement
         Dim result As New OptionExplicitStatement(Parent)
 
         Dim m_Off As Boolean
         tm.AcceptIfNotInternalError(KS.Option)
         tm.AcceptIfNotInternalError("Explicit")
 
         If tm.Accept(KS.On) Then
             m_Off = False
         ElseIf tm.Accept("Off") Then
             m_Off = True
         ElseIf Not tm.AcceptEndOfStatement() Then
             Compiler.Report.ShowMessage(Messages.VBNC30640, tm.CurrentLocation)
             tm.GotoNewline(False)
         End If
 
         result.Init(m_Off)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\MainForm.cs" startline="235" endline="269">
<![CDATA[
         }
 
 		private void SetupNotifyIcon()
 		{
 			appIcon = new Icon(typeof(MainForm), "usbwirelessecurity.ico");
             heartbeatIcon = new Icon(typeof(MainForm), "usbwirelessecurity_hot.ico");
 			notifyIcon.Icon = appIcon;
 			notifyIcon.Visible = true;
 			notifyIcon.Text = this.Text;
 			this.Icon = appIcon;
 			
 			notifyIcon.Click += new EventHandler(notifyIcon_Click);
 			notifyIcon.DoubleClick += new EventHandler(notifyIcon_DoubleClick);
 
 			//context menu
 			MenuItem exitItem = new MenuItem();
 			exitItem.Text = "Exit";
 			exitItem.Click += new EventHandler(exitItem_Click);
 
             MenuItem aboutItem = new MenuItem();
             aboutItem.Text = "About...";
             aboutItem.Click += new EventHandler(aboutItem_Click);
 
             MenuItem restoreItem = new MenuItem();
             restoreItem.Text = "Restore";
             restoreItem.DefaultItem = true;
             restoreItem.Click += new EventHandler(restoreItem_Click);
 
             contextMenu = new ContextMenu();
             contextMenu.MenuItems.Add(restoreItem);
             contextMenu.MenuItems.Add(aboutItem);
             contextMenu.MenuItems.Add(exitItem);
 
 			notifyIcon.ContextMenu = contextMenu;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\DotAccessExpression.vb" startline="415" endline="458">
<![CDATA[
 
     ''' <summary>
     ''' Reclassifies an expression.
     ''' The resulting expression is NOT resolved.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function ReclassifyToValueExpression() As Expression
         Dim result As Expression = Nothing
         Select Case m_Classification.Classification
             Case ExpressionClassification.Classifications.Value
                 Return Me 'This expression is already a value expression.
             Case ExpressionClassification.Classifications.Variable
                 result = New VariableToValueExpression(Me, Me.Classification.AsVariableClassification)
             Case ExpressionClassification.Classifications.MethodGroup
                 result = New MethodGroupToValueExpression(Me, Me.Classification.AsMethodGroupClassification)
             Case ExpressionClassification.Classifications.PropertyAccess
                 result = New PropertyAccessToValueExpression(Me, Me.Classification.AsPropertyAccess)
             Case ExpressionClassification.Classifications.PropertyGroup
                 result = New PropertyGroupToValueExpression(Me, Me.Classification.AsPropertyGroup)
             Case ExpressionClassification.Classifications.LateBoundAccess
                 result = New LateBoundAccessToValueExpression(Me, Me.Classification.AsLateBoundAccess)
             Case ExpressionClassification.Classifications.MethodPointer
                 Throw New InternalException(Me, "Use the other overload.")
             Case ExpressionClassification.Classifications.EventAccess
                 Throw New InternalException(Me)
             Case ExpressionClassification.Classifications.Void
                 Compiler.Report.ShowMessage(Messages.VBNC30491, Me.Location)
                 Return Nothing
             Case ExpressionClassification.Classifications.Type
                 Dim exp As Expression = Nothing
                 If m_Classification.AsTypeClassification.CreateAliasExpression(Me, exp) = False Then
                     Throw New InternalException(Me)
                 End If
                 Return exp
             Case ExpressionClassification.Classifications.Namespace
                 Throw New InternalException(Me)
             Case Else
                 Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                 Return Nothing
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5648" endline="5691">
<![CDATA[
 
     ''' <summary>
     '''TryStatement  
     '''	"Try" StatementTerminator
     '''	   [  Block  ]
     '''	[  CatchStatement+  ]
     '''	[  FinallyStatement  ]
     '''	"End" "Try" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTryStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As TryStatement
         Dim result As New TryStatement(Parent)
 
         Dim m_TryCode As CodeBlock
         Dim m_FinallyBlock As CodeBlock
         Dim m_Catches As BaseObjects(Of CatchStatement)
 
         tm.AcceptIfNotInternalError(KS.Try)
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_TryCode = ParseCodeBlock(result, IsOneLiner)
         If m_TryCode Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Catches = New BaseObjects(Of CatchStatement)(result)
         While tm.CurrentToken = KS.Catch
             Dim newCatch As CatchStatement
             newCatch = ParseCatchStatement(result, IsOneLiner)
             m_Catches.Add(newCatch)
         End While
         While tm.CurrentToken = KS.Catch
             Dim newCatch As CatchStatement
             newCatch = ParseCatchStatement(result, IsOneLiner)
             m_Catches.Add(newCatch)
         End While
 
         If tm.Accept(KS.Finally) Then
             If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             m_FinallyBlock = ParseCodeBlock(result, IsOneLiner)
             If m_FinallyBlock Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_FinallyBlock = Nothing
         End If
 
         If tm.Accept(KS.End, KS.Try) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Catches, m_TryCode, m_FinallyBlock)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="117" endline="150">
<![CDATA[
 
     Public Overrides Function CreateDefinition() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.CreateDefinition AndAlso result
 
         If m_CecilType IsNot Nothing Then
             'This may happen with partial types
             Return result
         End If
 
         If Me.IsNestedType Then
             m_CecilType = New Mono.Cecil.TypeDefinition(Nothing, Me.Name, 0)
         Else
             m_CecilType = New Mono.Cecil.TypeDefinition(Me.Namespace, Me.Name, 0)
         End If
         m_CecilType.Annotations.Add(Compiler, Me)
         m_CecilType.Name = Name
         m_CecilType.Attributes = Helper.getTypeAttributeScopeFromScope(Modifiers, IsNestedType)
 
         If IsNestedType Then
             DeclaringType.CecilType.NestedTypes.Add(m_CecilType)
             m_CecilType.DeclaringType = DeclaringType.CecilType
         Else
             Compiler.ModuleBuilderCecil.Types.Add(m_CecilType)
         End If
 
         'create definitions for all members
         For i As Integer = 0 To Members.Count - 1
             result = Members(i).CreateDefinition() AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\MethodGroupToValueExpression.vb" startline="34" endline="70">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim arguments As ArgumentList = New ArgumentList(Me.Parent)
 
         If m_MethodGroup.Resolved = False Then
             result = m_MethodGroup.ResolveGroup(arguments) AndAlso result
         Else
             'm_FinalArguments = m_MethodGroup.
         End If
 
         If result = False Then
             result = m_MethodGroup.ResolveGroup(arguments, True) AndAlso result
             Return False
         End If
 
         Helper.Assert(m_MethodGroup.ResolvedMethod IsNot Nothing)
 
         If m_MethodGroup.ResolvedMethodInfo IsNot Nothing Then
             m_ExpressionType = m_MethodGroup.ResolvedMethodInfo.ReturnType
         ElseIf m_MethodGroup.ResolvedConstructor IsNot Nothing Then
             m_ExpressionType = m_MethodGroup.ResolvedConstructor.DeclaringType
         Else
             Throw New InternalException(Me)
         End If
 
         result = m_ExpressionType IsNot Nothing AndAlso result
 
         If Helper.CompareType(Compiler.TypeCache.System_Void, m_ExpressionType) Then
             Me.Classification = New VoidClassification(Me)
             result = ReportReclassifyToValueErrorMessage()
         Else
             Me.Classification = New ValueClassification(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\PropertyGroupToPropertyAccessExpression.vb" startline="30" endline="59">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_PropertyGroup IsNot Nothing, "m_PropertyGroup Is Nothing")
 
         If m_PropertyGroup.IsResolved = False OrElse m_PropertyGroup.ResolvedProperty Is Nothing Then
             result = m_PropertyGroup.ResolveGroup(New ArgumentList(Me)) AndAlso result
 
             If result = False Then
                 Compiler.Report.WriteLine("Property group resolution failed (unrecoverably), showing log")
                 Helper.LOGMETHODRESOLUTION = True
                 m_PropertyGroup.ResolveGroup(New ArgumentList(Me))
                 Return Helper.AddError(Me, "Failed to resolve property group.")
             End If
 
             If m_PropertyGroup.InstanceExpression Is Nothing AndAlso CecilHelper.IsStatic(m_PropertyGroup.ResolvedProperty) = False Then
                 Return Report.ShowMessage(Messages.VBNC30469, Me.Location)
             End If
         End If
 
         Helper.Assert(m_PropertyGroup.ResolvedProperty IsNot Nothing, "m_PropertyGroup.ResolvedProperty Is Nothing")
         m_ExpressionType = m_PropertyGroup.ResolvedProperty.PropertyType
 
         result = m_ExpressionType IsNot Nothing AndAlso result
 
         Me.Classification = New PropertyAccessClassification(Me, m_PropertyGroup.ResolvedProperty, m_PropertyGroup.InstanceExpression, m_PropertyGroup.Parameters)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="893" endline="924">
<![CDATA[
 
     Private Function SetClassificationOfModuleMembers(ByVal found As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)) As Boolean
         If found Is Nothing OrElse found.Count <= 0 Then
             Return False
         End If
 
         If Helper.IsMethodDeclaration(found(0)) Then
             Classification = New MethodGroupClassification(Me, Nothing, m_TypeArgumentList, Nothing, found)
             Return True
         End If
         If found.Count > 1 Then
             Return Helper.AddError(Me)
         End If
         If Helper.IsTypeDeclaration(found(0)) Then
             Classification = New TypeClassification(Me, found(0))
             Return True
         End If
         Dim first As Mono.Cecil.MemberReference = found(0)
         If Helper.IsFieldDeclaration(first) Then
             Dim var As Mono.Cecil.FieldReference = DirectCast(first, Mono.Cecil.FieldReference)
             Helper.Assert(Parent.FindFirstParent(Of EnumDeclaration)() Is Nothing)
 
             Classification = New VariableClassification(Me, var, Nothing)
             Return True
         End If
         If Helper.IsPropertyDeclaration(first) Then
             Classification = New PropertyGroupClassification(Me, Nothing, found)
             Return True
         End If
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\dshowUtil.vb" startline="243" endline="278">
<![CDATA[
 
     Public Overloads Overrides Function Split(ByVal Filename As String, _
     ByVal Pieces As Short, Optional ByVal MediaDuration As Double = 0) As Boolean
         MyBase.Split(Filename, Pieces)
 
         If Pieces < 2 Then Exit Function
         If MediaDuration = 0 Then Exit Function
 
         Dim Temp As Segment
         Dim Duration As Double = MediaDuration / Pieces
         Filename = AddDefaultPathIfNeeded(StripExtension(Filename))
 
         ReDim mSegments(Pieces - 1)
         For i As Integer = 0 To Pieces - 1
             Temp = New Segment
             Temp.Start = i * Duration
             Temp.Finish = Math.Min((i + 1) * Duration, MediaDuration)
             mSegments(i) = Temp
         Next
 
         mOutFile = Filename
         CreatePieces(False)
 
         Try
             Threading.Thread.Sleep(1000)
             Dim di As New IO.DirectoryInfo(GetDefaultDir)
             If di.GetFiles(StripPath(StripExtension(Filename)) & "*").Length >= Pieces Then
                 Return True
             Else
                 Return False
             End If
         Catch ex As Exception
             'Some disk exception
         End Try
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\OnErrorStatement.vb" startline="54" endline="90">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim parent As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
         Dim lastparent As CodeBlock = parent.FindFirstParent(Of CodeBlock)()
         Do Until lastparent Is Nothing
             parent = lastparent
             lastparent = parent.FindFirstParent(Of CodeBlock)()
         Loop
         Do Until lastparent Is Nothing
             parent = lastparent
             lastparent = parent.FindFirstParent(Of CodeBlock)()
         Loop
 
         If m_IsGotoMinusOne Then
             Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__ClearProjectError)
         ElseIf m_IsGotoZero Then
             Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__ClearProjectError)
             Emitter.EmitLoadI4Value(Info, 0)
             Emitter.EmitStoreVariable(Info, parent.VB_ActiveHandler)
         ElseIf m_IsResumeNext Then
             Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__ClearProjectError)
             Emitter.EmitLoadI4Value(Info, parent.UnstructuredExceptionHandlers.IndexOf(parent.UnstructuredResumeNextHandler)) 'Load the index of the switch table, 1 = resume next handler.
             Emitter.EmitStoreVariable(Info, parent.VB_ActiveHandler)
         Else
             Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__ClearProjectError)
             Dim index As Integer
             If parent.UnstructuredExceptionHandlers.Contains(m_ResolvedLabel.GetLabel(Info)) = False Then
                 parent.UnstructuredExceptionHandlers.Add(m_ResolvedLabel.GetLabel(Info))
             End If
             index = parent.UnstructuredExceptionHandlers.IndexOf(m_ResolvedLabel.GetLabel(Info))
             Emitter.EmitLoadI4Value(Info, index)
             Emitter.EmitStoreVariable(Info, parent.VB_ActiveHandler)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\TryCastExpression.vb" startline="93" endline="126">
<![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_IsDelegateCreationExpression Then
             result = m_ArgumentList(0).Expression.Classification.AsMethodPointerClassification.GenerateCode(Info) AndAlso result
         ElseIf m_IsValueTypeInitializer Then
             If CecilHelper.IsByRef(Info.DesiredType) Then
                 Dim type As Mono.Cecil.TypeReference = Helper.GetTypeOrTypeBuilder(Compiler, m_ResolvedType)
                 Emitter.EmitInitObj(Info, type)
             Else
                 Dim type As Mono.Cecil.TypeReference = Helper.GetTypeOrTypeBuilder(Compiler, m_ResolvedType)
                 Dim local As Mono.Cecil.Cil.VariableDefinition = Emitter.DeclareLocal(Info, type)
                 Emitter.EmitLoadVariableLocation(Info, local)
                 Emitter.EmitInitObj(Info, type)
                 Emitter.EmitLoadVariable(Info, local)
             End If
         ElseIf m_IsGenericConstructor Then
             Dim method As Mono.Cecil.MethodReference
             Dim args As Mono.Cecil.TypeReference() = New Mono.Cecil.TypeReference() {Helper.GetTypeOrTypeBuilder(Compiler, ExpressionType)}
             method = CecilHelper.MakeGenericMethod(Compiler.TypeCache.System_Activator__CreateInstance, args)
             Emitter.EmitCall(Info, method)
         Else
             Dim ctor As Mono.Cecil.MethodReference
             ctor = m_MethodClassification.ResolvedConstructor
 
             result = m_ArgumentList.GenerateCode(Info, ctor.Parameters) AndAlso result
 
             Emitter.EmitNew(Info, ctor)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\AboutBox.cs" startline="14" endline="20">
<![CDATA[
         {
             if (disposing && (components != null))
             {
                 components.Dispose();
             }
             base.Dispose(disposing);
         }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\AbstractMediaHandler.vb" startline="15" endline="21">
<![CDATA[
     End Property
 
     Sub New()
     Protected mList As New ArrayList
     Protected mDoc As New Xml.XmlDocument
     Protected mDshowList As New dshowUtil
 
     Private Tools() As ToolSpec
 
     Public ReadOnly Property ToolList() As ArrayList
         Get
             Return mList
         End Get
     End Property
 
     Sub New()
         mDoc.LoadXml(My.Resources.ToolsMetadata)
         FromXML(mDoc.DocumentElement)
         FromSettings()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\StdToolMgr.vb" startline="193" endline="203">
<![CDATA[
 
     Private Sub PositionSliders()
 
         'Adjust width of bar
         grpBar.Width = Me.Width - 6
         Dim Factor As Double = grpBar.Width / (mMax - mMin)
 
         'Move left pointer
         picSlider.Left = CInt((mValue * Factor) + grpBar.Left - (picSlider.Width / 2))
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="381" endline="438">
<![CDATA[
 
     ''' <summary>
     ''' Resolve this group with the specified parameters.
     ''' </summary>
     ''' <param name="SourceParameters"></param>
     ''' <remarks></remarks>
     Function ResolveGroup(ByVal SourceParameters As ArgumentList, Optional ByVal ShowErrors As Boolean = False, Optional ByVal CanBeLateBound As Boolean = True) As Boolean
         Dim result As Boolean = True
         Dim FinalSourceArguments As ArgumentList = Nothing
 
         If SourceParameters Is Nothing Then Throw New InternalException("SourceParameters is nothing.")
         If Resolved Then
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Method group is beeing resolved more than once.")
         End If
         If m_Group.Count <= 0 Then Throw New InternalException("Nothing to resolve...")
 
         Dim resolvedGroup As New Generic.List(Of Mono.Cecil.MemberReference)
 
         If m_Resolver Is Nothing Then m_Resolver = New MethodResolver(Parent)
         m_Resolver.CanBeLateBound = CanBeLateBound
         m_Resolver.ShowErrors = ShowErrors
         m_Resolver.Init(m_Group, SourceParameters, m_TypeArguments)
         result = m_Resolver.Resolve AndAlso result
 
         If result Then
             If m_Resolver.IsLateBound = False Then
                 FinalSourceArguments = New ArgumentList(Me.Parent, m_Resolver.ResolvedCandidate.ExactArguments)
                 resolvedGroup.Add(m_Resolver.ResolvedMember)
             End If
         End If
 
         'result = Helper.ResolveGroup(Me.Parent, m_Group, resolvedGroup, SourceParameters, TypeArguments, FinalSourceArguments, ShowErrors) AndAlso result
 
         If result Then
             m_Group = resolvedGroup
             m_Resolved = True
             If IsLateBound = False AndAlso Helper.IsShared(ResolvedMethod) Then
                 'Helper.StopIfDebugging(m_InstanceExpression IsNot Nothing AndAlso TypeOf m_InstanceExpression Is MeExpression = False)
                 m_InstanceExpression = Nothing
             End If
 #If EXTENDEDDEBUG Then
         Else
             'Don't stop here since method resolution might fail correctly.
             Compiler.Report.WriteLine("")
             Compiler.Report.WriteLine(".......Method resolution failed, showing log.......")
             Dim tmp As Boolean = Helper.LOGMETHODRESOLUTION
             Helper.LOGMETHODRESOLUTION = True
             resolvedGroup.Clear()
             result = Helper.ResolveGroup(Me.Parent, m_Group, resolvedGroup, SourceParameters, TypeArguments, FinalSourceArguments) AndAlso result
             Helper.LOGMETHODRESOLUTION = tmp
             Compiler.Report.WriteLine("...................................................")
 #End If
         End If
 
         m_FinalArguments = FinalSourceArguments
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\MainForm.cs" startline="473" endline="479">
<![CDATA[
 
 		private void Form1_Closing(object sender, CancelEventArgs e)
 		{
 			pm.Stop();
 			notifyIcon.Dispose();
 			notifyIcon = null;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="100" endline="106">
<![CDATA[
 
     Public Sub AddCustomAttribute(ByVal Attribute As Attribute)
         If m_CustomAttributes Is Nothing Then
             m_CustomAttributes = New Attributes(Me)
         End If
         m_CustomAttributes.Add(Attribute)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3429" endline="3443">
<![CDATA[
 
 #End Region
 
 #Region "   Utility and Worker Functions "
 
     Private Sub JumpItem(ByVal lvControl As ListView, _
         ByVal Item As ListViewItem, ByVal Jump2Pos As Integer)
 
         With lvControl
             Dim TempItem As ListViewItem = DirectCast(Item.Clone, ListViewItem)
             .Items.Insert(Jump2Pos, TempItem)
             .Items.Remove(Item)
         End With
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="853" endline="859">
<![CDATA[
     End Property
 
     ReadOnly Property ParamArrayExpression() As ArrayCreationExpression
         Get
             If IsParamArray = False Then Return Nothing
             Return DirectCast(m_ExactArguments(m_ExactArguments.Count - 1).Expression, ArrayCreationExpression)
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="710" endline="732">
<![CDATA[
 
     ''' <summary>
     ''' Eat all characters until the newline character(s). Optionally eat the newline character(s) as well
     ''' </summary>
     ''' <param name="NewLineCharAlso"></param>
     ''' <remarks></remarks>
     Private Sub EatLine(ByVal NewLineCharAlso As Boolean)
         'LineTerminator 
         '  < Unicode carriage return character (0x000D) > |
         '  < Unicode line feed character (0x000A) > |
         '  < Unicode carriage return character > < Unicode line feed character > |
         '  < Unicode line separator character (0x2028) > |
         '  < Unicode paragraph separator character (0x2029) >
 
         Dim ch As Char = m_CurrentChar
         Do Until IsNewLine(ch)
             ch = NextChar()
         Loop
         Do Until IsNewLine(ch)
             ch = NextChar()
         Loop
 
         If NewLineCharAlso Then
             EatNewLine()
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="4454" endline="4460">
<![CDATA[
 
     Private Sub MyWaveFormCallback(ByVal framesDone As Integer, ByVal framesTotal As Integer, _
     ByVal elapsedTime As TimeSpan, ByVal finished As Boolean)
         If Not mAudioWF Is Nothing Then
             picAudioSumm.BackgroundImage = mAudioWF.CreateBitmap(picAudioSumm.Width, picAudioSumm.Height, -1, -1, False)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MyGenerator.vb" startline="132" endline="140">
<![CDATA[
 
     Shared Function RemoveGlobal(ByVal ns As String) As String
         If IsGlobal(ns) Then
             Return ns.Substring(7)
         Else
             Helper.Assert(ns.StartsWith("Global.", Helper.StringComparison) = False)
             Return ns
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="59" endline="72">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_TypeName.ResolveTypeReferences AndAlso result
         'Not necessary.'result = m_ArrayTypeModifiers.ResolveCode AndAlso result
 
         Dim tp As Mono.Cecil.TypeReference = m_TypeName.ResolvedType
         tp = m_ArrayTypeModifiers.CreateArrayType(tp)
         m_ResolvedType = tp
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5223" endline="5244">
<![CDATA[
 
     ''' <summary>
     ''' EraseStatement  
     ''' EraseExpressions  
     '''	  Expression  |
     '''	  EraseExpressions  ,  Expression
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEraseStatement(ByVal Parent As ParsedObject) As EraseStatement
         Dim result As New EraseStatement(Parent)
 
         Dim m_Targets As ExpressionList
 
         tm.AcceptIfNotInternalError(KS.Erase)
 
         m_Targets = ParseExpressionList(Parent)
         If m_Targets Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Targets)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="702" endline="726">
<![CDATA[
 
     ''' <summary>
     ''' AttributeArgumentExpression  
     '''   ConstantExpression  |
     '''   GetTypeExpression  |
     '''   ArrayCreationExpression
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributeArgumentExpression(ByVal Parent As ParsedObject) As AttributeArgumentExpression
         Dim result As New AttributeArgumentExpression(Parent)
 
         Dim m_Expression As Expression
 
         If tm.CurrentToken = KS.GetType Then
             m_Expression = ParseGetTypeExpression(result)
         ElseIf tm.CurrentToken = KS.[New] Then
             m_Expression = ParseArrayCreationExpression(result)
         Else
             m_Expression = ParseExpression(result)
         End If
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeArgumentList.vb" startline="32" endline="42">
<![CDATA[
 
     ReadOnly Property ArgumentCollection() As Mono.Collections.Generic.Collection(Of TypeReference)
         Get
             If m_ArgumentCollection Is Nothing Then
                 m_ArgumentCollection = New Mono.Collections.Generic.Collection(Of TypeReference)()
                 For i As Integer = 0 To Count - 1
                     m_ArgumentCollection.Add(Item(i).ResolvedType)
                 Next
             End If
             Return m_ArgumentCollection
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\AssignStatements\CompoundAssignmentStatement.vb" startline="30" endline="41">
<![CDATA[
 
     Private Function CheckIndexedStatement(ByVal Info As ResolveInfo, ByVal InvocationExpression As InvocationOrIndexExpression) As Boolean
         Dim result As Boolean = True
 
         If InvocationExpression Is Nothing Then Return result
 
         If InvocationExpression.Classification.IsVariableClassification AndAlso CecilHelper.IsArray(InvocationExpression.Expression.ExpressionType) Then
             result = ResolveIndexedStatement(Info, InvocationExpression) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="958" endline="973">
<![CDATA[
 
     Private Sub Essential_Diagnostics(ByVal Name As String)
 
         Try
             SrvcCntrl.ServiceName = (Name)
             Dim ChkSrvc As Boolean = SrvcCntrl.CanPauseAndContinue
         Catch ex As InvalidOperationException
             Exit Sub
         End Try
 
         If SrvcCntrl.Status = ServiceProcess.ServiceControllerStatus.Running And Service_Startup(Name) = 2 Then
         Else
             Problem = CByte(Problem + 1)
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\TryCastExpression.vb" startline="44" endline="54">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_NonArrayTypeName IsNot Nothing Then
             result = m_NonArrayTypeName.ResolveTypeReferences AndAlso result
             m_ResolvedType = m_NonArrayTypeName.ResolvedType
         End If
         If m_ArgumentList IsNot Nothing Then result = m_ArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="220" endline="229">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
         If m_Get IsNot Nothing Then result = m_Get.ResolveCode(Info) AndAlso result
         If m_Set IsNot Nothing Then result = m_Set.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="230" endline="240">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Get IsNot Nothing Then result = m_Get.GenerateCode(Info) AndAlso result
         If m_Set IsNot Nothing Then result = m_Set.GenerateCode(Info) AndAlso result
 
         result = MyBase.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2780" endline="2790">
<![CDATA[
 
     Shared Function DoesTypeImplementInterface(ByVal Context As BaseObject, ByVal Type As Mono.Cecil.TypeReference, ByVal [Interface] As Mono.Cecil.TypeReference) As Boolean
         Dim ifaces As Mono.Collections.Generic.Collection(Of TypeReference)
         ifaces = CecilHelper.GetInterfaces(Type, True)
         For Each iface As Mono.Cecil.TypeReference In ifaces
             'If Helper.IsAssignable(Context, iface, [Interface]) Then Return True
             If Helper.CompareType(iface, [Interface]) Then Return True
             If DoesTypeImplementInterface(Context, iface, [Interface]) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2330" endline="2352">
<![CDATA[
 
     ''' <summary>
     ''' ParenthesizedExpression  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseParenthesizedExpression(ByVal Parent As ParsedObject) As ParenthesizedExpression
         Dim result As New ParenthesizedExpression(Parent)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.LParenthesis)
 
         m_Expression = ParseExpression(result)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         End If
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\OperatorDeclaration.vb" startline="212" endline="224">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveCode(Info) AndAlso result
         If m_CustomAttributes IsNot Nothing Then result = m_CustomAttributes.ResolveCode(Info) AndAlso result
 
         If m_ConstantExpression IsNot Nothing Then
             result = m_ConstantExpression.ResolveExpression(Info) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="928" endline="952">
<![CDATA[
 
     ''' <summary>
     ''' InterfaceBase   
     ''' InterfaceBases  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInterfaceBases(ByVal Parent As ParsedObject) As InterfaceBases
         Dim result As New InterfaceBases(Parent)
         Dim tmp As New Generic.List(Of NonArrayTypeName)
 
         Do While tm.Accept(KS.Inherits)
             Do
                 Dim newBase As NonArrayTypeName
                 newBase = ParseNonArrayTypeName(result)
                 tmp.Add(newBase)
             Loop While tm.Accept(KS.Comma)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Loop
         Do While tm.Accept(KS.Inherits)
             Do
                 Dim newBase As NonArrayTypeName
                 newBase = ParseNonArrayTypeName(result)
                 tmp.Add(newBase)
             Loop While tm.Accept(KS.Comma)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Loop
 
         If tmp.Count <= 0 Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(tmp.ToArray)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ReturnStatement.vb" startline="57" endline="78">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         EndLabel = Emitter.EmitBeginExceptionBlock(Info)
 
         result = CodeBlock.GenerateCode(Info) AndAlso result
 
         For i As Integer = 0 To m_Catches.Count - 1
             Dim catchstmt As CatchStatement = m_Catches(i)
             result = catchstmt.GenerateCode(Info) AndAlso result
         Next
 
         If m_FinallyBlock IsNot Nothing Then
             Info.ILGen.BeginFinallyBlock()
             result = m_FinallyBlock.GenerateCode(Info) AndAlso result
         End If
 
         Info.ILGen.EndExceptionBlock()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4213" endline="4240">
<![CDATA[
 
     ''' <summary>
     ''' EnumMemberDeclaration  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEnumMemberDeclaration(ByVal Parent As ParsedObject, ByVal Info As ParseAttributableInfo, ByVal EnumIndex As Integer) As EnumMemberDeclaration
         Dim result As New EnumMemberDeclaration(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_ConstantExpression As Expression
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Equals) Then
             m_ConstantExpression = ParseExpression(result)
             If m_ConstantExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_ConstantExpression = Nothing
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(EnumIndex, m_Identifier, m_ConstantExpression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="117" endline="135">
<![CDATA[
     End Property
 
     Protected Overridable Function ResolveExpressions(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_LeftExpression.ResolveExpression(Info) AndAlso result
         result = m_RightExpression.ResolveExpression(Info) AndAlso result
 
         If result = False Then Return False
 
         If m_LeftExpression.Classification.IsValueClassification = False Then
             result = Helper.VerifyValueClassification(m_LeftExpression, Info) AndAlso result
         End If
 
         If m_RightExpression.Classification.IsValueClassification = False Then
             result = Helper.VerifyValueClassification(m_RightExpression, Info) AndAlso result
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="935" endline="957">
<![CDATA[
 
     Private Sub MediaCntr_Diagnostics(ByVal Name As String, ByVal Setting As String)
 
         Try
             SrvcCntrl.ServiceName = (Name)
             Dim ChkSrvc As Boolean = SrvcCntrl.CanPauseAndContinue
         Catch ex As InvalidOperationException
             Exit Sub
         End Try
 
         If My.Settings(Setting) = 1 Then
             If Service_Startup(Name) = 2 Then
             Else
                 Problem = CByte(Problem + 1)
             End If
         ElseIf My.Settings(Setting) = 2 Then
             If Service_Startup(Name) = 3 OrElse Service_Startup(Name) = 4 Then
             Else
                 Problem = CByte(Problem + 1)
             End If
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="835" endline="865">
<![CDATA[
 
     Shared Sub EmitCall(ByVal Info As EmitInfo, ByVal Method As Mono.Cecil.MethodReference)
         Dim OriginalMethod As Mono.Cecil.MethodReference = Method
 
         Helper.Assert(Method IsNot Nothing, "The method Is Nothing")
 
         Dim minfo As Mono.Cecil.MethodReference
         Dim mD As Mono.Cecil.MethodDefinition
 
         minfo = SwitchVersionedMethods(Info, Method)
         minfo = Helper.GetMethodOrMethodReference(Info.Compiler, minfo)
 
         If minfo.OriginalMethod Is Nothing Then
             minfo.OriginalMethod = Method.OriginalMethod
         End If
 
         mD = CecilHelper.FindDefinition(minfo)
 
         minfo = CecilHelper.MakeEmittable(minfo)
 
         If mD Is Nothing Then
             Info.ILGen.Emit(OpCodes.Callvirt, minfo)
         ElseIf mD.IsStatic Then
             Info.ILGen.Emit(OpCodes.Call, minfo)
         ElseIf CecilHelper.IsValueType(Method.DeclaringType) Then
             Info.ILGen.Emit(OpCodes.Call, minfo)
         Else
             Info.ILGen.Emit(OpCodes.Call, minfo)
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="149" endline="168">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Helper.Assert(VariableType IsNot Nothing)
 
         If Me.GeneratedCode = False Then
             If IsLocalVariable Then
                 If m_LocalBuilder Is Nothing Then result = DefineLocalVariable(Info) AndAlso result
                 Helper.Assert(m_LocalBuilder IsNot Nothing)
                 result = EmitVariableInitializer(Info) AndAlso result
             ElseIf Me.Modifiers.Is(ModifierMasks.Static) Then
                 result = DefineField() AndAlso result
                 result = EmitStaticInitializer(Info) AndAlso result
             End If
 
             result = MyBase.GenerateCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="73" endline="86">
<![CDATA[
 
     Overloads Function GenerateCode(ByVal Info As EmitInfo, ByVal Destination As Mono.Cecil.ParameterDefinition) As Boolean
         Dim result As Boolean = True
 
         If m_Expression IsNot Nothing Then
             result = m_Expression.GenerateCode(Info) AndAlso result
         Else
             Helper.Assert(Destination IsNot Nothing)
             Helper.Assert(Destination.IsOptional)
             Emitter.EmitLoadValue(Info, Destination.Constant)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="146" endline="177">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim ArrayType As Mono.Cecil.TypeReference = Helper.GetTypeOrTypeBuilder(Compiler, ExpressionType())
         Dim tmpVar As Mono.Cecil.Cil.VariableDefinition = Emitter.DeclareLocal(Info, ArrayType)
 
         If m_ArrayNameModifier Is Nothing OrElse m_ArrayNameModifier.IsArrayTypeModifiers Then
             EmitArrayCreation(Info, ArrayType, m_ArrayElementInitializer.Elements)
         ElseIf m_ArrayNameModifier.IsArraySizeInitializationModifier Then
             EmitArrayCreation(Me, Info, ArrayType, m_ArrayNameModifier.AsArraySizeInitializationModifier)
         Else
             Throw New InternalException(Me)
         End If
 
         Emitter.EmitStoreVariable(Info, tmpVar)
 
         If m_ArrayElementInitializer IsNot Nothing AndAlso m_ArrayElementInitializer.Initializers IsNot Nothing Then
             With m_ArrayElementInitializer.Initializers
                 Dim indices As New Generic.List(Of Integer)
                 For i As Integer = 0 To .List.ToArray.GetUpperBound(0)
                     indices.Add(i)
                     result = EmitElementInitializer(Info, .List.ToArray()(i), 1, i, tmpVar, ArrayType, indices) AndAlso result
                     indices.RemoveAt(indices.Count - 1)
                 Next
             End With
         End If
 
         Emitter.EmitLoadVariable(Info, tmpVar)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="318" endline="349">
<![CDATA[
 
     Private Function ResolveIndexInvocation(ByVal Context As ParsedObject, ByVal VariableType As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean = True
         Dim Compiler As Compiler = Context.Compiler
 
         Dim defaultProperties As Mono.Collections.Generic.Collection(Of Mono.Cecil.PropertyReference) = Nothing
 
         If CecilHelper.IsArray(VariableType) Then
             result = ResolveArrayInvocation(Context, VariableType) AndAlso result
         ElseIf Helper.CompareType(VariableType, Compiler.TypeCache.System_Array) Then
             result = ResolveLateBoundArrayInvocation(Context) AndAlso result
         ElseIf Helper.IsDelegate(Compiler, VariableType) Then
             'This is an invocation expression (the classification can be reclassified as value and the expression is a delegate expression)
             result = ResolveDelegateInvocation(Context, VariableType)
         ElseIf Helper.HasDefaultProperty(Me, VariableType, defaultProperties) Then
             Dim propGroup As New PropertyGroupClassification(Me, m_Expression, defaultProperties)
             result = propGroup.ResolveGroup(m_ArgumentList)
             If result Then
                 m_ArgumentList.ReplaceAndVerifyArguments(propGroup.FinalArguments, propGroup.ResolvedProperty, True)
             End If
             Classification = New PropertyAccessClassification(propGroup)
             'Classification = propGroup
         ElseIf Helper.CompareType(VariableType, Compiler.TypeCache.System_Object) Then
             Dim lbaClass As New LateBoundAccessClassification(Me, m_Expression, Nothing, Nothing)
             lbaClass.Arguments = m_ArgumentList
             Classification = lbaClass
         Else
             result = Compiler.Report.ShowMessage(Messages.VBNC30471, Location) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\OperatorDeclaration.vb" startline="173" endline="211">
<![CDATA[
     End Property
 
     Public Overrides Function CreateDefinition() As Boolean
         Dim result As Boolean = True
         Dim Parent As MethodBaseDeclaration = FindFirstParent(Of MethodBaseDeclaration)()
         Dim Builder As Mono.Cecil.MethodDefinition = Nothing
 
         result = MyBase.CreateDefinition AndAlso result
 
         If Parent IsNot Nothing Then
             Builder = Parent.CecilBuilder
         Else
             'Helper.StopIfDebugging()
         End If
 
         Helper.Assert(m_ParameterBuilderCecil Is Nothing)
         m_ParameterBuilderCecil = New Mono.Cecil.ParameterDefinition(Nothing)
         m_ParameterBuilderCecil.Sequence = -1
         m_ParameterBuilderCecil.Annotations.Add(Compiler, Me)
         m_ParameterBuilderCecil.ParameterType = Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Void)
 
         m_ParameterBuilderCecil.Name = Name
         m_ParameterBuilderCecil.IsOptional = Modifiers.Is(ModifierMasks.Optional)
 
         If Builder IsNot Nothing AndAlso m_ParameterBuilderCecil.Sequence = -1 Then
             Builder.Parameters.Add(m_ParameterBuilderCecil)
         End If
 
         If Me.Modifiers.Is(ModifierMasks.ParamArray) AndAlso m_ParamArrayAttribute Is Nothing Then
             m_ParamArrayAttribute = New Mono.Cecil.CustomAttribute(Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_ParamArrayAttribute__ctor))
             m_ParameterBuilderCecil.CustomAttributes.Add(m_ParamArrayAttribute)
         End If
 
         If m_ParameterBuilderCecil.IsOptional Then
             m_ParameterBuilderCecil.HasDefault = True
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="248" endline="279">
<![CDATA[
 
     Protected MustOverride Sub EmitThisIfNecessary(ByVal Info As EmitInfo)
     Protected MustOverride Sub EmitStore(ByVal Info As EmitInfo)
 
     Function EmitVariableInitializer(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim varType As Mono.Cecil.TypeReference = VariableType
 
         If m_VariableInitializer IsNot Nothing Then
             EmitThisIfNecessary(Info)
             result = m_VariableInitializer.GenerateCode(Info.Clone(Me, True, False, varType)) AndAlso result
 
             If m_VariableInitializer.InitializerExpression IsNot Nothing AndAlso Helper.CompareType(varType, Compiler.TypeCache.System_Object) AndAlso Helper.CompareType(m_VariableInitializer.ExpressionType, Compiler.TypeCache.System_Object) Then
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
             End If
             EmitStore(Info)
         ElseIf m_IsNew Then
             Helper.Assert(m_NewExpression IsNot Nothing)
             EmitThisIfNecessary(Info)
             result = m_NewExpression.GenerateCode(Info.Clone(Me, True, False, varType)) AndAlso result
             EmitStore(Info)
         End If
 
         If m_VariableIdentifier IsNot Nothing AndAlso m_VariableIdentifier.ArrayNameModifier IsNot Nothing AndAlso m_VariableIdentifier.ArrayNameModifier.IsArraySizeInitializationModifier Then
             EmitThisIfNecessary(Info)
             ArrayCreationExpression.EmitArrayCreation(Me, Info, varType, m_VariableIdentifier.ArrayNameModifier.AsArraySizeInitializationModifier)
             EmitStore(Info)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CodeFiles.vb" startline="775" endline="784">
<![CDATA[
     End Property
 
 #End Region
 
     ReadOnly Property AllArgumentsAsArray() As String()
         Get
             Dim result(m_lstAllArgs.Count - 1) As String
             m_lstAllArgs.CopyTo(result, 0)
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="74" endline="82">
<![CDATA[
     End Property
 
     Private Overloads Shared Function ToString(ByVal obj As Object) As String
         If obj Is Nothing Then
             Return "Nothing"
         Else
             Return "Type
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2322" endline="2328">
<![CDATA[
 
     Private Sub PlayAllSelected()
         If lvPositions.Items.Count = 0 Then Exit Sub
         ReDim mPlaySegments(0)
         mPlaySegments = GetSegmentArray(AbstractMediaHandler.Mode.SaveSelected)
         PlaySelectedSegments()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2329" endline="2335">
<![CDATA[
 
     Private Sub PlayAllNotSelected()
         If lvPositions.Items.Count = 0 Then Exit Sub
         ReDim mPlaySegments(0)
         mPlaySegments = GetSegmentArray(AbstractMediaHandler.Mode.DeleteSelected)
         PlaySelectedSegments()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\InterfaceDeclaration.vb" startline="36" endline="45">
<![CDATA[
 
 
     Public Overrides Function CreateDefinition() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.CreateDefinition AndAlso result
         TypeAttributes = Helper.getTypeAttributeScopeFromScope(Modifiers, IsNestedType) Or Mono.Cecil.TypeAttributes.Interface Or Mono.Cecil.TypeAttributes.Abstract
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2189" endline="2195">
<![CDATA[
 
     <Diagnostics.DebuggerHidden()> Shared Function AddError(ByVal Context As BaseObject, Optional ByVal Message As String = Nothing) As Boolean
         If Message Is Nothing Then
             Message = "<no message written yet>"
         End If
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC99999, Context.Location, Message)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3" endline="10">
<![CDATA[
     Public Sub ShowList(ByVal List() As String)
         Array.Sort(List)
         tList.Text = Join(List, vbCrLf)
         tList.SelectionStart = 0
         tList.SelectionLength = 0
         Me.Text = mTranslator.LangText(113) & " [" & CStr(List.Length) & " filters]"
         Me.ShowDialog()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Compiler.vb" startline="124" endline="136">
<![CDATA[
     End Property
 
     Public Sub VerifyConsistency(ByVal result As Boolean, ByVal where As String)
         'Console.WriteLine("Verifying consistency
         If Report.Errors = 0 AndAlso result = False Then
             Report.WriteLine(vbnc.Report.ReportLevels.Debug, where & "
             Helper.StopIfDebugging()
             Throw New InternalException("Consistency check failed")
         ElseIf Report.Errors > 0 AndAlso result Then
             'Report.WriteLine(vbnc.Report.ReportLevels.Debug, Report.Errors.ToString & " errors, but compilation succeeded? " & Location)
             'Throw New InternalException("Consistency check failed")
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\PositionalArgument.vb" startline="58" endline="69">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim propD As Mono.Cecil.PropertyDefinition = CecilHelper.FindDefinition(m_PropertyAccess.ResolvedProperty)
         Dim methodD As Mono.Cecil.MethodReference = propD.GetMethod
         Dim methodR As Mono.Cecil.MethodReference = CecilHelper.GetCorrectMember(methodD, m_PropertyAccess.ResolvedProperty.DeclaringType, True)
         Dim methodE As Mono.Cecil.MethodReference = Helper.GetMethodOrMethodReference(Compiler, methodR)
 
         result = Helper.EmitArgumentsAndCallOrCallVirt(Info, m_PropertyAccess.InstanceExpression, m_PropertyAccess.Parameters, methodE) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\OnErrorStatement.vb" startline="91" endline="109">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Dim block As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
         block.HasUnstructuredExceptionHandling = True
         If m_IsResumeNext Then block.HasResume = True
         If block.HasStructuredExceptionHandling Then
             Helper.AddError(Me, "No structured exception handling in the same method.")
         End If
 
         If Token.IsSomething(m_Label) Then
             block = Me.FindFirstParent(Of CodeBlock)()
             m_ResolvedLabel = block.FindLabel(m_Label)
             Compiler.Helper.AddCheck("Label must exist.")
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="483" endline="500">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Accept(ByVal Special1 As KS, ByVal Special2 As KS, Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.Equals(Special1) AndAlso PeekToken.Equals(Special2) Then
             NextToken()
             NextToken()
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Return False
         End If
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="6128" endline="6148">
<![CDATA[
 
     ''' <summary>
     ''' ImportsStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseImportsStatement(ByVal Parent As ParsedObject) As ImportsStatement
         Dim result As New ImportsStatement(Parent)
 
         Dim m_Clauses As ImportsClauses
 
         tm.AcceptIfNotInternalError(KS.Imports)
 
         m_Clauses = ParseImportsClauses(result)
         If m_Clauses Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Clauses)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="1697" endline="1708">
<![CDATA[
 
     Sub SelectOutputArguments()
         If IsParamArray Then
             Dim ace As ArrayCreationExpression
             ace = ParamArrayExpression ' TryCast(OutputArguments.Item(OutputArguments.Count - 1).Expression, ArrayCreationExpression)
             If ace IsNot Nothing AndAlso ace.IsResolved = False AndAlso Helper.IsParamArrayParameter(Compiler, InputParameters(InputParameters.Count - 1)) Then
                 If ace.ResolveExpression(ResolveInfo.Default(Compiler)) = False Then
                     Helper.ErrorRecoveryNotImplemented(Parent.Location)
                 End If
             End If
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5070" endline="5097">
<![CDATA[
 
     ''' <summary>
     ''' RedimStatement  
     ''' RedimClauses  
     '''	   RedimClause  |
     '''	   RedimClauses  ","  RedimClause
     ''' RedimClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseReDimStatement(ByVal Parent As ParsedObject) As ReDimStatement
         Dim result As New ReDimStatement(Parent)
 
         Dim m_IsPreserve As Boolean
         Dim m_Clauses As RedimClauses
 
         tm.AcceptIfNotInternalError(KS.ReDim)
         If tm.CurrentToken.Equals("Preserve") Then
             m_IsPreserve = True
             tm.NextToken()
         End If
 
         m_Clauses = ParseRedimClauses(result)
         If m_Clauses Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_IsPreserve, m_Clauses)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="301" endline="316">
<![CDATA[
 
     Private Sub AddKeyword(ByVal keyword As String, ByVal ks As KS)
         Dim list As Generic.List(Of KW) = Nothing
         Dim kw As New KW()
         kw.KeywordL = keyword.ToLowerInvariant()
         kw.KS = ks
 
         If Not m_Keywords(keyword.Length - 2).TryGetValue(keyword(0), list) Then
             list = New Generic.List(Of KW)
             m_Keywords(keyword.Length - 2)(keyword(0)) = list
         End If
 
         list.Add(kw)
 
         strSpecial(ks) = keyword
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2496" endline="2525">
<![CDATA[
 
     ''' <summary>
     ''' NewExpression 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseNewExpression(ByVal Parent As ParsedObject) As NewExpression
         Dim result As New NewExpression(Parent)
         Dim iCurrent As RestorablePoint = tm.GetRestorablePoint
         Dim bShowingErrors As Boolean
 
         Dim ace As ArrayCreationExpression
 
         bShowingErrors = Me.ShowErrors
         Me.m_ShowErrors = False
         ace = ParseArrayCreationExpression(result)
         Me.m_ShowErrors = bShowingErrors
 
         If ace IsNot Nothing Then
             tm.IgnoreRestoredPoint()
             result.Init(ace)
         Else
             tm.RestoreToPoint(iCurrent)
             Dim doce As DelegateOrObjectCreationExpression
             doce = ParseDelegateOrObjectCreationExpression(result)
             If doce Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(doce)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2426" endline="2449">
<![CDATA[
 
     Private Function ParseArrayInitializerExpression(ByVal Parent As ParsedObject) As ArrayInitializerExpression
         Dim result As New ArrayInitializerExpression(Parent)
 
         Dim m_Initializers As New Expressions()
 
         tm.AcceptIfNotInternalError(KS.LBrace)
 
         If tm.CurrentToken <> KS.RBrace Then
             Do
                 Dim newExp As Expression
                 newExp = ParseExpression(result)
                 If newExp Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
                 m_Initializers.Add(newExp)
             Loop While tm.Accept(KS.Comma)
         End If
 
         If tm.Accept(KS.RBrace) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Initializers)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="119" endline="132">
<![CDATA[
 
     Friend Function DefineStaticMember() As Boolean
         Dim result As Boolean = True
 
         If FieldBuilder Is Nothing Then
 
             Dim staticName As String
             staticName = "$STATIC$" & Me.FindFirstParent(Of INameable).Name & "$" & Me.ObjectID.ToString & "$" & Me.Name
             m_FieldBuilderCecil = New Mono.Cecil.FieldDefinition(staticName, Helper.GetAttributes(Compiler, Me), Helper.GetTypeOrTypeReference(Compiler, FieldType))
             DeclaringType.CecilType.Fields.Add(m_FieldBuilderCecil)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2602" endline="2627">
<![CDATA[
 
     Private Function ParseNamedArgument(ByVal Parent As ParsedObject) As NamedArgument
         Dim result As New NamedArgument(Parent)
         Dim Name As String
         Dim Expression As Expression = Nothing
 
         If tm.CurrentToken.IsIdentifier Then
             Name = tm.CurrentToken.Identifier
         ElseIf tm.CurrentToken.IsKeyword Then
             Name = tm.CurrentToken.Identifier
         Else
             Throw New InternalException(result)
         End If
         tm.NextToken()
         tm.AcceptIfNotInternalError(KS.Colon)
         tm.AcceptIfNotInternalError(KS.Equals)
         tm.AcceptNewLine()
 
         Expression = ParseExpression(result)
         If Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
 
         result.Init(Name, Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3465" endline="3498">
<![CDATA[
 
     ''' <summary>
     ''' "TypeOf" Expression "Is" TypeName
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeOfExpression(ByVal Parent As ParsedObject) As TypeOfExpression
         Dim result As New TypeOfExpression(Parent)
 
         Dim m_Expression As Expression
         Dim m_Is As Boolean
         Dim m_Type As TypeName
 
         tm.AcceptIfNotInternalError(KS.TypeOf)
 
         m_Expression = ParseExpression(New ExpressionParseInfo(result, False, True))
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Is) Then
             m_Is = True
         ElseIf tm.Accept(KS.IsNot) Then
             m_Is = False
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
             Return Nothing
         End If
         tm.AcceptNewLine()
 
         m_Type = ParseTypeName(result)
         If m_Type Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression, m_Is, m_Type)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="80" endline="98">
<![CDATA[
 
     Private Function DefineField() As Boolean
         Dim result As Boolean = True
 
         'result = MyBase.Define AndAlso result
 
         If IsStatic AndAlso m_FieldBuilderStatic Is Nothing Then
             Dim staticName As String
             Dim attr As Mono.Cecil.FieldAttributes = Mono.Cecil.FieldAttributes.Private
 
             staticName = "$STATIC$" & Me.FindFirstParent(Of INameable).Name & "$" & Me.ObjectID.ToString & "$" & Me.Name
             If DeclaringMethod.IsShared Then attr = attr Or Mono.Cecil.FieldAttributes.Static
 
             m_FieldBuilderStatic = New Mono.Cecil.FieldDefinition(staticName, attr, Helper.GetTypeOrTypeReference(Compiler, Me.VariableType))
             DeclaringType.CecilType.Fields.Add(m_FieldBuilderStatic)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="542" endline="561">
<![CDATA[
 
     Sub InferTypeArguments()
         If m_TypeArguments IsNot Nothing AndAlso m_TypeArguments.Count > 0 Then
             Log("Type arguments specified, not inferring them")
             Return
         End If
 
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate.IsRemoved("InferTypeArguments") Then Continue For
 
             If candidate.InferTypeArguments = False Then
                 Log("TYPE INFERENCE FAILED
                 m_Candidates(i).RemovedBy = "InferTypeArguments"
             Else
                 Log("TYPE INFERENCE PASSED
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="597" endline="643">
<![CDATA[
 
     ''' <summary>
     ''' AttributeArguments  
     '''     AttributePositionalArgumentList  |
     ''' 	AttributePositionalArgumentList  ,  VariablePropertyInitializerList  |
     '''	    VariablePropertyInitializerList
     '''
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributeArguments(ByVal Parent As ParsedObject) As AttributeArguments
         Dim result As New AttributeArguments(Parent)
 
         Dim m_AttributePositionalArgumentList As New AttributePositionalArgumentList(result)
         Dim m_VariablePropertyInitializerList As New VariablePropertyInitializerList(result)
 
         If AttributePositionalArgumentList.CanBeMe(tm) Then
             Do
                 Dim newObject As AttributeArgumentExpression
                 newObject = ParseAttributeArgumentExpression(Parent)
                 If newObject Is Nothing Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
                 m_AttributePositionalArgumentList.Add(newObject)
 
                 If tm.CurrentToken = KS.Comma Then
                     Dim current As RestorablePoint = tm.GetRestorablePoint
                     tm.NextToken()
                     If AttributePositionalArgumentList.CanBeMe(tm) = False Then
                         tm.RestoreToPoint(current)
                         Exit Do
                     Else
                         tm.RestoreToPoint(current)
                     End If
                 End If
             Loop While tm.Accept(KS.Comma)
         End If
 
         If m_AttributePositionalArgumentList.Count = 0 OrElse tm.Accept(KS.Comma) Then
             If ParseList(Of VariablePropertyInitializer)(m_VariablePropertyInitializerList, New ParseDelegate_Parent(Of VariablePropertyInitializer)(AddressOf ParseVariablePropertyInitializer), result) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End If
 
         result.Init(m_AttributePositionalArgumentList, m_VariablePropertyInitializerList)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\StdToolMgr.vb" startline="413" endline="455">
<![CDATA[
 
 #End Region
 
 #Region "   Draw the Play Position Trackbar "
 
     Public Sub Draw()
 
         If lplayPos.Height = 0 Then Exit Sub
         If lplayPos.Width = 0 Then Exit Sub
 
         mDrawing = True
 
         'Initialise the bitmap
         mBitMap = Nothing
         mBitMap = New Bitmap(lplayPos.Width, lplayPos.Height)
         Dim TempGr As Graphics = Graphics.FromImage(mBitMap)
 
         'Draw the segments if media loaded
         Dim Wide As Integer = lplayPos.Width - mPenWide
         Dim High As Integer = lplayPos.Height
 
         'Draw the keyframes
         If mFrames2Paint Then
             Dim Scale As Double = Wide / mPlayer.currentMedia.duration
             Dim FrLine As New Pen(Color.DarkKhaki)
             Dim Xpos As Single
             For i As Integer = 0 To mFrames.Length - 1
                 Xpos = CSng(Scale * mFrames(i))
                 TempGr.DrawLine(FrLine, Xpos, 0, Xpos, High)
             Next
         End If
 
         TempGr.Dispose()
 
         'Buffer back the drawn bitmap
         Dim gr As Graphics = lplayPos.CreateGraphics
         gr.Clear(Color.Beige)
         gr.DrawImageUnscaled(mBitMap, 0, 0)
         gr.Dispose()
 
         mDrawing = False
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\ASFhandler.vb" startline="154" endline="189">
<![CDATA[
 
     Public Overloads Overrides Function Split(ByVal Filename As String, _
     ByVal Pieces As Short, Optional ByVal MediaDuration As Double = 0) As Boolean
         MyBase.Split(Filename, Pieces)
 
         If Pieces < 2 Then Exit Function
         If MediaDuration = 0 Then Exit Function
 
         Try
             Dim sw As IO.StreamWriter = New IO.StreamWriter("MovicaTemp.@@@", False)
             Dim Duration As Double = MediaDuration / Pieces
 
             For i As Integer = 0 To Pieces - 1
                 sw.WriteLine(CStr(Duration * i) & "," & CStr(Duration))
             Next
             sw.Close()
 
             '-i long.asf -l timeranges.txt -sep -o short{00}.asf -unique
             Dim Temp As String = "-i " & Chr(34) & mInFile & Chr(34)
             Temp += " -s MovicaTemp.@@@ -sep -o " & Chr(34) & _
                 AddDefaultPathIfNeeded(StripExtension(Filename)) 
             If mIsAudio Then
                 Temp += "{000}.wma" & Chr(34) & " -unique -y"
             Else
                 Temp += "{000}.wmv" & Chr(34) & " -unique -y"
             End If
 
             RunConverter(Temp)
 
             Return FileCount(Filename) >= Pieces
 
         Catch ex As Exception
             MsgBox(ex.Message, MsgBoxStyle.Exclamation, "Failed")
         End Try
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="1285" endline="1324">
<![CDATA[
 
     ''' <summary>
     ''' QualifiedIdentifier 
     ''' 
     ''' Call if CurrentToken is identifier or "Global".
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseQualifiedIdentifier(ByVal Parent As ParsedObject) As QualifiedIdentifier
         Dim result As New QualifiedIdentifier(Parent)
 
         Helper.Assert(vbnc.QualifiedIdentifier.CanBeQualifiedIdentifier(tm))
 
         Dim m_First As ParsedObject
         Dim m_Second As Token = Nothing
 
         If tm.CurrentToken.IsIdentifier Then
             m_First = ParseIdentifier(result)
         ElseIf tm.CurrentToken.Equals(KS.Global) Then
             m_First = ParseGlobalExpression(result)
             If tm.CurrentToken <> KS.Dot Then Return Nothing
         Else
             Throw New InternalException(result)
         End If
 
         While tm.Accept(KS.Dot)
             tm.AcceptNewLine()
             If Token.IsSomething(m_Second) Then m_First = New QualifiedIdentifier(Parent, m_First, m_Second)
             If tm.CurrentToken.IsIdentifierOrKeyword Then
                 m_Second = tm.CurrentToken
                 tm.NextToken()
             Else
                 Compiler.Report.ShowMessage(Messages.VBNC30203, tm.CurrentLocation)
                 Return Nothing
             End If
         End While
         While tm.Accept(KS.Dot)
             tm.AcceptNewLine()
             If Token.IsSomething(m_Second) Then m_First = New QualifiedIdentifier(Parent, m_First, m_Second)
             If tm.CurrentToken.IsIdentifierOrKeyword Then
                 m_Second = tm.CurrentToken
                 tm.NextToken()
             Else
                 Compiler.Report.ShowMessage(Messages.VBNC30203, tm.CurrentLocation)
                 Return Nothing
             End If
         End While
 
         result.Init(m_First, m_Second)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="278" endline="324">
<![CDATA[
 
     Public Shared Function EmitLateGet(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification) As Boolean
         Dim result As Boolean = True
         Dim copyBacks As Mono.Cecil.Cil.VariableDefinition = Nothing, arguments As Mono.Cecil.Cil.VariableDefinition = Nothing
         Dim copyBackHints As Boolean() = Nothing
 
         'We need to emit a call to LateGet
 
         If LateBoundAccess.InstanceExpression Is Nothing Then
             '1 - the instance expression (none in this case)
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type))
 
             '2 - Type 
             Emitter.EmitLoadToken(Info, LateBoundAccess.LateBoundType)
             Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Type__GetTypeFromHandle_RuntimeTypeHandle)
         Else
             '1 - the instance expression
             result = LateBoundAccess.InstanceExpression.GenerateCode(Info) AndAlso result
 
             '2 - Type  - we have the instance, so no need to pass the type here.
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type))
         End If
 
         '3 - The member name
         Emitter.EmitLoadValue(Info, LateBoundAccess.Name)
 
         '4 - The arguments
         '5 - ArgumentNames
         EmitArguments(Info, LateBoundAccess, arguments)
 
         '6 - TypeArguments
         If LateBoundAccess.TypeArguments IsNot Nothing Then
             Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, LateBoundAccess.Parent.Location)
         Else
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type_Array))
         End If
 
         '7 - CopyBack
         EmitCopyBacks(Info, LateBoundAccess, copyBackHints, copyBacks)
 
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_NewLateBinding__LateGet_Object_Type_String_Array_Array_Array_Array)
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
 
         EmitStoreBacks(Info, LateBoundAccess, copyBackHints, copyBacks, arguments)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\DictionaryAccessExpression.vb" startline="62" endline="95">
<![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_IsLateBound Then
             Dim ie As Expression
             Dim lbaC As LateBoundAccessClassification
             If m_FirstPart Is Nothing Then
                 ie = New LoadLocalExpression(Me, m_WithStatement.WithVariable)
             Else
                 ie = m_FirstPart
             End If
             lbaC = New LateBoundAccessClassification(Me, ie, Nothing, Nothing)
             lbaC.Arguments = New ArgumentList(Me, New ConstantExpression(Me, m_SecondPart.Identifier, Compiler.TypeCache.System_String))
             result = LateBoundAccessToExpression.EmitLateIndexGet(Info, lbaC) AndAlso result
         Else
             If m_FirstPart IsNot Nothing Then
                 result = m_FirstPart.GenerateCode(Info) AndAlso result
             Else
                 Emitter.EmitLoadVariable(Info, m_WithStatement.WithVariable)
             End If
             result = m_SecondExpression.GenerateCode(Info) AndAlso result
             If Info.IsRHS Then
                 Emitter.EmitCallOrCallVirt(Info, CecilHelper.FindDefinition(m_DefaultProperty).GetMethod)
             ElseIf Info.IsLHS Then
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Else
                 Throw New InternalException(Me)
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="218" endline="250">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_ExpressionType Is Nothing Then
             result = m_NonArrayTypeName.ResolveTypeReferences AndAlso result
             If m_ArrayNameModifier IsNot Nothing Then result = m_ArrayNameModifier.ResolveCode(Info) AndAlso result
 
             Dim tmptp As Mono.Cecil.TypeReference = m_NonArrayTypeName.ResolvedType
             If m_ArrayNameModifier.IsArraySizeInitializationModifier Then
                 tmptp = m_ArrayNameModifier.AsArraySizeInitializationModifier.CreateArrayType(tmptp)
             ElseIf m_ArrayNameModifier.IsArrayTypeModifiers Then
                 tmptp = m_ArrayNameModifier.AsArrayTypeModifiers.CreateArrayType(tmptp)
             Else
                 Throw New InternalException(Me)
             End If
             m_ExpressionType = tmptp
         End If
 
         If m_ArrayElementInitializer IsNot Nothing Then
             Dim elementInfo As New ExpressionResolveInfo(Compiler, m_ExpressionType)
             result = m_ArrayElementInitializer.ResolveCode(elementInfo) AndAlso result
         End If
 
         If m_ArrayNameModifier IsNot Nothing Then
             Dim elementInfo As New ExpressionResolveInfo(Compiler, m_ExpressionType)
             result = m_ArrayNameModifier.ResolveCode(elementInfo) AndAlso result
         End If
 
         Classification = New ValueClassification(Me, m_ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="6166" endline="6209">
<![CDATA[
 
     Private Function GetPartialType(ByVal Parent As ParsedObject, ByVal m_Identifier As Identifier, ByVal m_TypeParameters As TypeParameters, ByVal m_Modifiers As Modifiers, ByVal IsClass As Boolean, ByVal [Namespace] As String) As PartialTypeDeclaration
         Dim result As PartialTypeDeclaration
 
         'Get the actual name of the type including generic number
         Dim CompleteName As String
         Dim GenericName As Identifier
         If m_TypeParameters Is Nothing Then
             GenericName = m_Identifier
         Else
             GenericName = New Identifier(Helper.CreateGenericTypename(m_Identifier.Name, m_TypeParameters.Parameters.Count))
         End If
 
         CompleteName = GenericName.Name
         If TypeOf Parent Is AssemblyDeclaration AndAlso [Namespace] <> String.Empty Then
             CompleteName = [Namespace] & "." & CompleteName
         End If
 
         'Try to find the type in the parent
         Dim partialType As TypeDeclaration = FindTypeInParent(Parent, CompleteName)
         Dim partialClassOrStruct As PartialTypeDeclaration = TryCast(partialType, PartialTypeDeclaration)
 
         If partialType IsNot Nothing Then
             'There is already a type with the same name
             result = partialClassOrStruct
             result.IsPartial = True
             result.Modifiers = result.Modifiers.AddModifiers(m_Modifiers.Mask)
             result.PartialModifierFound = result.Modifiers.Is(ModifierMasks.Partial) OrElse m_Modifiers.Is(ModifierMasks.Partial)
         ElseIf partialType IsNot Nothing Then
             'There is another type with the same name
             Helper.AddError(tm.Compiler, tm.CurrentLocation, "Two types with the same name
             Return Nothing
         Else
             'No type with the same name.
             If IsClass Then
                 result = New ClassDeclaration(Parent, [Namespace], GenericName, m_TypeParameters)
             Else
                 result = New StructureDeclaration(Parent, [Namespace], GenericName, m_TypeParameters)
             End If
             result.Modifiers = m_Modifiers
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MemberCache.vb" startline="253" endline="287">
<![CDATA[
 
     Private Sub Flatten(ByVal Name As String, ByVal base As MemberCache, ByVal Visibility As MemberVisibility)
         If base Is Nothing Then
             If Helper.IsInterface(Compiler, m_Type) AndAlso CecilHelper.IsGenericParameter(m_Type) = False Then
                 Dim ifaces As Mono.Collections.Generic.Collection(Of TypeReference)
                 Dim icaches() As MemberCache
 
                 ifaces = CecilHelper.GetInterfaces(m_Type, True)
 
                 ReDim icaches(ifaces.Count - 1)
                 m_ShadowedInterfaceMembers = New Generic.List(Of Mono.Cecil.MemberReference)
 
                 For i As Integer = 0 To ifaces.Count - 1
                     icaches(i) = m_Compiler.TypeManager.GetCache(ifaces(i))
                     icaches(i).Load(Nothing, Visibility)
                     m_ShadowedInterfaceMembers.AddRange(icaches(i).m_ShadowedInterfaceMembers)
                 Next
 
                 For i As Integer = 0 To ifaces.Count - 1
                     FlattenWith(Name, icaches(i), Visibility)
                 Next
                 Dim system_object As MemberCache = m_Compiler.TypeManager.GetCache(Compiler.TypeCache.System_Object)
                 system_object.Load(Name, Visibility)
                 FlattenWith(Name, system_object, Visibility)
             Else
                 m_FlattenedCacheInsensitive = m_CacheInsensitive
             End If
 
             Return
         End If
 
         base.Load(Name, Visibility)
 
         FlattenWith(Name, base, Visibility)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="4369" endline="4396">
<![CDATA[
 
 #End Region
 
 #Region "   MRU "
 
     Private Sub MenuItem1_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles MenuItem1.Popup
         'Clear the list
         For i As Integer = 0 To mnuArr.Length - 1
             If mnuArr(i) Is Nothing Then Exit For
             MenuItem1.MenuItems.Remove(mnuArr(i))
             mnuArr(i) = Nothing
         Next
 
         If mMRU.Length = 0 Then
             ReDim mnuArr(0)
             mnuArr(0) = New MenuItem(mTranslator.LangText(110))
             MenuItem1.MenuItems.Add(7, mnuArr(0))
             mnuArr(0).Enabled = False
         Else
             ReDim mnuArr(mMRU.Length - 1)
             Dim List As String() = mMRU.List
             For i As Integer = 0 To mMRU.Length - 1
                 mnuArr(i) = New MenuItem(mMRU.ShortName(List(i)), AddressOf mnuArr_Click)
                 mnuArr(i).Tag = List(i)
                 MenuItem1.MenuItems.Add(7 + i, mnuArr(i))
             Next
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\EventAccessorDeclarations.vb" startline="192" endline="201">
<![CDATA[
 
     Function DefineOverrides() As Boolean
         Dim result As Boolean = True
 
         If m_ImplementsClause IsNot Nothing Then
             result = m_ImplementsClause.DefineImplements(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="70" endline="78">
<![CDATA[
 
     Public Overrides Function CreateDefinition() As Boolean Implements IMember.CreateDefinition
         Dim result As Boolean = True
 
         result = MyBase.CreateDefinition AndAlso result
         If m_CustomAttributes IsNot Nothing Then m_CustomAttributes.SetParent(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="288" endline="303">
<![CDATA[
 
     ''' <summary>
     ''' The name of the method. (Any method actually, since they should all have the same name).
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property MethodName() As String
         Get
             For i As Integer = 0 To m_Group.Count - 1
                 If m_Group(i) IsNot Nothing Then
                     Return m_Group(i).Name
                 End If
             Next
             Throw New InternalException(Me)
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4849" endline="4868">
<![CDATA[
 
     ''' <summary>
     ''' VariableDeclarators  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseLocalVariableDeclarators(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal Info As ParseAttributableInfo) As Generic.List(Of LocalVariableDeclaration)
         Dim result As New Generic.List(Of LocalVariableDeclaration)
 
         Do
             Dim tmp As New Generic.List(Of LocalVariableDeclaration)
             tmp = ParseLocalVariableDeclarator(Parent, Modifiers, Info)
             If tmp Is Nothing Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 result.AddRange(tmp)
             End If
         Loop While tm.Accept(KS.Comma)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4869" endline="4890">
<![CDATA[
 
     ''' <summary>
     ''' VariableDeclarators  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeVariableDeclarators(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal Info As ParseAttributableInfo) As Generic.List(Of TypeVariableDeclaration)
         Dim result As New Generic.List(Of TypeVariableDeclaration)
 
         Do
             Dim tmp As New Generic.List(Of TypeVariableDeclaration)
             'Console.WriteLine("ParseTypeVariableDeclarators...")
             tmp = ParseTypeVariableDeclarator(Parent, Modifiers, Info)
             'Console.WriteLine("Got something
             If tmp Is Nothing Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 result.AddRange(tmp)
             End If
         Loop While tm.Accept(KS.Comma)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Compiler.vb" startline="137" endline="147">
<![CDATA[
 
     Public Sub VerifyConsistency(ByVal result As Boolean, ByVal Location As Span)
         If Report.Errors = 0 AndAlso result = False Then
             Report.WriteLine(vbnc.Report.ReportLevels.Debug, Location.AsString(Compiler) & " No errors, but compilation failed? ")
             Helper.StopIfDebugging()
             Throw New InternalException("Consistency check failed")
         ElseIf Report.Errors > 0 AndAlso result Then
             'Report.WriteLine(vbnc.Report.ReportLevels.Debug, Report.Errors.ToString & " errors, but compilation succeeded? " & Location)
             'Throw New InternalException("Consistency check failed")
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\CallStatement.vb" startline="84" endline="100">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Target.ResolveExpression(Info) AndAlso result
 
         If result = False Then Return result
 
         If m_Target.Classification.IsMethodGroupClassification Then
             Dim tmp As New InvocationOrIndexExpression(Me)
             tmp.Init(m_Target, New ArgumentList(tmp))
             result = tmp.ResolveExpression(Info) AndAlso result
             m_Target = tmp
         End If
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="473" endline="489">
<![CDATA[
 
     ''' <summary>
     ''' Intrinsic type
     ''' </summary>
     ''' <param name="Compiler"></param>
     ''' <param name="Type"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function IsIntrinsicType(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Dim tC As TypeCode = GetTypeCode(Compiler, Type)
 
         If tC = TypeCode.Object Then
             Return Helper.CompareType(Type, Compiler.TypeCache.System_Object)
         Else
             Return True
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\LateBoundAccessToValueExpression.vb" startline="83" endline="91">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim constant As Object = Nothing
 
         If Not GetConstant(constant, True) Then Return False
 
         Classification = New ValueClassification(Me, ExpressionType, constant)
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\OptionStrictStatement.vb" startline="125" endline="136">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
 
         result = m_Event.ResolveExpression(Info) AndAlso result
 
         result = m_Arguments.ResolveCode(Info) AndAlso result
 
         Compiler.Helper.AddCheck("The result of the expression must be classified as an event access for an event defined in the class itself; ")
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="158" endline="169">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_GeneratedCode = False Then
             If m_CustomAttributes IsNot Nothing Then result = m_CustomAttributes.GenerateCode(Info) AndAlso result
 
             m_GeneratedCode = True
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\Main.vb" startline="67" endline="76">
<![CDATA[
 
     Public Function FindFormat(ByVal Extension As String) As Format
 
         For i As Integer = 0 To UBound(Formats)
             If Array.IndexOf(Formats(i).Extensions, Extension) > -1 Then
                 Return Formats(i)
             End If
         Next
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2550" endline="2557">
<![CDATA[
 
     Shared Sub SetTypeOrTypeBuilder(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference())
         If Type Is Nothing Then Return
         For i As Integer = 0 To Type.Length - 1
             Helper.Assert(Type(i) IsNot Nothing)
             Type(i) = GetTypeOrTypeBuilder(Compiler, Type(i))
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" startline="27" endline="39">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_DestinationType IsNot Nothing Then
             result = m_DestinationType.ResolveTypeReferences AndAlso result
             m_ResolvedDestinationType = m_DestinationType.ResolvedType
             Helper.Assert(CecilHelper.IsByRef(m_ResolvedDestinationType) = False)
         End If
 
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="150" endline="159">
<![CDATA[
     End Property
 #End If
 
     Function AcceptSequence(ByVal ParamArray ks As KS()) As Boolean
         For i As Integer = 0 To ks.GetUpperBound(0)
             If Me.PeekToken(i).Equals(ks(i)) = False Then Return False
         Next
         Me.NextToken(ks.GetUpperBound(0) + 1)
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1256" endline="1263">
<![CDATA[
 
     Public Shared Function CompareParameterTypes(ByVal a As Mono.Collections.Generic.Collection(Of ParameterDefinition), ByVal b As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Boolean
         If a.Count <> b.Count Then Return False
         For i As Integer = 0 To a.Count - 1
             If Helper.CompareType(a(i).ParameterType, b(i).ParameterType) = False Then Return False
         Next
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ReturnStatement.vb" startline="72" endline="86">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         EndLabel = Emitter.DefineLabel(Info)
 
         For i As Integer = 0 To m_Cases.Count - 1
             Dim stmt As CaseStatement = m_Cases(i)
             result = stmt.GenerateCode(Info) AndAlso result
         Next
 
         Emitter.MarkLabel(Info, EndLabel)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AliasClause.vb" startline="187" endline="201">
<![CDATA[
 
     Shared Function GetGetMethod(ByVal Compiler As Compiler, ByVal ArrayType As Mono.Cecil.TypeReference) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
         Dim ranks As Integer = CecilHelper.GetArrayRank(ArrayType)
 
         ArrayType = Helper.GetTypeOrTypeBuilder(Compiler, ArrayType)
         elementType = Helper.GetTypeOrTypeBuilder(Compiler, elementType)
         result = New Mono.Cecil.MethodReference("Get", ArrayType, elementType, True, False, Mono.Cecil.MethodCallingConvention.Default)
         For i As Integer = 1 To ranks
             result.Parameters.Add(New Mono.Cecil.ParameterDefinition(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Int32)))
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\OperatorDeclaration.vb" startline="82" endline="92">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParameterList = Nothing) As Parameter
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParameterList)
         Dim result As New Parameter(NewParent)
         result.m_CustomAttributes = m_CustomAttributes
         result.m_Modifiers = m_Modifiers
         result.m_ParameterIdentifier = m_ParameterIdentifier
         If m_TypeName IsNot Nothing Then result.m_TypeName = m_TypeName
         If m_ConstantExpression IsNot Nothing Then result.m_ConstantExpression = m_ConstantExpression
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="408" endline="422">
<![CDATA[
 
     <Obsolete()> _
     Function AcceptIdentifier(ByRef result As Token) As Boolean
         Dim tmp As Token = CurrentToken()
         If CurrentToken.IsIdentifier Then
             result = CurrentToken()
             If tmp.IsIdentifier = False Then Throw New InternalException("Not an identifier?????")
             If CurrentToken.IsIdentifier = False Then Throw New InternalException("Not an identifier???")
             If result.IsIdentifier = False Then Throw New InternalException("Not an identifier?")
             NextToken()
             Return True
         Else
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="1373" endline="1381">
<![CDATA[
 
     Public Shared Function AreSame(ByVal a As Mono.Collections.Generic.Collection(Of ParameterDefinition), ByVal b As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Boolean
         If a.Count <> b.Count Then Return False
         If a.Count = 0 Then Return True
         For i As Integer = 0 To a.Count - 1
             If Not AreSame(a(i).ParameterType, b(i).ParameterType) Then Return False
         Next
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2298" endline="2329">
<![CDATA[
 
     ''' <summary>
     ''' InvocationExpression
     ''' IndexExpression
     ''' Note that for the index expression the parenthesis are not optional.
     ''' This is reflected by the fact that m_ArgumentList is not nothing if 
     ''' parenthesis are provided.
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInvocationOrIndexExpression(ByVal Parent As ParsedObject, ByVal First As Expression) As InvocationOrIndexExpression
         Dim result As New InvocationOrIndexExpression(Parent)
 
         Dim m_Expression As Expression
         Dim m_ArgumentList As ArgumentList
 
         m_Expression = First
 
         If tm.Accept(KS.LParenthesis) Then
             If tm.Accept(KS.RParenthesis) = False Then
                 m_ArgumentList = ParseArgumentList(result)
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 m_ArgumentList = New ArgumentList(result)
             End If
         Else
             m_ArgumentList = Nothing
         End If
 
         result.Init(m_Expression, m_ArgumentList)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="100" endline="116">
<![CDATA[
 
     Function GetConditionalConstants(ByVal Line As UInteger) As ConditionalConstants
         If m_ConditionalConstantsLines.Count = 0 Then Return Nothing
 
         'If the first #const is after the line, no constants in this file at the line
         If m_ConditionalConstantsLines(0) > Line Then Return Nothing
 
         For i As Integer = 0 To m_ConditionalConstantsLines.Count - 1
             'If the current #const is after the line, the previous one corresponds to the line
             If m_ConditionalConstantsLines(i) > Line Then
                 Return m_ConditionalConstants(i - 1)
             End If
         Next
 
         'If no constants are after the line, the last is the one.
         Return m_ConditionalConstants(m_ConditionalConstants.Count - 1)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\ConstructedTypeName.vb" startline="36" endline="54">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ResolvedType IsNot Nothing Then Return True
 
         If m_TypeArity > 0 Then
             Dim qi As QualifiedIdentifier = DirectCast(m_Name, QualifiedIdentifier)
             result = qi.ResolveAsTypeName(False, m_TypeArity) AndAlso result
 
             If result Then m_ResolvedType = qi.ResolvedType
         Else
             result = m_Name.ResolveTypeReferences AndAlso result
             If result Then m_ResolvedType = DirectCast(m_Name, TypeName).ResolvedType
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="557" endline="580">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_Variables.Count - 1
             result = m_Variables(i).ResolveCode(Info) AndAlso result
         Next
 
         'We may add statements as we go.
         Dim counter As Integer = 0
         Dim count As Integer = m_Statements.Count
         While counter < m_Statements.Count
             Dim obj As Statement = m_Statements(counter)
             result = obj.ResolveStatement(Info) AndAlso result
             If count <> m_Statements.Count Then
             	'A statement has been added somewhere.
             	'Find the correct index of the current statement.
                 counter = m_Statements.IndexOf(obj)
             End If
             counter += 1
         End While
         While counter < m_Statements.Count
             Dim obj As Statement = m_Statements(counter)
             result = obj.ResolveStatement(Info) AndAlso result
             If count <> m_Statements.Count Then
             	'A statement has been added somewhere.
             	'Find the correct index of the current statement.
                 counter = m_Statements.IndexOf(obj)
             End If
             counter += 1
         End While
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="202" endline="219">
<![CDATA[
 
     Public Function ResolveMember(ByVal Info As ResolveInfo) As Boolean Implements INonTypeMember.ResolveMember
         Dim result As Boolean = True
 
         result = m_Signature.ResolveCode(Info) AndAlso result
 
         If m_Get IsNot Nothing Then result = m_Get.ResolveMember(ResolveInfo.Default(Info.Compiler)) AndAlso result
         If m_Set IsNot Nothing Then result = m_Set.ResolveMember(ResolveInfo.Default(Info.Compiler)) AndAlso result
 
         If Modifiers.Is(ModifierMasks.Default) Then
             Dim tp As TypeDeclaration = Me.FindFirstParent(Of TypeDeclaration)()
             result = tp.SetDefaultAttribute(Me.Name) AndAlso result
         End If
 
         result = Signature.VerifyParameterNamesDoesntMatchFunctionName() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3958" endline="4002">
<![CDATA[
 
     ''' <summary>
     ''' Parameter            
     ''' ParameterModifier    
     ''' ParameterIdentifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseParameter(ByVal Parent As ParsedObject) As Parameter
         Helper.Assert(TypeOf Parent Is ParameterList)
         Dim result As New Parameter(DirectCast(Parent, ParameterList))
 
         Dim m_Attributes As New Attributes(result)
         Dim m_Modifiers As Modifiers
         Dim m_ParameterIdentifier As ParameterIdentifier
         Dim m_TypeName As TypeName
         Dim m_ConstantExpression As Expression
 
         If vbnc.Attributes.IsMe(tm) Then
             ParseAttributes(result, m_Attributes)
         End If
 
         m_Modifiers = ParseModifiers(ModifierMasks.ParameterModifiers)
 
         m_ParameterIdentifier = ParseParameterIdentifier(result)
         If m_ParameterIdentifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeName = Nothing
         End If
 
         If tm.Accept(KS.Equals) Then
             tm.AcceptNewLine()
             m_ConstantExpression = ParseExpression(result)
             If m_ConstantExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_ConstantExpression = Nothing
         End If
 
         result.Init(m_Attributes, m_Modifiers, m_ParameterIdentifier, m_TypeName, m_ConstantExpression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\PartialTypeDeclaration.vb" startline="39" endline="79">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_InterfacesImplemented = False AndAlso m_TypeImplementsClauses IsNot Nothing Then
             result = m_TypeImplementsClauses.ResolveTypeReferences AndAlso result
             For i As Integer = 0 To m_TypeImplementsClauses.Clauses.Count - 1
                 AddInterface(m_TypeImplementsClauses.Clauses(i).ResolvedType)
             Next
             m_InterfacesImplemented = True
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         If Me.IsPartial Then
             If PartialModifierFound = False Then
                 Dim first As PartialTypeDeclaration = Me
                 Compiler.Report.ShowMessage(Messages.VBNC30179, Me.Location, Me.DescriptiveType, Me.Name, Me.DescriptiveType, Me.Name, Me.Namespace, Me.Namespace)
                 result = False
             End If
             'TODO
             'If TypeOf Me Is ClassDeclaration Then
             '    Dim inheritedTypes() As Mono.Cecil.TypeReference
             '    inheritedTypes = GetInheritedTypes()
             '    If inheritedTypes.Length > 0 Then
             '        Dim tmpType As Mono.Cecil.TypeReference
             '        tmpType = CheckUniqueType(inheritedTypes)
             '        If tmpType Is Nothing Then
             '            Return Helper.AddError(Me, "Partial classes must inherit from only one base class.")
             '        Else
             '            BaseType = tmpType
             '        End If
             '    Else
             '        Helper.Assert(BaseType IsNot Nothing) 'Should already be set to System.Object.
             '    End If
             'End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="77" endline="105">
<![CDATA[
 
     Overloads Function ResolveTypeReferences(ByVal AsAttributeTypeName As Boolean) As Boolean
         Dim result As Boolean = True
         If IsBuiltInTypeName Then
             'Not necessary.'result = AsBuiltInTypeName.ResolveTypeReferences AndAlso result
             m_ResolvedType = AsBuiltInTypeName.ResolvedType
         ElseIf IsQualifiedIdentifier Then
             Dim tpParam As Mono.Cecil.GenericParameter
             result = AsQualifiedIdentifier.ResolveAsTypeName(AsAttributeTypeName) AndAlso result
             If result = False Then Return result
             m_ResolvedType = AsQualifiedIdentifier.ResolvedType
             tpParam = TryCast(m_ResolvedType, Mono.Cecil.GenericParameter)
             If tpParam IsNot Nothing Then
                 m_TypeParameter = DirectCast(tpParam.Annotations(Compiler), TypeParameter)
             End If
             If result = False Then Return result
             If Not TypeOf m_ResolvedType Is Mono.Cecil.GenericInstanceType AndAlso m_ResolvedType.GenericParameters.Count > 0 Then
                 Dim tmp As New Mono.Cecil.GenericInstanceType(m_ResolvedType)
                 For i As Integer = 0 To m_ResolvedType.GenericParameters.Count - 1
                     tmp.GenericArguments.Add(m_ResolvedType.GenericParameters(i))
                 Next
                 m_ResolvedType = tmp
             End If
         Else
             Throw New InternalException(Me)
         End If
         Return result
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\CaseClauses.vb" startline="71" endline="99">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Condition.ResolveExpression(Info) AndAlso result
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         If m_Condition.Classification.IsValueClassification Then
             'nothing to do
         ElseIf m_Condition.Classification.CanBeValueClassification Then
             m_Condition = m_Condition.ReclassifyToValueExpression
             result = m_Condition.ResolveExpression(ResolveInfo.Default(Compiler)) AndAlso result
 
             If result = False Then
                 result = Helper.AddError(Me) AndAlso result
                 Return result
             End If
             m_Condition = Helper.CreateTypeConversion(Me, m_Condition, Compiler.TypeCache.System_Boolean, result)
 
             If result = False Then
                 result = Helper.AddError(Me) AndAlso result
                 Return result
             End If
         Else
             result = Helper.AddError(Me, "Each expression in an If...Then...Else statement must be classified as a value and be implicitly convertible to Boolean") AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\ASFhandler.vb" startline="118" endline="153">
<![CDATA[
 
     Public Overloads Overrides Function Split(ByVal Filename As String, _
     ByVal Duration As Double, ByVal MediaDuration As Double) As Boolean
         MyBase.Split(Filename, Duration, MediaDuration)
 
         If MediaDuration = 0 Then Exit Function
         If Duration = 0 Then Exit Function
 
         Try
             Dim sw As IO.StreamWriter = New IO.StreamWriter("MovicaTemp.@@@", False)
 
             Dim Pieces As Integer = CInt(Fix(MediaDuration / Duration))
             If MediaDuration Mod Duration > 0 Then Pieces += 1
             For i As Integer = 0 To Pieces - 1
                 sw.WriteLine(CStr(Duration * i) & "," & CStr(Duration))
             Next
             sw.Close()
 
             '-i long.asf -l timeranges.txt -sep -o short{00}.asf -unique
             Dim Temp As String = "-i " & Chr(34) & mInFile & Chr(34)
             Temp += " -s MovicaTemp.@@@ -sep -o " & Chr(34) & _
                 AddDefaultPathIfNeeded(StripExtension(Filename))
             If mIsAudio Then
                 Temp += "{000}.wma" & Chr(34) & " -unique -y"
             Else
                 Temp += "{000}.wmv" & Chr(34) & " -unique -y"
             End If
 
             RunConverter(Temp)
             Return FileCount(Filename) >= Pieces
 
         Catch ex As Exception
             MsgBox(ex.Message, MsgBoxStyle.Exclamation, "Failed")
         End Try
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="100" endline="111">
<![CDATA[
 
     Function GenerateVariableCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Info.IsRHS, "With variables can't be assigned to...")
 
         If Info.IsRHS Then
             Emitter.EmitLoadVariable(Info, m_WithVariable)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="222" endline="235">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns the resolved method.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property ResolvedMethod() As Mono.Cecil.MethodReference
         Get
             If SuccessfullyResolved = False Then Throw New InternalException(Me)
             If m_Group.Count = 0 Then Return Nothing
             Return DirectCast(m_Group(0), Mono.Cecil.MethodReference)
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1764" endline="1778">
<![CDATA[
 
     Shared Sub EmitRetOrLeave(ByVal Info As EmitInfo, ByVal CurrentStatement As Statement, ByVal HasReturnValue As Boolean)
         Dim emitLeave As Boolean
 
         emitLeave = IsLeaveNecessary(CurrentStatement, Nothing)
 
         If emitLeave Then
             If HasReturnValue Then
                 Emitter.EmitStoreVariable(Info, Info.Method.DefaultReturnVariable)
             End If
             Emitter.EmitLeave(Info, CurrentStatement.FindParentCodeBlock.UpmostBlock.EndOfMethodLabel)
         Else
             Emitter.EmitRet(Info)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="189" endline="204">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns nothing if the resolved method isn't a methodinfo.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property ResolvedMethodInfo() As Mono.Cecil.MethodReference
         Get
             If SuccessfullyResolved = False Then Throw New InternalException(Me)
             If TypeOf m_Group(0) Is Mono.Cecil.MethodReference Then
                 Return DirectCast(m_Group(0), Mono.Cecil.MethodReference)
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="205" endline="221">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns nothing if the resolved method isn't a constructorinfo.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property ResolvedConstructor() As Mono.Cecil.MethodReference
         Get
             If SuccessfullyResolved = False Then Throw New InternalException(Me)
             If TypeOf m_Group(0) Is Mono.Cecil.MethodReference Then
                 Return DirectCast(m_Group(0), Mono.Cecil.MethodReference)
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="105" endline="118">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         If result = False Then Return False
 
         If VariableType IsNot Nothing Then
             m_FieldBuilderCecil.FieldType = Helper.GetTypeOrTypeReference(Compiler, VariableType)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="375" endline="384">
<![CDATA[
 
     Sub RemoveInvalid()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim m As MemberCandidate = m_Candidates(i)
             If m.IsRemoved("RemoveInvalid") Then Continue For
             If IsValidCandidate(m) = False Then
                 m_Candidates(i).RemovedBy = "RemoveInvalid"
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="280" endline="294">
<![CDATA[
 
     Shared Function VerifyValueClassification(ByRef Expression As Expression, ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         If Expression.Classification.IsValueClassification Then
             result = True
         ElseIf Expression.Classification.CanBeValueClassification Then
             Expression = Expression.ReclassifyToValueExpression
             result = Expression.ResolveExpression(Info) AndAlso result
             Helper.StopIfDebugging(result = False)
         Else
             Helper.AddError(Expression)
             result = False
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1490" endline="1511">
<![CDATA[
 
     Shared Function ApplyTypeArguments(ByVal Context As BaseObject, ByVal Member As Mono.Cecil.MemberReference, ByVal TypeArguments As TypeArgumentList) As Mono.Cecil.MemberReference
         Dim result As Mono.Cecil.MemberReference
         Dim minfo As Mono.Cecil.MethodReference
 
         minfo = TryCast(Member, Mono.Cecil.MethodReference)
         If minfo IsNot Nothing Then
             Dim args As Mono.Collections.Generic.Collection(Of Mono.Cecil.TypeReference)
             args = CecilHelper.GetGenericArguments(minfo)
 
             If args.Count = TypeArguments.Count Then
                 result = TypeArguments.Compiler.TypeManager.MakeGenericMethod(TypeArguments.Parent, minfo, args, TypeArguments.ArgumentCollection)
             Else
                 result = Nothing
             End If
         Else
             result = Nothing
             Context.Compiler.Report.ShowMessage(Messages.VBNC99997, Context.Location)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AliasClause.vb" startline="50" endline="59">
<![CDATA[
 
     Function CreateArrayType(ByVal OriginalType As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         If Me.IsArraySizeInitializationModifier Then
             Return Me.AsArraySizeInitializationModifier.CreateArrayType(OriginalType)
         ElseIf Me.IsArrayTypeModifiers Then
             Return Me.AsArrayTypeModifiers.CreateArrayType(OriginalType)
         Else
             Throw New InternalException(Me)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ReturnStatement.vb" startline="90" endline="98">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Lock.ResolveExpression(INfo) AndAlso result
         result = CodeBlock.ResolveCode(info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="108" endline="118">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
 
         result = m_UsingResources.ResolveCode(Info) AndAlso result
 
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="1991" endline="2004">
<![CDATA[
 
     Private Function ParseCByteExpression(ByVal Parent As ParsedObject) As CByteExpression
         Dim result As New CByteExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CByte)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2005" endline="2019">
<![CDATA[
 
     Private Function ParseCBoolExpression(ByVal Parent As ParsedObject) As CBoolExpression
         Dim result As New CBoolExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CBool)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2020" endline="2034">
<![CDATA[
 
     Private Function ParseCCharExpression(ByVal Parent As ParsedObject) As CCharExpression
         Dim result As New CCharExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CChar)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2035" endline="2049">
<![CDATA[
 
     Private Function ParseCDateExpression(ByVal Parent As ParsedObject) As CDateExpression
         Dim result As New CDateExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CDate)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2050" endline="2064">
<![CDATA[
 
     Private Function ParseCDblExpression(ByVal Parent As ParsedObject) As CDblExpression
         Dim result As New CDblExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CDbl)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2065" endline="2079">
<![CDATA[
 
     Private Function ParseCDecExpression(ByVal Parent As ParsedObject) As CDecExpression
         Dim result As New CDecExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CDec)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2080" endline="2094">
<![CDATA[
 
     Private Function ParseCIntExpression(ByVal Parent As ParsedObject) As CIntExpression
         Dim result As New CIntExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CInt)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2095" endline="2109">
<![CDATA[
 
     Private Function ParseCLngExpression(ByVal Parent As ParsedObject) As CLngExpression
         Dim result As New CLngExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CLng)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2110" endline="2124">
<![CDATA[
 
     Private Function ParseCObjExpression(ByVal Parent As ParsedObject) As CObjExpression
         Dim result As New CObjExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CObj)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2125" endline="2139">
<![CDATA[
 
     Private Function ParseCSByteExpression(ByVal Parent As ParsedObject) As CSByteExpression
         Dim result As New CSByteExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CSByte)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2140" endline="2154">
<![CDATA[
 
     Private Function ParseCShortExpression(ByVal Parent As ParsedObject) As CShortExpression
         Dim result As New CShortExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CShort)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2155" endline="2169">
<![CDATA[
 
     Private Function ParseCSngExpression(ByVal Parent As ParsedObject) As CSngExpression
         Dim result As New CSngExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CSng)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2170" endline="2184">
<![CDATA[
 
     Private Function ParseCStrExpression(ByVal Parent As ParsedObject) As CStrExpression
         Dim result As New CStrExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CStr)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2185" endline="2199">
<![CDATA[
 
     Private Function ParseCUIntExpression(ByVal Parent As ParsedObject) As CUIntExpression
         Dim result As New CUIntExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CUInt)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2200" endline="2214">
<![CDATA[
 
     Private Function ParseCULngExpression(ByVal Parent As ParsedObject) As CULngExpression
         Dim result As New CULngExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CULng)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2215" endline="2229">
<![CDATA[
 
     Private Function ParseCUShortExpression(ByVal Parent As ParsedObject) As CUShortExpression
         Dim result As New CUShortExpression(Parent, True)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.CUShort)
 
         m_Expression = ParseParenthesizedExpression(Parent)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" startline="165" endline="176">
<![CDATA[
 
     Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         BaseType = Compiler.TypeCache.System_MulticastDelegate
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         result = m_Signature.ResolveTypeReferences(False) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\SubSignature.vb" startline="165" endline="175">
<![CDATA[
 
     Overridable Overloads Function ResolveTypeReferences(ByVal ResolveTypeParameters As Boolean) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_ParameterList IsNot Nothing)
 
         result = m_ParameterList.ResolveTypeReferences AndAlso result
         If ResolveTypeParameters = True AndAlso m_TypeParameters IsNot Nothing Then result = m_TypeParameters.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AliasClause.vb" startline="84" endline="92">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_BoundList IsNot Nothing Then result = m_BoundList.ResolveCode(Info) AndAlso result
         If m_ArrayTypeModifiers IsNot Nothing Then result = m_ArrayTypeModifiers.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AttributeArguments.vb" startline="42" endline="50">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_AttributePositionalArgumentList IsNot Nothing Then result = m_AttributePositionalArgumentList.ResolveCode(info) AndAlso result
         If m_VariablePropertyInitializerList IsNot Nothing Then result = m_VariablePropertyInitializerList.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="63" endline="72">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveCode(Info) AndAlso result
         If m_TypeParameter IsNot Nothing Then result = m_TypeParameter.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="55" endline="62">
<![CDATA[
 
     Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\BoundList.vb" startline="178" endline="189">
<![CDATA[
 
     Function ResolveMember(ByVal Info As ResolveInfo) As Boolean Implements INonTypeMember.ResolveMember
         Dim result As Boolean = True
 
         If m_TypeName Is Nothing AndAlso Location.File(Compiler).IsOptionStrictOn Then
             result = Compiler.Report.ShowMessage(Messages.VBNC30209, Me.Location) AndAlso result
         End If
 
         result = m_ConstantExpression.ResolveExpression(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="1905" endline="1938">
<![CDATA[
 
     ''' <summary>
     ''' MemberAccessExpression 
     ''' MemberAccessBase 
     ''' 
     ''' TODO
     ''' LAMESPEC
     ''' MemberAccessExpression 
     ''' </summary>
     ''' <param name="FirstExpression"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseMemberAccessExpression(ByVal Parent As ParsedObject, ByVal FirstExpression As Expression) As MemberAccessExpression
         Dim result As New MemberAccessExpression(Parent)
 
         Dim m_First As Expression
         Dim m_Second As IdentifierOrKeywordWithTypeArguments
 
         m_First = FirstExpression 'Might be nothing.
         If m_First IsNot Nothing Then m_First.Parent = result
         'According to the language specification, the dot is optional,
         'but that doesn't seem to be correct... so let's make it 
         'required
         tm.AcceptIfNotInternalError(KS.Dot)
         'Specifically, this is not a MemberAccessExpression without the
         'dot, so it is an internal error.
         tm.AcceptNewLine()
         m_Second = ParseIdentifierOrKeywordWithTypeArguments(result)
         If m_Second Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_First, m_Second)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ReturnStatement.vb" startline="87" endline="103">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Test.ResolveExpression(Info) AndAlso result
         If result = False Then Return False
 
         result = Helper.VerifyValueClassification(m_Test, Info) AndAlso result
         If result = False Then Return False
 
         m_CachedTest = New CachedExpression(m_Test, m_Test)
 
         result = m_Cases.ResolveCode(info) AndAlso result
 
         Compiler.Helper.AddCheck("Check that there is at most one else block, and only at the end.")
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\InterfaceDeclaration.vb" startline="60" endline="75">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_InterfaceBases IsNot Nothing Then
             result = m_InterfaceBases.ResolveTypeReferences AndAlso result
             For i As Integer = 0 To m_InterfaceBases.Bases.Length - 1
                 AddInterface(m_InterfaceBases.Bases(i).ResolvedType)
             Next
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="398" endline="429">
<![CDATA[
 
     ''' <summary>
     ''' ImportsNamespaceClause  
     ''' 
     ''' ConstructedTypeName  
     '''	QualifiedIdentifier  "("  "Of"  TypeArgumentList  ")"
     '''    
     ''' Only namespaces, classes, structures, enumerated types, and standard modules may be imported.
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseImportsNamespaceClause(ByVal Parent As ParsedObject) As ImportsNamespaceClause
         Dim result As New ImportsNamespaceClause(Parent)
 
         Dim iCurrent As RestorablePoint = tm.GetRestorablePoint
         Dim qi As QualifiedIdentifier
 
         qi = ParseQualifiedIdentifier(result)
         If qi Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If result IsNot Nothing AndAlso tm.CurrentToken = KS.LParenthesis AndAlso tm.PeekToken = KS.Of Then
             Dim ctn As ConstructedTypeName = Nothing
             tm.RestoreToPoint(iCurrent)
             ctn = ParseConstructedTypeName(result)
             If ctn Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(ctn)
         Else
             tm.IgnoreRestoredPoint()
             result.Init(qi)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="172" endline="184">
<![CDATA[
 
     ''' <summary>
     ''' The state of the Option Explicit flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionExplicitOn() As Boolean
         Get
             If m_OptionExplicit Is Nothing Then
                 Return Compiler.CommandLine.OptionExplicit = CommandLine.OptionExplicitTypes.On
             Else
                 Return m_OptionExplicit.IsOn
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="185" endline="198">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The state of the Option Strict flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionStrictOn() As Boolean
         Get
             If m_OptionStrict Is Nothing Then
                 Return Compiler.CommandLine.OptionStrict = CommandLine.OptionStrictTypes.On
             Else
                 Return m_OptionStrict.IsOn
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="199" endline="212">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The state of the Option Compare flag in this file.
     ''' Looks up in commandline options if not set.
     ''' </summary>
     ReadOnly Property IsOptionCompareBinary() As Boolean
         Get
             If m_OptionCompare Is Nothing Then
                 Return Compiler.CommandLine.OptionCompare = CommandLine.OptionCompareTypes.Binary
             Else
                 Return m_OptionCompare.IsBinary
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="213" endline="222">
<![CDATA[
     End Property
 
     Public Shadows ReadOnly Property IsOptionInferOn As Boolean
         Get
             If m_OptionInfer Is Nothing Then
                 Return Compiler.CommandLine.OptionInfer = CommandLine.OptionInferTypes.On
             Else
                 Return m_OptionInfer.IsOn
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="433" endline="442">
<![CDATA[
 #End Region
 
     Private Sub ParseEndOfLine()
         If m_Current.IsEndOfLine = False Then
             Helper.AddError(Me.Compiler, GetCurrentLocation, "Expected end of line")
             EatLine(False)
             Return
         End If
         'Me.NextUnconditionally()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1149" endline="1156">
<![CDATA[
 
     Shared Sub EmitLoadI4Value(ByVal Info As EmitInfo, ByVal I As Boolean)
         If I Then
             EmitLoadI4Value(Info, -1, Info.Compiler.TypeCache.System_Boolean)
         Else
             EmitLoadI4Value(Info, 0, Info.Compiler.TypeCache.System_Boolean)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1325" endline="1338">
<![CDATA[
 
     ''' <summary>
     ''' Loads the boolean value onto the stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Value"></param>
     ''' <remarks></remarks>
     Overloads Shared Sub EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As Boolean)
         If Value Then
             EmitLoadI4Value(Info, 1, Info.Compiler.TypeCache.System_Boolean)
         Else
             EmitLoadI4Value(Info, 0, Info.Compiler.TypeCache.System_Boolean)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="85" endline="93">
<![CDATA[
         Get
             If m_SymbolDocument Is Nothing Then
                 m_SymbolDocument = New Mono.Cecil.Cil.Document(System.IO.Path.Combine(m_RelativePath.Replace("<"c, "["c).Replace(">"c, "]"c), m_FileName.Replace("<"c, "["c).Replace(">"c, "]"c)))
                 m_SymbolDocument.Language = Cil.DocumentLanguage.Basic
                 m_SymbolDocument.LanguageVendor = Cil.DocumentLanguageVendor.Microsoft
                 m_SymbolDocument.Type = Cil.DocumentType.Text
             End If
             Return m_SymbolDocument
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeConverter.vb" startline="800" endline="809">
<![CDATA[
 
     Private Shared Function GetResultType(ByVal op1 As TypeCode, ByVal op2 As TypeCode, ByVal array As String) As TypeCode
         Dim chr As Char
         chr = array.Chars(op1 + op2 * 19)
         If chr = "X"c Then
             Return Nothing
         Else
             Return CType(Microsoft.VisualBasic.Asc(chr) - Microsoft.VisualBasic.Asc("A"), TypeCode)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\OperatorDeclaration.vb" startline="291" endline="300">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Me.CustomAttributes IsNot Nothing Then
             result = Me.CustomAttributes.GenerateCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="109" endline="115">
<![CDATA[
 
     Sub NextToken(ByVal Jump As Integer)
         Helper.Assert(Jump >= 0)
         For i As Integer = 1 To Jump
             NextToken()
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\PropertyGroupToPropertyAccessExpression.vb" startline="27" endline="34">
<![CDATA[
         Get
             Dim result As String = ""
             If m_PropertyGroup.InstanceExpression IsNot Nothing Then
                 result = m_PropertyGroup.InstanceExpression.AsString & "."
             End If
             result &= m_PropertyGroup.Group(0).Name
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5310" endline="5328">
<![CDATA[
 
     ''' <summary>
     ''' ErrorStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseErrorStatement(ByVal Parent As ParsedObject) As ErrorStatement
         Dim result As New ErrorStatement(Parent)
 
         Dim m_ErrNumber As Expression
 
         tm.AcceptIfNotInternalError(KS.Error)
 
         m_ErrNumber = ParseExpression(result)
         If m_ErrNumber Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_ErrNumber)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="184" endline="192">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveTypeReferences AndAlso result
         If m_ArgumentList IsNot Nothing Then result = m_ArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\DictionaryAccessExpression.vb" startline="42" endline="50">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_FirstPart IsNot Nothing Then result = m_FirstPart.ResolveTypeReferences AndAlso result
         If m_SecondPart IsNot Nothing Then result = m_SecondPart.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\LateBoundAccessToValueExpression.vb" startline="46" endline="57">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_First IsNot Nothing Then result = m_First.ResolveTypeReferences AndAlso result
         If m_Second IsNot Nothing Then result = m_Second.ResolveTypeReferences AndAlso result
 
         ' If m_TypeArguments IsNot Nothing Then result = m_TypeArguments.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AliasClause.vb" startline="32" endline="39">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_BoundList IsNot Nothing Then result = m_BoundList.ResolveTypeReferences AndAlso result
         If m_ArrayTypeModifiers IsNot Nothing Then result = m_ArrayTypeModifiers.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="32" endline="39">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Event IsNot Nothing Then result = m_Event.ResolveTypeReferences AndAlso result
         If m_EventHandler IsNot Nothing Then result = m_EventHandler.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\CallStatement.vb" startline="54" endline="63">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Expression1 IsNot Nothing Then result = m_Expression1.ResolveTypeReferences AndAlso result
         If m_Expression2 IsNot Nothing Then result = m_Expression2.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\OptionStrictStatement.vb" startline="35" endline="42">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Event IsNot Nothing Then result = m_Event.ResolveTypeReferences AndAlso result
         If m_Arguments IsNot Nothing Then result = m_Arguments.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\OptionStrictStatement.vb" startline="51" endline="58">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Expression IsNot Nothing Then result = m_Expression.ResolveTypeReferences AndAlso result
         If m_ArraySizeInitModifier IsNot Nothing Then result = m_ArraySizeInitModifier.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ReturnStatement.vb" startline="53" endline="62">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Test IsNot Nothing Then result = m_Test.ResolveTypeReferences AndAlso result
         If m_Cases IsNot Nothing Then result = m_Cases.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="485" endline="491">
<![CDATA[
 
     Function IsIntegralType(ByVal Type As TypeCode) As Boolean
         For Each t As Mono.Cecil.TypeReference In IntegralTypes
             If Helper.GetTypeCode(Compiler, t) = Type Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="70" endline="88">
<![CDATA[
     End Property
 
     Function DefineHandlesOrImplements() As Boolean
         Dim result As Boolean = True
 
         If m_HandlesOrImplements IsNot Nothing Then
             Dim hclause As HandlesClause = m_HandlesOrImplements.HandlesClause
             Dim iclause As MemberImplementsClause = m_HandlesOrImplements.ImplementsClause
             If hclause IsNot Nothing Then
                 'Helper.NotImplemented()
             ElseIf iclause IsNot Nothing Then
                 result = iclause.DefineImplements(Me.CecilBuilder)
             Else
                 Throw New InternalException(Me)
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4718" endline="4740">
<![CDATA[
 
     ''' <summary>
     ''' AliasClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAliasClause(ByVal Parent As ParsedObject) As AliasClause
         Dim result As New AliasClause(Parent)
 
         Dim m_StringLiteral As Token = Nothing
 
         tm.AcceptIfNotInternalError(KS.Alias)
 
         If tm.CurrentToken.IsStringLiteral Then
             m_StringLiteral = tm.CurrentToken
             tm.NextToken()
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         End If
 
         result.Init(m_StringLiteral)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4741" endline="4764">
<![CDATA[
 
     ''' <summary>
     ''' LibraryClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseLibraryClause(ByVal Parent As ParsedObject) As LibraryClause
         Dim result As New LibraryClause(Parent)
 
         Dim m_StringLiteral As Token
 
         tm.AcceptIfNotInternalError(KS.Lib)
 
         If tm.CurrentToken.IsStringLiteral Then
             m_StringLiteral = tm.CurrentToken
             tm.NextToken()
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
             m_StringLiteral = Nothing
         End If
 
         result.Init(m_StringLiteral)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MemberCache.vb" startline="241" endline="252">
<![CDATA[
 
     Private Sub Flatten(ByVal Name As String, ByVal Visibility As MemberVisibility)
         Dim bases As List(Of MemberCache) = GetBaseCache()
 
         If bases.Count = 0 Then
             Flatten(Name, Nothing, Visibility)
         Else
             For i As Integer = 0 To bases.Count - 1
                 Flatten(Name, bases(i), Visibility)
             Next
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="322" endline="335">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
         result = ResolveOverrides() AndAlso result
         result = m_Signature.ResolveCode(Info) AndAlso result
 
         If m_Code IsNot Nothing Then
             result = m_Code.ResolveCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="42" endline="59">
<![CDATA[
     End Property
 
     Overridable ReadOnly Property AsTypeString() As String
         Get
             If m_Expression Is Nothing Then
                 Return "Nothing"
             Else
                 If m_Expression.ExpressionType Is Nothing Then
                     Return "(Nothing)"
                 Else
                     If m_Expression.ExpressionType.FullName = "" Then
                         Return m_Expression.ExpressionType.Name
                     Else
                         Return m_Expression.ExpressionType.FullName
                     End If
                 End If
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="96" endline="110">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If HandlesClause IsNot Nothing Then
             result = HandlesClause.ResolveTypeReferences AndAlso result
         ElseIf ImplementsClause IsNot Nothing Then
             result = ImplementsClause.ResolveTypeReferences AndAlso result
         Else
             Helper.Stop()
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="787" endline="804">
<![CDATA[
 
     Private Function ResolveAliasImports(ByVal imps As ImportsClauses, ByVal Name As String) As Boolean
         Dim import As ImportsClause = imps.Item(Name)
         Dim nsimport As ImportsNamespaceClause
         If import IsNot Nothing Then
             nsimport = import.AsAliasClause.NamespaceClause
             If nsimport.IsNamespaceImport Then
                 Classification = New NamespaceClassification(Me, nsimport.NamespaceImported)
                 Return True
             ElseIf nsimport.IsTypeImport Then
                 Classification = New TypeClassification(Me, nsimport.TypeImported)
                 Return True
             Else
                 Throw New InternalException(Me)
             End If
         End If
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="661" endline="687">
<![CDATA[
 
     Private Delegate Function ParseDelegate_Parent(Of T)(ByVal Parent As ParsedObject) As T
 
     ''' <summary>
     ''' VariablePropertyInitializer  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseVariablePropertyInitializer(ByVal Parent As ParsedObject) As VariablePropertyInitializer
         Dim result As New VariablePropertyInitializer(Parent)
 
         Dim m_IdentifierOrKeyword As IdentifierOrKeyword
         Dim m_AttributeArgumentExpression As AttributeArgumentExpression
 
         m_IdentifierOrKeyword = ParseIdentifierOrKeyword(result)
         If m_IdentifierOrKeyword Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         tm.AcceptIfNotInternalError(KS.Colon)
         tm.AcceptIfNotInternalError(KS.Equals)
         tm.AcceptNewLine()
 
         m_AttributeArgumentExpression = ParseAttributeArgumentExpression(result)
         If m_AttributeArgumentExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_IdentifierOrKeyword, m_AttributeArgumentExpression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" startline="64" endline="78">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(EventParent.EventType IsNot Nothing)
         If Signature.Parameters.Count = 0 Then
             Dim param As New Parameter(Signature.Parameters, "obj", EventParent.EventType)
             Signature.Parameters.Add(param)
             result = param.CreateDefinition AndAlso result
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="150" endline="168">
<![CDATA[
 
     ''' <summary>
     ''' Searches the namespaces of the current compiling assembly / referenced assemblies to check
     ''' if the name is a namespace.
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsNamespace(ByVal Name As String, ByVal onlyExact As Boolean) As Boolean
         Name = vbnc.Namespace.RemoveGlobal(Name)
         If ContainsKey(Name) Then
             Return True
         ElseIf onlyExact = False Then
             For Each strNS As [Namespace] In Me
                 If strNS.StartsWith(Name) Then Return True
             Next
         End If
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="953" endline="977">
<![CDATA[
 
     ''' <summary>
     ''' TypeImplementsClause  
     ''' Implements  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeImplementsClauses(ByVal Parent As ParsedObject) As TypeImplementsClauses
         Dim result As New TypeImplementsClauses(Parent)
 
         Dim m_Clauses As New Generic.List(Of NonArrayTypeName)
 
         Do While tm.Accept(KS.Implements)
             Do
                 Dim newI As NonArrayTypeName
                 newI = ParseNonArrayTypeName(result)
                 If newI Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 m_Clauses.Add(newI)
             Loop While tm.Accept(KS.Comma)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Loop
         Do While tm.Accept(KS.Implements)
             Do
                 Dim newI As NonArrayTypeName
                 newI = ParseNonArrayTypeName(result)
                 If newI Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 m_Clauses.Add(newI)
             Loop While tm.Accept(KS.Comma)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Loop
 
         result.Init(m_Clauses)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2655" endline="2681">
<![CDATA[
     ''' <summary>
     ''' A single identifier followed by an optional type argument list.
     ''' 
     ''' SimpleNameExpression 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSimpleNameExpression(ByVal Parent As ParsedObject) As SimpleNameExpression
         Dim result As New SimpleNameExpression(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_TypeArgumentList As TypeArgumentList
 
         m_Identifier = ParseIdentifier(result)
         If result Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.CurrentToken = KS.LParenthesis AndAlso tm.PeekToken = KS.Of Then
             m_TypeArgumentList = ParseTypeArgumentList(result)
             If m_TypeArgumentList Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             'If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented()
         Else
             m_TypeArgumentList = Nothing
         End If
 
         result.Init(m_Identifier, m_TypeArgumentList)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4241" endline="4267">
<![CDATA[
 
     ''' <summary>
     ''' Operand  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOperand(ByVal Parent As ParsedObject) As Operand
         Dim result As New Operand(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_TypeName As TypeName
 
         tm.Accept(KS.ByVal)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeName = Nothing
         End If
 
         result.Init(m_Identifier, m_TypeName)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="43" endline="53">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_NonArrayTypeName IsNot Nothing Then result = m_NonArrayTypeName.ResolveTypeReferences AndAlso result
         If m_ArrayNameModifier IsNot Nothing Then result = m_ArrayNameModifier.ResolveTypeReferences AndAlso result
         If m_ArrayElementInitializer IsNot Nothing Then result = m_ArrayElementInitializer.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="592" endline="606">
<![CDATA[
 
     Sub RemoveNarrowingExceptObject(ByVal error_lines As Generic.List(Of String))
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate.IsRemoved("RemoveNarrowingExceptObject") Then Continue For
 
             If candidate.IsNarrowingInternal(True, error_lines) Then
                 Log("NARROWING (EXCEPT OBJECT)    
                 m_Candidates(i).RemovedBy = "RemoveNarrowingExceptObject"
             Else
                 Log("NOT NARROWING (EXCEPT OBJECT)
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\AssignStatements\MidAssignStatement.vb" startline="44" endline="54">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Target IsNot Nothing Then result = m_Target.ResolveTypeReferences AndAlso result
         If m_Start IsNot Nothing Then result = m_Start.ResolveTypeReferences AndAlso result
         If m_Length IsNot Nothing Then result = m_Length.ResolveTypeReferences AndAlso result
         If m_Source IsNot Nothing Then result = m_Source.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="59" endline="71">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ArrayNameModifier IsNot Nothing Then result = m_ArrayNameModifier.ResolveTypeReferences AndAlso result
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveTypeReferences AndAlso result
         If m_Expression IsNot Nothing Then result = m_Expression.ResolveTypeReferences AndAlso result
 
         If m_Declaration IsNot Nothing Then result = m_Declaration.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeCache.vb" startline="350" endline="376">
<![CDATA[
 
     Protected Function GetVBType(ByVal Name As String) As Mono.Cecil.TypeDefinition
         Dim result As Mono.Cecil.TypeDefinition = Nothing
 
         If String.IsNullOrEmpty(Compiler.CommandLine.VBRuntime) AndAlso vbruntime Is Nothing Then
             Dim tps As Generic.List(Of Mono.Cecil.TypeReference)
             tps = Compiler.TypeManager.GetType(Name, True)
 
             If tps.Count = 1 Then
                 result = CecilHelper.FindDefinition(tps(0))
 #If DEBUG Then
             ElseIf tps.Count > 1 Then
                 Compiler.Report.WriteLine("Found " & tps.Count & " types with the name " & Name)
 #End If
             End If
         Else
             result = [GetType](vbruntime, Name)
         End If
 
 #If DEBUG Then
         If result Is Nothing Then
             Compiler.Report.WriteLine("Could not load VB Type
         End If
 #End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="896" endline="927">
<![CDATA[
 
     ''' <summary>
     ''' ArraySizeInitializationModifier  
     ''' LAMESPEC this might be correct? REMOVED, CURRENTLY USING ^ SPEC!
     ''' ArraySizeInitializationModifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArraySizeInitializationModifer(ByVal Parent As ParsedObject) As ArraySizeInitializationModifier
         Dim result As New ArraySizeInitializationModifier(Parent)
 
         Dim m_BoundList As BoundList = Nothing
         Dim m_ArrayTypeModifiers As ArrayTypeModifiers = Nothing
 
         tm.AcceptIfNotInternalError(KS.LParenthesis)
 
         m_BoundList = ParseBoundList(result)
         If m_BoundList Is Nothing Then
             If m_ShowErrors = False Then Return Nothing
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If vbnc.ArrayTypeModifiers.CanBeMe(tm) Then
             m_ArrayTypeModifiers = ParseArrayTypeModifiers(result)
             If m_ArrayTypeModifiers Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_BoundList, m_ArrayTypeModifiers)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="1939" endline="1964">
<![CDATA[
 
     Private Function ParseIdentifierOrKeywordWithTypeArguments(ByVal Parent As ParsedObject) As IdentifierOrKeywordWithTypeArguments
         Dim result As New IdentifierOrKeywordWithTypeArguments(Parent)
 
         Dim m_TypeArguments As TypeArgumentList
         Dim m_Token As Token
 
         If tm.CurrentToken.IsIdentifierOrKeyword Then
             m_Token = tm.CurrentToken
             tm.NextToken()
         Else
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Return Nothing
         End If
 
         If tm.CurrentToken.Equals(KS.LParenthesis) AndAlso tm.PeekToken.Equals(KS.Of) Then
             m_TypeArguments = ParseTypeArgumentList(result)
             If m_TypeArguments Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeArguments = Nothing
         End If
 
         result.Init(m_Token, m_TypeArguments)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="727" endline="773">
<![CDATA[
 
 
 
     ''' <summary>
     ''' Type | QualifiedIdentifier ( Of [TypeArityList] )
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseGetTypeTypeName(ByVal Parent As GetTypeExpression) As GetTypeTypeName
         'TypeName |
         'QualifiedIdentifier (Of [TypeArityList])
         'TypeArityList 
         ' , |
         ' TypeParameterList ,
         Dim result As New GetTypeTypeName(Parent)
 
         'First try to parse as typename, if no 
         'success try as qualifiedidentifier.
         Dim m_TypeName As TypeName
         Dim iCurPos As RestorablePoint = tm.GetRestorablePoint
 
         m_TypeName = ParseTypeName(result)
         If m_TypeName Is Nothing Then
             tm.RestoreToPoint(iCurPos)
 
             Dim qn As QualifiedIdentifier
 
             qn = ParseQualifiedIdentifier(result)
             If qn Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             tm.AcceptIfNotInternalError(KS.LParenthesis)
             tm.AcceptIfNotError(KS.Of)
 
             Dim typeArity As Integer = 1
             Do While tm.Accept(KS.Comma)
                 typeArity += 1
             Loop
             Do While tm.Accept(KS.Comma)
                 typeArity += 1
             Loop
 
             tm.AcceptIfNotError(KS.RParenthesis)
 
             result.Init(qn, typeArity)
         Else
             tm.IgnoreRestoredPoint()
             result.Init(m_TypeName)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MemberCache.vb" startline="457" endline="482">
<![CDATA[
 
     Private Function GetBaseCache() As List(Of MemberCache)
         Dim base As Mono.Cecil.TypeReference
         Dim cache As MemberCache
 
         If m_Bases IsNot Nothing Then Return m_Bases
 
         m_Bases = New List(Of MemberCache)
 
         For i As Integer = 0 To m_Types.Count - 1
             base = CecilHelper.FindDefinition(m_Types(i)).BaseType
 
             If base Is Nothing Then Continue For
 
             base = CecilHelper.InflateType(base, m_Type)
 
             If m_Compiler.TypeManager.MemberCache.ContainsKey(base) = False Then
                 cache = New MemberCache(m_Compiler, base)
             Else
                 cache = m_Compiler.TypeManager.MemberCache(base)
             End If
             m_Bases.Add(cache)
         Next
 
         Return m_Bases
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="6085" endline="6117">
<![CDATA[
 
     ''' <summary>
     ''' AddHandlerStatement  
     ''' RemoveHandlerStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAddOrRemoveHandlerStatement(ByVal Parent As ParsedObject) As AddOrRemoveHandlerStatement
         Dim result As New AddOrRemoveHandlerStatement(Parent)
 
         Dim m_Event As Expression
         Dim m_EventHandler As Expression
         Dim m_IsAddHandler As Boolean
 
         If tm.Accept(KS.AddHandler) Then
             m_IsAddHandler = True
         ElseIf tm.Accept(KS.RemoveHandler) Then
             m_IsAddHandler = False
         Else
             Throw New InternalException(result)
         End If
 
         m_Event = ParseExpression(result)
         If m_Event Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Comma) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_EventHandler = ParseExpression(result)
         If m_EventHandler Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Event, m_EventHandler, m_IsAddHandler)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="1745" endline="1777">
<![CDATA[
 
     ''' <summary>
     ''' ParametersOrType  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseParametersOrType(ByVal Parent As ParsedObject) As ParametersOrType
         Dim result As New ParametersOrType(Parent)
 
         Dim m_NonArrayTypeName As NonArrayTypeName
         Dim m_ParameterList As ParameterList
 
         If tm.Accept(KS.As) Then
             m_NonArrayTypeName = ParseNonArrayTypeName(result)
             result.Init(m_NonArrayTypeName)
         Else
             m_ParameterList = New ParameterList(result)
             If tm.Accept(KS.LParenthesis) Then
                 If tm.Accept(KS.RParenthesis) = False Then
                     If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                         Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                     End If
                     If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 Else
                     m_ParameterList = New ParameterList(result)
                 End If
                 result.Init(m_ParameterList)
             Else
                 result.Init(m_ParameterList)
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeCache.vb" startline="275" endline="299">
<![CDATA[
 
     Protected Function GetMethod(ByVal Type As Mono.Cecil.TypeDefinition, ByVal Name As String, ByVal ParamArray Types() As Mono.Cecil.TypeReference) As Mono.Cecil.MethodDefinition
         Dim result As Mono.Cecil.MethodDefinition = Nothing
         If Type Is Nothing Then
 #If DEBUG Then
             Compiler.Report.WriteLine("Could not load the method '" & Name & "', the specified type was Nothing.")
 #End If
             Return Nothing
         End If
 
         For i As Integer = 0 To Type.Methods.Count - 1
             Dim md As MethodDefinition = Type.Methods(i)
             If Helper.CompareNameOrdinal(md.Name, Name) = False Then Continue For
             If Helper.CompareTypes(Helper.GetTypes(md.Parameters), Types) = False Then Continue For
             result = md
             Exit For
         Next
 #If DEBUG Then
         If result Is Nothing Then
             Compiler.Report.WriteLine(Report.ReportLevels.Debug, "Could not find the method '" & Name & "' on the type '" & Type.FullName)
         End If
 #End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="187" endline="201">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
         If m_Signature IsNot Nothing Then result = m_Signature.ResolveTypeReferences AndAlso result
         If m_Get IsNot Nothing Then result = m_Get.ResolveTypeReferences AndAlso result
         If m_Set IsNot Nothing Then result = m_Set.ResolveTypeReferences AndAlso result
 
         m_CecilBuilder.PropertyType = Helper.GetTypeOrTypeReference(Compiler, Me.Signature.ReturnType)
 
         If m_MemberImplementsClause IsNot Nothing Then result = m_MemberImplementsClause.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\VariableInitializerList.vb" startline="39" endline="46">
<![CDATA[
 
     ReadOnly Property Identifier() As String
         Get
             If m_Identifier IsNot Nothing Then
                 Return m_Identifier
             End If
             Return m_IdentifierOrKeyword.Identifier
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="314" endline="321">
<![CDATA[
 
     Public Overridable Function ResolveMember(ByVal Info As ResolveInfo) As Boolean Implements INonTypeMember.ResolveMember
         Dim result As Boolean = True
 
         result = m_Signature.Parameters.ResolveParameters(Info, True) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\AbstractMediaHandler.vb" startline="343" endline="349">
<![CDATA[
 
     Protected Function OutFileCheck() As Boolean
         If IO.File.Exists(mOutFile) Then
             Dim fi As New IO.FileInfo(mOutFile)
             If fi.Length > 0 Then Return True
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4900" endline="4914">
<![CDATA[
 
     Private Function ParseTypeVariableDeclarator(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal Info As ParseAttributableInfo) As Generic.List(Of TypeVariableDeclaration)
         Dim result As New Generic.List(Of TypeVariableDeclaration)
         Dim tmp As Boolean
 
         'Console.Write("ParseTypeVariableDeclarator...")
         tmp = ParseVariableDeclarator(Parent, Modifiers, Info, result, False)
         'Console.WriteLine("tmp
         If tmp = False Then
             'Console.WriteLine("tmp was false")
             Return Nothing
         End If
         'Console.WriteLine("tmp was true")
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="166" endline="173">
<![CDATA[
 
     Function ResolveMember(ByVal Info As ResolveInfo) As Boolean Implements INonTypeMember.ResolveMember
         Dim result As Boolean = True
         
         If m_ConstantExpression IsNot Nothing Then result = m_ConstantExpression.ResolveExpression(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="150" endline="157">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_CustomAttributes IsNot Nothing Then result = m_CustomAttributes.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ParametersOrType.vb" startline="52" endline="60">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_ParameterList IsNot Nothing Then result = m_ParameterList.ResolveCode(info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4891" endline="4899">
<![CDATA[
 
     Private Function ParseLocalVariableDeclarator(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal Info As ParseAttributableInfo) As Generic.List(Of LocalVariableDeclaration)
         Dim result As New Generic.List(Of LocalVariableDeclaration)
         If ParseVariableDeclarator(Parent, Modifiers, Info, result, True) = False Then
             Console.WriteLine("Returned false")
             Return Nothing
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="466" endline="482">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="Special"></param>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Accept(ByVal Special As KS, Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.Equals(Special) Then
             Accept = True
             NextToken()
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Accept = False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="501" endline="513">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     Function Accept(ByVal Identifier As String, Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.Equals(Identifier) Then
             Accept = True
             NextToken()
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Accept = False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="112" endline="121">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_HandlesOrImplements IsNot Nothing Then result = m_HandlesOrImplements.ResolveCode(Info) AndAlso result
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\EventAccessorDeclarations.vb" startline="174" endline="183">
<![CDATA[
 
     Public Function ResolveMember(ByVal Info As ResolveInfo) As Boolean Implements INonTypeMember.ResolveMember
         Dim result As Boolean = True
 
         If m_ImplementsClause IsNot Nothing Then result = m_ImplementsClause.ResolveCode(Info) AndAlso result
 
         Helper.Assert(EventType IsNot Nothing)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\AbstractMediaHandler.vb" startline="26" endline="37">
<![CDATA[
 
     Public ReadOnly Property ValidExtenstions(ByVal Enabled As Boolean) As String
         Get
             Dim Temp As String = ".mpg|.mpeg|.wmv|.asf|.wma|.avi|.mp3|.moviclip"
             For i As Integer = 0 To mList.Count - 1
                 Dim Tool As ToolSpec = DirectCast(mList(i), ToolSpec)
                 If Tool.Enabled = Enabled Then
                     Temp += "|" + Tool.Extensions
                 End If
             Next
             Return Temp
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ParameterList.vb" startline="32" endline="40">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal ParameterTypes() As Mono.Cecil.TypeReference)
         MyBase.new(Parent)
         If ParameterTypes IsNot Nothing Then
             For Each t As Mono.Cecil.TypeReference In ParameterTypes
                 Add("", t)
             Next
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\SubSignature.vb" startline="96" endline="105">
<![CDATA[
 
     Public Overrides Function CreateDefinition() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.CreateDefinition AndAlso result
         If m_TypeParameters IsNot Nothing Then result = m_TypeParameters.CreateDefinition AndAlso result
         If m_ParameterList IsNot Nothing Then result = m_ParameterList.CreateDefinition AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ReturnStatement.vb" startline="89" endline="99">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Catches IsNot Nothing Then result = m_Catches.ResolveTypeReferences() AndAlso result
         If m_FinallyBlock IsNot Nothing Then result = m_FinallyBlock.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="268" endline="285">
<![CDATA[
     End Property
 
     ReadOnly Property HasMethodBody() As Boolean
         Get
             Dim result As Boolean
 
             If TypeOf Me Is ExternalSubDeclaration Then Return False
 
             result = CBool(MethodAttributes And Mono.Cecil.MethodAttributes.Abstract) = False AndAlso CBool(MethodImplAttributes And Mono.Cecil.MethodImplAttributes.Runtime) = False
 
             If result Then
                 If Me.CustomAttributes IsNot Nothing AndAlso Me.CustomAttributes.IsDefined(Compiler.TypeCache.System_Runtime_InteropServices_DllImportAttribute) Then
                     result = False
                 End If
             End If
 
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="112" endline="127">
<![CDATA[
 
     Public Overrides Function GetConstant(ByRef result As Object, ByVal ShowError As Boolean) As Boolean
         Dim rvalue As Object = Nothing
         Dim lvalue As Object = Nothing
 
         If Not m_LeftExpression.GetConstant(lvalue, ShowError) Then Return False
         If Not m_RightExpression.GetConstant(rvalue, ShowError) Then Return False
 
         If lvalue Is Nothing Or rvalue Is Nothing Then
             result = True
             Return True
         End If
 
         If ShowError Then Show30059()
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2526" endline="2554">
<![CDATA[
 
     ''' <summary>
     ''' DelegateCreationExpression 
     ''' ObjectCreationExpression   
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDelegateOrObjectCreationExpression(ByVal Parent As ParsedObject) As DelegateOrObjectCreationExpression
         Dim result As New DelegateOrObjectCreationExpression(Parent)
 
         Dim m_NonArrayTypeName As NonArrayTypeName = Nothing
         Dim m_ArgumentList As ArgumentList = Nothing
 
         tm.AcceptIfNotInternalError(KS.[New])
         m_NonArrayTypeName = ParseNonArrayTypeName(result)
 
         If tm.Accept(KS.LParenthesis) Then
             If tm.CurrentToken <> KS.RParenthesis Then
                 m_ArgumentList = ParseArgumentList(result)
                 If m_ArgumentList Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         If m_ArgumentList Is Nothing Then m_ArgumentList = New ArgumentList(result)
 
         result.Init(m_NonArrayTypeName, m_ArgumentList)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2230" endline="2261">
<![CDATA[
 
     ''' <summary>
     ''' VariableIdentifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseVariableIdentifier(ByVal Parent As ParsedObject) As VariableIdentifier
         Dim result As New VariableIdentifier(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_ArrayNameModifier As ArrayNameModifier
 
         If tm.CurrentToken.IsIdentifier = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, tm.CurrentLocation)
             Return Nothing
         End If
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Interrogation) Then result.IsNullable = True
 
         If vbnc.ArrayNameModifier.CanBeMe(tm) Then
             m_ArrayNameModifier = ParseArrayNameModifier(result)
             If m_ArrayNameModifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_ArrayNameModifier = Nothing
         End If
 
         result.Init(m_Identifier, m_ArrayNameModifier)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="195" endline="225">
<![CDATA[
 
     Public Shared Function GetCorrectMember(ByVal Member As PropertyDefinition, ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.PropertyReference
         Dim result As Mono.Cecil.PropertyDefinition
         Dim genericType As Mono.Cecil.GenericInstanceType = TryCast(Type, Mono.Cecil.GenericInstanceType)
         Dim propertyType As Mono.Cecil.TypeReference
         Dim getMethod As Mono.Cecil.MethodReference = Nothing
         Dim setMethod As Mono.Cecil.MethodReference = Nothing
 
         If genericType Is Nothing Then Return Member
 
         propertyType = CecilHelper.ResolveType(Member.PropertyType, Member.DeclaringType.GenericParameters, genericType.GenericArguments)
         propertyType = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, propertyType)
 
         If Member.GetMethod IsNot Nothing Then
             getMethod = GetCorrectMember(Member.GetMethod, Type)
         End If
 
         If Member.SetMethod IsNot Nothing Then
             setMethod = GetCorrectMember(Member.SetMethod, Type)
         End If
 
         'If propertyType Is Member.PropertyType AndAlso (getMethod Is Nothing OrElse Member.GetMethod Is getMethod) AndAlso (setMethod Is Nothing OrElse Member.SetMethod Is setMethod) Then
         'Return Member
         'End If
         result = New Mono.Cecil.PropertyDefinition(Member.Name, Member.Attributes, propertyType)
         result.DeclaringType = genericType
         result.SetMethod = setMethod
         result.GetMethod = getMethod
         result.Annotations.Add("OriginalProperty", Member)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4122" endline="4155">
<![CDATA[
 
     ''' <summary>
     ''' MustOverridePropertyMemberDeclaration  
     '''	[  Attributes  ]  [  MustOverridePropertyModifier+  ]  "Property" FunctionSignature  [  ImplementsClause  ]
     '''		StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseMustOverridePropertyMemberDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As MustOverridePropertyDeclaration
         Dim result As New MustOverridePropertyDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As FunctionSignature = Nothing
         Dim m_ImplementsClause As MemberImplementsClause = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.MustOverridePropertyModifiers)
 
         tm.AcceptIfNotInternalError(KS.Property)
 
         m_Signature = ParseFunctionSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         result.Signature = m_Signature
 
         If MemberImplementsClause.IsMe(tm) Then
             m_ImplementsClause = ParseImplementsClause(result)
             If m_ImplementsClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, , , m_ImplementsClause)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="73" endline="95">
<![CDATA[
 
     ReadOnly Property CanBeExpression() As Boolean
         Get
             Dim result As Boolean = False
 
             If m_Group IsNot Nothing Then Return m_Group.DefaultInstanceAlias IsNot Nothing
 
             If Compiler.Assembly.GroupedClasses Is Nothing Then Return False
 
             If m_Type Is Nothing Then Return False
 
             For Each data As MyGroupData In Compiler.Assembly.GroupedClasses
                 If data.DefaultInstanceAlias Is Nothing Then Continue For
                 If data.TypeToCollect Is Nothing Then Continue For
                 If Helper.IsSubclassOf(data.TypeToCollect, m_Type) = False Then Continue For
 
                 m_Group = data
 
                 Return True
             Next
 
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="26" endline="32">
<![CDATA[
 
     Sub AddType(ByVal Type As Mono.Cecil.TypeReference)
         Dim [namespace] As String = Type.Namespace
 
         If [namespace] Is Nothing Then [namespace] = String.Empty
         GetTypes([namespace]).Add(Type)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeImplementsClauses.vb" startline="90" endline="98">
<![CDATA[
 
     ReadOnly Property FoundObject() As Object
         Get
             If FoundOnlyOneObject = False Then
                 Throw New InternalException("")
             Else
                 Return m_FoundObjects(0)
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2353" endline="2367">
<![CDATA[
 
 
     Private Function ParseUnaryMinusExpression(ByVal Info As ExpressionParseInfo) As UnaryMinusExpression
         Dim result As New UnaryMinusExpression(Info.Parent)
 
         Dim m_Expression As Expression
         tm.AcceptIfNotInternalError(KS.Minus)
 
         m_Expression = ParseExponent(Info)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2412" endline="2425">
<![CDATA[
 
     Private Function ParseUnaryPlusExpression(ByVal Info As ExpressionParseInfo) As UnaryPlusExpression
         Dim result As New UnaryPlusExpression(Info.Parent)
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.Add)
 
         m_Expression = ParseExponent(Info)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1889" endline="1899">
<![CDATA[
 
     Shared Sub EmitStoreField(ByVal Info As EmitInfo, ByVal Field As Mono.Cecil.FieldReference)
         Dim Field2 As Mono.Cecil.FieldReference = Field
         Field2 = Emitter.GetFieldRef(Field2)
         Field2 = Helper.GetFieldOrFieldBuilder(Info.Compiler, Field2)
         If CecilHelper.IsStatic(Field) Then
             Info.ILGen.Emit(OpCodes.Stsfld, Field2)
         Else
             Info.ILGen.Emit(OpCodes.Stfld, Field2)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\AssignStatements\AddAssignStatement.vb" startline="65" endline="76">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim lInfo As EmitInfo = Info.Clone(Me, RSide)
 
         Helper.Assert(LSide.Classification.IsVariableClassification OrElse LSide.Classification.IsPropertyAccessClassification)
         result = LSide.Classification.GenerateCode(lInfo) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" startline="48" endline="63">
<![CDATA[
 
     Public Overrides Function CreateDefinition() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.CreateDefinition AndAlso result
 
         If DeclaringType.IsValueType Then
             Me.MethodImplAttributes = Mono.Cecil.MethodImplAttributes.IL Or Mono.Cecil.MethodImplAttributes.Managed
         ElseIf DeclaringType.IsInterface Then
             Me.MethodImplAttributes = Mono.Cecil.MethodImplAttributes.IL Or Mono.Cecil.MethodImplAttributes.Managed
         Else
             Me.MethodImplAttributes = Mono.Cecil.MethodImplAttributes.IL Or Mono.Cecil.MethodImplAttributes.Managed Or Mono.Cecil.MethodImplAttributes.Synchronized
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\Attributes.vb" startline="36" endline="44">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As Attributes
         If NewParent Is Nothing Then NewParent = DirectCast(Me.Parent, ParsedObject)
         Dim result As New Attributes(NewParent)
         For Each item As Attribute In Me
             result.Add(item.Clone(NewParent))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\LateBoundAccessToPropertyAccessExpression.vb" startline="34" endline="53">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info.IsLHS Then
             If LateBoundAccess.Name Is Nothing Then
                 result = EmitLateindexSet(Info) AndAlso result
             Else
                 result = EmitLateSet(Info) AndAlso result
             End If
         Else
             If LateBoundAccess.Name Is Nothing Then
                 result = EmitLateIndexGet(Info) AndAlso result
             Else
                 result = EmitLateGet(Info) AndAlso result
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2770" endline="2800">
<![CDATA[
 
     Private Sub mPlayer_PlayStateChange(ByVal sender As Object, _
     ByVal e As AxWMPLib._WMPOCXEvents_PlayStateChangeEvent) _
     Handles mPlayer.PlayStateChange
 
         With mPlayer
             Select Case .playState
                 Case WMPLib.WMPPlayState.wmppsStopped
                     'Stop fast play when stopped
                     ' Don't bother when player is paused
                     mFFwd = False
                     mFRev = False
                     .settings.rate = 1
                     FinishTheList()
                     lvPositions.Select()
 
                     mPlaySelected = False       'Restore player to ordinary control
                     Timer.Enabled = False       'Disable timer
                     Me.TopMost = False          'Form is not top most
                 Case WMPLib.WMPPlayState.wmppsPlaying
                     If chkOnTop.Checked Then
                         Me.TopMost = True
                     Else
                         Me.TopMost = False
                     End If
                 Case Else
                     Me.TopMost = False
             End Select
         End With
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3365" endline="3383">
<![CDATA[
 
     Private Sub PasteSelected()
         If mItems(0) Is Nothing Then Exit Sub
         Dim CopyTo As Integer, TempItem As ListViewItem
 
         With lvPositions
             If .SelectedItems.Count = 0 Then
                 CopyTo = .Items.Count - 1
             Else
                 CopyTo = .SelectedItems(0).Index
             End If
             For i As Integer = 1 To mItems.Length
                 TempItem = DirectCast(mItems(i - 1).Clone, ListViewItem)
                 .Items.Insert(CopyTo + i, TempItem)
             Next
         End With
         UpdateSelDur()
         mSelsDirty = True
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="1217" endline="1249">
<![CDATA[
 
     ''' <summary>
     ''' SimpleTypeName 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSimpleTypeName(ByVal Parent As ParsedObject) As SimpleTypeName
         Dim result As New SimpleTypeName(Parent)
 
         If BuiltInTypeName.IsBuiltInTypeName(tm) Then
             Dim m_BuiltInTypeName As BuiltInTypeName
             m_BuiltInTypeName = ParseBuiltinTypeName(result)
             If m_BuiltInTypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             result.Init(m_BuiltInTypeName)
         Else
             Dim m_QualifiedIdentifier As QualifiedIdentifier
 
             If QualifiedIdentifier.CanBeQualifiedIdentifier(tm) = False Then
                 If tm.CurrentToken.IsKeyword Then
                     Compiler.Report.ShowMessage(Messages.VBNC30180, tm.CurrentLocation)
                     tm.NextToken()
                 End If
                 Return Nothing
             End If
 
             m_QualifiedIdentifier = ParseQualifiedIdentifier(result)
             If m_QualifiedIdentifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             result.Init(m_QualifiedIdentifier)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="1968" endline="1998">
<![CDATA[
 
 #End Region
 
 #Region "   Menu items "
 
     Private Sub mnuOpen_Click(ByVal sender As System.Object, _
 ByVal e As System.EventArgs) Handles mnuOpen.Click
 
         If mainTabs.SelectedTab Is tabJoin Then
             OpenFilesForJoining()
         Else
             Dim Filter As String = mStdToolMgr.ValidExtenstions(True)
             Filter = Replace(Filter, ".", "*.")
             Filter = Replace(Filter, "|", ";")
 
             dlgOpenFile.Filter = "Supported Media Files|" & Filter    '*.wmv;*.asf;*.mpg;*.mpeg;*.avi;*.rm";*.flv;*.mp3;*.wma
             dlgOpenFile.Multiselect = False
             If chkDialogView.Checked Then mOpenFileExtender.Enabled = True
 
             If dlgOpenFile.ShowDialog() = Windows.Forms.DialogResult.OK Then
                 Me.Refresh()
                 If Len(dlgOpenFile.FileName) > 0 Then
                     mMaskFile = False
                     OpenFile(dlgOpenFile.FileName)
                 End If
             End If
 
             mOpenFileExtender.Enabled = False
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\MainForm.cs" startline="508" endline="525">
<![CDATA[
 
 		private void unauthorizeFobMenuItem_Click(object sender, EventArgs e)
 		{
 			lock(keyFobView)
 			{
 				foreach(ListViewItem lvi in keyFobView.SelectedItems)
 				{
 					pm.UnauthorizeFob(pm.KeyFobs[lvi.Text]);
 					settings.RemoveKeyFob(pm.KeyFobs[lvi.Text].SerialNumber);
 				}
 				foreach(ListViewItem lvi in keyFobView.SelectedItems)
 				{
 					pm.UnauthorizeFob(pm.KeyFobs[lvi.Text]);
 					settings.RemoveKeyFob(pm.KeyFobs[lvi.Text].SerialNumber);
 				}
 
                 if (!this.AtLeastOneAuthorizedFob)
                 {
                     lockingEnabled = false;
                     notifyIcon.ShowBalloonTip(2000, this.Text, "No authorized fobs detected, system is not protected by auto-locking until one is detected, and then leaves.", ToolTipIcon.Info);
                 }
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2262" endline="2297">
<![CDATA[
 
     ''' <summary>
     ''' RaiseEventStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseRaiseEventStatement(ByVal Parent As ParsedObject) As RaiseEventStatement
         Dim result As New RaiseEventStatement(Parent)
 
         Dim m_Event As SimpleNameExpression
         Dim m_Arguments As ArgumentList
         Dim m_Identifier As IdentifierOrKeyword
 
         tm.AcceptIfNotInternalError(KS.RaiseEvent)
 
         m_Identifier = ParseIdentifierOrKeyword(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Event = New SimpleNameExpression(result)
         m_Event.Identifier = New Identifier(m_Event, m_Identifier.Identifier, m_Identifier.Location, TypeCharacters.Characters.None)
 
         If tm.Accept(KS.LParenthesis) Then
             If tm.Accept(KS.RParenthesis) = False Then
                 m_Arguments = ParseArgumentList(result)
                 If m_Arguments Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 m_Arguments = New ArgumentList(result)
             End If
         Else
             m_Arguments = Nothing
         End If
 
         result.Init(m_Event, m_Arguments)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="560" endline="596">
<![CDATA[
 
     ''' <summary>
     ''' Attribute          
     ''' AttributeModifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttribute(ByVal Parent As ParsedObject) As Attribute
         Dim result As New Attribute(Parent)
 
         Dim m_IsAssembly As Boolean
         Dim m_IsModule As Boolean
         Dim m_SimpleTypeName As SimpleTypeName = Nothing
         Dim m_AttributeArguments As AttributeArguments = Nothing
 
         If tm.Accept("Assembly") Then
             m_IsAssembly = True
             If tm.AcceptIfNotError(KS.Colon) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         ElseIf tm.Accept(KS.Module) Then
             m_IsModule = True
             If tm.AcceptIfNotError(KS.Colon) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         m_SimpleTypeName = ParseSimpleTypeName(result)
         If m_SimpleTypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.LParenthesis) Then
             If tm.CurrentToken <> KS.RParenthesis Then
                 m_AttributeArguments = ParseAttributeArguments(result)
                 If m_AttributeArguments Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_IsAssembly, m_IsModule, m_SimpleTypeName, m_AttributeArguments)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\EventAccessorDeclarations.vb" startline="223" endline="254">
<![CDATA[
 
     Public Overrides Function CreateDefinition() As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_CecilBuilder Is Nothing)
         result = MyBase.CreateDefinition AndAlso result
 
         m_CecilBuilder = New Mono.Cecil.EventDefinition(Name, 0, Nothing)
         m_CecilBuilder.Annotations.Add(Compiler, Me)
         FindFirstParent(Of TypeDeclaration).CecilType.Events.Add(m_CecilBuilder)
         m_CecilBuilder.Name = Name
 
         If m_AddMethod IsNot Nothing Then
             result = m_AddMethod.CreateDefinition AndAlso result
             DeclaringType.Members.Add(m_AddMethod)
             m_CecilBuilder.AddMethod = m_AddMethod.CecilBuilder
         End If
 
         If m_RemoveMethod IsNot Nothing Then
             result = m_RemoveMethod.CreateDefinition AndAlso result
             DeclaringType.Members.Add(m_RemoveMethod)
             m_CecilBuilder.RemoveMethod = m_RemoveMethod.CecilBuilder
         End If
 
         If m_RaiseMethod IsNot Nothing Then
             result = m_RaiseMethod.CreateDefinition AndAlso result
             DeclaringType.Members.Add(m_RaiseMethod)
             m_CecilBuilder.InvokeMethod = m_RaiseMethod.CecilBuilder
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5329" endline="5371">
<![CDATA[
 
     ''' <summary>
     ''' MidAssignmentStatement  
     '''	   "Mid" [ "$" ]  "("  Expression "," Expression  [ "," Expression  ] ")"  =  Expression  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseMidAssignmentStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As MidAssignStatement
         Dim result As New MidAssignStatement(Parent)
 
         Dim m_Target As Expression
         Dim m_Start As Expression
         Dim m_Length As Expression
         Dim m_Source As Expression
 
         tm.AcceptIfNotInternalError("Mid")
 
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Target = ParseExpression(result)
         If m_Target Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.Comma) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Start = ParseExpression(result)
         If m_Start Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Comma) Then
             m_Length = ParseExpression(result)
             If m_Length Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Length = Nothing
         End If
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.Accept(KS.Equals) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Source = ParseExpression(result)
         If m_Source Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Target, m_Start, m_Length, m_Source)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\dshowUtil.vb" startline="205" endline="242">
<![CDATA[
 
     Public Overloads Overrides Function Split(ByVal Filename As String, _
     ByVal Duration As Double, ByVal MediaDuration As Double) As Boolean
         MyBase.Split(Filename, Duration, MediaDuration)
 
         If MediaDuration = 0 Then Exit Function
         If Duration = 0 Then Exit Function
 
         Dim Pieces As Integer = CInt(Fix(MediaDuration / Duration))
         Dim Temp As Segment
         Dim PieceFile As String = String.Empty
 
         If MediaDuration Mod Duration > 0 Then Pieces += 1
         Filename = AddDefaultPathIfNeeded(StripExtension(Filename))
         ReDim mSegments(Pieces - 1)
         For i As Integer = 0 To Pieces - 1
             Temp = New Segment
             Temp.Start = i * Duration
             Temp.Finish = Math.Min((i + 1) * Duration, MediaDuration)
             mSegments(i) = Temp
         Next
 
         mOutFile = Filename
         CreatePieces(False)
 
         Try
             Threading.Thread.Sleep(1000)
             Dim di As New IO.DirectoryInfo(GetDefaultDir)
             If di.GetFiles(StripPath(StripExtension(Filename)) & "*").Length >= Pieces Then
                 Return True
             Else
                 Return False
             End If
         Catch ex As Exception
             'Some disk exception
         End Try
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5932" endline="5976">
<![CDATA[
 
     ''' <summary>
     ''' ForEachStatement  
     '''	   "For" "Each" LoopControlVariable "In" Expression  StatementTerminator
     '''	         [  Block  ]
     '''	   "Next" [Expression  ]  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseForEachStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As ForEachStatement
         Dim result As New ForEachStatement(Parent)
 
         Dim m_LoopControlVariable As LoopControlVariable
         Dim m_InExpression As Expression
         Dim m_NextExpression As Expression
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.For)
         tm.AcceptIfNotInternalError(KS.Each)
 
         m_LoopControlVariable = ParseLoopControlVariable(result)
         If m_LoopControlVariable Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.In) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         tm.AcceptNewLine()
 
         m_InExpression = ParseExpression(result)
         If m_InExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.Next) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.CurrentToken.IsEndOfStatement = False Then
             m_NextExpression = ParseExpression(m_Code)
             If m_NextExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_NextExpression = Nothing
         End If
 
         result.Init(m_LoopControlVariable, m_InExpression, m_NextExpression, m_Code)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5692" endline="5731">
<![CDATA[
 
     ''' <summary>
     ''' CatchStatement  
     '''	   "Catch" [  Identifier "As" NonArrayTypeName  ]  [ "When" BooleanExpression  ]  StatementTerminator
     '''	      [  Block  ]
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseCatchStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As CatchStatement
         Dim result As New CatchStatement(Parent)
 
         Dim m_Code As CodeBlock
         Dim m_Variable As Identifier = Nothing
         Dim m_When As Expression = Nothing
         Dim m_TypeName As NonArrayTypeName = Nothing
 
         tm.AcceptIfNotInternalError(KS.Catch)
 
         If tm.AcceptEndOfStatement(IsOneLiner) = False Then
             m_Variable = ParseIdentifier(result)
             If m_Variable IsNot Nothing Then
                 If tm.AcceptIfNotError(KS.As) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 m_TypeName = ParseNonArrayTypeName(result)
                 If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.Accept(KS.When) Then
                 m_When = ParseExpression(result)
                 If m_When Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         End If
 
         result.Init(m_Variable, m_TypeName, m_When, m_Code)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AliasClause.vb" startline="46" endline="55">
<![CDATA[
 
     Sub Init(ByVal Elements As Expression())
         m_VariableInitializerList = New VariableInitializerList(Me)
         For Each e As Expression In Elements
             Dim vi As VariableInitializer
             vi = New VariableInitializer(Me)
             vi.Init(e)
             m_VariableInitializerList.Add(vi)
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="124" endline="132">
<![CDATA[
 
     Public Sub Emit(ByVal opcode As Mono.Cecil.Cil.OpCode, ByVal labels() As Label)
         Dim tmpCecil As Mono.Cecil.Cil.Instruction()
         ReDim tmpCecil(labels.Length - 1)
         For i As Integer = 0 To labels.Length - 1
             tmpCecil(i) = labels(i).CecilLabel
         Next
         Emit(opcode, tmpCecil)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3933" endline="3957">
<![CDATA[
 
     ''' <summary>
     ''' Constraint  
     ''' LAMESPEC? Using the following
     ''' Constraint  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseConstraint(ByVal Parent As ParsedObject) As Constraint
         Dim result As New Constraint(Parent)
 
         Dim m_Special As KS
         Dim m_TypeName As TypeName = Nothing
 
         If tm.CurrentToken.Equals(KS.[New], KS.Class, KS.Structure) Then
             m_Special = tm.CurrentToken.Keyword
             tm.NextToken()
         Else
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_TypeName, m_Special)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="283" endline="303">
<![CDATA[
 
     ReadOnly Property CodeStream() As IO.StreamReader
         Get
             Dim Stream As System.IO.Stream
             Dim StreamReader As System.IO.StreamReader
 
             Try
                 If m_Code IsNot Nothing Then
                     Stream = New System.IO.MemoryStream(Compiler.CommandLine.Encoding.GetBytes(m_Code))
                 Else
                     Stream = New System.IO.FileStream(FileName, IO.FileMode.Open, IO.FileAccess.Read, IO.FileShare.Read)
                 End If
 
                 StreamReader = New System.IO.StreamReader(Stream, Compiler.CommandLine.Encoding, True)
 
                 Return StreamReader
             Catch e As Exception
                 Compiler.Report.ShowMessage(Messages.VBNC31007, Span.CommandLineSpan, FileName)
                 Return Nothing
             End Try
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\PropertyGroupToPropertyAccessExpression.vb" startline="60" endline="67">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = Classification.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Index.vb" startline="35" endline="43">
<![CDATA[
     End Property
 
     Public Function GetAllNames() As String()
         Dim result() As String
         ReDim result(m_lstCollections.Count - 1)
         m_lstCollections.Keys.CopyTo(result, 0)
         Array.Sort(result)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="99" endline="107">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AliasClause.vb" startline="31" endline="37">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_VariableInitializerList IsNot Nothing Then result = m_VariableInitializerList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="141" endline="149">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_CustomAttributes IsNot Nothing Then result = m_CustomAttributes.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\Operand.vb" startline="55" endline="62">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ParametersOrType.vb" startline="54" endline="61">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ArrayNameModifier IsNot Nothing Then result = m_ArrayNameModifier.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\OnErrorStatement.vb" startline="46" endline="53">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ResolvedLabel IsNot Nothing Then result = m_ResolvedLabel.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\Constraint.vb" startline="73" endline="80">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="594" endline="603">
<![CDATA[
 
     Function EmitAttributes() As Boolean
         Dim result As Boolean = True
 
         If m_Attributes IsNot Nothing Then
             result = m_Attributes.GenerateCode(Nothing) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeImplementsClauses.vb" startline="63" endline="69">
<![CDATA[
 
     ReadOnly Property AsString() As String
         Get
             If TypeOf m_TypeName Is NonArrayTypeName Then Return AsNonArrayTypeName.Name
             If TypeOf m_TypeName Is ArrayTypeName Then Return AsArrayTypeName.Name
             Return DirectCast(m_TypeName, INameable).Name
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeImplementsClauses.vb" startline="38" endline="48">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Returns true if the resolved object is the "Global" keyword.
     ''' </summary>
     ''' <value></value>
     ''' <remarks></remarks>
     ReadOnly Property IsGlobal() As Boolean
         Get
             Return m_FoundObjects.Count = 1 AndAlso ((TypeOf m_FoundObjects(0) Is Token AndAlso DirectCast(m_FoundObjects(0), Token).Equals(KS.Global)) OrElse (TypeOf m_FoundObjects(0) Is GlobalExpression))
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\BooleanLiteralExpression.vb" startline="54" endline="68">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim tp As TypeReference
 
         result = m_Expression.GenerateCode(Info) AndAlso result
 
         tp = m_Expression.ExpressionType
         If CecilHelper.IsByRef(tp) Then
             tp = CecilHelper.GetElementType(tp)
         End If
         Emitter.EmitBox(Info, tp)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeParameter.vb" startline="141" endline="151">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeParameterConstraints IsNot Nothing Then
             result = m_TypeParameterConstraints.ResolveTypeReferences AndAlso result
             result = DefineParameterConstraints() AndAlso result
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="79" endline="88">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Condition.ResolveExpression(Info) AndAlso result
         result = Helper.VerifyValueClassification(m_Condition, Info) AndAlso result
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="58" endline="67">
<![CDATA[
 
     Public MemberCache As New Generic.Dictionary(Of Mono.Cecil.TypeReference, MemberCache)(New TypeComparer)
 
     ReadOnly Property Corlib As AssemblyDefinition
         Get
             For i As Integer = 0 To m_CecilAssemblies.Count - 1
                 If Helper.CompareNameOrdinal(m_CecilAssemblies(i).Name.Name, "mscorlib") Then Return m_CecilAssemblies(i)
             Next
             Return Nothing
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\BaseList.vb" startline="30" endline="36">
<![CDATA[
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For i As Integer = 0 To m_List.Count - 1
             result = m_List(i).ResolveCode(Info) AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="905" endline="914">
<![CDATA[
 
     Shared Function GetParameterTypes(ByVal Parameters As Mono.Cecil.ParameterReference()) As Mono.Cecil.TypeReference()
         Dim result() As Mono.Cecil.TypeReference
         Helper.Assert(Parameters IsNot Nothing)
         ReDim result(Parameters.Length - 1)
         For i As Integer = 0 To Parameters.GetUpperBound(0)
             result(i) = Parameters(i).ParameterType
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeParameter.vb" startline="158" endline="170">
<![CDATA[
 
     ReadOnly Property GenericParameterAttributes() As Mono.Cecil.GenericParameterAttributes
         Get
             Dim result As Mono.Cecil.GenericParameterAttributes
 
             If m_TypeParameterConstraints IsNot Nothing Then
                 For i As Integer = 0 To m_TypeParameterConstraints.Constraints.Count - 1
                     result = result Or m_TypeParameterConstraints.Constraints(i).SpecialConstraintAttribute
                 Next
             End If
 
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="81" endline="94">
<![CDATA[
 
     Public Overrides Function CreateDefinition() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.CreateDefinition AndAlso result
 
         If Me.Modifiers.Is(ModifierMasks.MustInherit) Then
             TypeAttributes = TypeAttributes Or Mono.Cecil.TypeAttributes.Abstract
         ElseIf Me.Modifiers.Is(ModifierMasks.NotInheritable) Then
             TypeAttributes = TypeAttributes Or Mono.Cecil.TypeAttributes.Sealed
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1242" endline="1251">
<![CDATA[
 
     Shared Function GetInvokeMethod(ByVal Compiler As Compiler, ByVal DelegateType As Mono.Cecil.TypeReference) As Mono.Cecil.MethodReference
         Helper.Assert(IsDelegate(Compiler, DelegateType), "The type '" & DelegateType.FullName & "' is not a delegate.")
         Dim results As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference) = Compiler.TypeManager.GetCache(DelegateType).Lookup(DelegateDeclaration.STR_Invoke, MemberVisibility.Public).Members
         If results IsNot Nothing AndAlso results.Count = 1 AndAlso TypeOf results(0) Is Mono.Cecil.MethodReference Then
             Return DirectCast(results(0), Mono.Cecil.MethodReference)
         Else
             Throw New NotImplementedException
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\CaseClauses.vb" startline="113" endline="128">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then
             result = m_TypeName.ResolveTypeReferences AndAlso result
         End If
 
         If m_When IsNot Nothing Then
             result = m_When.ResolveTypeReferences AndAlso result
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\MainForm.cs" startline="310" endline="332">
<![CDATA[
 
         void pluginListViewContextMenu_Popup(object sender, EventArgs e)
         {
             if (pluginListView.SelectedItems.Count > 0)
             {
                 string pluginName = pluginListView.SelectedItems[0].Text;
                 Plugin p = pluginManager.GetPluginByName(pluginName);
 
                 if (p != null)
                 {
                     enablePluginMenuItem.Checked = p.Enabled;
 
                     if (p.Configurator != null)
                     {
                         configurePluginMenuItem.Enabled = true;
                     }
                     else
                     {
                         configurePluginMenuItem.Enabled = false;
                     }
                 }
             }
         }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="70" endline="83">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.GenerateCode(Info) AndAlso result
 
         If Signature.Parameters IsNot Nothing Then
             For i As Integer = 0 To Signature.Parameters.Count - 1
                 result = Signature.Parameters(i).GenerateCode(Info) AndAlso result
             Next
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="137" endline="166">
<![CDATA[
 
     Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_TypeDeclarations.Length - 1
             Dim type As TypeDeclaration = m_TypeDeclarations(i)
 
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Try
                 System.Console.ForegroundColor = ConsoleColor.Green
             Catch ex As Exception
 
             End Try
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveCode " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
             Try
                 System.Console.ResetColor()
             Catch ex As Exception
 
             End Try
 #End If
             result = type.ResolveCode(Info) AndAlso result
             Compiler.VerifyConsistency(result, type.Location)
         Next
 
         result = m_Attributes.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\StdToolMgr.vb" startline="470" endline="491">
<![CDATA[
 
 #End Region
 
 #Region "   Media Player events "
 
     Private Sub mPlayer_PlayStateChange(ByVal sender As Object, _
     ByVal e As AxWMPLib._WMPOCXEvents_PlayStateChangeEvent) _
     Handles mPlayer.PlayStateChange
         If mSuspend Then Exit Sub
         Select Case mPlayer.playState
             Case WMPLib.WMPPlayState.wmppsPlaying
                 If Not mFrames Is Nothing Then
                     mFrames2Paint = True
                     Draw()
                 End If
                 Timer.Enabled = True
                 cPlay.ImageIndex = 6        'Show Pause
             Case WMPLib.WMPPlayState.wmppsPaused
                 Timer.Enabled = False
                 cPlay.ImageIndex = 1        'Show Play
         End Select
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="1965" endline="1990">
<![CDATA[
 
     ''' <summary>
     ''' DictionaryAccessExpression 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDictionaryAccessExpression(ByVal Parent As ParsedObject, ByVal FirstPart As Expression) As DictionaryAccessExpression
         Dim result As New DictionaryAccessExpression(Parent)
 
         Dim m_FirstPart As Expression
         Dim m_SecondPart As IdentifierOrKeyword
 
         m_FirstPart = FirstPart
         If m_FirstPart IsNot Nothing Then m_FirstPart.Parent = result
         tm.AcceptIfNotInternalError(KS.Exclamation)
         If tm.CurrentToken.IsIdentifierOrKeyword Then
             m_SecondPart = ParseIdentifierOrKeyword(result)
             If m_SecondPart Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             Compiler.Report.ShowMessage(Messages.VBNC30203, tm.CurrentLocation)
             Return Nothing
         End If
 
         result.Init(m_FirstPart, m_SecondPart)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeImplementsClauses.vb" startline="406" endline="429">
<![CDATA[
 
     Private Function CheckCurrentFunctionForTypeParameters(ByVal R As String, ByVal TypeArgumentCount As Integer) As Boolean
         Dim signature As SubSignature = Nothing
         Dim method As MethodBaseDeclaration = FromWhere.FindFirstParent(Of MethodBaseDeclaration)()
 
         If method IsNot Nothing Then
             signature = method.Signature
         Else
             Dim del As DelegateDeclaration = FromWhere.FindFirstParent(Of DelegateDeclaration)()
             If del IsNot Nothing Then
                 signature = del.Signature
             End If
         End If
 
         If signature IsNot Nothing AndAlso signature.TypeParameters IsNot Nothing Then
             Dim item As TypeParameter = signature.TypeParameters.Parameters.Item(R)
             If item IsNot Nothing Then
                 m_FoundObjects.Add(item)
                 Return True
             End If
         End If
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5168" endline="5189">
<![CDATA[
 
     ''' <summary>
     ''' ExitStatement  
     ''' ExitKind  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseExitStatement(ByVal Parent As ParsedObject) As ExitStatement
         Dim m_ExitWhat As KS
         Dim exitLocation As Span
 
         tm.AcceptIfNotInternalError(KS.Exit)
         If tm.CurrentToken.Equals(KS.Sub, KS.Function, KS.Property, KS.Do, KS.For, KS.Try, KS.While, KS.Select) Then
             m_ExitWhat = tm.CurrentToken.Keyword
             exitLocation = tm.CurrentLocation
             tm.NextToken()
         Else
             Compiler.Report.ShowMessage(Messages.VBNC30240, tm.CurrentLocation)
             Return Nothing
         End If
 
         Return New ExitStatement(Parent, m_ExitWhat, exitLocation)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="186" endline="197">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_LoopControlVariable IsNot Nothing Then result = m_LoopControlVariable.ResolveTypeReferences AndAlso result
         If m_InExpression IsNot Nothing Then result = m_InExpression.ResolveTypeReferences AndAlso result
         If m_NextExpression IsNot Nothing Then result = m_NextExpression.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="146" endline="157">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         If m_Condition IsNot Nothing Then result = m_Condition.ResolveTypeReferences AndAlso result
         If m_ElseIfs IsNot Nothing Then result = m_ElseIfs.ResolveTypeReferences AndAlso result
         If m_FalseCode IsNot Nothing Then result = m_FalseCode.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="97" endline="114">
<![CDATA[
     End Property
 
     Public Overrides Function GetConstant(ByRef result As Object, ByVal ShowError As Boolean) As Boolean
         Dim lvalue As Object = Nothing
         Dim rvalue As Object = Nothing
 
         If Not m_LeftExpression.GetConstant(lvalue, ShowError) Then Return False
         If Not m_RightExpression.GetConstant(rvalue, ShowError) Then Return False
 
         If ((TypeOf lvalue Is String OrElse TypeOf lvalue Is Char) AndAlso (TypeOf rvalue Is String OrElse TypeOf rvalue Is Char)) = False Then
             If ShowError Then Show30059()
             Return False
         End If
 
         result = CStr(lvalue) & CStr(rvalue)
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeCache.vb" startline="262" endline="270">
<![CDATA[
 
     Private Function IsMatch(ByVal Types As Mono.Cecil.TypeReference(), ByVal Parameters As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Boolean
         If Parameters.Count = 0 AndAlso (Types Is Nothing OrElse Types.Length = 0) Then Return True
         If Parameters.Count <> Types.Length Then Return False
         For j As Integer = 0 To Parameters.Count - 1
             If Helper.CompareType(Parameters(j).ParameterType, Types(j)) = False Then Return False
         Next
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\DotAccessExpression.vb" startline="319" endline="342">
<![CDATA[
 
     Function GetObjectReference() As Expression
         Dim result As Expression
         If TypeOf Me Is GetRefExpression Then
             Return Me
         ElseIf TypeOf Me Is InstanceExpression Then
             Return Me
         ElseIf CecilHelper.IsValueType(ExpressionType) Then
             If TypeOf Me Is DeRefExpression Then
                 Dim derefExp As DeRefExpression = DirectCast(Me, DeRefExpression)
                 result = derefExp.Expression
             ElseIf Helper.CompareType(CecilHelper.FindDefinition(Me.ExpressionType).BaseType, Compiler.TypeCache.System_Enum) Then
                 result = New BoxExpression(Me, Me, CecilHelper.MakeByRefType(Me.ExpressionType))
                 'ElseIf Me.ExpressionType.IsValueType AndAlso Helper.IsNullableType(Compiler, Me.ExpressionType) = False Then
                 '    result = New BoxExpression(Me, Me, Me.ExpressionType)
             Else
                 result = New GetRefExpression(Me, Me)
             End If
         Else
             result = Me
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CodeFiles.vb" startline="1153" endline="1174">
<![CDATA[
 
     Private Function AddFile(ByVal File As String) As Boolean
         Dim result As Boolean = True
 
         Dim strFile As String
         Dim strFiles As String()
 
         strFiles = GetFullPaths(File)
 
         If strFiles Is Nothing OrElse strFiles.Length = 0 Then
             If IsPattern(File) = False Then
                 result = Compiler.Report.SaveMessage(Messages.VBNC2001, Span.CommandLineSpan, File) AndAlso result
             End If
             Return result
         End If
 
         For Each strFile In strFiles
             m_lstFileNames.Add(New CodeFile(strFile, System.IO.Path.GetDirectoryName(File), Me.Compiler))
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1221" endline="1243">
<![CDATA[
 
     Overloads Shared Function EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As Long) As Boolean
         Helper.Assert(Info.DesiredType IsNot Nothing)
         Dim DesiredTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, Info.DesiredType)
         If Value <= Integer.MaxValue AndAlso Value >= Integer.MinValue Then
             Return EmitLoadValue(Info, CInt(Value))
         End If
 
         Dim tmp As EmitInfo = Info.Clone(Info.Context, CType(Nothing, Mono.Cecil.TypeReference))
 
         Select Case DesiredTypeCode
             Case TypeCode.Single
                 EmitLoadValue(tmp, CSng(Value))
                 Return True
             Case TypeCode.Double
                 EmitLoadValue(tmp, CDbl(Value))
                 Return True
             Case TypeCode.Decimal
                 EmitLoadValue(tmp, CDec(Value))
                 Return True
         End Select
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" startline="48" endline="73">
<![CDATA[
 
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
         Dim expType As Mono.Cecil.TypeReference = Expression.ExpressionType
         Dim expTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, expType)
 
         Select Case expTypeCode
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Char_Array) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.System_Char_Array) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="6309" endline="6332">
<![CDATA[
 
     Private Function FindTypeInParent(ByVal Parent As ParsedObject, ByVal CompleteName As String) As TypeDeclaration
         Dim assemblyParent As AssemblyDeclaration = TryCast(Parent, AssemblyDeclaration)
         Dim typeParent As TypeDeclaration = TryCast(Parent, TypeDeclaration)
         Dim partialType As TypeDeclaration = Nothing
         Dim partialTypes As Generic.List(Of INameable)
 
         If assemblyParent IsNot Nothing Then
             partialType = assemblyParent.FindTypeWithFullname(CompleteName)
         ElseIf typeParent IsNot Nothing Then
             partialTypes = typeParent.Members.Index.Item(CompleteName)
             If partialTypes IsNot Nothing Then
                 If partialTypes.Count = 1 Then
                     partialType = TryCast(partialTypes(0), TypeDeclaration)
                     If partialType Is Nothing Then
                         Helper.AddError(Compiler, tm.CurrentLocation, "Already a member with the name " & CompleteName)
                     End If
                 ElseIf partialTypes.Count > 1 Then
                     Helper.AddError(Compiler, tm.CurrentLocation, "Already a member with the name " & CompleteName)
                 End If
             End If
         End If
         Return partialType
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\EventAccessorDeclarations.vb" startline="150" endline="165">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ImplementsClause IsNot Nothing Then result = m_ImplementsClause.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
         If m_AddMethod IsNot Nothing Then result = m_AddMethod.ResolveTypeReferences AndAlso result
         If m_RemoveMethod IsNot Nothing Then result = m_RemoveMethod.ResolveTypeReferences AndAlso result
         If m_RaiseMethod IsNot Nothing Then result = m_RaiseMethod.ResolveTypeReferences AndAlso result
 
         Helper.Assert(EventType IsNot Nothing)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="978" endline="1003">
<![CDATA[
 
     ''' <summary>
     ''' BoundList
     ''' UpperBoundList
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseBoundList(ByVal Parent As ParsedObject) As BoundList
         Dim result As New BoundList(Parent)
 
         Dim newExp As Expression = Nothing
         Dim tmp As New Generic.List(Of Expression)
 
         Do
             If tm.CurrentToken.IsIntegerLiteral AndAlso tm.CurrentToken.IntegralLiteral = 0 AndAlso tm.PeekToken.Equals(KS.To) Then tm.NextToken(2)
             newExp = ParseExpression(result)
             If newExp Is Nothing Then
                 If m_ShowErrors = False Then Return Nothing
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             tmp.Add(newExp)
         Loop While tm.Accept(KS.Comma)
 
         result.Init(tmp.ToArray)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="54" endline="63">
<![CDATA[
 
     Public Function Parse(ByVal RootNamespace As String, ByVal assembly As AssemblyDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = ParseAssemblyDeclaration(RootNamespace, assembly) AndAlso result
 
         result = Compiler.Report.Errors = 0 AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="423" endline="439">
<![CDATA[
 
     ''' <summary>
     ''' Returns true if the current token is an identifier
     ''' and advances to the next token.
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptIdentifier(Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.IsIdentifier Then
             NextToken()
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="440" endline="449">
<![CDATA[
 
     Function AcceptStringLiteral(Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.IsStringLiteral Then
             NextToken()
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="450" endline="465">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' </summary>
     ''' <param name="GotoNewline"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptIntegerLiteral(Optional ByVal GotoNewline As Boolean = False) As Boolean
         If CurrentToken.IsIntegerLiteral Then
             NextToken()
             Return True
         Else
             If GotoNewline Then Me.GotoNewline(True)
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\LateBoundAccessToValueExpression.vb" startline="34" endline="46">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Me.LateBoundAccess.Name Is Nothing Then
             result = EmitLateIndexGet(Info) AndAlso result
         Else
             result = EmitLateGet(Info) AndAlso result
         End If
 
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\GenericTypeDeclaration.vb" startline="35" endline="46">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeParameters IsNot Nothing Then
             result = m_TypeParameters.ResolveTypeReferences AndAlso result
         End If
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ReturnStatement.vb" startline="53" endline="62">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Test IsNot Nothing Then result = m_Test.ResolveTypeReferences AndAlso result
         If m_Cases IsNot Nothing Then result = m_Cases.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="223" endline="241">
<![CDATA[
 
     ''' <summary>
     ''' Skips tokens until it finds any of the specified tokens.
     ''' If StopOnNewLine = True then stops also when a NewLine is found 
     ''' (the newline token is not eaten).
     ''' </summary>
     ''' <param name="StopOnNewline"></param>
     ''' <param name="Specials"></param>
     ''' <remarks></remarks>
     Sub GotoAny(ByVal StopOnNewline As Boolean, ByVal ParamArray Specials() As KS)
         Do Until (CurrentToken.Equals(Specials))
             If StopOnNewline AndAlso CurrentToken.IsEndOfLine Then
                 Return
             ElseIf CurrentToken.IsEndOfFile Then
                 Return
             End If
             NextToken()
         Loop
         Do Until (CurrentToken.Equals(Specials))
             If StopOnNewline AndAlso CurrentToken.IsEndOfLine Then
                 Return
             ElseIf CurrentToken.IsEndOfFile Then
                 Return
             End If
             NextToken()
         Loop
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ParametersOrType.vb" startline="70" endline="82">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_ParameterList IsNot Nothing Then
             result = m_ParameterList.ResolveTypeReferences AndAlso result
         End If
         If m_NonArrayTypeName IsNot Nothing Then
             result = m_NonArrayTypeName.ResolveTypeReferences AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="889" endline="896">
<![CDATA[
 
     Public Shared Function IsGenericType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Dim genericType As Mono.Cecil.GenericInstanceType = TryCast(Type, GenericInstanceType)
         If genericType IsNot Nothing Then Return True
         If Type.GenericParameters Is Nothing OrElse Type.GenericParameters.Count = 0 Then Return False
         If Type.GenericParameters IsNot Nothing AndAlso Type.GenericParameters.Count > 0 Then Return True
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="341" endline="364">
<![CDATA[
 
     ''' <summary>
     ''' If GotoNewline = true then calls GotoNewline(True) - next token is the first one after the newline.
     ''' Accepts only newline, not endofcode, nor endoffile. 
     ''' </summary>
     ''' <param name="GotoNewline"></param>
     ''' <param name="EOFIsError">Specifies whether to return false if the current token is EOF or not.</param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptNewLine(Optional ByVal GotoNewline As Boolean = False, Optional ByVal EOFIsError As Boolean = True, Optional ByVal ReportError As Boolean = False) As Boolean
         If CurrentToken.IsEndOfLine Then
             If CurrentToken.IsEndOfLineOnly Then
                 NextToken()
                 Return True
             ElseIf EOFIsError = False Then
                 Return True
             Else
                 Return False
             End If
         Else
             If GotoNewline Then Me.GotoNewline(True, ReportError)
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\cOpenFileDialogExt.vb" startline="51" endline="65">
<![CDATA[
     End Property
 
     Public Sub WndProc(ByRef m As Message)
         If Not _enabled Then
             Return
         End If
         If m.Msg = 289 Then
             Dim dialogHandle As Integer = m.LParam.ToInt32
             If Not (dialogHandle = _lastDialogHandle) Then
                 Dim listviewHandle As Integer = FindWindowEx(dialogHandle, 0, "SHELLDLL_DefView", "")
                 SendMessage(listviewHandle, WM_COMMAND, _viewType, 0)
                 _lastDialogHandle = dialogHandle
             End If
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\NonArrayTypeName.vb" startline="150" endline="167">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim stn As SimpleTypeName
         Dim ctn As ConstructedTypeName
 
         stn = TryCast(m_TypeName, SimpleTypeName)
         If stn IsNot Nothing Then
             result = stn.ResolveCode(Info) AndAlso result
         Else
             ctn = TryCast(m_TypeName, ConstructedTypeName)
             If ctn IsNot Nothing Then
                 result = ctn.ResolveCode(Info) AndAlso result
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeImplementsClauses.vb" startline="130" endline="148">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim atn As ArrayTypeName
         Dim natn As NonArrayTypeName
 
         atn = TryCast(m_TypeName, ArrayTypeName)
         If atn IsNot Nothing Then
             result = atn.ResolveCode(Info) AndAlso result
         Else
             natn = TryCast(m_TypeName, NonArrayTypeName)
             If natn IsNot Nothing Then
                 result = natn.ResolveCode(Info) AndAlso result
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="364" endline="384">
<![CDATA[
     End Property
 
     Public Overrides Function GetConstant(ByRef result As Object, ByVal ShowError As Boolean) As Boolean
         Dim rvalue As Object = Nothing
         Dim lvalue As Object = Nothing
 
         If Not m_LeftExpression.GetConstant(lvalue, ShowError) Then Return False
         If Not m_RightExpression.GetConstant(rvalue, ShowError) Then Return False
 
         If lvalue Is Nothing Or rvalue Is Nothing Then
             result = Nothing
             Return True
         End If
 
         If Not GetConstant(result, lvalue, rvalue) Then
             If ShowError Then Show30059()
             Return False
         End If
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="326" endline="337">
<![CDATA[
 
     Public Sub Trace(ByVal format As String, ByVal ParamArray args() As Object)
         If Compiler.CommandLine.Trace = False Then Return
         If args IsNot Nothing Then
             For i As Integer = 0 To args.Length - 1
                 If TypeOf args(i) Is Span Then
                     args(i) = DirectCast(args(i), Span).ToString(Compiler)
                 End If
             Next
         End If
         Console.WriteLine(format, args)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\BoundList.vb" startline="275" endline="281">
<![CDATA[
     End Property
 
     Public ReadOnly Property FieldType() As Mono.Cecil.TypeReference Implements IFieldMember.FieldType
         Get
             If m_FieldBuilderCecil Is Nothing Then Return Nothing
             Return m_FieldBuilderCecil.FieldType
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\OperatorDeclaration.vb" startline="145" endline="151">
<![CDATA[
     End Property
 
     Public Property Name() As String Implements INameable.Name
         Get
             If m_ParameterIdentifier Is Nothing Then Return Nothing
             Return m_ParameterIdentifier.Name
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3406" endline="3423">
<![CDATA[
 
     ''' <summary>
     ''' AddressOfExpression  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAddressOfExpression(ByVal Parent As ParsedObject) As AddressOfExpression
         Dim result As New AddressOfExpression(Parent)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.AddressOf)
 
         m_Expression = ParseExpression(result)
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5920" endline="5931">
<![CDATA[
 
     Private Function ParseCallStatement(ByVal Parent As ParsedObject) As CallStatement
         Dim result As New CallStatement(Parent)
 
         Dim m_Target As Expression
         tm.AcceptIfNotInternalError(KS.Call)
         m_Target = ParseExpression(result)
 
         result.Init(m_Target)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="174" endline="183">
<![CDATA[
 
     Function DefineConstant() As Boolean
         Dim result As Boolean = True
         Dim obj As Object = Nothing
 
         result = GetConstantValue(obj) AndAlso result
         ConstantValue = obj
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\dshowUtil.vb" startline="15" endline="24">
<![CDATA[
 
     'Form overrides dispose to clean up the component list.
     Protected Overloads Overrides Sub Dispose(ByVal disposing As Boolean)
         If disposing Then
             If Not (components Is Nothing) Then
                 components.Dispose()
             End If
         End If
         MyBase.Dispose(disposing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="21" endline="30">
<![CDATA[
 
     'Form overrides dispose to clean up the component list.
     Protected Overloads Overrides Sub Dispose(ByVal disposing As Boolean)
         If disposing Then
             If Not (components Is Nothing) Then
                 components.Dispose()
             End If
         End If
         MyBase.Dispose(disposing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\StdToolMgr.vb" startline="16" endline="25">
<![CDATA[
 
     'UserControl overrides dispose to clean up the component list.
     Protected Overloads Overrides Sub Dispose(ByVal disposing As Boolean)
         If disposing Then
             If Not (components Is Nothing) Then
                 components.Dispose()
             End If
         End If
         MyBase.Dispose(disposing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\StdToolMgr.vb" startline="15" endline="24">
<![CDATA[
 
     'UserControl overrides dispose to clean up the component list.
     Protected Overloads Overrides Sub Dispose(ByVal disposing As Boolean)
         If disposing Then
             If Not (components Is Nothing) Then
                 components.Dispose()
             End If
         End If
         MyBase.Dispose(disposing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\StdToolMgr.vb" startline="84" endline="95">
<![CDATA[
 
     ' <summary> 
     ' Clean up any resources being used.
     ' </summary>
     Protected Shadows Sub Dispose(ByVal disposing As Boolean)
         If disposing Then
             If (Not (components) Is Nothing) Then
                 components.Dispose()
             End If
         End If
         MyBase.Dispose(disposing)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\RMhandler.vb" startline="59" endline="68">
<![CDATA[
 
     Private Function GetOrCreateNode(ByVal ParNode As XmlNode, ByVal Name As String) As XmlNode
         Dim xNode As XmlNode
         xNode = ParNode.SelectSingleNode(Name)
         If xNode Is Nothing Then
             xNode = ParNode.OwnerDocument.CreateElement(Name)
             ParNode.AppendChild(xNode)
         End If
         Return xNode
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3499" endline="3518">
<![CDATA[
 
     ''' <summary>
     ''' LiteralExpression  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseLiteralExpression(ByVal Parent As ParsedObject) As LiteralExpression
         Dim result As LiteralExpression
 
         Dim m_Value As Token
         m_Value = tm.CurrentToken
         If m_Value.IsLiteral = False Then
             result = Nothing
         Else
             result = New LiteralExpression(Parent)
             result.Init(m_Value)
             tm.NextToken()
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="116" endline="123">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_TypeName, m_ArgumentList, m_VariableInitializer) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="89" endline="101">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If Info Is Nothing Then
             Info = New EmitInfo(Me)
         End If
 
         result = DefineHandlesOrImplements() AndAlso result
         result = MyBase.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="68" endline="79">
<![CDATA[
     End Property
 
     Function FindAssemblyDefinition(ByVal Fullname As String) As Mono.Cecil.AssemblyDefinition
         For i As Integer = 0 To m_CecilAssemblies.Count - 1
             Dim a As Mono.Cecil.AssemblyDefinition
             a = m_CecilAssemblies(i)
             If Helper.CompareNameOrdinal(a.Name.FullName, Fullname) Then
                 Return a
             End If
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\EventAccessorDeclarations.vb" startline="84" endline="91">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For i As Integer = 0 To m_Handlers.Length - 1
             result = m_Handlers(i).ResolveCode(Info) AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="524" endline="531">
<![CDATA[
     Function AcceptAll(ByVal ParamArray Specials() As KS) As Boolean
         Dim i As Integer
         AcceptAll = True
         For i = 0 To Specials.Length - 1
             AcceptAll = PeekToken(i).Equals(Specials(i)) AndAlso AcceptAll
         Next
         If AcceptAll Then NextToken(Specials.Length)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="1162" endline="1170">
<![CDATA[
 
     Function FindTypeWithName(ByVal Name As String) As TypeDeclaration
         For i As Integer = 0 To m_Members.Count - 1
             Dim tD As TypeDeclaration = TryCast(m_Members(i), TypeDeclaration)
             If tD Is Nothing Then Continue For
             If Helper.CompareName(tD.Name, Name) Then Return tD
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="1171" endline="1179">
<![CDATA[
 
     Function FindTypeWithFullname(ByVal Fullname As String) As TypeDeclaration
         For i As Integer = 0 To m_Members.Count - 1
             Dim tD As TypeDeclaration = TryCast(m_Members(i), TypeDeclaration)
             If tD Is Nothing Then Continue For
             If Helper.CompareName(tD.FullName, Fullname) Then Return tD
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MemberCache.vb" startline="119" endline="132">
<![CDATA[
 
     ''' <summary>
     ''' Create a new message with the specified data.
     ''' </summary>
     Sub New(ByVal Compiler As Compiler, ByVal Message As Messages, ByVal Parameters() As String, ByVal Location As Span)
         Me.m_Compiler = Compiler
         Me.m_Message = New Messages() {Message}
         Me.m_Location = Location
         If Parameters Is Nothing Then
             Me.m_Parameters = New String()() {New String() {}}
         Else
             Me.m_Parameters = New String()() {Parameters}
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Index.vb" startline="44" endline="61">
<![CDATA[
 
     Shadows Sub Add(ByVal Base As INameable)
         Dim idxList As IndexList
         'Does name exist already?
         Dim name As String = Base.Name
 
         If name Is Nothing Then Throw New InternalException("Got nothing for base type = " & CObj(Base).GetType().FullName)
 
         If m_lstCollections.ContainsKey(name) Then
             idxList = DirectCast(m_lstCollections.Item(name), IndexList)
         Else 'If not, create a new indexlist
             idxList = New IndexList()
             idxList.Name = name
             m_lstCollections.Add(idxList.Name, idxList)
         End If
         'Add the value
         idxList.Values.Add(Base)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1300" endline="1314">
<![CDATA[
 
     Overloads Shared Function EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As Double) As Boolean
         Helper.Assert(Info.DesiredType IsNot Nothing)
         Dim DesiredTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, Info.DesiredType)
         Dim tmp As EmitInfo = Info
 
         Select Case DesiredTypeCode
             Case TypeCode.Single
                 If Value <= Single.MaxValue AndAlso Value >= Single.MinValue Then
                     EmitLoadValue(tmp, CSng(Value))
                     Return True
                 End If
         End Select
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="869" endline="895">
<![CDATA[
 
     ''' <summary>
     ''' ArrayNameModifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArrayNameModifier(ByVal Parent As ParsedObject) As ArrayNameModifier
         Dim result As New ArrayNameModifier(Parent)
 
         If ArrayTypeModifiers.CanBeMe(tm) Then
             Dim newATM As ArrayTypeModifiers
             newATM = ParseArrayTypeModifiers(result)
             If newATM Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(newATM)
         ElseIf ArraySizeInitializationModifier.CanBeMe(tm) Then
             Dim newASIM As ArraySizeInitializationModifier
             newASIM = ParseArraySizeInitializationModifer(result)
             If newASIM Is Nothing Then
                 If m_ShowErrors = False Then Return Nothing
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             result.Init(newASIM)
         Else
             Throw New InternalException(result)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1423" endline="1436">
<![CDATA[
 
     Shared Function GetTypes(ByVal Arguments As Generic.List(Of Argument)) As Mono.Cecil.TypeReference()
         Dim result() As Mono.Cecil.TypeReference = New Mono.Cecil.TypeReference() {}
 
         If Arguments Is Nothing Then Return result
         ReDim result(Arguments.Count - 1)
         For i As Integer = 0 To Arguments.Count - 1
             Helper.Assert(Arguments(i) IsNot Nothing)
             If Arguments(i) IsNot Nothing AndAlso Arguments(i).Expression IsNot Nothing Then
                 result(i) = Arguments(i).Expression.ExpressionType
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="202" endline="238">
<![CDATA[
 
     Public Overrides Function CreateImplicitInstanceConstructors() As Boolean
         Dim result As Boolean = True
 
         'Find the default constructors for this class
         Me.FindDefaultConstructors()
 
         result = MyBase.CreateImplicitInstanceConstructors() AndAlso result
 
         'If a type contains no instance constructor declarations, a default constructor 
         'is automatically provided. The default constructor simply invokes the 
         'parameterless constructor of the direct base type. If the direct 
         'base type does not have an accessible parameterless constructor, 
         'a compile-time error occurs. 
         'The declared access type for the default constructor is always Public. 
         If HasInstanceConstructors = False Then
             Dim ctor As ConstructorDeclaration
             Dim modifiers As Modifiers
 
             If Me.Modifiers.Is(ModifierMasks.MustInherit) Then
                 modifiers.AddModifier(KS.Protected)
             End If
 
             ctor = New ConstructorDeclaration(Me)
             ctor.Init(modifiers, New SubSignature(ctor, ConstructorDeclaration.ConstructorName, New ParameterList(ctor)), New CodeBlock(ctor))
 
             Members.Add(ctor)
 
             result = ctor.CreateDefinition AndAlso result
             result = AddInitializeComponentCall(ctor) AndAlso result
 
             DefaultInstanceConstructor = ctor
             m_HasImplicitInstanceConstructor = True
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MyGenerator.vb" startline="112" endline="123">
<![CDATA[
 
     Overloads Function Equals(ByVal str As String) As Boolean
         If IsGlobal(str) Then
             If Me.Global = False Then
                 Return False
             Else
                 Return Helper.CompareName(RemoveGlobal(str), Me.Name)
             End If
         Else
             Return Helper.CompareName(str, Me.Name)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\EndStatement.vb" startline="34" endline="41">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__EndApp)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ReturnStatement.vb" startline="30" endline="38">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ' Helper.NotImplemented()
         Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.System_Diagnostics_Debugger__Break)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="43" endline="49">
<![CDATA[
 
     Function TypesAsArray() As Mono.Cecil.TypeReference()
         Dim result() As Mono.Cecil.TypeReference
         ReDim result(Me.Count - 1)
         MyBase.Values.CopyTo(result, 0)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="915" endline="923">
<![CDATA[
 
     Private Sub patch_length(ByVal w As IO.BinaryWriter, ByVal len_pos As Long)
         Dim ms As IO.Stream = w.BaseStream
 
         Dim pos As Long = ms.Position
         ms.Position = len_pos
         w.Write(CShort(pos - len_pos))
         ms.Position = pos
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\VariableInitializerList.vb" startline="30" endline="36">
<![CDATA[
     Overloads Sub Add(ByVal Name As String, ByVal Value As Object)
         Dim var As New VariablePropertyInitializer(Me)
         Dim exp As New AttributeArgumentExpression(var)
         exp.Init(New ConstantExpression(var, Value, CecilHelper.GetType(Compiler, Value)))
         var.Init(Name, exp)
         Add(var)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1264" endline="1270">
<![CDATA[
 
     Private Shared Sub AddPropertyUnlessSignatureMatches(ByVal properties As Mono.Collections.Generic.Collection(Of Mono.Cecil.PropertyReference), ByVal prop As Mono.Cecil.PropertyReference)
         For i As Integer = 0 To properties.Count - 1
             If Helper.CompareParameterTypes(prop.Parameters, properties(i).Parameters) = True Then Return
         Next
         properties.Add(prop)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="234" endline="246">
<![CDATA[
     End Property
 
     Function ToTypes() As Mono.Cecil.TypeReference()
         Dim result(m_Arguments.Count - 1) As Mono.Cecil.TypeReference
         For i As Integer = 0 To m_Arguments.Count - 1
             If m_Arguments(i).Expression Is Nothing Then
                 result(i) = New MissingType(Compiler)
             Else
                 result(i) = m_Arguments(i).Expression.ExpressionType
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Compiler.vb" startline="108" endline="123">
<![CDATA[
 
     Public ReadOnly Property AssemblyResolver() As DefaultAssemblyResolver
         Get
             If m_AssemblyResolver Is Nothing Then
                 m_AssemblyResolver = New DefaultAssemblyResolver()
                 'We don't want any automatic assembly resolving
                 For Each dir As String In m_AssemblyResolver.GetSearchDirectories()
                     m_AssemblyResolver.RemoveSearchDirectory(dir)
                 Next
                 'Add or own search paths
                 For Each dir As String In CommandLine.LibPath
                     m_AssemblyResolver.AddSearchDirectory(dir)
                 Next
             End If
             Return m_AssemblyResolver
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="607" endline="621">
<![CDATA[
 
     Sub RemoveNarrowing()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate.IsRemoved("RemoveNarrowing") Then Continue For
 
             If candidate.IsNarrowingInternal(False, Nothing) Then
                 Log("NARROWING    
                 candidate.RemovedBy = "RemoveNarrowing"
             Else
                 Log("NOT NARROWING
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2555" endline="2601">
<![CDATA[
 
     ''' <summary>
     ''' ArgumentList  
     '''                     PositionalArgumentList  |
     '''	                    NamedArgumentList
     ''' 
     ''' PositionalArgumentList  
     ''' 
     ''' NamedArgumentList  
     '''
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArgumentList(ByVal Parent As ParsedObject) As ArgumentList
         Dim result As New ArgumentList(Parent)
 
         Dim m_Arguments As New BaseObjects(Of Argument)(result)
 
         'First parse positional arguments
         Do
             'Check for named argument.
             If NamedArgument.CanBeMe(tm) Then Exit Do
 
             Dim exp As Expression
             exp = Nothing
 
             If tm.CurrentToken.Equals(KS.Comma) = False Then
                 exp = ParseExpression(result)
             End If
 
             Dim newPA As PositionalArgument
             newPA = New PositionalArgument(result, m_Arguments.Count, exp)
             m_Arguments.Add(newPA)
         Loop While tm.Accept(KS.Comma)
 
         'Then parse named arguments
         If NamedArgument.CanBeMe(tm) Then
             Do
                 Dim newArgument As NamedArgument
                 newArgument = ParseNamedArgument(result)
                 m_Arguments.Add(newArgument)
             Loop While tm.Accept(KS.Comma)
         End If
 
         result.Init(m_Arguments)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="577" endline="591">
<![CDATA[
 
     Sub RemoveInapplicable(ByVal error_lines As Generic.List(Of String))
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If m_Candidates(i).IsRemoved("RemoveInapplicable") Then Continue For
 
             If candidate.IsApplicable(error_lines) = False Then
                 Log("NOT APPLICABLE
                 m_Candidates(i).RemovedBy = "RemoveInapplicable"
             Else
                 Log("APPLICABLE    
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\AbstractMediaHandler.vb" startline="88" endline="112">
<![CDATA[
 
     Private Function ToXML() As Xml.XmlNode
         mDoc.LoadXml("<Tools/>")
         Dim Node, Value As XmlElement
         Dim Tool As ToolSpec
         For i As Integer = 0 To mList.Count - 1
             Tool = DirectCast(mList(i), ToolSpec)
             Node = mDoc.CreateElement("Tool")
 
             Value = mDoc.CreateElement("DisplayName")
             Value.InnerText = Tool.DisplayName
             Node.AppendChild(Value)
 
             Value = mDoc.CreateElement("Enabled")
             If Tool.Enabled Then Value.InnerText = "yes"
             Node.AppendChild(Value)
 
             Value = mDoc.CreateElement("Path")
             Value.InnerText = Tool.Path.Value
             Node.AppendChild(Value)
 
             mDoc.DocumentElement.AppendChild(Node)
         Next
         Return mDoc.DocumentElement
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="777" endline="807">
<![CDATA[
 
     Private Function GetDate() As Token
         Helper.Assert(CurrentChar() = "#"c, "GetDate called without a date!")
 
         EatWhiteSpace()
 
         Dim Count As Integer
         'Date value
         Dim bCont As Boolean = True
         StringBuilderLength = 0
         Do
             Count += 1
             Dim ch As Char = NextChar()
             If (IsNewLine()) Then
                 Compiler.Report.ShowMessage(Messages.VBNC90000, GetCurrentLocation())
                 bCont = False
             Else
                 Select Case ch
                     Case nl0
                         Compiler.Report.ShowMessage(Messages.VBNC90001, GetCurrentLocation())
                         bCont = False
                     Case "#"c
                         NextChar() 'The ending #
                         bCont = False
                 End Select
             End If
             If bCont Then StringBuilderAppend(ch)
         Loop While bCont
 
         Return Token.CreateDateToken(GetCurrentLocation, CDate(StringBuilderToString))
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="244" endline="265">
<![CDATA[
     End Property
 
     Private Function VerifyImplicitConstructor() As Boolean
         Dim result As Boolean = True
         Dim baseDefaultCtor As Mono.Cecil.MethodReference
 
         If m_HasImplicitInstanceConstructor = False Then Return result
 
         baseDefaultCtor = Me.GetBaseDefaultConstructor()
 
         If baseDefaultCtor IsNot Nothing Then
             If Helper.IsPrivate(baseDefaultCtor) Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC30387, Location, Name, BaseType.Name) AndAlso result
             Else
                 result = AddInitializeComponentCall(Me.DefaultInstanceConstructor) AndAlso result
             End If
         Else
             result = Compiler.Report.ShowMessage(Messages.VBNC30387, Location, Name, BaseType.Name) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="57" endline="79">
<![CDATA[
 
     Public Overrides Function CreateDefinition() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.CreateDefinition() AndAlso result
 
         If IsStatic Then
             If m_FieldBuilderStaticInit Is Nothing AndAlso HasInitializer Then
                 Dim staticName As String
                 Dim attr As Mono.Cecil.FieldAttributes = Mono.Cecil.FieldAttributes.Private
 
                 staticName = "$STATIC$" & Me.FindFirstParent(Of INameable).Name & "$" & Me.ObjectID.ToString & "$" & Me.Name & "$Init"
                 If DeclaringMethod.IsShared Then attr = attr Or Mono.Cecil.FieldAttributes.Static
 
                 m_FieldBuilderStaticInit = New Mono.Cecil.FieldDefinition(staticName, attr, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.MS_VB_CS_StaticLocalInitFlag))
                 DeclaringType.CecilType.Fields.Add(m_FieldBuilderStaticInit)
             End If
         Else
             'TODO
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\AbstractMediaHandler.vb" startline="191" endline="236">
<![CDATA[
 
 #End Region
 
 #Region "   Asynch Caller "
 
     Friend Sub RunConverter(ByVal Args As String)
 
         Dim CutterPath As String
         If String.IsNullOrEmpty(mCutterPath) Then
             CutterPath = System.AppDomain.CurrentDomain.BaseDirectory
         Else
             CutterPath = mCutterPath
         End If
         ProcessCaller.FileName = CutterPath + mConverter
         ProcessCaller.WorkingDirectory = CutterPath
 
         ProcessCaller.Arguments = Args
 
         Dim Text As String
         Text = vbCrLf + "Using converter 
         Text += vbCrLf + "With arguments 
         Text += vbCrLf + "Please wait..." & vbCrLf
         mParent.UpdateRTF(Text, modMain.MessageType.AsUsual)
         mParent.UpdateRTF("Detailed results will follow
             modMain.MessageType.AsUsual)
 
         Dim i As Integer
         For i = 1 To 5
             Try
                 ProcessCaller.Start()
                 ProcessCaller.WaitUntilDone()
                 Do While Not ProcessCaller.IsDone
                     Threading.Thread.Sleep(1000)
                     Application.DoEvents()
                 Loop
                 Do While Not ProcessCaller.IsDone
                     Threading.Thread.Sleep(1000)
                     Application.DoEvents()
                 Loop
                 Exit For
             Catch ex As Exception
                 Thread.Sleep(500)
                 Debug.WriteLine(ex.Message)
             End Try
         Next
 
         If i = 6 Then
             MsgBox("Could not complete operation. Please try again later.")
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="273" endline="297">
<![CDATA[
 
     Public Function ConvertToChar(ByRef result As Object, ByVal ShowError As Boolean) As Boolean
         Dim tpCode As TypeCode
 
         tpCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, result))
 
         Select Case tpCode
             Case TypeCode.String
                 If CStr(result).Length = 1 Then
                     result = CChar(result)
                 Else
                     If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30060, Location, result.ToString, ExpressionType.ToString)
                     Return False
                 End If
             Case TypeCode.Char
                 result = CChar(result)
             Case TypeCode.DBNull
                 result = VB.ChrW(0)
             Case Else
                 If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30060, Location, result.ToString, ExpressionType.ToString)
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4403" endline="4453">
<![CDATA[
 
     ''' <summary>
     ''' SubDeclaration  
     '''	[  Attributes  ]  [  ProcedureModifier+  ] "Sub" SubSignature  [  HandlesOrImplements  ]  LineTerminator
     '''	Block
     '''	"End" "Sub" StatementTerminator
     ''' 
     ''' MustOverrideSubDeclaration  
     '''	[  Attributes  ]  [  MustOverrideProcedureModifier+  ] "Sub" SubSignature  [  HandlesOrImplements  ]
     '''		StatementTerminator
     '''
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSubDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As SubDeclaration
         Dim result As New SubDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As SubSignature = Nothing
         Dim m_HandlesOrImplements As HandlesOrImplements = Nothing
         Dim m_Block As CodeBlock = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.MustOverrideProcedureModifiers)
 
         tm.AcceptIfNotInternalError(KS.Sub)
 
         m_Signature = ParseSubSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If vbnc.HandlesOrImplements.IsMe(tm) Then
             m_HandlesOrImplements = ParseHandlesOrImplements(result)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If m_Modifiers.Is(ModifierMasks.MustOverride) = False Then
             m_Block = ParseCodeBlock(result, False)
             If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             If tm.AcceptIfNotError(KS.End, KS.Sub) = False Then
                 tm.GotoNewline(False)
             End If
             If tm.AcceptEndOfStatement(, True) = False Then
                 tm.GotoNewline(True)
             End If
         End If
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, m_HandlesOrImplements, m_Block)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="152" endline="189">
<![CDATA[
     End Property
 
     Public Function Resolve() As Boolean
         Dim result As Boolean = True
 
         'If m_Resolved AndAlso ShowErrors = False Then Helper.StopIfDebugging()
 
         Log("")
         Log("Resolving method {0} with arguments {1}", ArgumentsTypesAsString)
 
         result = ResolveInternal()
 
         If result Then
             Helper.Assert(CandidatesLeft = 1 OrElse IsLateBound)
 
             If IsLateBound Then
                 m_ResolvedCandidate = Nothing
             Else
                 SelectMostApplicableParamArraysVersion()
 
                 For Each member As MemberCandidate In m_Candidates
                     If member.RemovedBy IsNot Nothing Then Continue For
 
                     If IsValidCandidate(member) = False Then
                         result = Compiler.Report.ShowMessage(Messages.VBNC30657, Parent.Location, member.Member.Name)
                         Exit For
                     End If
                     m_ResolvedCandidate = member
                     m_ResolvedCandidate.SelectOutputArguments()
                     Exit For
                 Next
             End If
         End If
 
         m_Resolved = True
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\ImportsClause.vb" startline="78" endline="112">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Dim nri As TypeNameResolutionInfo
         If IsConstructedTypeName Then
             nri = New TypeNameResolutionInfo(AsConstructedTypeName, Me)
         ElseIf IsQualifiedIdentifier Then
             nri = New TypeNameResolutionInfo(AsQualifiedIdentifier, Me)
         Else
             Throw New InternalException(Me)
         End If
         nri.IsImportsResolution = True
         result = nri.Resolve AndAlso result
 
         If nri.FoundOnlyOneObject = False Then
             'Do not propage error condition here, since this message is a warning
 			Compiler.Report.ShowMessage(Messages.VBNC40056, Location, Name)
             Return True
         End If
 
         If nri.FoundIs(Of [Namespace])() Then
             m_Namespace = nri.FoundAs(Of [Namespace])()
         ElseIf nri.FoundIs(Of TypeDeclaration)() Then
             m_Type = nri.FoundAs(Of TypeDeclaration).CecilType
         ElseIf nri.FoundIs(Of Type)() Then
             m_Type = nri.FoundAs(Of Mono.Cecil.TypeReference)()
         ElseIf nri.FoundIs(Of Mono.Cecil.TypeReference)() Then
             m_Type = nri.FoundAs(Of Mono.Cecil.TypeReference)()
         Else
             Helper.AddError(Me)
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MyGenerator.vb" startline="65" endline="72">
<![CDATA[
 
     Overrides Function ToString() As String
         If m_Global Then
             Return "Global." & m_Name
         Else
             Return m_Name
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="28" endline="36">
<![CDATA[
 
     Shadows Sub Add(ByVal Type As Mono.Cecil.TypeReference)
         Dim name As String = Type.Name
         If MyBase.ContainsKey(name) Then
             'System.Console.WriteLine("Already added type
         Else
             MyBase.Add(name, Type)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\LateBoundAccessToValueExpression.vb" startline="39" endline="45">
<![CDATA[
         Get
             If m_First IsNot Nothing Then
                 Return m_First.AsString & "." & m_Second.Identifier
             Else
                 Return "." & m_Second.Identifier
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="251" endline="261">
<![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             If Me.IsResolved Then
                 Return m_ExpressionType
             ElseIf m_ExpressionType IsNot Nothing Then
                 Return m_ExpressionType
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\MPGhandler.vb" startline="177" endline="185">
<![CDATA[
 
     Private Function GetDuration() As Double
         Dim Pos As Integer = InStrRev(mParent.rtfTrace.Text, "Estimated Duration
         If Pos > 0 Then
             Return Val(mParent.rtfTrace.Text.Substring(Pos + 19, 9))
         Else
             Return 999999999999
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\PositionalArgument.vb" startline="27" endline="35">
<![CDATA[
         Get
             Dim result As String = ""
             If m_PropertyAccess.InstanceExpression IsNot Nothing Then
                 result = m_PropertyAccess.InstanceExpression.AsString & "."
             End If
             result &= m_PropertyAccess.ResolvedProperty.Name
             result &= "(" & m_PropertyAccess.Parameters.AsString & ")"
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3519" endline="3536">
<![CDATA[
 
     Private Function ParseBooleanLiteralExpression(ByVal Parent As ParsedObject) As BooleanLiteralExpression
         Dim result As New BooleanLiteralExpression(Parent)
 
         Dim m_Value As Boolean
 
         If tm.Accept(KS.True) Then
             m_Value = True
         ElseIf tm.Accept(KS.False) Then
             m_Value = False
         Else
             Throw New InternalException(result)
         End If
 
         result.Init(m_Value)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5032" endline="5054">
<![CDATA[
 
     ''' <summary>
     ''' ThrowStatement  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseThrowStatement(ByVal Parent As ParsedObject) As ThrowStatement
         Dim result As New ThrowStatement(Parent)
 
         Dim m_Exception As Expression
 
         tm.AcceptIfNotInternalError(KS.Throw)
 
         If tm.CurrentToken.IsEndOfStatement = False Then
             m_Exception = ParseExpression(result)
             If m_Exception Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Exception = Nothing
         End If
 
         result.Init(m_Exception)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5245" endline="5262">
<![CDATA[
 
     Private Function ParseReturnStatement(ByVal Parent As ParsedObject) As ReturnStatement
         Dim result As New ReturnStatement(Parent)
 
         Dim m_Expression As Expression
 
         tm.AcceptIfNotInternalError(KS.Return)
         If Not tm.CurrentToken.IsEndOfStatement Then
             m_Expression = ParseExpression(result)
             If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Expression = Nothing
         End If
 
         result.Init(m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="499" endline="516">
<![CDATA[
     ''' <summary>
     '''  Parses attributes (if any). Always returns something.
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributes(ByVal Parent As ParsedObject) As Attributes
         Dim result As Attributes = Nothing
 
         If Attributes.IsMe(tm) Then
             While AttributeBlock.IsMe(tm)
                 If result Is Nothing Then result = New Attributes(Parent)
                 If ParseAttributeBlock(Parent, result) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
             End While
             While AttributeBlock.IsMe(tm)
                 If result Is Nothing Then result = New Attributes(Parent)
                 If ParseAttributeBlock(Parent, result) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
             End While
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="348" endline="375">
<![CDATA[
 
     ''' <summary>
     ''' ImportsAliasClause  
     '''	Identifier  =  QualifiedIdentifier  |
     '''	Identifier  =  ConstructedTypeName
     ''' 
     ''' ConstructedTypeName  
     '''	QualifiedIdentifier  "("  "Of"  TypeArgumentList  ")"
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseImportsAliasClause(ByVal Parent As ParsedObject) As ImportsAliasClause
         Dim result As New ImportsAliasClause(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_Second As ImportsNamespaceClause = Nothing
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         tm.AcceptIfNotInternalError(KS.Equals)
 
         m_Second = ParseImportsNamespaceClause(result)
         If m_Second Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_Identifier, m_Second)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="4488" endline="4508">
<![CDATA[
 
     Private Sub DrawPos(ByVal Ctl As PictureBox, ByVal pen As Pen, ByVal Pos As Double)
 
         Dim bitmap As Bitmap = Nothing
         Dim g As Graphics = Nothing
 
         bitmap = New Bitmap(Ctl.Width, Ctl.Height)
         g = Graphics.FromImage(bitmap)
         g.Clear(Color.Black)
 
         Dim x As Integer = CInt(Ctl.Width * Pos)
         g.DrawLine(pen, x, 0, x, Ctl.Height - 1)
         bitmap.MakeTransparent(Color.Black)
 
         If Not g Is Nothing Then
             g.Dispose()
         End If
 
         Ctl.Image = bitmap
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="160" endline="188">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The type of the method group, is the return type of the method.
     ''' If this method is a sub, the return type is System.Void.
     ''' If this is a constructor, the return type is nothing.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property Type() As Mono.Cecil.TypeReference
         Get
             If SuccessfullyResolved = False Then Throw New InternalException(Me)
             Dim m As Mono.Cecil.MethodReference = ResolvedMethodInfo
             If m Is Nothing Then
                 Dim c As Mono.Cecil.MethodReference = ResolvedConstructor
                 If c Is Nothing Then
                     Throw New InternalException(Me)
                 Else
                     Return Nothing
                 End If
             Else
                 If m.ReturnType Is Nothing Then
                     Return Compiler.TypeCache.System_Void
                 Else
                     Return m.ReturnType
                 End If
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="447" endline="468">
<![CDATA[
 
     Private Function ResolvePropertyGroupInvocation() As Boolean
         Dim result As Boolean = True
         Dim propGroup As PropertyGroupClassification = m_Expression.Classification.AsPropertyGroup
         Dim tmpResult As Boolean
 
         tmpResult = propGroup.ResolveGroup(m_ArgumentList)
 
         If tmpResult = False Then
             tmpResult = ResolveReclassifyToValueThenIndex()
 
             Helper.StopIfDebugging(tmpResult = False)
 
             Return tmpResult
         Else
             result = m_ArgumentList.ReplaceAndVerifyArguments(propGroup.FinalArguments, propGroup.ResolvedProperty, True) AndAlso result
         End If
 
         Classification = New PropertyAccessClassification(propGroup)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="480" endline="504">
<![CDATA[
 
     Public Shared Function GetCorrectMember(ByVal Member As FieldDefinition, ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.FieldReference
         Dim result As Mono.Cecil.FieldReference
         Dim genericType As Mono.Cecil.GenericInstanceType = TryCast(Type, Mono.Cecil.GenericInstanceType)
         Dim elementType As Mono.Cecil.TypeDefinition
         Dim fieldType As Mono.Cecil.TypeReference
 
         If genericType Is Nothing Then
             Return Member
         End If
 
         elementType = CecilHelper.FindDefinition(genericType.ElementType)
         fieldType = CecilHelper.ResolveType(Member.FieldType, elementType.GenericParameters, genericType.GenericArguments)
 
         'If fieldType IsNot Member.FieldType Then
         fieldType = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, fieldType)
 
         result = New FieldReference(Member.Name, fieldType, Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, Member.DeclaringType))
         result.Annotations.Add("MemberInReflection", New FieldReference(Member.Name, Member.FieldType, genericType))
         Return result
         'Else
         '    Return Member
         'End If
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="733" endline="750">
<![CDATA[
 
     Private Sub EatNewLine()
         Select Case CurrentChar()
             Case nlD
                 NextChar()
                 If CurrentChar() = nlA Then
                     NextChar()
                 End If
                 IncLine()
             Case nlA, nl2029, nl2028
                 NextChar()
                 IncLine()
             Case nl0
                 IncLine()
             Case Else
                 Throw New InternalException("Current character is not a new line.")
         End Select
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4465" endline="4488">
<![CDATA[
 
     Shared Function GetVisibility(ByVal Compiler As Compiler, ByVal CallerType As Mono.Cecil.TypeReference, ByVal CalledType As Mono.Cecil.TypeReference) As MemberVisibility
         Helper.Assert(CallerType IsNot Nothing)
         Helper.Assert(CalledType IsNot Nothing)
         Helper.Assert(Compiler.Assembly.IsDefinedHere(CallerType))
 
         If Helper.CompareType(CallerType, CalledType) Then Return MemberVisibility.All
 
         If Compiler.Assembly.IsDefinedHere(CalledType) Then
             If Helper.IsNested(CalledType, CallerType) Then
                 Return MemberVisibility.All
             ElseIf Helper.IsSubclassOf(CalledType, CallerType) Then
                 Return MemberVisibility.PublicProtectedFriend
             Else
                 Return MemberVisibility.PublicFriend
             End If
         Else
             If Helper.IsSubclassOf(CalledType, CallerType) Then
                 Return MemberVisibility.PublicProtected
             Else
                 Return MemberVisibility.Public
             End If
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2349" endline="2362">
<![CDATA[
 
     Private Sub TestSegment()
         If lvPositions.Items.Count = 0 Then Exit Sub
         With lvPositions.SelectedItems
             If .Count = 0 Then Exit Sub
             ReDim mPlaySegments(.Count - 1)
             For i As Integer = 0 To .Count - 1
                 mPlaySegments(i) = New Segment
                 mPlaySegments(i).Start = MinToSec(.Item(i).Text)
                 mPlaySegments(i).Finish = MinToSec(.Item(i).SubItems(1).Text)
             Next
         End With
         PlaySelectedSegments()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="424" endline="446">
<![CDATA[
 
     Function RuleNot(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing
 
         If CurrentToken.Equals(KS.Not) Then
             NextToken()
             RuleNot = RuleRelational(LSide)
 
             Dim op1 As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 LSide = 0
             Else
                 LSide = Not op1
             End If
         Else
             If RuleRelational(LSide) = False Then
                 Return False
             End If
         End If
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="882" endline="911">
<![CDATA[
 
     Private Sub BWDiagnostics_RunWorkerCompleted(ByVal sender As Object, ByVal e As System.ComponentModel.RunWorkerCompletedEventArgs) Handles BWDiagnostics.RunWorkerCompleted
 
         ToolTip.SetToolTip(BtnDiagnostics, "Run Services Diagnostics")
 
         If Problem = 0 Then
 
             Try
                 BtnDiagnostics.Values.Image = New Bitmap(DataDir & "ok_status.png")
             Catch ex As ArgumentException
             End Try
             LblDiagnostics_Status.ForeColor = Color.RoyalBlue
             LblDiagnostics_Status.Text = "no problem found"
 
         ElseIf Problem > 0 Then
 
             Try
                 BtnDiagnostics.Values.Image = New Bitmap(DataDir & "critical_status.png")
             Catch ex As ArgumentException
             End Try
             LblDiagnostics_Status.ForeColor = Color.Red
 
             If Problem = 1 Then
                 LblDiagnostics_Status.Text = ("1 problem found")
             ElseIf Problem > 1 Then
                 LblDiagnostics_Status.Text = (Problem & " problems found")
             End If
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4500" endline="4538">
<![CDATA[
 
     ''' <summary>
     ''' EventMemberSpecifier  
     '''  QualifiedIdentifier  "."  IdentifierOrKeyword  |
     '''  MyBase  "."  IdentifierOrKeyword  |
     '''	 Me  "."  IdentifierOrKeyword
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEventMemberSpecifier(ByVal Parent As ParsedObject) As EventMemberSpecifier
         Dim result As New EventMemberSpecifier(Parent)
 
         Dim m_First As Expression
         Dim m_Second As IdentifierOrKeyword
 
         If tm.CurrentToken = KS.MyBase Then
             m_First = ParseMyBaseExpression(result)
         ElseIf tm.CurrentToken = KS.Me Then
             m_First = ParseMeExpression(result)
         Else
             Dim id As Identifier
             id = ParseIdentifier(result)
             If id Is Nothing Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             Dim sne As New SimpleNameExpression(result)
             sne.Init(id, New TypeArgumentList(sne))
             m_First = sne
         End If
         If m_First Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.Dot) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Second = ParseIdentifierOrKeyword(result)
         If m_Second Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_First, m_Second)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="111" endline="125">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_LoopControlVariable IsNot Nothing Then result = m_LoopControlVariable.ResolveTypeReferences AndAlso result
         If m_LoopStartExpression IsNot Nothing Then result = m_LoopStartExpression.ResolveTypeReferences AndAlso result
         If m_LoopEndExpression IsNot Nothing Then result = m_LoopEndExpression.ResolveTypeReferences AndAlso result
         If m_LoopStepExpression IsNot Nothing Then result = m_LoopStepExpression.ResolveTypeReferences AndAlso result
         If m_NextExpressionList IsNot Nothing Then result = m_NextExpressionList.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="556" endline="576">
<![CDATA[
 
     'Helper conversion functions
     Private Function ToDouble(ByVal value As Object, ByRef Result As Double) As Boolean
         Dim vTp As Mono.Cecil.TypeReference = CecilHelper.GetType(Compiler, value)
         If Helper.CompareType(vTp, Compiler.TypeCache.System_Byte) OrElse _
             Helper.CompareType(vTp, Compiler.TypeCache.System_Decimal) OrElse _
             Helper.CompareType(vTp, Compiler.TypeCache.System_Double) OrElse _
             Helper.CompareType(vTp, Compiler.TypeCache.System_Int32) OrElse _
             Helper.CompareType(vTp, Compiler.TypeCache.System_Int64) OrElse _
             Helper.CompareType(vTp, Compiler.TypeCache.System_SByte) OrElse _
             Helper.CompareType(vTp, Compiler.TypeCache.System_Int16) OrElse _
             Helper.CompareType(vTp, Compiler.TypeCache.System_Single) OrElse _
             Helper.CompareType(vTp, Compiler.TypeCache.System_UInt32) OrElse _
             Helper.CompareType(vTp, Compiler.TypeCache.System_UInt64) OrElse _
             Helper.CompareType(vTp, Compiler.TypeCache.System_UInt16) Then
             Result = CDbl(value)
             Return True
         Else
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2368" endline="2398">
<![CDATA[
 
     Private Function ParseCTypeExpression(ByVal Parent As ParsedObject, ByVal GetKeyword As KS) As CTypeExpression
         Dim result As CTypeExpression = Nothing
 
         Dim m_DestinationType As TypeName
         Dim m_Expression As Expression
 
         Select Case GetKeyword
             Case KS.CType
                 result = New CTypeExpression(Parent, True)
             Case KS.DirectCast
                 result = New DirectCastExpression(Parent)
             Case KS.TryCast
                 result = New TryCastExpression(Parent)
             Case Else
                 Throw New InternalException(result)
         End Select
 
         tm.AcceptIfNotInternalError(GetKeyword)
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         m_Expression = ParseExpression(result)
         If tm.AcceptIfNotError(KS.Comma) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         m_DestinationType = ParseTypeName(result)
         If m_DestinationType Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
 
         result.Init(m_Expression, m_DestinationType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1536" endline="1560">
<![CDATA[
 
     Shared Sub EmitLoadVariableLocation(ByVal Info As EmitInfo, ByVal Variable As VariableClassification)
         If Variable.LocalBuilder IsNot Nothing Then
             Info.ILGen.Emit(OpCodes.Ldloca, Variable.LocalBuilder)
         ElseIf Variable.FieldInfo IsNot Nothing Then
             Dim emittableField As Mono.Cecil.FieldReference = Helper.GetFieldOrFieldReference(Info.Compiler, Variable.FieldInfo)
             If Variable.InstanceExpression IsNot Nothing Then
                 Dim result As Boolean
                 result = Variable.InstanceExpression.GenerateCode(Info)
                 Helper.Assert(result)
                 'Helper.Assert(Variable.FieldInfo.IsStatic = False)
                 Info.ILGen.Emit(OpCodes.Ldflda, emittableField)
             Else
                 Helper.Assert(CecilHelper.IsStatic(Variable.FieldInfo))
                 Info.ILGen.Emit(OpCodes.Ldsflda, emittableField)
             End If
          ElseIf Variable.ParameterInfo IsNot Nothing Then
             Helper.Assert(Variable.InstanceExpression Is Nothing)
             EmitLoadParameterAddress(Info, Variable.ParameterInfo)
         ElseIf Variable.Method IsNot Nothing Then
             Info.ILGen.Emit(OpCodes.Ldloca, Variable.Method.DefaultReturnVariable)
         Else
             Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="288" endline="317">
<![CDATA[
 
     Public Overrides Function GetConstant(ByRef result As Object, ByVal ShowError As Boolean) As Boolean
         'Check for constant expression
         If m_AscWExpression IsNot Nothing Then
             If m_AscWExpression.GetConstant(result, False) Then
                 result = Microsoft.VisualBasic.AscW(CChar(result))
                 Return True
             End If
         ElseIf m_ArgumentList.Count = 1 AndAlso m_Expression.Classification.IsMethodGroupClassification Then
             Dim param As Object = Nothing
             Dim mgc As MethodGroupClassification = m_Expression.Classification.AsMethodGroupClassification
 
             If mgc.IsLateBound = False Then
                 Dim mi As Mono.Cecil.MethodReference = mgc.ResolvedMethodInfo
                 If mi IsNot Nothing Then
                     If m_ArgumentList(0).Expression IsNot Nothing Then
                         If m_ArgumentList(0).Expression.GetConstant(param, False) Then
                             If Compiler.NameResolver.IsConstantMethod(mi, param, param) Then
                                 result = param
                                 Return True
                             End If
                         End If
                     End If
                 End If
             End If
         End If
 
         If ShowError Then Show30059()
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="1999" endline="2032">
<![CDATA[
 
     Private Sub OpenFile(ByVal Filename As String, Optional ByVal MaskName As String = "")
 
         Waiting(True)
         Dim fi As New FileInfo(Filename)
         If UCase(fi.Extension) = ".MOVICLIP" Then
             LoadMask(Filename)
             Exit Sub
         End If
 
         mFileLoaded = False
         mInFile = Filename
 
         statMain.Text = mTranslator.LangText(96)
         Try
             If CreateHandler(fi.Extension) Then
                 mPlayer.URL = mInFile
                 mMRU.Add(Filename)
             End If
         Catch ex As Exception
             Debug.WriteLine(mTranslator.LangText(112) & vbCrLf & ex.Message)
             If Len(MaskName) > 0 Then lvPositions.Items.Clear()
             mPlayer.URL = ""
             Waiting(False)
             Exit Sub
         End Try
 
         UpdateTitle(fi.Name, MaskName)
         tFile2Split.Text = Trim(fi.Name)
         mainTabs.SelectedTab = tabPlayer
 
         UpdateEditorOptions(fi.Extension)
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\DotAccessExpression.vb" startline="355" endline="403">
<![CDATA[
 
     ''' <summary>
     ''' The resulting expression is NOT resolved.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function ReclassifyToPropertyAccessExpression() As Expression
         Dim result As Expression
         Select Case m_Classification.Classification
             Case ExpressionClassification.Classifications.PropertyGroup
                 Dim pgClass As PropertyGroupClassification = Me.Classification.AsPropertyGroup
                 result = New PropertyGroupToPropertyAccessExpression(Me, pgClass)
             Case ExpressionClassification.Classifications.Value
                 Throw New InternalException(Me)
             Case ExpressionClassification.Classifications.Variable
                 Throw New InternalException(Me)
             Case ExpressionClassification.Classifications.EventAccess
                 Throw New InternalException(Me)
             Case ExpressionClassification.Classifications.LateBoundAccess
                 Return New LateBoundAccessToPropertyAccessExpression(Me, Me.Classification.AsLateBoundAccess)
             Case ExpressionClassification.Classifications.MethodGroup
                 Throw New InternalException(Me)
             Case ExpressionClassification.Classifications.MethodPointer
                 Throw New InternalException(Me)
             Case ExpressionClassification.Classifications.PropertyAccess
                 Throw New InternalException(Me)
             Case ExpressionClassification.Classifications.Void
                 Throw New InternalException(Me)
             Case ExpressionClassification.Classifications.Type
                 Dim exp As Expression = Nothing
                 If m_Classification.AsTypeClassification.CreateAliasExpression(Me, exp) = False Then
                     Throw New InternalException(Me)
                 End If
                 If exp.Classification.IsPropertyGroupClassification Then
                     exp = exp.ReclassifyToPropertyAccessExpression
                     If exp.ResolveExpression(ResolveInfo.Default(Compiler)) = False Then
                         Throw New InternalException(Me)
                     End If
                 End If
                 Helper.Assert(exp.Classification.IsPropertyAccessClassification)
                 Return exp
             Case ExpressionClassification.Classifications.Namespace
                 Throw New InternalException(Me)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\PropertyGetDeclaration.vb" startline="33" endline="68">
<![CDATA[
 
     Public Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal ImplementsClause As MemberImplementsClause, ByVal Block As CodeBlock)
         Dim mySignature As FunctionSignature
 
         mySignature = New FunctionSignature(Me)
 
         Dim typeParams As TypeParameters
         Dim retTypeAttributes As Attributes
         Dim name As String
         Dim params As ParameterList
         Dim typename As TypeName
 
         typeParams = PropertySignature.TypeParameters
         If PropertySignature.ReturnTypeAttributes IsNot Nothing Then
             retTypeAttributes = PropertySignature.ReturnTypeAttributes.Clone(mySignature)
         Else
             retTypeAttributes = Nothing
         End If
         If PropertySignature.Parameters IsNot Nothing Then
             params = PropertySignature.Parameters.Clone(Me)
         Else
             params = Nothing
         End If
         If PropertySignature.TypeName IsNot Nothing Then
             typename = PropertySignature.TypeName
         ElseIf PropertySignature.ReturnType IsNot Nothing Then
             typename = New TypeName(mySignature, PropertySignature.ReturnType)
         Else
             typename = Nothing
         End If
         name = "get_" & PropertySignature.Name
 
         mySignature.Init(New Identifier(mySignature, name, PropertySignature.Location, PropertySignature.Identifier.TypeCharacter), typeParams, params, retTypeAttributes, typename, PropertySignature.Location)
 
         MyBase.Init(Modifiers, mySignature, ImplementsClause, Block)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4350" endline="4402">
<![CDATA[
 
     ''' <summary>
     ''' FunctionDeclaration  
     '''	[  Attributes  ]  [  ProcedureModifier+  ]  "Function" FunctionSignature  [  HandlesOrImplements  ]
     '''		LineTerminator
     '''	Block
     '''	"End" "Function" StatementTerminator
     ''' 
     ''' MustOverrideFunctionDeclaration  
     '''	[  Attributes  ]  [  MustOverrideProcedureModifier+  ]  "Function" FunctionSignature
     '''		[  HandlesOrImplements  ]  StatementTerminator
     '''
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseFunctionDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As FunctionDeclaration
         Dim result As New FunctionDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Signature As FunctionSignature = Nothing
         Dim m_HandlesOrImplements As HandlesOrImplements = Nothing
         Dim m_Block As CodeBlock = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.MustOverrideProcedureModifiers)
 
         tm.AcceptIfNotInternalError(KS.Function)
 
         m_Signature = ParseFunctionSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If vbnc.HandlesOrImplements.IsMe(tm) Then
             m_HandlesOrImplements = ParseHandlesOrImplements(result)
             If m_HandlesOrImplements Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then tm.GotoNewline(True)
 
         If m_Modifiers.Is(ModifierMasks.MustOverride) = False Then
             m_Block = ParseCodeBlock(result, False)
             If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             If tm.AcceptIfNotError(KS.End, KS.Function) = False Then
                 tm.GotoNewline(False)
             End If
             If tm.AcceptEndOfStatement(, True) = False Then
                 tm.GotoNewline(True)
             End If
         End If
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, m_HandlesOrImplements, m_Block)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="774" endline="819">
<![CDATA[
 
     ''' <summary>
     ''' ArrayCreationExpression    
     ''' 
     ''' LAMESPEC? I think the following should be used
     ''' ArrayCreationExpression    
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArrayCreationExpression(ByVal Parent As ParsedObject) As ArrayCreationExpression
         Dim result As New ArrayCreationExpression(Parent)
 
         Dim m_ArrayElementInitializer As ArrayElementInitializer
         Dim m_NonArrayTypeName As NonArrayTypeName
         Dim m_ArrayNameModifier As ArrayNameModifier
 
         tm.AcceptIfNotInternalError(KS.[New])
 
         m_NonArrayTypeName = ParseNonArrayTypeName(result)
 
         If tm.CurrentToken <> KS.LParenthesis Then
             If ShowErrors Then tm.AcceptIfNotError(KS.LParenthesis)
             Return Nothing
         End If
         If ArrayNameModifier.CanBeMe(tm) = False Then
             If ShowErrors Then Compiler.Report.ShowMessage(Messages.VBNC90007, tm.CurrentLocation, tm.CurrentToken.ToString)
             Return Nothing
         End If
 
         m_ArrayNameModifier = ParseArrayNameModifier(result)
         If m_ArrayNameModifier Is Nothing Then
             If m_ShowErrors = False Then Return Nothing
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.CurrentToken <> KS.LBrace Then
             If ShowErrors Then tm.AcceptIfNotError(KS.LBrace)
             Return Nothing
         End If
 
         m_ArrayElementInitializer = ParseArrayElementInitializer(result)
         If m_ArrayElementInitializer Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_NonArrayTypeName, m_ArrayNameModifier, m_ArrayElementInitializer)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="159" endline="196">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim sne As SimpleNameExpression
 
         If m_Expression IsNot Nothing Then
             sne = TryCast(m_Expression, SimpleNameExpression)
             If sne IsNot Nothing Then
                 sne.InferEnabled = Me.IsOptionInferOn
                 If sne.ResolveExpression(Info) = False Then
                     If sne.InferPossible Then
                         MustInfer = True
                         result = True 'So far so good
                     Else
                         result = False
                     End If
                 End If
             Else
                 result = m_Expression.ResolveExpression(Info) AndAlso result
 
                 Dim iie As InvocationOrIndexExpression = TryCast(m_Expression, InvocationOrIndexExpression)
                 If iie IsNot Nothing AndAlso iie.IsLateBoundArray Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC30039, Location) AndAlso result
                 End If
             End If
         Else
             'result = m_Identifier.Resolve AndAlso result
             'result = m_ArrayNameModifier.Resolve AndAlso result
             result = m_TypeName.ResolveTypeReferences AndAlso result
             m_Declaration = New LocalVariableDeclaration(Me, New Modifiers(), m_Identifier, False, m_TypeName, Nothing, Nothing)
             result = m_Declaration.ResolveTypeReferences() AndAlso result
             'result = m_Declaration.ResolveMember(ResolveInfo.Default(Info.Compiler)) AndAlso result
             result = m_Declaration.ResolveCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\MainForm.cs" startline="656" endline="666">
<![CDATA[
 
 		#endregion
 
 		private void heartbeatChangeTimer_Tick(object sender, EventArgs e)
 		{
 			long nowTicks = DateTime.Now.Ticks;
 			if(nowTicks - lastHeartbeatIconChange >= 1500000)
 			{
 				notifyIcon.Icon = appIcon;
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="562" endline="576">
<![CDATA[
 
     Sub RemoveInapplicable_ParameterCount()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If m_Candidates(i).IsRemoved("RemoveInapplicable_ParameterCount") Then Continue For
 
             If candidate.IsApplicable_ParameterCount() = False Then
                 Log("NOT PC APPLICABLE
                 m_Candidates(i).RemovedBy = "RemoveInapplicable_ParameterCount"
             Else
                 Log("PC APPLICABLE    
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Classes\GMode.vb" startline="254" endline="275">
<![CDATA[
 
     Private Sub TurnOff(ByVal Name As String, ByVal Setting As String)
 
         Try
             SrvcCntrl.ServiceName = (Name)
             Dim ChkSrvc As Boolean = SrvcCntrl.CanPauseAndContinue
         Catch ex As InvalidOperationException
             Exit Sub
         End Try
 
         If String.Compare(Setting, (Name & "1"), True) = 0 Then
             If SrvcCntrl.Status = ServiceProcess.ServiceControllerStatus.Stopped OrElse SrvcCntrl.Status = ServiceProcess.ServiceControllerStatus.StopPending Then
                 Try
                     SrvcCntrl.Start()
                     SrvcCntrl.WaitForStatus(ServiceProcess.ServiceControllerStatus.Running, TimeSpan.FromSeconds(3))
                 Catch ex As InvalidOperationException
                 Catch ex As System.ServiceProcess.TimeoutException
                 End Try
             End If
         End If
         
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="1772" endline="1867">
<![CDATA[
 
 #End Region
 
 #Region "   WinAPI declares "
 
     Private Structure SHFILEOPSTRUCT
         Dim hwnd As Integer
         Dim wFunc As Integer
         Dim pFrom As String
         Dim pTo As String
         Dim fFlags As Short
         Dim fAnyOperationsAborted As Boolean
         Dim hNameMappings As Integer
         Dim lpszProgressTitle As String
     End Structure
 
     Private Const FO_DELETE As Short = &H3S
     Private Const FOF_ALLOWUNDO As Short = &H40S
     Private Const FOF_NOCONFIRMATION As Short = &H10S
 
     Private Declare Function SHFileOperation Lib "shell32.dll" Alias _
       "SHFileOperationA" (ByRef lpFileOp As SHFILEOPSTRUCT) As Integer
 
 #End Region
 
 #Region "   Constants and Variables "
 
     Private mFileLoaded As Boolean
     Private mSliderMoving As Boolean
     Private mInFile As String
     Private mHandler As AbstractMediaHandler
     Private mFrameAdjPossible As Boolean
     Private mSelStrt, mSelStop As Double
     Private mOneSidedSelection As Boolean
     Private mItems As ListViewItem()                    'Holds items during cut-paste
     Private mTypes As New MediaTypes
     Private mFFwd As Boolean
     Private mFRev As Boolean
     Private mAllowListIndexChange As Boolean = True     'Some event model workaround
     Private mPlaySelected As Boolean = False
     Private mPlaySelIndex As Integer = 0
     Private mPlaySegments As Segment()
     Private mMaskFile As Boolean
     Private mMaskFilename As String
     Private mRepeatPlay As Boolean
     Private mPlayMuted As Boolean
     Private mSuspendPlayerRefresh As Boolean
     Private mStdToolMgr As New StdToolMgr
     Private mnuArr(0) As MenuItem
     Private mSelsDirty As Boolean                       'To track the selection list changes
 
     Private mAudioWF As WaveForm
     Private mIsAudio As Boolean
     Private mDisplayControl As Windows.Forms.Control = mPlayer
 
     Private Const mReactTime As Double = 0.15
 
     Private mOpenFileExtender As New cOpenFileDialogExt
 
 #End Region
 
 #Region "   Load and unload "
 
     Private Sub frmMain_Load(ByVal sender As Object, _
 ByVal e As System.EventArgs) Handles MyBase.Load
 
         DisplayFineControls(False)
         mPlayer.uiMode = "none"
         mPlayer.stretchToFit = True
         MPcontrols.Player = mPlayer
         MPcontrols.Volume = mPlayer.settings.volume
 
         'If CheckUpdate(True, True) Then Me.Close()
 
         LoadSettings()
 
         Dim CmdArgs As String() = Environment.GetCommandLineArgs()
         If CmdArgs.Length > 1 Then
             'Add check later to see that param /play is being passed
             Try
                 If String.Compare(Trim(CmdArgs(1)), "/play", False) = 0 Then
                     LoadMask(CmdArgs(2))
                 ElseIf String.Compare(Trim(CmdArgs(1)), "/edit", False) = 0 Then
                     Dim Filename As String = CmdArgs(2)
                     If isValidExtension(Filename) Then
                         OpenFile(Filename)
                     End If
                 End If
             Catch ex As Exception
                 'do nothing - ignore pranks ;)
             End Try
         End If
 
         mOpenFileExtender.DialogViewType = cOpenFileDialogExt.DialogViewTypes.Thumbnails
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="95" endline="123">
<![CDATA[
 
     Public Overrides Function ResolveBaseType() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveBaseType() AndAlso result
 
         If m_InheritsClauses IsNot Nothing AndAlso m_InheritsClauses.Count > 0 Then
             For i As Integer = 0 To m_InheritsClauses.Count - 1
                 result = m_InheritsClauses(i).ResolveTypeReferences AndAlso result
             Next
             If result = False Then Return False
 
             For i As Integer = 1 To m_InheritsClauses.Count - 1
                 If Helper.CompareType(m_InheritsClauses(0).ResolvedType, m_InheritsClauses(i).ResolvedType) = False Then
                     Helper.AddError(Compiler, Me.Location, "Class specifies different base classes")
                     result = False
                 End If
             Next
             If result = False Then Return False
             BaseType = m_InheritsClauses(0).ResolvedType
         Else
             BaseType = Compiler.TypeCache.System_Object
         End If
 
         'We need to clear the member cache here since our base type has changed
         Compiler.TypeManager.ClearCache(Me.CecilType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="1139" endline="1169">
<![CDATA[
 
     Private Function GetIntegralToken(ByVal Value As ULong, ByVal Base As IntegerBase, ByVal TypeCharacter As LiteralTypeCharacters_Characters) As Token
         Dim case_type As BuiltInDataTypes
         'TODO
         If TypeCharacter = LiteralTypeCharacters_Characters.None Then
             If Value > Integer.MaxValue Then
                 case_type = BuiltInDataTypes.Long
             Else
                 case_type = BuiltInDataTypes.Integer
             End If
         Else
             case_type = LiteralTypeCharacters.GetBuiltInType(TypeCharacter)
         End If
 
         Select Case case_type
             Case BuiltInDataTypes.Integer
                 Return Token.CreateInt32Token(GetCurrentLocation, ExtractInt(Value, Base))
             Case BuiltInDataTypes.UInteger
                 Return Token.CreateUInt32Token(GetCurrentLocation, ExtractUInt(Value, Base))
             Case BuiltInDataTypes.Long
                 Return Token.CreateInt64Token(GetCurrentLocation, ExtractLong(Value, Base))
             Case BuiltInDataTypes.ULong
                 Return Token.CreateUInt64Token(GetCurrentLocation, ExtractULong(Value, Base))
             Case BuiltInDataTypes.Short
                 Return Token.CreateInt16Token(GetCurrentLocation, ExtractShort(Value, Base))
             Case BuiltInDataTypes.UShort
                 Return Token.CreateUInt16Token(GetCurrentLocation, ExtractUShort(Value, Base))
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2450" endline="2495">
<![CDATA[
 
     ''' <summary>
     ''' LoopControlVariable  
     '''	   Identifier  [  ArrayNameModifier  ] "As" TypeName  |
     '''	   Expression
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseLoopControlVariable(ByVal Parent As ParsedObject) As LoopControlVariable
         Dim result As New LoopControlVariable(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_ArrayNameModifier As ArrayNameModifier = Nothing
         Dim m_TypeName As TypeName = Nothing
         Dim m_Expression As Expression = Nothing
 
         'First try first option
         Dim tmpANM As ArrayNameModifier = Nothing
         Dim iCurrent As RestorablePoint = tm.GetRestorablePoint
         Dim doExpression As Boolean = True
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If m_Identifier IsNot Nothing Then
             If ArrayNameModifier.CanBeMe(tm) Then
                 tmpANM = ParseArrayNameModifier(result)
                 If tmpANM Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tmpANM Is Nothing AndAlso tm.Accept(KS.As) Then
                 m_ArrayNameModifier = tmpANM
                 m_TypeName = ParseTypeName(result)
                 If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 doExpression = False
             End If
         End If
 
         If doExpression Then
             tm.RestoreToPoint(iCurrent)
             m_Expression = ParseExpression(New ExpressionParseInfo(result, True))
             If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             tm.IgnoreRestoredPoint()
         End If
 
         result.Init(m_Identifier, m_ArrayNameModifier, m_TypeName, m_Expression)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeImplementsClauses.vb" startline="785" endline="874">
<![CDATA[
 
     Private Function ResolveUnqualifiedName(ByVal Rs As String(), ByVal TypeArgumentCount As Integer) As Boolean
 
         For Each R As String In Rs
             '---------------------------------------------------------------------------------------------------------
             ' Given an unqualified name R, the following steps describe how to determine to which namespace or type an 
             ' unqualified name refers
             '---------------------------------------------------------------------------------------------------------
 
             '---------------------------------------------------------------------------------------------------------
             '* For each nested type containing the name reference, starting from the innermost type and going to the
             '* outermost, if R matches the name of an accessible nested type or a type parameter in the current type, 
             '* then the unqualified name refers to that type or type parameter.
             '---------------------------------------------------------------------------------------------------------
             If CheckNestedTypesOrTypeParameters(R, TypeArgumentCount) Then Return True
 
             '---------------------------------------------------------------------------------------------------------
             '* For each nested namespace containing the name reference, starting from the innermost namespace and 
             '* going to the outermost namespace, do the following
             '*
             '**	If R matches the name of an accessible type or nested namespace in the current namespace, then the
             '** unqualified name refers to that type or nested namespace.
             '*
             '**	If the namespace contains one or more accessible standard modules, and R matches the name of an 
             '** accessible nested type in exactly one standard module, then the unqualified name refers to that nested type
             '*
             '** If R matches the name of accessible nested types in more than one standard module, a compile-time 
             '** error occurs.
             '---------------------------------------------------------------------------------------------------------
             If CheckNamespaces(R, TypeArgumentCount) Then Return True
 
             '---------------------------------------------------------------------------------------------------------
             '* If the source file has one or more import aliases, and R matches the name of one of them, then 
             '* the unqualified name refers to that import alias.
             '---------------------------------------------------------------------------------------------------------
             Helper.Assert(FromWhere IsNot Nothing)
             'Helper.Assert(FromWhere.HasLocation)
             Helper.Assert(FromWhere.File IsNot Nothing)
             Helper.Assert(FromWhere.File.Imports IsNot Nothing)
 
             If CheckImportsAlias(R, FromWhere.File.Imports, TypeArgumentCount) Then Return True
 
             '---------------------------------------------------------------------------------------------------------
             '*	If the source file containing the name reference has one or more imports
             '**	If R matches the name of an accessible type in exactly one import, then the unqualified name refers to 
             '** that type. If R matches the name of an accessible type in more than one import and all are not the 
             '** same entity, a compile-time error occurs.
             '**	If R matches the name of a namespace in exactly one import, then the unqualified name refers to that
             '** namespace. If R matches the name of a namespace in more than one import and all are not the same entity, a 
             '** compile-time error occurs.
             '**	If the imports contain one or more accessible standard modules, and R matches the name of an accessible 
             '** nested type in exactly one standard module, then the unqualified name refers to that type. If R matches 
             '** the name of accessible nested types in more than one standard module, a compile-time error occurs.
             '---------------------------------------------------------------------------------------------------------
             If CheckImports(R, FromWhere.File.Imports, TypeArgumentCount) Then Return True
 
             '---------------------------------------------------------------------------------------------------------
             '* If the compilation environment defines one or more import aliases, and R matches the name of one of 
             '* them, then the unqualified name refers to that import alias.
             '---------------------------------------------------------------------------------------------------------
             If CheckImportsAlias(R, FromWhere.Compiler.CommandLine.Imports.Clauses, TypeArgumentCount) Then Return True
 
             '---------------------------------------------------------------------------------------------------------
             '* If the compilation environment defines one or more imports
             '**	If R matches the name of an accessible type in exactly one import, then the unqualified name refers to 
             '** that type. If R matches the name of an accessible type in more than one import, a compile-time error 
             '** occurs.
             '**	If R matches the name of a namespace in exactly one import, then the unqualified name refers to that
             '** namespace. If R matches the name of a namespace in more than one import, a compile-time error occurs.
             '**	If the imports contain one or more accessible standard modules, and R matches the name of an accessible
             '** nested type in exactly one standard module, then the unqualified name refers to that type. If R matches the                 
             '** name of accessible nested types in more than one standard module, a compile-time error occurs.
             '---------------------------------------------------------------------------------------------------------
             If CheckImports(R, FromWhere.Compiler.CommandLine.Imports.Clauses, TypeArgumentCount) Then Return True
         Next
         '---------------------------------------------------------------------------------------------------------
         '* Otherwise, a compile-time error occurs.
         '---------------------------------------------------------------------------------------------------------
 
         FromWhere.Compiler.Report.ShowMessage(Messages.VBNC30451, FromWhere.Location, Rs(0))
 
         '---------------------------------------------------------------------------------------------------------
         '* Note   
         '* An implication of this resolution process is that type members do not shadow namespaces or types 
         '* when resolving namespace or type names.
         '* If the type name is a constructed type name (i.e. it includes a type argument list), then only types 
         '* with the same arity as the type argument list are matched.
         '---------------------------------------------------------------------------------------------------------
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="374" endline="421">
<![CDATA[
 #End Region
 
 #Region "External Source"
     Private Sub ParseExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.LParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected '('")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsStringLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected string literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.Comma Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ','")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current.IsIntegerLiteral = False Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected integer literal")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         If m_Current <> KS.RParenthesis Then
             Helper.AddError(Compiler, GetCurrentLocation, "Expected ')'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryMinusExpression.vb" startline="30" endline="63">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim expInfo As EmitInfo = Info.Clone(Me, True, False, OperandType)
 
         Select Case OperandTypeCode
             Case TypeCode.Decimal
                 result = Expression.GenerateCode(expInfo) AndAlso result
                 Emitter.EmitCall(Info, Compiler.TypeCache.System_Decimal__Negate_Decimal)
             Case TypeCode.Single, TypeCode.Double
                 result = Expression.GenerateCode(expInfo) AndAlso result
                 Emitter.EmitNeg(Info)
             Case TypeCode.SByte, TypeCode.Int16
                 result = Expression.GenerateCode(expInfo) AndAlso result
                 Emitter.EmitNeg(Info)
             Case TypeCode.Object
                 Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 result = Me.Expression.GenerateCode(expInfo) AndAlso result
                 Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Operators__NegateObject_Object)
             Case TypeCode.Int32
                 Emitter.EmitLoadI4Value(Info, 0)
                 result = Expression.GenerateCode(expInfo) AndAlso result
                 Emitter.EmitSubOvf(Info, OperandType)
             Case TypeCode.Int64
                 Emitter.EmitLoadI8Value(Info, 0)
                 result = Expression.GenerateCode(expInfo) AndAlso result
                 Emitter.EmitSubOvf(Info, OperandType)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="23" endline="70">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim opType As TypeCode = MyBase.OperandTypeCode
 
         ValidateBeforeGenerateCode(Info)
 
         Select Case opType
             Case TypeCode.Boolean, TypeCode.Object
                 If opType = TypeCode.Object Then
                     Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 End If
 
                 Dim loadfalse, loadtrue, endexp As Label
                 loadfalse = Emitter.DefineLabel(Info)
                 loadtrue = Emitter.DefineLabel(Info)
                 endexp = Emitter.DefineLabel(Info)
 
                 result = m_LeftExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfFalse(Info, loadfalse)
 
                 result = m_RightExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 Emitter.MarkLabel(Info, loadfalse) '
                 Emitter.EmitLoadValue(Info, False) 'Load false value
                 Emitter.EmitBranch(Info, endexp)
 
                 Emitter.MarkLabel(Info, loadtrue)
                 Emitter.EmitLoadValue(Info, True) 'Load true value
 
                 Emitter.MarkLabel(Info, endexp) 'The end of the expression
                
                 If opType = TypeCode.Object Then
                     Emitter.EmitBox(Info, Compiler.TypeCache.System_Boolean)
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="830" endline="895">
<![CDATA[
 
     Private Function GetIdentifier(Optional ByVal Escaped As Boolean = False) As Token
         Dim bValid As Boolean = False
         Dim ch As Char
 
         'Identifier  
         '	NonEscapedIdentifier  [  TypeCharacter  ]  |
         '	Keyword  TypeCharacter  |
         '	EscapedIdentifier
         '
         'NonEscapedIdentifier  
         'EscapedIdentifier  
         '
         'IdentifierName 
 
         'IdentifierStart 
         '   AlphaCharacter |
         '   UnderscoreCharacter IdentifierCharacter 
 
         'IdentifierCharacter 
         '   UnderscoreCharacter |
         '   AlphaCharacter |
         '   NumericCharacter |
         '   CombiningCharacter |
         '   FormattingCharacter
         StringBuilderLength = 0
 
         ch = CurrentChar()
         StringBuilderAppend(ch)
         If IsAlphaCharacter(ch) Then
             bValid = True
         ElseIf IsUnderscoreCharacter(ch) Then
             ch = NextChar()
             StringBuilderAppend(ch)
             bValid = IsIdentifierCharacter(ch)
         End If
 
         If Not bValid Then
             Compiler.Report.ShowMessage(Messages.VBNC30203, Me.GetCurrentLocation(), CStr(ch))
             Return Nothing
         Else
             Do While IsIdentifierCharacter(NextChar)
                 StringBuilderAppend(CurrentChar)
             Loop
             Do While IsIdentifierCharacter(NextChar)
                 StringBuilderAppend(CurrentChar)
             Loop
         End If
 
         'The type character ! presents a special problem in that it can be used both as a type character and 
         'as a separator in the language. To remove ambiguity, a ! character is a type character as long as 
         'the character that follows it cannot start an identifier. If it can, then the ! character is a separator, 
         'not a type character.
         Dim typecharacter As TypeCharacters.Characters
         Dim canstartidentifier As Boolean = Me.IsLastChar = False AndAlso (IsAlphaCharacter(PeekChar) OrElse IsUnderscoreCharacter(PeekChar))
         If TypeCharacters.IsTypeCharacter(CurrentChar, typecharacter) AndAlso (canstartidentifier = False OrElse typecharacter <> TypeCharacters.Characters.SingleTypeCharacter) Then
             NextChar()
             m_CurrentTypeCharacter = typecharacter
             Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
         Else
             Dim keyword As KS
             If Escaped = False AndAlso Token.IsKeyword(m_StringBuilder, m_StringBuilderLength, keyword) Then
                 Return Token.CreateKeywordToken(GetCurrentLocation, keyword)
             Else
                 m_CurrentTypeCharacter = typecharacter
                 Return Token.CreateIdentifierToken(GetCurrentLocation, StringBuilderToString())
             End If
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="1364" endline="1411">
<![CDATA[
 
     ''' <summary>
     ''' Parses type members for interfaces.
     ''' Never returns nothing.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseInterfaceMembers(ByVal Parent As InterfaceDeclaration) As Boolean
         Dim newMembers As New Generic.List(Of IMember)
         While True
             Dim attributes As Attributes = Nothing
 
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(Parent, attributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             Dim newType As TypeDeclaration
             newType = ParseTypeDeclaration(Parent, attributes, Parent.Namespace)
             If newType IsNot Nothing AndAlso Not Parent.Members.Contains(newType) Then
                 Parent.Members.Add(newType)
                 Continue While
             End If
 
             Dim newMember As IMember
             'InterfaceDeclarations
             If InterfaceEventMemberDeclaration.IsMe(tm) Then
                 newMember = ParseInterfaceEventMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
             ElseIf InterfaceFunctionDeclaration.IsMe(tm) Then
                 newMember = ParseInterfaceFunctionDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
             ElseIf InterfaceSubDeclaration.IsMe(tm) Then
                 newMember = ParseInterfaceSubDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
             ElseIf InterfacePropertyMemberDeclaration.IsMe(tm) Then
                 newMember = ParseInterfacePropertyMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
             Else
                 If attributes IsNot Nothing AndAlso attributes.Count > 0 Then
                     Helper.AddError(Compiler, tm.CurrentLocation, "Hanging attributes.")
                 End If
                 Exit While
             End If
 
             If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             Parent.Members.Add(newMember)
         End While
         While True
             Dim attributes As Attributes = Nothing
 
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(Parent, attributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             Dim newType As TypeDeclaration
             newType = ParseTypeDeclaration(Parent, attributes, Parent.Namespace)
             If newType IsNot Nothing AndAlso Not Parent.Members.Contains(newType) Then
                 Parent.Members.Add(newType)
                 Continue While
             End If
 
             Dim newMember As IMember
             'InterfaceDeclarations
             If InterfaceEventMemberDeclaration.IsMe(tm) Then
                 newMember = ParseInterfaceEventMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
             ElseIf InterfaceFunctionDeclaration.IsMe(tm) Then
                 newMember = ParseInterfaceFunctionDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
             ElseIf InterfaceSubDeclaration.IsMe(tm) Then
                 newMember = ParseInterfaceSubDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
             ElseIf InterfacePropertyMemberDeclaration.IsMe(tm) Then
                 newMember = ParseInterfacePropertyMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
             Else
                 If attributes IsNot Nothing AndAlso attributes.Count > 0 Then
                     Helper.AddError(Compiler, tm.CurrentLocation, "Hanging attributes.")
                 End If
                 Exit While
             End If
 
             If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             Parent.Members.Add(newMember)
         End While
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="23" endline="70">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim opType As TypeCode = MyBase.OperandTypeCode
 
         ValidateBeforeGenerateCode(Info)
 
         Select Case opType
             Case TypeCode.Boolean, TypeCode.Object
                 If opType = TypeCode.Object Then
                     Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 End If
 
                 Dim loadfalse, loadtrue, endexp As Label
                 loadfalse = Emitter.DefineLabel(Info)
                 loadtrue = Emitter.DefineLabel(Info)
                 endexp = Emitter.DefineLabel(Info)
 
                 result = m_LeftExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfFalse(Info, loadfalse)
 
                 result = m_RightExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 Emitter.MarkLabel(Info, loadfalse) '
                 Emitter.EmitLoadValue(Info, False) 'Load false value
                 Emitter.EmitBranch(Info, endexp)
 
                 Emitter.MarkLabel(Info, loadtrue)
                 Emitter.EmitLoadValue(Info, True) 'Load true value
 
                 Emitter.MarkLabel(Info, endexp) 'The end of the expression
                
                 If opType = TypeCode.Object Then
                     Emitter.EmitBox(Info, Compiler.TypeCache.System_Boolean)
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\CaseClauses.vb" startline="79" endline="117">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim startLabel As Label = Emitter.DefineLabel(Info)
         EndLabel = Emitter.DefineLabel(Info)
         m_NextIteration = Emitter.DefineLabel(Info)
 
         Emitter.MarkLabel(Info, startLabel)
         If m_PreCondition IsNot Nothing Then
             Emitter.MarkLabel(Info, m_NextIteration)
             result = m_PreCondition.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean)) AndAlso result
             Emitter.EmitConversion(m_PreCondition.ExpressionType, Compiler.TypeCache.System_Boolean, Info)
             If m_IsWhile Then
                 Emitter.EmitBranchIfFalse(Info, EndLabel)
             Else
                 Emitter.EmitBranchIfTrue(Info, EndLabel)
             End If
         End If
 
         result = CodeBlock.GenerateCode(Info) AndAlso result
 
         If m_PostCondition IsNot Nothing Then
             Emitter.MarkLabel(Info, m_NextIteration)
             result = m_PostCondition.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean)) AndAlso result
             Emitter.EmitConversion(m_PostCondition.ExpressionType, Compiler.TypeCache.System_Boolean, Info)
             If m_IsWhile Then
                 Emitter.EmitBranchIfFalse(Info, EndLabel)
             Else
                 Emitter.EmitBranchIfTrue(Info, EndLabel)
             End If
         End If
         Emitter.EmitBranch(Info, startLabel)
 
         Emitter.MarkLabel(Info, EndLabel)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="327" endline="334">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Arguments.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\MethodGroupToValueExpression.vb" startline="43" endline="50">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.GenerateCode(Info) AndAlso result 'Helper.NotImplemented()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AttributeArgumentExpression.vb" startline="39" endline="46">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveExpression(info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\VariableIdentifiers.vb" startline="64" endline="72">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Initializer.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\VariableInitializerList.vb" startline="32" endline="38">
<![CDATA[
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_AttributeArgumentExpression.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ErrorStatement.vb" startline="47" endline="56">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_ErrNumber.ResolveExpression(info) AndAlso result
 
         Compiler.Helper.AddCheck("The expression must be classified as a value and its type must be implicitly convertible to Integer.")
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\OptionStrictStatement.vb" startline="117" endline="125">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_AssignStatement.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\RedimClauses.vb" startline="66" endline="77">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Clauses.ResolveCode(info) AndAlso result
 
         Compiler.Helper.AddCheck("Each clause in the statement must be classified as a variable or a property access whose type is an array type or Object, and be followed by a list of array bounds. ")
         Compiler.Helper.AddCheck("The number of the bounds must be consistent with the type of the variable; any number of bounds is allowed for Object.")
         Compiler.Helper.AddCheck("If the Preserve keyword is specified, then the expressions must also be classifiable as a value, and the new size for each dimension except for the rightmost one must be the same as the size of the existing array. ")
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="87" endline="94">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_TypeName.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="169" endline="176">
<![CDATA[
 
     Function IsNamespaceExact(ByVal A As String, ByVal B As String) As Boolean
         For i As Integer = 0 To Me.Count - 1
             Dim ns As [Namespace] = Me.Item(i)
             If ns.Equals(A, B) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ParameterList.vb" startline="90" endline="108">
<![CDATA[
 
     ''' <summary>
     ''' Resolves either all optional parameters or all non-optional parameters.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="OptionalParameters"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function ResolveParameters(ByVal Info As ResolveInfo, ByVal OptionalParameters As Boolean) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To Count - 1
             If Me(i).Modifiers.Is(ModifierMasks.Optional) = OptionalParameters Then
                 result = Me(i).ResolveCode(Info) AndAlso result
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="741" endline="748">
<![CDATA[
 
     Public Shared Function MakeGenericMethod(ByVal Method As MethodReference, ByVal Types() As Mono.Cecil.TypeReference) As Mono.Cecil.GenericInstanceMethod
         Dim result As New Mono.Cecil.GenericInstanceMethod(Method)
         For i As Integer = 0 To Types.Length - 1
             result.GenericArguments.Add(Types(i))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="1181" endline="1187">
<![CDATA[
 
     Public Shared Function FindField(ByVal fields As Mono.Collections.Generic.Collection(Of FieldDefinition), ByVal name As String) As FieldDefinition
         For i As Integer = 0 To fields.Count - 1
             If Helper.CompareNameOrdinal(fields(i).Name, name) Then Return fields(i)
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="142" endline="151">
<![CDATA[
     End Property
 
     ReadOnly Property CandidatesLeft() As Integer
         Get
             Dim result As Integer
             For i As Integer = 0 To m_Candidates.Count - 1
                 If m_Candidates(i).RemovedBy Is Nothing Then result += 1
             Next
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="264" endline="273">
<![CDATA[
 
     Public Function CreateImplicitInstanceConstructors() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To Me.Types.Length - 1
             result = CreateImplicitInstanceConstructors(Me.Types(i)) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="288" endline="297">
<![CDATA[
 
     Public Function CreateImplicitSharedConstructors() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To Me.Types.Length - 1
             result = CreateImplicitSharedConstructors(Me.Types(i)) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="312" endline="321">
<![CDATA[
 
     Public Function CreateDelegateMembers() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To Types.Length - 1
             result = CreateDelegateMembers(Types(i)) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="337" endline="346">
<![CDATA[
 
     Public Function CreateRegularEventMembers() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To Types.Length - 1
             result = CreateRegularEventMembers(Types(i)) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="360" endline="369">
<![CDATA[
 
     Public Function CreateWithEventsMembers() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To Types.Length - 1
             result = CreateWithEventsMembers(Types(i)) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="388" endline="397">
<![CDATA[
 
     Public Function CreateMyGroupMembers() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To Me.Types.Length - 1
             result = CreateMyGroupMembers(Types(i)) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="486" endline="495">
<![CDATA[
 
     Function DefineConstants() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To Types.Length - 1
             result = DefineConstants(Types(i)) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="522" endline="531">
<![CDATA[
 
     Function DefineOptionalParameters() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To Types.Length - 1
             result = DefineOptionalParameters(Types(i)) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="564" endline="573">
<![CDATA[
 
     Public Function DefineSecurityDeclarations() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To Types.Length - 1
             result = DefineSecurityDeclarations(Types(i)) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="915" endline="924">
<![CDATA[
 
     Shared Function GetParameterTypes(ByVal Parameters As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Mono.Cecil.TypeReference()
         Dim result() As Mono.Cecil.TypeReference
         Helper.Assert(Parameters IsNot Nothing)
         ReDim result(Parameters.Count - 1)
         For i As Integer = 0 To Parameters.Count - 1
             result(i) = Parameters(i).ParameterType
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\BaseObjects`1.vb" startline="57" endline="67">
<![CDATA[
 
     Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For i As Integer = 0 To Count - 1
             Dim pO As BaseObject = TryCast(CObj(Item(i)), BaseObject)
             If pO IsNot Nothing Then
                 result = pO.ResolveCode(Info) AndAlso result
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="1290" endline="1310">
<![CDATA[
 
     Public Shared Function FindDefinition(ByVal method As PropertyReference) As PropertyDefinition
         If method Is Nothing Then Return Nothing
         Dim pD As PropertyDefinition
 
         pD = TryCast(method, PropertyDefinition)
         If pD IsNot Nothing Then Return pD
 
         If method.Annotations.Contains("OriginalProperty") Then
             pD = DirectCast(method.Annotations("OriginalProperty"), PropertyDefinition)
             Return pD
         End If
 
         Dim type As TypeDefinition = FindDefinition(method.DeclaringType)
         'method = method.GetOriginalMethod
         'If Helper.CompareNameOrdinal(method.Name, MethodDefinition.Cctor) OrElse Helper.CompareNameOrdinal(method.Name, MethodDefinition.Ctor) Then
         '    Return GetMethod(type.Constructors, method)
         'Else
         Return GetProperty(type.Properties, method)
         'End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\SubSignature.vb" startline="184" endline="198">
<![CDATA[
     End Property
 
     Public Function VerifyParameterNamesDoesntMatchFunctionName() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To Parameters.Count - 1
             Dim p As Parameter = Parameters(i)
 
             If Helper.CompareName(p.Name, Name) Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC30530, Me.Location)
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\EndStatement.vb" startline="45" endline="57">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim nullExp As New NothingConstantExpression(Me)
         result = nullExp.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
         For i As Integer = 0 To m_Targets.Count - 1
             Dim exp As Expression = DirectCast(m_Targets.Item(i), Expression)
             result = exp.GenerateCode(Info.Clone(Me, nullExp)) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="6669" endline="6676">
<![CDATA[
 
     Public Sub ShowIdentifierExpected(ByVal Location As Span)
         If tm.CurrentToken.IsKeyword Then
             Compiler.Report.ShowMessage(Messages.VBNC30183, Location)
         Else
             Compiler.Report.ShowMessage(Messages.VBNC30203, Location)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\StdToolMgr.vb" startline="559" endline="579">
<![CDATA[
 
     Private mDrawing As Boolean
     Private Sub DrawSlider()
 
         If mDrawing Then Exit Sub
         'Refresh the bit map
         Dim gr As Graphics = lplayPos.CreateGraphics
         gr.Clear(Color.Beige)
         gr.DrawImageUnscaled(mBitMap, 0, 0)
 
         'Draw the new slider
         Try
             mSliderPos = CInt(lplayPos.Width * mPlayer.Ctlcontrols.currentPosition _
             / mPlayer.currentMedia.duration) - 3
             gr.DrawRectangle(mPen, mSliderPos, 2, mSliderW, lplayPos.Height - 6)
             lPos.Text = SecToMin(mPlayer.Ctlcontrols.currentPosition)
         Catch ex As Exception
             'do nothing
         End Try
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="87" endline="93">
<![CDATA[
 
     Shared Function EmitBeginExceptionBlock(ByVal Info As EmitInfo) As Label
         Helper.Assert(Info.InExceptionFilter = False)
         Dim result As Label
         result = Info.ILGen.BeginExceptionBlock
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="100" endline="110">
<![CDATA[
         Get
             If m_BlockStatements Is Nothing Then
                 m_BlockStatements = New Generic.List(Of BlockStatement)
                 For Each stmt As Statement In m_Statements
                     Dim blockStmt As BlockStatement
                     blockStmt = TryCast(stmt, BlockStatement)
                     If blockStmt IsNot Nothing Then m_BlockStatements.Add(blockStmt)
                 Next
             End If
             Return m_BlockStatements
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="527" endline="541">
<![CDATA[
 
     Sub RemoveInaccessible()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate.IsRemoved("RemoveInaccessible") Then Continue For
 
             If candidate.IsAccessible = False Then
                 Log("NOT ACCESSIBLE
                 m_Candidates(i).RemovedBy = "RemoveInaccessible"
             Else
                 Log("ACCESSIBLE    
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="240" endline="260">
<![CDATA[
 
     Private Function EmitConstantInitialization(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim parent As TypeDeclaration
         Dim constant As Object = Nothing
 
         Parent = Me.DeclaringType
 
         For Each variable As ConstantDeclaration In parent.Members.GetSpecificMembers(Of ConstantDeclaration)()
             result = variable.GetConstant(constant, True) AndAlso result
             If Helper.CompareType(variable.FieldType, Compiler.TypeCache.System_DateTime) Then
                 Emitter.EmitLoadDateValue(Info, DirectCast(constant, Date))
                 Emitter.EmitStoreField(Info, variable.FieldBuilder)
             ElseIf Helper.CompareType(variable.FieldType, Compiler.TypeCache.System_Decimal) Then
                 Emitter.EmitLoadDecimalValue(Info, DirectCast(constant, Decimal))
                 Emitter.EmitStoreField(Info, variable.FieldBuilder)
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="363" endline="373">
<![CDATA[
 
     Private Sub ParseEndRegion()
         If m_Current.Equals("Region") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'Region'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="422" endline="432">
<![CDATA[
 
     Private Sub ParseEndExternalSource()
         If m_Current.Equals("ExternalSource") = False Then
             Helper.AddError(Me.Compiler, Me.GetCurrentLocation, "Expected 'ExternalSource'")
             Me.EatLine(False)
             Return
         End If
         Me.NextUnconditionally()
 
         ParseEndOfLine()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\dshowUtil.vb" startline="9" endline="21">
<![CDATA[
     Public Sub New(ByRef Parent As frmMain, ByVal InputFile As String)
         MyBase.New(Parent, InputFile)
         mConverter = "MovicaCmd@@@.cmd"     'Implemented this handler using batch files for the most part
         Try
             If ShowInfo(mInFile, True) = False Then
                 Throw New Exception("Keyframe list is empty. Editing will not be possible")
             Else
                 mParent.MPcontrols.KeyFrames = mKeyFrames
             End If
         Catch ex As Exception
             Throw ex
         End Try
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3285" endline="3301">
<![CDATA[
 
     Private Sub lvSelectionInit()
 
         With lvPositions.SelectedItems(0)
             mSelStrt = MinToSec(.Text)
             If .SubItems.Count = 1 Then
                 mSelStop = mPlayer.currentMedia.duration
                 mOneSidedSelection = True
             Else
                 mSelStop = MinToSec(.SubItems(1).Text)
                 mOneSidedSelection = False
             End If
         End With
 
         DisplayFineControls(True)
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="974" endline="989">
<![CDATA[
 
     Private Sub Manual_Diagnostics(ByVal Name As String)
 
         Try
             SrvcCntrl.ServiceName = (Name)
             Dim ChkSrvc As Boolean = SrvcCntrl.CanPauseAndContinue
         Catch ex As InvalidOperationException
             Exit Sub
         End Try
 
         If Service_Startup(Name) = 2 OrElse Service_Startup(Name) = 3 Then
         Else
             Problem = CByte(Problem + 1)
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="125" endline="136">
<![CDATA[
 
     Friend Function Emit(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = Type.GenerateCode(Nothing) AndAlso result
         result = Type.Members.GenerateCode(Nothing) AndAlso result
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = Emit(NestedType) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\MainForm.cs" startline="495" endline="507">
<![CDATA[
 
 		private void authorizeMenuItem_Click(object sender, EventArgs e)
 		{
 			lock(keyFobView)
 			{
 				foreach(ListViewItem lvi in keyFobView.SelectedItems)
 				{
 					pm.AuthorizeFob(pm.KeyFobs[lvi.Text]);
 					settings.AddAuthorizedKeyFob(pm.KeyFobs[lvi.Text].SerialNumber);
                     lockingEnabled = true;
 				}
 				foreach(ListViewItem lvi in keyFobView.SelectedItems)
 				{
 					pm.AuthorizeFob(pm.KeyFobs[lvi.Text]);
 					settings.AddAuthorizedKeyFob(pm.KeyFobs[lvi.Text].SerialNumber);
                     lockingEnabled = true;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="40" endline="46">
<![CDATA[
 
     Function AddNamespace(ByVal [Namespace] As String) As TypeDictionary
         Dim result As New TypeDictionary()
         Helper.Assert(MyBase.ContainsKey([Namespace]) = False)
         MyBase.Add([Namespace], result)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="134" endline="143">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = VerifyImplicitConstructor() AndAlso result
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ExternalFunctionDeclaration.vb" startline="58" endline="67">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = Signature.VerifyParameterNamesDoesntMatchFunctionName() AndAlso result
         result = MyBase.ResolveMember(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\FunctionDeclaration.vb" startline="58" endline="67">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = Signature.VerifyParameterNamesDoesntMatchFunctionName() AndAlso result
         result = MyBase.ResolveMember(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="133" endline="143">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Helper.Assert(VariableType IsNot Nothing)
 
         If Me.GeneratedCode = False Then
             result = MyBase.GenerateCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="226" endline="247">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Helper.Assert(VariableType IsNot Nothing)
 
         If Me.GeneratedCode = False Then
             'If IsLocalVariable Then
             '    If m_LocalBuilder Is Nothing Then result = DefineLocalVariable(Info) AndAlso result
             '    Helper.Assert(m_LocalBuilder IsNot Nothing)
             '    result = EmitVariableInitializer(Info) AndAlso result
             'ElseIf Me.Modifiers.Is(ModifierMasks.Static) Then
             '    result = EmitStaticInitializer(Info) AndAlso result
             'Else
             '    'Field builder has been defined in DefineMember
             '    'EmitVariableInitializer will be called by the constructor declaration
             'End If
 
             result = MyBase.GenerateCode(Info) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\InterfaceDeclaration.vb" startline="31" endline="40">
<![CDATA[
     Public Overrides Function CreateDefinition() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.CreateDefinition() AndAlso result
         result = AddAttribute() AndAlso result
 
         TypeAttributes = TypeAttributes Or Mono.Cecil.TypeAttributes.Sealed
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ParametersOrType.vb" startline="61" endline="69">
<![CDATA[
 
     Public Overrides Function CreateDefinition() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.CreateDefinition AndAlso result
         If m_ParameterList IsNot Nothing Then result = m_ParameterList.CreateDefinition AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" startline="63" endline="72">
<![CDATA[
     End Property
 
     Public Overrides Function CreateDefinition() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.CreateDefinition AndAlso result
         If m_ParametersOrType IsNot Nothing Then result = m_ParametersOrType.CreateDefinition AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="102" endline="111">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_HandlesOrImplements IsNot Nothing Then result = m_HandlesOrImplements.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\CaseClauses.vb" startline="52" endline="62">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Clauses IsNot Nothing Then result = m_Clauses.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="25" endline="32">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
         If m_TypeArguments IsNot Nothing Then result = m_TypeArguments.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\GenericTypeDeclaration.vb" startline="55" endline="64">
<![CDATA[
 
     Public Overrides Function CreateDefinition() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.CreateDefinition() AndAlso result
 
         If m_TypeParameters IsNot Nothing Then result = m_TypeParameters.CreateDefinition AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="314" endline="322">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ConstructorModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ConstructorModifiers)
             i += 1
         End While
         If tm.PeekToken(i).Equals(KS.Sub) = False Then Return False
         Return tm.PeekToken(i + 1).Equals(KS.[New])
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AliasClause.vb" startline="137" endline="148">
<![CDATA[
 
     Private Function ConvertArgument(ByVal constant As Object, ByVal Type As Mono.Cecil.TypeReference) As Object
         If Helper.IsEnum(Compiler, Type) = False Then Return constant
 
         Dim enumCecilAssembly As Mono.Cecil.AssemblyNameReference = CecilHelper.GetAssemblyRef(Type)
         Dim enumAssembly As Assembly = System.Reflection.Assembly.Load(enumCecilAssembly.FullName)
         Dim enumType As Type = enumAssembly.GetType(Type.FullName)
 
         If enumType.IsEnum = False Then Return constant
 
         Return System.Enum.ToObject(enumType, constant)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="313" endline="333">
<![CDATA[
 
     Shared Function FindAssembly(ByVal type As Mono.Cecil.TypeReference) As Mono.Cecil.AssemblyDefinition
         Helper.Assert(type IsNot Nothing)
 
         While type.DeclaringType IsNot Nothing
             If type.Module IsNot Nothing AndAlso type.Module.Assembly IsNot Nothing Then Return type.Module.Assembly
             type = type.DeclaringType
         End While
         While type.DeclaringType IsNot Nothing
             If type.Module IsNot Nothing AndAlso type.Module.Assembly IsNot Nothing Then Return type.Module.Assembly
             type = type.DeclaringType
         End While
         Dim tS As Mono.Cecil.TypeSpecification = TryCast(type, Mono.Cecil.TypeSpecification)
         While tS IsNot Nothing
             type = tS.ElementType
             tS = TryCast(type, Mono.Cecil.TypeSpecification)
         End While
         While tS IsNot Nothing
             type = tS.ElementType
             tS = TryCast(type, Mono.Cecil.TypeSpecification)
         End While
         'Helper.Assert(type IsNot Nothing AndAlso type.[Module] IsNot Nothing)
 
         If type Is Nothing OrElse type.Module Is Nothing Then
             Return Nothing
         Else
             Return type.Module.Assembly
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="168" endline="189">
<![CDATA[
 
     ReadOnly Property HasSecurityCustomAttribute() As Boolean
         Get
             Dim checkedAll As Boolean = True
 
             If CustomAttributes Is Nothing Then Return False
 
             If m_HasSecurityCustomAttribute.HasValue Then Return m_HasSecurityCustomAttribute.Value
 
             For i As Integer = 0 To CustomAttributes.Count - 1
                 If CustomAttributes(i).ResolvedType Is Nothing Then
                     checkedAll = False
                 ElseIf Helper.IsSubclassOf(Compiler.TypeCache.System_Security_Permissions_SecurityAttribute, CustomAttributes(i).ResolvedType) Then
                     m_HasSecurityCustomAttribute = True
                     Return True
                 End If
             Next
 
             If checkedAll Then m_HasSecurityCustomAttribute = False
 
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="1119" endline="1144">
<![CDATA[
 
     ''' <summary>
     ''' Checks whether the specified Type is defined in the current compiling assembly
     ''' </summary>
     ''' <param name="Type"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsDefinedHere(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Helper.Assert(Type IsNot Nothing)
         If TypeOf Type Is Mono.Cecil.ArrayType Then
             Return IsDefinedHere(DirectCast(Type, Mono.Cecil.ArrayType).ElementType)
         ElseIf TypeOf Type Is Mono.Cecil.GenericParameter Then
             Dim gp As Mono.Cecil.GenericParameter = DirectCast(Type, Mono.Cecil.GenericParameter)
             If TypeOf gp.Owner Is Mono.Cecil.TypeDefinition Then
                 Return IsDefinedHere(DirectCast(gp.Owner, Mono.Cecil.TypeDefinition))
             ElseIf TypeOf gp.Owner Is Mono.Cecil.MethodDefinition Then
                 Return IsDefinedHere(DirectCast(gp.Owner, Mono.Cecil.MethodDefinition))
             Else
                 Throw New NotImplementedException
             End If
         ElseIf TypeOf Type Is ByReferenceType Then
             Dim tR As ByReferenceType = DirectCast(Type, ByReferenceType)
             Return IsDefinedHere(tR.ElementType)
         End If
         Return Type.Module.Assembly Is Compiler.AssemblyBuilderCecil
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="1670" endline="1696">
<![CDATA[
 
     Function ResolveUnresolvedExpressions() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_ExactArguments.Count - 1
             Dim exp As Expression
             Dim expType As Mono.Cecil.TypeReference
 
             exp = m_ExactArguments(0).Expression
             expType = exp.ExpressionType
 
             If Helper.CompareType(expType, Compiler.TypeCache.DelegateUnresolvedType) = False Then Continue For
             If Helper.IsDelegate(Compiler, DefinedParameters(i).ParameterType) = False Then Return False
 
             Dim aoe As AddressOfExpression
             aoe = TryCast(exp, AddressOfExpression)
 
             If aoe IsNot Nothing Then
                 Dim exp2 As Expression
                 exp2 = exp.ReclassifyMethodPointerToValueExpression(DefinedParameters(i).ParameterType)
                 result = exp2.ResolveExpression(ResolveInfo.Default(Compiler)) AndAlso result
                 If result Then m_ExactArguments(0).Expression = exp2
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="399" endline="407">
<![CDATA[
 
     Function AcceptEndOfFile() As Boolean
         If CurrentToken.IsEndOfFile Then
             NextToken()
             Return True
         Else
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="4318" endline="4330">
<![CDATA[
 
     Private Sub lbStdTools_SelectedIndexChanged(ByVal sender As System.Object, _
     ByVal e As System.EventArgs) Handles lbStdTools.SelectedIndexChanged
 
         If lbStdTools.SelectedItem Is Nothing Then Exit Sub
 
         Dim Tool As ToolSpec = DirectCast(lbStdTools.SelectedItem, ToolSpec)
         lblToolDesc.Text = Tool.Desc
         tStdToolPath.Text = Tool.Path.Value
         cToolFind.Enabled = Tool.Path.Required
         chkEnabled.Checked = Tool.Enabled
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="490" endline="500">
<![CDATA[
 
     Private Sub BWCPUUsg_ProgressChanged(ByVal sender As Object, ByVal e As System.ComponentModel.ProgressChangedEventArgs) Handles BWCPUUsg.ProgressChanged
         If e.ProgressPercentage < 5 Then
             TrkCPUUsg.Value = 5
         ElseIf e.ProgressPercentage < 95 Then
             TrkCPUUsg.Value = e.ProgressPercentage
         ElseIf e.ProgressPercentage > 95 Then
             TrkCPUUsg.Value = 95
         End If
         LblCPUUsg.Text = ("CPU usage
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1577" endline="1594">
<![CDATA[
 
     Shared Sub EmitLoadVariableLocation(ByVal Info As EmitInfo, ByVal Field As Mono.Cecil.FieldReference)
         Dim emittableField As Mono.Cecil.FieldReference
         Dim fD As Mono.Cecil.FieldDefinition = CecilHelper.FindDefinition(Field)
 
         emittableField = Emitter.GetFieldRef(Field)
         emittableField = Helper.GetFieldOrFieldBuilder(Info.Compiler, emittableField)
 
         If fD.IsLiteral Then
             EmitLoadValueAddress(Info, fD.Constant)
         Else
             If fD.IsStatic Then
                 Info.ILGen.Emit(OpCodes.Ldsflda, emittableField)
             Else
                 Info.ILGen.Emit(OpCodes.Ldflda, emittableField)
             End If
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeParameter.vb" startline="75" endline="92">
<![CDATA[
     End Property
 
     Shared Function Clone(ByVal Builder As Mono.Cecil.GenericParameter, ByVal Owner As Mono.Cecil.IGenericParameterProvider, ByVal Position As Integer) As Mono.Cecil.GenericParameter
         Dim result As New Mono.Cecil.GenericParameter(Builder.Name, Owner)
 
         For i As Integer = 0 To Builder.Constraints.Count - 1
             result.Constraints.Add(Builder.Constraints(i))
         Next
 
         result.HasDefaultConstructorConstraint = Builder.HasDefaultConstructorConstraint
         result.HasNotNullableValueTypeConstraint = Builder.HasNotNullableValueTypeConstraint
         result.HasReferenceTypeConstraint = Builder.HasReferenceTypeConstraint
         result.IsContravariant = Builder.IsContravariant
         result.IsCovariant = Builder.IsCovariant
         result.IsNonVariant = Builder.IsNonVariant
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="61" endline="79">
<![CDATA[
 
     Shared Function TypeCharacterToType(ByVal Compiler As Compiler, ByVal TypeCharacter As TypeCharacters.Characters) As Mono.Cecil.TypeReference
         Select Case GetDataType(TypeCharacter)
             Case KS.Integer
                 Return Compiler.TypeCache.System_Int32
             Case KS.Long
                 Return Compiler.TypeCache.System_Int64
             Case KS.Decimal
                 Return Compiler.TypeCache.System_Decimal
             Case KS.Single
                 Return Compiler.TypeCache.System_Single
             Case KS.Double
                 Return Compiler.TypeCache.System_Double
             Case KS.String
                 Return Compiler.TypeCache.System_String
             Case Else
                 Throw New InternalException("Unknown typecharacter
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1602" endline="1625">
<![CDATA[
 
     Shared Function GetConversionOperators(ByVal Compiler As Compiler, ByVal Names As String(), ByVal Type As Mono.Cecil.TypeReference, ByVal ReturnType As Mono.Cecil.TypeReference) As Generic.List(Of Mono.Cecil.MethodReference)
         Dim ops As Generic.List(Of Mono.Cecil.MethodReference)
 
         ops = GetOperators(Compiler, Names, Type)
 
         If ops Is Nothing Then
             ops = GetOperators(Compiler, Names, ReturnType)
         Else
             ops.AddRange(GetOperators(Compiler, Names, ReturnType))
         End If
 
         If ops IsNot Nothing Then
             For i As Integer = ops.Count - 1 To 0 Step -1
                 If CompareType(ops(i).ReturnType, ReturnType) = False Then
                     ops.RemoveAt(i)
                 ElseIf CompareType(ops(i).Parameters(0).ParameterType, Type) = False Then
                     ops.RemoveAt(i)
                 End If
             Next
         End If
 
         Return ops
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3819" endline="3850">
<![CDATA[
 
     ''' <summary>
     ''' FunctionSignature  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseFunctionSignature(ByVal Parent As ParsedObject) As FunctionSignature
         Dim result As New FunctionSignature(Parent)
 
         Dim m_Identifier As Identifier = Nothing
         Dim m_TypeParameters As TypeParameters = Nothing
         Dim m_ParameterList As New ParameterList(result)
         Dim m_ReturnTypeAttributes As Attributes = Nothing
         Dim m_TypeName As TypeName = Nothing
 
         If ParseSubSignature(result, m_Identifier, m_TypeParameters, m_ParameterList) = False Then
             tm.GotoNewline(True)
         End If
 
         If tm.Accept(KS.As) Then
             If Attributes.IsMe(tm) Then
                 If ParseAttributes(result, m_ReturnTypeAttributes) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
             End If
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_Identifier, m_TypeParameters, m_ParameterList, m_ReturnTypeAttributes, m_TypeName, New Span(m_Identifier.Location, tm.CurrentLocation))
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CCharExpression.vb" startline="83" endline="114">
<![CDATA[
 
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 'Nothing to do
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32007, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.String
                 'OK
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
             Case Else
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\OperatorDeclaration.vb" startline="225" endline="253">
<![CDATA[
 
     Function DefineOptionalParameters() As Boolean
         Dim result As Boolean = True
 
         If Me.Modifiers.Is(ModifierMasks.Optional) Then
             Dim constant As Object = Nothing
             If m_ConstantExpression Is Nothing Then
                 Helper.AddError(Me, "Optional parameters must have a constant expression.")
                 result = False
             ElseIf m_ConstantExpression.GetConstant(constant, True) = False Then
                 Helper.AddError(Me, "Optional expressions must be constant.")
                 result = False
             Else
                 result = TypeConverter.ConvertTo(Me, constant, ParameterType, constant, True) AndAlso result
                 If constant Is DBNull.Value Then
                     constant = Nothing
                 End If
                 ConstantValue = constant
                 ConstantDeclaration.CreateConstantAttribute(Compiler, constant, m_ParameterBuilderCecil.CustomAttributes)
             End If
         Else
             If m_ConstantExpression IsNot Nothing Then
                 Helper.AddError(Me, "Non-optional parameters cannot have constant expressions.")
                 result = False
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeImplementsClauses.vb" startline="552" endline="607">
<![CDATA[
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <param name="R"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function CheckNamespace(ByVal R As String, ByVal Types As TypeDictionary, ByVal TypeArgumentCount As Integer) As Boolean
         '---------------------------------------------------------------------------------------------------------
         '* (...)
         '**	If R matches the name of an accessible type or nested namespace in the current namespace, then the
         '** unqualified name refers to that type or nested namespace.
         '*
         '**	If the namespace contains one or more accessible standard modules, and R matches the name of an 
         '** accessible nested type in exactly one standard module, then the unqualified name refers to that nested type
         '*
         '** If R matches the name of accessible nested types in more than one standard module, a compile-time 
         '** error occurs.
         '---------------------------------------------------------------------------------------------------------
 
         '**	If R matches the name of an accessible type or nested namespace in the current namespace, then the
         '** unqualified name refers to that type or nested namespace.
         Dim RName As String = vbnc.Helper.CreateGenericTypename(R, TypeArgumentCount)
 
         Dim foundType As Mono.Cecil.TypeReference
 
         foundType = Types.Item(RName)
         If foundType IsNot Nothing Then
             m_FoundObjects.Add(foundType)
             Return True
         End If
 
         '**	If the namespace contains one or more accessible standard modules, and R matches the name of an 
         '** accessible nested type in exactly one standard module, then the unqualified name refers to that nested type
         Dim foundModules As Generic.List(Of Mono.Cecil.TypeReference)
         foundModules = Helper.FilterToModules(FromWhere.Compiler, Types)
         If foundModules.Count > 0 Then
             Dim typesInAllModules As New Generic.List(Of Mono.Cecil.TypeReference)
             For Each [module] As Mono.Cecil.TypeReference In foundModules
                 Dim typeInCurrentModule As Mono.Cecil.TypeReference
                 typeInCurrentModule = CecilHelper.GetNestedType([module], RName)
                 If typeInCurrentModule IsNot Nothing Then typesInAllModules.Add(typeInCurrentModule)
             Next
             If typesInAllModules.Count = 1 Then
                 m_FoundObjects.AddRange(typesInAllModules.ToArray)
                 Return True
             ElseIf typesInAllModules.Count > 1 Then
                 '** If R matches the name of accessible nested types in more than one standard module, a compile-time 
                 '** error occurs.
                 Helper.AddError(Name)
                 Return False
             End If
         End If
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="968" endline="1005">
<![CDATA[
 
     Private Function SignWithKeyFile(ByVal result As Mono.Cecil.AssemblyNameDefinition, ByVal KeyFile As String, ByVal DelaySign As Boolean) As Boolean
         Dim filename As String
 
         filename = IO.Path.GetFullPath(KeyFile)
 
 #If DEBUG Then
         Compiler.Report.WriteLine("Signing with file
 #End If
 
         If IO.File.Exists(filename) = False Then
             Helper.AddError(Me, "Can't find keyfile
             Return False
         End If
 
         Using stream As New IO.FileStream(filename, IO.FileMode.Open, IO.FileAccess.Read)
             Dim snkeypair() As Byte
             ReDim snkeypair(CInt(stream.Length - 1))
             stream.Read(snkeypair, 0, snkeypair.Length)
 
             If Helper.IsOnMono Then
                 SignWithKeyFileMono(result, filename, DelaySign, snkeypair)
             Else
                 If DelaySign Then
                     result.PublicKey = snkeypair
                 Else
                     'FIXME
                     'result.KeyPair = New StrongNameKeyPair(snkeypair)
                     result.PublicKey = snkeypair
                 End If
             End If
 
         End Using
 
         Compiler.ModuleBuilderCecil.Attributes = Compiler.ModuleBuilderCecil.Attributes Or ModuleAttributes.StrongNameSigned
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5430" endline="5485">
<![CDATA[
 
     ''' <summary>
     ''' Homebrew
     ''' UsingDeclarator 
     '''  Identifier  [  As  [  New  ]  NonArrayTypeName  [  (  ArgumentList  )  ]  ]  |
     '''  Identifier  [  As  NonArrayTypeName  ]  [  =  VariableInitializer  ]
     '''
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseUsingDeclarator(ByVal Parent As ParsedObject) As UsingDeclarator
         Dim result As New UsingDeclarator(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_IsNew As Boolean
         Dim m_IsVariableDeclaration As Boolean
         Dim m_TypeName As NonArrayTypeName
         Dim m_VariableInitializer As VariableInitializer = Nothing
         Dim m_ArgumentList As ArgumentList = Nothing
         Dim m_VariableDeclaration As LocalVariableDeclaration
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             m_IsVariableDeclaration = True
             m_IsNew = tm.Accept(KS.[New])
 
             m_TypeName = ParseNonArrayTypeName(result)
 
             If m_IsNew = False Then
                 If tm.Accept(KS.Equals) Then
                     m_VariableInitializer = ParseVariableInitializer(result)
                 End If
             Else
                 If tm.Accept(KS.LParenthesis) Then
                     If tm.Accept(KS.RParenthesis) = False Then
                         m_ArgumentList = ParseArgumentList(result)
                         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                     End If
                 End If
                 If m_ArgumentList Is Nothing Then m_ArgumentList = New ArgumentList(result)
             End If
 
             m_VariableDeclaration = New LocalVariableDeclaration(result, m_Identifier, m_IsNew, m_TypeName, m_VariableInitializer, m_ArgumentList)
         Else
             m_VariableDeclaration = Nothing
             m_VariableInitializer = Nothing
             m_ArgumentList = Nothing
             m_TypeName = Nothing
         End If
 
 
         result.Init(m_Identifier, m_IsNew, m_TypeName, m_ArgumentList, m_VariableInitializer, m_IsVariableDeclaration, m_VariableDeclaration)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="23" endline="70">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim opType As TypeCode = MyBase.OperandTypeCode
 
         ValidateBeforeGenerateCode(Info)
 
         Select Case opType
             Case TypeCode.Boolean, TypeCode.Object
                 If opType = TypeCode.Object Then
                     Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 End If
 
                 Dim loadfalse, loadtrue, endexp As Label
                 loadfalse = Emitter.DefineLabel(Info)
                 loadtrue = Emitter.DefineLabel(Info)
                 endexp = Emitter.DefineLabel(Info)
 
                 result = m_LeftExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfFalse(Info, loadfalse)
 
                 result = m_RightExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 Emitter.MarkLabel(Info, loadfalse) '
                 Emitter.EmitLoadValue(Info, False) 'Load false value
                 Emitter.EmitBranch(Info, endexp)
 
                 Emitter.MarkLabel(Info, loadtrue)
                 Emitter.EmitLoadValue(Info, True) 'Load true value
 
                 Emitter.MarkLabel(Info, endexp) 'The end of the expression
                
                 If opType = TypeCode.Object Then
                     Emitter.EmitBox(Info, Compiler.TypeCache.System_Boolean)
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\OptionStrictStatement.vb" startline="64" endline="124">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_Event.Classification.IsEventAccessClassification)
 
         Dim cl As EventAccessClassification = m_Event.Classification.AsEventAccess
         Dim eventtp As Mono.Cecil.TypeReference = cl.EventType
         Dim delegatetp As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(cl.Type)
 
         Helper.Assert(delegatetp IsNot Nothing)
 
         Dim raiseMethod As Mono.Cecil.MethodReference
         raiseMethod = CecilHelper.FindDefinition(cl.EventInfo).InvokeMethod
         If raiseMethod IsNot Nothing Then
             'Call the raise method
             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
         Else
             'Manually raise the event
             Dim delegateVar As Mono.Cecil.Cil.VariableDefinition
             Dim endIfLabel As Label
             Dim eventDeclaration As RegularEventDeclaration
             Dim eventdesc As Mono.Cecil.EventDefinition
             Dim invokemethod As Mono.Cecil.MethodReference
 
             delegateVar = Emitter.DeclareLocal(Info, Helper.GetTypeOrTypeBuilder(Compiler, delegatetp))
             endIfLabel = Emitter.DefineLabel(Info)
             eventdesc = CecilHelper.FindDefinition(cl.EventInfo)
             eventDeclaration = DirectCast(eventdesc.Annotations(Compiler), RegularEventDeclaration)
             invokemethod = Helper.GetInvokeMethod(Compiler, delegatetp)
 
             'Helper.Assert(eventDeclaration IsNot Nothing)
             'Helper.Assert(TypeOf cl.EventInfo Is EventDescriptor)
             'Helper.Assert(Helper.CompareType(cl.EventType, Me.FindFirstParent(Of IType).CecilType))
             Helper.Assert(invokemethod IsNot Nothing)
 
             'Load the field of the variable
             If eventDeclaration.EventField.IsStatic = False Then
                 Emitter.EmitLoadMe(Info, cl.EventType)
             End If
             Emitter.EmitLoadVariable(Info, eventDeclaration.EventField)
 
             'Test if the field is nothing
             Emitter.EmitStoreVariable(Info, delegateVar)
             Emitter.EmitLoadVariable(Info, delegateVar)
             'If the field is nothing, don't invoke anything.
             Emitter.EmitBranchIfFalse(Info, endIfLabel)
 
             'Load the field again
             Emitter.EmitLoadVariable(Info, delegateVar)
             'Load the invoke arguments
             result = m_Arguments.GenerateCode(Info.Clone(Me, True), invokemethod.Parameters) AndAlso result
             'Call the invoke method.
             Emitter.EmitCallOrCallVirt(Info, invokemethod)
 
             'End of the RaiseEvent statement.
             Emitter.MarkLabel(Info, endIfLabel)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="124" endline="161">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         'TODO
         If m_ArgumentList IsNot Nothing Then
             result = m_ArgumentList.ResolveCode(Info) AndAlso result
         End If
 
         If m_TypeName IsNot Nothing Then
             UsingVariableType = m_TypeName.ResolvedType
             m_IsVariableDeclaration = True
             If m_IsNew Then
                 Dim grp As New MethodGroupClassification(Me, Nothing, Nothing, Nothing, CecilHelper.GetConstructors(CecilHelper.FindDefinition(m_TypeName.ResolvedType)))
                 result = grp.ResolveGroup(m_ArgumentList) AndAlso result
                 m_Constructor = grp.ResolvedConstructor
                 If m_Constructor Is Nothing Then
                     result = Helper.AddError(Me) AndAlso result
                 End If
             End If
         ElseIf m_VariableInitializer IsNot Nothing Then
             UsingVariableType = Compiler.TypeCache.System_Object
             m_IsVariableDeclaration = True
         Else
             Helper.Assert(m_ArgumentList Is Nothing)
             'Helper.Assert(m_Identifier IsNot Nothing)
             m_IsVariableDeclaration = False
             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End If
 
         If m_VariableInitializer IsNot Nothing Then
             Dim expInfo As ExpressionResolveInfo
             expInfo = New ExpressionResolveInfo(Compiler, UsingVariableType)
             result = m_VariableInitializer.ResolveCode(expInfo) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="112" endline="145">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Condition.ResolveExpression(Info) AndAlso result
         result = CodeBlock.ResolveCode(Info) AndAlso result
         If m_FalseCode IsNot Nothing Then result = m_FalseCode.ResolveCode(Info) AndAlso result
         If m_ElseIfs IsNot Nothing Then result = m_ElseIfs.ResolveCode(Info) AndAlso result
 
         If result = False Then Return result
 
         If m_Condition.Classification.IsValueClassification Then
             'nothing to do
         ElseIf m_Condition.Classification.CanBeValueClassification Then
             m_Condition = m_Condition.ReclassifyToValueExpression
             result = m_Condition.ResolveExpression(ResolveInfo.Default(Compiler)) AndAlso result
 
             If result = False Then
                 Helper.AddError(Me)
                 Return result
             End If
         Else
             Helper.AddError(Me, "Each expression in an If...Then...Else statement must be classified as a value and be implicitly convertible to Boolean")
         End If
 
         m_Condition = Helper.CreateTypeConversion(Me, m_Condition, Compiler.TypeCache.System_Boolean, result)
 
         If result = False Then
             Helper.AddError(Me)
             Return result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3683" endline="3726">
<![CDATA[
 
     ''' <summary>
     ''' PropertySetDeclaration  
     '''	[  Attributes  ]  [  AccessModifier  ]  "Set" [  (  ParameterList  )  ]  LineTerminator
     '''	[  Block  ]
     '''	"End" "Set" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParsePropertySetMember(ByVal Parent As PropertyDeclaration, ByVal Info As ParseAttributableInfo, ByVal ParentSignature As FunctionSignature, ByVal ParentImplements As MemberImplementsClause, ByVal ParentModifiers As ModifierMasks) As PropertySetDeclaration
         Dim result As New PropertySetDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_ParameterList As New ParameterList(result)
         Dim m_Block As CodeBlock
 
         m_Modifiers = ParseModifiers(ModifierMasks.AccessModifiers)
         If m_Modifiers.Empty = False Then
             m_Modifiers.AddModifiers(ParentModifiers And (Not ModifierMasks.AccessModifiers))
         Else
             m_Modifiers.AddModifiers(ParentModifiers)
         End If
         tm.AcceptIfNotInternalError(KS.Set)
 
         If tm.Accept(KS.LParenthesis) Then
             If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Block = ParseCodeBlock(result, False)
         If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Set) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, ParentImplements, m_Block, m_ParameterList)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\CaseClauses.vb" startline="129" endline="160">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_TypeName IsNot Nothing Then
             m_ExceptionType = m_TypeName.ResolvedType
             Helper.Assert(m_ExceptionType IsNot Nothing)
             If Helper.CompareType(Compiler.TypeCache.System_Exception, m_ExceptionType) = False AndAlso Helper.IsSubclassOf(Compiler.TypeCache.System_Exception, m_ExceptionType) = False Then
                 Helper.AddError(Me, "Exception type does not inherit from System.Exception")
                 result = True
             End If
         ElseIf m_When Is Nothing Then
             m_ExceptionType = Compiler.TypeCache.System_Exception
         End If
         If m_Variable IsNot Nothing Then 'Token.IsSomething(m_Variable) Then
             m_VariableDeclaration = New LocalVariableDeclaration(Me, m_Variable, False, m_TypeName, Nothing, Nothing)
             result = m_VariableDeclaration.ResolveTypeReferences AndAlso result
             CodeBlock.Variables.Add(m_VariableDeclaration)
         End If
         If m_When IsNot Nothing Then result = m_When.ResolveExpression(Info) AndAlso result
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         If m_When IsNot Nothing Then
             m_When = Helper.CreateTypeConversion(Me, m_When, Compiler.TypeCache.System_Boolean, result)
             If result = False Then
                 Helper.AddError(Me)
                 Return result
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="55" endline="62">
<![CDATA[
     End Property
 
     Function FindNamespace(ByVal A As String, ByVal B As String) As [Namespace]
         For i As Integer = 0 To Count - 1
             If Item(i).Equals(A, B) Then Return Item(i)
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="514" endline="523">
<![CDATA[
 
     Function AcceptAny(ByVal ParamArray Keywords() As KS) As Boolean
         Dim i As Integer
         For i = 0 To Keywords.Length - 1
             If Accept(Keywords(i)) Then
                 Return True
             End If
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1592" endline="1601">
<![CDATA[
 
     Shared Function ApplyTypeArguments(ByVal Parent As ParsedObject, ByVal OpenParameters As Mono.Collections.Generic.Collection(Of ParameterReference), ByVal TypeParameters As Mono.Collections.Generic.Collection(Of TypeReference), ByVal TypeArguments As Mono.Collections.Generic.Collection(Of TypeReference)) As Mono.Cecil.ParameterReference()
         Dim result(OpenParameters.Count - 1) As Mono.Cecil.ParameterReference
 
         For i As Integer = 0 To result.Length - 1
             result(i) = ApplyTypeArguments(Parent, OpenParameters(i), TypeParameters, TypeArguments)
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ParameterList.vb" startline="47" endline="55">
<![CDATA[
 
     Function Clone(Optional ByVal NewParent As ParsedObject = Nothing) As ParameterList
         If NewParent Is Nothing Then NewParent = Me.Parent
         Dim result As New ParameterList(NewParent)
         For i As Integer = 0 To Me.Count - 1
             result.Add(Me.Item(i).Clone(result))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1405" endline="1415">
<![CDATA[
 
     Shared Function GetTypes(ByVal Params As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As Mono.Cecil.TypeReference()
         Dim result() As Mono.Cecil.TypeReference = Nothing
 
         If Params Is Nothing Then Return result
         ReDim result(Params.Count - 1)
         For i As Integer = 0 To Params.Count - 1
             result(i) = Params(i).ParameterType
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="37" endline="53">
<![CDATA[
     Shared Function GetIntrinsicTypesImplicitlyConvertibleFrom(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As TypeCode()
         Dim result As TypeCode() = Nothing
 
         If m_ImplicitlyConvertedIntrinsicTypes.TryGetValue(Type, result) Then
             Return result
         End If
 
         If Helper.CompareType(Type, Compiler.TypeCache.System_Char_Array) Then
             result = New TypeCode() {TypeCode.String}
         End If
 
         If result IsNot Nothing Then
             m_ImplicitlyConvertedIntrinsicTypes.Add(Type, result)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="542" endline="556">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_Variables.Count - 1
             result = m_Variables(i).ResolveTypeReferences AndAlso result
         Next
 
         For i As Integer = 0 To m_Statements.Count - 1
             result = m_Statements(i).ResolveTypeReferences AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="503" endline="524">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_Variables.Count - 1
             Dim var As LocalVariableDeclaration = m_Variables(i)
             result = CreateLabelForCurrentInstruction(Info) AndAlso result
             result = var.DefineLocalVariable(Info) AndAlso result
             result = var.CreateDefinition AndAlso result
         Next
 
         For i As Integer = 0 To m_Sequence.Count - 1
             Dim stmt As BaseObject = m_Sequence.Item(i)
 
             Emitter.MarkSequencePoint(Info, stmt.Location)
 
             result = CreateLabelForCurrentInstruction(Info) AndAlso result
             result = stmt.GenerateCode(Info) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\BoundList.vb" startline="227" endline="243">
<![CDATA[
 
     Public Shared Sub CreateConstantAttribute(ByVal Compiler As Compiler, ByVal constant As Object, ByVal CustomAttributes As Mono.Collections.Generic.Collection(Of CustomAttribute))
         If TypeOf constant Is Decimal Then
             Dim value As Decimal = DirectCast(constant, Decimal)
             Dim ctor As MethodDefinition = Compiler.TypeCache.System_Runtime_CompilerServices_DecimalConstantAttribute__ctor_Byte_Byte_UInt32_UInt32_UInt32
             Dim attrib As New Mono.Cecil.CustomAttribute(Helper.GetMethodOrMethodReference(Compiler, ctor))
             Dim params As Object() = New Emitter.DecimalFields(value).AsByte_Byte_UInt32_UInt32_UInt32()
             For i As Integer = 0 To params.Length - 1
                 attrib.ConstructorArguments.Add(New CustomAttributeArgument(ctor.Parameters(i).ParameterType, params(i)))
             Next
             CustomAttributes.Add(attrib)
         ElseIf TypeOf constant Is Date Then
             Dim attrib As New Mono.Cecil.CustomAttribute(Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Runtime_CompilerServices_DateTimeConstantAttribute__ctor_Int64))
             attrib.ConstructorArguments.Add(New CustomAttributeArgument(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Int64), DirectCast(constant, Date).Ticks))
             CustomAttributes.Add(attrib)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="422" endline="488">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Call this function from a method beeing emitted.
     ''' </summary>
     ''' <param name="Method"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Friend Overloads Function GenerateCode(ByVal Method As IMethod) As Boolean
         Dim result As Boolean = True
 
 #If EXTENDEDDEBUG Then
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Emitting method
 #End If
 
         Dim info As New EmitInfo(Method)
 
         m_EndOfMethodLabel = Emitter.DefineLabel(info)
         If Me.HasUnstructuredExceptionHandling Then
             result = GenerateUnstructuredStart(info) AndAlso result
         End If
 
 #If DEBUG Then
         If CecilHelper.GetMemberType(Method.MemberDescriptor) = MemberTypes.Constructor = False Then
             info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Nop)
         End If
 #End If
 
         result = GenerateCode(info) AndAlso result
 
         If Me.HasUnstructuredExceptionHandling = False Then
             Emitter.MarkLabel(info, m_EndOfMethodLabel.Value)
         End If
 
         Dim retvar As Mono.Cecil.Cil.VariableDefinition = Method.DefaultReturnVariable
         If retvar IsNot Nothing Then
             Emitter.EmitLoadVariable(info, retvar)
         Else
             Helper.Assert(Method.HasReturnValue = False)
         End If
 
         If Me.HasUnstructuredExceptionHandling Then
             result = GenerateUnstructuredEnd(Method, info) AndAlso result
         Else
             Emitter.EmitRet(info)
 #If DEBUGREFLECTION Then
             Dim obj As Object
             If TypeOf info.Method Is ConstructorDeclaration Then
                 obj = CType(info.Method, ConstructorDeclaration).ConstructorBuilder
             Else
                 obj = info.Method.MethodBuilder
             End If
             Helper.DebugReflection_AppendLine("{0} = {1}.GetILGenerator", info.ILGen, obj)
             Helper.DebugReflection_AppendLine("{0}.Emit (System.Reflection.Emit.Opcodes.Ret)", info.ILGen)
 #End If
         End If
 
 #If EXTENDEDDEBUG Then
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Method " & Method.FullName & " emitted (ID
 #End If
 #If EXTENDEDDEBUG Then
         If info.Stack.Count <> 0 Then
             Throw New InternalException("End of method " & Method.FullName & " reached, but stack is not empty.")
         End If
 #End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="234" endline="264">
<![CDATA[
 
     Function RuleMod(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleIntegerDivision(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Mod)
             NextToken()
             RuleIntegerDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CLng(0)
             Else
                 LSide = op1 Mod op2
             End If
         End While
         While CurrentToken.Equals(KS.Mod)
             NextToken()
             RuleIntegerDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CLng(0)
             Else
                 LSide = op1 Mod op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="530" endline="567">
<![CDATA[
 
     ''' <summary>
     ''' Finds the smallest type that can hold both specified types.
     ''' If tp1 = Integer and tp2 = Long would return Long
     ''' </summary>
     ''' <param name="tp1"></param>
     ''' <param name="tp2"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetSmallestIntegralType(ByVal tp1 As Mono.Cecil.TypeReference, ByVal tp2 As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Dim cont1(), cont2() As Mono.Cecil.TypeReference
 
         Helper.Assert(tp1 IsNot Nothing, "tp1 Is Nothing")
         Helper.Assert(tp2 IsNot Nothing, "tp2 Is Nothing")
 
         Dim itp1, itp2 As Mono.Cecil.TypeReference
         itp1 = GetIntegralType(Compiler, tp1)
         itp2 = GetIntegralType(Compiler, tp2)
         cont1 = valCanBeContainBy(getTypeIndex(CType(TypeToKeyword(itp1), BuiltInDataTypes)))
         cont2 = valCanBeContainBy(getTypeIndex(CType(TypeToKeyword(itp2), BuiltInDataTypes)))
 
         If cont1 Is Nothing Or cont2 Is Nothing Then Return Nothing
 
         Dim found As New ArrayList
         For Each t1 As Mono.Cecil.TypeReference In cont1
             For Each t2 As Mono.Cecil.TypeReference In cont2
                 If Helper.CompareType(t1, t2) Then
                     found.Add(t1)
                 End If
             Next
         Next
 
         If found.Count = 0 Then
             Return Nothing
         Else
             Return CType(found(0), Mono.Cecil.TypeReference)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="105" endline="135">
<![CDATA[
 
     Function RuleExponent(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleIdentifier(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Power)
             NextToken()
             RuleIdentifier(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             Else
                 LSide = op1 ^ op2
             End If
         End While
         While CurrentToken.Equals(KS.Power)
             NextToken()
             RuleIdentifier(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             Else
                 LSide = op1 ^ op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="517" endline="547">
<![CDATA[
 
     Function RuleXor(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleOr_OrElse(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Xor)
             NextToken()
             RuleOr_OrElse(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             Else
                 LSide = op1 Xor op2
             End If
         End While
         While CurrentToken.Equals(KS.Xor)
             NextToken()
             RuleOr_OrElse(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             Else
                 LSide = op1 Xor op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="1609" endline="1655">
<![CDATA[
 
 
     ''' <summary>
     ''' EventAccessorDeclaration  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEventAccessorDeclarations(ByVal Parent As EventDeclaration, ByVal EventName As Identifier, ByVal EventModifiers As Modifiers) As EventAccessorDeclarations
         Dim result As New EventAccessorDeclarations(Parent)
         Dim parsing As Boolean = True
 
         Dim m_AddHandler As CustomEventHandlerDeclaration = Nothing
         Dim m_RemoveHandler As CustomEventHandlerDeclaration = Nothing
         Dim m_RaiseEvent As CustomEventHandlerDeclaration = Nothing
 
         Do
             Dim attributes As Attributes = Nothing
             If vbnc.Attributes.IsMe(tm) Then
                 ParseAttributes(result, attributes)
             End If
             If CustomEventHandlerDeclaration.IsMe(tm) Then
                 Dim newMember As CustomEventHandlerDeclaration
                 newMember = ParseCustomEventHandlerDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes), EventName, EventModifiers)
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 Select Case newMember.HandlerType
                     Case KS.AddHandler
                         m_AddHandler = newMember
                     Case KS.RemoveHandler
                         m_RemoveHandler = newMember
                     Case KS.RaiseEvent
                         m_RaiseEvent = newMember
                     Case Else
                         Throw New InternalException(result)
                 End Select
             Else
                 If attributes IsNot Nothing AndAlso attributes.Count > 0 Then
                     Helper.AddError(Compiler, tm.CurrentLocation)
                 End If
                 Exit Do
             End If
         Loop
 
         result.Init(m_AddHandler, m_RemoveHandler, m_RaiseEvent)
 
         result.HasErrors = m_AddHandler IsNot Nothing AndAlso m_RemoveHandler IsNot Nothing AndAlso m_RaiseEvent IsNot Nothing
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\MainForm.cs" startline="333" endline="379">
<![CDATA[
 
 		private void Form1_Load(object sender, System.EventArgs e)
 		{
 			this.SetupNotifyIcon();
 			this.SetupContextMenu();
 			this.SetupPluginContextMenu();
 
 			settings = SettingsManager.Instance;
 			numericUpDown1.Value = settings.PresenceWindow;
 
 			pluginManager = new PluginManager();
 			UpdatePluginListView();
 
 			pm = new PresenceManager();
 			pm.PresenceNotification += new PresenceNotificationEventHandler(pm_PresenceNotification);
 			pm.PresenceManagerError += new PresenceManagerErrorEventHandler(pm_PresenceManagerError);
 			pm.MessageReceived += new MessageReceivedEventHandler(pm_MessageReceived);
 			
 			this.Closing += new CancelEventHandler(Form1_Closing);
 
 			securityCheckTimer = new Timer();
 			securityCheckTimer.Interval = 3000;
 			securityCheckTimer.Tick += new EventHandler(securityCheckTimer_Tick);
 			securityCheckTimer.Start();
 
 			//TODO
             heartbeatChangeTimer = new Timer();
 			heartbeatChangeTimer.Interval = 100;
 			heartbeatChangeTimer.Tick += new EventHandler(heartbeatChangeTimer_Tick);
 			heartbeatChangeTimer.Start();
 
 			foreach(string s in settings.AuthorizedKeyFobSerialNumbers)
 			{
 				pm.AuthorizedSerialNumbers.Add(s);
 			}
 			foreach(string s in settings.AuthorizedKeyFobSerialNumbers)
 			{
 				pm.AuthorizedSerialNumbers.Add(s);
 			}
 
 			try
 			{
 				pm.InitReceiver();
 			}
 			catch(Exception exc)
 			{
 				notifyIcon.ShowBalloonTip(2,this.Text, exc.Message,ToolTipIcon.Info);
 			}
 
 			pm.Start();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="1598" endline="1642">
<![CDATA[
 
     Public Sub NextUnconditionally()
         Dim lastTokenType As TokenType
         Dim lastKS As KS
 
         If m_Peeked.HasValue Then
             m_Current = m_Peeked.Value
             m_CurrentData = m_Current.m_TokenType
             m_Peeked = Nothing
             Return
         End If
 
         If Token.IsSomething(m_Current) AndAlso m_Current.IsEndOfFile Then
             NextFile()
         End If
 
         If m_CodeFile Is Nothing Then
             m_Current = Token.CreateEndOfCodeToken
             Return
         End If
 
         lastTokenType = m_Current.m_TokenType
         If lastTokenType = TokenType.Symbol Then
             lastKS = DirectCast(m_CurrentData, KS)
         End If
 
         m_CurrentTypeCharacter = TypeCharacters.Characters.None
         m_Current = GetNextToken()
 
         m_CurrentData = m_Current.m_TokenObject
 
         If m_Current.m_TokenType = TokenType.EndOfLine Then
             If lastTokenType = TokenType.Symbol AndAlso (lastKS = KS.Comma OrElse lastKS = KS.LParenthesis OrElse lastKS = KS.LBrace) Then
                 m_CurrentTypeCharacter = TypeCharacters.Characters.None
                 m_Current = GetNextToken()
                 m_CurrentData = m_Current.m_TokenObject
             Else
                 m_Peeked = GetNextToken()
 
                 If m_Peeked.Value.IsSymbol AndAlso (m_Peeked.Value.Symbol = KS.RParenthesis OrElse m_Peeked.Value.Symbol = KS.RBrace) Then
                     NextUnconditionally()
                 End If
             End If
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="1004" endline="1068">
<![CDATA[
 
     ''' <summary>
     ''' NonArrayTypeName  
     ''' SimpleTypeName    
     ''' BuiltInTypeName   
     ''' PrimitiveTypeName      
     ''' NumericTypeName        
     ''' IntegralTypeName       
     ''' FloatingPointTypeName  
     ''' ConstructedTypeName    
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseNonArrayTypeName(ByVal Parent As ParsedObject) As NonArrayTypeName
         Dim result As New NonArrayTypeName(Parent)
 
         Dim m_SimpleTypeName As SimpleTypeName
         Dim m_ConstructedTypeName As ConstructedTypeName
 
         m_SimpleTypeName = ParseSimpleTypeName(result)
 
         If m_SimpleTypeName Is Nothing Then Return Nothing
 
         If m_SimpleTypeName.IsQualifiedIdentifier AndAlso tm.CurrentToken = KS.LParenthesis AndAlso tm.PeekToken = KS.Of Then
             Dim m_TypeArgumentList As TypeArgumentList
             Dim m_Q As QualifiedIdentifier
             Dim m_NestedTypeName As ConstructedTypeName
 
             m_TypeArgumentList = ParseTypeArgumentList(result)
             If m_TypeArgumentList Is Nothing Then Return Nothing
             m_ConstructedTypeName = New ConstructedTypeName(result)
             m_ConstructedTypeName.Init(m_SimpleTypeName.AsQualifiedIdentifier, m_TypeArgumentList)
 
             Do While tm.Accept(KS.Dot)
                 m_Q = ParseQualifiedIdentifier(result)
                 m_TypeArgumentList = Nothing
 
                 m_NestedTypeName = New ConstructedTypeName(m_ConstructedTypeName)
 
                 If tm.Accept(KS.LParenthesis) Then
                     tm.AcceptIfNotError(KS.Of)
 
                     m_TypeArgumentList = New TypeArgumentList(m_NestedTypeName)
                     If ParseList(Of TypeName)(m_TypeArgumentList, New ParseDelegate_Parent(Of TypeName)(AddressOf ParseTypeName), Parent) = False Then
                         Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                     End If
 
                     tm.AcceptIfNotError(KS.RParenthesis)
                 End If
 
                 m_NestedTypeName.Init(m_ConstructedTypeName, m_Q, m_TypeArgumentList)
 
                 m_ConstructedTypeName = m_NestedTypeName
             Loop
             Do While tm.Accept(KS.Dot)
                 m_Q = ParseQualifiedIdentifier(result)
                 m_TypeArgumentList = Nothing
 
                 m_NestedTypeName = New ConstructedTypeName(m_ConstructedTypeName)
 
                 If tm.Accept(KS.LParenthesis) Then
                     tm.AcceptIfNotError(KS.Of)
 
                     m_TypeArgumentList = New TypeArgumentList(m_NestedTypeName)
                     If ParseList(Of TypeName)(m_TypeArgumentList, New ParseDelegate_Parent(Of TypeName)(AddressOf ParseTypeName), Parent) = False Then
                         Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                     End If
 
                     tm.AcceptIfNotError(KS.RParenthesis)
                 End If
 
                 m_NestedTypeName.Init(m_ConstructedTypeName, m_Q, m_TypeArgumentList)
 
                 m_ConstructedTypeName = m_NestedTypeName
             Loop
 
             result.Init(m_ConstructedTypeName)
         Else
             result.Init(m_SimpleTypeName)
         End If
 
         If tm.Accept(KS.Interrogation) Then
             result.IsNullable = True
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="200" endline="225">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Compiler.Report.Trace("{0}
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveCode(Info) AndAlso result
 
         result = MyBase.ResolveCode(ResolveInfo.Default(Info.Compiler)) AndAlso result
         If m_ArgumentList IsNot Nothing Then
             result = m_ArgumentList.ResolveCode(ResolveInfo.Default(Info.Compiler)) AndAlso result
             If result = False Then Return False
         End If
 
         If m_NewExpression IsNot Nothing Then
             result = m_NewExpression.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
             If result = False Then Return False
         End If
 
         If m_VariableInitializer IsNot Nothing Then
             result = m_VariableInitializer.ResolveCode(New ExpressionResolveInfo(Compiler, VariableType)) AndAlso result
             If result = False Then Return False
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="72" endline="113">
<![CDATA[
     End Property
 
     Public Overrides Function GetConstant(ByRef value As Object, ByVal ShowError As Boolean) As Boolean
         If Me.FieldInfo IsNot Nothing Then
             Dim attrib As Object
             Dim dec As Decimal, dt As Date
             Dim constant As ConstantDeclaration
             Dim enumc As EnumMemberDeclaration
 
             attrib = FieldDefinition.Annotations(Compiler)
 
             If attrib IsNot Nothing Then
                 enumc = TryCast(attrib, EnumMemberDeclaration)
                 If enumc IsNot Nothing Then Return enumc.GetConstantValue(value)
 
                 constant = TryCast(attrib, ConstantDeclaration)
                 If constant IsNot Nothing Then Return constant.GetConstant(value, ShowError)
             End If
 
             If Me.FieldDefinition.IsLiteral Then
                 value = Me.FieldDefinition.Constant
                 Return True
             ElseIf Me.FieldDefinition.IsInitOnly Then
                 If ConstantDeclaration.GetDecimalConstant(Compiler, FieldDefinition, dec) Then
                     value = dec
                     Return True
                 ElseIf ConstantDeclaration.GetDateConstant(Compiler, FieldDefinition, dt) Then
                     value = dt
                     Return True
                 Else
                     If ShowError Then Parent.Show30059()
                     Return False
                 End If
             Else
                 If ShowError Then Parent.Show30059()
                 Return False
             End If
         Else
             If ShowError Then Parent.Show30059()
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="200" endline="233">
<![CDATA[
 
     Function RuleIntegerDivision(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleMultiplicationAndRealDivision(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.IntDivision)
             NextToken()
             RuleMultiplicationAndRealDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Long.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Long.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf CLng(op2) = 0 Then
                 Compiler.Report.ShowMessage(Messages.VBNC30542, Location)
                 LSide = CDbl(0)
             Else
                 LSide = CDbl(CLng(op1) \ CLng(op2))
             End If
         End While
         While CurrentToken.Equals(KS.IntDivision)
             NextToken()
             RuleMultiplicationAndRealDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Long.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Long.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf CLng(op2) = 0 Then
                 Compiler.Report.ShowMessage(Messages.VBNC30542, Location)
                 LSide = CDbl(0)
             Else
                 LSide = CDbl(CLng(op1) \ CLng(op2))
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CCharExpression.vb" startline="34" endline="67">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 'Nothing to do
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32007, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Boolean, TypeCode.Double, TypeCode.DateTime, TypeCode.Decimal, TypeCode.Single
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToChar_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'Nothing to do
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToChar_String)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3553" endline="3597">
<![CDATA[
 
     ''' <summary>
     ''' ConstructorMemberDeclaration  
     ''' [  Attributes  ]  [  ConstructorModifier+  ]  "Sub" "New" [  "("  [  ParameterList  ]  ")"  ]  LineTerminator
     '''	[  Block  ]
     '''	"End" "Sub" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseConstructorMember(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As ConstructorDeclaration
         Dim result As New ConstructorDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_ParameterList As New ParameterList(result)
         Dim m_Signature As SubSignature
         Dim m_Block As CodeBlock
 
         m_Modifiers = ParseModifiers(ModifierMasks.ConstructorModifiers)
 
         tm.AcceptIfNotInternalError(KS.Sub)
         tm.AcceptIfNotInternalError(KS.[New])
 
         If tm.Accept(KS.LParenthesis) Then
             If tm.Accept(KS.RParenthesis) = False Then
                 If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End If
 
         m_Signature = New SubSignature(result, "", m_ParameterList)
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Block = ParseCodeBlock(result, False)
         If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Sub) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, m_Block)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="70" endline="111">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         ValidateBeforeGenerateCode(Info)
 
         If CecilHelper.IsValueType(m_LeftExpression.ExpressionType) Then
             Throw New InternalException(Me)
         End If
         If CecilHelper.IsValueType(m_RightExpression.ExpressionType) Then
             Throw New InternalException(Me)
         End If
 
         Dim desiredType As Mono.Cecil.TypeReference = m_DesiredNothingType
         If TypeOf m_LeftExpression Is NothingConstantExpression = False Then
             If desiredType Is Nothing Then desiredType = m_LeftExpression.ExpressionType
         ElseIf TypeOf m_RightExpression Is NothingConstantExpression = False Then
             If desiredType Is Nothing Then desiredType = m_LeftExpression.ExpressionType
         Else
             'If Nothing Is / IsNot Nothing Then...
             Emitter.EmitLoadValue(Info, m_Keyword = KS.Is)
             Return result
         End If
 
         If desiredType IsNot Nothing Then
             If CecilHelper.IsByRef(desiredType) Then desiredType = CecilHelper.GetElementType(desiredType)
             Info = Info.Clone(Me, True, False, desiredType)
         End If
 
         result = m_LeftExpression.GenerateCode(Info) AndAlso result
         result = m_RightExpression.GenerateCode(Info) AndAlso result
 
         If Keyword = KS.Is Then
             Emitter.EmitIs(Info)
         ElseIf Keyword = KS.IsNot Then
             Emitter.EmitIsNot(Info)
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5591" endline="5647">
<![CDATA[
 
     ''' <summary>
     ''' DoLoopStatement  
     ''' DoTopLoopStatement  
     '''	   "Do" [  WhileOrUntil  BooleanExpression  ]  StatementTerminator
     '''	       [  Block  ]
     '''	   "Loop" StatementTerminator
     ''' DoBottomLoopStatement  
     '''	   "Do" StatementTerminator
     '''	       [  Block  ]
     '''	   "Loop" WhileOrUntil  BooleanExpression  StatementTerminator
     '''WhileOrUntil  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseDoStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As DoStatement
         Dim result As New DoStatement(Parent)
 
         Dim m_PreCondition As Expression
         Dim m_PostCondition As Expression
         Dim m_IsWhile As Boolean
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.Do)
         If tm.CurrentToken.Equals(KS.While, KS.Until) Then
             m_PreCondition = ParseDoStatementCondition(result, m_IsWhile)
             If m_PreCondition Is Nothing Then
                 Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
             End If
         Else
             m_PreCondition = Nothing
         End If
 
         If tm.AcceptEndOfStatement(IsOneLiner, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.Loop) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.CurrentToken.Equals(KS.While, KS.Until) Then
             m_PostCondition = ParseDoStatementCondition(result, m_IsWhile)
             If m_PostCondition Is Nothing Then
                 Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
             End If
         Else
             m_PostCondition = Nothing
         End If
 
         result.Init(m_PreCondition, m_PostCondition, m_IsWhile, m_Code)
 
         If m_PreCondition IsNot Nothing AndAlso m_PostCondition IsNot Nothing Then
             'helper.AddError "error BC30238
             Compiler.Report.ShowMessage(Messages.VBNC30238, tm.CurrentLocation)
             result.HasErrors = True
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="393" endline="442">
<![CDATA[
 
     Public Shared Function EmitLateCall(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification) As Boolean
         Dim result As Boolean = True
         Dim copyBacks As Mono.Cecil.Cil.VariableDefinition = Nothing, arguments As Mono.Cecil.Cil.VariableDefinition = Nothing
         Dim copyBackHints As Boolean() = Nothing
 
         'We need to emit a call to LateCall
 
         '1 - the instance expression
         If LateBoundAccess.InstanceExpression IsNot Nothing Then
             result = LateBoundAccess.InstanceExpression.GenerateCode(Info.Clone(Info.Context, True, False, LateBoundAccess.InstanceExpression.ExpressionType)) AndAlso result
         Else
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Object))
         End If
 
         '2 - Type
         If LateBoundAccess.LateBoundType Is Nothing Then
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type))
         Else
             Emitter.EmitLoadToken(Info, LateBoundAccess.LateBoundType)
             Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Type__GetTypeFromHandle_RuntimeTypeHandle)
         End If
 
         '3 - The member name
         Emitter.EmitLoadValue(Info, LateBoundAccess.Name)
 
         '4 - The arguments
         '5 - ArgumentNames
         EmitArguments(Info, LateBoundAccess, arguments)
 
         '6 - TypeArguments
         If LateBoundAccess.TypeArguments IsNot Nothing Then
             Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, LateBoundAccess.Parent.Location)
         Else
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Type_Array))
         End If
 
         '7 - CopyBack
         EmitCopyBacks(Info, LateBoundAccess, copyBackHints, copyBacks)
 
         '8 - Ignore return
         Emitter.EmitLoadI4Value(Info, 1)
         Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_NewLateBinding__LateCall_Object_Type_String_Array_Array_Array_Array_Boolean)
 
         Emitter.EmitPop(Info, Info.Compiler.TypeCache.System_Object)
 
         EmitStoreBacks(Info, LateBoundAccess, copyBackHints, copyBacks, arguments)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CDecExpression.vb" startline="49" endline="83">
<![CDATA[
 
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         If Conversion.GetConstant(Nothing, False) Then Return result
 
         Select Case expTypeCode
             Case TypeCode.DateTime, TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
             Case TypeCode.Single, TypeCode.Decimal, TypeCode.Double, TypeCode.UInt64, TypeCode.Int64, TypeCode.UInt32, TypeCode.Int32, TypeCode.Int16, TypeCode.Byte, TypeCode.SByte, TypeCode.UInt16
                 'Implicitly convertible
             Case Else
                 If Conversion.IsExplicit = False AndAlso Conversion.Location.File(Conversion.Compiler).IsOptionStrictOn Then
                     result = Conversion.Compiler.Report.ShowMessage(Messages.VBNC30512, Conversion.Location, Helper.ToString(Conversion, expType), Helper.ToString(Conversion, ExpressionType)) AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CSngExpression.vb" startline="49" endline="83">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         If Conversion.GetConstant(Nothing, False) Then Return result
 
         Select Case expTypeCode
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
             Case TypeCode.Single, TypeCode.Decimal, TypeCode.UInt64, TypeCode.Int64, TypeCode.UInt32, TypeCode.Int32, TypeCode.Int16, TypeCode.Byte, TypeCode.SByte, TypeCode.UInt16
                 'Implicitly convertible
             Case Else
                 If Conversion.IsExplicit = False AndAlso Conversion.Location.File(Conversion.Compiler).IsOptionStrictOn Then
                     result = Conversion.Compiler.Report.ShowMessage(Messages.VBNC30512, Conversion.Location, Helper.ToString(Conversion, expType), Helper.ToString(Conversion, ExpressionType)) AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="80" endline="88">
<![CDATA[
     End Property
 
     ReadOnly Property Handlers() As Generic.List(Of AddOrRemoveHandlerStatement)
         Get
             If m_Handlers Is Nothing Then
                 m_Handlers = New Generic.List(Of AddOrRemoveHandlerStatement)
             End If
             Return m_Handlers
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="32" endline="46">
<![CDATA[
 
     Shared Sub MarkSequencePoint(ByVal Info As EmitInfo, ByVal Location As Span)
         If Location.File(Info.Compiler) Is Nothing Then Return
         If Location.Line <= 0 Then Return
 
         Dim s As Mono.Cecil.Cil.SequencePoint
         Dim instr As Mono.Cecil.Cil.Instruction
         s = New Mono.Cecil.Cil.SequencePoint(Location.File(Info.Compiler).SymbolDocument)
         instr = Info.ILGen.CreateAndEmitNop()
         instr.SequencePoint = s
         s.StartLine = CInt(Location.Line)
         s.StartColumn = Location.Column
         s.EndLine = CInt(Location.Line)
         s.EndColumn = Location.EndColumn
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="437" endline="451">
<![CDATA[
 
     ''' <summary>
     ''' Compares two strings.
     ''' </summary>
     ''' <param name="Value1"></param>
     ''' <param name="Value2"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function CompareName(ByVal Value1 As String, ByVal Value2 As String, ByVal Ordinal As Boolean) As Boolean
         If Ordinal Then
             Return CompareNameOrdinal(Value1, Value2)
         Else
             Return CompareName(Value1, Value2)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Modules\Common.vb" startline="163" endline="175">
<![CDATA[
 
     Friend Function RNumber(ByVal MaxNumber As Integer, Optional ByVal MinNumber As Integer = 0) As Integer
 
         Dim R As New Random(System.DateTime.Now.Millisecond)
         If MinNumber > MaxNumber Then
             Dim T As Integer = MinNumber
             MinNumber = MaxNumber
             MaxNumber = T
         End If
         Return R.Next(MinNumber, MaxNumber)
         Randomize()
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="1353" endline="1363">
<![CDATA[
 
     Private Function ParseModifiers(ByVal ValidModifiers As ModifierMasks) As Modifiers
         Dim result As New Modifiers()
 
         While tm.CurrentToken.Equals(ValidModifiers)
             result.AddModifier(tm.CurrentToken.Keyword)
             tm.NextToken()
         End While
         While tm.CurrentToken.Equals(ValidModifiers)
             result.AddModifier(tm.CurrentToken.Keyword)
             tm.NextToken()
         End While
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\AbstractMediaHandler.vb" startline="293" endline="303">
<![CDATA[
 
     Protected Function AddDefaultPathIfNeeded(ByVal Filename As String) As String
         If InStr(Filename, "\") = 0 Then
             Dim TempPath As String = GetDefaultDir()
             If Not TempPath Is Nothing Then
                 Return TempPath & Filename
             End If
         Else
             Return Filename
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmManual.vb" startline="112" endline="125">
<![CDATA[
 
     Protected Friend Shared Function CProfile(ByVal Cntrl As System.Windows.Forms.ComboBox) As String
 
         If Cntrl.SelectedIndex = 0 Then
             CProfile = "1!"
         ElseIf Cntrl.SelectedIndex = 1 Then
             CProfile = "2!"
         ElseIf Cntrl.SelectedIndex = 2 Then
             CProfile = "3!"
         Else
             CProfile = "4!"
         End If
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="37" endline="80">
<![CDATA[
 
 #Region "Helper"
 
     'Constant methods.
     'Private Shared m_Asc_Char As MethodInfo ', if the constant string is not empty
     'Private Shared m_Asc_String As MethodInfo ', if the constant string is not empty
     'Private Shared m_AscW_Char As MethodInfo ', if the constant string is not empty
     'Private Shared m_AscW_String As MethodInfo ', if the constant string is not empty
     'Private Shared m_Chr_Integer As MethodInfo ', if the constant value is between 0 and 128
     'Private Shared m_ChrW_Integer As MethodInfo
     'Private Shared m_AllConstantFunctions As ArrayList
 
     'A constant expression is an expression whose value can be fully evaluated at compile time. The type of a constant expression can be Byte, Short, Integer, Long, Char, Single, Double, Decimal, Boolean, String, or any enumeration type. The following constructs are permitted in constant expressions
     'Literals (including Nothing).
     'References to constant type members or constant locals.
     'References to members of enumeration types.
     'Parenthesized subexpressions.
     'Coercion expressions, provided the target type is one of the types listed above. Coercions to and from String are an exception to this rule and not allowed because String conversions are always done in the current culture of the execution environment at run time.
     'The +, - and Not unary operators.
     'The +, -, *, ^, Mod, /, \, <<, >>, &, And, Or, Xor, AndAlso, OrElse, =, <, >, <>, <=, and => binary operators, provided each operand is of a type listed above.
     'The following run-time functions
     'Microsoft.VisualBasic.Strings.ChrW
     'Microsoft.VisualBasic.Strings.Chr, if the constant value is between 0 and 128
     'Microsoft.VisualBasic.Strings.AscW, if the constant string is not empty
     'Microsoft.VisualBasic.Strings.Asc, if the constant string is not empty
 
     'Constant expressions of an integral type (Long, Integer, Short, Byte) can be implicitly converted to a narrower integral type, and constant expressions of type Double can be implicitly converted to Single, provided the value of the constant expression is within the range of the destination type. These narrowing conversions are allowed regardless of whether permissive or strict semantics are being used.
 
     Private Shared Function IsMethod(ByVal m1 As Mono.Cecil.MethodReference, ByVal Name As String, ByVal ParameterType As Mono.Cecil.TypeReference, ByVal ReturnType As Mono.Cecil.TypeReference) As Boolean
         If CecilHelper.IsGenericMethod(m1) Then Return False
         If CecilHelper.IsGenericMethodDefinition(m1) Then Return False
 
         If CompareNameOrdinal(m1.Name, Name) = False Then Return False
 
         If Helper.CompareType(m1.ReturnType, ReturnType) = False Then Return False
 
         Dim p1 As Mono.Collections.Generic.Collection(Of Mono.Cecil.ParameterDefinition)
         p1 = m1.Parameters()
         If p1.Count <> 1 Then Return False
 
         If Helper.CompareType(p1(0).ParameterType, ParameterType) = False Then Return False
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="3728" endline="3746">
<![CDATA[
 
     ''' <summary>
     ''' Returns true if all types in both arrays are the exact same types.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function CompareTypes(ByVal Types1() As Mono.Cecil.TypeReference, ByVal Types2() As Mono.Cecil.TypeReference) As Boolean
         If Types1 Is Nothing AndAlso Types2 Is Nothing Then
             Return True
         ElseIf Types1 Is Nothing Xor Types2 Is Nothing Then
             Return False
         Else
             If Types1.Length <> Types2.Length Then Return False
             For i As Integer = 0 To Types1.Length - 1
                 If Helper.CompareType(Types1(i), Types2(i)) = False Then Return False
             Next
             Return True
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="1213" endline="1242">
<![CDATA[
 
     Public Shared Function FindDefinition(ByVal type As TypeReference) As TypeDefinition
         If type Is Nothing Then Return Nothing
         Dim tD As TypeDefinition = TryCast(type, TypeDefinition)
         If tD IsNot Nothing Then Return tD
         type = type.GetElementType
         If TypeOf type Is TypeDefinition Then
             Return DirectCast(type, TypeDefinition)
         End If
         Dim reference As AssemblyNameReference = TryCast(type.Scope, AssemblyNameReference)
         If reference IsNot Nothing Then
             Dim assembly As AssemblyDefinition = FindDefinition(reference)
             If type.IsNested Then
                 Return assembly.MainModule.GetType(type.FullName)
             Else
                 Return assembly.MainModule.GetType(type.Namespace, type.Name)
             End If
         End If
         Dim moduledef As ModuleDefinition = TryCast(type.Scope, ModuleDefinition)
         If moduledef IsNot Nothing Then
             Dim fn As String
             If type.IsNested Then
                 fn = FindDefinition(type.DeclaringType).FullName + "/" + type.Name
                 Return moduledef.GetType(fn)
             Else
                 Return moduledef.GetType(type.Namespace, type.Name)
             End If
         End If
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="365" endline="398">
<![CDATA[
 
     ''' <summary>
     ''' Accepts Newline or 
     ''' If ReportError = True then
     '''  - reports an error if currenttoken != ks.colon AND currenttoken != newline
     '''    doesn't matter if OnlyColon is true or not.
     ''' </summary>
     ''' <param name="OnlyColon">Set to true to only accept colon, not even NewLine</param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function AcceptEndOfStatement(Optional ByVal OnlyColon As Boolean = False, Optional ByVal ReportError As Boolean = False) As Boolean
         Dim result As Boolean = True
         If OnlyColon Then
             result = Accept(KS.Colon)
             If ReportError AndAlso result = False AndAlso CurrentToken.IsEndOfLineOnly = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30205, CurrentLocation)
             End If
             Return result
         Else
             If CurrentToken.IsEndOfLineOnly OrElse CurrentToken() = KS.Colon Then
                 Do
                     NextToken()
                 Loop While CurrentToken.IsEndOfLineOnly OrElse CurrentToken.Equals(KS.Colon)
                 Return True
             ElseIf CurrentToken.IsEndOfFile Then
                 Return True
             Else
                 If ReportError Then
                     Compiler.Report.ShowMessage(Messages.VBNC30205, CurrentLocation)
                 End If
                 Return False
             End If
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="78" endline="117">
<![CDATA[
     End Property
 
     Public Overrides Function GetConstant(ByRef m_ConstantValue As Object, ByVal lvalue As Object, ByVal rvalue As Object) As Boolean
         Dim shifts As Integer 'This needs to be an integer.
         Dim tmpShifts As Object = Nothing
 
         If Compiler.TypeResolution.CheckNumericRange(rvalue, tmpShifts, Compiler.TypeCache.System_Int32) = False Then
             Return Helper.AddError(Me, "Invalid numeric range")
         Else
             shifts = CInt(tmpShifts)
         End If
 
         Dim tlvalue As Mono.Cecil.TypeReference
         Dim clvalue As TypeCode
         tlvalue = CecilHelper.GetType(Compiler, lvalue)
         clvalue = Helper.GetTypeCode(Compiler, tlvalue)
 
         Select Case clvalue
             Case TypeCode.Byte
                 m_ConstantValue = CByte(lvalue) >> shifts
             Case TypeCode.SByte
                 m_ConstantValue = CSByte(lvalue) >> shifts
             Case TypeCode.Int16
                 m_ConstantValue = CShort(lvalue) >> shifts
             Case TypeCode.UInt16
                 m_ConstantValue = CUShort(lvalue) >> shifts
             Case TypeCode.Int32
                 m_ConstantValue = CInt(lvalue) >> shifts
             Case TypeCode.UInt32
                 m_ConstantValue = CUInt(lvalue) >> shifts
             Case TypeCode.Int64
                 m_ConstantValue = CLng(lvalue) >> shifts
             Case TypeCode.UInt64
                 m_ConstantValue = CULng(lvalue) >> shifts
             Case Else
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="36" endline="71">
<![CDATA[
 
     Public Overrides Function GetConstant(ByRef result As Object, ByVal ShowError As Boolean) As Boolean
         Dim first As Object = Nothing
         Dim second As Object = Nothing
         Dim third As Object = Nothing
 
         If ThirdPart IsNot Nothing Then
             If Not Condition.GetConstant(first, ShowError) Then Return False
             If Not SecondPart.GetConstant(second, ShowError) Then Return False
             If Not ThirdPart.GetConstant(third, ShowError) Then Return False
 
             result = If(CBool(first), second, third)
             Return TypeConverter.ConvertTo(Me, result, m_ExpressionType, result, ShowError)
         End If
 
         If TypeOf SecondPart Is NothingConstantExpression Then
             If TypeOf Condition Is NothingConstantExpression Then
                 result = Nothing
                 Return True
             Else
                 If ShowError Then Show30059()
                 Return False
             End If
         ElseIf TypeOf Condition Is NothingConstantExpression Then
             If ShowError Then Show30059()
             Return False
         Else
             If Not Condition.GetConstant(first, ShowError) Then Return False
             If Not SecondPart.GetConstant(second, ShowError) Then Return False
 
             Return TypeConverter.ConvertTo(Me, result, m_ExpressionType, result, ShowError)
         End If
 
         If ShowError Then Show30059()
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3090" endline="3160">
<![CDATA[
 
 #End Region
 
 #Region "   Positions List "
 
     Private Sub lvPositions_KeyDown(ByVal sender As System.Object, _
     ByVal e As System.Windows.Forms.KeyEventArgs) _
     Handles lvPositions.KeyDown, lvFiles.KeyUp
 
         Dim lvControl As ListView
         lvControl = DirectCast(sender, ListView)
 
         With lvControl
             If .Items.Count = 0 Then Exit Sub
             If .SelectedItems.Count = 0 Then Exit Sub
 
             mAllowListIndexChange = True
 
             Select Case e.KeyCode
                 Case Keys.Delete
                     DeleteSelected()
 
                 Case Keys.F11
                     'move up
                     MoveItemsUp(lvControl)
 
                 Case Keys.F12
                     'move down
                     MoveItemsDn(lvControl)
 
                 Case Keys.C
                     'Copy
                     If e.Control Then
                         CopySelected()
                     End If
 
                 Case Keys.V
                     'Paste
                     If e.Control Then
                         PasteSelected()
                     End If
 
                 Case Keys.Left
                     'Need to jump around the bug with index change
                     'Doing this instead of keeping last index to avoid problems with delete
                     If e.Control Then Exit Sub
                     mAllowListIndexChange = False
 
                     If e.Shift Then         'Shift means right slider
                         DoFrameAdjustment(False, False)
                     Else
                         DoFrameAdjustment(True, False)
                     End If
 
                 Case Keys.Right
                     'Need to jump around the bug with index change
                     'Doing this instead of keeping last index to avoid problems with delete
                     If e.Control Then Exit Sub
                     mAllowListIndexChange = False
 
                     If e.Shift Then         'Shift means right slider
                         DoFrameAdjustment(False, True)
                     Else
                         DoFrameAdjustment(True, True)
                         'Debug.WriteLine(GetAsyncKeyState(39))
                     End If
 
             End Select
         End With
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="6046" endline="6084">
<![CDATA[
 
     Private Function ParseCaseClause(ByVal Parent As ParsedObject) As CaseClause
         Dim result As New CaseClause(Parent)
 
         Dim m_Expression1 As Expression
         Dim m_Expression2 As Expression = Nothing
         Dim m_Comparison As KS
 
         If tm.Accept(KS.Is) Then
             tm.AcceptNewLine()
             If tm.CurrentToken.Equals(CaseClause.RelationalOperators) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30239, tm.CurrentLocation)
                 m_Comparison = KS.Equals
             Else
                 m_Comparison = tm.CurrentToken.Symbol
                 tm.NextToken()
                 tm.AcceptNewLine()
             End If
             m_Expression1 = ParseExpression(result)
             If m_Expression1 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         ElseIf tm.CurrentToken.Equals(CaseClause.RelationalOperators) Then
             m_Comparison = tm.CurrentToken.Symbol
             tm.NextToken()
             tm.AcceptNewLine()
             m_Expression1 = ParseExpression(result)
             If m_Expression1 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Expression1 = ParseExpression(result)
             If m_Expression1 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.Accept(KS.To) Then
                 m_Expression2 = ParseExpression(result)
                 If m_Expression2 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End If
 
         result.Init(m_Expression1, m_Expression2, m_Comparison)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="47" endline="78">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Loads the method pointer onto the evalation stack.
     ''' Creates a new delegate of the specified type.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_ResolvedMethod IsNot Nothing)
         Helper.Assert(m_DelegateType IsNot Nothing)
 
         If m_MethodGroup.InstanceExpression IsNot Nothing AndAlso CecilHelper.IsStatic(m_ResolvedMethod) = False Then
             result = m_MethodGroup.InstanceExpression.GenerateCode(Info.Clone(Parent, True, False, m_MethodGroup.InstanceExpression.ExpressionType)) AndAlso result
             Emitter.EmitDup(Info)
         Else
             Emitter.EmitLoadNull(Info.Clone(Parent, True, False, Compiler.TypeCache.System_Object))
         End If
 
         Emitter.EmitLoadVftn(Info, m_ResolvedMethod)
 
         Dim ctor As Mono.Cecil.MethodReference
         Dim dT As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(m_DelegateType)
         ctor = CecilHelper.FindConstructor(dT.Methods, False, New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_Object, Compiler.TypeCache.System_IntPtr})
         ctor = CecilHelper.GetCorrectMember(ctor, m_DelegateType)
         Emitter.EmitNew(Info, ctor)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="6503" endline="6557">
<![CDATA[
 
     ''' <summary>
     ''' InterfaceDeclaration  
     '''	[  Attributes  ]  [  TypeModifier+  ]  "Interface" Identifier  [  TypeParameters  ]  StatementTerminator
     '''	[  InterfaceBase+  ]
     '''	[  InterfaceMemberDeclaration+  ]
     '''	"End" "Interface" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseInterfaceDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As InterfaceDeclaration
         Dim result As InterfaceDeclaration
 
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_GenericName As Identifier
         Dim m_TypeParameters As TypeParameters
 
         m_Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         tm.AcceptIfNotInternalError(KS.Interface)
 
         m_Identifier = ParseIdentifier()
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement = False Then
             m_TypeParameters = ParseTypeParameters(Parent)
             If m_TypeParameters Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             m_GenericName = Helper.CreateGenericTypename(m_Identifier, m_TypeParameters)
         Else
             m_TypeParameters = Nothing
             m_GenericName = m_Identifier
         End If
 
         result = New InterfaceDeclaration(Parent, [Namespace], m_GenericName, m_TypeParameters)
 
         If m_TypeParameters IsNot Nothing Then
             m_TypeParameters.Parent = result
         End If
 
         If InterfaceBases.IsMe(tm) Then
             result.InterfaceBases = ParseInterfaceBases(result)
             If result.InterfaceBases Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If ParseInterfaceMembers(result) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Interface) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
         result.Modifiers = m_Modifiers
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\StdToolMgr.vb" startline="25" endline="53">
<![CDATA[
 
     'Required by the Windows Form Designer
     Private components As System.ComponentModel.IContainer
 
     'NOTE
     'It can be modified using the Windows Form Designer.  
     'Do not modify it using the code editor.
     Friend WithEvents rtf As System.Windows.Forms.RichTextBox
     <System.Diagnostics.DebuggerStepThrough()> Private Sub InitializeComponent()
         Me.rtf = New System.Windows.Forms.RichTextBox
         Me.SuspendLayout()
         '
         'rtf
         '
         Me.rtf.Dock = System.Windows.Forms.DockStyle.Fill
         Me.rtf.Location = New System.Drawing.Point(0, 0)
         Me.rtf.Name = "rtf"
         Me.rtf.Size = New System.Drawing.Size(320, 208)
         Me.rtf.TabIndex = 0
         Me.rtf.Text = ""
         '
         'ucRTF
         '
         Me.Controls.Add(Me.rtf)
         Me.Name = "ucRTF"
         Me.Size = New System.Drawing.Size(320, 208)
         Me.ResumeLayout(False)
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="829" endline="836">
<![CDATA[
 
     Shared Function FilterByName(ByVal Types As TypeDictionary, ByVal Name As String) As Mono.Cecil.TypeReference
         If Types.ContainsKey(Name) Then
             Return Types(Name)
         Else
             Return Nothing
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="45" endline="51">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = Classification.AsMethodPointerClassification.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="581" endline="594">
<![CDATA[
 
     Function FindVariable(ByVal Name As String) As IAttributableNamedDeclaration
         Dim found As Generic.List(Of INameable)
         found = m_Variables.Index.Item(Name)
         If found Is Nothing Then
             Return Nothing
         ElseIf found.Count = 1 Then
             Return DirectCast(found(0), IAttributableNamedDeclaration)
         ElseIf found.Count > 1 Then
             Throw New InternalException(Me)
         Else
             Return Nothing
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="376" endline="397">
<![CDATA[
 
     ''' <summary>
     ''' ImportsNamespaceClause  
     ''' 
     ''' ConstructedTypeName  
     '''	QualifiedIdentifier  "("  "Of"  TypeArgumentList  ")"
     '''    
     ''' Only namespaces, classes, structures, enumerated types, and standard modules may be imported.
     ''' This overload is used when parsing commandline imports.
     ''' </summary>
     ''' <remarks></remarks>
     Private Shared Function ParseImportsNamespaceClause(ByVal Parent As ParsedObject, ByVal str As String) As ImportsNamespaceClause
         Dim result As New ImportsNamespaceClause(Parent)
 
         Dim qi As QualifiedIdentifier = Nothing
         qi = ParseQualifiedIdentifier(result, str)
         If qi Is Nothing Then Helper.ErrorRecoveryNotImplemented(Parent.Location)
 
         result.Init(qi)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4003" endline="4025">
<![CDATA[
 
     ''' <summary>
     ''' ParameterIdentifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseParameterIdentifier(ByVal Parent As Parameter) As ParameterIdentifier
         Dim result As New ParameterIdentifier(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_ArrayNameModifier As ArrayNameModifier = Nothing
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If vbnc.ArrayNameModifier.CanBeMe(tm) Then
             m_ArrayNameModifier = ParseArrayNameModifier(result)
             If m_ArrayNameModifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_Identifier, m_ArrayNameModifier)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="33" endline="46">
<![CDATA[
 #End If
 
     Public Shared Sub GetConstructors(ByVal Type As Mono.Cecil.TypeReference, ByVal result As Mono.Collections.Generic.Collection(Of MethodReference))
         Dim tD As Mono.Cecil.TypeDefinition = FindDefinition(Type)
         For Each item As Mono.Cecil.MethodDefinition In tD.Methods
             If Not item.IsConstructor Then Continue For
             If item.IsStatic Then Continue For
             If Helper.CompareType(item.DeclaringType, Type) = False Then
                 result.Add(GetCorrectMember(item, Type))
             Else
                 result.Add(item)
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4454" endline="4477">
<![CDATA[
 
     ''' <summary>
     ''' HandlesOrImplements  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseHandlesOrImplements(ByVal Parent As ParsedObject) As HandlesOrImplements
         Dim result As New HandlesOrImplements(Parent)
 
         If vbnc.HandlesClause.IsMe(tm) Then
             Dim m_Clause As HandlesClause
             m_Clause = ParseHandlesClause(result)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(m_Clause)
         ElseIf vbnc.MemberImplementsClause.IsMe(tm) Then
             Dim m_Clause As MemberImplementsClause
             m_Clause = ParseImplementsClause(result)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(m_Clause)
         Else
             Throw New InternalException(result)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3873" endline="3905">
<![CDATA[
 
     ''' <summary>
     ''' TypeParameter  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeParameter(ByVal Parent As ParsedObject) As TypeParameter
         Dim result As New TypeParameter(Parent)
         Dim m_Identifier As Identifier
         Dim m_TypeParameterConstraints As TypeParameterConstraints
         Dim parentList As TypeParameterList
 
         Helper.Assert(TypeOf Parent Is TypeParameterList)
 
         parentList = DirectCast(Parent, TypeParameterList)
         result.GenericParameterPosition = parentList.Count + 1
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             result.Identifier = m_Identifier
         End If
 
         If TypeParameterConstraints.CanBeMe(tm) Then
             m_TypeParameterConstraints = ParseTypeParameterConstraints(result)
             If m_TypeParameterConstraints Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.TypeParameterConstraints = m_TypeParameterConstraints
         Else
             m_TypeParameterConstraints = Nothing
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="1100" endline="1106">
<![CDATA[
 
     Public Shared Function GetGetMethod(ByVal Prop As Mono.Cecil.PropertyReference) As Mono.Cecil.MethodReference
         Dim pD As Mono.Cecil.PropertyDefinition = FindDefinition(Prop)
         Dim result As MethodReference = pD.GetMethod
         result = GetCorrectMember(result, Prop.DeclaringType)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="1107" endline="1113">
<![CDATA[
 
     Public Shared Function GetSetMethod(ByVal Prop As PropertyReference) As MethodReference
         Dim pD As Mono.Cecil.PropertyDefinition = FindDefinition(Prop)
         Dim result As MethodReference = pD.SetMethod
         result = GetCorrectMember(result, Prop.DeclaringType)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="412" endline="419">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = GenerateCodeInternal(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\AbstractMediaHandler.vb" startline="284" endline="292">
<![CDATA[
 
     Public Function StripPath(ByVal Filename As String) As String
         Dim PathEnd As Integer = InStrRev(Filename, "\")
         If PathEnd > 0 Then
             Return Filename.Substring(PathEnd)
         Else
             Return Filename
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\InterfaceMemberSpecifier.vb" startline="118" endline="127">
<![CDATA[
 
 
     Public Function ResolveEarly() As Boolean
         Dim result As Boolean = True
 
         result = ResolveTypeReferences() AndAlso result
         result = ResolveCode(ResolveInfo.Default(Compiler)) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="906" endline="913">
<![CDATA[
 
     Public Shared Function GetTypes(ByVal Params As Mono.Collections.Generic.Collection(Of GenericParameter)) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim result As New Mono.Collections.Generic.Collection(Of TypeReference)(Params.Count)
         For i As Integer = 0 To Params.Count - 1
             result.Add(Params(i))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="914" endline="921">
<![CDATA[
 
     Public Shared Function GetTypes(ByVal Params As Mono.Collections.Generic.Collection(Of TypeReference)) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim result As New Mono.Collections.Generic.Collection(Of TypeReference)(Params.Count)
         For i As Integer = 0 To Params.Count - 1
             result.Add(Params(i))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="433" endline="441">
<![CDATA[
 
     Public Shared Function SelectNarrowingConversionOperator(ByVal Compiler As Compiler, ByVal Type As TypeReference, ByVal ReturnType As TypeReference, ByRef ConversionMethod As MethodReference) As Boolean
         Dim methods As Generic.List(Of MethodReference)
 
         methods = TypeResolution.GetNarrowingConversionOperators(Compiler, Type, ReturnType)
         If methods Is Nothing OrElse methods.Count <> 1 Then Return False
         ConversionMethod = methods(0)
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\DotAccessExpression.vb" startline="306" endline="318">
<![CDATA[
 
     Function ResolveAddressOfExpression(ByVal DelegateType As Mono.Cecil.TypeReference, ByVal ShowErrors As Boolean) As Boolean
         Dim result As Boolean = True
         Dim aoe As AddressOfExpression = TryCast(Me, AddressOfExpression)
 
         If aoe Is Nothing Then
             result = False
         Else
             result = aoe.Resolve(DelegateType, ShowErrors) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="24" endline="38">
<![CDATA[
         Get
             Dim result As Mono.Cecil.TypeReference
             Dim lType, rType As Mono.Cecil.TypeReference
 
             lType = Me.LeftType
             rType = Me.RightType
 
             If Helper.CompareType(lType, rType) AndAlso Helper.IsEnum(Compiler, lType) Then
                 result = lType
             Else
                 result = MyBase.ExpressionType()
             End If
 
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="24" endline="38">
<![CDATA[
         Get
             Dim result As Mono.Cecil.TypeReference
             Dim lType, rType As Mono.Cecil.TypeReference
 
             lType = Me.LeftType
             rType = Me.RightType
 
             If Helper.CompareType(lType, rType) AndAlso Helper.IsEnum(Compiler, lType) Then
                 result = lType
             Else
                 result = MyBase.ExpressionType()
             End If
 
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="490" endline="511">
<![CDATA[
     End Property
 
     Function VerifyConstraints(ByVal ShowErrors As Boolean) As Boolean
         Dim result As Boolean = True
 
         Dim parameters As Mono.Collections.Generic.Collection(Of GenericParameter)
         Dim arguments As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim mit As GenericInstanceMethod
         Dim md As MethodDefinition
 
         mit = TryCast(ResolvedMethod, GenericInstanceMethod)
         md = CecilHelper.FindDefinition(mit)
 
         If mit Is Nothing OrElse md Is Nothing Then Return True
 
         parameters = md.GenericParameters
         arguments = mit.GenericArguments
 
         result = Helper.VerifyConstraints(Me.Parent, parameters, arguments, ShowErrors)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="209" endline="225">
<![CDATA[
 
     Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveTypeReferences " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             result = ResolveTypeReferences(type) AndAlso result
         Next
 
         result = m_Attributes.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\AbstractMediaHandler.vb" startline="313" endline="332">
<![CDATA[
 
     Public Function CFmt(ByVal DblTime As Double, Optional ByVal CollapseZero As Boolean = False) As String
 
         If DblTime = 0 Then
             If CollapseZero Then
                 Return "0"
             Else
                 DblTime = 0.01 'This is needed for mpgtx
             End If
         End If
 
         Dim TempDt As Date
         TempDt = Date.FromOADate(DblTime / 86400)    '24 * 60 * 60
         If DblTime >= 3600 Then
             Return TempDt.ToString("HH
         Else
             Return TempDt.ToString("mm
         End If
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="981" endline="994">
<![CDATA[
 
     Public Shared Function IsNullable(ByVal Type As TypeReference) As Boolean
         Dim git As GenericInstanceType
 
         If Type Is Nothing Then Return False
         If Not Type.IsGenericInstance Then Return False
 
         If Helper.CompareNameOrdinal(Type.Name, "Nullable`1") = False Then Return False
 
         git = TryCast(Type, GenericInstanceType)
         If git Is Nothing Then Return False
 
         Return Helper.CompareType(Compiler.CurrentCompiler.TypeCache.System_Nullable1, git.ElementType)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\Attributes.vb" startline="45" endline="58">
<![CDATA[
 
     Function IsDefined(ByVal AttributeType As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean = False
 
         For Each att As Attribute In Me
             If AttributeType Is Nothing Then Return False
             If Helper.CompareType(att.AttributeType, AttributeType) Then
                 result = True
                 Exit For
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\CaseRangeExpression.vb" startline="189" endline="207">
<![CDATA[
     End Property
 
     ReadOnly Property CanBeValueClassification() As Boolean
         Get
             Select Case m_Classification
                 Case Classifications.Value, Classifications.Variable, _
                 Classifications.LateBoundAccess, Classifications.MethodGroup, _
                 Classifications.MethodPointer, Classifications.PropertyAccess, Classifications.PropertyGroup
                     Return True
                 Case Classifications.Type
                     Dim tc As TypeClassification = AsTypeClassification
                     Return tc.CanBeExpression AndAlso tc.Expression.Classification.CanBeValueClassification
                 Case Classifications.Void, Classifications.Namespace, Classifications.EventAccess
                     Return False
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
                     Return False
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="272" endline="293">
<![CDATA[
 
     ''' <summary>
     ''' ImportsClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Shared Function ParseImportsClause(ByVal Parent As ParsedObject, ByVal str As String) As ImportsClause
         Dim result As New ImportsClause(Parent)
 
         If ImportsAliasClause.IsMe(str) Then
             Dim m_Clause As ImportsAliasClause
             m_Clause = ParseImportsAliasClause(Parent, str)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(Parent.Location)
             result.Init(m_Clause)
         Else
             Dim m_Clause As ImportsNamespaceClause
             m_Clause = ParseImportsNamespaceClause(Parent, str)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(Parent.Location)
             result.Init(m_Clause)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="604" endline="640">
<![CDATA[
 
     ''' <summary>
     ''' - All code is emitted for fields with initializers.
     ''' - All the code is emitted for each and every method, constructor, operator and property.
     ''' - Classes, modules, structures, methods, constructors, properties, events, operators should implement IEmittable.Emit(Info as EmitInfo)
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Emit() As Boolean
         Dim result As Boolean = True
 
         result = EmitAttributes() AndAlso result
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Try
                 System.Console.ForegroundColor = ConsoleColor.Yellow
             Catch ex As Exception
 
             End Try
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Emit " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
             Try
                 System.Console.ResetColor()
             Catch ex As Exception
 
             End Try
 #End If
             result = Emit(type) AndAlso result
         Next
 
         SetFileVersion()
         SetAdditionalAttributes()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="320" endline="345">
<![CDATA[
 
     Function RuleStringConcat(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleAdditionSubtractionStringConcat(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Concat)
             NextToken()
             RuleAdditionSubtractionStringConcat(RSide)
 
             Dim op1, op2 As String
             Dim bErr As Boolean
 
             op1 = LSide.ToString
             op2 = RSide.ToString
 
             If bErr Then
                 LSide = ""
             Else
                 LSide = op1 & op2
             End If
         End While
         While CurrentToken.Equals(KS.Concat)
             NextToken()
             RuleAdditionSubtractionStringConcat(RSide)
 
             Dim op1, op2 As String
             Dim bErr As Boolean
 
             op1 = LSide.ToString
             op2 = RSide.ToString
 
             If bErr Then
                 LSide = ""
             Else
                 LSide = op1 & op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="90" endline="100">
<![CDATA[
 
     Public ReadOnly Property IsExternalDeclaration() As Boolean
         Get
             If TypeOf Me Is ExternalSubDeclaration Then Return True
             If CustomAttributes Is Nothing Then Return False
             For i As Integer = 0 To CustomAttributes.Count - 1
                 If CustomAttributes(i).ResolvedType Is Nothing Then Continue For
                 If Helper.CompareType(CustomAttributes(i).ResolvedType, Compiler.TypeCache.System_Runtime_InteropServices_DllImportAttribute) Then Return True
             Next
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\CallStatement.vb" startline="38" endline="60">
<![CDATA[
     End Property
 
     Private Function IsExcluded() As Boolean
         Dim exp As InvocationOrIndexExpression
         Dim method As Mono.Cecil.MethodReference
         Dim classification As MethodGroupClassification
    
         If Not m_Target.Classification.IsVoidClassification Then Return False
 
         exp = TryCast(m_Target, InvocationOrIndexExpression)
 
         If exp Is Nothing Then Return False
         If exp.Expression Is Nothing Then Return False
 
         classification = TryCast(exp.Expression.Classification, MethodGroupClassification)
         If classification Is Nothing Then Return False
 
         method = classification.ResolvedMethodInfo
 
         If method Is Nothing Then Return False
 
         Return Compiler.Scanner.IsConditionallyExcluded(method, Me.Location)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="347" endline="359">
<![CDATA[
 
     Private Function CreateRegularEventMembers(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To Type.Members.Count - 1
             Dim t As TypeDeclaration = TryCast(Type.Members(i), TypeDeclaration)
             If t IsNot Nothing Then result = CreateRegularEventMembers(t) AndAlso result
             Dim red As RegularEventDeclaration = TryCast(Type.Members(i), RegularEventDeclaration)
             If red IsNot Nothing Then result = red.CreateRegularEventMembers AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\AbstractMediaHandler.vb" startline="155" endline="173">
<![CDATA[
 
     Protected Function GetPieceSegments(ByVal MediaDuration As Double, _
     ByVal Pieces As Integer) As Segment()
 
         If MediaDuration = 0 Then Return Nothing
         If Pieces = 0 Then Return Nothing
 
         Dim PieceDur As Double = MediaDuration / Pieces
         Dim Temp(Pieces - 1) As Segment
         For i As Integer = 0 To Pieces - 1
             Temp(i) = New Segment
             Temp(i).Start = i * PieceDur
             Temp(i).Finish = (i + 1) * PieceDur
         Next
         Temp(Pieces - 1).Finish = MediaDuration
 
         Return Temp
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CodeFiles.vb" startline="908" endline="928">
<![CDATA[
 
     ''' <summary>
     ''' Add all the files corresponding to the specified pattern in the specified
     ''' directory to the list of code files, recursively.
     ''' </summary>
     Private Function AddFilesInDir(ByVal dir As String, ByVal relativepath As String, ByVal pattern As String) As Boolean
         Dim strFiles() As String
         Dim result As Boolean = True
 
         strFiles = IO.Directory.GetFiles(dir, pattern)
         For Each strFile As String In strFiles
             m_lstFileNames.Add(New CodeFile(strFile, relativepath, Me.Compiler))
         Next
         result = True
         strFiles = IO.Directory.GetDirectories(dir)
         For Each strDir As String In strFiles
             result = AddFilesInDir(strDir, IO.Path.Combine(relativepath, System.IO.Path.GetFileName(strDir)), pattern) AndAlso result
         Next
         'whoami()
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="97" endline="118">
<![CDATA[
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <param name="IncludePath"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Function ToString(ByVal IncludePath As Boolean, ByVal Compiler As Compiler) As String
         If m_Line < 0 Then
             Return "(in the commandline)"
         End If
 
         If Not File(Compiler) Is Nothing Then
             If IncludePath Then
                 Return String.Format("{0} ({1},{2})", File(Compiler).FileName, Line.ToString, Column.ToString)
             Else
                 Return String.Format("{0} ({1},{2})", File(Compiler).FileNameToReport, Line.ToString, Column.ToString)
             End If
         Else
             Return String.Format("({0},{1})", Line.ToString, Column.ToString)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="177" endline="201">
<![CDATA[
     End Property
 
     Protected Sub FindDefaultConstructors()
         For i As Integer = 0 To Me.Members.Count - 1
             Dim member As IMember = Me.Members(i)
             Dim ctor As ConstructorDeclaration = TryCast(member, ConstructorDeclaration)
 
             If ctor Is Nothing Then Continue For
 
             Dim isdefault As Boolean
             isdefault = False
             If ctor.GetParameters.Length = 0 Then
                 isdefault = True
             Else
                 isdefault = ctor.GetParameters()(0).IsOptional
             End If
             If isdefault Then
                 If ctor.IsShared Then
                     If m_DefaultSharedConstructor Is Nothing Then m_DefaultSharedConstructor = ctor
                 Else
                     If m_DefaultInstanceConstructor Is Nothing Then m_DefaultInstanceConstructor = ctor
                 End If
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AliasClause.vb" startline="60" endline="83">
<![CDATA[
     End Property
 
     Function CreateArrayType(ByVal OriginalType As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Dim result As Mono.Cecil.TypeReference = OriginalType
 
         If m_ArrayTypeModifiers IsNot Nothing Then
             result = m_ArrayTypeModifiers.CreateArrayType(result)
         End If
 
         If m_BoundList.Expressions.GetUpperBound(0) = 0 Then
             result = CecilHelper.MakeArrayType(result)
         Else
             Dim arr As ArrayType
             arr = CecilHelper.MakeArrayType(result, m_BoundList.Expressions.GetUpperBound(0) + 1)
             result = arr
             If arr.Rank > 1 Then
                 For d As Integer = 0 To arr.Rank - 1
                     arr.Dimensions(d) = New ArrayDimension(New Nullable(Of Integer)(0), Nothing)
                 Next
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="136" endline="158">
<![CDATA[
 
     Function RuleUnaryNegation(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing
 
         If CurrentToken.Equals(KS.Minus) Then
             NextToken()
             RuleUnaryNegation = RuleExponent(LSide)
 
             Dim op1 As Double
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 LSide = 0
             Else
                 LSide = -op1
             End If
         Else
             If RuleExponent(LSide) = False Then
                 Return False
             End If
         End If
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeCache.vb" startline="211" endline="226">
<![CDATA[
 #End If
 
     Protected Overloads Function [GetType](ByVal Assembly As Mono.Cecil.AssemblyDefinition, ByVal FullName As String) As Mono.Cecil.TypeDefinition
         If Assembly Is Nothing Then Return Nothing
         Dim result As Mono.Cecil.TypeDefinition = Nothing
         Dim split As String() = FullName.Split("+"c)
         For i As Integer = 0 To split.Length - 1
             If result Is Nothing Then
                 result = Assembly.MainModule.GetType(split(i))
             Else
                 result = Me.GetType(result, split(i))
             End If
         Next
         If result Is Nothing Then Compiler.Report.WriteLine(String.Format("Could not load the type '{0}' from the assembly '{1}'", FullName, Assembly.Name.FullName))
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\AbstractMediaHandler.vb" startline="134" endline="154">
<![CDATA[
 
     Protected Function GetDurationSegments(ByVal MediaDuration As Double, _
     ByVal PieceDur As Double) As Segment()
 
         If MediaDuration = 0 Then Return Nothing
         If PieceDur = 0 Then Return Nothing
 
         Dim Pieces As Integer = CInt(Fix(MediaDuration / PieceDur))
         If MediaDuration Mod PieceDur > 0 Then Pieces += 1
         Dim Temp(Pieces - 1) As Segment
 
         For i As Integer = 0 To Pieces - 1
             Temp(i) = New Segment
             Temp(i).Start = i * PieceDur
             Temp(i).Finish = (i + 1) * PieceDur
         Next
         Temp(Pieces - 1).Finish = MediaDuration
 
         Return Temp
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="180" endline="208">
<![CDATA[
 
     Function FillWithOptionalParameters(ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Dim result As Boolean = True
         Dim parameters As Mono.Collections.Generic.Collection(Of ParameterDefinition)
 
         If Method Is Nothing Then Return False
 
         parameters = Helper.GetParameters(Compiler, Method)
 
         For i As Integer = 0 To parameters.Count - 1
             If i >= Me.Count OrElse m_Arguments(i).Expression Is Nothing Then
                 Helper.Assert(parameters(i).IsOptional)
 
                 Dim newExp As ConstantExpression
                 Dim newArg As PositionalArgument
 
                 newExp = New ConstantExpression(Me, parameters(i).Constant, parameters(i).ParameterType)
                 newArg = New PositionalArgument(Me, i, newExp)
 
                 If i >= Me.Count Then
                     Me.Arguments.Add(newArg)
                 Else
                     Me.Arguments(i) = newArg
                 End If
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeParameter.vb" startline="37" endline="69">
<![CDATA[
 
     Public Overrides Function CreateDefinition() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.CreateDefinition() AndAlso result
 
         If m_CecilBuilder IsNot Nothing Then Return result
 
         Dim p As BaseObject = Me.Parent
         Dim owner As Mono.Cecil.IGenericParameterProvider = Nothing
         While p IsNot Nothing AndAlso owner Is Nothing
             Dim tD As TypeDeclaration = TryCast(p, TypeDeclaration)
             Dim mD As MethodBaseDeclaration = TryCast(p, MethodBaseDeclaration)
 
             If tD IsNot Nothing Then
                 owner = tD.CecilType
                 Exit While
             ElseIf mD IsNot Nothing Then
                 owner = mD.CecilBuilder
                 Exit While
             Else
                 p = p.Parent
             End If
         End While
         While p IsNot Nothing AndAlso owner Is Nothing
             Dim tD As TypeDeclaration = TryCast(p, TypeDeclaration)
             Dim mD As MethodBaseDeclaration = TryCast(p, MethodBaseDeclaration)
 
             If tD IsNot Nothing Then
                 owner = tD.CecilType
                 Exit While
             ElseIf mD IsNot Nothing Then
                 owner = mD.CecilBuilder
                 Exit While
             Else
                 p = p.Parent
             End If
         End While
 
         Helper.Assert(owner IsNot Nothing)
 
         m_CecilBuilder = New Mono.Cecil.GenericParameter(m_Identifier.Identifier, owner)
         m_CecilBuilder.Annotations.Add(Compiler, Me)
         owner.GenericParameters.Add(m_CecilBuilder)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="1250" endline="1284">
<![CDATA[
 
     Private Shared Function ParseQualifiedIdentifier(ByVal Parent As ParsedObject, ByVal str As String) As QualifiedIdentifier
         Dim result As New QualifiedIdentifier(Parent)
 
         Dim m_First As ParsedObject
         Dim m_Second As Token = Nothing
 
         Dim first As String
         Dim second As String = Nothing
         Dim isplit As Integer = str.LastIndexOf("."c)
 
         If isplit >= 0 Then
             first = str.Substring(0, isplit)
             second = str.Substring(isplit + 1)
         Else
             first = str
         End If
 
         If first.Contains("."c) Then
             m_First = ParseQualifiedIdentifier(result, first)
             If m_First Is Nothing Then Helper.ErrorRecoveryNotImplemented(Parent.Location)
         ElseIf first.Length > 7 AndAlso Helper.CompareName(first.Substring(1, 7), "Global.") Then
             m_First = New GlobalExpression(result)
         Else
             m_First = New Identifier(Parent, first, Parent.Location, TypeCharacters.Characters.None)
         End If
 
         If second IsNot Nothing Then
             m_Second = Token.CreateIdentifierToken(Span.CommandLineSpan, second)
         End If
 
         result.Init(m_First, m_Second)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="4342" endline="4354">
<![CDATA[
 
     Private Sub chkEnabled_Clicked(ByVal sender As Object, ByVal e As System.EventArgs) Handles chkEnabled.Click
         Dim Tool As ToolSpec = DirectCast(lbStdTools.SelectedItem, ToolSpec)
         If chkEnabled.Checked = True Then
             If Not mStdToolMgr.isValid(Tool.DisplayName) Then
                 chkEnabled.Checked = False
                 MsgBox(mTranslator.LangText(102), MsgBoxStyle.Exclamation)
                 Exit Sub
             Else
                 SaveToolMgr()
             End If
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3417" endline="3428">
<![CDATA[
 
     Private Function Safe2ShowTuner() As Boolean
 
         Select Case lvPositions.SelectedItems.Count
             Case 0, Is > 1
                 Return False
             Case 1
                 If lvPositions.SelectedItems(0).SubItems.Count = 1 Then Return False
         End Select
         Return True
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeCache.vb" startline="377" endline="388">
<![CDATA[
 
     Protected Overrides Sub InitAssemblies()
         For Each a As Mono.Cecil.AssemblyDefinition In Compiler.TypeManager.CecilAssemblies
             If a.Name.Name = "Microsoft.VisualBasic" Then
                 vbruntime = a 
             ElseIf a.Name.Name = "mscorlib" Then
                 mscorlib = a 
             ElseIf a.Name.Name = "System.Windows.Forms" Then
                 winforms = a 
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Compiler.vb" startline="642" endline="667">
<![CDATA[
 
     ''' <summary>
     ''' Returns true if the specified MethodInfo is a valid candidate to a Main function.
     ''' </summary>
     ''' <param name="method"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsMainMethod(ByVal method As Mono.Cecil.MethodDefinition) As Boolean
         'Only static methods
         If method.IsStatic = False Then Return False
         'Only non-private methods (or maybe only public?)
         If method.IsPrivate Then Return False
         'Only methods called 'Main'
         If vbnc.Helper.CompareName(method.Name, "Main") = False Then Return False
         'Only methods with no return type or Integer return type
         If Helper.CompareType(method.ReturnType, Compiler.TypeCache.System_Void) = False AndAlso Helper.CompareType(method.ReturnType, Compiler.TypeCache.System_Int32) = False Then Return False
 
         'Only methods with no parameters or methods with one String() parameter
         Dim params As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         params = method.Parameters
         If params.Count = 0 Then Return True
         If params.Count > 1 Then Return False
         If Helper.CompareType(params(0).ParameterType, Compiler.TypeCache.System_String_Array) AndAlso params(0).IsOptional = False AndAlso params(0).IsOut = False Then Return True
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\DotAccessExpression.vb" startline="343" endline="354">
<![CDATA[
 
     Function DereferenceByRef() As Expression
         Dim result As Expression
 
         If CecilHelper.IsByRef(ExpressionType) Then
             result = New DeRefExpression(Me, Me)
         Else
             result = Me
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="63" endline="69">
<![CDATA[
     End Property
 
     Function GetAllDictionaries() As Generic.List(Of TypeDictionary)
         Dim result As New Generic.List(Of TypeDictionary)
         result.AddRange(Values)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="242" endline="261">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Compare one CodeFile to another based on filename.
     ''' </summary>
     ''' <param name="value"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Overrides Function Equals(ByVal value As Object) As Boolean
         Dim file As CodeFile = TryCast(value, CodeFile)
         If file IsNot Nothing Then
             If file Is Me Then
                 Return True
             Else
                 Return Microsoft.VisualBasic.Strings.StrComp(m_FileName, file.FileName, Microsoft.VisualBasic.CompareMethod.Text) = 0
             End If
         Else
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="295" endline="305">
<![CDATA[
 
     Shared Function IsEmittableMember(ByVal Compiler As Compiler, ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Dim result As Boolean
 
         If Member Is Nothing Then Return True
         If TypeOf Member Is Mono.Cecil.GenericParameter Then Return True
         If TypeOf Member Is Mono.Cecil.ArrayType Then Return True
         result = FindAssembly(Member) Is Compiler.AssemblyBuilderCecil
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\AbstractMediaHandler.vb" startline="113" endline="120">
<![CDATA[
 
     Private Function FindToolIndex(ByVal DisplayName As String) As Integer
         For i As Integer = 0 To mList.Count - 1
             Dim Tool As ToolSpec = DirectCast(mList(i), ToolSpec)
             If Tool.DisplayName = DisplayName Then Return i
         Next
         Return -1
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="846" endline="868">
<![CDATA[
 
     ''' <summary>
     ''' VariableInitializer  
     ''' RegularInitializer 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseVariableInitializer(ByVal Parent As ParsedObject) As VariableInitializer
         Dim result As New VariableInitializer(Parent)
 
         If ArrayElementInitializer.CanBeMe(tm) Then
             Dim newAEI As ArrayElementInitializer
             newAEI = ParseArrayElementInitializer(Parent)
             If newAEI Is Nothing Then Return Nothing
             result.Init(newAEI)
         Else
             Dim newExp As Expression
             newExp = ParseExpression(Parent)
             If newExp Is Nothing Then Return Nothing
             result.Init(newExp)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\BaseObject.vb" startline="219" endline="242">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Get the compiler compiling right now.
     ''' </summary>
     Overridable ReadOnly Property Compiler() As Compiler Implements IBaseObject.Compiler
         Get
             If m_Compiler IsNot Nothing Then
                 Return m_Compiler
             End If
 
             If TypeOf m_Parent Is Compiler Then
                 m_Compiler = DirectCast(m_Parent, Compiler)
             ElseIf TypeOf Me Is Compiler Then
                 m_Compiler = DirectCast(Me, vbnc.Compiler)
             ElseIf m_Parent Is Nothing Then
                 Return Nothing
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 m_Compiler = m_Parent.Compiler
             End If
 
             Return m_Compiler
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="316" endline="347">
<![CDATA[
 
     ''' <summary>
     ''' ImportsAliasClause  
     '''	Identifier  =  QualifiedIdentifier  |
     '''	Identifier  =  ConstructedTypeName
     ''' 
     ''' ConstructedTypeName  
     '''	QualifiedIdentifier  "("  "Of"  TypeArgumentList  ")"
     ''' 
     ''' This overload is used when parsing commandline imports.
     ''' </summary>
     ''' <param name="str"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Shared Function ParseImportsAliasClause(ByVal Parent As ParsedObject, ByVal str As String) As ImportsAliasClause
         Dim result As New ImportsAliasClause(Parent)
 
         Dim m_Identifier As Identifier
         Dim m_Second As ImportsNamespaceClause = Nothing
 
         Dim values() As String = str.Split("="c)
         If values.Length <> 2 Then Return Nothing
 
         m_Identifier = New Identifier(result, values(0), Span.CommandLineSpan, TypeCharacters.Characters.None)
 
         m_Second = ParseImportsNamespaceClause(result, values(1))
         If m_Second Is Nothing Then Helper.ErrorRecoveryNotImplemented(Parent.Location)
 
         result.Init(m_Identifier, m_Second)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2558" endline="2574">
<![CDATA[
 
     Shared Function GetTypeOrTypeBuilders(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference(), Optional ByVal OnlySuccessful As Boolean = False) As Mono.Cecil.TypeReference()
         Dim result() As Mono.Cecil.TypeReference
         If Type Is Nothing Then Return Nothing
 
         ReDim result(Type.GetUpperBound(0))
         For i As Integer = 0 To Type.GetUpperBound(0)
             Dim tmp As Mono.Cecil.TypeReference
             tmp = GetTypeOrTypeBuilder(Compiler, Type(i))
             If tmp Is Nothing AndAlso OnlySuccessful Then
                 result(i) = Type(i)
             Else
                 result(i) = tmp
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="385" endline="409">
<![CDATA[
 
     Private Function ContainsGenericParameters(ByVal Type As TypeReference, ByVal Find As Mono.Collections.Generic.Collection(Of GenericParameter)) As Boolean
         Dim elementType As TypeReference
         Dim tg As GenericParameter
         Dim git As GenericInstanceType
 
         If Type Is Nothing Then Return False
 
         tg = TryCast(Type, GenericParameter)
         If tg IsNot Nothing AndAlso Find.Contains(tg) Then Return True
 
         git = TryCast(Type, GenericInstanceType)
         If git IsNot Nothing AndAlso git.HasGenericArguments Then
             For i As Integer = 0 To Find.Count - 1
                 If git.GenericArguments.Contains(Find(i)) Then Return True
             Next
         End If
 
         elementType = Type.GetElementType()
         If elementType IsNot Nothing AndAlso elementType IsNot Type Then
             Return ContainsGenericParameters(elementType, Find)
         End If
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="942" endline="980">
<![CDATA[
 
     ''' <summary>
     ''' Creates an integer array of the arguments.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Arguments"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function EmitIntegerArray(ByVal Info As EmitInfo, ByVal Arguments As Expression()) As Boolean
         Dim result As Boolean = True
 
         Dim arrayType As Mono.Cecil.TypeReference = Info.Compiler.TypeCache.System_Int32_Array
         Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(arrayType)
         Dim tmpVar As Mono.Cecil.Cil.VariableDefinition = Emitter.DeclareLocal(Info, arrayType)
         Dim elementInfo As EmitInfo = Info.Clone(Info.Context, True, False, elementType)
 
         'Create the array.
         ArrayCreationExpression.EmitArrayCreation(Info, arrayType, New Generic.List(Of Integer)(New Integer() {Arguments.Length}))
 
         'Save it into a temporary variable.
         Emitter.EmitStoreVariable(Info, tmpVar)
 
         'Store every element into its index in the array.
         For i As Integer = 0 To Arguments.Length - 1
             'Load the array variable.
             Emitter.EmitLoadVariable(Info, tmpVar)
             Emitter.EmitLoadI4Value(Info, i)
             'Load all the indices.
             result = Arguments(i).GenerateCode(elementInfo) AndAlso result
             'Store the element in the arry.
             Emitter.EmitStoreElement(elementInfo, elementType, arrayType)
             'Increment the indices.
         Next
 
         'Load the final array onto the stack.
         Emitter.EmitLoadVariable(Info, tmpVar)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeImplementsClauses.vb" startline="521" endline="551">
<![CDATA[
 
     Private Function CheckModules(ByVal moduletypes As TypeList, ByVal R As String, ByVal TypeArgumentCount As Integer) As Boolean
         '**	(...), and R matches the name of an 
         '** accessible nested type in exactly one standard module, (...)
 #If DEBUG Then
         For Each t As Mono.Cecil.TypeReference In moduletypes
             Helper.Assert(Helper.IsModule(FromWhere.Compiler, t))
         Next
 #End If
         Dim allModuleTypes As New Generic.List(Of Mono.Cecil.TypeReference) 'Descriptor)
 
         For Each t As Mono.Cecil.TypeReference In moduletypes
             Dim tFound As Mono.Cecil.TypeReference
             tFound = CecilHelper.GetNestedType(t, R)
             If tFound IsNot Nothing Then
                 allModuleTypes.Add(tFound)
             End If
         Next
 
         If allModuleTypes.Count = 1 Then
             m_FoundObjects.Add(allModuleTypes.Item(0))
             Return True
         ElseIf allModuleTypes.Count > 1 Then
             '** If R matches the name of accessible nested types in more than one standard module, a compile-time 
             '** error occurs.
             Helper.AddError(Name)
             Return False
         End If
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2720" endline="2746">
<![CDATA[
 
     Shared Function GetMostEncompassedTypes(ByVal Compiler As Compiler, ByVal Types() As TypeCode) As TypeCode()
         Dim result As Generic.List(Of TypeCode)
 
         If Types Is Nothing Then Return Nothing
         If Types.Length <= 1 Then Return Types
 
         result = New Generic.List(Of TypeCode)(Types)
 
         If result.Count <= 1 Then Return result.ToArray
 
         Dim didSomething As Boolean = False
         Do
             didSomething = False
             For i As Integer = result.Count - 2 To 0 Step -1
                 If IsFirstEncompassingSecond(Compiler, result(i), result(i + 1)) Then
                     result.RemoveAt(i)
                     didSomething = True
                 ElseIf IsFirstEncompassingSecond(Compiler, result(i + 1), result(i)) Then
                     result.RemoveAt(i + 1)
                     didSomething = True
                 End If
             Next
         Loop While didSomething
 
         Return result.ToArray
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmManual.vb" startline="603" endline="631">
<![CDATA[
 
     Private Sub LstSecurity_SelectedIndexChanged(ByVal sender As Object, ByVal e As System.EventArgs) Handles LstSecurity.SelectedIndexChanged
 
         If My.Settings.ViewInfo = True Then
 
             Dim I, Indx As Integer
             For I = 0 To LstSecurity.SelectedItems.Count - 1
                 Indx = LstSecurity.SelectedItems(I).Index
             Next
 
             If Indx = 0 Then
                 Service_Info("wscsvc")
             ElseIf Indx = 1 Then
                 Service_Info("wuauserv")
             ElseIf Indx = 2 Then
                 Service_Info("WinDefend")
             ElseIf Indx = 3 Then
                 Service_Info("MpsSvc")
             ElseIf Indx = 4 Then
                 Service_Info("SDRSVC")
             ElseIf Indx = 5 Then
                 Service_Info("RemoteRegistry")
             ElseIf Indx = 6 Then
                 Service_Info("PolicyAgent")
             End If
 
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="287" endline="313">
<![CDATA[
 
     Private Sub CreateDefaultCtorCallCecil()
         Dim type As TypeDeclaration = Me.FindFirstParent(Of TypeDeclaration)()
         Dim classtype As ClassDeclaration = TryCast(type, ClassDeclaration)
         Dim defaultctor As Mono.Cecil.MethodReference
         If classtype IsNot Nothing Then
             defaultctor = classtype.GetBaseDefaultConstructorCecil()
             If defaultctor IsNot Nothing AndAlso Helper.IsPrivate(defaultctor) = False Then
                 If Helper.IsPrivate(defaultctor) OrElse (Helper.IsFamilyOrAssembly(defaultctor) AndAlso defaultctor.DeclaringType.Module.Assembly IsNot Me.Compiler.AssemblyBuilderCecil) Then
                     Helper.AddError(Compiler, Location, "Base class does not have an accessible default constructor")
                 Else
                     m_DefaultBaseConstructorCecil = defaultctor
                     m_DefaultBaseConstructorCecil = Helper.GetMethodOrMethodReference(Compiler, m_DefaultBaseConstructorCecil)
 
 #If DEBUG Then
                     Try
                         For Each param As Mono.Cecil.ParameterDefinition In m_DefaultBaseConstructor.Parameters
                             Helper.Assert(param.IsOptional)
                         Next
                     Catch ex As Exception
                         Helper.Assert(False)
                     End Try
 #End If
                 End If
             End If
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="116" endline="144">
<![CDATA[
     Function IsConditionallyExcluded(ByVal CalledMethod As Mono.Cecil.MethodReference, ByVal AtLocation As Span) As Boolean
         Dim attribs As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttribute)
 
         If m_Methods.ContainsKey(CalledMethod) Then
             attribs = m_Methods(CalledMethod)
         Else
             attribs = CecilHelper.FindDefinition(CalledMethod).CustomAttributes
             m_Methods.Add(CalledMethod, attribs)
         End If
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return False
 
         For i As Integer = 0 To attribs.Count - 1
             Dim attrib As Mono.Cecil.CustomAttribute = attribs(i)
             Dim identifier As String
             If Helper.CompareType(Compiler.TypeCache.System_Diagnostics_ConditionalAttribute, attrib.AttributeType) = False Then
                 Continue For
             End If
             If attrib.ConstructorArguments.Count <> 1 Then
                 Continue For
             End If
             identifier = TryCast(attrib.ConstructorArguments(0).Value, String)
             If identifier = String.Empty Then Continue For
 
             If Not IsDefinedAtLocation(identifier, AtLocation) Then Return True
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\Main.vb" startline="222" endline="228">
<![CDATA[
 
     Public Function Remove(ByVal index As Integer) As Segment
         Dim obj As Segment
         obj = SegmentCollection(index)
         Remove = obj
         SegmentCollection.Remove(obj)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="120" endline="128">
<![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             If MyBase.IsResolved Then
                 Return m_ExpressionType
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="3912" endline="3919">
<![CDATA[
 
     Shared Function IsParamArrayParameter(ByVal Context As BaseObject, ByVal Parameter As Mono.Cecil.ParameterReference) As Boolean
         Dim result As Boolean
         Dim pD As Mono.Cecil.ParameterDefinition = CecilHelper.FindDefinition(Parameter)
         result = CecilHelper.IsDefined(pD.CustomAttributes, Context.Compiler.TypeCache.System_ParamArrayAttribute)
         LogResolutionMessage(Context.Compiler, "IsParamArrayParameter
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\EventAccessorDeclarations.vb" startline="69" endline="78">
<![CDATA[
     End Property
 
     ReadOnly Property AddDefinition() As Mono.Cecil.MethodDefinition
         Get
             If m_AddMethod Is Nothing Then
                 Return Nothing
             Else
                 Return m_AddMethod.CecilBuilder
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\EventAccessorDeclarations.vb" startline="79" endline="88">
<![CDATA[
     End Property
 
     ReadOnly Property RemoveDefinition() As Mono.Cecil.MethodDefinition
         Get
             If m_RemoveMethod Is Nothing Then
                 Return Nothing
             Else
                 Return m_RemoveMethod.CecilBuilder
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\EventAccessorDeclarations.vb" startline="89" endline="98">
<![CDATA[
     End Property
 
     ReadOnly Property RaiseDefinition() As Mono.Cecil.MethodDefinition
         Get
             If m_RaiseMethod Is Nothing Then
                 Return Nothing
             Else
                 Return m_RaiseMethod.CecilBuilder
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="80" endline="89">
<![CDATA[
 
     Function GetCache(ByVal Type As Mono.Cecil.TypeReference) As MemberCache
         Dim result As MemberCache = Nothing
 
         If MemberCache.TryGetValue(Type, result) Then
             Return result
         Else
             Return New MemberCache(Compiler, Type)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="1890" endline="1904">
<![CDATA[
 
     Private Function ParseBuiltInTypeExpression(ByVal Parent As ParsedObject) As BuiltInTypeExpression
         Dim result As New BuiltInTypeExpression(Parent)
 
         Dim m_Type As BuiltInDataTypes
 
         Helper.Assert(tm.CurrentToken.Equals(Enums.BuiltInTypeTypeNames))
 
         m_Type = CType(tm.CurrentToken.Keyword, BuiltInDataTypes)
         tm.NextToken()
 
         result.Init(m_Type)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="1175" endline="1194">
<![CDATA[
 
     ''' <summary>
     ''' ArrayTypeModifiers  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseArrayTypeModifiers(ByVal Parent As ParsedObject) As ArrayTypeModifiers
         Dim result As New ArrayTypeModifiers(Parent)
 
         Dim tmp As New Generic.List(Of ArrayTypeModifier)
         Do
             Dim newATM As ArrayTypeModifier
             newATM = ParseArrayTypeModifier(result)
             If newATM Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             tmp.Add(newATM)
         Loop While ArrayTypeModifier.CanBeMe(tm)
 
         result.Init(tmp.ToArray)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="113" endline="124">
<![CDATA[
 
     Private Function DefineTypeHierarchy(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = Type.DefineTypeHierarchy AndAlso result
 
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = DefineTypeHierarchy(NestedType) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeCache.vb" startline="248" endline="261">
<![CDATA[
 
     Protected Function GetProperty(ByVal Type As Mono.Cecil.TypeDefinition, ByVal Name As String, ByVal ParamArray Types() As Mono.Cecil.TypeReference) As Mono.Cecil.PropertyDefinition
         If Type Is Nothing Then Return Nothing
         Dim properties As Mono.Collections.Generic.Collection(Of PropertyDefinition)
         properties = CecilHelper.FindProperties(Type.Properties, Name)
         For i As Integer = 0 To properties.Count - 1
             Dim prop As Mono.Cecil.PropertyDefinition = properties(i)
             Dim params As Mono.Collections.Generic.Collection(Of ParameterDefinition) = prop.Parameters
 
             If IsMatch(Types, params) Then Return prop
         Next
 
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="294" endline="315">
<![CDATA[
 
     ''' <summary>
     ''' ImportsClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseImportsClause(ByVal Parent As ParsedObject) As ImportsClause
         Dim result As New ImportsClause(Parent)
 
         If ImportsAliasClause.IsMe(tm) Then
             Dim m_Clause As ImportsAliasClause
             m_Clause = ParseImportsAliasClause(result)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(m_Clause)
         Else
             Dim m_Clause As ImportsNamespaceClause
             m_Clause = ParseImportsNamespaceClause(result)
             If m_Clause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             result.Init(m_Clause)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1728" endline="1755">
<![CDATA[
 
     ''' <summary>
     ''' Finds the parent namespace of the specified namespace.
     ''' "NS1.NS2" => "NS1"
     ''' "NS1" => ""
     ''' "" => Nothing
     ''' Nothing =>InternalException()
     ''' </summary>
     ''' <param name="Namespace"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function GetNamespaceParent(ByVal [Namespace] As String) As String
         If [Namespace] Is Nothing Then
             Throw New InternalException("")
         ElseIf [Namespace] = String.Empty Then
             Return Nothing
         Else
             Dim dotIdx As Integer
             dotIdx = [Namespace].LastIndexOf("."c)
             If dotIdx > 0 Then
                 Return [Namespace].Substring(0, dotIdx)
             ElseIf dotIdx = 0 Then
                 Throw New InternalException("A namespace starting with a dot??")
             Else
                 Return String.Empty
             End If
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2752" endline="2761">
<![CDATA[
 
     Shared Function IsNullableType(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As Boolean
         If CecilHelper.IsValueType(Type) = False Then Return False
         If CompareType(Type, Compiler.TypeCache.System_Nullable1) Then Return True
 
         If CecilHelper.IsGenericTypeDefinition(Type) Then Return False
         If CecilHelper.IsGenericParameter(Type) Then Return False
         If CecilHelper.IsGenericType(Type) = False Then Return False
         Return Helper.CompareType(CecilHelper.GetGenericTypeDefinition(Type), Compiler.TypeCache.System_Nullable1)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeCache.vb" startline="227" endline="239">
<![CDATA[
 
     Protected Overloads Function [GetType](ByVal Type As Mono.Cecil.TypeDefinition, ByVal Name As String) As Mono.Cecil.TypeDefinition
         If Type Is Nothing Then Return Nothing
         Dim result As Mono.Cecil.TypeDefinition = Nothing
         For Each item As Mono.Cecil.TypeDefinition In Type.NestedTypes
             If Helper.CompareNameOrdinal(item.Name, Name) Then
                 result = item
                 Exit For
             End If
         Next
         If result Is Nothing Then Compiler.Report.WriteLine(String.Format("Could not load the nested type '{0}' from the type '{1}'", Name, Type.FullName))
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="292" endline="328">
<![CDATA[
 
     ''' <summary>
     ''' Tries to load the specified file as an assembly.
     ''' </summary>
     ''' <param name="Filename"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function LoadAssembly(ByVal Filename As String, ByRef FullPath As String) As Mono.Cecil.AssemblyDefinition
         Dim refAss As Mono.Cecil.AssemblyDefinition
         Dim readerParameters As New ReaderParameters(ReadingMode.Deferred)
         readerParameters.AssemblyResolver = Compiler.AssemblyResolver
 
         FullPath = Nothing
 
         '  Try
         If IO.File.Exists(Filename) Then
             refAss = Mono.Cecil.AssemblyDefinition.ReadAssembly(Filename, readerParameters)
             FullPath = Filename
             Return refAss
         End If
 
         '  Catch ex As IO.FileNotFoundException
         For Each strPath As String In Compiler.CommandLine.LibPath
             Dim strFullPath As String = IO.Path.Combine(strPath, Filename)
             Try
                 If IO.File.Exists(strFullPath) Then
                     refAss = Mono.Cecil.AssemblyDefinition.ReadAssembly(strFullPath, readerParameters)
                     FullPath = strFullPath
                     Return refAss
                 End If
             Catch ex2 As Exception
                 'Do nothing, just keep on trying
             End Try
         Next
         '  End Try
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="1351" endline="1366">
<![CDATA[
 
     Public Shared Function GetProperty(ByVal collection As ICollection, ByVal reference As PropertyReference) As PropertyDefinition
         For Each meth As PropertyDefinition In collection
             If Helper.CompareNameOrdinal(meth.Name, reference.Name) = False Then
                 Continue For
             End If
             If Not AreSame(meth.PropertyType, reference.PropertyType) Then
                 Continue For
             End If
             If Not AreSame(meth.Parameters, reference.Parameters) Then
                 Continue For
             End If
             Return meth
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="226" endline="245">
<![CDATA[
 
     Private Overloads Function ResolveTypeReferences(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = Type.ResolveTypeReferences AndAlso result
 
         If result = False Then Return result
 
         For Each Member As ParsedObject In Type.Members
             Dim NestedType As TypeDeclaration = TryCast(Member, TypeDeclaration)
             If NestedType IsNot Nothing Then
                 result = ResolveTypeReferences(NestedType) AndAlso result
             Else
                 result = Member.ResolveTypeReferences() AndAlso result
             End If
             If result = False Then Return result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Compiler.vb" startline="963" endline="982">
<![CDATA[
 
     Function FindMainMethod(ByVal MainClass As TypeDeclaration, ByVal Result As Generic.List(Of Mono.Cecil.MethodDefinition), ByRef hasMainMethod As Boolean) As Boolean
         Dim tps() As TypeDeclaration
 
         If MainClass Is Nothing Then
             tps = theAss.Types
         Else
             tps = New TypeDeclaration() {MainClass}
         End If
 
         Result.Clear()
         For Each t As TypeDeclaration In tps
             For Each m As Mono.Cecil.MethodDefinition In t.CecilType.Methods
                 If hasMainMethod = False Then hasMainMethod = vbnc.Helper.CompareName(m.Name, "Main")
                 If IsMainMethod(m) Then Result.Add(m)
             Next
         Next
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Classes\GMode.vb" startline="226" endline="253">
<![CDATA[
 
     Private Function TurnOn(ByVal Name As String, ByVal Setting As String) As String
 
         Try
             SrvcCntrl.ServiceName = (Name)
             Dim ChkSrvc As Boolean = SrvcCntrl.CanPauseAndContinue
         Catch ex As InvalidOperationException
             TurnOn = Name & "0!"
             Exit Function
         End Try
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", Setting, 0) = 1 Then
             If SrvcCntrl.Status = ServiceProcess.ServiceControllerStatus.Running OrElse SrvcCntrl.Status = ServiceProcess.ServiceControllerStatus.StartPending Then
                 TurnOn = Name & "1!"
                 Try
                     SrvcCntrl.Stop()
                     SrvcCntrl.WaitForStatus(ServiceProcess.ServiceControllerStatus.Stopped, TimeSpan.FromSeconds(3))
                 Catch ex As InvalidOperationException
                 Catch ex As System.ServiceProcess.TimeoutException
                 End Try
             Else
                 TurnOn = Name & "0!"
             End If
         Else
             TurnOn = Name & "0!"
         End If
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\MainForm.cs" startline="526" endline="573">
<![CDATA[
 
 		private void securityCheckTimer_Tick(object sender, EventArgs e)
 		{
 			if(!pm.Initialized)
 			{
 				try
 				{
 					pm.InitReceiver();
 					pm.Start();
 				}
 				catch(Exception exc)
 				{
 					string err = exc.ToString();
 					int lerr = err.Length;
 					System.Threading.Thread.Sleep(150);
 				}
 			}
 
 			
 
 			if(!this.AtLeastOneAuthorizedFob &&
 				lockingEnabled &&
 				!locked)
 			{
 				try
 				{
 					LockStation();
 				}
 				catch
 				{
 				}
 			}
             else if (!this.AtLeastOneAuthorizedFob &&
                 !lockingEnabled &&
                 !locked &&
                 !startupNoFobMessageShown)
             {
                 notifyIcon.ShowBalloonTip(2000, this.Text, "No authorized fobs detected, system is not protected by auto-locking until one is detected, and then leaves.", ToolTipIcon.Info);
                 startupNoFobMessageShown = true;
             }
             else if (this.AtLeastOneAuthorizedFob &&
                 locked)
             {
                 UnlockStation();
             }
 
 			securityCheckTimer.Interval = 500;
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\MPGhandler.vb" startline="146" endline="176">
<![CDATA[
 
 
     Public Overloads Overrides Function Split(ByVal Filename As String, _
     ByVal Size As Integer) As Boolean
         MyBase.Split(Filename, Size)
 
         'mpgtx -s file {699M} --- size
         Dim Pieces As Integer
         Try
             Dim fi As New IO.FileInfo(mInFile)
             Dim MediaSize As Long = fi.Length
             MediaSize = CLng(MediaSize / 1024)
 
             Dim Temp As String = "-s -f -b " & Chr(34) & AddDefaultPathIfNeeded(StripExtension(mOutFile)) & Chr(34) & " " _
             & Chr(34) & mInFile & Chr(34) & " {"
 
             pieces = CInt(Fix(MediaSize / Size))
             For i As Integer = 1 To (Pieces - 1)
                 Temp += Trim(CStr(i * Size)) & "k-"
             Next
             Temp += Trim(CStr(Pieces * Size)) & "k}"
 
             If mIsAudio Then SafeHarborMsg()
             RunConverter(Temp)
         Catch ex As Exception
             MsgBox(ex.Message)
         End Try
 
         Return FileCount(Filename) >= Pieces
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2987" endline="2995">
<![CDATA[
 
     <Obsolete()> Private Function ParseExpression() As Expression
         Dim result As Expression = Nothing
 
         Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
         '        result = ParseOr_OrElse_Xor(Info)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="124" endline="133">
<![CDATA[
 
     Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_InheritsClauses Is Nothing OrElse m_InheritsClauses.Count > 0) 'Perf check
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="1922" endline="1937">
<![CDATA[
 
     Private Function DirtyCheck() As Boolean
 
         If mSelsDirty Then
             If mMaskFile Then
                 If MsgBox(Replace(mTranslator.LangText(119), "{1}", mMaskFilename), MsgBoxStyle.YesNo) = MsgBoxResult.Yes Then
                     SaveMask(True)
                 End If
             Else
                 If MsgBox(mTranslator.LangText(127), MsgBoxStyle.YesNo) = MsgBoxResult.No Then
                     Return True
                 End If
             End If
         End If
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\DotAccessExpression.vb" startline="459" endline="476">
<![CDATA[
 
     Function ReportReclassifyToValueErrorMessage() As Boolean
 
         Select Case m_Classification.Classification
             Case ExpressionClassification.Classifications.EventAccess
                 Compiler.Report.ShowMessage(Messages.VBNC32022, Me.Location)
             Case ExpressionClassification.Classifications.Type
                 Compiler.Report.ShowMessage(Messages.VBNC30108, Me.Location)
             Case ExpressionClassification.Classifications.Namespace
                 Compiler.Report.ShowMessage(Messages.VBNC30112, Me.Location)
             Case ExpressionClassification.Classifications.Void
                 Compiler.Report.ShowMessage(Messages.VBNC30491, Me.Location)
             Case Else
                 Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End Select
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="158" endline="192">
<![CDATA[
 
     Public Function CreateWithEventsMembers() As Boolean
         Dim result As Boolean = True
 
         If Me.Modifiers.Is(ModifierMasks.WithEvents) = False Then Return result
 
         Dim parentType As TypeDeclaration = Me.FindFirstParent(Of TypeDeclaration)()
         Dim propertyAccessor As New PropertyDeclaration(parentType)
         Dim modifiers As Modifiers
 
         If Me.IsShared Then
             modifiers.AddModifiers(ModifierMasks.Shared)
         Else
             modifiers.AddModifier(KS.Overridable)
         End If
         If (Me.Modifiers.Mask And ModifierMasks.AccessModifiers) = 0 Then
             modifiers.AddModifier(KS.Private)
         Else
             modifiers.AddModifiers(Me.Modifiers.Mask And ModifierMasks.AccessModifiers)
         End If
 
         propertyAccessor.Init(modifiers, Name, Me.TypeName)
         propertyAccessor.SetDeclaration.Signature.Parameters(0).Name = "WithEventsValue"
         result = propertyAccessor.CreateDefinition AndAlso result
 
         propertyAccessor.HandlesField = Me
         propertyAccessor.SetDeclaration.MethodImplAttributes = Mono.Cecil.MethodImplAttributes.Synchronized
 
         Me.AddCustomAttribute(New Attribute(Me, Compiler.TypeCache.System_Runtime_CompilerServices_AccessedThroughPropertyAttribute, Name))
         Rename("_" & Name)
 
         parentType.Members.Add(propertyAccessor)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="214" endline="239">
<![CDATA[
 
     Private Function EmitVariableInitialization(ByVal Info As EmitInfo) As Boolean
         Dim variables As Generic.List(Of TypeVariableDeclaration)
         Dim parent As TypeDeclaration
         Dim result As Boolean = True
 
         parent = Me.DeclaringType
         variables = parent.Members.GetSpecificMembers(Of TypeVariableDeclaration)()
 
         For Each variable As TypeVariableDeclaration In variables
             If variable.HasInitializer AndAlso variable.IsShared = Me.IsShared Then
                 result = variable.EmitVariableInitializer(Info) AndAlso result
             End If
         Next
 
         For Each variable As LocalVariableDeclaration In parent.StaticVariables
             If variable.HasInitializer AndAlso variable.DeclaringMethod.IsShared = Me.IsShared Then
                 If Me.IsShared = False Then Emitter.EmitLoadMe(Info, Me.DeclaringType.CecilType)
                 result = variable.CreateDefinition AndAlso result
                 Emitter.EmitNew(Info, Compiler.TypeCache.MS_VB_CS_StaticLocalInitFlag__ctor)
                 Emitter.EmitStoreField(Info, CecilHelper.GetCorrectMember(variable.StaticInitBuilder, variable.StaticInitBuilder.DeclaringType))
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2039" endline="2046">
<![CDATA[
 
     Private Sub mnuInfo_Click(ByVal sender As System.Object, _
 ByVal e As System.EventArgs) Handles mnuInfo.Click
         If Not mHandler Is Nothing Then
             mHandler.ShowInfo()
             mainTabs.SelectedTab = tabTrace
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2304" endline="2321">
<![CDATA[
 
 #End Region
 
 #Region "   Playback "
 
     Private Sub mnuPlaySel_Click(ByVal sender As System.Object, _
     ByVal e As System.EventArgs) Handles mnuPlaySel.Click, mnuPlayUns.Click
 
         If lvPositions.Items.Count = 0 Then Exit Sub
         Dim MnuItem As MenuItem = DirectCast(sender, MenuItem)
 
         If MnuItem Is mnuPlaySel Then
             PlayAllSelected()
         Else
             PlayAllNotSelected()
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3268" endline="3284">
<![CDATA[
 
     Private Sub lvPositions_SelectedIndexChanged(ByVal sender As Object, _
 ByVal e As System.EventArgs) Handles lvPositions.SelectedIndexChanged
 
         If Not mAllowListIndexChange Then Exit Sub
 
         If lvPositions.SelectedItems.Count = 1 Then
             lvSelectionInit()
             mPlayer.Ctlcontrols.currentPosition = mSelStrt
             mPlayer.Ctlcontrols.pause()
             MPcontrols.RefreshPositions()
         Else
             DisplayFineControls(False)
         End If
         Timer.Enabled = False
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\DotAccessExpression.vb" startline="199" endline="233">
<![CDATA[
 
 #Region "Resolution region"
     ''' <summary>
     ''' Has this expression been resolved?
     ''' </summary>
     ''' <remarks></remarks>
     Private m_Resolved As Boolean
 
     ''' <summary>
     ''' Is this expression beeing resolved (in Resolve / DoResolve)
     ''' </summary>
     ''' <remarks></remarks>
     Private m_Resolving As Boolean
 
     Function ResolveExpression(ByVal ResolveInfo As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(ResolveInfo IsNot Nothing)
 
         StartResolve()
 
         Try
             result = ResolveExpressionInternal(ResolveInfo) AndAlso result
         Catch ex As Exception
             Compiler.Report.ShowMessage(Messages.VBNC99999, Me.Location, "Internal compiler error close to this location")
             Throw
         End Try
 #If EXTENDEDDEBUG Then
         Helper.Assert(result = False OrElse m_Classification IsNot Nothing, "Classification is nothing! (type of expression = " & Me.GetType.ToString & ")")
         Helper.Assert(ResolveInfo.CanFail OrElse result = (Compiler.Report.Errors = 0))
 #End If
 
         EndResolve(result)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2500" endline="2521">
<![CDATA[
 
     Shared Function GetMethodOrMethodReference(ByVal Compiler As Compiler, ByVal Method As Mono.Cecil.MethodReference) As Mono.Cecil.MethodReference
         Helper.Assert(Method IsNot Nothing)
         Helper.Assert(Method.DeclaringType IsNot Nothing)
 
         If Method.Annotations.Contains("MemberInReflection") Then
             Return GetMethodOrMethodReference(Compiler, DirectCast(Method.Annotations("MemberInReflection"), Mono.Cecil.MethodReference))
         End If
 
         Dim upper As Mono.Cecil.TypeReference
         upper = Method.DeclaringType
         While upper.DeclaringType IsNot Nothing
             upper = upper.DeclaringType
         End While
         While upper.DeclaringType IsNot Nothing
             upper = upper.DeclaringType
         End While
         Helper.Assert(upper.Module IsNot Nothing)
         Helper.Assert(upper.Module.Assembly IsNot Nothing)
         If Compiler.AssemblyBuilderCecil Is upper.Module.Assembly Then
             Return Method
         Else
             Return CecilHelper.MakeEmittable(Method)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3161" endline="3202">
<![CDATA[
 
     Private Sub DoFrameAdjustment(ByVal ChangeStart As Boolean, _
 ByVal Forward As Boolean)
 
         If lvPositions.SelectedItems.Count <> 1 Then Exit Sub
 
         Dim StepValue As Integer, Position, NewPosition As Double
 
         If Forward Then
             StepValue = 1
         Else
             StepValue = -1
         End If
 
         lvSelectionInit()
 
         If ChangeStart Then
             Position = mSelStrt
         Else
             If mOneSidedSelection Then Exit Sub
             Position = mSelStop
         End If
 
         mPlayer.Ctlcontrols.currentPosition = Position
         NewPosition = Position + StepValue * FineResolution.Value
 
         With lvPositions.SelectedItems(0)
             If ChangeStart Then
                 If NewPosition >= mSelStop Then Exit Sub
                 .SubItems(0).Text = SecToMin(Math.Round(NewPosition, 3))
             Else
                 If NewPosition <= MinToSec(.SubItems(0).Text) Then Exit Sub
                 If NewPosition >= mPlayer.currentMedia.duration Then Exit Sub
                 .SubItems(1).Text = SecToMin(Math.Round(NewPosition, 3))
             End If
         End With
 
         mPlayer.Ctlcontrols.currentPosition = NewPosition
         mSelsDirty = True
         UpdateSelDur()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\StdToolMgr.vb" startline="34" endline="83">
<![CDATA[
 
     ' <summary> 
     ' Required method for Designer support - do not modify 
     ' the contents of this method with the code editor.
     ' </summary>
     Friend WithEvents picSlider As System.Windows.Forms.PictureBox
     Friend WithEvents ToolTip As System.Windows.Forms.ToolTip
 
     Private Sub InitializeComponent()
         Me.components = New System.ComponentModel.Container
         Dim resources As System.Resources.ResourceManager = New System.Resources.ResourceManager(GetType(ucSlider))
         Me.picSlider = New System.Windows.Forms.PictureBox
         Me.grpBar = New System.Windows.Forms.GroupBox
         Me.ToolTip = New System.Windows.Forms.ToolTip(Me.components)
         Me.SuspendLayout()
         '
         'picSlider
         '
         Me.picSlider.Image = CType(resources.GetObject("picSlider.Image"), System.Drawing.Image)
         Me.picSlider.Location = New System.Drawing.Point(0, 2)
         Me.picSlider.Name = "picSlider"
         Me.picSlider.Size = New System.Drawing.Size(6, 6)
         Me.picSlider.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage
         Me.picSlider.TabIndex = 0
         Me.picSlider.TabStop = False
         '
         'grpBar
         '
         Me.grpBar.Location = New System.Drawing.Point(3, 5)
         Me.grpBar.Name = "grpBar"
         Me.grpBar.Size = New System.Drawing.Size(131, 8)
         Me.grpBar.TabIndex = 2
         Me.grpBar.TabStop = False
         '
         'ToolTip
         '
         Me.ToolTip.AutoPopDelay = 5000
         Me.ToolTip.InitialDelay = 500
         Me.ToolTip.ReshowDelay = 100
         '
         'ucSlider
         '
         Me.Controls.Add(Me.picSlider)
         Me.Controls.Add(Me.grpBar)
         Me.DockPadding.All = 2
         Me.Name = "ucSlider"
         Me.Size = New System.Drawing.Size(144, 16)
         Me.ResumeLayout(False)
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="726" endline="732">
<![CDATA[
     End Property
 
     ReadOnly Property ResolvedMember() As Mono.Cecil.MemberReference
         Get
             If m_ResolvedCandidate Is Nothing Then Return Nothing
             Return m_ResolvedCandidate.Member
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\OperatorDeclaration.vb" startline="98" endline="104">
<![CDATA[
     End Property
 
     Property ConstantValue() As Object
         Get
             If m_ParameterBuilderCecil Is Nothing Then Return Nothing
             Return m_ParameterBuilderCecil.Constant
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\CaseRangeExpression.vb" startline="41" endline="48">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="35" endline="42">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\MethodGroupToValueExpression.vb" startline="37" endline="44">
<![CDATA[
 
     Shared Function IsUnaryMe(ByVal tm As tm) As Boolean
         Dim result As Boolean = True
 
         Return tm.Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\MethodGroupToValueExpression.vb" startline="45" endline="52">
<![CDATA[
 
     Shared Function IsBinaryMe(ByVal tm As tm) As Boolean
         Dim result As Boolean = True
 
         Return tm.Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\MethodGroupToValueExpression.vb" startline="53" endline="60">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\PropertyGroupToPropertyAccessExpression.vb" startline="43" endline="50">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="47" endline="54">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim result As Boolean = True
 
         Return tm.Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="55" endline="62">
<![CDATA[
 
     Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1651" endline="1666">
<![CDATA[
 
     ''' <summary>
     ''' Loads the value of the specified parameter.
     ''' If it is a byref parameter, the passed-in address is loaded.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Parameter"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadParameterAddress(ByVal Info As EmitInfo, ByVal Parameter As Mono.Cecil.ParameterDefinition)
         Dim position As Integer = GetParameterPosition(Info, Parameter)
         If position <= 255 Then
             Info.ILGen.Emit(OpCodes.Ldarga_S, CByte(position))
         Else
             Info.ILGen.Emit(OpCodes.Ldarga, position)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="373" endline="382">
<![CDATA[
 
     ''' <summary>
     ''' Finds all the non-nested types in the compiling code and loads them into the lists.
     ''' </summary>
     ''' <remarks></remarks>
     Public Sub LoadCompiledTypes()
         For Each t As TypeDeclaration In Compiler.theAss.Types
             LoadType(t.CecilType)
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="1188" endline="1198">
<![CDATA[
 
     Public Shared Function FindProperties(ByVal properties As Mono.Collections.Generic.Collection(Of PropertyDefinition), ByVal name As String) As Mono.Collections.Generic.Collection(Of PropertyDefinition)
         Dim result As Mono.Collections.Generic.Collection(Of PropertyDefinition) = Nothing
         For i As Integer = 0 To properties.Count - 1
             If Helper.CompareNameOrdinal(properties(i).Name, name) Then
                 If result Is Nothing Then result = New Mono.Collections.Generic.Collection(Of PropertyDefinition)
                 result.Add(properties(i))
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="52" endline="63">
<![CDATA[
 
     Public Function Clone() As AddressOfExpression
         Dim result As New AddressOfExpression(Parent, m_Expression)
         Dim mpc As MethodPointerClassification
         If Classification IsNot Nothing Then
             mpc = Classification.AsMethodPointerClassification
             If mpc.MethodGroup.MethodDeclaration IsNot Nothing Then
                 result.Init(mpc.MethodGroup.MethodDeclaration, mpc.MethodGroup.InstanceExpression)
             End If
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\dshowUtil.vb" startline="8" endline="25">
<![CDATA[
 
     Public Function GetList() As String()
         Dim fMgr As New FilgraphManager
 
         Dim frColl As IAMCollection = DirectCast(fMgr.RegFilterCollection, IAMCollection)
         Dim frInfo As IRegFilterInfo
 
         ReDim mList(frColl.Count - 1)
 
         For i As Integer = 0 To frColl.Count - 1
             frColl.Item(i, frInfo)
             mList(i) = frInfo.Name
             'Debug.WriteLine(frInfo.Name)
         Next
 
         Return mList
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="1135" endline="1174">
<![CDATA[
 
 
     ''' <summary>
     ''' TypeName 
     ''' 
     ''' ArrayTypeName          
     ''' ArrayTypeModifiers     
     ''' ArrayTypeModifier      
     ''' RankList               
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseTypeName(ByVal Parent As ParsedObject) As TypeName
         Dim result As New TypeName(Parent)
 
         Dim m_NonArrayTypeName As NonArrayTypeName
         Dim m_ArrayTypeModifiers As ArrayTypeModifiers
         Dim m_ArrayTypeName As ArrayTypeName
 
         m_NonArrayTypeName = ParseNonArrayTypeName(result)
 
         If m_NonArrayTypeName Is Nothing Then Return Nothing
 
         If ArrayTypeName.CanBeArrayTypeModifier(tm) Then
             m_ArrayTypeName = New ArrayTypeName(Parent)
 
             m_ArrayTypeModifiers = ParseArrayTypeModifiers(m_ArrayTypeName)
             If m_ArrayTypeModifiers Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
             m_NonArrayTypeName.Parent = m_ArrayTypeName
 
             m_ArrayTypeName.Init(m_NonArrayTypeName, m_ArrayTypeModifiers)
 
             result.Init(m_ArrayTypeName)
         Else
             result.Init(m_NonArrayTypeName)
         End If
 
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="212" endline="228">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Show the saved messages. Returns true if any error messages have been shown.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function ShowSavedMessages() As Boolean
         Dim result As Boolean = False
 
         For Each msg As Message In m_SavedMessages
             ShowMessage(False, msg) 'Compiler.Report.WriteLine(str)
             If msg.Level >= MessageLevel.Error Then result = True
         Next
         m_SavedMessages.Clear()
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="185" endline="204">
<![CDATA[
 
     Overloads Function [GetType](ByVal Name As String, ByVal InList As IEnumerable, ByVal OnlyCreatedTypes As Boolean) As Generic.List(Of Mono.Cecil.TypeReference)
         Dim result As New Generic.List(Of Mono.Cecil.TypeReference)
         For Each tp As Mono.Cecil.TypeReference In InList
             Dim tpD As Mono.Cecil.TypeDefinition = TryCast(tp, Mono.Cecil.TypeDefinition)
             If OnlyCreatedTypes AndAlso tpD Is Nothing Then Continue For
             If Helper.CompareName(tp.Name, Name) OrElse Helper.CompareName(tp.FullName, Name) Then
 #If EXTENDEDDEBUG Then
                 Compiler.Report.WriteLine("Found type
 #End If
                 result.Add(tp)
             Else
 #If EXTENDEDDEBUG Then
                 Compiler.Report.WriteLine("Discarded type
 #End If
             End If
             result.AddRange(Me.GetType(Name, CecilHelper.GetNestedTypes(tp), OnlyCreatedTypes))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\dshowUtil.vb" startline="108" endline="120">
<![CDATA[
 
     Private Function BuildKeyFrameList() As Boolean
         Dim Temp As String(), Start, Finish As Integer
         Start = InStr(mInfo, "    times
         Finish = InStr(mInfo, "    filepositions
         If Finish < Start Then Exit Function
         Temp = mInfo.Substring(Start, Finish - Start).Split("-"c)
         ReDim mKeyFrames(Temp.Length - 2)   'To skip the blank that will be picked up
         For i As Integer = 0 To Temp.Length - 2
             mKeyFrames(i) = Val(Temp(i + 1))
         Next
         Return Not mKeyFrames Is Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\MainForm.cs" startline="633" endline="655">
<![CDATA[
 
 		private void enablePluginMenuItem_Click(object sender, EventArgs e)
 		{
 			foreach(ListViewItem lvi in pluginListView.SelectedItems)
 			{
 				string pluginName = lvi.Text;
 				Plugin selectedPlugin = null;
 				foreach(Plugin plugin in pluginManager.Plugins)
 				{
 					if(plugin.Name == pluginName)
 					{
 						selectedPlugin = plugin;
 						break;
 					}
 				}
 				foreach(Plugin plugin in pluginManager.Plugins)
 				{
 					if(plugin.Name == pluginName)
 					{
 						selectedPlugin = plugin;
 						break;
 					}
 				}
 
                 //Toggle the enabled state
                 selectedPlugin.Enabled = !selectedPlugin.Enabled;
                 settings.SetPluginStatus(selectedPlugin.Name, selectedPlugin.Enabled);
 			}
 			foreach(ListViewItem lvi in pluginListView.SelectedItems)
 			{
 				string pluginName = lvi.Text;
 				Plugin selectedPlugin = null;
 				foreach(Plugin plugin in pluginManager.Plugins)
 				{
 					if(plugin.Name == pluginName)
 					{
 						selectedPlugin = plugin;
 						break;
 					}
 				}
 
                 //Toggle the enabled state
                 selectedPlugin.Enabled = !selectedPlugin.Enabled;
                 settings.SetPluginStatus(selectedPlugin.Name, selectedPlugin.Enabled);
 			}
 
 			UpdatePluginListView();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="981" endline="1019">
<![CDATA[
 
     ''' <summary>
     ''' Creates an integer array of the arguments.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Arguments"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function EmitIntegerArray(ByVal Info As EmitInfo, ByVal Arguments As ArgumentList) As Boolean
         Dim result As Boolean = True
 
         Dim arrayType As Mono.Cecil.TypeReference = Info.Compiler.TypeCache.System_Int32_Array
         Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(arrayType)
         Dim tmpVar As Mono.Cecil.Cil.VariableDefinition = Emitter.DeclareLocal(Info, arrayType)
         Dim elementInfo As EmitInfo = Info.Clone(Info.Context, True, False, elementType)
 
         'Create the array.
         ArrayCreationExpression.EmitArrayCreation(Info, arrayType, New Generic.List(Of Integer)(New Integer() {Arguments.Count}))
 
         'Save it into a temporary variable.
         Emitter.EmitStoreVariable(Info, tmpVar)
 
         'Store every element into its index in the array.
         For i As Integer = 0 To Arguments.Count - 1
             'Load the array variable.
             Emitter.EmitLoadVariable(Info, tmpVar)
             Emitter.EmitLoadI4Value(Info, i)
             'Load all the indices.
             result = Arguments(i).GenerateCode(elementInfo) AndAlso result
             'Store the element in the arry.
             Emitter.EmitStoreElement(elementInfo, elementType, arrayType)
             'Increment the indices.
         Next
 
         'Load the final array onto the stack.
         Emitter.EmitLoadVariable(Info, tmpVar)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeImplementsClauses.vb" startline="430" endline="478">
<![CDATA[
 
     Private Function CheckNestedTypesOrTypeParameters(ByVal R As String, ByVal TypeArgumentCount As Integer) As Boolean
         '---------------------------------------------------------------------------------------------------------
         '* For each nested type containing the name reference, starting from the innermost type and going to the
         '* outermost, if R matches the name of an accessible nested type or a type parameter in the current type, 
         '* then the unqualified name refers to that type or type parameter.
         '---------------------------------------------------------------------------------------------------------
 
         'SPEC OMISSION
         'Spec does not say anything about type parameters declared in a method.
         If CheckCurrentFunctionForTypeParameters(R, TypeArgumentCount) Then Return True
 
 
         Dim tp As IType = FromWhere.FindFirstParent(Of IType)()
         Dim obj As BaseObject = FromWhere
         Do
             tp = obj.FindFirstParent(Of IType)()
             If tp Is Nothing Then Exit Do
             obj = DirectCast(tp, BaseObject)
 
             'First check if there are nested types with the corresponding name.
             Dim nestedName As String = Helper.CreateGenericTypename(R, TypeArgumentCount)
             Dim nestedType As TypeDefinition = tp.CecilType
 
             Do
                 For i As Integer = 0 To nestedType.NestedTypes.Count - 1
                     If Helper.CompareName(nestedType.NestedTypes(i).Name, nestedName) Then
                         m_FoundObjects.Add(nestedType.NestedTypes(i))
                         Return True 'There can only be one nested type with the same name
                     End If
                 Next
                 nestedType = CecilHelper.FindDefinition(nestedType.BaseType)
             Loop While nestedType IsNot Nothing
 
             'Then check if there are type parameters with the corresponding name
             'in the type (only if the current type is a class or a structure)
             Dim tpConstructable As IConstructable = TryCast(tp, IConstructable)
             If tpConstructable IsNot Nothing AndAlso tpConstructable.TypeParameters IsNot Nothing Then
                 Dim param As TypeParameter
                 param = tpConstructable.TypeParameters.Parameters.Item(R)
                 If param IsNot Nothing Then
                     m_FoundObjects.Add(param)
                     Return True
                 End If
             End If
         Loop
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="4117" endline="4146">
<![CDATA[
 
     Private Sub tbPositions_ButtonClick(ByVal sender As System.Object, _
     ByVal e As System.Windows.Forms.ToolBarButtonClickEventArgs) _
     Handles tbPositions.ButtonClick
 
         Dim Command As String = DirectCast(e.Button.Tag, String)
         Select Case Command
             Case "Open"
                 dlgOpenFile.Filter = "Movica MoviClips |*.moviclip"
                 dlgOpenFile.Multiselect = False
 
                 If dlgOpenFile.ShowDialog() = Windows.Forms.DialogResult.OK Then
                     Me.Refresh()
                     If Len(dlgOpenFile.FileName) > 0 Then
                         LoadMask(dlgOpenFile.FileName)
                     End If
                 End If
             Case "Save"
                 SaveMask()
             Case "Play"
                 PlayAllSelected()
             Case "PlayNotSelected"
                 PlayAllNotSelected()
             Case "PlaySelected"
                 TestSegment()
             Case "ToggleRepeat"
                 ToggleRepeatPlay()
         End Select
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\VariableIdentifiers.vb" startline="73" endline="113">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim expInfo As ExpressionResolveInfo = TryCast(Info, ExpressionResolveInfo)
 
         result = m_Initializer.ResolveCode(Info) AndAlso result
 
         If result = False Then Return result
 
         Dim initExp As Expression = TryCast(m_Initializer, Expression)
         If initExp IsNot Nothing Then
             If initExp.Classification.IsValueClassification = False Then
                 If initExp.Classification.IsMethodPointerClassification Then
                     Dim exp As ExpressionResolveInfo = TryCast(Info, ExpressionResolveInfo)
                     If exp IsNot Nothing AndAlso exp.LHSType IsNot Nothing Then
                         initExp = initExp.ReclassifyMethodPointerToValueExpression(exp.LHSType)
                     Else
                         initExp = initExp.ReclassifyToValueExpression
                     End If
                 Else
                     initExp = initExp.ReclassifyToValueExpression
                 End If
                 If initExp Is Nothing Then
                     result = False
                 Else
                     result = initExp.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
                 End If
             End If
 
             If result = False Then Return result
 
             If expInfo IsNot Nothing Then
                 initExp = Helper.CreateTypeConversion(Me, initExp, expInfo.LHSType, result)
             Else
                 Helper.StopIfDebugging()
             End If
             m_Initializer = initExp
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="680" endline="714">
<![CDATA[
 
     Sub SelectMostApplicableParamArraysVersion()
         For i As Integer = 0 To m_Candidates.Count - 1
             Dim a, b As Boolean
             Dim paramArgTypesA() As Mono.Cecil.TypeReference
             Dim paramArgTypesB() As Mono.Cecil.TypeReference
             Dim candidate As MemberCandidate = m_Candidates(i)
 
             If candidate.RemovedBy IsNot Nothing Then Continue For
             If candidate.ApplicableExpandedAndUnexpanded = False Then Continue For
 
             'We need to select between the expanded and unexpanded forms
 
             paramArgTypesA = candidate.TypesInInvokedOrder() 'expanded
             paramArgTypesB = candidate.DefinedParametersTypes() 'unexpanded
 
             a = Helper.IsFirstMoreApplicable(m_Parent, Arguments.Arguments, paramArgTypesA, paramArgTypesB)
             b = Helper.IsFirstMoreApplicable(m_Parent, Arguments.Arguments, paramArgTypesB, paramArgTypesA)
 
             If a Xor b Then
                 If a = False Then
                     Log("NOT MOST PARAMARRAY APPLICABLE
                     candidate.ApplicableExpandedAndUnexpanded = False
                     candidate.IsParamArray = False
                     'we need to unexpand
                     candidate.UnexpandParamArrayArgument()
                 Else
                     Log("NOT MOST PARAMARRAY APPLICABLE
                     candidate.ApplicableExpandedAndUnexpanded = False 'expanded is the good one
                 End If
             Else
                 Log("EQUALLY PARAMARRAY APPLICABLE
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5271" endline="5309">
<![CDATA[
 
     ''' <summary>
     ''' RedimClause  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseRedimClause(ByVal Parent As ParsedObject) As RedimClause
         Dim result As New RedimClause(Parent)
 
         Dim m_Expression As Expression
         Dim asim As ArraySizeInitializationModifier
 
         m_Expression = ParseExpression(result)
         If m_Expression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         Dim invExpression As InvocationOrIndexExpression = TryCast(m_Expression, InvocationOrIndexExpression)
         If invExpression IsNot Nothing Then
             m_Expression = invExpression.Expression
             asim = New ArraySizeInitializationModifier(result)
             Dim bl As New BoundList(asim)
             Dim exp() As Expression
 
             ReDim exp(invExpression.ArgumentList.Count - 1)
             For i As Integer = 0 To invExpression.ArgumentList.Count - 1
                 exp(i) = invExpression.ArgumentList(i).Expression
             Next
             bl.Init(exp)
             asim.Init(bl, Nothing)
 
         ElseIf tm.CurrentToken.Equals(KS.LParenthesis) AndAlso tm.PeekToken.IsIntegerLiteral AndAlso tm.PeekToken.IntegralLiteral = 0 AndAlso tm.PeekToken(2).Equals(KS.To) Then
             asim = ParseArraySizeInitializationModifer(result)
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
             Return Nothing
         End If
 
         result.Init(m_Expression, asim)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="372" endline="398">
<![CDATA[
 
     Public Function SetDefaultAttribute(ByVal Name As String) As Boolean
         Dim result As Boolean = True
 
         If CustomAttributes IsNot Nothing Then
             For Each att As Attribute In CustomAttributes
                 result = att.ResolveCode(ResolveInfo.Default(Compiler)) AndAlso result
                 If result = False Then Return result
                 If Helper.CompareType(att.AttributeType, Compiler.TypeCache.System_Reflection_DefaultMemberAttribute) Then
                     Dim tmpName As String
                     tmpName = TryCast(att.GetArgument(0), String)
                     If tmpName IsNot Nothing AndAlso Helper.CompareNameOrdinal(Name, tmpName) = False Then
                         Compiler.Report.ShowMessage(Messages.VBNC32304, Location, Me.FullName, tmpName, Name)
                         Return False
                     End If
                     Return True
                 End If
             Next
         End If
 
         'Helper.NotImplementedYet("Check that the property is indexed.")
         Dim attrib As Attribute
         attrib = New Attribute(Me, Compiler.TypeCache.System_Reflection_DefaultMemberAttribute, Name)
         result = attrib.ResolveCode(ResolveInfo.Default(Compiler)) AndAlso result
         AddCustomAttribute(attrib)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="242" endline="249">
<![CDATA[
     End Property
 
     Public ReadOnly Property GetParameters() As Mono.Cecil.ParameterDefinition() Implements IMethod.GetParameters
         Get
             Helper.Assert(m_Signature IsNot Nothing)
             Helper.Assert(m_Signature.Parameters IsNot Nothing)
             Return m_Signature.Parameters.AsParameterInfo
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3837" endline="3849">
<![CDATA[
 
     Private Sub numPick_Enter(ByVal sender As Object, _
     ByVal e As System.EventArgs) _
     Handles numHr.Enter, numMin.Enter, numSec.Enter, numPcs.Enter
 
         Dim Ctl As Control = DirectCast(sender, Control)
         If Ctl Is numPcs Then
             radPieces.Checked = True
         Else
             radTime.Checked = True
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" startline="73" endline="80">
<![CDATA[
 
     Public ReadOnly Property EventField() As Mono.Cecil.FieldDefinition
         Get
             Helper.Assert(m_Variable IsNot Nothing)
             Helper.Assert(m_Variable.IsFieldVariable)
             Helper.Assert(m_Variable.FieldBuilder IsNot Nothing)
             Return m_Variable.FieldBuilder
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="247" endline="267">
<![CDATA[
 
     ''' <summary>
     ''' A list of the types of the arguments.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetTypes() As Generic.List(Of Mono.Cecil.TypeReference)
         Dim result As New Generic.List(Of Mono.Cecil.TypeReference)
 
         Helper.Assert(Me.HasNamedArguments = False)
 
         For Each arg As PositionalArgument In m_Arguments
             If arg.Expression IsNot Nothing Then
                 result.Add(arg.Expression.ExpressionType)
             Else
                 Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmManual.vb" startline="525" endline="555">
<![CDATA[
 
     Private Sub Apply_Setting(ByVal Name As String, ByVal Cntrl As System.Windows.Forms.ComboBox)
 
         Try
             SrvcCntrl.ServiceName = (Name)
             Dim ChkSrvc As Boolean = SrvcCntrl.CanPauseAndContinue
         Catch ex As InvalidOperationException
             Exit Sub
         End Try
 
         If Cntrl.SelectedIndex = 0 Then
             Try
                 SrvcCntrl.StartupType = ("Automatic")
                 SrvcCntrl.Start()
                 SrvcCntrl.WaitForStatus(ServiceProcess.ServiceControllerStatus.Running, TimeSpan.FromSeconds(3))
             Catch ex As InvalidOperationException
             Catch ex As System.ServiceProcess.TimeoutException
             End Try
         ElseIf Cntrl.SelectedIndex = 1 Then
             SrvcCntrl.StartupType = ("Manual")
         ElseIf Cntrl.SelectedIndex = 2 Then
             Try
                 SrvcCntrl.StartupType = ("Disabled")
                 SrvcCntrl.Stop()
                 SrvcCntrl.WaitForStatus(ServiceProcess.ServiceControllerStatus.Stopped, TimeSpan.FromSeconds(3))
             Catch ex As InvalidOperationException
             Catch ex As System.ServiceProcess.TimeoutException
             End Try
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1514" endline="1535">
<![CDATA[
 
     ''' <summary>
     ''' Load a constant decimal value on to the evaluation stack.
     ''' </summary>
     ''' <param name="decimalValue"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadDecimalValue(ByVal Info As EmitInfo, ByVal decimalValue As DecimalFields)
         If decimalValue.Value = -1 Then
             Info.ILGen.Emit(OpCodes.Ldsfld, Helper.GetFieldOrFieldReference(Info.Compiler, Info.Compiler.TypeCache.System_Decimal__MinusOne))
         ElseIf decimalValue.Value = 0 Then
             Info.ILGen.Emit(OpCodes.Ldsfld, Helper.GetFieldOrFieldReference(Info.Compiler, Info.Compiler.TypeCache.System_Decimal__Zero))
         ElseIf decimalValue.Value = 1 Then
             Info.ILGen.Emit(OpCodes.Ldsfld, Helper.GetFieldOrFieldReference(Info.Compiler, Info.Compiler.TypeCache.System_Decimal__One))
          Else
             EmitLoadI4Value(Info, decimalValue.Lo)
             EmitLoadI4Value(Info, decimalValue.Mid)
             EmitLoadI4Value(Info, decimalValue.Hi)
             EmitLoadI4Value(Info, CInt(decimalValue.SignAsBit), Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Boolean))
             EmitLoadI4Value(Info, CInt(decimalValue.Scale), Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Byte))
             Emitter.EmitNew(Info, Helper.GetMethodOrMethodReference(Info.Compiler, Info.Compiler.TypeCache.System_Decimal__ctor_Int32_Int32_Int32_Boolean_Byte))
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="4410" endline="4453">
<![CDATA[
 
 #End Region
 
 #Region "   Audio files "
 
     Private Sub SwitchVisual(ByVal Blankout As Boolean)
 
         If Blankout Then
             mPlayer.Ctlcontrols.stop()
             Timer.Enabled = False
             lvPositions.Items.Clear()
             Me.Text = "Movica"
             mPlayer.Visible = False
             panAudio.Visible = False
             mSelsDirty = False
             Exit Sub
         End If
 
         If mIsAudio Then
             mPlayer.Visible = False
             panAudio.Visible = True
             mAudioWF = New WaveForm(mInFile, New WAVEFORMPROC(AddressOf MyWaveFormCallback), Me)
             mDisplayControl = panAudio
 
             With mAudioWF
                 .FrameResolution = 0.01F
                 .CallbackFrequency = 500
                 .ColorBackground = Color.White
                 .ColorLeft = Color.FromArgb(199, 241, 214)
                 .ColorRight = Color.FromArgb(255, 235, 205)
                 .ColorLeftEnvelope = Color.FromArgb(85, 211, 129)
                 .ColorRightEnvelope = Color.FromArgb(255, 160, 122)
                 .ColorRight = Color.BlanchedAlmond
 
                 mAudioMaxPos = Math.Min(.FramesToRender / 100, mAudioDet)
                 mAudioMinPos = 0
                 .RenderStart(True, BASSFlag.BASS_SAMPLE_FLOAT Or BASSFlag.BASS_STREAM_PRESCAN)
             End With
         Else
             mPlayer.Visible = True
             panAudio.Visible = False
             mDisplayControl = mPlayer
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1610" endline="1625">
<![CDATA[
 
     ''' <summary>
     ''' Calculates the actual parameter position of the parameter.
     ''' Ready to send to ILGenerator.Emit(...)
     ''' </summary>
     ''' <param name="Parameter"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function GetParameterPosition(ByVal Info As EmitInfo, ByVal Parameter As Mono.Cecil.ParameterDefinition) As Integer
         Dim position As Integer = Parameter.Index
         Dim member As IMethodSignature = Parameter.Method
         If member.HasThis Then
             position += 1
         End If
         Return position
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryNotExpression.vb" startline="30" endline="45">
<![CDATA[
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Dim result As Mono.Cecil.TypeReference
             Dim lType As Mono.Cecil.TypeReference
 
             lType = Me.Expression.ExpressionType
 
             If Helper.IsEnum(Compiler, lType) Then
                 result = lType
             Else
                 result = MyBase.ExpressionType()
             End If
 
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="383" endline="402">
<![CDATA[
 
     ''' <summary>
     ''' Returns all the modules within the specified namespace.
     ''' Never returns nothing and never throws an exception.
     ''' </summary>
     ''' <param name="Namespace"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetModulesByNamespace(ByVal [Namespace] As String) As TypeDictionary
         Dim result As TypeDictionary = Nothing
 
         If [Namespace] Is Nothing Then [Namespace] = ""
         If [Namespace].StartsWith("Global.") Then [Namespace] = [Namespace].Substring(7)
 
         If m_CecilModulesByNamespace.TryGetValue([Namespace], result) Then
             Return result
         Else
             Return Nothing
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="844" endline="857">
<![CDATA[
 
     Public Shared Function GetCustomAttributes(ByVal Attributes As Mono.Collections.Generic.Collection(Of CustomAttribute), ByVal AttributeType As Mono.Cecil.TypeReference) As Mono.Collections.Generic.Collection(Of CustomAttribute)
         Dim result As Mono.Collections.Generic.Collection(Of CustomAttribute) = Nothing
 
         For i As Integer = 0 To Attributes.Count - 1
             Dim attrib As CustomAttribute = Attributes(i)
             If Helper.CompareType(AttributeType, attrib.Constructor.DeclaringType) Then
                 If result Is Nothing Then result = New Mono.Collections.Generic.Collection(Of CustomAttribute)()
                 result.Add(attrib)
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="873" endline="884">
<![CDATA[
 
     Public Shared Function GetAttributes(ByVal CustomAttributes As Mono.Collections.Generic.Collection(Of CustomAttribute), ByVal Type As TypeReference) As Mono.Collections.Generic.Collection(Of CustomAttribute)
         Dim result As Mono.Collections.Generic.Collection(Of CustomAttribute) = Nothing
         For i As Integer = 0 To CustomAttributes.Count - 1
             Dim Attribute As CustomAttribute = CustomAttributes(i)
             If Helper.CompareType(Attribute.Constructor.DeclaringType, Type) Then
                 If result Is Nothing Then result = New Mono.Collections.Generic.Collection(Of CustomAttribute)()
                 result.Add(Attribute)
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="544" endline="565">
<![CDATA[
 
     ''' <summary>
     ''' Returns all the members in the types with the specified name.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function GetMembersOfTypes(ByVal Compiler As Compiler, ByVal Types As TypeList, ByVal Name As String) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim result As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference) = Nothing
 
         If Types Is Nothing Then Return Nothing
 
         For Each type As Mono.Cecil.TypeReference In Types
             Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
             members = Compiler.TypeManager.GetCache(type).LookupFlattenedMembers(Name)
             If members IsNot Nothing AndAlso members.Count > 0 Then
                 If result Is Nothing Then result = New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
                 result.AddRange(members)
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="147" endline="156">
<![CDATA[
 
     Public Overrides Function CreateDefinition() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.CreateDefinition AndAlso result
 
         MethodImplAttributes = Mono.Cecil.MethodImplAttributes.IL
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\InterfaceBases.vb" startline="44" endline="53">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_Bases IsNot Nothing)
         result = Helper.ResolveTypeReferencesCollection(m_Bases)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="385" endline="392">
<![CDATA[
 
     Public Overloads Function Equals(ByVal Special As KS) As Boolean
         If m_TokenType = TokenType.Keyword OrElse m_TokenType = TokenType.Symbol Then
             Return CInt(m_TokenObject) = CInt(Special)
         Else
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AliasClause.vb" startline="93" endline="104">
<![CDATA[
 
     Shared Function CanBeMe(ByVal tm As tm) As Boolean
         If tm.CurrentToken = KS.LParenthesis Then
             If tm.PeekToken.Equals(KS.Comma, KS.RParenthesis) Then
                 Return False
             Else
                 Return True
             End If
         Else
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="40" endline="49">
<![CDATA[
     End Property
 
     ReadOnly Property Expression() As Expression
         Get
             If m_Group Is Nothing Then
                 If Not CanBeExpression() Then Return Nothing
                 If m_Group Is Nothing Then Return Nothing
             End If
             Return m_Group.DefaultInstanceAlias
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\BoundList.vb" startline="144" endline="153">
<![CDATA[
 
     Shared Function GetDateConstant(ByVal Compiler As Compiler, ByVal Field As Mono.Cecil.FieldDefinition, ByRef value As Date) As Boolean
         Dim dtAttrs As Mono.Collections.Generic.Collection(Of CustomAttribute)
         dtAttrs = CecilHelper.GetCustomAttributes(Field.CustomAttributes, Compiler.TypeCache.System_Runtime_CompilerServices_DateTimeConstantAttribute)
         If dtAttrs IsNot Nothing AndAlso dtAttrs.Count = 1 Then
             value = DirectCast(dtAttrs(0).Properties(0).Argument.Value, Date)
             Return True
         End If
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="248" endline="291">
<![CDATA[
 
     ''' <summary>
     ''' Loads all the types (referenced and compiled) and all the namespaces as well.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function LoadReferenced() As Boolean
         Dim result As Boolean = True
 
         result = LoadReferencedAssemblies() AndAlso result
         If result = False Then Return result
 
         For Each ass As Mono.Cecil.AssemblyDefinition In CecilAssemblies
             If Helper.CompareNameOrdinal(ass.Name.Name, "Microsoft.VisualBasic") Then
                 Compiler.TypeCache.InitInternalVB()
                 Exit For
             End If
         Next
 
         result = LoadReferencedTypes() AndAlso result
 
 #If EXTENDEDDEBUG Then
         Compiler.Report.WriteLine(String.Format("{0} assemblies were loaded.", Assemblies.Count.ToString))
         If Compiler.CommandLine.Verbose Then
             For i As Integer = 0 To Assemblies.Count - 1
                 Compiler.Report.WriteLine("#" & (i + 1).ToString & "
             Next
         End If
         Compiler.Report.WriteLine(String.Format("{0} namespaces were loaded.", Namespaces.Count))
         If Compiler.CommandLine.Verbose Then
             Dim ns As String() = Namespaces.NamespacesAsString
             For i As Integer = 0 To ns.Length - 1
                 Compiler.Report.WriteLine("#" & (i + 1).ToString & "
             Next
         End If
         Compiler.Report.WriteLine(String.Format("{0} types were loaded.", Types.Count))
         If Compiler.CommandLine.Verbose Then
             For i As Integer = 0 To Types.Count - 1
                 'Compiler.Report.WriteLine("#" & (i + 1).ToString & "
             Next
         End If
 #End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeConverter.vb" startline="333" endline="369">
<![CDATA[
             "XXXXXXXXXXXXXXXXX-X" & _
             "X0X00000000000000-0" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XIXI1000000000001-0" & _
             "XIX1I222222221111-0" & _
             "XIX04I00000000001-0" & _
             "XIX040I0000000001-0" & _
             "XIX0400I000000001-0" & _
             "XIX04000I00000001-0" & _
             "XIX040000I0000001-0" & _
             "XIX0400000I000001-0" & _
             "XIX04000000I00001-0" & _
             "XIX040000000I0001-0" & _
             "XIX0100000000I001-0" & _
             "XIX01000000000I05-0" & _
             "XIX010000000000I1-0" & _
             "XIX1111111111161I-0" & _
             "-------------------" & _
             "XIX00000000000000-I"
 
     Shared Function GetErrorNumberForBinaryOperation(ByVal op As KS, ByVal left As TypeCode, ByVal right As TypeCode) As Integer
         If op = KS.ShiftLeft OrElse op = KS.ShiftRight Then
             If left = TypeCode.Object AndAlso (right = TypeCode.DateTime OrElse right = TypeCode.Char) Then Return 0
             If left <> TypeCode.DateTime AndAlso left <> TypeCode.Char Then
                 If right = TypeCode.DateTime Then Return 30311
                 If right = TypeCode.Char Then Return 32006
             End If
         ElseIf (op = KS.Add OrElse op = KS.Minus) AndAlso left = TypeCode.DateTime AndAlso right = TypeCode.DateTime Then
             Return 0
         End If
 
         Dim resultType As TypeCode
         resultType = TypeConverter.GetBinaryResultType(op, left, right)
 
         If resultType = TypeCode.Empty Then Return 30452
         Return 0
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\BoundList.vb" startline="53" endline="64">
<![CDATA[
 
     ''' <summary>
     ''' Checks for the following grammar
     ''' ConstantMemberDeclaration  
     ''' </summary>
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ConstantModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ConstantModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Const
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\FunctionDeclaration.vb" startline="45" endline="52">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverrideProcedureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverrideProcedureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Function
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\PropertyGetDeclaration.vb" startline="69" endline="76">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Get
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" startline="100" endline="107">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.AccessModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Set
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\AbstractMediaHandler.vb" startline="275" endline="283">
<![CDATA[
 
     Public Function StripExtension(ByVal Filename As String) As String
         Dim ExtStrt As Integer = InStrRev(Filename, ".")
         If InStr("wmv|asf|mpg|mpeg|wma|rm|flv|mp3|moviclip", Filename.Substring(ExtStrt), CompareMethod.Text) > 0 Then
             Return Filename.Substring(0, ExtStrt - 1)
         Else
             Return Filename
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ConversionOperatorDeclaration.vb" startline="79" endline="87">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ConversionOperatorModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ConversionOperatorModifiers)
             i += 1
         End While
         If tm.PeekToken(i).Equals(KS.Operator) = False Then Return False
         Return IsOverloadableConversionOperator(tm.PeekToken(i + 1))
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4454" endline="4464">
<![CDATA[
 
     Shared Function GetMethodAttributes(ByVal Member As Mono.Cecil.MemberReference) As Mono.Cecil.MethodAttributes
         Select Case CecilHelper.GetMemberType(Member)
             Case MemberTypes.Method, MemberTypes.Constructor
                 Return CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.MethodReference)).Attributes
             Case MemberTypes.Property
                 Return GetPropertyAttributes(DirectCast(Member, Mono.Cecil.PropertyReference))
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="1114" endline="1132">
<![CDATA[
 
     Public Shared Function IsClass(ByVal Type As TypeReference) As Boolean
         Dim tD As Mono.Cecil.TypeDefinition
         Dim tG As Mono.Cecil.GenericParameter
 
         If IsValueType(Type) Then Return False
         If TypeOf Type Is Mono.Cecil.ArrayType Then Return True
 
         tG = TryCast(Type, Mono.Cecil.GenericParameter)
         If tG IsNot Nothing Then
             If tG.HasReferenceTypeConstraint Then Return True
             If tG.HasNotNullableValueTypeConstraint Then Return False
             Return True
         End If
 
         tD = FindDefinition(Type)
 
         Return tD.IsClass
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ExternalFunctionDeclaration.vb" startline="43" endline="52">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ExternalMethodModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ExternalMethodModifiers)
             i += 1
         End While
         If tm.PeekToken(i) <> KS.Declare Then Return False
         If tm.PeekToken(i + 1).Equals(ModifierMasks.CharSetModifiers) Then i += 1
         Return tm.PeekToken(i + 1) = KS.Function
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\AbstractMediaHandler.vb" startline="174" endline="190">
<![CDATA[
 
     Public Function GetSplitName(ByVal Filename As String, _
     Optional ByVal Number As Integer = 0) As String
 
         Filename = Trim(Filename)
         If Len(Filename) = 0 Then Return Nothing
         Dim ExtStrt As Integer = InStrRev(Filename, ".")
         Dim Temp As String = Filename.Substring(0, ExtStrt - 1)
         If Number > 0 Then
             Temp += Trim(CStr(Number).PadLeft(4, "0"c))
         Else
             Temp += "_part"
         End If
 
         Return Temp & Filename.Substring(ExtStrt - 1)
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\ASFhandler.vb" startline="64" endline="80">
<![CDATA[
 
     Friend Overloads Overrides Sub ShowInfo(ByVal Filenames As String())
         'put filenames in a file
         Try
             Dim sw As New IO.StreamWriter("TempMovica.@@@")
             For i As Integer = 0 To UBound(Filenames)
                 sw.WriteLine(Filenames(i))
             Next
             sw.Close()
             Dim Temp As String = " -l TempMovica.@@@ -infokf"
             RunConverter(Temp)
             Kill("TempMovica.@@@")
         Catch ex As Exception
             MsgBox(ex.Message)
         End Try
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="880" endline="898">
<![CDATA[
 
     ''' <summary>
     ''' Finds a non-private, non-shared constructor with no parameters in the array.
     ''' If nothing found, returns nothing.
     ''' </summary>
     ''' <param name="Constructors"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function GetDefaultConstructor(ByVal Constructors As Mono.Collections.Generic.Collection(Of MethodDefinition)) As Mono.Cecil.MethodDefinition
         For i As Integer = 0 To Constructors.Count - 1
             If Not Constructors(i).IsConstructor Then Continue For
             If HasParameters(Constructors(i)) = False OrElse HasOnlyOptionalParameters(Constructors(i)) Then
                 If CecilHelper.IsStatic(Constructors(i)) = False AndAlso Helper.IsPrivate(Constructors(i)) = False Then
                     Return Constructors(i)
                 End If
             End If
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="443" endline="462">
<![CDATA[
 
     Private Shared Function ResolveMembers(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         For Each n As IBaseObject In Type.Members.GetSpecificMembers(Of IBaseObject)()
             Dim nType As TypeDeclaration = TryCast(n, TypeDeclaration)
             Dim nMember As INonTypeMember = TryCast(n, INonTypeMember)
 
             If nType IsNot Nothing Then
                 result = ResolveMembers(nType) AndAlso result
             ElseIf nMember IsNot Nothing Then
                 'Resolve all non-type members.
                 result = nMember.ResolveMember(ResolveInfo.Default(Type.Compiler)) AndAlso result
             Else
                 Helper.Stop() '?
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1383" endline="1404">
<![CDATA[
 
     Shared Function IsShared(ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Dim result As Boolean = True
         Select Case CecilHelper.GetMemberType(Member)
             Case MemberTypes.Method, MemberTypes.Constructor
                 Return CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.MethodReference)).IsStatic
             Case MemberTypes.Property
                 Dim pInfo As Mono.Cecil.PropertyDefinition = CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.PropertyReference))
                 Return CecilHelper.IsStatic(pInfo)
             Case MemberTypes.Field
                 Dim fInfo As Mono.Cecil.FieldDefinition = CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.FieldReference))
                 Return fInfo.IsStatic
             Case MemberTypes.TypeInfo
                 Return False
             Case MemberTypes.NestedType
                 Return False
             Case MemberTypes.Event
                 Return CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.EventReference)).AddMethod.IsStatic
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ConversionOperatorDeclaration.vb" startline="57" endline="66">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Operand.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\CaseClauses.vb" startline="61" endline="70">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Condition.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeParameters.vb" startline="51" endline="59">
<![CDATA[
 
     Public Overrides Function CreateDefinition() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.CreateDefinition AndAlso result
         result = m_TypeParameters.CreateDefinition() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\RMhandler.vb" startline="113" endline="125">
<![CDATA[
 
     Private Function GetFileJoinCommand() As String
 
         Dim Temp As String = String.Empty
 
         For i As Integer = 0 To UBound(mJoinFiles)
             Temp += " -i " + Chr(34) + mJoinFiles(i) + Chr(34)
         Next
 
         Temp += " -o " + Chr(34) + mOutFile + Chr(34)
         Return Temp
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="414" endline="446">
<![CDATA[
 
     Private Function ResolveDelegateInvocation(ByVal Context As ParsedObject, ByVal DelegateType As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean = True
         Dim invokeMethod As Mono.Cecil.MethodReference
         Dim params As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Dim argTypes As Generic.List(Of Mono.Cecil.TypeReference)
         Dim paramTypes() As Mono.Cecil.TypeReference
         Dim Compiler As Compiler = Context.Compiler
 
         invokeMethod = Helper.GetInvokeMethod(Compiler, DelegateType)
         params = Helper.GetParameters(Compiler, invokeMethod)
         paramTypes = Helper.GetTypes(params)
         argTypes = m_ArgumentList.GetTypes
 
         If argTypes.Count <> paramTypes.Length Then Return False
 
         For i As Integer = 0 To argTypes.Count - 1
             If Compiler.TypeResolution.IsImplicitlyConvertible(Context, argTypes(i), paramTypes(i)) = False Then
                 Helper.AddError(Me, "Cannot convert implicitly from '" & argTypes(i).Name & "' to '" & paramTypes(i).Name & "'")
                 Return False
             End If
         Next
 
         m_InvocationMethod = invokeMethod
 
         If invokeMethod.ReturnType IsNot Nothing Then
             Classification = New ValueClassification(Me, invokeMethod.ReturnType)
         Else
             Classification = New VoidClassification(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeCache.vb" startline="305" endline="311">
<![CDATA[
 
     Sub Init()
         InitOptimizations()
         InitAssemblies()
         InitInternal()
         InitVBNCTypes()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="133" endline="139">
<![CDATA[
 
     Overloads Sub Add(ByVal ns As [Namespace])
         If Not ContainsKey(ns.Name) Then
             MyBase.Add(ns)
             m_Hashed.Add(ns.Name, ns)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3408" endline="3416">
<![CDATA[
 
     Private Sub DisplayFineControls(ByVal Show As Boolean)
         Label9.Visible = Show
         FineResolution.Visible = Show
         cStrtFrFwd.Visible = Show
         cStrtFrRev.Visible = Show
         cEndFrFwd.Visible = Show
         cEndFrRev.Visible = Show
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="80" endline="87">
<![CDATA[
     End Property
 
     Public Overrides Function GetConstant(ByRef result As Object, ByVal lvalue As Object, ByVal rvalue As Object) As Boolean
         If TypeOf lvalue Is Boolean = False Then Return False
         If TypeOf rvalue Is Boolean = False Then Return False
         result = CBool(lvalue) AndAlso CBool(rvalue)
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2411" endline="2423">
<![CDATA[
 
     Shared Function IntToBin(ByVal Int As ULong) As String
         If Int = 0 Then Return "0"
         IntToBin = ""
         Do Until Int = 0
             If CBool(Int And 1UL) Then
                 IntToBin = "1" & IntToBin
             Else
                 IntToBin = "0" & IntToBin
             End If
             Int >>= 1
         Loop
         Do Until Int = 0
             If CBool(Int And 1UL) Then
                 IntToBin = "1" & IntToBin
             Else
                 IntToBin = "0" & IntToBin
             End If
             Int >>= 1
         Loop
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="523" endline="534">
<![CDATA[
 
     Public Shared Function GetCorrectMember(ByVal Member As MethodReference, ByVal Arguments As Mono.Collections.Generic.Collection(Of TypeReference), Optional ByVal Emittable As Boolean = False) As Mono.Cecil.MethodReference
         Dim mD As MethodDefinition = TryCast(Member, MethodDefinition)
 
         If mD IsNot Nothing Then Return GetCorrectMember(mD, Arguments, Emittable)
         If Member.OriginalMethod IsNot Nothing Then
             mD = TryCast(Member.OriginalMethod, MethodDefinition)
             If mD IsNot Nothing Then Return GetCorrectMember(mD, Arguments, Emittable)
         End If
 
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeArityList.vb" startline="55" endline="67">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_TypeParameters.Length - 1
             If m_TypeParameters(i) IsNot Nothing Then
                 result = m_TypeParameters(i).ResolveTypeReferences() AndAlso result
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="274" endline="287">
<![CDATA[
 
     Private Function CreateImplicitInstanceConstructors(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = Type.CreateImplicitInstanceConstructors() AndAlso result
 
         For i As Integer = 0 To Type.Members.Count - 1
             Dim t As TypeDeclaration = TryCast(Type.Members(i), TypeDeclaration)
             If t Is Nothing Then Continue For
             result = CreateImplicitInstanceConstructors(t) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="298" endline="311">
<![CDATA[
 
     Private Function CreateImplicitSharedConstructors(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         result = Type.CreateImplicitSharedConstructors() AndAlso result
 
         For i As Integer = 0 To Type.Members.Count - 1
             Dim t As TypeDeclaration = TryCast(Type.Members(i), TypeDeclaration)
             If t Is Nothing Then Continue For
             result = CreateImplicitSharedConstructors(t) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeConverter.vb" startline="782" endline="791">
<![CDATA[
 
     Private Shared Function GetResultType(ByVal op1 As TypeCode, ByVal array As String) As TypeCode
         Dim chr As Char
         chr = array.Chars(op1)
         If chr = "X"c Then
             Return Nothing
         Else
             Return GetTypeCodeOfChar(chr)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="6118" endline="6127">
<![CDATA[
 
     Private Function ParseImportsStatements(ByVal Parent As ParsedObject) As Generic.List(Of ImportsStatement)
         Dim result As New Generic.List(Of ImportsStatement)
         While ImportsStatement.IsMe(tm)
             Dim newI As ImportsStatement
             newI = ParseImportsStatement(Parent)
             result.Add(newI)
         End While
         While ImportsStatement.IsMe(tm)
             Dim newI As ImportsStatement
             newI = ParseImportsStatement(Parent)
             result.Add(newI)
         End While
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="6149" endline="6165">
<![CDATA[
 
     ''' <summary>
     ''' Parses a imports statement as specified on the commandline.
     ''' </summary>
     ''' <param name="str"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Shared Function ParseImportsStatement(ByVal Parent As ImportsStatement, ByVal str As String) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Parent IsNot Nothing)
         Helper.Assert(Parent.Clauses IsNot Nothing)
 
         result = ParseImportsClauses(Parent.Clauses, str) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="1243" endline="1250">
<![CDATA[
 
     Public Shared Function FindDefinition(ByVal field As FieldReference) As FieldDefinition
         If field Is Nothing Then Return Nothing
         Dim fD As FieldDefinition = TryCast(field, FieldDefinition)
         If fD IsNot Nothing Then Return fD
         Dim type As TypeDefinition = FindDefinition(field.DeclaringType)
         Return GetField(type.Fields, field)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="77" endline="116">
<![CDATA[
     End Property
 
     Public Overrides Function GetConstant(ByRef m_ConstantValue As Object, ByVal lvalue As Object, ByVal rvalue As Object) As Boolean
         Dim shifts As Integer 'This needs to be an integer.
         Dim tmpShifts As Object = Nothing
 
         If Compiler.TypeResolution.CheckNumericRange(rvalue, tmpShifts, Compiler.TypeCache.System_Int32) = False Then
             Return False
         Else
             shifts = CInt(tmpShifts)
         End If
 
         Dim tlvalue As Mono.Cecil.TypeReference
         Dim clvalue As TypeCode
         tlvalue = CecilHelper.GetType(Compiler, lvalue)
         clvalue = Helper.GetTypeCode(Compiler, tlvalue)
 
         Select Case clvalue
             Case TypeCode.Byte
                 m_ConstantValue = CByte(lvalue) << shifts
             Case TypeCode.SByte
                 m_ConstantValue = CSByte(lvalue) << shifts
             Case TypeCode.Int16
                 m_ConstantValue = CShort(lvalue) << shifts
             Case TypeCode.UInt16
                 m_ConstantValue = CUShort(lvalue) << shifts
             Case TypeCode.Int32
                 m_ConstantValue = CInt(lvalue) << shifts
             Case TypeCode.UInt32
                 m_ConstantValue = CUInt(lvalue) << shifts
             Case TypeCode.Int64
                 m_ConstantValue = CLng(lvalue) << shifts
             Case TypeCode.UInt64
                 m_ConstantValue = CULng(lvalue) << shifts
             Case Else
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="137" endline="157">
<![CDATA[
 
 
     Public Shared Function GetCorrectMember(ByVal Member As TypeReference, ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Dim tD As Mono.Cecil.TypeDefinition = TryCast(Member, Mono.Cecil.TypeDefinition)
 
         If tD IsNot Nothing Then Return GetCorrectMember(tD, Type)
 
         Dim tG As Mono.Cecil.GenericInstanceType = TryCast(Member, Mono.Cecil.GenericInstanceType)
         If tG IsNot Nothing Then
             tD = TryCast(tG.ElementType, Mono.Cecil.TypeDefinition)
             If tD IsNot Nothing Then
                 Helper.Assert(tG.GenericParameters.Count = 0)
                 Return GetCorrectMember(tD, Type)
             End If
         End If
 
         tD = FindDefinition(Member)
         Return GetCorrectMember(tD, Type)
 
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4814" endline="4829">
<![CDATA[
 
     Shared Function GetCoClassType(ByVal Compiler As Compiler, ByVal Type As TypeReference) As TypeReference
         Dim td As TypeDefinition = CecilHelper.FindDefinition(Type)
         Dim result As TypeReference = Nothing
 
         For i As Integer = 0 To td.CustomAttributes.Count - 1
             Dim attrib As CustomAttribute = td.CustomAttributes(i)
             If Helper.CompareType(attrib.AttributeType, Compiler.TypeCache.System_Runtime_InteropServices_CoClassAttribute) = False Then Continue For
             If attrib.Constructor Is Nothing Then Continue For
             If attrib.ConstructorArguments.Count <> 1 Then Continue For
             result = TryCast(attrib.ConstructorArguments(0).Value, TypeReference)
             If result IsNot Nothing Then Exit For
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="4331" endline="4337">
<![CDATA[
 
     Private Sub ToolURL_LinkClicked(ByVal sender As System.Object, _
     ByVal e As System.Windows.Forms.LinkLabelLinkClickedEventArgs) Handles linkToolURL.LinkClicked
         If lbStdTools.SelectedItem Is Nothing Then Exit Sub
         Dim Tool As ToolSpec = DirectCast(lbStdTools.SelectedItem, ToolSpec)
         System.Diagnostics.Process.Start(Tool.URL)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ReturnStatement.vb" startline="24" endline="32">
<![CDATA[
         Get
             If TypeOf Me.Parent Is CodeBlock Then
                 Return DirectCast(Me.Parent, CodeBlock).IsOneLiner
             ElseIf TypeOf Me.Parent Is Statement Then
                 Return DirectCast(Me.Parent, Statement).IsOneLiner
             Else
                 Throw New InternalException(Me)
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3722" endline="3740">
<![CDATA[
 
     Private Function CheckForSkipFile(ByVal Type As String) As Boolean
 
         Dim SkipFilename As String
         Select Case Type
             Case "Comskip"
                 SkipFilename = StripExtention(mInFile) & ".txt"
             Case "SmartSkip"
                 SkipFilename = mInFile & ".chapters.xml"
         End Select
 
         Try
             Dim fi As New FileInfo(SkipFilename)
             Return fi.Exists
         Catch ex As Exception
             'do nothing
         End Try
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="53" endline="66">
<![CDATA[
 
     ''' <summary>
     ''' Returns the default constructor (non-private, non-shared, with no parameters) for the base type (if any).         
     ''' If no constructor found, returns nothing.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetBaseDefaultConstructor() As Mono.Cecil.MethodReference
         If CecilHelper.IsGenericType(Me.BaseType) Then
             Return Helper.GetDefaultGenericConstructor(Me.BaseType)
         Else
             Return Helper.GetDefaultConstructor(Me.BaseType)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="67" endline="80">
<![CDATA[
 
     ''' <summary>
     ''' Returns the default constructor (non-private, non-shared, with no parameters) for the base type (if any).          
     ''' If no constructor found, returns nothing.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetBaseDefaultConstructorCecil() As Mono.Cecil.MethodReference
         If CecilHelper.IsGenericType(Me.BaseType) Then
             Return Helper.GetDefaultGenericConstructor(Me.BaseType)
         Else
             Return Helper.GetDefaultConstructor(Me.BaseType)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1951" endline="1967">
<![CDATA[
 
     ''' <summary>
     ''' Returns true if CallerType is a nested class of CalledType.
     ''' Returns false if both types are equal.
     ''' </summary>
     ''' <param name="CalledType"></param>
     ''' <param name="CallerType"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function IsNested(ByVal CalledType As Mono.Cecil.TypeReference, ByVal CallerType As Mono.Cecil.TypeReference) As Boolean
         Dim tmp As Mono.Cecil.TypeReference = CecilHelper.FindDefinition(CallerType).DeclaringType
         Do Until tmp Is Nothing
             If CompareType(CalledType, tmp) Then Return True
             tmp = CecilHelper.FindDefinition(tmp).DeclaringType
         Loop
         Do Until tmp Is Nothing
             If CompareType(CalledType, tmp) Then Return True
             tmp = CecilHelper.FindDefinition(tmp).DeclaringType
         Loop
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="393" endline="403">
<![CDATA[
 
     Shared Function IsKeyword(ByVal str As Char(), ByVal length As Integer, ByRef Keyword As KS) As Boolean
         Dim special As KS
         special = Enums.GetKS(str, length)
         If special <> KS.None Then
             Keyword = special
             Return True
         Else
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="49" endline="58">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_LeftExpression.ResolveTypeReferences AndAlso result
         result = m_RightExpression.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="36" endline="43">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveTypeReferences AndAlso result
         result = m_Type.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\AssignStatements\AddAssignStatement.vb" startline="32" endline="39">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_LSide.ResolveTypeReferences AndAlso result
         result = m_RSide.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1341" endline="1354">
<![CDATA[
 
     Shared Function GetDefaultMemberAttribute(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.CustomAttribute
         Dim attribs As Mono.Collections.Generic.Collection(Of CustomAttribute)
         Dim attrib As Mono.Cecil.CustomAttribute = Nothing
         Dim tD As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(Type)
 
         attribs = CecilHelper.GetCustomAttributes(tD, Compiler.TypeCache.System_Reflection_DefaultMemberAttribute)
 
         If attribs IsNot Nothing AndAlso attribs.Count = 1 Then
             attrib = attribs(0)
         End If
 
         Return attrib
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="82" endline="98">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Creates a string array with all the namespaces.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property NamespacesAsString() As String()
         Get
             Dim result(Count - 1) As String
             Dim tmp() As [Namespace] = Me.ToArray
             For i As Integer = 0 To Count - 1
                 result(i) = tmp(i).Name
             Next
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\CaseClauses.vb" startline="52" endline="62">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_Clauses IsNot Nothing Then result = m_Clauses.ResolveTypeReferences AndAlso result
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="574" endline="593">
<![CDATA[
 
     Private Function DefineSecurityDeclarations(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To Type.Members.Count - 1
             Dim nestedType As TypeDeclaration = TryCast(Type.Members(i), TypeDeclaration)
             If nestedType IsNot Nothing Then
                 result = DefineSecurityDeclarations(nestedType) AndAlso result
                 Continue For
             End If
 
             Dim method As MethodBaseDeclaration = TryCast(Type.Members(i), MethodBaseDeclaration)
             If method IsNot Nothing Then
                 result = method.DefineSecurityDeclarations AndAlso result
                 Continue For
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="61" endline="68">
<![CDATA[
 
     Function DefineOptionalParameters() As Boolean
         Dim result As Boolean = True
 
         result = m_Signature.Parameters.DefineOptionalParameters AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\SubDeclaration.vb" startline="127" endline="135">
<![CDATA[
     End Property
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverrideProcedureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverrideProcedureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i) = KS.Sub AndAlso tm.PeekToken(i + 1).IsIdentifier
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="110" endline="118">
<![CDATA[
 
     Private Sub FrmMain_Resize(ByVal sender As Object, ByVal e As System.EventArgs) Handles Me.Resize
 
         Dim Child As Form
         For Each Child In Me.MdiChildren
             Child.Size = New Size((Me.Size.Width - 291), (Me.Size.Height - 94))
         Next
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AttributeArguments.vb" startline="36" endline="44">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For Each attrib As Attribute In m_List
             result = attrib.ResolveCode(info) AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2428" endline="2457">
<![CDATA[
 
     'TODO
     Shared Function OctToInt(ByVal str As String) As ULong
         Dim i, n As Integer
         Dim l As Integer = str.Length
         OctToInt = 0
         For i = l To 1 Step -1
             Select Case str.Chars(i - 1)
                 Case "0"c
                     n = 0
                 Case "1"c
                     n = 1
                 Case "2"c
                     n = 2
                 Case "3"c
                     n = 3
                 Case "4"c
                     n = 4
                 Case "5"c
                     n = 5
                 Case "6"c
                     n = 6
                 Case "7"c
                     n = 7
                 Case Else
                     Throw New ArgumentOutOfRangeException("str", str, "Invalid octal number
             End Select
             OctToInt += CULng(n * (8 ^ (l - i)))
         Next
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="488" endline="508">
<![CDATA[
     End Property
 
     ReadOnly Property HasSharedFieldsWithInitializers() As Boolean
         Get
             For i As Integer = 0 To Me.Members.Count - 1
                 Dim item As VariableDeclaration = TryCast(Me.Members(i), VariableDeclaration)
                 If item IsNot Nothing AndAlso item.IsShared AndAlso item.HasInitializer Then Return True
 
                 Dim cd As ConstantDeclaration = TryCast(Me.Members(i), ConstantDeclaration)
                 If cd IsNot Nothing AndAlso cd.RequiresSharedInitialization Then Return True
             Next
 
             If m_StaticVariables IsNot Nothing Then
                 For i As Integer = 0 To m_StaticVariables.Count - 1
                     Dim item As VariableDeclaration = m_StaticVariables(i)
                     If item.DeclaringMethod.IsShared AndAlso item.HasInitializer Then Return True
                 Next
             End If
 
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3004" endline="3011">
<![CDATA[
 
     Public Function ParseExpression(ByVal Parent As ParsedObject) As Expression
         Dim result As Expression = Nothing
 
         result = ParseOr_OrElse_Xor(New ExpressionParseInfo(Parent))
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\ASFhandler.vb" startline="102" endline="117">
<![CDATA[
 
     Private Function GetFileJoinCommand() As String
 
         Dim Temp As String
 
         For i As Integer = 0 To UBound(mJoinFiles)
             Temp += " -i " + Chr(34) + mJoinFiles(i) + Chr(34)
         Next
 
         Temp += " -o " + Chr(34) + mOutFile + Chr(34) + " -cvb -y -details"
         If Options("ForceJoin") = "True" Then
             Temp += " -breakvideo"
         End If
         Return Temp
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="496" endline="521">
<![CDATA[
 
     Private Function DefineConstants(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To Type.Members.Count - 1
             Dim nestedType As TypeDeclaration = TryCast(Type.Members(i), TypeDeclaration)
             If nestedType IsNot Nothing Then
                 result = DefineConstants(nestedType) AndAlso result
                 Continue For
             End If
 
             Dim constant As ConstantDeclaration = TryCast(Type.Members(i), ConstantDeclaration)
             If constant IsNot Nothing Then
                 result = constant.DefineConstant AndAlso result
                 Continue For
             End If
 
             Dim enumc As EnumMemberDeclaration = TryCast(Type.Members(i), EnumMemberDeclaration)
             If enumc IsNot Nothing Then
                 result = enumc.DefineConstant AndAlso result
                 Continue For
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmAuto.vb" startline="21" endline="34">
<![CDATA[
     End Property
 
     Private Sub FrmAuto_Load(ByVal sender As Object, ByVal e As System.EventArgs) Handles Me.Load
 
         On Error Resume Next
         HdrMain.Values.Image = New Bitmap(DataDir & "auto_tuneup.png")
 
         Dim ShieldPic As New Bitmap(DataDir & "shield.png")
         LnkProfile.Values.Image = ShieldPic
         LnkManTuneUp.Values.Image = ShieldPic
         LnkExport.Values.Image = ShieldPic
         LnkRescueCntr.Values.Image = ShieldPic
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\MainForm.cs" startline="605" endline="632">
<![CDATA[
 
 		#region Plugin Context Menu Handlers
 
 		private void configurePluginMenuItem_Click(object sender, EventArgs e)
 		{
 			foreach(ListViewItem lvi in pluginListView.SelectedItems)
 			{
 				string pluginName = lvi.Text;
 				Plugin selectedPlugin = null;
 				foreach(Plugin plugin in pluginManager.Plugins)
 				{
 					if(plugin.Name == pluginName)
 					{
 						selectedPlugin = plugin;
 						break;
 					}
 				}
 				foreach(Plugin plugin in pluginManager.Plugins)
 				{
 					if(plugin.Name == pluginName)
 					{
 						selectedPlugin = plugin;
 						break;
 					}
 				}
 
 				if(selectedPlugin.Configurator != null)
 				{
 					selectedPlugin.Configurator.Show();
 				}
 				else
 				{
 					MessageBox.Show(String.Format(@"{0} does not have a configurator.", selectedPlugin.Name));
 				}
 			}
 			foreach(ListViewItem lvi in pluginListView.SelectedItems)
 			{
 				string pluginName = lvi.Text;
 				Plugin selectedPlugin = null;
 				foreach(Plugin plugin in pluginManager.Plugins)
 				{
 					if(plugin.Name == pluginName)
 					{
 						selectedPlugin = plugin;
 						break;
 					}
 				}
 
 				if(selectedPlugin.Configurator != null)
 				{
 					selectedPlugin.Configurator.Show();
 				}
 				else
 				{
 					MessageBox.Show(String.Format(@"{0} does not have a configurator.", selectedPlugin.Name));
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AliasClause.vb" startline="56" endline="87">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         
         If m_VariableInitializerList IsNot Nothing Then
             Dim expInfo As ExpressionResolveInfo = TryCast(Info, ExpressionResolveInfo)
             Dim elementInfo As ResolveInfo
             If expInfo IsNot Nothing Then
                 Helper.Assert(CecilHelper.GetElementType(expInfo.LHSType) IsNot Nothing)
                 Helper.Assert(CecilHelper.IsArray(expInfo.LHSType))
                 If expInfo.LHSType IsNot Nothing AndAlso CecilHelper.GetArrayRank(expInfo.LHSType) > 1 Then
                     Dim newArrayRank As Integer = CecilHelper.GetArrayRank(expInfo.LHSType) - 1
                     Dim elementType As Mono.Cecil.TypeReference = CecilHelper.MakeArrayType(CecilHelper.GetElementType(expInfo.LHSType), newArrayRank)
                     elementInfo = New ExpressionResolveInfo(Compiler, elementType)
                 Else
                     elementInfo = New ExpressionResolveInfo(Compiler, CecilHelper.GetElementType(expInfo.LHSType))
                 End If
             Else
                 Helper.StopIfDebugging(True)
                 elementInfo = Info
             End If
 
                 Helper.Assert(expInfo Is Nothing OrElse DirectCast(elementInfo, ExpressionResolveInfo).LHSType IsNot Nothing)
 
                 result = m_VariableInitializerList.ResolveCode(elementInfo) AndAlso result
             End If
         result = SetElements() AndAlso result
 
         Compiler.Helper.AddCheck("Array element initializers must all have the same number of elements / ranks.")
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="4147" endline="4161">
<![CDATA[
 
 #End Region
 
 #Region "   Tabs - Advanced "
 
 #End Region
 
 #Region "   Languages "
 
     Private Sub cbLang_SelectedIndexChanged(ByVal sender As Object, ByVal e As System.EventArgs) Handles cbLang.SelectedIndexChanged
 
         mTranslator.Language = cbLang.SelectedItem.ToString
         ChangeLanguage()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\IniFile.vb" startline="70" endline="76">
<![CDATA[
 
     Public Sub WriteInteger(ByVal Section As String, _
       ByVal Key As String, ByVal Value As Integer)
         ' Writes an integer to your INI file
         WriteString(Section, Key, CStr(Value))
         Flush()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="825" endline="834">
<![CDATA[
 
     ''' <summary>
     ''' Loads Me onto the evaluation stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadMe(ByVal Info As EmitInfo, ByVal TypeOfMe As Mono.Cecil.TypeReference)
         TypeOfMe = Helper.GetTypeOrTypeBuilder(Info.Compiler, TypeOfMe)
         Info.ILGen.Emit(OpCodes.Ldarg_0)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="4306" endline="4317">
<![CDATA[
 
 #End Region
 
 #Region "   Tool Manager "
 
     Private Sub RenderStdToolList()
 
         lbStdTools.BeginUpdate()
         lbStdTools.DataSource = mStdToolMgr.ToolList
         lbStdTools.EndUpdate()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\StdToolMgr.vb" startline="297" endline="306">
<![CDATA[
         Set(ByVal Value As Boolean)
             If mPlayer Is Nothing Then Exit Property
             If Value Then
                 cMute.ImageIndex = 10
             Else
                 cMute.ImageIndex = 0
             End If
             cMute.Pushed = Value
             mPlayer.settings.mute = Value
         End Set
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\StdToolMgr.vb" startline="313" endline="330">
<![CDATA[
         Set(ByVal value As MPCDisplayMode)
             mDisplayMode = value
             'Make changes to the display mode
             Select Case mDisplayMode
                 Case MPCDisplayMode.Normal
                     cBegin.Visible = True
                     cEnd.Visible = True
                     VolBar.Left = 233
                 Case MPCDisplayMode.Compact
                     cBegin.Visible = False
                     cEnd.Visible = False
                     VolBar.Left = 182
                 Case MPCDisplayMode.Full
                     cBegin.Visible = True
                     cEnd.Visible = True
                     VolBar.Left = 233
             End Select
         End Set
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="71" endline="98">
<![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Dim result As Mono.Cecil.TypeReference
             Select Case Classification.Classification
                 Case ExpressionClassification.Classifications.Value
                     result = Classification.AsValueClassification.Type
                 Case ExpressionClassification.Classifications.Variable
                     result = Classification.AsVariableClassification.Type
                 Case ExpressionClassification.Classifications.Type
                     Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
                     result = Nothing
                 Case ExpressionClassification.Classifications.Namespace
                     Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
                     result = Nothing
                 Case ExpressionClassification.Classifications.PropertyGroup
                     result = Classification.AsPropertyGroup.Type
                 Case ExpressionClassification.Classifications.PropertyAccess
                     result = Classification.AsPropertyAccess.Type
                 Case ExpressionClassification.Classifications.MethodGroup
                     result = Classification.AsMethodGroupClassification.Type
                 Case Else
                     Throw New InternalException(Me)
             End Select
             Helper.Assert(result IsNot Nothing)
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3977" endline="4002">
<![CDATA[
 
     Private Sub tbTrace_ButtonClick(ByVal sender As System.Object, _
 ByVal e As System.Windows.Forms.ToolBarButtonClickEventArgs) Handles tbTrace.ButtonClick
 
         Select Case DirectCast(e.Button.Tag, String)
             Case "Clear"
                 rtfTrace.Clear()
                 rtfTrace.SelectionColor = Color.Black
             Case "Save"
                 'Save the contents to a file
                 dlgSaveFile.InitialDirectory = dlgOpenFile.InitialDirectory
                 dlgSaveFile.DefaultExt = ".rtf"
                 dlgSaveFile.FileName = "TraceOut.rtf"
                 dlgSaveFile.Filter = "Trace Output |*.rtf"
 
                 If dlgSaveFile.ShowDialog() = Windows.Forms.DialogResult.OK Then
                     Me.Refresh()
                     Try
                         rtfTrace.SaveFile(dlgSaveFile.FileName)
                     Catch ex As Exception
                         MsgBox(ex.Message, , "Error in saving")
                     End Try
                 End If
         End Select
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\dshowUtil.vb" startline="13" endline="47">
<![CDATA[
 
     'Required by the Windows Form Designer
     Private components As System.ComponentModel.IContainer
 
     'NOTE
     'It can be modified using the Windows Form Designer.  
     'Do not modify it using the code editor.
     <System.Diagnostics.DebuggerStepThrough()> _
     Private Sub InitializeComponent()
         Me.tList = New System.Windows.Forms.TextBox
         Me.SuspendLayout()
         '
         'tList
         '
         Me.tList.BackColor = System.Drawing.SystemColors.ControlLightLight
         Me.tList.Location = New System.Drawing.Point(12, 12)
         Me.tList.Multiline = True
         Me.tList.Name = "tList"
         Me.tList.ReadOnly = True
         Me.tList.ScrollBars = System.Windows.Forms.ScrollBars.Both
         Me.tList.Size = New System.Drawing.Size(331, 247)
         Me.tList.TabIndex = 0
         '
         'frmList
         '
         Me.AutoScaleDimensions = New System.Drawing.SizeF(6.0!, 13.0!)
         Me.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font
         Me.ClientSize = New System.Drawing.Size(355, 274)
         Me.Controls.Add(Me.tList)
         Me.Name = "frmList"
         Me.Text = "Installed filters"
         Me.ResumeLayout(False)
         Me.PerformLayout()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\StdToolMgr.vb" startline="603" endline="628">
<![CDATA[
 
 #End Region
 
 #Region "   Utility functions "
 
     Public Sub SetToolbarMode(ByVal Status As Boolean)
         cPlay.Enabled = Status
         cStop.Enabled = Status
         cBegin.Enabled = False
         cEnd.Enabled = False
         cSelStrt.Enabled = Status
         cSelEnd.Enabled = Status
         cMute.Enabled = Status
         lplayPos.Enabled = Status
         If Status Then
             Try
                 cFFwd.Enabled = mPlayer.settings.isAvailable("rate")
                 cFRev.Enabled = mPlayer.settings.isAvailable("rate")
             Catch ex As Exception
                 MsgBox(ex.Message)
             End Try
         Else
             cFFwd.Enabled = False
             cFRev.Enabled = False
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmManual.vb" startline="26" endline="35">
<![CDATA[
 
     Private Sub ChkDelSnapshots_CheckedChanged(ByVal sender As Object, ByVal e As System.EventArgs) Handles ChkDelSnapshots.CheckedChanged
         If ChkDelSnapshots.Checked = True Then
             CboTime.SelectedIndex = 0
             CboTime.Enabled = True
         ElseIf ChkDelSnapshots.Checked = False Then
             CboTime.SelectedIndex = -1
             CboTime.Enabled = False
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmManual.vb" startline="36" endline="45">
<![CDATA[
 
     Private Sub ChkQueryNet_CheckedChanged(ByVal sender As Object, ByVal e As System.EventArgs) Handles ChkQueryNet.CheckedChanged
         If ChkQueryNet.Checked = True Then
             CboQueryNet.SelectedIndex = 0
             CboQueryNet.Enabled = True
         ElseIf ChkQueryNet.Checked = False Then
             CboQueryNet.SelectedIndex = -1
             CboQueryNet.Enabled = False
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="101" endline="109">
<![CDATA[
 
     Private Sub FrmMain_Shown(ByVal sender As Object, ByVal e As System.EventArgs) Handles Me.Shown
 
         Call Check_Status()
         Tip = CByte(RNumber(9))
         Call SetTip()
         BWCPUUsg.RunWorkerAsync()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2134" endline="2141">
<![CDATA[
     End Property
 
     Sub New(ByVal Compiler As Compiler)
         m_Compiler = Compiler
         If m_SharedCompilers.Contains(Compiler) = False Then
             m_SharedCompilers.Add(Compiler)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmDiagnostics.vb" startline="94" endline="107">
<![CDATA[
 
 #End Region
 
 #Region "Tasks"
 
     Private Sub BtnProfile_Click(ByVal sender As Object, ByVal e As System.EventArgs) Handles BtnProfile.Click
 
         If FrmUsrProfile.ShowDialog(Me) = Windows.Forms.DialogResult.OK Then
             If BtnExport.Enabled = ComponentFactory.Krypton.Toolkit.ButtonEnabled.True Then
                 BtnDiagnose.PerformClick()
             End If
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\TypeVariableDeclaration.vb" startline="144" endline="151">
<![CDATA[
 
     Protected Overrides Sub EmitStore(ByVal Info As EmitInfo)
         If FieldBuilder IsNot Nothing Then
             Emitter.EmitStoreField(Info, FieldBuilder)
         Else
             Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\Nameables.vb" startline="58" endline="73">
<![CDATA[
 
     ''' <summary>
     ''' Adds a new object to this collection.
     ''' </summary>
     ''' <param name="Base"></param>
     ''' <remarks></remarks>
     Shadows Sub Add(ByVal Base As T)
         'This is a workaround for #463303
         Dim B As INameable = DirectCast(Base, INameable)
 
 #If DEBUG Then
         If B.Name = "" Then Throw New InternalException(Base)
 #End If
         MyBase.Add(Base)
         m_Index.Add(Base)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3313" endline="3327">
<![CDATA[
 
     Private Sub SegMenu_Popup(ByVal sender As Object, ByVal e As System.EventArgs) Handles SegMenu.Popup
         If mItems(0) Is Nothing Then
             MenuItem11.Enabled = False
         Else
             MenuItem11.Enabled = True
         End If
         If lvPositions.SelectedItems.Count = 0 Then
             MenuItem9.Enabled = False
             MenuItem10.Enabled = False
         Else
             MenuItem9.Enabled = True
             MenuItem10.Enabled = True
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2820" endline="2851">
<![CDATA[
 
 #End Region
 
 #Region "   Tabs - General "
 
     Private Sub mainTabs_SelectedIndexChanged(ByVal sender As Object, _
     ByVal e As System.EventArgs) Handles mainTabs.SelectedIndexChanged
 
         Select Case mainTabs.SelectedIndex
             Case 0
                 panSegments.Width = 140
                 If Safe2ShowTuner() Then DisplayFineControls(True)
             Case 1
                 panSegments.Width = 0
                 DisplayFineControls(False)
             Case 2
                 mPlayer.Ctlcontrols.pause()
                 panSegments.Width = 0
                 DisplayFineControls(False)
             Case 3
                 panSegments.Width = 0
                 lvFiles.Columns(0).Width = lvFiles.Width
                 DisplayFineControls(False)
             Case 4
                 panSegments.Width = 0
                 DisplayFineControls(False)
             Case 5
                 panSegments.Width = 0
                 DisplayFineControls(False)
                 RenderStdToolList()
         End Select
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmDiagnostics.vb" startline="20" endline="31">
<![CDATA[
     Private Sub FrmDiagnostics_Load(ByVal sender As Object, ByVal e As System.EventArgs) Handles Me.Load
 
         On Error Resume Next
         HdrMain.Values.Image = New Bitmap(DataDir & "services_diagnostics.png")
         BtnProfile.Image = New Bitmap(DataDir & "usr_profile.png")
         BtnExport.Image = New Bitmap(DataDir & "export.png")
         BtnExport.Enabled = ComponentFactory.Krypton.Toolkit.ButtonEnabled.False
         BtnFix.Enabled = False
         TabMain.SelectedIndex = 0
         LstServices.Visible = False
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1007" endline="1047">
<![CDATA[
 
 
     ''' <summary>
     ''' Type = the type of the element. (not of the array.)
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ElementType"></param>
     ''' <remarks></remarks>
     Shared Sub EmitStoreElement(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference, ByVal ArrayType As Mono.Cecil.TypeReference)
         ArrayType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ArrayType)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         Select Case Helper.GetTypeCode(Info.Compiler, ElementType)
             Case TypeCode.Int32, TypeCode.UInt32
                 Info.ILGen.Emit(OpCodes.Stelem_I4)
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Boolean
                 Info.ILGen.Emit(OpCodes.Stelem_I1)
             Case TypeCode.Int16, TypeCode.UInt16, TypeCode.Char
                 Info.ILGen.Emit(OpCodes.Stelem_I2)
             Case TypeCode.Int64, TypeCode.UInt64
                 Info.ILGen.Emit(OpCodes.Stelem_I8)
             Case TypeCode.Single
                 Info.ILGen.Emit(OpCodes.Stelem_R4)
             Case TypeCode.Double
                 Info.ILGen.Emit(OpCodes.Stelem_R8)
             Case TypeCode.DateTime, TypeCode.Decimal
                 EmitStoreObject(Info, ElementType)
                 Return
             Case TypeCode.String
                 Info.ILGen.Emit(OpCodes.Stelem_Ref)
             Case TypeCode.Object
                 If CecilHelper.IsValueType(ElementType) Then
                     Info.ILGen.Emit(OpCodes.Stobj, ElementType)
                 ElseIf CecilHelper.IsGenericParameter(ElementType) Then
                     Info.ILGen.Emit(OpCodes.Stelem_Any, ElementType)
                 Else
                     Info.ILGen.Emit(OpCodes.Stelem_Ref)
                 End If
             Case Else
                 Helper.Stop()
         End Select
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\IniFile.vb" startline="77" endline="83">
<![CDATA[
 
     Public Sub WriteBoolean(ByVal Section As String, _
       ByVal Key As String, ByVal Value As Boolean)
         ' Writes a boolean to your INI file
         WriteString(Section, Key, CStr(CInt(Value)))
         Flush()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\BaseObject.vb" startline="155" endline="164">
<![CDATA[
 
     Function FindFirstParent(Of T)() As T
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T Then
             Return CType(CObj(Parent), T)
         Else
             Return Parent.FindFirstParent(Of T)()
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="471" endline="477">
<![CDATA[
 
     Function IsNumericType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         For Each t As Mono.Cecil.TypeReference In NumericTypes
             If Helper.CompareType(t, Type) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="478" endline="484">
<![CDATA[
 
     Function IsIntegralType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         For Each t As Mono.Cecil.TypeReference In IntegralTypes
             If Helper.CompareType(t, Type) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="4355" endline="4363">
<![CDATA[
 
     Private Sub SaveToolMgr()
         If lbStdTools.SelectedItem Is Nothing Then Exit Sub
         Dim Tool As ToolSpec = DirectCast(lbStdTools.SelectedItem, ToolSpec)
         Dim i As Integer = mStdToolMgr.ToolList.IndexOf(Tool)
         Tool.Enabled = chkEnabled.Checked
         Tool.Path.Value = Trim(tStdToolPath.Text)
         mStdToolMgr.Save()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="4011" endline="4061">
<![CDATA[
 
     Private Sub SaveMask(Optional ByVal Current As Boolean = False)
 
         If lvPositions.Items.Count = 0 Then Exit Sub
         If Not FinishTheList() Then Exit Sub
 
         'determine name for mask
         Dim MaskFilename As String
         Dim Mask As New MediaMask, fi As New IO.FileInfo(mInFile)
         If Current Then
             MaskFilename = mMaskFilename
         Else
             dlgSaveFile.Filter = "Movica MoviClips|*.MoviClip"
             dlgSaveFile.InitialDirectory = fi.DirectoryName
             dlgSaveFile.DefaultExt = ".MoviClip"
             dlgSaveFile.FileName = ""
             If dlgSaveFile.ShowDialog() = Windows.Forms.DialogResult.OK Then
                 MaskFilename = dlgSaveFile.FileName
                 Me.Refresh()
             Else
                 Exit Sub
             End If
         End If
 
         Mask.FileName = mInFile
         Mask.RepeatPlay = mRepeatPlay
 
         'load the segments array
         Dim TempSegments As Segment()
         TempSegments = GetSegmentArray(AbstractMediaHandler.Mode.SaveSelected)
         For i As Integer = 0 To UBound(TempSegments)
             Mask.Segments.Add(TempSegments(i))
         Next
 
         'save
         Dim fs As IO.FileStream, writer As XmlTextWriter
         Try
             fs = New IO.FileStream(MaskFilename, IO.FileMode.Create)
             Dim x As New XmlSerializer(GetType(MediaMask))
             writer = New XmlTextWriter(fs, System.Text.Encoding.UTF8)
             writer.Formatting = Formatting.Indented
 
             ' perform the XML serialization
             x.Serialize(writer, Mask)
             UpdateTitle(fi.Name, mHandler.StripPath(mHandler.StripExtension(MaskFilename)))
             mSelsDirty = False
         Finally
             ' close the writer, which closes the underlying FileStream
             writer.Close()
         End Try
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="447" endline="481">
<![CDATA[
 
     Function RuleAnd_AndAlso(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleNot(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.And, KS.AndAlso)
             Dim DoAlso As Boolean
             DoAlso = CurrentToken.Equals(KS.AndAlso)
             NextToken()
             RuleNot(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             ElseIf DoAlso Then
                 LSide = op1 AndAlso op2 'Since its a constant expression, there's no difference between And & AndAlso
             Else
                 LSide = op1 And op2
             End If
         End While
         While CurrentToken.Equals(KS.And, KS.AndAlso)
             Dim DoAlso As Boolean
             DoAlso = CurrentToken.Equals(KS.AndAlso)
             NextToken()
             RuleNot(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             ElseIf DoAlso Then
                 LSide = op1 AndAlso op2 'Since its a constant expression, there's no difference between And & AndAlso
             Else
                 LSide = op1 And op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="482" endline="516">
<![CDATA[
 
     Function RuleOr_OrElse(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleAnd_AndAlso(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Or, KS.OrElse)
             Dim DoElse As Boolean
             DoElse = CurrentToken.Equals(KS.OrElse)
             NextToken()
             RuleAnd_AndAlso(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             ElseIf DoElse Then
                 LSide = op1 OrElse op2 'Since its a constant expression, there's no difference between Or & OrElse
             Else
                 LSide = op1 Or op2
             End If
         End While
         While CurrentToken.Equals(KS.Or, KS.OrElse)
             Dim DoElse As Boolean
             DoElse = CurrentToken.Equals(KS.OrElse)
             NextToken()
             RuleAnd_AndAlso(RSide)
 
             Dim op1 As Boolean, op2 As Boolean
             Dim bErr As Boolean
             If ToBoolean(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
             If ToBoolean(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Boolean.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = False
             ElseIf DoElse Then
                 LSide = op1 OrElse op2 'Since its a constant expression, there's no difference between Or & OrElse
             Else
                 LSide = op1 Or op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CDateExpression.vb" startline="86" endline="118">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Info.Compiler.TypeCache.System_Double.Name, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Double
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30533, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Boolean, TypeCode.Byte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.SByte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Decimal, TypeCode.Single
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3627" endline="3653">
<![CDATA[
 
     Private Sub EndSelection()
 
         Dim CurrPos As Double
         CurrPos = Math.Round(mPlayer.Ctlcontrols.currentPosition, 3)
 
         'Debug.Write(CurrPos)
         'Debug.WriteLine(Timer.Enabled)
 
         Dim Last As Integer = lvPositions.Items.Count - 1
         If Last < 0 Then Exit Sub
 
         With lvPositions.Items(Last)
             If CurrPos - mReactTime <= MinToSec(.Text) Then Exit Sub
             If .SubItems.Count = 1 Then
                 'Add End
                 .SubItems.Add(SecToMin(CurrPos - mReactTime))
             Else
                 'Change End
                 .SubItems(1).Text = SecToMin(CurrPos - mReactTime)
             End If
         End With
 
         UpdateSelDur()
         mSelsDirty = True
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="737" endline="786">
<![CDATA[
 
     Private Function CheckOutermostNamespace(ByVal R As String) As Boolean
 
         '---------------------------------------------------------------------------------------------------------
         '* For each nested namespace, starting from the innermost and going to the outermost namespace, 
         '  do the following
         '** If the namespace contains an accessible namespace member with the given name, then the identifier
         '   refers to that member and, depending on the member, is classified as a namespace or a type.
         '** Otherwise, if the namespace contains one or more accessible standard modules, and a member name 
         '   lookup of the identifier produces an accessible match in exactly one standard module, then the 
         '   result is exactly the same as a member access of the form M.E, where M is the standard module 
         '   containing the matching member and E is the identifier. If the identifier matches accessible type 
         '   members in more than one standard module, a compile-time error occurs.
         '**	If R matches the name of an accessible type or nested namespace in the current namespace, then the
         '** unqualified name refers to that type or nested namespace.
         '---------------------------------------------------------------------------------------------------------
         Dim foundNamespace As [Namespace] = Nothing
         Dim foundType As Mono.Cecil.TypeReference
 
         foundType = Compiler.TypeManager.TypesByNamespace("").Item(R)
         If foundType Is Nothing AndAlso Compiler.Assembly.Name <> "" Then
             foundType = Compiler.TypeManager.TypesByNamespace(Compiler.Assembly.Name).Item(R)
         End If
 
         foundNamespace = Compiler.TypeManager.Namespaces(R)
         If foundNamespace IsNot Nothing AndAlso foundType Is Nothing Then
             Classification = New NamespaceClassification(Me, foundNamespace)
             Return True
         ElseIf foundNamespace Is Nothing AndAlso foundType IsNot Nothing Then
             Classification = New TypeClassification(Me, foundType)
             Return True
         ElseIf foundNamespace IsNot Nothing AndAlso foundType IsNot Nothing Then
             Return Helper.AddError(Me)
         End If
 
         If foundNamespace Is Nothing Then Return False
 
         Dim modules As TypeDictionary
         Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         modules = Compiler.TypeManager.GetModulesByNamespace(foundNamespace.ToString)
         members = Helper.GetMembersOfTypes(Compiler, modules, R)
         If members.Count = 1 Then
             Helper.Assert(Helper.IsTypeDeclaration(members(0)))
             Classification = New TypeClassification(Me, members(0))
         ElseIf members.Count > 1 Then
             Return Helper.AddError(Me)
         End If
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3424" endline="3464">
<![CDATA[
 
     Private Function ParseIfExpression(ByVal Parent As ParsedObject) As IfExpression
         Dim result As New IfExpression(Parent)
         Dim expressions As ExpressionList
 
         tm.AcceptIfNotInternalError(KS.If)
 
         If Not tm.Accept(KS.LParenthesis) Then
             Compiler.Report.ShowMessage(Messages.VBNC30199, tm.CurrentLocation)
             tm.GotoNewline(False)
             Return result
         End If
 
         If tm.Accept(KS.RParenthesis) Then
             Compiler.Report.ShowMessage(Messages.VBNC33104, tm.CurrentLocation)
             tm.GotoNewline(False)
             Return result
         End If
 
         expressions = ParseExpressionList(result)
 
         If expressions.Count < 2 OrElse expressions.Count > 3 Then
             Compiler.Report.ShowMessage(Messages.VBNC33104, tm.CurrentLocation)
             tm.GotoNewline(False)
             Return result
         End If
 
         If Not tm.Accept(KS.RParenthesis) Then
             Compiler.Report.ShowMessage(Messages.VBNC30198, tm.CurrentLocation)
             tm.GotoNewline(False)
             Return result
         End If
 
         result.Condition = expressions(0)
         result.SecondPart = expressions(1)
         If expressions.Count = 3 Then
             result.ThirdPart = expressions(2)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="377" endline="387">
<![CDATA[
 
     Public Sub EmitCall(ByVal opcode As Mono.Cecil.Cil.OpCode, ByVal methodInfo As Mono.Cecil.MethodReference, ByVal optionalParameterTypes() As Mono.Cecil.TypeReference)
         'Helper.Assert(Helper.IsEmittableMember(Compiler, methodInfo))
         Log("EmitCall({0},{1},{2})", opcode.ToString, ToString(methodInfo), ToString(optionalParameterTypes))
         'Helper.Assert(Helper.IsEmittableMember(Compiler, methodInfo.ReturnType.ReturnType))
         If optionalParameterTypes Is Nothing Then
             CilWorker.Emit(opcode, methodInfo)
         Else
             Throw New NotImplementedException("CilWorker.Append(CilWorker.Create(opcode, methodInfo, optionalParameterTypes))")
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="111" endline="129">
<![CDATA[
     End Property
 
     Sub FindStaticVariables(ByVal list As Generic.List(Of LocalVariableDeclaration))
         If m_StaticVariables IsNot Nothing Then
             list.AddRange(m_StaticVariables)
             Return
         End If
 
         For Each var As LocalVariableDeclaration In m_Variables
             If var.Modifiers.Is(ModifierMasks.Static) Then
                 list.Add(var)
             End If
         Next
         For Each stmt As BlockStatement In BlockStatements
             stmt.CodeBlock.FindStaticVariables(list)
         Next
 
         m_StaticVariables = list
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmManual.vb" startline="677" endline="698">
<![CDATA[
 
     Private Sub Service_Info(ByVal Name As String)
 
         Try
             SrvcCntrl.ServiceName = (Name)
             Dim ChkSrvc As Boolean = SrvcCntrl.CanPauseAndContinue
             Dim Path As String = CStr(My.Computer.Registry.GetValue(("HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\" & Name), "ImagePath", ""))
 
             If SrvcCntrl.Status = ServiceProcess.ServiceControllerStatus.Running OrElse SrvcCntrl.Status = ServiceProcess.ServiceControllerStatus.StartPending Then
                 PicStatus.ImageLocation = (DataDir & "start.png")
             ElseIf SrvcCntrl.Status = ServiceProcess.ServiceControllerStatus.Stopped OrElse SrvcCntrl.Status = ServiceProcess.ServiceControllerStatus.StopPending Then
                 PicStatus.ImageLocation = (DataDir & "stop.png")
             End If
 
             TxtInfo.Text = ("Service name
 
         Catch ex As InvalidOperationException
             PicStatus.ImageLocation = (DataDir & "error.png")
             TxtInfo.Text = ("Service name
         End Try
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2711" endline="2769">
<![CDATA[
 
     Private Sub mPlayer_KeyUpEvent(ByVal sender As System.Object, _
     ByVal e As AxWMPLib._WMPOCXEvents_KeyUpEvent) Handles mPlayer.KeyUpEvent
 
         If Not mFileLoaded Then Exit Sub
 
         Select Case e.nKeyCode
 
             Case 36     'Keys.Home
                 'Start selection
                 StartSelection()
 
             Case 35     'Keys.End - end Selection
                 'End Selection
                 EndSelection()
 
             Case 46     'Keys.Delete
                 If e.nShiftState = 2 Then           'Control Delete
                     If lvPositions.Items.Count = 0 Then Exit Sub
                     lvPositions.Items.RemoveAt(lvPositions.Items.Count - 1)
                 End If
 
             Case 32     'Keys.Space
                 If mPlayer.playState <> 2 Then
                     mPlayer.Ctlcontrols.pause()
                 Else
                     mPlayer.Ctlcontrols.play()
                 End If
 
             Case 37         'Left Arrow
                 If e.nShiftState = 2 Then           'Control Left Arrow
                     mPlayer.Ctlcontrols.currentPosition -= 2
                 End If
 
             Case 39         'Right Arrow
                 If e.nShiftState = 2 Then           'Control Right Arrow
                     mPlayer.Ctlcontrols.currentPosition += 2
                 End If
 
             Case 38         'Up Arrow
                 If e.nShiftState = 2 Then
                     'Control+Up = Increase speed
                     ToggleFastForward()
                 Else
                     'Change volume
                     If mPlayer.playState = WMPLib.WMPPlayState.wmppsPlaying Then MPcontrols.IncreaseVolume()
                 End If
 
             Case 40         'Down Arrow
                 If e.nShiftState = 2 Then
                     'Control+Down = Decrease speed
                     ToggleFastReverse()
                 Else
                     'Change volume
                     If mPlayer.playState = WMPLib.WMPPlayState.wmppsPlaying Then MPcontrols.DecreaseVolume()
                 End If
 
         End Select
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="106" endline="140">
<![CDATA[
 
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
         
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         If Conversion.GetConstant(Nothing, False) Then Return result
 
         Select Case expTypeCode
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, Info.Compiler.TypeCache.System_Boolean))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
             Case TypeCode.Boolean
                 'Implicitly convertible
             Case Else
                 If Conversion.IsExplicit = False AndAlso Conversion.Location.File(Conversion.Compiler).IsOptionStrictOn Then
                     result = Conversion.Compiler.Report.ShowMessage(Messages.VBNC30512, Conversion.Location, Helper.ToString(Conversion, expType), Helper.ToString(Conversion, ExpressionType)) AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1756" endline="1766">
<![CDATA[
 
     Shared Function IsAccessibleExternal(ByVal Compiler As Compiler, ByVal Member As Mono.Cecil.MemberReference) As Boolean
         If Compiler.Assembly.IsDefinedHere(Member) Then Return True
 
         If IsPublic(Member) Then Return True
         If IsProtectedFriend(Member) Then Return True
         If IsPrivate(Member) Then Return False
         If IsFriend(Member) Then Return False
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="3851" endline="3871">
<![CDATA[
 
     Shared Function Compare(ByVal g1 As Mono.Cecil.IGenericParameterProvider, ByVal g2 As Mono.Cecil.IGenericParameterProvider) As Boolean
         Helper.Assert(g1 IsNot Nothing AndAlso g2 IsNot Nothing)
         Dim m1 As Mono.Cecil.MethodReference = TryCast(g1, Mono.Cecil.MethodReference)
         Dim m2 As Mono.Cecil.MethodReference = TryCast(g2, Mono.Cecil.MethodReference)
 
         If m1 IsNot Nothing AndAlso m2 IsNot Nothing Then
             Return m1 Is m2
         ElseIf m1 IsNot Nothing Xor m2 IsNot Nothing Then
             Return False
         End If
 
         Dim t1 As Mono.Cecil.TypeReference = TryCast(g1, Mono.Cecil.TypeReference)
         Dim t2 As Mono.Cecil.TypeReference = TryCast(g2, Mono.Cecil.TypeReference)
 
         If t1 IsNot Nothing AndAlso t2 IsNot Nothing Then
             Return Helper.CompareType(t1, t2)
         End If
 
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\dshowUtil.vb" startline="121" endline="135">
<![CDATA[
 
     Private Function GetKeyframe(ByVal Value As Double) As String
 
         Dim Index As Integer = Array.BinarySearch(mKeyFrames, Value)
         If Index > 0 Then
             Return CStr(CInt(Value * 1000))
         Else
             Index = Index Xor -1
             If Index >= mKeyFrames.Length - 1 Then      'Value not found in array
                 Return CStr(CInt(mKeyFrames(mKeyFrames.Length - 1) * 1000))
             Else                                        'Pick the prior frame
                 Return CStr(CInt(mKeyFrames(Math.Max(Index - 1, 0)) * 1000))
             End If
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1999" endline="2028">
<![CDATA[
 
     ''' <summary>
     ''' Finds the member with the exact same signature.
     ''' </summary>
     ''' <param name="grp"></param>
     ''' <param name="params"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function ResolveGroupExact(ByVal Context As BaseObject, ByVal grp As Generic.List(Of Mono.Cecil.MemberReference), ByVal params() As Mono.Cecil.TypeReference) As Mono.Cecil.MemberReference
         Dim Compiler As Compiler = Context.Compiler
 
         For i As Integer = 0 To grp.Count - 1
             Dim member As Mono.Cecil.MemberReference = grp(i)
             Dim paramtypes As Mono.Cecil.TypeReference() = Helper.GetParameterTypes(Context, member)
             If Helper.CompareTypes(paramtypes, params) Then Return member
 
             If paramtypes.Length <> params.Length Then Continue For
 
             Dim found As Boolean = True
             For j As Integer = 0 To paramtypes.Length - 1
                 If Helper.IsSubclassOf(paramtypes(j), params(j)) = False Then
                     found = False
                     Exit For
                 End If
             Next
             If found Then Return member
         Next
 
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\CaseClauses.vb" startline="43" endline="80">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim nextIteration As Nullable(Of Label)
         Select Case m_ContinueWhat
             Case KS.While
                 Dim whilestmt As WhileStatement = TryCast(m_ContainingStatement, WhileStatement)
                 If whilestmt IsNot Nothing Then
                     nextIteration = whilestmt.nextiteration
                 Else
                     Throw New InternalException(Me)
                 End If
             Case KS.Do
                 Dim dostmt As DoStatement = TryCast(m_ContainingStatement, DoStatement)
                 If dostmt IsNot Nothing Then
                     nextIteration = dostmt.nextiteration
                 Else
                     Throw New InternalException(Me)
                 End If
             Case KS.For
                 Dim forstmt As ForStatement = TryCast(m_ContainingStatement, ForStatement)
                 Dim foreachstmt As ForEachStatement = TryCast(m_ContainingStatement, ForEachStatement)
                 If forstmt IsNot Nothing Then
                     nextIteration = forstmt.NextIteration
                 ElseIf foreachstmt IsNot Nothing Then
                     nextIteration = foreachstmt.nextiteration
                 Else
                     Throw New InternalException(Me)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Helper.Assert(nextIteration.HasValue)
         Emitter.EmitBranchOrLeave(Info, nextIteration.Value, Me, m_ContainingStatement)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1899" endline="1950">
<![CDATA[
 
 
     Shared Function IsAccessible(ByVal Context As BaseObject, ByVal CalledMethodAccessability As Mono.Cecil.MethodAttributes, ByVal CalledType As Mono.Cecil.TypeReference, ByVal CallerType As Mono.Cecil.TypeReference) As Boolean
         'If both types are equal everything is accessible.
         If CompareType(CalledType, CallerType) Then Return True
 
         'If the callertype is a nested class of the called type, then everything is accessible as well.
         If IsNested(CalledType, CallerType) Then Return True
 
         'If the called type is not accessible from the caller, the member cannot be accessible either.
         If IsAccessible(Context.Compiler, CalledType, CallerType) = False Then Return False
 
         Dim ac As Mono.Cecil.MethodAttributes = (CalledMethodAccessability And Mono.Cecil.MethodAttributes.MemberAccessMask)
         Dim isPrivate As Boolean = ac = Mono.Cecil.MethodAttributes.Private
         Dim isFriend As Boolean = ac = Mono.Cecil.MethodAttributes.Assembly OrElse ac = Mono.Cecil.MethodAttributes.FamORAssem
         Dim isProtected As Boolean = ac = Mono.Cecil.MethodAttributes.Family OrElse ac = Mono.Cecil.MethodAttributes.FamORAssem
         Dim isPublic As Boolean = ac = Mono.Cecil.MethodAttributes.Public
 
         'Public members are always accessible!
         If isPublic Then Return True
 
         'If the member is private, the member is not accessible
         '(to be accessible the types must be equal or the caller type must
         'be a nested type of the called type, cases already covered).
         'Catch
         If isPrivate Then Return Helper.IsEnum(Context.Compiler, CalledType)
 
         If isFriend AndAlso isProtected Then
             'Friend and Protected
             'Both types must be in the same assembly or CallerType must inherit from CalledType.
             Return Context.Compiler.Assembly.IsDefinedHere(CalledType) OrElse (Helper.IsSubclassOf(CalledType, CallerType))
         ElseIf isFriend Then
             'Friend, but not Protected
             'Both types must be in the same assembly
             Return Context.Compiler.Assembly.IsDefinedHere(CalledType)
         ElseIf isProtected Then
             'Protected, but not Friend
             'CallerType must inherit from CalledType.
             Return Helper.IsSubclassOf(CalledType, CallerType)
         End If
 
         Context.Compiler.Report.ShowMessage(Messages.VBNC99997, Context.Location) '("No accessibility??")
 
         'private 	    = 1	= 0001
         'famandassembly = 2 = 0010
         'Assembly       = 3 = 0011
         'family         = 4 = 0100
         'famorassembly  = 5 = 0101
         'public 	    = 6	= 0110
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MemberCache.vb" startline="288" endline="318">
<![CDATA[
 
     Private Shared Sub AddToFlattenedCache(ByVal FlattenedCache As MemberCacheEntries, ByVal Name As String, ByVal MemberCache As MemberCache, ByVal Cache As MemberCacheEntries, ByVal Visibility As MemberVisibility)
         Dim cache_entry As MemberCacheEntry = Nothing
         If Name Is Nothing Then
             For Each obj As KeyValuePair(Of String, MemberCacheEntry) In Cache
                 If Not FlattenedCache.TryGetValue(obj.Key, cache_entry) Then
                     cache_entry = New MemberCacheEntry(obj.Value.Name)
                     FlattenedCache.Add(cache_entry)
                 End If
                 For i As Integer = 0 To obj.Value.Members.Count - 1
                     Dim m As MemberReference = obj.Value.Members(i)
                     If cache_entry.Members.Contains(m) = False Then
                         cache_entry.Members.Add(m)
                     End If
                 Next
             Next
         Else
             Dim value As MemberCacheEntry = Nothing
             If Not Cache.TryGetValue(Name, value) Then Return
             If Not FlattenedCache.TryGetValue(Name, cache_entry) Then
                 cache_entry = New MemberCacheEntry(Name)
                 FlattenedCache.Add(cache_entry)
             End If
             For i As Integer = 0 To value.Members.Count - 1
                 Dim m As MemberReference = value.Members(i)
                 If cache_entry.Members.Contains(m) = False Then
                     cache_entry.Members.Add(m)
                 End If
             Next
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmProfiles.vb" startline="132" endline="142">
<![CDATA[
 
     Private Sub LstProfiles_SelectedIndexChanged(ByVal sender As Object, ByVal e As System.EventArgs) Handles LstProfiles.SelectedIndexChanged
 
         Dim I, Indx As Integer
         For I = 0 To LstProfiles.SelectedItems.Count - 1
             Indx = LstProfiles.SelectedItems(I).Index
             SelectedProfile = (ProfilesDir & LstProfiles.Items.Item(Indx).Text & ".wsp")
             Exit Sub
         Next
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="138" endline="154">
<![CDATA[
 
 #End Region
 
 #Region "Links"
 
     Private Sub LnkHome_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles LnkHome.Click
 
         If PnlHome.Visible = False Then
             Call Check_Status()
             PnlHome.Visible = True
             Dim Child As Form
             For Each Child In Me.MdiChildren
                 Child.Dispose()
             Next
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="314" endline="335">
<![CDATA[
 
     ''' <summary>
     ''' Loads a pointer to the specified method onto the stack.
     ''' Loads either a Lftfn or Ldvirtftn, according to the static 
     ''' state of the method.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Method"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadVftn(ByVal Info As EmitInfo, ByVal Method As Mono.Cecil.MethodReference)
         Dim methodinf As Mono.Cecil.MethodReference = Method '= TryCast(Method, Mono.Cecil.MethodReference)
         If methodinf IsNot Nothing Then
             methodinf = Helper.GetMethodOrMethodReference(Info.Compiler, methodinf)
             If CecilHelper.FindDefinition(methodinf).IsStatic Then
                 Info.ILGen.Emit(OpCodes.Ldftn, methodinf)
             Else
                 Info.ILGen.Emit(OpCodes.Ldvirtftn, methodinf)
             End If
         Else
             Helper.Stop()
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\BaseObject.vb" startline="115" endline="132">
<![CDATA[
     End Property
 
     Overridable ReadOnly Property FullName() As String Implements IBaseObject.FullName
         Get
             Dim nameable As INameable = TryCast(Me, INameable)
             Helper.Assert(nameable IsNot Nothing)
             Dim nstpparent As IBaseObject = Me.FindFirstParent(Of IType)()
             If TypeOf Me Is TypeParameter Then Return Nothing
             If nstpparent IsNot Nothing Then
                 If TypeOf nstpparent Is IType Then
                     Return nstpparent.FullName & "+" & nameable.Name
                 Else
                     Return nstpparent.FullName & "." & nameable.Name
                 End If
             Else
                 Return nameable.Name
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ExternalSubDeclaration.vb" startline="84" endline="94">
<![CDATA[
     End Property
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ExternalMethodModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ExternalMethodModifiers)
             i += 1
         End While
         If tm.PeekToken(i) <> KS.Declare Then Return False
         If tm.PeekToken(i + 1).Equals(ModifierMasks.CharSetModifiers) Then i += 1
         Return tm.PeekToken(i + 1) = KS.Sub AndAlso tm.PeekToken(i + 2).IsIdentifier
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2801" endline="2814">
<![CDATA[
 
     Private Sub Player_MediaError(ByVal sender As System.Object, _
     ByVal e As AxWMPLib._WMPOCXEvents_MediaErrorEvent) Handles mPlayer.MediaError
         Dim errSource As WMPLib.IWMPMedia2 = DirectCast(e.pMediaObject, WMPLib.IWMPMedia2)
         Dim errorItem As WMPLib.IWMPErrorItem = errSource.Error
         Dim errorDesc As String = errorItem.errorDescription
         Dim errorStr As String = "Error " + errorItem.errorCode.ToString("X") + _
             " in " + errSource.sourceURL + vbCrLf + errorDesc
         MessageBox.Show(errorStr, "Player Error")
         lvPositions.Items.Clear()
         statSel.Text = ""
         statDur.Text = ""
         Waiting(False)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\CaseRangeExpression.vb" startline="49" endline="75">
<![CDATA[
 
     Overloads Function [GetType](ByVal ThrowIfNoType As Boolean) As Mono.Cecil.TypeReference
         Select Case m_Classification
             Case Classifications.Value
                 Return AsValueClassification.Type
             Case Classifications.Variable
                 Return AsVariableClassification.Type
             Case Classifications.MethodGroup
                 Return AsMethodGroupClassification.Type
             Case Classifications.MethodPointer
                 Return AsMethodPointerClassification.Type
             Case Classifications.PropertyAccess
                 Return AsPropertyAccess.Type
             Case Classifications.PropertyGroup
                 Return AsPropertyGroup.Type
             Case Classifications.Void
                 Return Compiler.TypeCache.System_Void
             Case Classifications.LateBoundAccess
                 Return AsLateBoundAccess.Type
             Case Else
                 If ThrowIfNoType Then
                     Throw New InternalException("No type was found")
                 Else
                     Return Nothing
                 End If
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="464" endline="490">
<![CDATA[
 
     Function MakeGenericType(ByVal Parent As ParsedObject, ByVal OpenType As Mono.Cecil.TypeReference, ByVal GenericArguments As Mono.Collections.Generic.Collection(Of TypeReference)) As Mono.Cecil.TypeReference
         Dim result As Mono.Cecil.GenericInstanceType
 
         result = New Mono.Cecil.GenericInstanceType(Helper.GetTypeOrTypeReference(Parent.Compiler, OpenType))
 
         For i As Integer = 0 To GenericArguments.Count - 1
             result.GenericArguments.Add(Helper.GetTypeOrTypeReference(Parent.Compiler, GenericArguments(i)))
         Next
 
         'Needs to add this to a cache, otherwise two otherwise equal types might be created with two different 
         'type instances, which is not good as any type comparison would fail.
         Dim key As String = result.FullName
         Helper.Assert(key IsNot Nothing AndAlso key <> "")
         If m_GenericTypeCache.ContainsKey(key) Then
             'Revert to the cached type if it has already been created.
             result = m_GenericTypeCache(key)
         Else
             Dim addToCache As Boolean = True
             For Each item As Mono.Cecil.TypeReference In GenericArguments
                 If CecilHelper.IsGenericParameter(item) Then addToCache = False 
             Next
             If addToCache Then m_GenericTypeCache.Add(key, result)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="319" endline="362">
<![CDATA[
     End Property
 
     Shared Function ResolveInterfaceGroup(ByVal grp As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference), ByVal codedMember As IMember) As Mono.Cecil.MemberReference
         Helper.Assert(codedMember IsNot Nothing)
 
         Dim methodtypes() As Mono.Cecil.TypeReference
         Dim grptypes() As Mono.Cecil.TypeReference
         Dim result As Mono.Cecil.MemberReference = Nothing
 
         Select Case CecilHelper.GetMemberType(codedMember.MemberDescriptor)
             Case MemberTypes.Method
                 Dim method As IMethod = TryCast(codedMember, IMethod)
                 methodtypes = method.Signature.Parameters.ToTypeArray
             Case MemberTypes.Property
                 Dim prop As PropertyDeclaration = TryCast(codedMember, PropertyDeclaration)
                 methodtypes = prop.Signature.Parameters.ToTypeArray
             Case MemberTypes.Event
                 methodtypes = New Mono.Cecil.TypeReference() {}
             Case Else
                 methodtypes = Nothing
                 codedMember.Compiler.Report.ShowMessage(Messages.VBNC99997, codedMember.Location)
         End Select
 
         For Each member As Mono.Cecil.MemberReference In grp
             Select Case CecilHelper.GetMemberType(member)
                 Case MemberTypes.Method
                     grptypes = Helper.GetParameterTypes(codedMember.Parent, member)
                 Case MemberTypes.Property
                     grptypes = Helper.GetParameterTypes(Helper.GetParameters(codedMember.Compiler, DirectCast(member, Mono.Cecil.PropertyReference)))
                 Case MemberTypes.Event
                     grptypes = New Mono.Cecil.TypeReference() {}
                 Case Else
                     Throw New InternalException(codedMember)
             End Select
             If Helper.CompareTypes(methodtypes, grptypes) Then
                 Helper.Assert(result Is Nothing)
                 result = member
 #If Not DEBUG Then
                 Exit For
 #End If
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmGameMode.vb" startline="20" endline="38">
<![CDATA[
     End Property
 
     Private Sub FrmGameMode_Load(ByVal sender As Object, ByVal e As System.EventArgs) Handles Me.Load
 
         On Error Resume Next
 
         HdrMain.Values.Image = New Bitmap(DataDir & "game_mode.png")
 
         Dim ShieldPic As New Bitmap(DataDir & "shield.png")
         LnkVisEffects.Values.Image = ShieldPic
         LnkTaskMngr.Values.Image = ShieldPic
         LnkGameCntrl.Values.Image = ShieldPic
         LnkPowerOpt.Values.Image = ShieldPic
         LnkDisplaySet.Values.Image = ShieldPic
         LnkDirectX.Values.Image = ShieldPic
         LnkMemory.Values.Image = ShieldPic
         LnkPerfMon.Values.Image = ShieldPic
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MemberCache.vb" startline="138" endline="178">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Formats the message to a string.
     ''' The returned string might have several lines.
     ''' </summary>
     Overrides Function ToString() As String
         Dim strMessages(), strMessage, strLocation As String
         Dim result As String
 
         Helper.Assert(m_Message IsNot Nothing, "m_Message Is Nothing")
         Helper.Assert(m_Parameters IsNot Nothing, "m_Parameters Is Nothing")
 
         'Get the message string and format it with the message parameters.
         ReDim strMessages(m_Message.GetUpperBound(0))
         For i As Integer = 0 To m_Message.GetUpperBound(0)
             strMessages(i) = Report.LookupErrorCode(m_Message(i))
             Helper.Assert(m_Parameters(i) IsNot Nothing, "m_Parameters(" & i.ToString & ") Is Nothing")
 			If m_Parameters IsNot Nothing AndAlso m_Parameters.Length > i Then
             	strMessages(i) = String.Format(strMessages(i), m_Parameters(i))
 			End If
             If i = 0 Then strMessages(i) = m_Message(i).ToString & "
         Next
         strMessage = Microsoft.VisualBasic.Join(strMessages, Microsoft.VisualBasic.vbNewLine)
 
         'Get the location string
         If Location.HasFile Then
             strLocation = Location.ToString(Compiler)
             result = MESSAGEFORMATWITHLOCATION
         Else
             strLocation = "vbnc
             result = MESSAGEFORMATWITHLOCATION
         End If
 
         'Format the entire message.
         result = result.Replace("%LOCATION%", strLocation)
         result = result.Replace("%MESSAGE%", strMessage)
         result = result.Replace("%MESSAGELEVEL%", Level.ToString.ToLower())
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MemberImplementsClause.vb" startline="95" endline="140">
<![CDATA[
 
     Function DefineImplements(ByVal Method As Mono.Cecil.MethodDefinition) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Method IsNot Nothing)
 
         For i As Integer = 0 To m_ImplementsList.Count - 1
             Dim ispec As InterfaceMemberSpecifier = Me.m_ImplementsList(i)
             Dim methodI As Mono.Cecil.MethodReference = Nothing
             Dim propertyI As Mono.Cecil.PropertyReference = Nothing
             Dim propertyDef As Mono.Cecil.PropertyDefinition = Nothing
 
             If ispec.ResolvedMethodInfo IsNot Nothing Then
                 methodI = Helper.GetMethodOrMethodReference(Compiler, ispec.ResolvedMethodInfo)
             End If
 
             If ispec.ResolvedPropertyInfo IsNot Nothing Then
                 propertyI = Helper.GetPropertyOrPropertyBuilder(Compiler, ispec.ResolvedPropertyInfo)
                 propertyDef = CecilHelper.FindDefinition(propertyI)
             End If
 
             Helper.Assert(propertyI Is Nothing Xor methodI Is Nothing)
 
             If propertyI IsNot Nothing Then
                 'This is a property
                 If Method.Name.StartsWith("get_") Then
                     methodI = CecilHelper.GetCorrectMember(propertyDef.GetMethod, propertyI.DeclaringType)
                 ElseIf Method.Name.StartsWith("set_") Then
                     methodI = CecilHelper.GetCorrectMember(propertyDef.SetMethod, propertyI.DeclaringType)
                 Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
                 End If
                 methodI = Helper.GetMethodOrMethodReference(Compiler, methodI)
             End If
 
 
             Helper.Assert(methodI IsNot Nothing)
 
             Method.Overrides.Add(CecilHelper.MakeEmittable(methodI))
 
 #If EXTENDEDDEBUG Then
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Defined method override '" & Builder.FullName & "
 #End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="52" endline="98">
<![CDATA[
     End Property
 
     Function ResolveGroup(ByVal SourceParameters As ArgumentList, Optional ByVal ShowErrors As Boolean = False) As Boolean
         Dim result As Boolean = True
         Dim destinationParameterTypes()() As Mono.Cecil.TypeReference
         Dim destinationParameters() As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Dim sourceParameterTypes() As Mono.Cecil.TypeReference
 
         ReDim destinationParameterTypes(m_Members.Count - 1)
         ReDim destinationParameters(m_Members.Count - 1)
         For i As Integer = 0 To m_Members.Count - 1
             destinationParameters(i) = m_Members(i).Parameters
             destinationParameterTypes(i) = Helper.GetTypes(destinationParameters(i))
         Next
 
         sourceParameterTypes = SourceParameters.ToTypes
 
         Dim resolvedGroup As New Generic.List(Of Mono.Cecil.MemberReference)
         Dim inputGroup As New Generic.List(Of Mono.Cecil.MemberReference)(m_Members.Count)
         For i As Integer = 0 To m_Members.Count - 1
             inputGroup.Add(DirectCast(m_Members(i), PropertyReference))
         Next
 
         If m_Resolver Is Nothing Then m_Resolver = New MethodResolver(Parent)
         m_Resolver.ShowErrors = ShowErrors
         m_Resolver.Init(inputGroup, SourceParameters, Nothing)
         result = m_Resolver.Resolve AndAlso result
 
         If result Then
             If m_Resolver.IsLateBound = False Then
                 m_FinalSourceArguments = New ArgumentList(Me.Parent, m_Resolver.ResolvedCandidate.ExactArguments)
                 resolvedGroup.Add(m_Resolver.ResolvedMember)
             End If
         End If
 
         'result = Helper.ResolveGroup(Me.Parent, inputGroup, resolvedGroup, SourceParameters, Nothing, Nothing, False)
 
         If result Then
             m_ResolvedProperty = TryCast(resolvedGroup(0), Mono.Cecil.PropertyReference)
             result = m_ResolvedProperty IsNot Nothing AndAlso result
         End If
 
         m_Parameters = SourceParameters
         m_Resolved = True
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="932" endline="967">
<![CDATA[
 
     Public Function SetCecilName(ByVal Name As Mono.Cecil.AssemblyNameDefinition) As Boolean
         Dim result As Boolean = True
         Dim keyfile As String = Nothing
         Dim keyname As String = Nothing
         Dim delaysign As Boolean = False
 
         Name.Name = IO.Path.GetFileNameWithoutExtension(Compiler.OutFileName)
 
         If Compiler.CommandLine.KeyFile <> String.Empty Then
             keyfile = Compiler.CommandLine.KeyFile
         End If
 
         For Each attri As Attribute In Me.Attributes
             Dim attribType As Mono.Cecil.TypeReference
             attribType = attri.ResolvedType
 
             If Helper.CompareType(attribType, Compiler.TypeCache.System_Reflection_AssemblyVersionAttribute) Then
                 result = SetVersion(Name, attri, attri.Location) AndAlso result
             ElseIf Helper.CompareType(attribType, Compiler.TypeCache.System_Reflection_AssemblyKeyFileAttribute) Then
                 If keyfile = String.Empty Then keyfile = TryCast(attri.Arguments()(0), String)
             ElseIf Helper.CompareType(attribType, Compiler.TypeCache.System_Reflection_AssemblyKeyNameAttribute) Then
                 keyname = TryCast(attri.Arguments()(0), String)
             ElseIf Helper.CompareType(attribType, Compiler.TypeCache.System_Reflection_AssemblyDelaySignAttribute) Then
                 delaysign = CBool(attri.Arguments()(0))
             End If
         Next
 
         If keyfile <> String.Empty Then
             If SignWithKeyFile(Name, keyfile, delaysign) = False Then
                 Return result
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="159" endline="199">
<![CDATA[
 
     Function RuleMultiplicationAndRealDivision(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleUnaryNegation(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Mult, KS.RealDivision)
             Dim DoMult As Boolean
             DoMult = CurrentToken.Equals(KS.Mult)
             NextToken()
 
             RuleUnaryNegation(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf DoMult Then
                 LSide = op1 * op2
             Else
                 If op2 = 0 Then
                     Compiler.Report.ShowMessage(Messages.VBNC30542, Location)
                     LSide = CDbl(0)
                 Else
                     LSide = op1 / op2
                 End If
             End If
         End While
         While CurrentToken.Equals(KS.Mult, KS.RealDivision)
             Dim DoMult As Boolean
             DoMult = CurrentToken.Equals(KS.Mult)
             NextToken()
 
             RuleUnaryNegation(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf DoMult Then
                 LSide = op1 * op2
             Else
                 If op2 = 0 Then
                     Compiler.Report.ShowMessage(Messages.VBNC30542, Location)
                     LSide = CDbl(0)
                 Else
                     LSide = op1 / op2
                 End If
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3860" endline="3896">
<![CDATA[
 
     Private Sub UpdateEstSize()
 
         If mHandler Is Nothing Then Exit Sub
         If mPlayer.openState <> WMPLib.WMPOpenState.wmposMediaOpen Then Exit Sub
 
         Dim fi As New FileInfo(mHandler.InputFile)
         Dim FileSize As Long = fi.Length
         Dim EstSize As Double
 
         If radTime.Checked Then
             Dim Duration As Double
             Duration = numHr.Value * 3600 + numMin.Value * 60 + numSec.Value
             If Duration > mPlayer.currentMedia.duration Then
                 EstSize = FileSize / 1024
             Else
                 EstSize = (Duration / mPlayer.currentMedia.duration) * (FileSize / 1024)
             End If
         End If
 
         If radPieces.Checked Then
             If numPcs.Value = 0 Then Exit Sub
             EstSize = (FileSize / numPcs.Value) / 1024
         End If
 
         If radSize.Checked Then
             If Len(cbSize.Text) = 0 Then
                 EstSize = 0
             Else
                 EstSize = Val(cbSize.Text)
                 If EstSize > FileSize / 1024 Then EstSize = FileSize / 1024
             End If
         End If
 
         lSize.Text = CStr(CInt(EstSize)) + " kb"
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4591" endline="4649">
<![CDATA[
 
     ''' <summary>
     ''' ExternalSubDeclaration 
     ''' 	[  Attributes  ]  [  ExternalMethodModifier+  ] "Declare" [  CharsetModifier  ] "Sub" Identifier
     '''		LibraryClause  [  AliasClause  ]  [  (  [  ParameterList  ]  )  ]  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseExternalSubDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As ExternalSubDeclaration
         Dim result As New ExternalSubDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_CharsetModifier As KS
         Dim m_Identifier As Identifier
         Dim m_LibraryClause As LibraryClause = Nothing
         Dim m_AliasClause As AliasClause = Nothing
         Dim m_ParameterList As ParameterList = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.ExternalMethodModifiers)
 
         tm.AcceptIfNotInternalError(KS.Declare)
 
         If tm.CurrentToken.Equals(ModifierMasks.CharSetModifiers) Then
             m_CharsetModifier = tm.CurrentToken.Keyword
             tm.NextToken()
         End If
 
         tm.AcceptIfNotInternalError(KS.Sub)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         m_LibraryClause = ParseLibraryClause(result)
         If m_LibraryClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If AliasClause.IsMe(tm) Then
             m_AliasClause = ParseAliasClause(result)
             If m_AliasClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.Accept(KS.LParenthesis) Then
             m_ParameterList = New ParameterList(result)
             If tm.Accept(KS.RParenthesis) = False Then
                 If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
 
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_CharsetModifier, m_Identifier, m_LibraryClause, m_AliasClause, m_ParameterList)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeImplementsClauses.vb" startline="608" endline="658">
<![CDATA[
 
     Private Function CheckNamespaces(ByVal R As String, ByVal TypeArgumentCount As Integer) As Boolean
         '---------------------------------------------------------------------------------------------------------
         '* For each nested namespace containing the name reference, starting from the innermost namespace and 
         '* going to the outermost namespace, do the following
         '** (...)
         '---------------------------------------------------------------------------------------------------------
         'Check all the namespaces up to the outermost namespace (not including)
         Dim declaringtype As TypeDeclaration = FromWhere.FindFirstParent(Of TypeDeclaration)()
         Dim ns As String
         If declaringtype IsNot Nothing Then
             ns = declaringtype.Namespace
         Else
             ns = FromWhere.Compiler.CommandLine.RootNamespace
         End If
         If ns Is Nothing Then ns = String.Empty
         Dim current As BaseObject = FromWhere
         'Dim dotR As String = "." & R
         'Dim nsDotR As String = ns & dotR
         Do
             If CheckNamespace(R, FromWhere.Compiler.TypeManager.GetTypesByNamespace(ns), TypeArgumentCount) Then Return True
 
             If ns.Length > R.Length + 1 AndAlso ns.EndsWith(R, Helper.StringComparison) AndAlso ns(ns.Length - R.Length - 1) = "."c Then
                 m_FoundObjects.Add(FromWhere.Compiler.TypeManager.Namespaces(ns))
                 Return True
             End If
 
             If ns <> String.Empty AndAlso TypeArgumentCount = 0 Then
                 Dim nSpace As [Namespace]
                 nSpace = FromWhere.Compiler.TypeManager.Namespaces.FindNamespace(ns, R)
                 If nSpace IsNot Nothing Then
                     m_FoundObjects.Add(nSpace)
                     Return True
                 End If
             End If
 
             If Helper.CompareName(ns, R) Then
                 m_FoundObjects.Add(FromWhere.Compiler.TypeManager.Namespaces(ns))
                 Return True
             End If
             ns = vbnc.Helper.GetNamespaceParent(ns)
             'nsDotR = ns & dotR
         Loop Until ns Is Nothing
 
         'Check the outermost namespace
         'First the current compiling outermost namespace
         If CheckNamespace(R, FromWhere.Compiler.TypeManager.GetTypesByNamespace(String.Empty), TypeArgumentCount) Then Return True
 
         'then all the namespaces in the referenced assemblies
         Return CheckOutermostNamespace(R, TypeArgumentCount)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="228" endline="277">
<![CDATA[
 
     Private Shared Function EmitStoreBacks(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification, ByVal CopyBacks As Boolean(), ByVal array As Mono.Cecil.Cil.VariableDefinition, ByVal arguments As Mono.Cecil.Cil.VariableDefinition) As Boolean
         Dim result As Boolean = True
         Dim args As ArgumentList
 
         If CopyBacks Is Nothing OrElse CopyBacks.Length = 0 Then Return result
 
         args = LateBoundAccess.Arguments
 
         For i As Integer = 0 To CopyBacks.Length - 1
             Dim branch As Label
 
             If CopyBacks(i) = False Then Continue For
 
             Dim arg As Argument
             Dim exp As Expression
 
             arg = args.Arguments(i)
             exp = arg.Expression
 
             branch = Emitter.DefineLabel(Info)
             Emitter.EmitLoadVariable(Info, array)
             Emitter.EmitLoadI4Value(Info, i)
             Emitter.EmitLoadElement(Info, Info.Compiler.TypeCache.System_Boolean_Array)
             Emitter.EmitBranchIfFalse(Info, branch)
 
             Dim tmpVar As Mono.Cecil.Cil.VariableDefinition
             tmpVar = Emitter.DeclareLocal(Info, exp.ExpressionType)
 
             Emitter.EmitLoadVariable(Info, arguments)
             Emitter.EmitLoadI4Value(Info, i)
             Emitter.EmitLoadElement(Info, Info.Compiler.TypeCache.System_Object_Array)
             Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
             Emitter.EmitLoadToken(Info, exp.ExpressionType)
             Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Type__GetTypeFromHandle_RuntimeTypeHandle)
             Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ChangeType_Object_Type)
 
             Dim vosExp As New ValueOnStackExpression(exp, Info.Compiler.TypeCache.System_Object)
             Dim convExp As DirectCastExpression
             convExp = New DirectCastExpression(exp)
             convExp.Init(vosExp, exp.ExpressionType)
             result = convExp.GenerateCode(Info) AndAlso result
             Emitter.EmitStoreVariable(Info, tmpVar)
             result = exp.GenerateCode(Info.Clone(Info.Context, New LoadLocalExpression(exp, tmpVar))) AndAlso result
 
             Emitter.MarkLabel(Info, branch)
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="1656" endline="1714">
<![CDATA[
 
     ''' <summary>
     ''' CustomEventMemberDeclaration  
     '''	[  Attributes  ]  [  EventModifiers+  ]  "Custom" "Event" Identifier "As" TypeName  [  ImplementsClause  ]
     '''		StatementTerminator
     '''		EventAccessorDeclaration+
     '''	"End" "Event" StatementTerminator
     ''' 
     ''' LAMESPEC!!! Using the following
     ''' CustomEventMemberDeclaration  
     '''	[  Attributes  ]  [  EventModifiers+  ]  "Custom" "Event" Identifier "As" NonArrayTypeName  [  ImplementsClause  ]
     '''		StatementTerminator
     '''		EventAccessorDeclaration+
     '''	"End" "Event" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseCustomEventMemberDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As CustomEventDeclaration
         Dim result As New CustomEventDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_TypeName As NonArrayTypeName
         Dim m_ImplementsClause As MemberImplementsClause = Nothing
         Dim m_EventAccessorDeclarations As EventAccessorDeclarations = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.EventModifiers)
 
         tm.AcceptIfNotInternalError("Custom")
         tm.AcceptIfNotInternalError(KS.Event)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.As) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_TypeName = ParseNonArrayTypeName(result)
         If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement = False Then
             m_ImplementsClause = ParseImplementsClause(result)
             If m_ImplementsClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         m_EventAccessorDeclarations = ParseEventAccessorDeclarations(result, m_Identifier, m_Modifiers)
         If m_EventAccessorDeclarations Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Event) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Identifier, m_TypeName, m_ImplementsClause)
 
         result.AddMethod = m_EventAccessorDeclarations.AddHandler
         result.RemoveMethod = m_EventAccessorDeclarations.RemoveHandler
         result.RaiseMethod = m_EventAccessorDeclarations.RaiseEvent
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="948" endline="954">
<![CDATA[
 
     Public Shared Function IsGenericMethod(ByVal Method As Mono.Cecil.MethodReference) As Boolean
         If TypeOf Method Is Mono.Cecil.GenericInstanceMethod Then Return True
         If Method.GenericParameters.Count > 0 Then Return True
         Return False
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="168" endline="175">
<![CDATA[
 
     ReadOnly Property IfdOut() As Boolean
         Get
             For i As Integer = 0 To m_ConditionStack.Count - 1
                 If Not m_ConditionStack(i) > 0 Then Return True
             Next
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\CustomEventDeclaration.vb" startline="41" endline="48">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.EventModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.EventModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals("Custom") AndAlso tm.PeekToken(i + 1).Equals(KS.Event)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\OperatorDeclaration.vb" startline="179" endline="188">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.OperatorModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.OperatorModifiers)
             i += 1
         End While
         If tm.PeekToken(i).Equals(KS.Operator) = False Then Return False
         If IsOverloadableOperator(tm.PeekToken(i + 1)) = False Then Return False
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CodeFiles.vb" startline="1175" endline="1223">
<![CDATA[
 
     ''' <summary>
     ''' Parses the commandline
     ''' Returns false if no commandline found, or if there was an error parsing the commandline.
     ''' Messages here are saved, since they have to be shown after the logo is shown, but the 
     ''' showing of the logo can be cancelled on the commandline, so the entire commandline
     ''' has to the parsed before any messages are shown.
     ''' </summary>
     Private Function ParseInternal(ByVal Args() As String) As Boolean
         Dim result As Boolean = True
         m_lstAllArgs.AddRange(Args)
         For Each s As String In Args
             If s.StartsWith("@") Then
                 result = ParseResponseFile(s.Substring(1)) AndAlso result
                 Continue For
             End If
 
             Dim isOption As Boolean
 
             isOption = s.StartsWith("-"c)
             If isOption = False AndAlso s.StartsWith("/"c) Then
                 Dim idxSecond As Integer = s.IndexOf("/"c, 2)
                 Dim idxColon As Integer = s.IndexOf("
 
                 isOption = idxColon >= 0 OrElse idxSecond = -1
             End If
 
             If isOption Then
                 Dim strName As String = "", strValue As String = ""
                 'Find the colon which separates the values
                 Dim iColon As Integer = InStr(2, s, "
                 'If found, split it in a name and value pair
                 If iColon > 0 Then
                     strName = s.Substring(1, iColon - 2)
                     strValue = s.Substring(strName.Length + 2)
                 Else
                     'if not, the whole string is the name
                     strName = s.Substring(1)
                 End If
                 'find the option
                 result = SetOption(strName, strValue) AndAlso result
                 Continue For
             End If
 
             AddFile(s)
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\MainForm.cs" startline="436" endline="472">
<![CDATA[
 
 		protected void UpdateFobView(object sender, EventArgs e)
 		{
 			if(keyFobView.InvokeRequired)
 			{
 				EventHandler UpdateFobViewHandler = new EventHandler(UpdateFobView);
 				keyFobView.Invoke(UpdateFobViewHandler, new object[] { this, null });
 			}
 			else
 			{
 				lock(keyFobView)
 				{
 					keyFobView.Items.Clear();
 					if(pm.KeyFobs.Count == 0)
 					{
 						MessageBox.Show("Wha happen!");
 					}
 
 					foreach(KeyFob fob in pm.KeyFobs)
 					{
 						string auth = "Not Authorized";
 						if(fob.IsAuthorized) { auth = "Authorized"; }
 						ListViewItem row = new ListViewItem(fob.SerialNumber);
 						ListViewItem.ListViewSubItem lvsi1 = new ListViewItem.ListViewSubItem(row, fob.Status.ToString());
 						ListViewItem.ListViewSubItem lvsi2 = new ListViewItem.ListViewSubItem(row, auth);
 						row.SubItems.Add(lvsi1);
 						row.SubItems.Add(lvsi2);
 						keyFobView.Items.Add(row);
 
 						if(fob.Status == KeyFobStatus.NotPresent)
 						{
 							row.ForeColor = Color.Silver;
 						}
 					}
 					foreach(KeyFob fob in pm.KeyFobs)
 					{
 						string auth = "Not Authorized";
 						if(fob.IsAuthorized) { auth = "Authorized"; }
 						ListViewItem row = new ListViewItem(fob.SerialNumber);
 						ListViewItem.ListViewSubItem lvsi1 = new ListViewItem.ListViewSubItem(row, fob.Status.ToString());
 						ListViewItem.ListViewSubItem lvsi2 = new ListViewItem.ListViewSubItem(row, auth);
 						row.SubItems.Add(lvsi1);
 						row.SubItems.Add(lvsi2);
 						keyFobView.Items.Add(row);
 
 						if(fob.Status == KeyFobStatus.NotPresent)
 						{
 							row.ForeColor = Color.Silver;
 						}
 					}
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="79" endline="122">
<![CDATA[
     End Property
 
     Function GenerateCode_LoadCurrentLoopVariable(ByVal Info As EmitInfo) As Boolean
         Dim varType As Mono.Cecil.TypeReference = m_LoopControlVariable.VariableType
         Dim isGenericParameter As Boolean = CecilHelper.IsGenericParameter(varType)
         Dim isValueType As Boolean = isGenericParameter = False AndAlso CecilHelper.IsValueType(varType)
         Dim isClass As Boolean = isGenericParameter = False AndAlso CecilHelper.IsClass(varType)
 
         Emitter.EmitLoadVariable(Info, m_Enumerator)
         Emitter.EmitCallVirt(Info, Compiler.TypeCache.System_Collections_IEnumerator__get_Current)
 
         Dim valueTPLoad As Label = Nothing
         Dim valueTPLoaded As Label = Nothing
 
         If isValueType Then
             Dim tmpStructureVariable As Mono.Cecil.Cil.VariableDefinition
 
             valueTPLoad = Emitter.DefineLabel(Info)
             valueTPLoaded = Emitter.DefineLabel(Info)
             tmpStructureVariable = Emitter.DeclareLocal(Info, varType)
             Emitter.EmitDup(Info)
             Emitter.EmitBranchIfTrue(Info, valueTPLoad)
             Emitter.EmitPop(Info, Compiler.TypeCache.System_Object)
             Emitter.EmitLoadVariable(Info, tmpStructureVariable)
             Emitter.EmitBranch(Info, valueTPLoaded)
             Emitter.FreeLocal(tmpStructureVariable)
         Else
             Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
         End If
 
         If isGenericParameter Then
             Emitter.EmitUnbox_Any(Info, varType)
         ElseIf isClass Then
             Emitter.EmitCastClass(Info, varType)
         ElseIf isValueType Then
             Emitter.MarkLabel(Info, valueTPLoad)
             Emitter.EmitUnbox(Info, varType)
             Emitter.EmitLoadObject(Info, varType)
             Emitter.MarkLabel(Info, valueTPLoaded)
         Else
             Emitter.EmitConversion(Compiler.TypeCache.System_Object, varType, Info.Clone(Me, True, True, varType))
         End If
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="247" endline="261">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Property BaseType() As Mono.Cecil.TypeReference Implements IType.BaseType
         Get
             If m_CecilType Is Nothing Then
                 Return Nothing
             End If
             Return m_CecilType.BaseType
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="119" endline="128">
<![CDATA[
     End Property
 
     ReadOnly Property LocalBuilder() As Mono.Cecil.Cil.VariableDefinition
         Get
             If m_LocalVariable IsNot Nothing Then
                 Return m_LocalVariable.LocalBuilder
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="125" endline="134">
<![CDATA[
     End Property
 
     Public ReadOnly Property GetMethod() As Mono.Cecil.MethodDefinition
         Get
             If m_Get IsNot Nothing Then
                 Return m_Get.CecilBuilder
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\PropertyDeclaration.vb" startline="141" endline="150">
<![CDATA[
     End Property
 
     Public ReadOnly Property SetMethod() As Mono.Cecil.MethodDefinition
         Get
             If m_Set IsNot Nothing Then
                 Return m_Set.CecilBuilder
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="1311" endline="1321">
<![CDATA[
 
     Public Shared Function FindDefinition(ByVal method As EventReference) As EventDefinition
         If method Is Nothing Then Return Nothing
         Dim type As TypeDefinition = FindDefinition(method.DeclaringType)
         'method = method.GetOriginalMethod
         'If Helper.CompareNameOrdinal(method.Name, MethodDefinition.Cctor) OrElse Helper.CompareNameOrdinal(method.Name, MethodDefinition.Ctor) Then
         '    Return GetMethod(type.Constructors, method)
         'Else
         Return GetEvent(type.Events, method)
         'End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="767" endline="776">
<![CDATA[
 
     Private Sub EatWhiteSpace()
         While IsWhiteSpace()
             If IsLineContinuation() Then
                 EatLine(True)
             Else
                 NextChar()
             End If
         End While
         While IsWhiteSpace()
             If IsLineContinuation() Then
                 EatLine(True)
             Else
                 NextChar()
             End If
         End While
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2791" endline="2804">
<![CDATA[
 
     Shared Function GetEnumType(ByVal Compiler As Compiler, ByVal EnumType As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Dim tp As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(EnumType)
         Dim fInfo As Mono.Cecil.FieldReference
 
         Helper.Assert(Helper.IsEnum(Compiler, EnumType))
 
         tp = CecilHelper.FindDefinition(EnumType)
         fInfo = CecilHelper.FindField(tp.Fields, EnumDeclaration.EnumTypeMemberName)
 
         Helper.Assert(fInfo IsNot Nothing)
 
         Return fInfo.FieldType
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="136" endline="149">
<![CDATA[
     End Property
 
     Function GenerateCodeAsValue(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim constant As Object = Nothing 'm_ResolvedProperty.GetConstantValue
         If constant IsNot Nothing Then
             Emitter.EmitLoadValue(Info, constant)
         Else
             Helper.EmitArgumentsAndCallOrCallVirt(Info, m_InstanceExpression, m_Parameters, CecilHelper.GetGetMethod(m_ResolvedProperty))
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="799" endline="808">
<![CDATA[
 
     Shared Function FilterByName(ByVal collection As Generic.List(Of Type), ByVal Name As String) As Generic.List(Of Type)
         Dim result As New Generic.List(Of Type)
         Dim tmpname As String = ""
         For Each obj As Type In collection
             If Helper.CompareName(Name, obj.Name) Then result.Add(obj)
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="837" endline="850">
<![CDATA[
 
     ''' <summary>
     ''' Returns a list of type descriptors that only are modules.
     ''' </summary>
     ''' <param name="Types"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function FilterToModules(ByVal Compiler As Compiler, ByVal Types As TypeDictionary) As Generic.List(Of Mono.Cecil.TypeReference)
         Dim result As New Generic.List(Of Mono.Cecil.TypeReference)
         For Each t As Mono.Cecil.TypeReference In Types.Values
             If IsModule(Compiler, t) Then result.Add(t)
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4571" endline="4581">
<![CDATA[
 
     Shared Function IsAccessible(ByVal Context As BaseObject, ByVal Caller As Mono.Cecil.TypeReference, ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Select Case CecilHelper.GetMemberType(Member)
             Case MemberTypes.Constructor, MemberTypes.Method
                 Return IsAccessible(Context, Caller, DirectCast(Member, Mono.Cecil.MethodReference))
             Case MemberTypes.Property
                 Return IsAccessible(Context, Caller, DirectCast(Member, Mono.Cecil.PropertyReference))
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\Attributes.vb" startline="59" endline="78">
<![CDATA[
 
     ''' <summary>
     ''' Might return nothing
     ''' </summary>
     ''' <param name="AttributeType"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function FindAttributes(ByVal AttributeType As Mono.Cecil.TypeReference) As Generic.List(Of Attribute)
         Dim result As Generic.List(Of Attribute) = Nothing
 
         If AttributeType Is Nothing Then Return Nothing
 
         For Each att As Attribute In Me
             If Helper.CompareType(att.AttributeType, AttributeType) Then
                 If result Is Nothing Then result = New Generic.List(Of Attribute)
                 result.Add(att)
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeImplementsClauses.vb" startline="659" endline="679">
<![CDATA[
 
     Private Function CheckImportsAlias(ByVal R As String, ByVal [Imports] As ImportsClauses, ByVal TypeArgumentCount As Integer) As Boolean
         '---------------------------------------------------------------------------------------------------------
         '* If the source file has one or more import aliases, and R matches the name of one of them, then 
         '* the unqualified name refers to that import alias.
         '---------------------------------------------------------------------------------------------------------
         ' (...)
         '---------------------------------------------------------------------------------------------------------
         '* If the compilation environment defines one or more import aliases, and R matches the name of one of 
         '* them, then the unqualified name refers to that import alias.
         '---------------------------------------------------------------------------------------------------------
         For Each import As ImportsClause In [Imports]
             If import.IsAliasClause Then
                 If Helper.CompareName(import.AsAliasClause.Name, R) Then
                     m_FoundObjects.Add(import)
                     Return True
                 End If
             End If
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="522" endline="543">
<![CDATA[
 
     ''' <summary>
     ''' Returns all the members in the types with the specified name.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function GetMembersOfTypes(ByVal Compiler As Compiler, ByVal Types As TypeDictionary, ByVal Name As String) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim result As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference) = Nothing
 
         If Types Is Nothing Then Return Nothing
 
         For Each type As Mono.Cecil.TypeReference In Types.Values
             Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
             members = Compiler.TypeManager.GetCache(type).LookupFlattenedMembers(Name)
             If members IsNot Nothing Then
                 If result Is Nothing Then result = New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
                 result.AddRange(members)
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\AbstractMediaHandler.vb" startline="237" endline="265">
<![CDATA[
 
 #End Region
 
 #Region "   Synch Caller "
 
     Protected Function ReturnOutput(ByVal Args As String) As String
         'Currently ignoring the stderr output - need to create an async reader for it
 
         Dim ProcInfo As New ProcessStartInfo
         ProcInfo.FileName = mCutterPath & mConverter
         ProcInfo.WorkingDirectory = mCutterPath
         ProcInfo.Arguments = Args
         ProcInfo.UseShellExecute = False
         ProcInfo.CreateNoWindow = True
         ProcInfo.WindowStyle = ProcessWindowStyle.Hidden
         ProcInfo.RedirectStandardOutput = True
 
         Try
             Dim Proc As New Process
             Proc.StartInfo = ProcInfo
             Proc.Start()
 
             ReturnOutput = Proc.StandardOutput.ReadToEnd
             Proc.WaitForExit()
         Catch ex As Exception
             MsgBox(ex.Message)
         End Try
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1626" endline="1650">
<![CDATA[
 
     ''' <summary>
     ''' Loads the value of the specified parameter.
     ''' If it is a byref parameter, the passed-in address is loaded.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Parameter"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadParameter(ByVal Info As EmitInfo, ByVal Parameter As Mono.Cecil.ParameterDefinition)
         Dim position As Integer = GetParameterPosition(Info, Parameter)
         Select Case position
             Case 0
                 Info.ILGen.Emit(OpCodes.Ldarg_0)
             Case 1
                 Info.ILGen.Emit(OpCodes.Ldarg_1)
             Case 2
                 Info.ILGen.Emit(OpCodes.Ldarg_2)
             Case 3
                 Info.ILGen.Emit(OpCodes.Ldarg_3)
             Case Is <= 255
                 Info.ILGen.Emit(OpCodes.Ldarg_S, CByte(position))
             Case Else
                 Info.ILGen.Emit(OpCodes.Ldarg, position)
         End Select
    End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="246" endline="273">
<![CDATA[
 
     Public Sub EndExceptionBlockCecil()
         Log("EndExceptionBlock")
         Dim block As TryBlock = m_ExceptionBlocks.Pop
         If block.EndTry Is Nothing Then block.EndTry = CreateAndEmitNop()
 
         Dim TryStart As Mono.Cecil.Cil.Instruction
         TryStart = CilBody.Instructions(block.Start)
         If block.Handlers(block.Handlers.Count - 1).HandlerType = Mono.Cecil.Cil.ExceptionHandlerType.Finally Then
             CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Endfinally)
         End If
         For i As Integer = 0 To block.Handlers.Count - 1
             Dim handler As Mono.Cecil.Cil.ExceptionHandler
             handler = block.Handlers(i)
             handler.TryStart = TryStart
             If handler.TryEnd Is Nothing Then
                 handler.TryEnd = block.EndTry
             End If
             If handler.HandlerEnd Is Nothing Then
                 If handler.HandlerType <> Mono.Cecil.Cil.ExceptionHandlerType.Finally Then
                     CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Leave, block.EndBlock)
                 End If
                 handler.HandlerEnd = block.EndBlock
             End If
             CilBody.ExceptionHandlers.Add(handler)
         Next
         CilWorker.Append(block.EndBlock)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmAuto.vb" startline="234" endline="266">
<![CDATA[
 
     Private Sub Profile_TuneUp(ByVal Name As String, ByVal Setting As String)
 
         Try
             SrvcCntrl.ServiceName = (Name)
             Dim ChkSrvc As Boolean = SrvcCntrl.CanPauseAndContinue
         Catch ex As InvalidOperationException
             Exit Sub
         End Try
 
         If My.Settings(Setting) = 1 Then
 
             Try
                 SrvcCntrl.StartupType = ("Automatic")
                 SrvcCntrl.Start()
                 SrvcCntrl.WaitForStatus(ServiceProcess.ServiceControllerStatus.Running, TimeSpan.FromSeconds(3))
             Catch ex As InvalidOperationException
             Catch ex As System.ServiceProcess.TimeoutException
             End Try
 
         ElseIf My.Settings(Setting) = 2 Then
 
             Try
                 SrvcCntrl.StartupType = ("Manual")
                 SrvcCntrl.Stop()
                 SrvcCntrl.WaitForStatus(ServiceProcess.ServiceControllerStatus.Stopped, TimeSpan.FromSeconds(3))
             Catch ex As InvalidOperationException
             Catch ex As System.ServiceProcess.TimeoutException
             End Try
 
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Classes\SrvcProfile.vb" startline="66" endline="96">
<![CDATA[
 
     Private Sub Apply(ByVal Name As String, ByVal Setting As String)
 
         Try
             SrvcCntrl.ServiceName = (Name)
             Dim ChkSrvc As Boolean = SrvcCntrl.CanPauseAndContinue
         Catch ex As InvalidOperationException
             Exit Sub
         End Try
 
         If String.Compare(Setting, (Name & "1"), True) = 0 Then
             Try
                 SrvcCntrl.StartupType = ("Automatic")
                 SrvcCntrl.Start()
                 SrvcCntrl.WaitForStatus(ServiceProcess.ServiceControllerStatus.Running, TimeSpan.FromSeconds(3))
             Catch ex As InvalidOperationException
             Catch ex As System.ServiceProcess.TimeoutException
             End Try
         ElseIf String.Compare(Setting, (Name & "2"), True) = 0 Then
             SrvcCntrl.StartupType = ("Manual")
         ElseIf String.Compare(Setting, (Name & "3"), True) = 0 Then
             Try
                 SrvcCntrl.StartupType = ("Disabled")
                 SrvcCntrl.Stop()
                 SrvcCntrl.WaitForStatus(ServiceProcess.ServiceControllerStatus.Stopped, TimeSpan.FromSeconds(3))
             Catch ex As InvalidOperationException
             Catch ex As System.ServiceProcess.TimeoutException
             End Try
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1441" endline="1475">
<![CDATA[
 
     Shared Function GetTypeOrTypeReference(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         If Type Is Nothing Then Return Nothing
         If TypeOf Type Is Mono.Cecil.GenericParameter Then Return Type
 
         If Compiler.Assembly.IsDefinedHere(Type) Then
             Return Type
         ElseIf TypeOf Type Is ByReferenceType Then
             Dim refType As ByReferenceType = DirectCast(Type, ByReferenceType)
             Dim elementType As Mono.Cecil.TypeReference
             elementType = GetTypeOrTypeReference(Compiler, refType.ElementType)
             If elementType Is refType.ElementType Then Return Type
             Return New ByReferenceType(elementType)
         ElseIf TypeOf Type Is Mono.Cecil.ArrayType Then
             Dim arrType As Mono.Cecil.ArrayType = DirectCast(Type, Mono.Cecil.ArrayType)
             Dim elementType As Mono.Cecil.TypeReference
             elementType = GetTypeOrTypeReference(Compiler, arrType.ElementType)
             If elementType Is arrType.ElementType Then Return Type
             Dim result As Mono.Cecil.ArrayType = New Mono.Cecil.ArrayType(elementType, arrType.Rank)
             For i As Integer = 0 To arrType.Rank - 1
                 result.Dimensions(i) = arrType.Dimensions(i)
             Next
             Return result
         ElseIf TypeOf Type Is Mono.Cecil.GenericInstanceType Then
             Dim git As Mono.Cecil.GenericInstanceType = DirectCast(Type, Mono.Cecil.GenericInstanceType)
             Dim elementType As Mono.Cecil.TypeReference = GetTypeOrTypeReference(Compiler, git.ElementType)
             Dim result As New Mono.Cecil.GenericInstanceType(elementType)
             For i As Integer = 0 To git.GenericArguments.Count - 1
                 result.GenericArguments.Add(GetTypeOrTypeReference(Compiler, git.GenericArguments(i)))
             Next
             Return result
         Else
             Return Compiler.AssemblyBuilderCecil.MainModule.Import(CecilHelper.FindDefinition(Type))
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="167" endline="205">
<![CDATA[
 
     Private Sub LnkAutoTuneUp_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles LnkAutoTuneUp.Click
 
         If User_Profile() = False Then
 
             If FrmUsrProfile.ShowDialog(Me) = Windows.Forms.DialogResult.OK Then
                 Dim Child As Form
                 For Each Child In Me.MdiChildren
                     If Child.Text = "Automatic TuneUp" Then
                         Exit Sub
                     Else
                         Child.Dispose()
                     End If
                 Next
 
                 FrmAuto.MdiParent = Me
                 FrmAuto.Size = New Size((Me.Size.Width - 291), (Me.Size.Height - 94))
                 FrmAuto.Show()
                 PnlHome.Visible = False
             End If
 
         ElseIf User_Profile() = True Then
 
             Dim Child As Form
             For Each Child In Me.MdiChildren
                 If Child.Text = "Automatic TuneUp" Then
                     Exit Sub
                 Else
                     Child.Dispose()
                 End If
             Next
 
             FrmAuto.MdiParent = Me
             FrmAuto.Size = New Size((Me.Size.Width - 291), (Me.Size.Height - 94))
             FrmAuto.Show()
             PnlHome.Visible = False
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="54" endline="129">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim method As Mono.Cecil.MethodReference
 
         If m_LateBoundExpression IsNot Nothing Then Return m_LateBoundExpression.GenerateCode(Info)
 
         Dim rside As EmitInfo
         rside = Info.Clone(Parent, True)
 
         If m_Classification IsNot Nothing Then
             m_InstanceExpression = m_Classification.InstanceExpression
             m_Property = m_Classification.ResolvedProperty
             m_Parameters = m_Classification.Parameters
         End If
 
         Helper.Assert(m_Property IsNot Nothing)
 
         If Info.IsLHS Then
             method = CecilHelper.GetCorrectMember(CecilHelper.FindDefinition(m_Property).SetMethod, m_Property.DeclaringType)
         Else
             method = CecilHelper.GetCorrectMember(CecilHelper.FindDefinition(m_Property).GetMethod, m_Property.DeclaringType)
         End If
 
         Helper.Assert(method IsNot Nothing)
 
         'If m_InstanceExpression IsNot Nothing Then
         '    rside = rside.Clone(m_Property.DeclaringType)
         '    result = m_InstanceExpression.GenerateCode(rside) AndAlso result
         'End If
 
         Dim exp As Expression()
         Dim args As ArgumentList
         Dim expCount As Integer
 
         If m_Parameters IsNot Nothing Then
             expCount = m_Parameters.Count
         End If
         If Info.IsLHS Then
             expCount += 1
         End If
         ReDim exp(expCount - 1)
 
         If m_Parameters IsNot Nothing Then
             'Dim params() As ParameterInfo = Helper.GetParameters(Compiler, method)
             'If Info.IsLHS Then
             '    'Remove the last parameter, it is a setter.
             '    Helper.Assert(params.GetUpperBound(0) >= 0)
             '    Dim tmpParameters As ParameterInfo()
             '    ReDim tmpParameters(params.GetUpperBound(0) - 1)
             '    Array.Copy(params, tmpParameters, tmpParameters.Length)
             '    params = tmpParameters
             'End If
             'result = m_Parameters.GenerateCode(rside, params) AndAlso result
 
             For i As Integer = 0 To m_Parameters.Count - 1
                 exp(i) = m_Parameters(i).Expression
             Next
         End If
 
         If Info.IsLHS Then
             ' rside = rside.Clone(m_Property.PropertyType)
             'result = Info.RHSExpression.GenerateCode(rside) AndAlso result
 
             exp(expCount - 1) = Info.RHSExpression
         End If
 
         'Emitter.EmitCallOrCallVirt(Info, method)
 
         args = New ArgumentList(Me.Parent, exp)
 
         Helper.EmitArgumentsAndCallOrCallVirt(Info, m_InstanceExpression, args, method)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\CaseClauses.vb" startline="66" endline="112">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_When IsNot Nothing Then
             Dim EndWhen, DoWhenComparison As Label
             EndWhen = Emitter.DefineLabel(Info)
             DoWhenComparison = Emitter.DefineLabel(Info)
 
             Emitter.EmitBeginExceptionFilter(Info)
             'Check if the exception object is of type System.Exception.
             Emitter.EmitIsInst(Info, Compiler.TypeCache.System_Object, Compiler.TypeCache.System_Exception)
             Emitter.EmitDup(Info)
             'If True, do the comparison
             Emitter.EmitBranchIfTrue(Info, DoWhenComparison, Compiler.TypeCache.System_Exception)
             'Otherwise load a false value and go to the end of the filter.
             Emitter.EmitPop(Info, Compiler.TypeCache.System_Exception)
             Emitter.EmitLoadValue(Info, False)
             Emitter.EmitBranch(Info, EndWhen)
 
             'Do the when clause.
             Emitter.MarkLabel(Info, DoWhenComparison)
             Emitter.EmitPop(Info, Compiler.TypeCache.System_Exception)
             result = m_When.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean)) AndAlso result
             Emitter.MarkLabel(Info, EndWhen)
             Emitter.EmitBeginCatch(Info, Nothing)
         Else
             Helper.Assert(m_ExceptionType IsNot Nothing)
             Emitter.EmitBeginCatch(Info, m_ExceptionType)
         End If
 
         If m_VariableDeclaration Is Nothing Then
             If m_ExceptionType Is Nothing Then
                 Emitter.EmitPop(Info, Compiler.TypeCache.System_Object)
             Else
                 Emitter.EmitPop(Info, m_ExceptionType)
             End If
         Else
             result = m_VariableDeclaration.GenerateCode(Info) AndAlso result
             Emitter.EmitIsInst(Info, Compiler.TypeCache.System_Object, m_ExceptionType)
             Emitter.EmitStoreVariable(Info, m_VariableDeclaration.LocalBuilder)
         End If
         result = CodeBlock.GenerateCode(Info) AndAlso result
 
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Names\QualifiedIdentifier.vb" startline="56" endline="99">
<![CDATA[
     End Property
 
     Function ResolveAsTypeName(ByVal AsAttributeTypeName As Boolean, Optional ByVal TypeArity As Integer = 0) As Boolean
         Dim result As Boolean = True
         Dim nri As New TypeNameResolutionInfo(Me, Me)
         Dim resolvedType As Mono.Cecil.TypeReference
 
         nri.IsAttributeTypeName = AsAttributeTypeName
         nri.TypeArgumentCount = TypeArity
         result = nri.Resolve() AndAlso result
         If result = False Then Return result
         If nri.FoundOnlyOneObject Then
             If nri.FoundIsType Then
                 resolvedType = nri.FoundAsType
             ElseIf nri.FoundIs(Of TypeParameter)() Then
                 resolvedType = nri.FoundAsType 'New TypeParameterDescriptor(nri.FoundAs(Of TypeParameter)())
             ElseIf nri.FoundIs(Of ImportsClause)() Then
                 Dim ic As ImportsClause = nri.FoundAs(Of ImportsClause)()
                 If ic.IsNamespaceClause Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC30182, Me.Location)
                 ElseIf ic.AsAliasClause.Second.IsNamespaceImport Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC30182, Me.Location)
                 Else
                     resolvedType = ic.AsAliasClause.Second.TypeImported
                     If resolvedType Is Nothing Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC30002, Me.Location, ic.AsAliasClause.Name)
                     End If
                 End If
             Else
                 resolvedType = Nothing
                 Return Helper.AddError(Me, "Could not resolve
             End If
         ElseIf nri.FoundObjects.Count > 1 Then
             resolvedType = Nothing
             Return Helper.AddError(Me, "Could not resolve (>1 results)
         Else
             resolvedType = Nothing
             Return Helper.AddError(Me, "Could not resolve (no result)
         End If
 
         m_ResolvedType = resolvedType
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="23" endline="70">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim opType As TypeCode = MyBase.OperandTypeCode
 
         ValidateBeforeGenerateCode(Info)
 
         Select Case opType
             Case TypeCode.Boolean, TypeCode.Object
                 If opType = TypeCode.Object Then
                     Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 End If
 
                 Dim loadfalse, loadtrue, endexp As Label
                 loadfalse = Emitter.DefineLabel(Info)
                 loadtrue = Emitter.DefineLabel(Info)
                 endexp = Emitter.DefineLabel(Info)
 
                 result = m_LeftExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfFalse(Info, loadfalse)
 
                 result = m_RightExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 Emitter.MarkLabel(Info, loadfalse) '
                 Emitter.EmitLoadValue(Info, False) 'Load false value
                 Emitter.EmitBranch(Info, endexp)
 
                 Emitter.MarkLabel(Info, loadtrue)
                 Emitter.EmitLoadValue(Info, True) 'Load true value
 
                 Emitter.MarkLabel(Info, endexp) 'The end of the expression
                
                 If opType = TypeCode.Object Then
                     Emitter.EmitBox(Info, Compiler.TypeCache.System_Boolean)
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="23" endline="70">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim opType As TypeCode = MyBase.OperandTypeCode
 
         ValidateBeforeGenerateCode(Info)
 
         Select Case opType
             Case TypeCode.Boolean, TypeCode.Object
                 If opType = TypeCode.Object Then
                     Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 End If
 
                 Dim loadfalse, loadtrue, endexp As Label
                 loadfalse = Emitter.DefineLabel(Info)
                 loadtrue = Emitter.DefineLabel(Info)
                 endexp = Emitter.DefineLabel(Info)
 
                 result = m_LeftExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfFalse(Info, loadfalse)
 
                 result = m_RightExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 Emitter.MarkLabel(Info, loadfalse) '
                 Emitter.EmitLoadValue(Info, False) 'Load false value
                 Emitter.EmitBranch(Info, endexp)
 
                 Emitter.MarkLabel(Info, loadtrue)
                 Emitter.EmitLoadValue(Info, True) 'Load true value
 
                 Emitter.MarkLabel(Info, endexp) 'The end of the expression
                
                 If opType = TypeCode.Object Then
                     Emitter.EmitBox(Info, Compiler.TypeCache.System_Boolean)
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="23" endline="70">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim opType As TypeCode = MyBase.OperandTypeCode
 
         ValidateBeforeGenerateCode(Info)
 
         Select Case opType
             Case TypeCode.Boolean, TypeCode.Object
                 If opType = TypeCode.Object Then
                     Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 End If
 
                 Dim loadfalse, loadtrue, endexp As Label
                 loadfalse = Emitter.DefineLabel(Info)
                 loadtrue = Emitter.DefineLabel(Info)
                 endexp = Emitter.DefineLabel(Info)
 
                 result = m_LeftExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfFalse(Info, loadfalse)
 
                 result = m_RightExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 Emitter.MarkLabel(Info, loadfalse) '
                 Emitter.EmitLoadValue(Info, False) 'Load false value
                 Emitter.EmitBranch(Info, endexp)
 
                 Emitter.MarkLabel(Info, loadtrue)
                 Emitter.EmitLoadValue(Info, True) 'Load true value
 
                 Emitter.MarkLabel(Info, endexp) 'The end of the expression
                
                 If opType = TypeCode.Object Then
                     Emitter.EmitBox(Info, Compiler.TypeCache.System_Boolean)
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="23" endline="70">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim opType As TypeCode = MyBase.OperandTypeCode
 
         ValidateBeforeGenerateCode(Info)
 
         Select Case opType
             Case TypeCode.Boolean, TypeCode.Object
                 If opType = TypeCode.Object Then
                     Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 End If
 
                 Dim loadfalse, loadtrue, endexp As Label
                 loadfalse = Emitter.DefineLabel(Info)
                 loadtrue = Emitter.DefineLabel(Info)
                 endexp = Emitter.DefineLabel(Info)
 
                 result = m_LeftExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfFalse(Info, loadfalse)
 
                 result = m_RightExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 Emitter.MarkLabel(Info, loadfalse) '
                 Emitter.EmitLoadValue(Info, False) 'Load false value
                 Emitter.EmitBranch(Info, endexp)
 
                 Emitter.MarkLabel(Info, loadtrue)
                 Emitter.EmitLoadValue(Info, True) 'Load true value
 
                 Emitter.MarkLabel(Info, endexp) 'The end of the expression
                
                 If opType = TypeCode.Object Then
                     Emitter.EmitBox(Info, Compiler.TypeCache.System_Boolean)
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeParameter.vb" startline="171" endline="212">
<![CDATA[
     End Property
 
     Function DefineParameterConstraints() As Boolean
         Dim result As Boolean = True
         Dim attributes As Mono.Cecil.GenericParameterAttributes
 
         If m_Defined Then Return True
         m_Defined = True
 
         attributes = GenericParameterAttributes
 
         If m_TypeParameterConstraints IsNot Nothing Then
             Dim interfaces As New Generic.List(Of Mono.Cecil.TypeReference)
             Dim basetype As Mono.Cecil.TypeReference = Nothing
             For Each constraint As Constraint In m_TypeParameterConstraints.Constraints
                 If constraint.TypeName IsNot Nothing Then
                     If Helper.IsInterface(Compiler, constraint.TypeName.ResolvedType) Then
                         interfaces.Add(constraint.TypeName.ResolvedType)
                     Else
                         If basetype IsNot Nothing Then
                             result = Helper.AddError(Me) AndAlso result
                             result = False
                         Else
                             basetype = constraint.TypeName.ResolvedType
                         End If
                     End If
                 End If
             Next
             If basetype IsNot Nothing Then
                 basetype = Helper.GetTypeOrTypeBuilder(Compiler, basetype)
                 m_CecilBuilder.Constraints.Add(Helper.GetTypeOrTypeReference(Compiler, basetype))
             End If
             If interfaces.Count > 0 Then
                 For i As Integer = 0 To interfaces.Count - 1
                     m_CecilBuilder.Constraints.Add(Helper.GetTypeOrTypeReference(Compiler, interfaces(i)))
                 Next
             End If
         End If
 
         m_CecilBuilder.Attributes = CType(attributes, Mono.Cecil.GenericParameterAttributes)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="47" endline="62">
<![CDATA[
 
     ''' <summary>
     ''' Never returns nothing.
     ''' </summary>
     ''' <param name="Namespace"></param>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Default Shadows ReadOnly Property Item(ByVal [Namespace] As String) As TypeDictionary
         Get
             If MyBase.ContainsKey([Namespace]) Then
                 Return MyBase.Item([Namespace])
             Else
                 Return TypeDictionary.EmptyDictionary
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\RedimClauses.vb" startline="57" endline="65">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = Helper.GenerateCodeCollection(m_Clauses, Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="408" endline="415">
<![CDATA[
 
     Public Overrides Function Equals(ByVal obj As Object) As Boolean
         If TypeOf obj Is Token Then
             Return Equals(DirectCast(obj, Token))
         Else
             Throw New InternalException()
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\InterfaceEventMemberDeclaration.vb" startline="31" endline="38">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceEventModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceEventModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Event)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\InterfaceFunctionDeclaration.vb" startline="36" endline="43">
<![CDATA[
 
     Shared Shadows Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Function)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\InterfacePropertyMemberDeclaration.vb" startline="33" endline="40">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfacePropertyModifier)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfacePropertyModifier)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Property)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\InterfaceSubDeclaration.vb" startline="31" endline="38">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.InterfaceProcedureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Sub)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MustOverridePropertyDeclaration.vb" startline="32" endline="39">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverridePropertyModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.MustOverridePropertyModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Property)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" startline="44" endline="51">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.EventModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.EventModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Event)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\RegularPropertyDeclaration.vb" startline="35" endline="42">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.PropertyModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.PropertyModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Property)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="553" endline="560">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.ClassModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.ClassModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Class)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" startline="177" endline="184">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Delegate)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="54" endline="62">
<![CDATA[
     End Property
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Enum)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\InterfaceDeclaration.vb" startline="76" endline="83">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Interface)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\InterfaceDeclaration.vb" startline="69" endline="76">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.TypeModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Module)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="35" endline="42">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.StructureModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.StructureModifiers)
             i += 1
         End While
         Return tm.PeekToken(i).Equals(KS.Structure)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="1339" endline="1350">
<![CDATA[
 
     Public Shared Function GetMethod(ByVal type As TypeDefinition, ByVal reference As MethodReference) As MethodDefinition
         While type IsNot Nothing
             Dim method As MethodDefinition = GetMethod(type.Methods, reference)
             If method Is Nothing Then
                 type = FindDefinition(type.BaseType)
             Else
                 Return method
             End If
         End While
         While type IsNot Nothing
             Dim method As MethodDefinition = GetMethod(type.Methods, reference)
             If method Is Nothing Then
                 type = FindDefinition(type.BaseType)
             Else
                 Return method
             End If
         End While
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3799" endline="3818">
<![CDATA[
 
     ''' <summary>
     ''' SubSignature  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseSubSignature(ByVal Parent As ParsedObject) As SubSignature
         Dim result As New SubSignature(Parent)
 
         Dim m_Identifier As Identifier = Nothing
         Dim m_TypeParameters As TypeParameters = Nothing
         Dim m_ParameterList As New ParameterList(result)
 
         If ParseSubSignature(result, m_Identifier, m_TypeParameters, m_ParameterList) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         result.Init(m_Identifier, m_TypeParameters, m_ParameterList)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="1199" endline="1212">
<![CDATA[
 
     Public Shared Function FindConstructor(ByVal Methods As Mono.Collections.Generic.Collection(Of MethodDefinition), ByVal [Shared] As Boolean, ByVal parameters() As TypeReference) As MethodReference
         For i As Integer = 0 To Methods.Count - 1
             Dim mr As MethodDefinition = Methods(i)
 
             If mr.IsConstructor = False Then Continue For
             If mr.IsStatic Then
                 If [Shared] Then Return mr
                 Continue For
             End If
             If Helper.CompareTypes(Helper.GetParameterTypes(Compiler.CurrentCompiler, mr), parameters) Then Return mr
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmDiagnostics.vb" startline="81" endline="93">
<![CDATA[
 
     Private Sub LstServices_ItemChecked(ByVal sender As Object, ByVal e As System.Windows.Forms.ItemCheckedEventArgs) Handles LstServices.ItemChecked
 
         On Error Resume Next
         For Index As Byte = 0 To 28
             If LstServices.Items.Item(Index).Checked = True Then
                 BtnFix.Enabled = True
                 Exit Sub
             End If
         Next
         BtnFix.Enabled = False
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="753" endline="781">
<![CDATA[
 
     Shared Function FilterByTypeArguments(ByVal Members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference), ByVal TypeArguments As TypeArgumentList) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim result As New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim argCount As Integer
 
         If TypeArguments IsNot Nothing Then argCount = TypeArguments.Count
 
         For i As Integer = 0 To Members.Count - 1
             Dim member As Mono.Cecil.MemberReference = Members(i)
 
             Dim minfo As Mono.Cecil.MethodReference = TryCast(member, Mono.Cecil.MethodReference)
             If minfo IsNot Nothing Then
                 If CecilHelper.GetGenericArguments(minfo).Count = argCount Then
                     If argCount > 0 Then
                         member = TypeArguments.Parent.Compiler.TypeManager.MakeGenericMethod(TypeArguments.Parent, minfo, CecilHelper.GetGenericArguments(minfo), TypeArguments.ArgumentCollection)
                         result.Add(member)
                     Else
                         result.Add(member)
                     End If
                 Else
                     'Helper.StopIfDebugging()
                 End If
             Else
                 result.Add(member)
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryMinusExpression.vb" startline="64" endline="94">
<![CDATA[
 
     Public Overrides Function GetConstant(ByRef result As Object, ByVal ShowError As Boolean) As Boolean
         If Not Expression.GetConstant(result, ShowError) Then Return False
 
         Select Case Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, result))
             Case TypeCode.SByte
                 result = -CSByte(result)
             Case TypeCode.Int16
                 result = -CShort(result)
             Case TypeCode.Int32
                 result = -CInt(result)
             Case TypeCode.Int64
                 result = -CLng(result)
             Case TypeCode.Byte
             Case TypeCode.UInt16
             Case TypeCode.UInt32
             Case TypeCode.UInt64
                 result = -CULng(result)
             Case TypeCode.Decimal
                 result = -CDec(result)
             Case TypeCode.Double
                 result = -CDbl(result)
             Case TypeCode.Single
                 result = -CSng(result)
             Case Else
                 If ShowError Then Show30059()
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2477" endline="2523">
<![CDATA[
 
     Private Sub frmMain_DragDrop(ByVal sender As Object, _
     ByVal e As System.Windows.Forms.DragEventArgs) _
     Handles MyBase.DragDrop
 
         Dim arr As Array = DirectCast(e.Data.GetData(DataFormats.FileDrop), Array)
         Dim Filename As String
 
         If arr.GetLength(0) = 1 Then
             Filename = Convert.ToString(arr.GetValue(0))
             Try
                 If isValidExtension(Filename) Then
                     OpenFile(Filename)
                 End If
             Catch ex As Exception
                 MsgBox(ex.Message, MsgBoxStyle.Exclamation, "Invalid file format")
             End Try
         Else
             'TODO 
 
             'Clear join list
             lvFiles.Items.Clear()
             Dim j As Integer, ValidFile As String
             For i As Integer = 0 To UBound(arr)
                 Filename = Convert.ToString(arr.GetValue(i))
                 Try
                     If isValidExtension(Filename) Then
                         lvFiles.Items.Add(Filename)
                         j += 1
                         ValidFile = Filename
                     End If
                 Catch ex As Exception
                     MsgBox(ex.Message, MsgBoxStyle.Exclamation, "Invalid file format")
                 End Try
             Next
             If j > 1 Then
                 mainTabs.SelectedTab = tabJoin
             ElseIf j = 1 Then
                 mMaskFile = False
                 OpenFile(ValidFile)
             Else
                 lvFiles.Items.Clear()
                 statMain.Text = mTranslator.LangText(49)
             End If
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="225" endline="265">
<![CDATA[
 
 
     Public Shared Function GetAttributes(ByVal Compiler As Compiler, ByVal m_Declaration As IFieldMember) As Mono.Cecil.FieldAttributes
         Dim result As Mono.Cecil.FieldAttributes
 
         If m_Declaration.Modifiers.Is(ModifierMasks.WithEvents) Then
             result = Mono.Cecil.FieldAttributes.Private
         Else
             result = m_Declaration.Modifiers.GetFieldAttributeScope(DirectCast(m_Declaration, BaseObject).FindFirstParent(Of TypeDeclaration))
         End If
 
         If m_Declaration.Modifiers.Is(ModifierMasks.Static) Then
             result = result Or Mono.Cecil.FieldAttributes.SpecialName
             If DirectCast(m_Declaration, BaseObject).FindFirstParent(Of IMethod).IsShared Then
                 result = result Or Mono.Cecil.FieldAttributes.Static
             End If
         End If
         If m_Declaration.Modifiers.Is(ModifierMasks.Shared) OrElse m_Declaration.IsShared Then
             result = result Or Mono.Cecil.FieldAttributes.Static
         End If
         If TypeOf m_Declaration Is EnumMemberDeclaration Then
             result = result Or Mono.Cecil.FieldAttributes.Static Or Mono.Cecil.FieldAttributes.Literal
         End If
         If TypeOf m_Declaration Is ConstantDeclaration Then
             result = result Or Mono.Cecil.FieldAttributes.Static
             If m_Declaration.FieldType IsNot Nothing Then
                 If Helper.CompareType(m_Declaration.FieldType, Compiler.TypeCache.System_Decimal) Then
                     result = result Or Mono.Cecil.FieldAttributes.InitOnly
                 ElseIf Helper.CompareType(m_Declaration.FieldType, Compiler.TypeCache.System_DateTime) Then
                     result = result Or Mono.Cecil.FieldAttributes.InitOnly
                 Else
                     result = result Or Mono.Cecil.FieldAttributes.Literal Or Mono.Cecil.FieldAttributes.HasDefault
                 End If
             End If
         End If
         If m_Declaration.Modifiers.Is(ModifierMasks.ReadOnly) Then
             result = result Or Mono.Cecil.FieldAttributes.InitOnly
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1170" endline="1220">
<![CDATA[
 
     ''' <summary>
     ''' Loads an value of the desired type onto the evaluation stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Value"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Shared Function EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As Integer) As Boolean
         Helper.Assert(Info.DesiredType IsNot Nothing)
 
         Dim tmp As EmitInfo = Info
         Dim DesiredTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, Info.DesiredType)
 
         Select Case DesiredTypeCode
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Boolean
                 EmitLoadI4Value(Info, Value, Info.DesiredType)
                 Return True
             Case TypeCode.Int64
                 EmitLoadI8Value(Info, Value, Info.DesiredType)
                 Return True
             Case TypeCode.Byte, TypeCode.UInt16
                 EmitLoadI4Value(Info, CUInt(Value), Info.DesiredType)
                 Return True
             Case TypeCode.UInt32
                 If Value <= UInteger.MaxValue AndAlso Value >= UInteger.MinValue Then
                     EmitLoadI4Value(Info, CUInt(Value), Info.DesiredType)
                     Return True
                 End If
             Case TypeCode.UInt64
                 If Value <= ULong.MaxValue AndAlso Value >= ULong.MinValue Then
                     EmitLoadValue(tmp, CULng(Value))
                     Return True
                 End If
             Case TypeCode.Single
                 EmitLoadR4Value(tmp, CSng(Value))
                 Return True
             Case TypeCode.Double
                 EmitLoadR8Value(tmp, CDbl(Value))
                 Return True
             Case TypeCode.Decimal
                 EmitLoadDecimalValue(tmp, CDec(Value))
                 Return True
             Case TypeCode.Object
                 EmitLoadI4Value(tmp, Value)
                 'EmitBox(Info, Info.Compiler.TypeCache.System_Int32)
                 Return True
         End Select
         Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmManual.vb" startline="556" endline="602">
<![CDATA[
 
 #End Region
 
 #Region "Services Information"
 
     Private Sub LstPerformance_SelectedIndexChanged(ByVal sender As Object, ByVal e As System.EventArgs) Handles LstPerformance.SelectedIndexChanged
 
         If My.Settings.ViewInfo = True Then
 
             Dim I, Indx As Integer
             For I = 0 To LstPerformance.SelectedItems.Count - 1
                 Indx = LstPerformance.SelectedItems(I).Index
             Next
 
             If Indx = 0 Then
                 Service_Info("Themes")
             ElseIf Indx = 1 Then
                 Service_Info("UxSms")
             ElseIf Indx = 2 Then
                 Service_Info("ehstart")
             ElseIf Indx = 3 Then
                 Service_Info("WMPNetworkSvc")
             ElseIf Indx = 4 Then
                 Service_Info("WSearch")
             ElseIf Indx = 5 Then
                 Service_Info("PcaSvc")
             ElseIf Indx = 6 Then
                 Service_Info("DPS")
             ElseIf Indx = 7 Then
                 Service_Info("Spooler")
             ElseIf Indx = 8 Then
                 Service_Info("stisvc")
             ElseIf Indx = 9 Then
                 Service_Info("TabletInputService")
             ElseIf Indx = 10 Then
                 Service_Info("SENS")
             ElseIf Indx = 11 Then
                 Service_Info("seclogon")
             ElseIf Indx = 12 Then
                 Service_Info("WerSvc")
             ElseIf Indx = 13 Then
                 Service_Info("defragsvc")
             End If
 
         End If
     
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2248" endline="2294">
<![CDATA[
 
     Private Sub mnuImpComskip_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles mnuImpComskip.Click
 
         Dim sr As System.IO.StreamReader
         Dim Line As String, lvItem As ListViewItem
         Dim TimeStr, TimeEnd, FrameRate As Double
         Dim Temp As String()
         Dim MaxVal As Double = mPlayer.currentMedia.duration
 
         lvPositions.Items.Clear()
         Try
             sr = File.OpenText(StripExtention(mInFile) & ".txt")
             Line = Trim(sr.ReadLine)
             Temp = Split(Line, " ")
             FrameRate = Val(Temp(UBound(Temp))) / 100
             Line = sr.ReadLine
 
             lvItem = lvPositions.Items.Add(SecToMin(0))
             While sr.Peek <> -1
                 Line = sr.ReadLine()
                 Temp = Split(Line, Chr(9))
                 TimeStr = (Val(Temp(0)) - 1) / FrameRate
                 TimeEnd = (Val(Temp(1)) - 1) / FrameRate
 
                 'Validate
                 If (TimeStr > MaxVal) Or (TimeEnd > MaxVal) Then
                     MsgBox("This file has positions outside the extent of the movie." & vbCrLf & "Please check if you have the correct file", _
                     MsgBoxStyle.Exclamation, "Error in reading skip file")
                     Exit Try
                 End If
 
                 'Add item
                 If TimeStr > 0 Then
                     lvItem.SubItems.Add(SecToMin(TimeStr))
                     lvItem = lvPositions.Items.Add(SecToMin(TimeEnd))
                 Else
                     lvItem.Text = SecToMin(TimeEnd)
                 End If
             End While
             While sr.Peek <> -1
                 Line = sr.ReadLine()
                 Temp = Split(Line, Chr(9))
                 TimeStr = (Val(Temp(0)) - 1) / FrameRate
                 TimeEnd = (Val(Temp(1)) - 1) / FrameRate
 
                 'Validate
                 If (TimeStr > MaxVal) Or (TimeEnd > MaxVal) Then
                     MsgBox("This file has positions outside the extent of the movie." & vbCrLf & "Please check if you have the correct file", _
                     MsgBoxStyle.Exclamation, "Error in reading skip file")
                     Exit Try
                 End If
 
                 'Add item
                 If TimeStr > 0 Then
                     lvItem.SubItems.Add(SecToMin(TimeStr))
                     lvItem = lvPositions.Items.Add(SecToMin(TimeEnd))
                 Else
                     lvItem.Text = SecToMin(TimeEnd)
                 End If
             End While
         Catch ex As Exception
             MsgBox("Error reading the Comskip file", MsgBoxStyle.Exclamation, "Error reading the file")
         Finally
             sr.Close()
         End Try
         lvItem.SubItems.Add(SecToMin(MaxVal))
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1767" endline="1839">
<![CDATA[
 
     ''' <summary>
     ''' Checks if the called type is accessible from the caller type.
     ''' </summary>
     ''' <param name="CalledType"></param>
     ''' <param name="CallerType"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function IsAccessible(ByVal Compiler As Compiler, ByVal CalledType As Mono.Cecil.TypeReference, ByVal CallerType As Mono.Cecil.TypeReference) As Boolean
         Dim calledTypeD As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(CalledType)
         Dim callerTypeD As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(CallerType)
 
         If Not Compiler.Assembly.IsDefinedHere(CalledType) Then
             'The types are not in the same assembly, they can only be accessible if the
             'called type is public and all its declaring types are public.
             Dim declType As Mono.Cecil.TypeDefinition = calledTypeD
             Do Until declType Is Nothing
                 If declType.IsPublic = False AndAlso declType.IsNestedPublic = False Then Return False
                 declType = CecilHelper.FindDefinition(declType.DeclaringType)
             Loop
             Do Until declType Is Nothing
                 If declType.IsPublic = False AndAlso declType.IsNestedPublic = False Then Return False
                 declType = CecilHelper.FindDefinition(declType.DeclaringType)
             Loop
             Return True
         End If
 
         'If it is the same type they are obviously accessible.
         If CompareType(CalledType, CallerType) Then Return True
 
         'Now both types are in the same assembly.
 
         'If the called type is not a nested type it is accessible.
         If CalledType.DeclaringType Is Nothing Then Return True
 
         'The caller can descend once into a private type, check if that is the case
         If calledTypeD.IsNestedPrivate Then
             'don't fail here, because could be the private nesting is further up the hierarchy
             If Helper.CompareType(CalledType.DeclaringType, CallerType) Then
                 Return True
             End If
         End If
 
         'Add all the surrounding types of the caller type to a list.
         Dim callerHierarchy As New Generic.List(Of Mono.Cecil.TypeReference)
         Dim tmp As Mono.Cecil.TypeReference = CallerType.DeclaringType
         Do Until tmp Is Nothing
             callerHierarchy.Add(tmp)
             tmp = tmp.DeclaringType
         Loop
         Do Until tmp Is Nothing
             callerHierarchy.Add(tmp)
             tmp = tmp.DeclaringType
         Loop
 
         Dim tmpCaller As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(CalledType.DeclaringType)
         Do Until tmpCaller Is Nothing
             If callerHierarchy.Contains(tmpCaller) Then
                 'The caller can descend once into a private type, check that here.
                 If calledTypeD.IsNestedPrivate Then Return Helper.CompareType(CalledType.DeclaringType, tmpCaller)
 
                 'We've reached a common surrounding type.
                 'No matter what accessibility level this type has 
                 'it is accessible.
                 Return True
             End If
             If tmpCaller.IsNestedPrivate Then
                 'There is a private type here...
                 Return False
             End If
             tmpCaller = CecilHelper.FindDefinition(tmpCaller.DeclaringType)
         Loop
         Do Until tmpCaller Is Nothing
             If callerHierarchy.Contains(tmpCaller) Then
                 'The caller can descend once into a private type, check that here.
                 If calledTypeD.IsNestedPrivate Then Return Helper.CompareType(CalledType.DeclaringType, tmpCaller)
 
                 'We've reached a common surrounding type.
                 'No matter what accessibility level this type has 
                 'it is accessible.
                 Return True
             End If
             If tmpCaller.IsNestedPrivate Then
                 'There is a private type here...
                 Return False
             End If
             tmpCaller = CecilHelper.FindDefinition(tmpCaller.DeclaringType)
         Loop
 
         'If the called type is a private nested type and the above checks failed, it is inaccessible
         If calledTypeD.IsNestedPrivate Then Return Helper.CompareType(CalledType.DeclaringType, CallerType)
 
         'There is no common surrounding type, and the access level of all 
         'surrounding types of the called types are non-private, so the type
         'is accessible.
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Compiler.vb" startline="95" endline="141">
<![CDATA[
 
     ''' <summary>
     ''' Some decent parsing is needed here.
     ''' </summary>
     ''' <remarks></remarks>
     Sub Parse()
         If m_Value = String.Empty Then
             m_ObjectValue = Nothing
             Return
         End If
 
         If Helper.CompareName(m_Value, "Nothing") Then
             m_ObjectValue = Nothing
             Return
         ElseIf Helper.CompareName(m_Value, "True") Then
             m_ObjectValue = True
             Return
         ElseIf Helper.CompareName(m_Value, "False") Then
             m_ObjectValue = False
             Return
         End If
 
         If m_Value.StartsWith("#") Then
             If m_Value.EndsWith("#") Then
                 m_ObjectValue = DateTime.Parse(m_Value.Substring(1, m_Value.Length - 2))
                 Return
             Else
                 Helper.AddError(Compiler, Span.CommandLineSpan, "Invalid date constant
             End If
         End If
 
         If m_Value.StartsWith("""") Then
             If m_Value.EndsWith("""") Then
                 m_ObjectValue = m_Value.Substring(1, m_Value.Length - 2)
                 Return
             Else
                 Helper.AddError(Compiler, Span.CommandLineSpan, "Invalid string constant
             End If
         End If
 
         If True OrElse Microsoft.VisualBasic.IsNumeric(m_Value) Then
             m_ObjectValue = VB.Val(m_Value)
             Return
         End If
 
         Helper.AddError(Compiler, Span.CommandLineSpan, "Invalid constant
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="61" endline="107">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim usingDecls As UsingDeclarators = TryCast(m_UsingResources, UsingDeclarators)
         Dim usingExp As Expression = TryCast(m_UsingResources, Expression)
         Dim usingVars As New Generic.Stack(Of Mono.Cecil.Cil.VariableDefinition)
         Dim exceptionEnds As New Generic.Stack(Of Label)
         Dim exceptionEnds2 As New Generic.Stack(Of Label)
 
         If usingDecls IsNot Nothing Then
             For i As Integer = 0 To usingDecls.Count - 1
                 Dim tmpDecl As UsingDeclarator = usingDecls(i)
                 result = usingDecls(i).GenerateCode(Info) AndAlso result
                 usingVars.Push(tmpDecl.UsingVariable)
                 exceptionEnds.Push(Emitter.EmitBeginExceptionBlock(Info))
                 exceptionEnds2.Push(Emitter.DefineLabel(Info))
             Next
         ElseIf usingExp IsNot Nothing Then
             Dim local As Mono.Cecil.Cil.VariableDefinition = Emitter.DeclareLocal(Info, usingExp.ExpressionType)
             result = usingExp.GenerateCode(Info.Clone(Me, True, False, usingExp.ExpressionType)) AndAlso result
             Emitter.EmitStoreVariable(Info, local)
             usingVars.Push(local)
             exceptionEnds.Push(Emitter.EmitBeginExceptionBlock(Info))
             exceptionEnds2.Push(Emitter.DefineLabel(Info))
         Else
             Throw New InternalException(Me)
         End If
 
         result = CodeBlock.GenerateCode(Info) AndAlso result
 
         Do Until usingVars.Count = 0
             Dim tmpvar As Mono.Cecil.Cil.VariableDefinition = usingVars.Pop
             Dim endblock As Label = exceptionEnds.Pop
             Dim endblock2 As Label = exceptionEnds2.Pop
 
             Info.ILGen.BeginFinallyBlock()
             Emitter.EmitLoadVariable(Info, tmpvar)
             Emitter.EmitBranchIfFalse(Info, endblock2)
             Emitter.EmitLoadVariable(Info, tmpvar)
             Emitter.EmitCallVirt(Info, Compiler.TypeCache.System_IDisposable__Dispose)
             Emitter.MarkLabel(Info, endblock2)
             Info.ILGen.EndExceptionBlock()
         Loop
         Do Until usingVars.Count = 0
             Dim tmpvar As Mono.Cecil.Cil.VariableDefinition = usingVars.Pop
             Dim endblock As Label = exceptionEnds.Pop
             Dim endblock2 As Label = exceptionEnds2.Pop
 
             Info.ILGen.BeginFinallyBlock()
             Emitter.EmitLoadVariable(Info, tmpvar)
             Emitter.EmitBranchIfFalse(Info, endblock2)
             Emitter.EmitLoadVariable(Info, tmpvar)
             Emitter.EmitCallVirt(Info, Compiler.TypeCache.System_IDisposable__Dispose)
             Emitter.MarkLabel(Info, endblock2)
             Info.ILGen.EndExceptionBlock()
         Loop
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="428" endline="479">
<![CDATA[
 
     Public Shared Function ResolveType(ByVal original As TypeReference, ByVal parameters As Mono.Collections.Generic.Collection(Of GenericParameter), ByVal arguments As Mono.Collections.Generic.Collection(Of TypeReference)) As TypeReference
         Dim spec As TypeSpecification = TryCast(original, TypeSpecification)
         Dim array As ArrayType = TryCast(original, ArrayType)
         Dim reference As ByReferenceType = TryCast(original, ByReferenceType)
         Dim genericType As GenericInstanceType = TryCast(original, GenericInstanceType)
 
         If parameters.Count <> arguments.Count Then
             Throw New System.ArgumentException("Parameters and Arguments must have the same number of elements.")
         End If
 
         If spec IsNot Nothing Then
             Dim resolved As TypeReference = ResolveType(spec.ElementType, parameters, arguments)
 
             If genericType IsNot Nothing Then
                 Dim result As GenericInstanceType = New GenericInstanceType(genericType.ElementType)
                 For i As Integer = 0 To genericType.GenericArguments.Count - 1
                     Dim tg As Mono.Cecil.TypeReference = ResolveType(genericType.GenericArguments(i), parameters, arguments)
                     result.GenericArguments.Add(tg)
                 Next
                 Return result
             End If
 
             If resolved Is spec.ElementType Then
                 Return spec
             End If
 
 
             If array IsNot Nothing Then
                 Return New ArrayType(resolved, array.Dimensions.Count)
             ElseIf (reference IsNot Nothing) Then
                 Return New ByReferenceType(resolved)
             Else
                 Throw New System.NotImplementedException()
             End If
         End If
 
         For i As Integer = 0 To parameters.Count - 1
             If parameters(i) Is original Then
                 Return arguments(i)
             End If
         Next
 
         If original.IsNested Then
             Dim parentType As TypeReference = InflateType(original.DeclaringType, parameters, arguments)
             If parentType IsNot original Then
                 Return Compiler.CurrentCompiler.ModuleBuilderCecil.Import(FindDefinition(original))
             End If
         End If
 
         Return original
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="79" endline="127">
<![CDATA[
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Resolve(ByVal DelegateType As Mono.Cecil.TypeReference, ByVal ShowErrors As Boolean) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(DelegateType IsNot Nothing)
 
         If Helper.CompareType(DelegateType, Compiler.TypeCache.DelegateUnresolvedType) Then
             m_DelegateType = DelegateType
             Return True
         End If
 
         If Helper.IsDelegate(Compiler, DelegateType) = False Then
             If ShowErrors Then
                 Compiler.Report.ShowMessage(Messages.VBNC30581, Me.Parent.Location, DelegateType.FullName)
             End If
             Return False
         End If
 
         Dim params As Mono.Collections.Generic.Collection(Of ParameterDefinition) = Helper.GetDelegateArguments(Compiler, DelegateType)
         Dim paramtypes() As Mono.Cecil.TypeReference = Helper.GetParameterTypes(params)
 
         m_ResolvedMethod = CType(Helper.ResolveGroupExact(Me.Parent, m_MethodGroup.Group, paramtypes), Mono.Cecil.MethodReference)
         m_DelegateType = DelegateType
 
         If m_ResolvedMethod Is Nothing Then
             If ShowErrors Then
                 For i As Integer = 0 To m_MethodGroup.Group.Count - 1
                     Compiler.Report.ShowMessage(Messages.VBNC30408, Me.Parent.Location, Helper.ToString(Me.Parent, m_MethodGroup.Group(i)), Helper.ToString(Me.Parent, DelegateType))
                 Next
             End If
             result = False
         Else
             If m_MethodGroup.InstanceExpression Is Nothing AndAlso CecilHelper.IsStatic(m_ResolvedMethod) = False Then
                 If ShowErrors Then
                     Compiler.Report.ShowMessage(Messages.VBNC30469, Parent.Location)
                 End If
                 Return False
             End If
         End If
 
         m_Resolved = True
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CodeFiles.vb" startline="857" endline="907">
<![CDATA[
 
     ''' <summary>
     ''' Reads the specified response file and sends the arguments to pParse.
     ''' </summary>
     Private Function ParseResponseFile(ByVal Filename As String) As Boolean
         If m_lstResponseFiles.Contains(Filename) Then
             Compiler.Report.ShowMessage(Messages.VBNC2014, Span.CommandLineSpan, Filename)
             Return False
         Else
             m_lstResponseFiles.Add(Filename)
         End If
 
         Dim lstArgs As New Specialized.StringCollection
         Dim strLines As String()
 
         If IO.File.Exists(Filename) Then
             'Do nothing
             Filename = IO.Path.GetFullPath(Filename)
         ElseIf IO.File.Exists(IO.Path.GetFullPath(Filename)) Then
             Filename = IO.Path.GetFullPath(Filename)
         Else
 #If DEBUG Then
             Compiler.Report.WriteLine("IO.File.Exists(" & Filename & ") => " & IO.File.Exists(Filename).ToString)
             Compiler.Report.WriteLine("IO.File.Exists(" & IO.Path.GetFullPath(Filename) & ") >= " & IO.File.Exists(IO.Path.GetFullPath(Filename)).ToString)
 #End If
             Compiler.Report.ShowMessage(Messages.VBNC2001, Span.CommandLineSpan, Filename)
             Return False
         End If
 
         Helper.Assert(IO.File.Exists(Filename))
 
         Try
             strLines = IO.File.ReadAllLines(Filename)
         Catch ex As IO.IOException
             Compiler.Report.ShowMessage(Messages.VBNC2007, Span.CommandLineSpan, Filename)
             Return False
         End Try
 
         'Read the file, line by line.
         For Each strLine As String In strLines
             If strLine.StartsWith("#") = False Then 'Skip comment lines
                 lstArgs.AddRange(Helper.ParseLine(strLine))    'Add the parsed elements of the line
             End If
         Next
 
         'Create a string array from the arraylist
         Dim strArgs(lstArgs.Count - 1) As String
         lstArgs.CopyTo(strArgs, 0)
         'Parse the arguments
         Return ParseInternal(strArgs)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\CaseClauses.vb" startline="118" endline="142">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_PreCondition IsNot Nothing Then
             result = m_PreCondition.ResolveExpression(Info) AndAlso result
             result = Helper.VerifyValueClassification(m_PreCondition, Info) AndAlso result
 
             If Me.Location.File(Compiler).IsOptionStrictOn AndAlso Compiler.TypeResolution.IsImplicitlyConvertible(Me, m_PreCondition.ExpressionType, Compiler.TypeCache.System_Boolean) = False Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC30512, m_PreCondition.Location, m_PreCondition.ExpressionType.FullName, "Boolean")
             End If
         End If
 
         If m_PostCondition IsNot Nothing Then
             result = m_PostCondition.ResolveExpression(info) AndAlso result
             result = Helper.VerifyValueClassification(m_PostCondition, Info) AndAlso result
 
             If Me.Location.File(Compiler).IsOptionStrictOn AndAlso Compiler.TypeResolution.IsImplicitlyConvertible(Me, m_PostCondition.ExpressionType, Compiler.TypeCache.System_Boolean) = False Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC30512, m_PostCondition.Location, m_PostCondition.ExpressionType.FullName, "Boolean")
             End If
         End If
         result = CodeBlock.ResolveCode(info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CSngExpression.vb" startline="84" endline="127">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_R4(Info, expType)
             Case TypeCode.Single
                 'Nothing to do
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_R4(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_R4(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitConv_R4(Info, expType)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToSingle_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToSingle_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToSingle_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToSingle_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5486" endline="5543">
<![CDATA[
 
     ''' <summary>
     ''' UsingStatement  
     '''	"Using" UsingResources  StatementTerminator
     '''		[  Block  ]
     '''	"End" "Using" StatementTerminator
     ''' 
     ''' UsingResources  
     ''' 
     ''' LAMESPEC!?
     ''' I'm using this
     ''' UsingResources 
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseUsingStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As UsingStatement
         Dim result As New UsingStatement(Parent)
 
         Dim m_UsingResources As ParsedObject
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.Using)
 
         Dim newDecls As UsingDeclarators = Nothing
         If tm.CurrentToken.IsIdentifier AndAlso tm.PeekToken.Equals(KS.Equals, KS.As) Then
             'This is a variable declaration
             newDecls = New UsingDeclarators(result)
             If ParseList(Of UsingDeclarator)(newDecls, New ParseDelegate_Parent(Of UsingDeclarator)(AddressOf ParseUsingDeclarator), result) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             m_UsingResources = newDecls
         Else
             'This is an expression
             Dim exp As Expression = Nothing
             exp = ParseExpression(result)
             If exp Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             m_UsingResources = exp
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If newDecls IsNot Nothing Then
             For Each decl As UsingDeclarator In newDecls
                 If decl.IsVariableDeclaration Then
                     m_Code.Variables.Add(decl.VariableDeclaration)
                 End If
                 decl.Parent = m_Code
             Next
         End If
 
         If tm.Accept(KS.End, KS.Using) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.Init(m_UsingResources, m_Code)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="106" endline="140">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences(ByVal ResolveTypeParameters As Boolean) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences(ResolveTypeParameters) AndAlso result
         If m_ReturnTypeAttributes IsNot Nothing Then result = m_ReturnTypeAttributes.ResolveTypeReferences AndAlso result
 
         If m_ReturnType Is Nothing Then
             If m_TypeName IsNot Nothing Then
                 result = m_TypeName.ResolveTypeReferences AndAlso result
                 If result = False Then Return result
                 m_ReturnType = m_TypeName.ResolvedType
             ElseIf Identifier.HasTypeCharacter Then
                 m_ReturnType = TypeCharacters.TypeCharacterToType(Compiler, Identifier.TypeCharacter)
             Else
                 If Me.Location.File(Compiler).IsOptionStrictOn Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30210, Me.Location) AndAlso result
                 Else
                     result = Compiler.Report.ShowMessage(Messages.VBNC42024, Me.Location) AndAlso result
                 End If
                 m_ReturnType = Compiler.TypeCache.System_Object
             End If
 
             If result AndAlso m_ReturnType.GenericParameters.Count > 0 Then
                 Dim tmp As New Mono.Cecil.GenericInstanceType(m_ReturnType)
                 For i As Integer = 0 To m_ReturnType.GenericParameters.Count - 1
                     tmp.GenericArguments.Add(m_ReturnType.GenericParameters(i))
                 Next
                 m_ReturnType = tmp
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="123" endline="165">
<![CDATA[
 
     Function GetConstantValue(ByRef result As Object) As Boolean
         Dim obj As Object = Nothing
 
         If m_FieldBuilderCecil.Constant IsNot Nothing Then
             result = m_FieldBuilderCecil.Constant
             Return True
         End If
 
         If m_ConstantExpression IsNot Nothing Then
             If Not m_ConstantExpression.GetConstant(obj, True) Then Return False
         Else
             If m_EnumIndex = 0 Then
                 obj = 0
             ElseIf Not Parent.Constants(m_EnumIndex - 1).GetConstantValue(obj) Then
                 Return False
             Else
                 obj = CDec(obj) + 1
             End If
         End If
 
         Select Case Parent.EnumConstantTypeKeyword
             Case KS.Byte
                 obj = CByte(obj)
             Case KS.SByte
                 obj = CSByte(obj)
             Case KS.Short
                 obj = CShort(obj)
             Case KS.UShort
                 obj = CUShort(obj)
             Case KS.Integer
                 obj = CInt(obj)
             Case KS.UInteger
                 obj = CUInt(obj)
             Case KS.Long
                 obj = CLng(obj)
             Case KS.ULong
                 obj = CULng(obj)
         End Select
 
         result = obj
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="578" endline="650">
<![CDATA[
 
     Public Shared Function GetCorrectMember(ByVal Member As MethodDefinition, ByVal Type As Mono.Cecil.TypeReference, Optional ByVal Emittable As Boolean = False) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim tD As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(Type)
         Dim genericArguments As Mono.Collections.Generic.Collection(Of TypeReference) = Nothing
         Dim genericParameters As Mono.Collections.Generic.Collection(Of GenericParameter) = Nothing
         Dim returnType As Mono.Cecil.TypeReference
         Dim reflectableMember As Mono.Cecil.MethodReference
         Dim declType As TypeReference = Nothing
 
         GetGenericArgsAndParams(Type, genericParameters, genericArguments)
 
         'If genericType Is Nothing Then
         '    Dim declType As TypeReference = Type
         '    While declType.IsNested
         '        Dim genType As GenericInstanceType = TryCast(declType, Mono.Cecil.GenericInstanceType)
         '        If genType IsNot Nothing Then
         '            If genericArguments Is Nothing Then genericArguments = New GenericArgumentCollection(Nothing)
         '            For Each arg As TypeReference In genType.GenericArguments
         '                genericArguments.Add(arg)
         '            Next
         '        End If
         '    End While
         '    Return Member
         'Else
         '    genericArguments = genericType.GenericArguments
         '    genericParameters = tD.GenericParameters
         'End If
 
         If genericParameters Is Nothing AndAlso genericArguments Is Nothing AndAlso tD Is Type AndAlso tD.Module Is Compiler.CurrentCompiler.ModuleBuilderCecil Then
             Return Member
         End If
 
         If Emittable Then
             returnType = Member.ReturnType
         Else
             returnType = CecilHelper.InflateType(Member.ReturnType, genericParameters, genericArguments)
         End If
         result = New Mono.Cecil.MethodReference(Member.Name, Type, returnType, Member.HasThis, Member.ExplicitThis, Member.CallingConvention)
         reflectableMember = New Mono.Cecil.MethodReference(Member.Name, Type, returnType, Member.HasThis, Member.ExplicitThis, Member.CallingConvention)
         reflectableMember.OriginalMethod = Member
         result.OriginalMethod = Member
 
         'If Member.DeclaringType.GenericParameters.Count > 0 AndAlso Not False Then
         '    Dim tmp As New GenericInstanceType(Member.DeclaringType)
         '    For i As Integer = 0 To Member.DeclaringType.GenericParameters.Count - 1
         '        tmp.GenericArguments.Add(Member.DeclaringType.GenericParameters(i))
         '    Next
         '    result.DeclaringType = tmp
         'End If
 
         For i As Integer = 0 To Member.Parameters.Count - 1
             Dim pD As Mono.Cecil.ParameterDefinition = Member.Parameters(i)
             Dim pDType As Mono.Cecil.TypeReference
             pDType = InflateType(pD.ParameterType, genericParameters, genericArguments)
             If pDType IsNot pD.ParameterType Then
                 Dim newPD As Mono.Cecil.ParameterDefinition
                 Dim pd2 As Mono.Cecil.TypeReference
                 pDType = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, pDType)
                 newPD = New ParameterDefinition(pD.Name, pD.Attributes, pDType)
                 result.Parameters.Add(newPD)
                 pd2 = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, pD.ParameterType)
                 reflectableMember.Parameters.Add(New ParameterDefinition(pD.Name, pD.Attributes, pd2))
             Else
                 result.Parameters.Add(pD)
                 reflectableMember.Parameters.Add(pD)
             End If
         Next
 
         result.Annotations.Add("MemberInReflection", reflectableMember)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4042" endline="4086">
<![CDATA[
 
     Private Function ParseInterfaceMemberSpecifier(ByVal Parent As ParsedObject) As InterfaceMemberSpecifier
         Dim result As New InterfaceMemberSpecifier(Parent)
 
         Dim m_NonArrayTypeName As NonArrayTypeName = Nothing
         Dim m_1 As NonArrayTypeName = Nothing
         Dim m_2 As IdentifierOrKeyword = Nothing
 
         m_NonArrayTypeName = ParseNonArrayTypeName(result)
 
         If tm.Accept(KS.Dot) Then
             m_1 = m_NonArrayTypeName
             m_2 = ParseIdentifierOrKeyword(result)
             If m_2 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         ElseIf m_NonArrayTypeName.IsSimpleTypeName AndAlso m_NonArrayTypeName.AsSimpleTypeName.IsQualifiedIdentifier Then
             Dim stn As SimpleTypeName = m_NonArrayTypeName.AsSimpleTypeName
             Dim qi As QualifiedIdentifier = stn.AsQualifiedIdentifier
             m_1 = m_NonArrayTypeName
             If Token.IsSomething(qi.Second) Then
                 m_2 = New IdentifierOrKeyword(result, qi.Second)
                 qi.Second = Nothing
             Else
                 Helper.AddError(Compiler, tm.CurrentLocation)
             End If
         ElseIf m_NonArrayTypeName.IsConstructedTypeName Then
             Dim constructedTypeName As ConstructedTypeName = m_NonArrayTypeName.AsConstructedTypeName
             If constructedTypeName.QualifiedIdentifier IsNot Nothing AndAlso constructedTypeName.ConstructedTypeName IsNot Nothing AndAlso constructedTypeName.TypeArgumentList Is Nothing Then
                 If constructedTypeName.QualifiedIdentifier.IsFirstIdentifier AndAlso Token.IsSomething(constructedTypeName.QualifiedIdentifier.Second) = False Then
                     m_1 = New NonArrayTypeName(result)
                     m_1.Init(constructedTypeName.ConstructedTypeName)
                     m_2 = New IdentifierOrKeyword(result, constructedTypeName.QualifiedIdentifier.FirstAsIdentifier.Identifier, KS.None)
                 Else
                     Helper.AddError(Compiler, tm.CurrentLocation)
                 End If
             Else
                 Helper.AddError(Compiler, tm.CurrentLocation)
             End If
         Else
             Helper.AddError(Compiler, tm.CurrentLocation)
         End If
 
         result.Init(m_1, m_2)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\ConstraintList.vb" startline="30" endline="65">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         Dim hasClass, hasStructure, hasNew As Boolean
 
         For Each constraint As Constraint In Me
             result = constraint.ResolveTypeReferences AndAlso result
             Select Case constraint.Special
                 Case KS.None
                 Case KS.Class
                     If hasClass Then
                         result = Compiler.Report.ShowMessage(Messages.VBNC32101, Location) AndAlso result
                     End If
                     hasClass = True
                 Case KS.Structure
                     If hasStructure Then
                         result = Compiler.Report.ShowMessage(Messages.VBNC32102, Location) AndAlso result
                     End If
                     hasStructure = True
                 Case KS.[New]
                     hasNew = True
             End Select
 
         Next
 
         If hasNew AndAlso hasStructure Then
             result = Compiler.Report.ShowMessage(Messages.VBNC32103, Location) AndAlso result
         End If
 
         If hasStructure AndAlso hasClass Then
             result = Compiler.Report.ShowMessage(Messages.VBNC32104, Location) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\RMhandler.vb" startline="126" endline="162">
<![CDATA[
 
     Public Overloads Overrides Function Split(ByVal Filename As String, _
     ByVal Duration As Double, ByVal MediaDuration As Double) As Boolean
         MyBase.Split(Filename, Duration, MediaDuration)
 
         If MediaDuration = 0 Then Exit Function
         If Duration = 0 Then Exit Function
 
         Dim Pieces As Integer = CInt(Fix(MediaDuration / Duration))
         Dim Temp As String = String.Empty
         Dim PieceFile As String = String.Empty
 
         If MediaDuration Mod Duration > 0 Then Pieces += 1
         Filename = AddDefaultPathIfNeeded(StripExtension(Filename))
         For i As Integer = 0 To Pieces - 1
             PieceFile = Filename & CStr(i + 1).PadLeft(4, "0"c) & ".rm"
             Temp = " -i " & Chr(34) & mInFile & Chr(34) & " -o " & Chr(34) & PieceFile & Chr(34)
             Temp += " -s " + CFmt(Duration * i, True) + " -e " + CFmt(Math.Min(Duration * (i + 1), MediaDuration), True)
 
             '-i input.rm -o output.rm -s start -e end
             RunConverter(Temp)
             Threading.Thread.Sleep(500)
         Next
 
         Try
             Threading.Thread.Sleep(1000)
             Dim di As New IO.DirectoryInfo(GetDefaultDir)
             If di.GetFiles(StripPath(StripExtension(Filename)) & "*").Length >= Pieces Then
                 Return True
             Else
                 Return False
             End If
         Catch ex As Exception
             'Some disk exception
         End Try
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\OperatorDeclaration.vb" startline="254" endline="290">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_ConstantExpression, m_TypeName, m_ParameterIdentifier) AndAlso result
         If m_CustomAttributes IsNot Nothing Then result = m_CustomAttributes.ResolveTypeReferences AndAlso result
 
         If result = False Then Return result
 
         'If ParameterType Is Nothing Then
         If m_TypeName IsNot Nothing Then
             ParameterType = m_TypeName.ResolvedType
             If m_ParameterIdentifier.ArrayNameModifier IsNot Nothing Then
                 If m_TypeName.IsArrayTypeName Then
                     Helper.AddError(Me)
                 Else
                     ParameterType = m_ParameterIdentifier.ArrayNameModifier.CreateArrayType(ParameterType)
                 End If
             End If
         ElseIf m_ParameterIdentifier.Identifier.HasTypeCharacter Then
             ParameterType = TypeCharacters.TypeCharacterToType(Compiler, m_ParameterIdentifier.Identifier.TypeCharacter)
         ElseIf ParameterType Is Nothing OrElse Helper.CompareType(ParameterType, Compiler.TypeCache.System_Void) Then
             If Me.Location.File(Compiler).IsOptionStrictOn Then
                 Helper.AddError(Me, "Parameter type must be specified.")
             Else
                 Helper.AddWarning("Parameter type should be specified.")
             End If
             ParameterType = Compiler.TypeCache.System_Object
         End If
         'End If
         Helper.Assert(ParameterType IsNot Nothing)
         If m_Modifiers.Is(ModifierMasks.ByRef) Then
             ParameterType = Compiler.TypeManager.MakeByRefType(Me, ParameterType)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\EnumDeclaration.vb" startline="79" endline="115">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
         If EnumConstantType Is Nothing Then
             If EnumType IsNot Nothing Then
                 result = EnumType.ResolveTypeReferences AndAlso result
                 If result = False Then Return False
                 EnumConstantType = EnumType.ResolvedType
             Else
                 EnumConstantType = Compiler.TypeCache.System_Int32
             End If
         End If
         If Helper.CompareType(Compiler.TypeCache.System_Byte, EnumConstantType) Then
             EnumConstantTypeKeyword = KS.Byte
         ElseIf Helper.CompareType(EnumConstantType, Compiler.TypeCache.System_SByte) Then
             EnumConstantTypeKeyword = KS.SByte
         ElseIf Helper.CompareType(EnumConstantType, Compiler.TypeCache.System_UInt16) Then
             EnumConstantTypeKeyword = KS.UShort
         ElseIf Helper.CompareType(EnumConstantType, Compiler.TypeCache.System_Int16) Then
             EnumConstantTypeKeyword = KS.Short
         ElseIf Helper.CompareType(EnumConstantType, Compiler.TypeCache.System_UInt32) Then
             EnumConstantTypeKeyword = KS.UInteger
         ElseIf Helper.CompareType(EnumConstantType, Compiler.TypeCache.System_Int32) Then
             EnumConstantTypeKeyword = KS.Integer
         ElseIf Helper.CompareType(EnumConstantType, Compiler.TypeCache.System_UInt64) Then
             EnumConstantTypeKeyword = KS.ULong
         ElseIf Helper.CompareType(EnumConstantType, Compiler.TypeCache.System_Int64) Then
             EnumConstantTypeKeyword = KS.Long
         Else
             result = Compiler.Report.ShowMessage(Messages.VBNC30650, Me.Location)
         End If
         m_ValueField.FieldType = Helper.GetTypeOrTypeReference(Compiler, EnumConstantType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="1815" endline="1883">
<![CDATA[
 
     ''' <summary>
     ''' AddHandlerDeclaration  
     '''	[  Attributes  ]  "AddHandler" "(" ParameterList ")" LineTerminator
     '''	[  Block  ]
     '''	"End" "AddHandler" StatementTerminator
     ''' 
     ''' RemoveHandlerDeclaration  
     '''	[  Attributes  ]  "RemoveHandler" "("  ParameterList  ")"  LineTerminator
     '''	[  Block  ]
     '''	"End" "RemoveHandler" StatementTerminator
     ''' 
     ''' LAMESPEC
     ''' RemoveHandlerDeclaration  
     '''	[  Attributes  ]  "RemoveHandler" "("  [ ParameterList  ] ")"  LineTerminator
     '''	[  Block  ]
     '''	"End" "RemoveHandler" StatementTerminator
     ''' 
     ''' RaiseEventDeclaration  
     '''	[  Attributes  ]  "RaiseEvent" (  ParameterList  )  LineTerminator
     '''	[  Block  ]
     '''	"End" "RaiseEvent" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseCustomEventHandlerDeclaration(ByVal Parent As EventDeclaration, ByVal Info As ParseAttributableInfo, ByVal EventName As Identifier, ByVal EventModifiers As Modifiers) As CustomEventHandlerDeclaration
         Dim result As New CustomEventHandlerDeclaration(Parent)
 
         Dim m_ParameterList As New ParameterList(result)
         Dim m_Block As CodeBlock
         Dim m_HandlerType As KS
         Dim m_Modifiers As Modifiers
 
         If tm.CurrentToken.Equals(KS.AddHandler, KS.RemoveHandler, KS.RaiseEvent) Then
             m_HandlerType = tm.CurrentToken.Keyword
             tm.NextToken()
         Else
             Throw New InternalException(result)
         End If
 
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.RParenthesis) = False Then
             If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Block = ParseCodeBlock(result, False)
         If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, m_HandlerType) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If m_ParameterList Is Nothing Then m_ParameterList = New ParameterList(result)
 
         If m_HandlerType = KS.RaiseEvent Then
             m_Modifiers = New Modifiers(ModifierMasks.Private)
         Else
             m_Modifiers = EventModifiers
         End If
 
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_ParameterList, m_Block, m_HandlerType, EventName)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ErrorStatement.vb" startline="45" endline="90">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Select Case m_ExitWhat
             Case KS.Sub
                 Emitter.EmitRetOrLeave(Info, Me, False)
             Case KS.Function
                 Dim func As FunctionDeclaration = TryCast(m_Container, FunctionDeclaration)
                 If func IsNot Nothing Then
                     Emitter.EmitLoadVariable(Info, func.DefaultReturnVariable)
                     Emitter.EmitRetOrLeave(Info, Me, False)
                 Else
                     Throw New InternalException(Me)
                 End If
             Case KS.Property
                 Dim propGet As PropertyGetDeclaration = TryCast(m_Container, PropertyGetDeclaration)
                 Dim propSet As PropertySetDeclaration = TryCast(m_Container, PropertySetDeclaration)
                 If propget IsNot Nothing Then
                     Emitter.EmitLoadVariable(Info, propGet.DefaultReturnVariable)
                     Emitter.EmitRetOrLeave(Info, Me, False)
                 ElseIf propSet IsNot Nothing Then
                     Emitter.EmitRetOrLeave(Info, Me, False)
                 Else
                     Throw New InternalException(Me)
                 End If
             Case KS.Select
                 Dim destinationStmt As SelectStatement
                 destinationStmt = DirectCast(m_Container, SelectStatement)
                 Emitter.EmitBranchOrLeave(Info, destinationStmt.EndLabel, Me, destinationStmt)
             Case KS.While, KS.Do, KS.For, KS.Try
                 Dim destinationStmt As BlockStatement
                 destinationStmt = TryCast(m_Container, BlockStatement)
                 If destinationStmt IsNot Nothing Then
                     Dim lblStatement As Statement
                     lblStatement = destinationStmt.FindFirstParent(Of Statement)()
                     Emitter.EmitBranchOrLeave(Info, destinationStmt.EndLabel, Me, lblStatement)
                 Else
                     Throw New InternalException(Me)
                 End If
             Case Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="682" endline="693">
<![CDATA[
 
     Private Function IsLineContinuation() As Boolean
         If Not (CurrentChar() = " "c AndAlso PeekChar() = "_"c) Then Return False
 
         Dim i As Integer = 2
         Do Until IsNewLine(PeekChars(i))
             If IsWhiteSpace(PeekChars(i)) = False Then Return False
             i += 1
         Loop
         Do Until IsNewLine(PeekChars(i))
             If IsWhiteSpace(PeekChars(i)) = False Then Return False
             i += 1
         Loop
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\MainForm.cs" startline="418" endline="435">
<![CDATA[
 
 		protected void UpdatePluginListView()
 		{
 			pluginListView.Items.Clear();
 
 			foreach(Plugin plugin in pluginManager.Plugins)
 			{
 				ListViewItem row = new ListViewItem(plugin.Name);
 				ListViewItem.ListViewSubItem lvsi1 = new ListViewItem.ListViewSubItem(row, plugin.Enabled.ToString());
 				row.SubItems.Add(lvsi1);
 				pluginListView.Items.Add(row);
 
 				if(!plugin.Enabled)
 				{
                     row.ForeColor = Color.Silver;
 				}
 			}
 			foreach(Plugin plugin in pluginManager.Plugins)
 			{
 				ListViewItem row = new ListViewItem(plugin.Name);
 				ListViewItem.ListViewSubItem lvsi1 = new ListViewItem.ListViewSubItem(row, plugin.Enabled.ToString());
 				row.SubItems.Add(lvsi1);
 				pluginListView.Items.Add(row);
 
 				if(!plugin.Enabled)
 				{
                     row.ForeColor = Color.Silver;
 				}
 			}
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="922" endline="930">
<![CDATA[
 
     Public Shared Function GetGenericArguments(ByVal Type As Mono.Cecil.TypeReference) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim tR As Mono.Cecil.GenericInstanceType = TryCast(Type, Mono.Cecil.GenericInstanceType)
         If tR Is Nothing Then
             Return GetTypes(Type.GenericParameters)
         Else
             Return GetTypes(tR.GenericArguments)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="931" endline="939">
<![CDATA[
 
     Public Shared Function GetGenericArguments(ByVal Method As Mono.Cecil.MethodReference) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim mR As Mono.Cecil.GenericInstanceMethod = TryCast(Method, Mono.Cecil.GenericInstanceMethod)
         If mR Is Nothing Then
             Return GetTypes(Method.GenericParameters)
         Else
             Return GetTypes(mR.GenericArguments)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\Constraint.vb" startline="51" endline="67">
<![CDATA[
     End Property
 
     ReadOnly Property SpecialConstraintAttribute() As Mono.Cecil.GenericParameterAttributes
         Get
             Select Case m_Special
                 Case KS.[New]
                     Return Mono.Cecil.GenericParameterAttributes.DefaultConstructorConstraint
                 Case KS.Class
                     Return Mono.Cecil.GenericParameterAttributes.ReferenceTypeConstraint
                 Case KS.Structure
                     Return Mono.Cecil.GenericParameterAttributes.NotNullableValueTypeConstraint
                 Case KS.None
                     Return Mono.Cecil.GenericParameterAttributes.NonVariant
                 Case Else
                     Throw New InternalException(Me)
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="185" endline="198">
<![CDATA[
 
     Private Function CreateImplicitTypes(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = CreateImplicitTypes(NestedType) AndAlso result
         Next
 
         For Each Member As IHasImplicitTypes In Type.Members.GetSpecificMembers(Of IHasImplicitTypes)()
             result = Member.CreateImplicitTypes() AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="414" endline="427">
<![CDATA[
 
     Private Function CreateImplicitMembers(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         For Each NestedType As TypeDeclaration In Type.Members.GetSpecificMembers(Of TypeDeclaration)()
             result = CreateImplicitMembers(NestedType) AndAlso result
         Next
 
         For Each Member As IHasImplicitMembers In Type.Members.GetSpecificMembers(Of IHasImplicitMembers)()
             result = Member.CreateImplicitMembers() AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="291" endline="297">
<![CDATA[
 
     Public Function CreateAndEmitNop() As Mono.Cecil.Cil.Instruction
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         CilWorker.Append(result)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmGameMode.vb" startline="381" endline="388">
<![CDATA[
 
     Private Sub BWGameMode_DoWork(ByVal sender As System.Object, ByVal e As System.ComponentModel.DoWorkEventArgs) Handles BWGameMode.DoWork
         If GameMode() = True Then
             GameModeClass.GamingOff()
         ElseIf GameMode() = False Then
             GameModeClass.GamingOn()
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="77" endline="90">
<![CDATA[
     End Property
 
     Function GetSpecificMembers(Of T)() As Generic.List(Of T)
         Dim result As New Generic.List(Of T)
 
         For i As Integer = 0 To Count - 1
             Dim obj As IMember = Me.Item(i)
             If TypeOf obj Is T Then
                 result.Add(CType(CObj(obj), T))
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4308" endline="4317">
<![CDATA[
 
     Shared Function ArgumentsToExpressions(ByVal Arguments As Generic.List(Of Argument)) As Expression()
         Dim result(Arguments.Count - 1) As Expression
 
         For i As Integer = 0 To Arguments.Count - 1
             result(i) = Arguments(i).Expression
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AttributePositionalArgumentList.vb" startline="44" endline="52">
<![CDATA[
 
     ReadOnly Property AsExpressions() As Expression()
         Get
             Dim result(Me.Count - 1) As Expression
             For i As Integer = 0 To Me.Count - 1
                 result(i) = Item(i).Expression
             Next
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ParameterList.vb" startline="81" endline="89">
<![CDATA[
     End Property
 
     Function ToTypeArray() As Mono.Cecil.TypeReference()
         Dim result(Me.Count - 1) As Mono.Cecil.TypeReference
         For i As Integer = 0 To Me.Count - 1
             result(i) = Me.Item(i).ParameterType
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeParameterList.vb" startline="37" endline="46">
<![CDATA[
 
     Function AsTypeArray() As Mono.Cecil.TypeReference()
         Dim result(Me.Count - 1) As Mono.Cecil.TypeReference
 
         For i As Integer = 0 To Me.Count - 1
             result(i) = Item(i).CecilBuilder
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="821" endline="828">
<![CDATA[
 
     Shared Function FilterByName(ByVal Types As TypeList, ByVal Name As String) As TypeList
         Dim result As New TypeList
         For Each obj As Mono.Cecil.TypeReference In Types
             If Helper.CompareName(Name, obj.Name) Then result.Add(obj)
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\MPGhandler.vb" startline="90" endline="106">
<![CDATA[
 
 
     Private Function GetFileJoinCommand() As String
 
         Dim Temp As String = "-j "
 
         For i As Integer = 0 To UBound(mJoinFiles)
             Temp += Chr(34) + mJoinFiles(i) + Chr(34) + " "
         Next
 
         Temp += " -o " + Chr(34) + mOutFile + Chr(34) + " -f"
         If Options("ForceJoin") = "True" Then
             Temp += " --force"
         End If
         Return Temp
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="354" endline="372">
<![CDATA[
 
     ''' <summary>
     ''' Finds all the public non-nested types in the referenced assemblies and loads them into the lists.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function LoadReferencedTypes() As Boolean
         For Each ass As Mono.Cecil.AssemblyDefinition In CecilAssemblies
             Dim types As Mono.Collections.Generic.Collection(Of TypeDefinition) = ass.MainModule.Types
             For i As Integer = 0 To types.Count - 1
                 Dim type As TypeDefinition = types(i)
                 If Type.IsPublic Then
                     LoadType(Type)
                 End If
             Next
         Next
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Compiler.vb" startline="983" endline="1010">
<![CDATA[
 
     ''' <summary>
     ''' Returns the directory where the system assemblies are installed
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function GetSystemDir() As String
         Dim assemblies() As Reflection.Assembly
         Dim result As String
 
         If Not String.IsNullOrEmpty(CommandLine.SDKPath) Then
             If CommandLine.Verbose Then Report.WriteLine(string.Format ("Using alternate system path
             Return CommandLine.SDKPath
         End If
 
         assemblies = AppDomain.CurrentDomain.GetAssemblies
 
         For Each a As Reflection.Assembly In assemblies
             Dim codebase As String = a.Location
             If codebase.EndsWith("corlib.dll") Then
                 result = codebase.Substring(0, codebase.LastIndexOf(System.IO.Path.DirectorySeparatorChar))
                 If CommandLine.Verbose Then Report.WriteLine(String.Format("Using system path
                 Return result
             End If
         Next
         Throw New InternalException("Cannot compute the system directory.")
         Return ""
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="349" endline="361">
<![CDATA[
 
     Shared Function GetGenericParameters(ByVal Member As MemberReference) As Mono.Collections.Generic.Collection(Of GenericParameter)
         Dim methodReference As MethodReference
         Dim typeReference As TypeReference
 
         methodReference = TryCast(Member, MethodReference)
         If methodReference IsNot Nothing Then Return CecilHelper.FindDefinition(methodReference).GenericParameters
 
         typeReference = TryCast(Member, TypeReference)
         If typeReference IsNot Nothing Then Return CecilHelper.FindDefinition(typeReference).GenericParameters
 
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeImplementsClauses.vb" startline="78" endline="85">
<![CDATA[
 
     Function FoundIs(Of Type)() As Boolean
         If FoundOnlyOneObject Then
             Return TypeOf FoundObject Is Type
         Else
             Throw New InternalException("")
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AliasClause.vb" startline="239" endline="257">
<![CDATA[
 
     Private Function GetRegularInitializer(ByVal indices As Generic.List(Of Integer)) As Expression
         Dim ai As ArrayElementInitializer = Me
         Dim result As Expression
 
         Dim index As Integer
         For i As Integer = 0 To indices.Count - 2
             index = indices(i)
             Helper.Assert(ai.m_VariableInitializerList.List.ToArray.Length > index)
             Helper.Assert(ai.m_VariableInitializerList.List.ToArray()(index).IsArrayElementInitializer)
             ai = ai.m_VariableInitializerList.List.ToArray()(index).AsArrayElementInitializer
         Next
         index = indices(indices.Count - 1)
         Helper.Assert(ai.m_VariableInitializerList.List.ToArray.Length > index)
         Helper.Assert(ai.m_VariableInitializerList.List.ToArray()(index).IsRegularInitializer)
         result = ai.m_VariableInitializerList.List.ToArray()(index).AsRegularInitializer
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\CustomEventHandlerDeclaration.vb" startline="53" endline="62">
<![CDATA[
 
     Public Overrides Function CreateDefinition() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.CreateDefinition AndAlso result
 
         MyBase.MethodImplAttributes = Mono.Cecil.MethodImplAttributes.IL Or Mono.Cecil.MethodImplAttributes.Managed
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="380" endline="387">
<![CDATA[
 
     Private Function IsPropertyHandlesHandler() As Boolean
         Dim propD As PropertyDeclaration
 
         propD = TryCast(Parent, PropertyDeclaration)
         If propD Is Nothing Then Return False
         Return propD.HandlesField IsNot Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CByteExpression.vb" startline="39" endline="48">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CCharExpression.vb" startline="68" endline="77">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CDateExpression.vb" startline="71" endline="80">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CDblExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CDecExpression.vb" startline="34" endline="43">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="39" endline="48">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CLngExpression.vb" startline="39" endline="48">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CSByteExpression.vb" startline="39" endline="48">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CShortExpression.vb" startline="39" endline="48">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CSngExpression.vb" startline="39" endline="48">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" startline="39" endline="47">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CUIntExpression.vb" startline="39" endline="48">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CULngExpression.vb" startline="39" endline="48">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CUShortExpression.vb" startline="39" endline="48">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="30" endline="38">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
         result = Validate(Info, Expression) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="280" endline="291">
<![CDATA[
 
     ''' <summary>
     ''' Checks for this grammar
     ''' VariableMemberDeclaration  
     ''' </summary>
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim i As Integer
         While tm.PeekToken(i).Equals(ModifierMasks.VariableModifiers)
             i += 1
         End While
         While tm.PeekToken(i).Equals(ModifierMasks.VariableModifiers)
             i += 1
         End While
         Return i > 0 AndAlso tm.PeekToken(i).IsIdentifier
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="721" endline="734">
<![CDATA[
 
     Shared Function IsPrivate(ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Dim mD As Mono.Cecil.MethodDefinition
 
         mD = TryCast(Method, Mono.Cecil.MethodDefinition)
 
         If mD IsNot Nothing Then Return mD.IsPrivate
 
         mD = CecilHelper.FindDefinition(Method)
 
         If mD IsNot Nothing Then Return mD.IsPrivate
 
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="735" endline="748">
<![CDATA[
 
     Shared Function IsFamilyOrAssembly(ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Dim mD As Mono.Cecil.MethodDefinition
 
         mD = TryCast(Method, Mono.Cecil.MethodDefinition)
 
         If mD IsNot Nothing Then Return mD.IsFamilyOrAssembly
 
         mD = CecilHelper.FindDefinition(Method)
 
         If mD IsNot Nothing Then Return mD.IsFamilyOrAssembly
 
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="91" endline="97">
<![CDATA[
 
     Function HasSpecificMember(Of T)() As Boolean
         For i As Integer = 0 To Count - 1
             If TypeOf Me.Item(i) Is T Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="1133" endline="1145">
<![CDATA[
 
     Public Shared Function IsReferenceTypeOrGenericReferenceTypeParameter(ByVal Type As TypeReference) As Boolean
         Dim tg As GenericParameter = TryCast(Type, GenericParameter)
         Dim td As TypeDefinition
 
         If tg IsNot Nothing Then
             If tg.HasReferenceTypeConstraint Then Return True
             Return False
         End If
 
         td = FindDefinition(Type)
         Return (td.IsInterface OrElse td.IsClass) AndAlso td.IsValueType = False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3356" endline="3364">
<![CDATA[
 
     Private Sub CopySelected()
         With lvPositions
             ReDim mItems(.SelectedItems.Count - 1)
             For i As Integer = 0 To .SelectedItems.Count - 1
                 mItems(i) = .SelectedItems(i)
             Next
         End With
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\PartialTypeDeclaration.vb" startline="80" endline="94">
<![CDATA[
 
     ''' <summary>
     ''' Checks that all types are equal.
     ''' Returns nothing if types are not equal.
     ''' </summary>
     ''' <param name="Types"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function CheckUniqueType(ByVal Types() As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Helper.Assert(Types.Length >= 1)
         For i As Integer = 1 To Types.Length - 1
             If Helper.CompareType(Types(0), Types(i)) = False Then Return Nothing
         Next
         Return Types(0)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\DotAccessExpression.vb" startline="118" endline="134">
<![CDATA[
 
     Function IsSharedContext() As Boolean
         Dim p As ParsedObject
         Dim td As TypeDeclaration
         Dim md As MethodDeclaration
 
         p = Parent
         While p IsNot Nothing
             md = TryCast(p, MethodDeclaration)
             If md IsNot Nothing Then Return md.IsShared
             td = TryCast(p, TypeDeclaration)
             If td IsNot Nothing Then Return td.IsShared
             p = p.Parent
         End While
         While p IsNot Nothing
             md = TryCast(p, MethodDeclaration)
             If md IsNot Nothing Then Return md.IsShared
             td = TryCast(p, TypeDeclaration)
             If td IsNot Nothing Then Return td.IsShared
             p = p.Parent
         End While
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="322" endline="336">
<![CDATA[
 
     Private Function CreateDelegateMembers(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
         Dim dd As DelegateDeclaration = TryCast(Type, DelegateDeclaration)
 
         If dd IsNot Nothing Then result = dd.CreateDelegateMembers() AndAlso result
 
         For i As Integer = 0 To Type.Members.Count - 1
             Dim t As TypeDeclaration = TryCast(Type.Members(i), TypeDeclaration)
             If t Is Nothing Then Continue For
             result = CreateDelegateMembers(t) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="398" endline="413">
<![CDATA[
 
     Private Function CreateMyGroupMembers(ByVal Type As TypeDeclaration) As Boolean
         Dim cd As ClassDeclaration
         Dim result As Boolean = True
 
         cd = TryCast(Type, ClassDeclaration)
         If cd IsNot Nothing Then result = cd.CreateMyGroupMembers() AndAlso result
 
         For i As Integer = 0 To Type.Members.Count - 1
             Dim t As TypeDeclaration = TryCast(Type.Members(i), TypeDeclaration)
             If t Is Nothing Then Continue For
             result = CreateMyGroupMembers(t) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\AssignStatements\CompoundAssignmentStatement.vb" startline="42" endline="72">
<![CDATA[
 
     Private Function ResolveIndexedStatement(ByVal Info As ResolveInfo, ByVal InvocationExpression As InvocationOrIndexExpression) As Boolean
         Dim result As Boolean = True
         Dim block As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
 
         For i As Integer = 0 To InvocationExpression.ArgumentList.Count - 1
             Dim arg As Argument = InvocationExpression.ArgumentList(i)
             Dim exp As Expression = arg.Expression
             Dim newExp As VariableExpression
             Dim varDecl As LocalVariableDeclaration
             Dim stmt As AssignmentStatement
 
             varDecl = New LocalVariableDeclaration(arg)
             varDecl.Init(Nothing, "VB$tmp", exp.ExpressionType)
             block.AddVariable(varDecl)
 
             newExp = New VariableExpression(arg, varDecl)
 
             stmt = New AssignmentStatement(Me.Parent)
             stmt.Init(newExp, exp)
             block.AddStatementBefore(stmt, Me)
 
             arg.Expression = newExp
         Next
 
         If InvocationExpression.Classification.IsVariableClassification Then
             result = CheckIndexedStatement(Info, TryCast(InvocationExpression.Classification.AsVariableClassification.ArrayVariable, InvocationOrIndexExpression)) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ParameterList.vb" startline="56" endline="65">
<![CDATA[
 
     Function DefineOptionalParameters() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To Me.Count - 1
             result = Item(i).DefineOptionalParameters AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\BaseList.vb" startline="41" endline="50">
<![CDATA[
 
     Public Overrides Function CreateDefinition() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_List.Count - 1
             result = m_List(i).CreateDefinition() AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="58" endline="65">
<![CDATA[
 
     Shared Function GetTypeCharacter(ByVal chr As String) As LiteralTypeCharacters_Characters
         chr = chr.ToUpperInvariant
         For i As Integer = 0 To m_Characters.GetUpperBound(0)
             If m_Characters(i).Equals(chr, StringComparison.Ordinal) Then Return CType(i + 1, LiteralTypeCharacters_Characters)
         Next
         Return LiteralTypeCharacters_Characters.None
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="125" endline="136">
<![CDATA[
 
     Public Shared Function IsValidType(ByVal type As TypeReference) As Boolean
         Dim arrayType As ArrayType
 
         If type Is Nothing Then Return True
         If TypeOf type Is PointerType Then Return False
 
         arrayType = TryCast(type, ArrayType)
         If arrayType IsNot Nothing AndAlso IsValidType(arrayType.ElementType) = False Then Return False
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="334" endline="341">
<![CDATA[
 
     Function IsValidCandidate(ByVal candidate As MemberCandidate) As Boolean
         If CecilHelper.IsValidType(candidate.ReturnType) = False Then Return False
         For j As Integer = 0 To candidate.DefinedParametersTypes.Length - 1
             If CecilHelper.IsValidType(candidate.DefinedParametersTypes(j)) = False Then Return False
         Next
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="286" endline="298">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveBaseType() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To Me.Members.Count - 1
             Dim t As TypeDeclaration = TryCast(Members(i), TypeDeclaration)
             If t Is Nothing Then Continue For
             result = t.ResolveBaseType AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="240" endline="271">
<![CDATA[
 
     ''' <summary>
     ''' Parses clauses seen on the command line.
     ''' ImportsClauses  
     ''' </summary>
     ''' <param name="str"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function ParseImportsClauses(ByVal Parent As ImportsClauses, ByVal str As String) As Boolean
         Dim result As Boolean = True
 
         For Each clause As String In str.Split(","c)
             If clause <> "" Then
                 Dim newClause As ImportsClause
                 newClause = ParseImportsClause(Parent, str)
                 If newClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(Parent.Location)
                 If Parent.Exists(newClause) Then
                     If newClause.IsNamespaceClause Then '
                         'ignore the duplication
                     ElseIf newClause.IsAliasClause Then
                         Parent.Compiler.Report.SaveMessage(Messages.VBNC30572, Span.CommandLineSpan, newClause.AsAliasClause.Name)
                     Else
                         Throw New InternalException("")
                     End If
                 Else
                     Parent.Add(newClause)
                 End If
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="1073" endline="1080">
<![CDATA[
 
     Public Shared Function GetElementType(ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Dim rT As ByReferenceType = TryCast(Type, ByReferenceType)
         If rT IsNot Nothing Then Return rT.ElementType
         Dim aT As Mono.Cecil.ArrayType = TryCast(Type, Mono.Cecil.ArrayType)
         If aT IsNot Nothing Then Return aT.ElementType
         Throw New InternalException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\BoundList.vb" startline="261" endline="268">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ConversionOperatorDeclaration.vb" startline="67" endline="74">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\CustomEventHandlerDeclaration.vb" startline="63" endline="70">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\CustomEventHandlerDeclaration.vb" startline="75" endline="82">
<![CDATA[
 
     Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveMember(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\EventAccessorDeclarations.vb" startline="184" endline="191">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="54" endline="61">
<![CDATA[
 
     Public Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveMember(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="412" endline="419">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="727" endline="736">
<![CDATA[
 
     Public Shared Function GetAssemblyRef(ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.AssemblyNameReference
         Dim modDef As ModuleDefinition = TryCast(Type.Scope, ModuleDefinition)
         If modDef IsNot Nothing Then Return modDef.Assembly.Name
 
         Dim assemblyRef As Mono.Cecil.AssemblyNameReference = TryCast(Type.Scope, AssemblyNameReference)
         If assemblyRef IsNot Nothing Then Return assemblyRef
 
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="865" endline="872">
<![CDATA[
 
     Public Shared Function IsDefined(ByVal CustomAttributes As Mono.Collections.Generic.Collection(Of CustomAttribute), ByVal Type As TypeReference) As Boolean
         For i As Integer = 0 To CustomAttributes.Count - 1
             Dim Attribute As CustomAttribute = CustomAttributes(i)
             If Helper.CompareType(Attribute.Constructor.DeclaringType, Type) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="471" endline="481">
<![CDATA[
     End Property
 
     ReadOnly Property HasInstanceConstructors() As Boolean
         Get
             For i As Integer = 0 To Me.Members.Count - 1
                 Dim cd As ConstructorDeclaration = TryCast(Me.Members(i), ConstructorDeclaration)
                 If cd Is Nothing Then Continue For
                 If cd.IsShared = False Then Return True
             Next
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4399" endline="4410">
<![CDATA[
 
     Shared Function IsLiteral0Expression(ByVal Compiler As Compiler, ByVal exp As Expression) As Boolean
         Dim constant As Object = Nothing
 
         If exp Is Nothing Then Return False
         Dim litExp As LiteralExpression = TryCast(exp, LiteralExpression)
         If litExp Is Nothing Then Return False
         If litExp.GetConstant(constant, False) = False Then Return False
         If Compiler.TypeResolution.IsIntegralType(CecilHelper.GetType(Compiler, constant)) = False Then Return False
         If CDbl(constant) = 0.0 Then Return True
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1791" endline="1804">
<![CDATA[
 
     Private Shared Function GetFieldRef(ByVal field As Mono.Cecil.FieldReference) As Mono.Cecil.FieldReference
         Dim gFD As Mono.Cecil.FieldDefinition = TryCast(field, Mono.Cecil.FieldDefinition)
 
         If gFD IsNot Nothing AndAlso gFD.DeclaringType.GenericParameters.Count > 0 Then
             Dim declType As Mono.Cecil.GenericInstanceType
             declType = New Mono.Cecil.GenericInstanceType(gFD.DeclaringType)
             For i As Integer = 0 To gFD.DeclaringType.GenericParameters.Count - 1
                 declType.GenericArguments.Add(gFD.DeclaringType.GenericParameters(i))
             Next
             Return New Mono.Cecil.FieldReference(field.Name, field.FieldType, declType)
         End If
         Return field
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="532" endline="563">
<![CDATA[
 
     Private Function DefineOptionalParameters(ByVal Type As TypeDeclaration) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To Type.Members.Count - 1
             Dim nestedType As TypeDeclaration = TryCast(Type.Members(i), TypeDeclaration)
             If nestedType IsNot Nothing Then
                 result = DefineOptionalParameters(nestedType) AndAlso result
                 Continue For
             End If
 
             Dim method As MethodBaseDeclaration = TryCast(Type.Members(i), MethodBaseDeclaration)
             If method IsNot Nothing Then
                 result = method.DefineOptionalParameters AndAlso result
                 Continue For
             End If
 
             Dim prop As PropertyDeclaration = TryCast(Type.Members(i), PropertyDeclaration)
             If prop IsNot Nothing Then
                 result = prop.Signature.Parameters.DefineOptionalParameters AndAlso result
                 If prop.SetDeclaration IsNot Nothing Then
                     result = prop.SetDeclaration.Signature.Parameters.DefineOptionalParameters AndAlso result
                 End If
                 If prop.GetDeclaration IsNot Nothing Then
                     result = prop.GetDeclaration.Signature.Parameters.DefineOptionalParameters AndAlso result
                 End If
                 Continue For
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AttributeArgumentExpression.vb" startline="47" endline="54">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\EventHandlesList.vb" startline="125" endline="132">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\FunctionSignature.vb" startline="47" endline="54">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_List.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\AssignStatements\SubtractionAssignStatement.vb" startline="47" endline="62">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         '#If DEBUG Then
         '        Dim m1, m2 As MethodInfo
         '        m1 = Me.GetType.GetMethod("ResolveTypeReferences")
         '        m2 = GetType(BlockStatement).GetMethod("ResolveTypeReferences")
         '        Helper.Assert(m1 IsNot m2)
         '#End If
 
         result = m_Code.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\EndStatement.vb" startline="64" endline="71">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_Targets.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeParameterConstraints.vb" startline="64" endline="71">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_ConstraintList.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="93" endline="100">
<![CDATA[
 
     Shared Function GetTypeCharacter(ByVal chr As Characters) As String
         If chr <> Characters.None Then
             Return m_Characters.Chars(chr)
         Else
             Return ""
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="338" endline="352">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Compares this token to any of the specified tokens. 
     ''' Returns true if any token matches.
     ''' </summary>
     ''' <param name="AnySpecial"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Overloads Function Equals(ByVal AnySpecial() As KS) As Boolean
         For i As Integer = 0 To VB.UBound(AnySpecial)
             If Equals(AnySpecial(i)) = True Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="362" endline="371">
<![CDATA[
 
     Shared Function GetGenericParameterConstraints(ByVal Context As BaseObject, ByVal Type As Mono.Cecil.TypeReference) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim tG As Mono.Cecil.GenericParameter = TryCast(Type, Mono.Cecil.GenericParameter)
 
         If tG IsNot Nothing Then Return tG.Constraints
 
         Dim tD As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(Type)
         If CecilHelper.IsGenericParameter(Type) = False Then Throw New InternalException("")
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmSrvcMngr.vb" startline="362" endline="379">
<![CDATA[
 
 #End Region
 
 #Region "Functions"
 
     Private Shared Function Startup(ByVal Name As String) As String
 
         If Common.Service_Startup(Name) = 2 Then
             Startup = "Automatic"
         ElseIf Common.Service_Startup(Name) = 3 Then
             Startup = "Manual"
         ElseIf Common.Service_Startup(Name) = 4 Then
             Startup = "Disabled"
         Else
             Startup = "Unknown"
         End If
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Modules\Common.vb" startline="49" endline="62">
<![CDATA[
 
     Private Function Check_Service(ByVal Name As String) As String
 
         If Service_Startup(Name) = 2 Then
             Check_Service = ("1!")
         ElseIf Service_Startup(Name) = 3 Then
             Check_Service = ("2!")
         ElseIf Service_Startup(Name) = 4 Then
             Check_Service = ("3!")
         Else
             Check_Service = ("4!")
         End If
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\ConstructedTypeName.vb" startline="200" endline="220">
<![CDATA[
 
     Function VerifyConstraints(ByVal ShowErrors As Boolean) As Boolean
         Dim result As Boolean = True
 
         Dim parameters As Mono.Collections.Generic.Collection(Of GenericParameter)
         Dim arguments As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim git As GenericInstanceType
         Dim td As TypeDefinition
 
         git = TryCast(m_ResolvedType, GenericInstanceType)
         td = CecilHelper.FindDefinition(git)
 
         If git Is Nothing OrElse td Is Nothing Then Return True
 
         parameters = td.GenericParameters
         arguments = git.GenericArguments
 
         result = Helper.VerifyConstraints(Me, parameters, arguments, ShowErrors)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="199" endline="208">
<![CDATA[
 
     Function ResolveBaseTypes() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To m_TypeDeclarations.Length - 1
             result = m_TypeDeclarations(i).ResolveBaseType() AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeConverter.vb" startline="551" endline="563">
<![CDATA[
 
     Shared Function GetUnaryResultType(ByVal op As KS, ByVal op1 As TypeCode) As TypeCode
         Select Case op
             Case KS.Add
                 Return GetUnaryPlusResultType(op1)
             Case KS.Minus
                 Return GetUnaryMinusResultType(op1)
             Case KS.Not
                 Return GetUnaryNotResultType(op1)
             Case Else
                 Throw New NotImplementedException()
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeConverter.vb" startline="615" endline="627">
<![CDATA[
 
     Shared Function GetUnaryOperandType(ByVal op As KS, ByVal operand As TypeCode) As TypeCode
         Select Case op
             Case KS.Add
                 Return GetUnaryPlusResultType(operand)
             Case KS.Minus
                 Return GetUnaryMinusResultType(operand)
             Case KS.Not
                 Return GetUnaryNotResultType(operand)
             Case Else
                 Throw New NotImplementedException
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2037" endline="2044">
<![CDATA[
 
     Shared Function IsTypeConvertibleToAny(ByVal TypeToSearch As Mono.Cecil.TypeReference, ByVal TypesToFind As Mono.Collections.Generic.Collection(Of TypeReference)) As Boolean
         For i As Integer = 0 To TypesToFind.Count - 1
             Dim t As Mono.Cecil.TypeReference = TypesToFind(i)
             If Helper.CompareType(t, TypeToSearch) OrElse Helper.IsSubclassOf(TypeToSearch, t) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2045" endline="2052">
<![CDATA[
 
     Shared Function IsTypeConvertibleToAny(ByVal TypesToSearch As Mono.Collections.Generic.Collection(Of TypeReference), ByVal TypeToFind As Mono.Cecil.TypeReference) As Boolean
         For i As Integer = 0 To TypesToSearch.Count - 1
             Dim t As Mono.Cecil.TypeReference = TypesToSearch(i)
             If Helper.CompareType(t, TypeToFind) OrElse Helper.IsSubclassOf(TypeToFind, t) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\MRUbuffer.vb" startline="65" endline="75">
<![CDATA[
 
     Public Function toXML() As XmlNode
         Dim Doc As New XmlDocument, Node As XmlNode
         Doc.LoadXml("<RecentFiles/>")
         For i As Integer = 0 To mLen - 1
             Node = Doc.CreateElement("File")
             Node.InnerText = mList(i)
             Doc.DocumentElement.AppendChild(Node)
         Next
         Return Doc.DocumentElement
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2029" endline="2036">
<![CDATA[
 
     Shared Function IsTypeConvertibleToAny(ByVal TypesToSearch As Mono.Cecil.TypeReference(), ByVal TypeToFind As Mono.Cecil.TypeReference) As Boolean
         For i As Integer = 0 To TypesToSearch.Length - 1
             Dim t As Mono.Cecil.TypeReference = TypesToSearch(i)
             If Helper.CompareType(t, TypeToFind) OrElse Helper.IsSubclassOf(t, TypeToFind) Then Return True
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="334" endline="348">
<![CDATA[
 
     Shared Function GetParameterTypes(ByVal Context As BaseObject, ByVal member As Mono.Cecil.MemberReference) As Mono.Cecil.TypeReference()
         Dim params As Mono.Collections.Generic.Collection(Of ParameterDefinition) = GetParameters(Context, member)
         Dim result() As Mono.Cecil.TypeReference
 
         If params Is Nothing Then Return Nothing
 
         ReDim result(params.Count - 1)
 
         For i As Integer = 0 To params.Count - 1
             result(i) = params(i).ParameterType
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Compiler.vb" startline="41" endline="55">
<![CDATA[
 
     Function IsDefined(ByVal str As String) As Boolean
         Dim def As Define
         def = Item(str)
         If def Is Nothing Then Return False
 
         If def.Value <> "" Then
             Dim b As Boolean
             If Boolean.TryParse(def.Value, b) Then Return b
             If VB.IsNumeric(def.Value) Then Return CBool(CDbl(def.Value))
             Return False
         End If
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1659" endline="1673">
<![CDATA[
 
     Shared Function GetUnaryOperators(ByVal Compiler As Compiler, ByVal Op As UnaryOperators, ByVal Type As Mono.Cecil.TypeReference) As Generic.List(Of Mono.Cecil.MethodReference)
         Dim opNameAlternatives As String() = Nothing
 
         Select Case Op
             Case UnaryOperators.Add
                 opNameAlternatives = New String() {"op_UnaryPlus"}
             Case UnaryOperators.Minus
                 opNameAlternatives = New String() {"op_UnaryNegation"}
             Case UnaryOperators.Not
                 opNameAlternatives = New String() {"op_OnesComplement", "op_LogicalNot"}
         End Select
 
         Return GetOperators(Compiler, opNameAlternatives, Type)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="229" endline="252">
<![CDATA[
 
     ''' <summary>
     ''' Helper to construct a message for a multiline message when every line after the first one
     ''' is the same message. Message() must be an array with two elements, FirstParameters() is applied
     ''' to the first one, then the second element is multiplied by the number of SubsequentParameters()
     ''' and then a message is created with the corresponding SubsequentParameters() for every line after the 
     ''' first one.
     ''' </summary>
     <Diagnostics.DebuggerHidden()> _
     Sub ShowMessageHelper(ByVal Message() As Messages, ByVal Location As Span, ByVal FirstParameters() As String, ByVal SubsequentParameters() As String)
         Dim msg() As Messages
         Dim params()() As String
 
         ReDim msg(SubsequentParameters.Length)
         ReDim params(SubsequentParameters.Length)
         msg(0) = Message(0)
         params(0) = FirstParameters
         For i As Integer = 1 To msg.GetUpperBound(0)
             msg(i) = Message(1)
             params(i) = New String() {SubsequentParameters(i - 1)}
         Next
 
         ShowMessage(msg, Location, params)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4601" endline="4625">
<![CDATA[
 
     ''' <summary>
     ''' Gets the parameters in the definition (not inflated)
     ''' </summary>
     ''' <param name="Member"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Shared Function GetOriginalParameters(ByVal Member As Mono.Cecil.MemberReference) As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Dim mR As Mono.Cecil.MethodReference = TryCast(Member, Mono.Cecil.MethodReference)
         If mR IsNot Nothing Then Return CecilHelper.FindDefinition(mR).Parameters
 
         Dim pR As Mono.Cecil.PropertyReference = TryCast(Member, Mono.Cecil.PropertyReference)
         If pR IsNot Nothing Then Return CecilHelper.FindDefinition(pR).Parameters
 
         Dim tR As Mono.Cecil.TypeReference = TryCast(Member, Mono.Cecil.TypeReference)
         If tR IsNot Nothing Then Return Nothing
 
         Dim fR As Mono.Cecil.FieldReference = TryCast(Member, Mono.Cecil.FieldReference)
         If fR IsNot Nothing Then Return Nothing
 
         Dim eR As Mono.Cecil.EventReference = TryCast(Member, Mono.Cecil.EventReference)
         If eR IsNot Nothing Then Return CecilHelper.FindDefinition(eR).InvokeMethod.Parameters()
 
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2762" endline="2779">
<![CDATA[
 
     Shared Function IsSubclassOf(ByVal BaseClass As Mono.Cecil.TypeReference, ByVal DerivedClass As Mono.Cecil.TypeReference) As Boolean
         If TypeOf BaseClass Is Mono.Cecil.GenericParameter Xor TypeOf DerivedClass Is Mono.Cecil.GenericParameter Then Return False
         If TypeOf DerivedClass Is ArrayType Then
             If Helper.CompareType(BaseClass, Compiler.CurrentCompiler.TypeCache.System_Array) Then Return True
             Return False
         End If
         If TypeOf BaseClass Is Mono.Cecil.ArrayType Or TypeOf DerivedClass Is Mono.Cecil.ArrayType Then Return False
         Dim base As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(BaseClass)
         Dim derived As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(DerivedClass)
         Dim current As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(derived.BaseType)
 
         Do While current IsNot Nothing
             If Helper.CompareType(current, base) Then Return True
             current = CecilHelper.FindDefinition(CecilHelper.FindDefinition(current).BaseType)
         Loop
         Do While current IsNot Nothing
             If Helper.CompareType(current, base) Then Return True
             current = CecilHelper.FindDefinition(CecilHelper.FindDefinition(current).BaseType)
         Loop
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1634" endline="1658">
<![CDATA[
 
     Shared Function GetOperators(ByVal Compiler As Compiler, ByVal Names() As String, ByVal Type As Mono.Cecil.TypeReference) As Generic.List(Of Mono.Cecil.MethodReference)
         Dim result As New Generic.List(Of Mono.Cecil.MethodReference)
 
         'Dim members() As MemberInfo
         Dim members As Generic.List(Of Mono.Cecil.MemberReference)
         members = Compiler.TypeManager.GetCache(Type).GetAllFlattenedMembers(MemberVisibility.All)
 
         For i As Integer = 0 To Names.Length - 1
             Dim testName As String = Names(i)
             For m As Integer = 0 To members.Count - 1
                 Dim member As MemberReference = members(m)
                 Dim mR As Mono.Cecil.MethodReference = TryCast(member, Mono.Cecil.MethodReference)
                 If mR IsNot Nothing Then
                     Dim mD As Mono.Cecil.MethodDefinition = CecilHelper.FindDefinition(mR)
                     If mD.IsSpecialName AndAlso Helper.CompareName(mD.Name, testName) AndAlso mD.IsStatic Then
                         result.Add(mR)
                     End If
                 End If
             Next
             If result.Count > 0 Then Exit For
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1361" endline="1382">
<![CDATA[
 
 
     Shared Function IsShadows(ByVal Context As BaseObject, ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Dim result As Boolean = True
         Select Case CecilHelper.GetMemberType(Member)
             Case MemberTypes.Method, MemberTypes.Constructor
                 Return CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.MethodReference)).IsHideBySig = False
             Case MemberTypes.Property
                 Return CBool(Helper.GetPropertyAttributes(DirectCast(Member, Mono.Cecil.PropertyReference)) And Mono.Cecil.MethodAttributes.HideBySig) = False
             Case MemberTypes.Field
                 Return True
             Case MemberTypes.TypeInfo
                 Return True
             Case MemberTypes.NestedType
                 Return True
             Case MemberTypes.Event
                 Return CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.EventReference)).AddMethod.IsHideBySig = False
             Case Else
                 Context.Compiler.Report.ShowMessage(Messages.VBNC99997, Context.Location)
         End Select
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="678" endline="706">
<![CDATA[
 
     ''' <summary>
     ''' Checks if the member is Friend (not Protected Friend)
     ''' </summary>
     ''' <param name="Member"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function GetAccessibility(ByVal Member As Mono.Cecil.MemberReference) As ModifierMasks
         Helper.Assert(Member IsNot Nothing)
         If TypeOf Member Is Mono.Cecil.MethodReference Then
             Return GetVisibility(CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.MethodReference)).Attributes)
         ElseIf TypeOf Member Is Mono.Cecil.TypeReference Then
             Return GetVisibility(CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.TypeReference)).Attributes)
         ElseIf TypeOf Member Is Mono.Cecil.EventReference Then
             Dim eD As Mono.Cecil.EventDefinition = CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.EventReference))
             If eD.AddMethod IsNot Nothing Then Return GetVisibility(eD.AddMethod.Attributes)
             If eD.RemoveMethod IsNot Nothing Then Return GetVisibility(eD.RemoveMethod.Attributes)
             If eD.InvokeMethod IsNot Nothing Then Return GetVisibility(eD.InvokeMethod.Attributes)
             Return 0
         ElseIf TypeOf Member Is Mono.Cecil.FieldReference Then
             Dim fD As Mono.Cecil.FieldDefinition = CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.FieldReference))
             Return GetVisibility(fD.Attributes)
         ElseIf TypeOf Member Is Mono.Cecil.PropertyReference Then
             Dim pD As Mono.Cecil.PropertyDefinition = CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.PropertyReference))
             Return GetVisibility(GetPropertyAccess(pD))
         Else
             Throw New NotImplementedException
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\LateBoundAccessToPropertyAccessExpression.vb" startline="26" endline="33">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Me.Classification = New PropertyAccessClassification(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\LateBoundAccessToValueExpression.vb" startline="26" endline="33">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Me.Classification = New ValueClassification(Me)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\MethodGroupToValueExpression.vb" startline="36" endline="43">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitLoadMe(Info, ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\MethodGroupToValueExpression.vb" startline="31" endline="39">
<![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Emitter.EmitLoadMe(Info, ExpressionType)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="127" endline="142">
<![CDATA[
 
     Public Shared Function GetAttributes(ByVal m_Declaration As ConstructorDeclaration) As Mono.Cecil.MethodAttributes
         Dim flags As Mono.Cecil.MethodAttributes
         flags = Mono.Cecil.MethodAttributes.SpecialName Or Mono.Cecil.MethodAttributes.RTSpecialName
 
         'LAMESPEC
         'VBC
         'VBC
         If m_Declaration.IsShared Then
             flags = flags Or Mono.Cecil.MethodAttributes.Private Or Mono.Cecil.MethodAttributes.Static
         Else
             flags = flags Or m_Declaration.Modifiers.GetMethodAttributeScope
         End If
 
         Return flags
     End Function
]]>
</clone_fragment>
<clone_fragment file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="242" endline="256">
<![CDATA[
     End Property
 
     Function FindLabel(ByVal Name As Token) As LabelDeclarationStatement
         Dim cb As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
         If cb IsNot Nothing Then
             Return cb.FindLabel(Name)
         Else
             For Each l As LabelDeclarationStatement In m_Labels
                 If l.Label.Equals(Name) Then
                     Return l
                 End If
             Next
         End If
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\CMPT890\CS VB JS examples\Examples\VB.NET\examples\MainModule.vb" startline="44" endline="81">
<![CDATA[
 
     Private Shared StopOnError As Boolean = False
 
     Public Shared Sub Main(ByVal args As String())
         Dim ClassName As String = Nothing
         Dim aargs(args.Length) As String
 
         Dim i As Integer
 
         For i = 0 To args.Length - 1
             aargs(i) = args(i)
         Next
         aargs(args.Length) = String.Empty
         args = aargs
 
         For i = 0 To args.Length - 1
             Dim opt As String = args(i)
             If opt = String.Empty Then GoTo 100
             If Left$(opt, 1) = "/" Then
                 Dim uopt As String = opt.ToUpper()
                 If uopt = "/STOP-ON-ERROR" Then
                     StopOnError = True
                 Else
                     Throw New ArgumentException("ArgumentException", opt)
                 End If
             Else
                 ClassName = opt
             End If
 100
         Next
         If ClassName = Nothing Then ClassName = "All"
 
         If ClassName = "All" Then
             Call ExecuteAllExamples()
         Else
             Call ExecuteExample(ClassName)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MemberCache.vb" startline="542" endline="553">
<![CDATA[
 
     ''' <summary>
     ''' This function returns the members list in the cache, or nothing
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function LookupFlattenedMembers(ByVal Name As String) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim cache As MemberCacheEntry = LookupFlattened(Name)
         If cache Is Nothing Then Return Nothing
         Return cache.Members
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="471" endline="477">
<![CDATA[
     End Property
 
     ReadOnly Property SpecialString() As String
         Get
             If TypeOf m_TokenObject Is KS Then Return DirectCast(m_TokenObject, KS).ToString()
             Return "not a symbol"
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4582" endline="4600">
<![CDATA[
 
     Overloads Shared Function GetParameters(ByVal Context As BaseObject, ByVal Member As Mono.Cecil.MemberReference) As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Dim mR As Mono.Cecil.MethodReference = TryCast(Member, Mono.Cecil.MethodReference)
         If mR IsNot Nothing Then Return mR.ResolvedParameters
 
         Dim pR As Mono.Cecil.PropertyReference = TryCast(Member, Mono.Cecil.PropertyReference)
         If pR IsNot Nothing Then Return CecilHelper.FindDefinition(pR).Parameters
 
         Dim tR As Mono.Cecil.TypeReference = TryCast(Member, Mono.Cecil.TypeReference)
         If tR IsNot Nothing Then Return Nothing
 
         Dim fR As Mono.Cecil.FieldReference = TryCast(Member, Mono.Cecil.FieldReference)
         If fR IsNot Nothing Then Return Nothing
 
         Dim eR As Mono.Cecil.EventReference = TryCast(Member, Mono.Cecil.EventReference)
         If eR IsNot Nothing Then Return CecilHelper.FindDefinition(eR).InvokeMethod.Parameters()
 
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="209" endline="220">
<![CDATA[
 
     ReadOnly Property AsString() As String
         Get
             Dim result As String = ""
             Dim sep As String = ""
 
             For Each arg As Argument In m_Arguments
                 result = result & sep & arg.AsString
                 sep = ", "
             Next
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="221" endline="233">
<![CDATA[
     End Property
 
     ReadOnly Property ArgumentsTypesAsString() As String
         Get
             Dim result As String = ""
             Dim sep As String = ""
 
             For Each arg As Argument In m_Arguments
                 result = result & sep & arg.AsTypeString
                 sep = ", "
             Next
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="47" endline="57">
<![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         For Each exp As Expression In m_Initializers
             result = exp.ResolveExpression(Info) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="4162" endline="4173">
<![CDATA[
 
     Private Sub LoadLangList()
 
         Dim Temp() As String = mTranslator.Languages
 
         cbLang.Items.Clear()
         For i As Integer = 0 To UBound(Temp)
             cbLang.Items.Add(Temp(i))
             If Temp(i) = mTranslator.Language Then cbLang.SelectedIndex = i
         Next
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="261" endline="286">
<![CDATA[
 
     Private Sub CreateDefaultCtorCall()
         Dim type As TypeDeclaration = Me.FindFirstParent(Of TypeDeclaration)()
         Dim classtype As ClassDeclaration = TryCast(type, ClassDeclaration)
         Dim defaultctor As Mono.Cecil.MethodReference
         If classtype IsNot Nothing Then
             defaultctor = classtype.GetBaseDefaultConstructor()
             If defaultctor IsNot Nothing AndAlso Helper.IsPrivate(defaultctor) = False Then
                 If Helper.IsPrivate(defaultctor) OrElse (Helper.IsFriend(defaultctor) AndAlso Not Compiler.Assembly.IsDefinedHere(defaultctor.DeclaringType)) Then
                     Helper.AddError(Me, "Base class does not have an accessible default constructor")
                 Else
                     m_DefaultBaseConstructor = defaultctor
 
 #If DEBUG Then
                     Try
                         For Each param As Mono.Cecil.ParameterDefinition In m_DefaultBaseConstructor.Parameters
                             Helper.Assert(param.IsOptional)
                         Next
                     Catch ex As Exception
                         Helper.Assert(False)
                     End Try
 #End If
                 End If
             End If
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CodeFiles.vb" startline="811" endline="856">
<![CDATA[
 
     ''' <summary>
     ''' Parse the specified arguments
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Parse(ByVal CommandLine As String()) As Boolean
         Dim result As Boolean = True
 
         Try
             result = ParseInternal(CommandLine) AndAlso result
 
             If m_bNoConfig = False AndAlso m_bNoStdLib = False Then
                 Dim defaultrspfile As String = Nothing
                 Dim compiler_path As String = System.Reflection.Assembly.GetExecutingAssembly.Location
                 If compiler_path = String.Empty Then
                     compiler_path = System.Reflection.Assembly.GetEntryAssembly.Location
                 End If
                 defaultrspfile = IO.Path.Combine(IO.Path.GetDirectoryName(compiler_path), "vbnc.rsp")
 
                 If defaultrspfile Is Nothing OrElse IO.File.Exists(defaultrspfile) = False Then
                     Try
                         Using resources As System.IO.Stream = Reflection.Assembly.GetExecutingAssembly.GetManifestResourceStream("vbnc.vbnc.rsp")
                             If resources IsNot Nothing Then
                                 Using reader As New IO.StreamReader(resources)
                                     Dim tmp As String = reader.ReadToEnd()
                                     IO.File.WriteAllText(defaultrspfile, tmp)
                                 End Using
                             End If
                         End Using
                     Catch ex As Exception
                         'Ignore any exceptions here.
                     End Try
                 End If
                 If IO.File.Exists(defaultrspfile) Then
                     result = ParseResponseFile(defaultrspfile) AndAlso result
                 Else
                     Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Default response file '" & defaultrspfile & "' was not loaded because it couldn't be found.")
                 End If
             End If
         Catch ex As Exception
             Helper.StopIfDebugging()
             Throw
         End Try
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmManual.vb" startline="632" endline="676">
<![CDATA[
 
     Private Sub LstNetwork_SelectedIndexChanged(ByVal sender As Object, ByVal e As System.EventArgs) Handles LstNetwork.SelectedIndexChanged
 
         If My.Settings.ViewInfo = True Then
 
             Dim I, Indx As Integer
             For I = 0 To LstNetwork.SelectedItems.Count - 1
                 Indx = LstNetwork.SelectedItems(I).Index
             Next
 
             If Indx = 0 Then
                 Service_Info("Dhcp")
             ElseIf Indx = 1 Then
                 Service_Info("Dnscache")
             ElseIf Indx = 2 Then
                 Service_Info("DFSR")
             ElseIf Indx = 3 Then
                 Service_Info("LanmanWorkstation")
             ElseIf Indx = 4 Then
                 Service_Info("Browser")
             ElseIf Indx = 5 Then
                 Service_Info("FDResPub")
             ElseIf Indx = 6 Then
                 Service_Info("LanmanServer")
             ElseIf Indx = 7 Then
                 Service_Info("lmhosts")
             ElseIf Indx = 8 Then
                 Service_Info("TermService")
             ElseIf Indx = 9 Then
                 Service_Info("upnphost")
             ElseIf Indx = 10 Then
                 Service_Info("CscService")
             ElseIf Indx = 11 Then
                 Service_Info("iphlpsvc")
             ElseIf Indx = 12 Then
                 Service_Info("WebClient")
             ElseIf Indx = 13 Then
                 Service_Info("W32Time")
             ElseIf Indx = 14 Then
                 Service_Info("Wlansvc")
             End If
 
         End If
  
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\RMhandler.vb" startline="163" endline="198">
<![CDATA[
 
     Public Overloads Overrides Function Split(ByVal Filename As String, _
     ByVal Pieces As Short, Optional ByVal MediaDuration As Double = 0) As Boolean
         MyBase.Split(Filename, Pieces)
 
         If Pieces < 2 Then Exit Function
         If MediaDuration = 0 Then Exit Function
 
         Dim Temp As String = String.Empty
         Dim PieceFile As String = String.Empty
         Dim Duration As Double = MediaDuration / Pieces
 
         Filename = AddDefaultPathIfNeeded(StripExtension(Filename))
         For i As Integer = 0 To Pieces - 1
             PieceFile = Filename & CStr(i + 1).PadLeft(4, "0"c) & ".rm"
             Temp = " -i " & Chr(34) & mInFile & Chr(34) & " -o " & Chr(34) & PieceFile & Chr(34)
             Temp += " -s " + CFmt(Duration * i, True) + " -e " + CFmt(Math.Min(Duration * (i + 1), MediaDuration), True)
 
             '-i input.rm -o output.rm -s start -e end
             RunConverter(Temp)
             Threading.Thread.Sleep(500)
         Next
 
         Try
             Threading.Thread.Sleep(1000)
             Dim di As New IO.DirectoryInfo(GetDefaultDir)
             If di.GetFiles(StripPath(StripExtension(Filename)) & "*").Length >= Pieces Then
                 Return True
             Else
                 Return False
             End If
         Catch ex As Exception
             'Some disk exception
         End Try
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CByteExpression.vb" startline="49" endline="86">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         If Conversion.GetConstant(Nothing, False) Then Return result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
             Case TypeCode.Byte
                 'Implicitly convertible
             Case Else
                 If Conversion.IsExplicit = False AndAlso Conversion.Location.File(Conversion.Compiler).IsOptionStrictOn Then
                     result = Conversion.Compiler.Report.ShowMessage(Messages.VBNC30512, Conversion.Location, Helper.ToString(Conversion, expType), Helper.ToString(Conversion, ExpressionType)) AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CDblExpression.vb" startline="44" endline="81">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         If Conversion.GetConstant(Nothing, False) Then Return result
 
         Select Case expTypeCode
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30532, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
             Case TypeCode.Single, TypeCode.Double, TypeCode.Decimal, TypeCode.UInt64, TypeCode.Int64, TypeCode.UInt32, TypeCode.Int32, TypeCode.Int16, TypeCode.Byte, TypeCode.SByte, TypeCode.UInt16
                 'Implicitly convertible
             Case Else
                 If Conversion.IsExplicit = False AndAlso Conversion.Location.File(Conversion.Compiler).IsOptionStrictOn Then
                     result = Conversion.Compiler.Report.ShowMessage(Messages.VBNC30512, Conversion.Location, Helper.ToString(Conversion, expType), Helper.ToString(Conversion, ExpressionType)) AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="49" endline="86">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         If Conversion.GetConstant(Nothing, False) Then Return result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
             Case TypeCode.Int32, TypeCode.Int16, TypeCode.Byte, TypeCode.SByte, TypeCode.UInt16
                 'Implicitly convertible
             Case Else
                 If Conversion.IsExplicit = False AndAlso Conversion.Location.File(Conversion.Compiler).IsOptionStrictOn Then
                     result = Conversion.Compiler.Report.ShowMessage(Messages.VBNC30512, Conversion.Location, Helper.ToString(Conversion, expType), Helper.ToString(Conversion, ExpressionType)) AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CLngExpression.vb" startline="49" endline="86">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         If Conversion.GetConstant(Nothing, False) Then Return result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
             Case TypeCode.Int64, TypeCode.UInt32, TypeCode.Int32, TypeCode.Int16, TypeCode.Byte, TypeCode.SByte, TypeCode.UInt16
                 'Implicitly convertible
             Case Else
                 If Conversion.IsExplicit = False AndAlso Conversion.Location.File(Conversion.Compiler).IsOptionStrictOn Then
                     result = Conversion.Compiler.Report.ShowMessage(Messages.VBNC30512, Conversion.Location, Helper.ToString(Conversion, expType), Helper.ToString(Conversion, ExpressionType)) AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CSByteExpression.vb" startline="49" endline="86">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         If Conversion.GetConstant(Nothing, False) Then Return result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
             Case TypeCode.SByte
                 'Implicitly convertible
             Case Else
                 If Conversion.IsExplicit = False AndAlso Conversion.Location.File(Conversion.Compiler).IsOptionStrictOn Then
                     result = Conversion.Compiler.Report.ShowMessage(Messages.VBNC30512, Conversion.Location, Helper.ToString(Conversion, expType), Helper.ToString(Conversion, ExpressionType)) AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CShortExpression.vb" startline="49" endline="86">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         If Conversion.GetConstant(Nothing, False) Then Return result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
             Case TypeCode.Int16, TypeCode.Byte, TypeCode.SByte
                 'Implicitly convertible
             Case Else
                 If Conversion.IsExplicit = False AndAlso Conversion.Location.File(Conversion.Compiler).IsOptionStrictOn Then
                     result = Conversion.Compiler.Report.ShowMessage(Messages.VBNC30512, Conversion.Location, Helper.ToString(Conversion, expType), Helper.ToString(Conversion, ExpressionType)) AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CUIntExpression.vb" startline="49" endline="86">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         If Conversion.GetConstant(Nothing, False) Then Return result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
             Case TypeCode.UInt32, TypeCode.Int32, TypeCode.Int16, TypeCode.Byte, TypeCode.SByte, TypeCode.UInt16
                 'Implicitly convertible
             Case Else
                 If Conversion.IsExplicit = False AndAlso Conversion.Location.File(Conversion.Compiler).IsOptionStrictOn Then
                     result = Conversion.Compiler.Report.ShowMessage(Messages.VBNC30512, Conversion.Location, Helper.ToString(Conversion, expType), Helper.ToString(Conversion, ExpressionType)) AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CULngExpression.vb" startline="49" endline="86">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         If Conversion.GetConstant(Nothing, False) Then Return result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
             Case TypeCode.UInt64, TypeCode.UInt32, TypeCode.Int32, TypeCode.Int16, TypeCode.Byte, TypeCode.SByte, TypeCode.UInt16
                 'Implicitly convertible
             Case Else
                 If Conversion.IsExplicit = False AndAlso Conversion.Location.File(Conversion.Compiler).IsOptionStrictOn Then
                     result = Conversion.Compiler.Report.ShowMessage(Messages.VBNC30512, Conversion.Location, Helper.ToString(Conversion, expType), Helper.ToString(Conversion, ExpressionType)) AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CUShortExpression.vb" startline="49" endline="86">
<![CDATA[
     
     Shared Function Validate(ByVal Info As ResolveInfo, ByVal Conversion As ConversionExpression) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
         Dim ExpressionType As TypeReference = Conversion.ExpressionType
 
         result = ValidateForNullable(Info, Conversion, expTypeCode, expType) AndAlso result
 
         If Conversion.GetConstant(Nothing, False) Then Return result
 
         Select Case expTypeCode
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, ExpressionType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'OK
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
             Case TypeCode.Int16, TypeCode.Byte, TypeCode.SByte, TypeCode.UInt16
                 'Implicitly convertible
             Case Else
                 If Conversion.IsExplicit = False AndAlso Conversion.Location.File(Conversion.Compiler).IsOptionStrictOn Then
                     result = Conversion.Compiler.Report.ShowMessage(Messages.VBNC30512, Conversion.Location, Helper.ToString(Conversion, expType), Helper.ToString(Conversion, ExpressionType)) AndAlso result
                 End If
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="896" endline="936">
<![CDATA[
 
     Private Function GetString() As Token
         Dim bEndOfString As Boolean = False
         StringBuilderLength = 0
         Do
             Select Case NextChar()
                 Case nl27, nl201C, nl201D
                     'If " followed by a ", output one "
                     Dim nc As Char = NextChar()
                     If nc = nl27 OrElse nc = nl201C OrElse nc = nl201D Then
                         StringBuilderAppend(nc)
                     Else
                         bEndOfString = True
                     End If
                 Case nlA, nlD, nl2028, nl2029
                     Compiler.Report.ShowMessage(Messages.VBNC30648, GetCurrentLocation)
                     bEndOfString = True
                 Case Else
                     If m_EndOfFile Then
                         Compiler.Report.ShowMessage(Messages.VBNC30648, GetCurrentLocation)
                         'PreviousChar() 'Step back
                         bEndOfString = True
                     Else
                         StringBuilderAppend(CurrentChar())
                     End If
 
             End Select
         Loop While bEndOfString = False
         If CurrentChar() = "C"c OrElse CurrentChar() = "c"c Then
             'Is a char type character
             NextChar()
             If StringBuilderLength <> 1 Then
                 Compiler.Report.ShowMessage(Messages.VBNC30004, GetCurrentLocation())
                 Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
             Else
                 Return Token.CreateCharToken(GetCurrentLocation, m_StringBuilder(0))
             End If
         Else
             Return Token.CreateStringLiteral(GetCurrentLocation, StringBuilderToString)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1986" endline="1993">
<![CDATA[
 
     Shared Function CreateArray(Of T)(ByVal Value As T, ByVal Length As Integer) As T()
         Dim result(Length - 1) As T
         For i As Integer = 0 To Length - 1
             result(i) = Value
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\BaseObject.vb" startline="145" endline="154">
<![CDATA[
 
     Function FindFirstParent_IType() As IType
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is IType Then
             Return CType(CObj(Parent), IType)
         Else
             Return Parent.FindFirstParent(Of IType)()
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MemberCache.vb" startline="185" endline="240">
<![CDATA[
 
     Private Sub Load(ByVal Type As Mono.Cecil.TypeReference, ByVal Members As Mono.Collections.Generic.Collection(Of MemberReference), ByVal Name As String, ByVal Visibility As MemberVisibility)
         Dim entries As MemberCacheEntries = Nothing
         Dim isDefinedHere As Boolean = Compiler.Assembly.IsDefinedHere(Type)
         Dim addTo As Boolean
 
         entries = m_CacheInsensitive(Visibility)
         If entries Is Nothing Then
             entries = New MemberCacheEntries()
             m_CacheInsensitive(Visibility) = entries
         End If
 
         For m As Integer = 0 To Members.Count - 1
             Dim member As Mono.Cecil.MemberReference = Members(m)
             Dim cache As MemberCacheEntry = Nothing
             Dim isPublic, isFriend, isProtected, isPrivate As Boolean
 
             If Name IsNot Nothing AndAlso Not Helper.CompareName(Name, member.Name) Then
                 Continue For
             End If
 
             isPublic = Helper.IsPublic(member)
             isPrivate = Helper.IsPrivate(member)
             isFriend = Helper.IsFriendOrProtectedFriend(member)
             isProtected = Helper.IsProtectedOrProtectedFriend(member)
 
             If isDefinedHere = False AndAlso isPublic = False AndAlso isProtected = False Then
                 'Don't load private and friend members in other assemblies.
                 Continue For
             End If
 
             addTo = False
             Select Case Visibility
                 Case MemberVisibility.All
                     addTo = True
                 Case MemberVisibility.Public
                     addTo = isPublic
                 Case MemberVisibility.PublicFriend
                     addTo = isPublic OrElse isFriend
                 Case MemberVisibility.PublicProtected
                     addTo = isPublic OrElse isProtected
                 Case MemberVisibility.PublicProtectedFriend
                     addTo = isPublic OrElse isProtected OrElse isFriend
             End Select
 
             If addTo = False Then
                 Continue For
             End If
 
             If entries.TryGetValue(member.Name, cache) Then
                 cache.Members.Add(member)
             Else
                 entries.Add(New MemberCacheEntry(member))
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ResumeStatement.vb" startline="70" endline="81">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Compiler.Helper.AddCheck("Resume statement can only occur in methods with no structured exception handling.")
 
         Dim block As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
         block.HasUnstructuredExceptionHandling = True
         block.HasResume = True
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\EventAccessorDeclarations.vb" startline="166" endline="173">
<![CDATA[
 
     Private Function CreateImplicitMembers() As Boolean Implements IHasImplicitMembers.CreateImplicitMembers
         Dim result As Boolean = True
 
         result = ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="136" endline="149">
<![CDATA[
 
 #If DEBUG Then
     ReadOnly Property TokenSequence() As String
         Get
             Const Range As Integer = 3
             Dim result As String = ""
             For i As Integer = -Range To Range
                 'If Me.IsTokenValid(Me.iCurrentToken + i) Then
                 'result &= "(" & i.ToString & ")
                 result &= Me.PeekToken(i).ToString & " "
                 'End If
             Next
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="785" endline="793">
<![CDATA[
 
     Public Shared Function IsStatic(ByVal [Property] As PropertyReference) As Boolean
         Dim pd As PropertyDefinition = FindDefinition([Property])
 
         If pd.GetMethod IsNot Nothing Then Return IsStatic(pd.GetMethod)
         If pd.SetMethod IsNot Nothing Then Return IsStatic(pd.SetMethod)
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="59" endline="68">
<![CDATA[
 
     Public Shared Function GetMembers(ByVal Type As Mono.Cecil.GenericParameter) As Mono.Collections.Generic.Collection(Of MemberReference)
         Dim result As New Mono.Collections.Generic.Collection(Of MemberReference)()
 
         For i As Integer = 0 To Type.Constraints.Count - 1
             AddRange(result, GetMembers(Type.Constraints(i)))
         Next
         AddRange(result, GetMembers(BaseObject.m_Compiler.TypeCache.System_Object))
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="751" endline="760">
<![CDATA[
     End Property
 
     <Diagnostics.Conditional("DEBUG")> _
     Sub Log(ByVal Format As String, Optional ByVal P1 As Object = Nothing, Optional ByVal P2 As Object = Nothing, Optional ByVal P3 As Object = Nothing)
         If LOGMETHODRESOLUTION Then
             Dim msg As String
             msg = String.Format(Format, MethodName, P1, P2, P3)
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, msg)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="578" endline="597">
<![CDATA[
 
     ''' <summary>
     ''' Removes private members if they are from an external assembly.
     ''' </summary>
     ''' <param name="Members"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function FilterExternalInaccessible(ByVal Compiler As Compiler, ByVal Members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim result As New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
 
         For i As Integer = 0 To Members.Count - 1
             Dim member As Mono.Cecil.MemberReference = Members(i)
             If (IsPrivate(member) OrElse IsFriend(member)) AndAlso Compiler.Assembly.IsDefinedHere(CecilHelper.FindDefinition(member.DeclaringType)) = False Then
                 Continue For
             End If
             result.Add(member)
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MustOverridePropertyDeclaration.vb" startline="38" endline="55">
<![CDATA[
 
     ''' <summary>
     ''' Finds the list item with the specified name.
     ''' Returns nothing if nothing found.
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <value></value>
     ''' <remarks></remarks>
     Default Shadows ReadOnly Property Item(ByVal Name As String) As T
         Get
             For Each tp As T In Me
                 Dim t As INameable = CType(CObj(tp), INameable)
                 If Helper.CompareName(t.Name, Name) Then
                     Return tp
                 End If
             Next
             Return Nothing
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="370" endline="387">
<![CDATA[
 
     Private Function CreateWithEventsMembers(ByVal member As IMember) As Boolean
         Dim result As Boolean = True
         Dim tvd As TypeVariableDeclaration
         Dim t As TypeDeclaration
 
         tvd = TryCast(member, TypeVariableDeclaration)
         If tvd IsNot Nothing Then result = tvd.CreateWithEventsMembers AndAlso result
 
         t = TryCast(member, TypeDeclaration)
         If t Is Nothing Then Return result
 
         For i As Integer = 0 To t.Members.Count - 1
             result = CreateWithEventsMembers(t.Members(i)) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3025" endline="3042">
<![CDATA[
 
     Private Function GetSelectedFilenames() As String()
         Dim Temp As String()
         With lvFiles
             If .SelectedItems.Count = 0 Then
                 ReDim Temp(.Items.Count - 1)
                 For i As Integer = 0 To UBound(Temp)
                     Temp(i) = .Items(i).Text
                 Next
             Else
                 ReDim Temp(.SelectedItems.Count - 1)
                 For i As Integer = 0 To UBound(Temp)
                     Temp(i) = .SelectedItems(i).Text
                 Next
             End If
         End With
         Return Temp
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="76" endline="106">
<![CDATA[
 
     ReadOnly Property ExplicitCtorCall() As Mono.Cecil.MethodReference
         Get
             Dim firststatement As BaseObject
             Dim cs As CallStatement
             Dim ie As InvocationOrIndexExpression
             Dim ctor As Mono.Cecil.MethodReference
 
             firststatement = Code.FirstStatement
             If firststatement Is Nothing Then Return Nothing
 
             cs = TryCast(firststatement, CallStatement)
             If cs Is Nothing Then Return Nothing
 
             ie = TryCast(cs.Target, InvocationOrIndexExpression)
             If ie Is Nothing Then Return Nothing
             If ie.Expression.Classification.IsMethodGroupClassification = False Then Return Nothing
 
             ctor = ie.Expression.Classification.AsMethodGroupClassification.ResolvedConstructor
             If ctor Is Nothing Then Return Nothing
 
             If Helper.CompareNameOrdinal(ctor.Name, ConstructorDeclaration.ConstructorName) = False Then Return Nothing
 
             If Helper.CompareType(CecilHelper.FindDefinition(ctor.DeclaringType), CecilHelper.FindDefinition(Me.FindTypeParent.BaseType)) Then
                 Return ctor
             ElseIf Helper.CompareType(CecilHelper.FindDefinition(ctor.DeclaringType), CecilHelper.FindDefinition(Me.FindTypeParent.CecilType)) Then
                 Return ctor
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3216" endline="3242">
<![CDATA[
 
     Private Sub MoveItemsUp(ByVal lvControl As ListView)
 
         With lvControl
             Dim NumSelected As Integer = .SelectedIndices.Count
             If .SelectedIndices.Contains(0) Then Exit Sub
 
             Dim Jump2 As Integer = .SelectedIndices.Item(NumSelected - 1) + 1
 
             For i As Integer = .SelectedIndices.Count - 1 To 0 Step -1
                 If i > 0 Then
                     'There is another selected item
                     If .SelectedIndices.Item(i - 1) = .SelectedIndices.Item(i) - 1 Then
                         'Contiguous item; check next item
                     Else
                         JumpItem(lvControl, .Items(.SelectedIndices.Item(i) - 1), Jump2)
                         Jump2 = .SelectedIndices.Item(i - 1) + 1
                     End If
                 Else
                     'This is the last selected item
                     JumpItem(lvControl, .Items(.SelectedIndices.Item(i) - 1), Jump2)
                 End If
             Next
         End With
         mSelsDirty = True
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2360" endline="2406">
<![CDATA[
 
     'TODO
     Shared Function HexToInt(ByVal str As String) As ULong
         Dim i, n As Integer
         Dim l As Integer = str.Length
         HexToInt = 0
         For i = l To 1 Step -1
             Select Case str.Chars(i - 1)
                 Case "0"c
                     n = 0
                 Case "1"c
                     n = 1
                 Case "2"c
                     n = 2
                 Case "3"c
                     n = 3
                 Case "4"c
                     n = 4
                 Case "5"c
                     n = 5
                 Case "6"c
                     n = 6
                 Case "7"c
                     n = 7
                 Case "8"c
                     n = 8
                 Case "9"c
                     n = 9
                 Case "a"c, "A"c
                     n = 10
                 Case "b"c, "B"c
                     n = 11
                 Case "c"c, "C"c
                     n = 12
                 Case "d"c, "D"c
                     n = 13
                 Case "e"c, "E"c
                     n = 14
                 Case "f"c, "F"c
                     n = 15
                 Case Else
                     Throw New ArgumentOutOfRangeException("str", str, "Invalid hex number
             End Select
 
             HexToInt += CULng(n * (16 ^ (l - i)))
         Next
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\StdToolMgr.vb" startline="371" endline="405">
<![CDATA[
 
 #End Region
 
 #Region "   Button clicks and Commands "
 
     Private Sub tbButtons_ButtonClick(ByVal sender As System.Object, _
  ByVal e As System.Windows.Forms.ToolBarButtonClickEventArgs) Handles tbButtons.ButtonClick
 
         Dim ButtonName As String = DirectCast(e.Button.Tag, String)
 
         Select Case ButtonName
             Case "cStop"
                 'Stop Playback
                 cPlay.ImageIndex = 1
             Case "cPlay"
 
             Case "cBegin"
 
             Case "cFRev"
 
             Case "cFFwd"
 
             Case "cEnd"
 
             Case "cSelStrt"
 
             Case "cSelEnd"
 
             Case "cMute"
                 Mute = cMute.Pushed
         End Select
 
         RaiseEvent ButtonPress(ButtonName)
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="226" endline="270">
<![CDATA[
 
     Public Shared Sub GetGenericArgsAndParams(ByVal Type As TypeReference, ByRef GenericParameters As Mono.Collections.Generic.Collection(Of GenericParameter), ByRef GenericArguments As Mono.Collections.Generic.Collection(Of TypeReference))
         Dim declType As TypeReference = Nothing
         Dim genericType As GenericInstanceType
         Dim genericTypeDefinition As TypeDefinition
         Dim cloned As Boolean
 
         Do
             If declType Is Nothing Then
                 declType = Type
             Else
                 declType = declType.DeclaringType
             End If
 
             genericType = TryCast(declType, Mono.Cecil.GenericInstanceType)
 
             If genericType IsNot Nothing Then
                 genericTypeDefinition = CecilHelper.FindDefinition(genericType)
 
                 Helper.Assert(genericType.GenericArguments.Count = genericTypeDefinition.GenericParameters.Count)
 
                 If GenericArguments Is Nothing Then
                     GenericArguments = genericType.GenericArguments
                     GenericParameters = genericTypeDefinition.GenericParameters
                 Else
                     If cloned = False Then
                         Dim tmp1 As New Mono.Collections.Generic.Collection(Of TypeReference)
                         Dim tmp2 As New Mono.Collections.Generic.Collection(Of GenericParameter)
                         For i As Integer = 0 To GenericArguments.Count - 1
                             tmp1.Add(GenericArguments(i))
                             tmp2.Add(GenericParameters(i))
                         Next
                         GenericArguments = tmp1
                         GenericParameters = tmp2
                         cloned = True
                     End If
 
                     For i As Integer = 0 To genericType.GenericArguments.Count - 1
                         GenericArguments.Insert(i, genericType.GenericArguments(i))
                         GenericParameters.Insert(i, genericTypeDefinition.GenericParameters(i))
                     Next
                 End If
             End If
         Loop While declType.IsNested
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="205" endline="247">
<![CDATA[
 
     ''' <summary>
     ''' Loads all the referenced assemblies.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function LoadReferencedAssemblies() As Boolean
         Dim result As Boolean = True
         Dim refAssembly As Mono.Cecil.AssemblyDefinition
         Dim loadedFiles As New Generic.List(Of String)
         Dim loaded As Boolean
         Dim fullPath As String = Nothing
 
         For Each strFile As String In Compiler.CommandLine.References
             If loadedFiles.Contains(strFile) Then Continue For
             loadedFiles.Add(strFile)
 
             refAssembly = LoadAssembly(strFile, fullPath)
             If refAssembly Is Nothing Then
                 Compiler.Report.ShowMessage(Messages.VBNC2017, Span.CommandLineSpan, strFile)
                 Return False
             End If
 
             loaded = False
             For a As Integer = 0 To CecilAssemblies.Count - 1
                 If Helper.CompareNameOrdinal(CecilAssemblies(a).Name.FullName, refAssembly.Name.FullName) Then
                     loaded = True
                     Exit For
                 End If
             Next
             If loaded Then Continue For
 
             If Compiler.CommandLine.Verbose Then
                 Compiler.Report.WriteLine(String.Format("Loaded {0} => {1}", fullPath, refAssembly.Name))
             End If
             m_CecilAssemblies.Add(refAssembly)
             Compiler.AssemblyResolver.RegisterAssembly(refAssembly)
         Next
 
         Compiler.TypeCache.Init()
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1114" endline="1144">
<![CDATA[
 
     Shared Sub EmitLoadI4Value(ByVal Info As EmitInfo, ByVal I As Integer, ByVal TypeToPushOnStack As Mono.Cecil.TypeReference)
         TypeToPushOnStack = Helper.GetTypeOrTypeBuilder(Info.Compiler, TypeToPushOnStack)
         Select Case I
             Case -1
                 Info.ILGen.Emit(OpCodes.Ldc_I4_M1)
             Case 0
                 Info.ILGen.Emit(OpCodes.Ldc_I4_0)
             Case 1
                 Info.ILGen.Emit(OpCodes.Ldc_I4_1)
             Case 2
                 Info.ILGen.Emit(OpCodes.Ldc_I4_2)
             Case 3
                 Info.ILGen.Emit(OpCodes.Ldc_I4_3)
             Case 4
                 Info.ILGen.Emit(OpCodes.Ldc_I4_4)
             Case 5
                 Info.ILGen.Emit(OpCodes.Ldc_I4_5)
             Case 6
                 Info.ILGen.Emit(OpCodes.Ldc_I4_6)
             Case 7
                 Info.ILGen.Emit(OpCodes.Ldc_I4_7)
             Case 8
                 Info.ILGen.Emit(OpCodes.Ldc_I4_8)
             Case SByte.MinValue To SByte.MaxValue
                 Dim sbit As SByte = CSByte(I)
                 Info.ILGen.Emit(OpCodes.Ldc_I4_S, sbit)
             Case Else
                 Info.ILGen.Emit(OpCodes.Ldc_I4, I)
         End Select
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4830" endline="4875">
<![CDATA[
 
     Shared Function GetDominantType(ByVal Compiler As Compiler, ByVal types As Generic.List(Of TypeReference)) As TypeReference
         Dim implicit() As Boolean
         Dim count As Integer
         Dim index As Integer
 
         'Given a set of types, it is often necessary in situations such as type inference to determine the dominant type of the set. 
 
         If types Is Nothing OrElse types.Count = 0 Then Return Nothing
         If types.Count = 1 Then Return types(0)
 
         ReDim implicit(types.Count - 1)
 
         For i As Integer = 0 To implicit.Length - 1
             implicit(i) = True
         Next
 
         'The dominant type of a set of types is determined by first removing any types that one or more other types do not have an implicit conversion to. 
         For i As Integer = 0 To types.Count - 1
             For j As Integer = 0 To types.Count - 1
                 If i = j Then Continue For
                 If Compiler.TypeResolution.IsImplicitlyConvertible(Compiler, types(i), types(j)) = False Then
                     implicit(j) = False
                     Exit For
                 End If
             Next
         Next
 
         count = 0
         For i As Integer = 0 To implicit.Length - 1
             If implicit(i) Then
                 index = i
                 count += 1
             End If
         Next
 
         'If there are no types left at this point, there is no dominant type. 
         If count = 0 Then Return Nothing
 
         'The dominant type is then the most encompassed of the remaining types. 
         If count = 1 Then Return types(index)
 
         'The dominant type is then the most encompassed of the remaining types. 
         'If there is more than one type that is most encompassed, then there is no dominant type. 
         Return GetMostEncompassedType(Compiler, types)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2985" endline="3024">
<![CDATA[
 
     Private Sub OpenFilesForJoining()
 
         With dlgOpenFile
             Dim Filter As String = mStdToolMgr.ValidExtenstions(True)
             Filter = Replace(Filter, ".", "*.")
             Filter = Replace(Filter, "|", ";")
 
             .Filter = "Supported Media Files|" & Filter
             .Multiselect = True
             If chkDialogView.Checked Then mOpenFileExtender.Enabled = True
 
             If .ShowDialog() = Windows.Forms.DialogResult.OK Then
                 If Len(.FileName) > 0 Then
                     'Rajat check for compatible extensions and file exists
                     If .FileNames.Length > 1 Then
                         For i As Integer = 0 To .FileNames.GetUpperBound(0)
                             If File.Exists(.FileNames(i)) Then
                                 lvFiles.Items.Add(.FileNames(i))
                             End If
                         Next
                     Else
                         If File.Exists(.FileName) Then
                             lvFiles.Items.Add(.FileName)
                             If chkAuto.Checked Then
                                 Dim Matches As String() = FindLikeFiles(.FileName)
                                 If Not Matches Is Nothing Then
                                     For i As Integer = 0 To UBound(Matches)
                                         lvFiles.Items.Add(Matches(i))
                                     Next
                                 End If
                             End If
                         End If
                     End If
                 End If
             End If
             mOpenFileExtender.Enabled = False
         End With
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\MPGhandler.vb" startline="107" endline="131">
<![CDATA[
 
     Public Overloads Overrides Function Split(ByVal Filename As String, _
     ByVal Duration As Double, ByVal MediaDuration As Double) As Boolean
         MyBase.Split(Filename, Duration, MediaDuration)
 
         If MediaDuration = 0 Then Exit Function
         If Duration = 0 Then Exit Function
         Dim ReportedDur As Double = GetDuration()
         If ReportedDur < MediaDuration Then MediaDuration = ReportedDur
         Dim Pieces As Integer = CInt(Fix(MediaDuration / Duration))
         If MediaDuration Mod Duration > 0 Then Pieces += 1
 
         Dim Temp As String = "-s -f -b " & Chr(34) & AddDefaultPathIfNeeded(StripExtension(Filename)) & Chr(34)
         Temp += " " & Chr(34) & mInFile & Chr(34) & " [-" & CFmt(Duration) & "]"
         For i As Integer = 1 To Pieces - 2
             Temp += " [" & CFmt(Duration * i) & "-" & CFmt(Duration * (i + 1)) & "]"
         Next
         Temp += " [" & CFmt(Duration * (Pieces - 1)) + "-]"
 
         If mIsAudio Then SafeHarborMsg()
         RunConverter(Temp)
 
         Return FileCount(Filename) >= Pieces
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CDateExpression.vb" startline="34" endline="70">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.DateTime
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Info.Compiler.TypeCache.System_Double.Name, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Double
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30533, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Boolean, TypeCode.Byte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.SByte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Decimal, TypeCode.Single
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDate_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDate_Object)
                 Else
                     result = Conversion.FindUserDefinedConversionOperator() AndAlso result
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDate_String)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="560" endline="630">
<![CDATA[
 
     Private Function GetTypeClassification(ByVal members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference), ByVal type As IType) As ExpressionClassification
         'Otherwise, the result is exactly the same as a member access of the form T.E, where T is the 
         'type containing the matching member and E is the identifier. In this case, it is an error for the 
         'identifier to refer to a non-shared member.
 
         Dim first As Mono.Cecil.MemberReference = members(0)
         '* If E is a built-in type or an expression classified as a type, and I is the name of an accessible 
         '  member of E, then E.I is evaluated and classified as follows
 
         '** If I is the keyword New, then a compile-time error occurs.
         '(not applicable)
 
         '** If I identifies one or more methods, then the result is a method group with the associated 
         '   type argument list and no associated instance expression.
         If Helper.IsMethodDeclaration(first) Then
             Return New MethodGroupClassification(Me, Nothing, m_TypeArgumentList, Nothing, members)
         End If
 
         '** If I identifies one or more properties, then the result is a property group with no associated 
         '   instance expression.
         If Helper.IsPropertyDeclaration(first) Then
             Return New PropertyGroupClassification(Me, Nothing, members)
         End If
 
         If members.Count > 1 Then Throw New InternalException(Me)
 
         '** If I identifies a type, then the result is that type.
         If Helper.IsTypeDeclaration(first) Then
             Return New TypeClassification(Me, first)
         End If
 
         '** If I identifies a shared variable, and if the variable is read-only, and the reference occurs 
         '   outside the shared constructor of the type in which the variable is declared, then the result is the 
         '   value of the shared variable I in E. Otherwise, the result is the shared variable I in E.
         If Helper.IsFieldDeclaration(first) Then
             Dim var As Mono.Cecil.FieldReference = TryCast(first, Mono.Cecil.FieldReference)
             Dim varD As Mono.Cecil.FieldDefinition = CecilHelper.FindDefinition(var)
             Dim constructor As ConstructorDeclaration = Me.FindFirstParent(Of ConstructorDeclaration)()
             If varD.IsStatic AndAlso varD.IsInitOnly AndAlso _
              (constructor Is Nothing OrElse constructor.Modifiers.Is(ModifierMasks.Shared) = False) Then
                 Return New ValueClassification(Me, var, Nothing)
             Else
                 Return New VariableClassification(Me, var, Nothing)
             End If
         End If
 
         '** If I identifies a shared event, the result is an event access with no associated instance expression.
         If Helper.IsEventDeclaration(first) Then
             Dim red As Mono.Cecil.EventReference = DirectCast(first, Mono.Cecil.EventReference)
             Dim redD As Mono.Cecil.EventDefinition = CecilHelper.FindDefinition(red)
             If redD.AddMethod.IsStatic OrElse redD.RemoveMethod.IsStatic Then
                 Return New EventAccessClassification(Me, red, Nothing)
             End If
         End If
 
         '** If I identifies a constant, then the result is the value of that constant.
         If CecilHelper.GetMemberType(first) = MemberTypes.Field AndAlso CecilHelper.FindDefinition(DirectCast(first, Mono.Cecil.FieldReference)).IsLiteral Then
             Return New ValueClassification(Me, DirectCast(first, Mono.Cecil.FieldReference), Nothing)
         End If
 
         '** If I identifies an enumeration member, then the result is the value of that enumeration member.
         If Helper.IsEnumFieldDeclaration(Compiler, first) Then
             Return New ValueClassification(Me, DirectCast(first, Mono.Cecil.FieldReference), Nothing)
         End If
 
         '** Otherwise, E.I is an invalid member reference, and a compile-time error occurs.
         Helper.AddError(Me)
 
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="144" endline="201">
<![CDATA[
 
     Private Function AddInitializeComponentCall(ByVal Ctor As ConstructorDeclaration) As Boolean
         Dim result As Boolean = True
 
         'If the class has the Microsoft.VisualBasic.CompilerServices.DesignerGeneratedAttribute, we call InitializeComponent.
         'InitializeComponent must be correctly spelled (case-sensitive), have no parameters (not even optional) and must be private
         Dim attribs As Generic.List(Of Attribute)
         attribs = Me.FindAttributes(Compiler.TypeCache.MS_VB_CS_DesignerGeneratedAttribute)
 
         If attribs Is Nothing OrElse attribs.Count = 0 Then Return result
 
         Dim methods As Generic.List(Of INameable)
 
         methods = Members.Index.Item("InitializeComponent")
 
         If methods Is Nothing OrElse methods.Count = 0 Then Return result
 
         methods = New Generic.List(Of INameable)(methods)
 
         For i As Integer = methods.Count - 1 To 0 Step -1
             Dim subD As SubDeclaration
             subD = TryCast(methods(i), SubDeclaration)
             If subD Is Nothing Then
                 methods.RemoveAt(i)
                 Continue For
             End If
 
             If subD.Signature.ReturnType IsNot Nothing AndAlso Helper.CompareType(subD.Signature.ReturnType, Compiler.TypeCache.System_Void) = False Then
                 methods.RemoveAt(i)
                 Continue For
             End If
 
             If subD.Signature.Parameters.Count <> 0 Then
                 methods.RemoveAt(i)
                 Continue For
             End If
 
             If subD.Modifiers.Is(ModifierMasks.Private) = False Then
                 methods.RemoveAt(i)
                 Continue For
             End If
         Next
 
         If methods.Count = 0 Then Return result
 
         If methods.Count > 1 Then
             'Huh?
             Helper.StopIfDebugging(True)
         Else
             Dim callStmt As New CallStatement(Me)
             Dim sExp As New SimpleNameExpression(callStmt)
             sExp.Init(New Identifier(Me, "InitializeComponent", Me.Location, TypeCharacters.Characters.None), Nothing)
             callStmt.Init(sExp)
             Ctor.Code.AddStatement(callStmt)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeConverter.vb" startline="628" endline="675">
<![CDATA[
 
     Shared Function GetBinaryOperandType(ByVal Compiler As Compiler, ByVal op As KS, ByVal op1 As Mono.Cecil.TypeReference, ByVal op2 As Mono.Cecil.TypeReference) As TypeCode
         Dim result As TypeCode
 
         result = GetBinaryOperandType(op, Helper.GetTypeCode(Compiler, op1), Helper.GetTypeCode(Compiler, op2))
 
         If result = TypeCode.Object Then
             Dim isIntrinsic1, isIntrinsic2 As Boolean
             Dim conv1, conv2 As TypeCode()
             Dim defs As String
 
             isIntrinsic1 = Helper.IsIntrinsicType(Compiler, op1)
             isIntrinsic2 = Helper.IsIntrinsicType(Compiler, op2)
 
             If isIntrinsic1 = isIntrinsic2 Then Return result
 
             defs = GetBinaryOperandDefinedTypes(op)
 
             Dim conversions As New Generic.List(Of TypeCode)
             If isIntrinsic1 = False Then
                 conv1 = TypeResolution.GetIntrinsicTypesImplicitlyConvertibleFrom(Compiler, op1)
                 If conv1 IsNot Nothing Then
                     For i As Integer = 0 To conv1.Length - 1
                         Dim chr As Char = GetCharOfTypeCode(conv1(i))
                         If defs.IndexOf(chr) >= 0 Then conversions.Add(conv1(i))
                     Next
                     If conversions.Count = 1 Then
                         result = GetBinaryOperandType(op, conversions(0), Helper.GetTypeCode(Compiler, op2))
                     End If
                 End If
             End If
             If isIntrinsic2 = False Then
                 conv2 = TypeResolution.GetIntrinsicTypesImplicitlyConvertibleFrom(Compiler, op2)
                 If conv2 IsNot Nothing Then
                     For i As Integer = 0 To conv2.Length - 1
                         Dim chr As Char = GetCharOfTypeCode(conv2(i))
                         If defs.IndexOf(chr) >= 0 Then conversions.Add(conv2(i))
                     Next
                     If conversions.Count = 1 Then
                         result = GetBinaryOperandType(op, Helper.GetTypeCode(Compiler, op1), conversions(0))
                     End If
                 End If
             End If
 
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MemberImplementsClause.vb" startline="41" endline="94">
<![CDATA[
 
     Function DefineImplements(ByVal Declaration As EventDeclaration) As Boolean
         Dim result As Boolean = True
         Dim declType As Mono.Cecil.TypeDefinition
 
         Helper.Assert(Declaration IsNot Nothing)
 
         declType = Declaration.DeclaringType.CecilType
 
         For i As Integer = 0 To m_ImplementsList.Count - 1
             Dim ispec As InterfaceMemberSpecifier = m_ImplementsList(i)
             Dim eventI As Mono.Cecil.EventDefinition
 
             eventI = CecilHelper.FindDefinition(ispec.ResolvedEventInfo)
 
             Helper.Assert(eventI IsNot Nothing)
 
             Dim addMethodI, removeMethodI As Mono.Cecil.MethodReference
             Dim addMethod, removeMethod As Mono.Cecil.MethodReference
             Dim raiseMethod As Mono.Cecil.MethodReference = Nothing
             Dim raiseMethodI As Mono.Cecil.MethodReference = Nothing
 
             addMethodI = Helper.GetMethodOrMethodReference(Compiler, eventI.AddMethod)
             removeMethodI = Helper.GetMethodOrMethodReference(Compiler, eventI.RemoveMethod)
             If eventI.InvokeMethod IsNot Nothing Then
                 raiseMethodI = Helper.GetMethodOrMethodReference(Compiler, eventI.InvokeMethod)
             End If
 
             addMethod = Helper.GetMethodOrMethodReference(Compiler, Declaration.AddDefinition)
             removeMethod = Helper.GetMethodOrMethodReference(Compiler, Declaration.RemoveDefinition)
             If Declaration.RaiseDefinition IsNot Nothing Then
                 raiseMethod = Helper.GetMethodOrMethodReference(Compiler, Declaration.RaiseDefinition)
             End If
 
             Helper.Assert((addMethodI Is Nothing Xor addMethod Is Nothing) = False)
             Helper.Assert((removeMethodI Is Nothing Xor removeMethod Is Nothing) = False)
             Helper.Assert((raiseMethodI Is Nothing Xor raiseMethod Is Nothing) = False)
 
             If addMethod IsNot Nothing AndAlso addMethodI IsNot Nothing Then
                 Dim methodDef As Mono.Cecil.MethodDefinition = CecilHelper.FindDefinition(addMethod)
                 methodDef.Overrides.Add(CecilHelper.MakeEmittable(addMethodI))
             End If
             If removeMethod IsNot Nothing AndAlso removeMethodI IsNot Nothing Then
                 Dim methodDef As Mono.Cecil.MethodDefinition = CecilHelper.FindDefinition(removeMethod)
                 methodDef.Overrides.Add(CecilHelper.MakeEmittable(removeMethodI))
             End If
             If raiseMethod IsNot Nothing AndAlso raiseMethodI IsNot Nothing Then
                 Dim methodDef As Mono.Cecil.MethodDefinition = CecilHelper.FindDefinition(raiseMethod)
                 methodDef.Overrides.Add(CecilHelper.MakeEmittable(raiseMethodI))
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\PropertySetDeclaration.vb" startline="36" endline="99">
<![CDATA[
 
     Public Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal ImplementsClause As MemberImplementsClause, ByVal Block As CodeBlock, ByVal SetParameters As ParameterList)
         Dim mySignature As SubSignature
         Dim name As String
         Dim typeParams As TypeParameters
         Dim params As ParameterList
         Dim manualValue As Boolean
 
         mySignature = New SubSignature(Me)
 
         typeParams = PropertySignature.TypeParameters
         If SetParameters IsNot Nothing Then
             params = SetParameters
         Else
             params = New ParameterList(Me)
         End If
 
         If params.Count = 1 Then
             manualValue = True
         Else
             manualValue = False
             If params.Count > 1 Then
                 Helper.AddError(Compiler, Me.Location, "Invalid set parameters, there should be only 0 or 1 parameters")
                 params.Clear()
             End If
         End If
 
         If PropertySignature.Parameters IsNot Nothing Then
             Dim tmp As Parameter = Nothing
 
             'The 'value' parameter should go at the end, so take it out of the list, add the other parameters, and add it back again
             If manualValue Then
                 tmp = params(0)
                 params.Clear()
             End If
 
             For i As Integer = 0 To PropertySignature.Parameters.Count - 1
                 params.Add(PropertySignature.Parameters(i).Clone(params))
             Next
 
             If manualValue Then
                 params.Add(tmp)
             End If
         End If
 
         ' Setter without a 'value', create it automatically
         If manualValue = False Then
             Dim valueName As String = "Value"
             Dim param As Parameter
             If PropertySignature.ReturnType IsNot Nothing Then
                 param = New Parameter(params, valueName, PropertySignature.ReturnType)
             Else
                 param = New Parameter(params, valueName, PropertySignature.TypeName)
                 param.ParameterIdentifier.Identifier.TypeCharacter = PropertySignature.Identifier.TypeCharacter
             End If
             params.Add(param)
         End If
 
         name = "set_" & PropertySignature.Name
 
         mySignature.Init(New Identifier(mySignature, name, PropertySignature.Location, PropertySignature.Identifier.TypeCharacter), typeParams, params)
 
         MyBase.Init(Modifiers, mySignature, ImplementsClause, Block)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2409" endline="2445">
<![CDATA[
 
 #End Region
 
 #Region "   Player Controls "
 
     Private Sub Mpcontrols_ButtonPress(ByVal Name As String) _
     Handles MPcontrols.ButtonPress
 
         Select Case Name
             Case "cStop"
                 mPlayer.Ctlcontrols.stop()
                 Timer.Enabled = False
             Case "cPlay"
                 If mPlayer.playState = WMPLib.WMPPlayState.wmppsPlaying Then
                     mPlayer.Ctlcontrols.pause()
                 Else
                     mPlayer.Ctlcontrols.play()
                 End If
                 mDisplayControl.Focus()
             Case "cBegin"
                 mPlayer.Ctlcontrols.currentPosition = 0
             Case "cFRev"
                 ToggleFastReverse()
             Case "cFFwd"
                 ToggleFastForward()
             Case "cEnd"
                 mPlayer.Ctlcontrols.pause()
                 mPlayer.Ctlcontrols.currentPosition = mPlayer.currentMedia.duration
             Case "cSelStrt"
                 StartSelection()
             Case "cSelEnd"
                 EndSelection()
             Case "cMute"
                 mPlayMuted = MPcontrols.Mute
         End Select
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="38" endline="45">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodDeclaration.vb" startline="62" endline="69">
<![CDATA[
 
     Public Overrides Function CreateDefinition() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.CreateDefinition AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="42" endline="51">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         ' result = Helper.ResolveTypeReferences(m_UsingResources) AndAlso result
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="544" endline="552">
<![CDATA[
 
     Public Overrides Function DefineTypeHierarchy() As Boolean
         Dim result As Boolean = True
 
         'Define type parameters
         result = MyBase.DefineTypeHierarchy AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\GenericTypeDeclaration.vb" startline="47" endline="54">
<![CDATA[
 
     Public Overrides Function DefineTypeHierarchy() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.DefineTypeHierarchy AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="58" endline="66">
<![CDATA[
 
     Public Overrides ReadOnly Property RightOperandTypeCode() As System.TypeCode
         Get
             If MyBase.OperandTypeCode = TypeCode.Object Then
                 Return TypeCode.Object
             Else
                 Return TypeCode.Int32
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="59" endline="67">
<![CDATA[
 
     Private Function GetValueType(ByVal tp As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Helper.Assert(tp IsNot Nothing)
         If TypeOf tp Is ByReferenceType Then
             Return tp.GetElementType
         Else
             Return tp
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="453" endline="470">
<![CDATA[
 
     ''' <summary>
     ''' If explicitly or implicitly convertible.
     ''' </summary>
     ''' <param name="Compiler"></param>
     ''' <param name="tpFrom"></param>
     ''' <param name="tpTo"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsExplicitlyConvertible(ByVal Compiler As Compiler, ByVal tpFrom As TypeCode, ByVal tpTo As TypeCode) As Boolean
         Dim result As Boolean
         Dim ct As ConversionType
 
         ct = Conversion(tpFrom, tpTo).Conversion
         result = ct = ConversionType.Implicit OrElse ct = ConversionType.Explicit
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\EnumMemberDeclaration.vb" startline="113" endline="122">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
         result = Helper.ResolveTypeReferences(m_ConstantExpression) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ReturnStatement.vb" startline="36" endline="45">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_Lock) AndAlso result
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="38" endline="47">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_Condition) AndAlso result
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="36" endline="43">
<![CDATA[
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_WithExpression) AndAlso result
         result = MyBase.ResolveTypeReferences() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="145" endline="157">
<![CDATA[
     End Property
 
     Private Function IsNegativeStep() As Boolean
         Dim constant As Object = Nothing
 
         If Not m_LoopStepExpression.GetConstant(constant, True) Then Return False
 
         If TypeOf constant Is Decimal Then
             Return CDec(constant) < 0
         Else
             Return CDbl(constant) < 0
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="57" endline="69">
<![CDATA[
 
     ReadOnly Property Name() As String
         Get
             If TypeOf Me Is MeExpression Then
                 Return KS.Me.ToString
             ElseIf TypeOf Me Is MyBaseExpression Then
                 Return KS.MyBase.ToString
             ElseIf TypeOf Me Is MyClassExpression Then
                 Return KS.MyClass.ToString
             Else
                 Throw New InternalException("Invalid instance expression.")
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="762" endline="776">
<![CDATA[
 
     Public Shared Function GetMemberType(ByVal member As Mono.Cecil.MemberReference) As MemberTypes
         If TypeOf member Is FieldReference Then Return MemberTypes.Field
         If TypeOf member Is TypeReference Then Return MemberTypes.TypeInfo
         If TypeOf member Is MethodReference Then
             If Helper.CompareNameOrdinal(member.Name, ".ctor") OrElse Helper.CompareNameOrdinal(member.Name, ".cctor") Then
                 Return MemberTypes.Constructor
             Else
                 Return MemberTypes.Method
             End If
         End If
         If TypeOf member Is EventReference Then Return MemberTypes.Event
         If TypeOf member Is PropertyReference Then Return MemberTypes.Property
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4750" endline="4766">
<![CDATA[
 
     Shared Function IsHideBySig(ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Select Case CecilHelper.GetMemberType(Member)
             Case MemberTypes.Constructor
                 Return False
             Case MemberTypes.Event, MemberTypes.Field, MemberTypes.NestedType, MemberTypes.TypeInfo
                 Return False
             Case MemberTypes.Property
                 Dim pInfo As Mono.Cecil.PropertyDefinition = CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.PropertyReference))
                 Return CBool(GetPropertyAttributes(pInfo) And Mono.Cecil.MethodAttributes.HideBySig)
             Case MemberTypes.Method
                 Dim mInfo As Mono.Cecil.MethodDefinition = CecilHelper.FindDefinition(DirectCast(Member, Mono.Cecil.MethodReference))
                 Return mInfo.IsHideBySig
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CodeFiles.vb" startline="1224" endline="1261">
<![CDATA[
 
     ''' <summary>
     ''' Shows an error if the filename(s) cannot be found.
     ''' If it returns an empty array something went wrong 
     ''' (the error message has already been shown).
     ''' </summary>
     ''' <param name="FileName">Can be a complete filename or a pattern.</param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetFullPaths(ByVal FileName As String) As String()
         Dim strPath As String = System.IO.Path.GetDirectoryName(FileName)
         Dim strFileName As String
 
         If strPath <> "" Then
             strFileName = FileName.Substring(strPath.Length + 1)
         Else
             strFileName = FileName
         End If
 
         Dim tmpPath As String
         If strPath = "" Then
             strPath = IO.Path.GetDirectoryName(IO.Path.GetFullPath(FileName))
         End If
         tmpPath = IO.Path.GetFullPath(strPath)
 
         If IO.Directory.Exists(tmpPath) = False Then Return Nothing
 
         If IsPattern(FileName) Then
             Return IO.Directory.GetFiles(tmpPath, strFileName)
         Else
             Dim file As String = IO.Path.Combine(tmpPath, strFileName)
             If IO.File.Exists(file) Then
                 Return New String() {file}
             Else
                 Return Nothing
             End If
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\BaseObject.vb" startline="258" endline="274">
<![CDATA[
     End Property
     ReadOnly Property ParentLocationTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 'If tmp.HasLocation = False Then
                 '    result &= "(" & tmp.GetType.Name & ")
                 'Else
                 result.Add("(" & tmp.GetType.Name & ")
                 'End If
                 tmp = tmp.Parent
             Loop
             Do Until tmp Is Nothing
                 'If tmp.HasLocation = False Then
                 '    result &= "(" & tmp.GetType.Name & ")
                 'Else
                 result.Add("(" & tmp.GetType.Name & ")
                 'End If
                 tmp = tmp.Parent
             Loop
 
             Return result.toarray
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="749" endline="757">
<![CDATA[
 
     Public Shared Function GetNestedType(ByVal Type As TypeReference, ByVal Name As String) As TypeReference
         Dim tD As TypeDefinition = FindDefinition(Type)
         For i As Integer = 0 To tD.NestedTypes.Count - 1
             If Helper.CompareName(tD.NestedTypes(i).Name, Name) Then Return tD.NestedTypes(i)
         Next
         If tD.BaseType Is Nothing Then Return Nothing
         Return GetNestedType(tD.BaseType, Name)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Modules\Common.vb" startline="17" endline="48">
<![CDATA[
 
 #End Region
 
 #Region "Create Snapshot"
 
     Friend Function Create_Snapshot(ByVal Name As String, ByVal Description As String) As Boolean
 
         If Directory.Exists(SnapshotsDir) = False Then
             Directory.CreateDirectory(SnapshotsDir)
         End If
 
         Dim Writer As New StreamWriter(SnapshotsDir & Name)
 
         With Writer
 
             .WriteLine("2.0!")
             .WriteLine(Description & "!")
             .WriteLine(My.Computer.Clock.LocalTime.ToString & "!")
 
             Dim Service, Services() As System.ServiceProcess.ServiceController
             Services = System.ServiceProcess.ServiceController.GetServices()
             For Each Service In Services
                 .WriteLine(Service.ServiceName & Check_Service(Service.ServiceName))
             Next
             .Close()
 
         End With
 
         File.SetAttributes((SnapshotsDir & Name), FileAttributes.ReadOnly)
         Create_Snapshot = True
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\ImportsClause.vb" startline="71" endline="97">
<![CDATA[
 
     ''' <summary>
     ''' Returns true if a clause with the same imported namespace or alias exists.
     ''' </summary>
     ''' <param name="Clause"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Exists(ByVal Clause As ImportsClause) As Boolean
         For Each cl As ImportsClause In Me
             If cl.IsNamespaceClause Then
                 If Clause.IsNamespaceClause Then
                     If Helper.CompareName(cl.AsNamespaceClause.Name, Clause.AsNamespaceClause.Name) Then
                         Return True
                     End If
                 End If
             ElseIf cl.IsAliasClause Then
                 If Clause.IsAliasClause Then
                     If Helper.CompareName(cl.AsAliasClause.Name, Clause.AsAliasClause.Name) Then
                         Return True
                     End If
                 End If
             Else
                 Throw New InternalException(Me)
             End If
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2628" endline="2636">
<![CDATA[
 
     Private Function ParseMyClassExpression(ByVal Parent As ParsedObject) As MyClassExpression
         Dim result As MyClassExpression
 
         tm.AcceptIfNotInternalError(KS.MyClass)
         result = New MyClassExpression(Parent)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2637" endline="2645">
<![CDATA[
 
     Private Function ParseMyBaseExpression(ByVal Parent As ParsedObject) As MyBaseExpression
         Dim result As MyBaseExpression
 
         tm.AcceptIfNotInternalError(KS.MyBase)
         result = New MyBaseExpression(Parent)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2646" endline="2654">
<![CDATA[
 
     Private Function ParseMeExpression(ByVal Parent As ParsedObject) As MeExpression
         Dim result As MeExpression
 
         tm.AcceptIfNotInternalError(KS.Me)
         result = New MeExpression(Parent)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\BoundList.vb" startline="55" endline="62">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = Helper.ResolveTypeReferences(m_Expressions) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="234" endline="264">
<![CDATA[
 
     Function RuleMod(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleIntegerDivision(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Mod)
             NextToken()
             RuleIntegerDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CLng(0)
             Else
                 LSide = op1 Mod op2
             End If
         End While
         While CurrentToken.Equals(KS.Mod)
             NextToken()
             RuleIntegerDivision(RSide)
 
             Dim op1, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                 bErr = True
             End If
 
             If bErr Then
                 LSide = CLng(0)
             Else
                 LSide = op1 Mod op2
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\ConstructedTypeName.vb" startline="192" endline="199">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = VerifyConstraints(True) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\VariableIdentifiers.vb" startline="53" endline="63">
<![CDATA[
     End Property
 
     ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Dim exp As Expression = InitializerExpression
             If exp IsNot Nothing Then
                 Return exp.ExpressionType
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="1164" endline="1180">
<![CDATA[
 
     Public Shared Function GetBaseType(ByVal Type As TypeReference) As TypeReference
         Dim result As Mono.Cecil.TypeReference
         Dim tD As Mono.Cecil.TypeDefinition
 
         tD = CecilHelper.FindDefinition(Type)
 
         If tD Is Nothing Then Return Nothing
 
         result = tD.BaseType
 
         If result Is Nothing Then Return Nothing
 
         result = CecilHelper.InflateType(result, Type)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="94" endline="105">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         If result = False Then Return result
 
         result = Validate(Info, Me) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2545" endline="2551">
<![CDATA[
 
     Private Function isValidExtenstionSlave(ByVal ExtStr As String, ByVal Ext As String) As Boolean
         Dim extArr As String() = Split(ExtStr, "|")
         For i As Integer = 0 To UBound(extArr)
             If Ext = extArr(i) Then Return True
         Next
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\BaseObject.vb" startline="197" endline="212">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Get the current compiling assembly.
     ''' </summary>
     Friend Overridable ReadOnly Property Assembly() As AssemblyDeclaration Implements IBaseObject.Assembly
         Get
             If TypeOf Me Is AssemblyDeclaration Then
                 Return DirectCast(Me, AssemblyDeclaration)
             ElseIf TypeOf Me Is Compiler Then
                 Return DirectCast(Me, Compiler).theAss
             Else
                 Helper.Assert(m_Parent IsNot Nothing)
                 Return m_Parent.Assembly
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Compiler.vb" startline="56" endline="65">
<![CDATA[
 
     Default Shadows ReadOnly Property Item(ByVal Name As String) As Define
         Get
             For Each def As Define In Me
                 If Helper.CompareName(def.Symbol, Name) Then
                     Return def
                 End If
             Next
             Return Nothing
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\MainForm.cs" startline="216" endline="234">
<![CDATA[
 
         protected bool AtLeastOneAuthorizedFob
         {
             get
             {
                 bool rv = false;
 
                 foreach (KeyFob fob in pm.KeyFobs)
                 {
                     if (fob.IsAuthorized &&
                         fob.Status == KeyFobStatus.Present)
                     {
                         rv = true;
                         break;
                     }
                 }
                 foreach (KeyFob fob in pm.KeyFobs)
                 {
                     if (fob.IsAuthorized &&
                         fob.Status == KeyFobStatus.Present)
                     {
                         rv = true;
                         break;
                     }
                 }
 
                 return rv;
             }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4524" endline="4552">
<![CDATA[
 
     Shared Function GetEventAttributes(ByVal [Event] As Mono.Cecil.EventReference) As Mono.Cecil.MethodAttributes
         Dim ev As Mono.Cecil.EventDefinition = CecilHelper.FindDefinition([Event])
         Dim result As Mono.Cecil.MethodAttributes
         Dim getA, setA, raiseA As Mono.Cecil.MethodAttributes
         Dim getM, setM, raiseM As Mono.Cecil.MethodDefinition
 
         getM = ev.AddMethod
         setM = ev.RemoveMethod
         raiseM = ev.InvokeMethod
 
         Helper.Assert(getM IsNot Nothing OrElse setM IsNot Nothing OrElse raiseM IsNot Nothing)
 
         If getM IsNot Nothing Then
             getA = getM.Attributes
         End If
 
         If setM IsNot Nothing Then
             setA = setM.Attributes
         End If
 
         If raiseM IsNot Nothing Then
             raiseA = raiseM.Attributes
         End If
 
         result = setA Or getA Or raiseA
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmSrvcMngr.vb" startline="400" endline="432">
<![CDATA[
 
     Private Shared Function Company(ByVal Name As String) As String
 
         Dim C As Char = (""""c)
         Dim FullPath As String = (CStr(My.Computer.Registry.GetValue(("HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\" & Name), "ImagePath", ""))).Trim(C)
 
         Try
             Dim Info As FileVersionInfo
 
             If FullPath.Contains("/"c) = True Then
 
                 Dim Split_Ary() = FullPath.Split("/"c)
                 If File.Exists(Split_Ary(0)) = True Then
                     Info = FileVersionInfo.GetVersionInfo(Split_Ary(0))
                     Company = Info.CompanyName
                 End If
             Else
 
                 Dim Folder As String = Path.GetDirectoryName(FullPath)
                 Dim FileName As String = Path.GetFileNameWithoutExtension(FullPath)
                 Dim FilePath As String = ((Folder & "\" & FileName & ".exe"))
 
                 If File.Exists(FilePath) = True Then
                     Info = FileVersionInfo.GetVersionInfo(FilePath)
                     Company = Info.CompanyName
                 End If
             End If
 
         Catch ex As ArgumentException
             Company = "Unknown"
         End Try
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3243" endline="3267">
<![CDATA[
 
     Private Sub MoveItemsDn(ByVal lvControl As ListView)
         With lvControl
             Dim NumSelected As Integer = .SelectedIndices.Count
             If .SelectedIndices.Contains(.Items.Count - 1) Then Exit Sub
 
             Dim Jump2 As Integer = .SelectedIndices.Item(0)
             For i As Integer = 0 To .SelectedIndices.Count - 1
                 If i < NumSelected - 1 Then
                     'There is another selected item
                     If .SelectedIndices.Item(i + 1) = .SelectedIndices.Item(i) + 1 Then
                         'Contiguous item; check next item
                     Else
                         JumpItem(lvControl, .Items(.SelectedIndices.Item(i) + 1), Jump2)
                         Jump2 = .SelectedIndices.Item(i + 1)
                     End If
                 Else
                     'This is the last selected item
                     JumpItem(lvControl, .Items(.SelectedIndices.Item(i) + 1), Jump2)
                 End If
             Next
         End With
         mSelsDirty = True
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\ASFhandler.vb" startline="81" endline="101">
<![CDATA[
 
     Private Function GetSaveCommand(ByVal Mode As AbstractMediaHandler.Mode) As String
 
         Dim Temp As String = "-i " & Chr(34) & mInFile & Chr(34) & _
         " -o " & Chr(34) & mOutFile & Chr(34)
 
         Dim Segment As Segment
         For Each Segment In mSegments
             Temp += " -start " + CStr(Segment.Start) + " -stop " + CStr(Segment.Finish)
         Next
 
         Temp += " -details -y"
         If Options("FrameAccurate") = "True" Then
             Temp += " -rkf"
         End If
         If Mode = AbstractMediaHandler.Mode.SaveSeparate Then
             Temp += " -sep"
         End If
         Return Temp
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="90" endline="96">
<![CDATA[
 
     Sub ClearCache(ByVal Type As Mono.Cecil.TypeReference)
         Dim result As MemberCache = Nothing
         If MemberCache.TryGetValue(Type, result) Then
             result.ClearAll()
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Index.vb" startline="90" endline="98">
<![CDATA[
 
     ReadOnly Property GetAllTypeBases() As ArrayList
         Get
             Dim result As New ArrayList
             For Each i As IndexList In m_lstCollections.Values
                 result.AddRange(i.Values)
             Next
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="206" endline="223">
<![CDATA[
 
     Private Sub LnkManualTuneUp_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles LnkManualTuneUp.Click
 
         Dim Child As Form
         For Each Child In Me.MdiChildren
             If Child.Text = "Manual TuneUp" Then
                 Exit Sub
             Else
                 Child.Dispose()
             End If
         Next
 
         FrmManual.MdiParent = Me
         FrmManual.Size = New Size((Me.Size.Width - 291), (Me.Size.Height - 94))
         FrmManual.Show()
         PnlHome.Visible = False
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="224" endline="241">
<![CDATA[
 
     Private Sub LnkGameMode_Click(ByVal sender As Object, ByVal e As System.EventArgs) Handles LnkGameMode.Click
 
         Dim Child As Form
         For Each Child In Me.MdiChildren
             If Child.Text = "Gaming Mode" Then
                 Exit Sub
             Else
                 Child.Dispose()
             End If
         Next
 
         FrmGameMode.MdiParent = Me
         FrmGameMode.Size = New Size((Me.Size.Width - 291), (Me.Size.Height - 94))
         FrmGameMode.Show()
         PnlHome.Visible = False
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="242" endline="259">
<![CDATA[
 
     Private Sub LnkProfiles_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles LnkProfiles.Click
 
         Dim Child As Form
         For Each Child In Me.MdiChildren
             If Child.Text = "Services Profiles" Then
                 Exit Sub
             Else
                 Child.Dispose()
             End If
         Next
 
         FrmProfiles.MdiParent = Me
         FrmProfiles.Size = New Size((Me.Size.Width - 291), (Me.Size.Height - 94))
         FrmProfiles.Show()
         PnlHome.Visible = False
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="260" endline="277">
<![CDATA[
 
     Private Sub LnkSrvcMngr_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles LnkSrvcMngr.Click
 
         Dim Child As Form
         For Each Child In Me.MdiChildren
             If Child.Text = "Services Manager" Then
                 Exit Sub
             Else
                 Child.Dispose()
             End If
         Next
 
         FrmSrvcMngr.MdiParent = Me
         FrmSrvcMngr.Size = New Size((Me.Size.Width - 291), (Me.Size.Height - 94))
         FrmSrvcMngr.Show()
         PnlHome.Visible = False
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmProfiles.vb" startline="344" endline="355">
<![CDATA[
 
     Private Shared Function Preview(ByVal Name As String, ByVal Setting As String) As String
         If String.Compare(Setting, (Name & "1"), True) = 0 Then
             Preview = " (Yes - Automatic Startup)"
         ElseIf String.Compare(Setting, (Name & "2"), True) = 0 Then
             Preview = " (Maybe - Manual Startup)"
         ElseIf String.Compare(Setting, (Name & "3"), True) = 0 Then
             Preview = " (No - Disabled Startup)"
         Else
             Preview = " (Windows service not found)"
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="89" endline="107">
<![CDATA[
     End Property
 
     Function GetMethodAttributeScope() As Mono.Cecil.MethodAttributes
         If Me.Is(ModifierMasks.Public) Then
             Return Mono.Cecil.MethodAttributes.Public
         ElseIf Me.Is(ModifierMasks.Friend) Then
             If Me.Is(ModifierMasks.Protected) Then
                 Return Mono.Cecil.MethodAttributes.FamORAssem
             Else
                 Return Mono.Cecil.MethodAttributes.Assembly
             End If
         ElseIf Me.Is(ModifierMasks.Protected) Then
             Return Mono.Cecil.MethodAttributes.Family
         ElseIf Me.Is(ModifierMasks.Private) Then
             Return Mono.Cecil.MethodAttributes.Private
         Else
             Return Mono.Cecil.MethodAttributes.Public
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="517" endline="540">
<![CDATA[
     ''' <summary>
     ''' AttributeBlock  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseAttributeBlock(ByVal Parent As ParsedObject, ByVal Attributes As Attributes) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Attributes IsNot Nothing)
 
         tm.AcceptIfNotInternalError(KS.LT)
         tm.AcceptNewLine()
 
         If ParseAttributeList(Parent, Attributes) = False Then
             Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         tm.AcceptNewLine()
         result = tm.AcceptIfNotError(KS.GT) AndAlso result
         If Attributes(0).IsAssembly = False AndAlso Attributes(0).IsModule = False Then
             tm.AcceptNewLine()
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\Main.vb" startline="63" endline="101">
<![CDATA[
 
     Public Function CheckUpdate(Optional ByVal AutoCheck As Boolean = False, _
     Optional ByVal StartUp As Boolean = False) As Boolean
 
         Dim PAD As New Xml.XmlDocument, RetVal As Boolean
         Dim CurrentVer As New Version(Application.ProductVersion)
 
         Try
             PAD.Load(mPADLoc & "?ver=" & CurrentVer.ToString)
             Dim VerStr As String = PAD.SelectSingleNode("AppInfo/NewVer").InnerText
             Dim NewAdd As String = PAD.SelectSingleNode("AppInfo/WhatsNew").InnerText
             Dim VerDt As Date = Date.Parse(PAD.SelectSingleNode("AppInfo/VerDt").InnerText)
 
             If Len(VerStr) > 0 Then
                 Dim LatestVer As New Version(VerStr)
 
                 If AutoCheck Then
                     If mSettings.GetSetting("Preferences", "VersionIgnored") = VerStr Then Exit Function
                     If LatestVer.CompareTo(CurrentVer) <= 0 Then Exit Function
                 End If
 
                 Dim frm As New frmAbout
                 frm.TopMost = True
                 If (LatestVer.CompareTo(CurrentVer) > 0) And VerDt > Now Then
                     RetVal = frm.UpdateAvailable("A newer version (" + _
                     VerStr + ") is available", VerStr, NewAdd)
                 Else
                     frm.UpdateAvailable("You have the latest version")
                 End If
                 frm = Nothing
             End If
         Catch ex As Exception
             If Not StartUp Then
                 MsgBox("Cannot check right now." + vbCrLf + "Please try again later.")
             End If
         End Try
 
         Return RetVal
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="1155" endline="1161">
<![CDATA[
 
     Function FindType(ByVal FullName As String) As TypeDeclaration
         For Each type As TypeDeclaration In Me.Types
             If Helper.CompareName(type.FullName, FullName) Then Return type
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2063" endline="2070">
<![CDATA[
 
     Shared Function DefineCollection(ByVal Collection As IEnumerable) As Boolean
         Dim result As Boolean = True
         For Each obj As IBaseObject In Collection
             result = obj.Define AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2071" endline="2079">
<![CDATA[
 
     Shared Function ResolveTypeReferencesCollection(ByVal Collection As IEnumerable) As Boolean
         Dim result As Boolean = True
         For Each obj As ParsedObject In Collection
             result = obj.ResolveTypeReferences AndAlso result
             'vbnc.Helper.Assert(result = (obj.Compiler.Report.Errors = 0))
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="1332" endline="1338">
<![CDATA[
 
     Public Shared Function GetMethod(ByVal type As ICollection, ByVal reference As MethodReference) As MethodDefinition
         For Each item As Mono.Cecil.MethodDefinition In type
             If CecilHelper.AreSame(reference, item) Then Return item
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AliasClause.vb" startline="40" endline="55">
<![CDATA[
 
     Function CreateArrayType(ByVal OriginalType As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Dim result As Mono.Cecil.TypeReference = Helper.GetTypeOrTypeReference(Compiler, OriginalType)
         Dim mods() As ArrayTypeModifier = m_ArrayTypeModifiers
         For i As Integer = mods.GetUpperBound(0) To 0 Step -1
             Dim arr As ArrayType
             arr = CecilHelper.MakeArrayType(result, mods(i).Ranks)
             result = arr
             If arr.Rank > 1 Then
                 For d As Integer = 0 To arr.Rank - 1
                     arr.Dimensions(d) = New ArrayDimension(New Nullable(Of Integer)(0), Nothing)
                 Next
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\AbstractMediaHandler.vb" startline="63" endline="78">
<![CDATA[
 
     Private Sub FromSettings()
         Dim Node As XmlNode = mSettings.SectionXML("Tools")
         If Node Is Nothing Then
             Node = ToXML()
         End If
         For Each Tool As XmlNode In Node.SelectNodes("Tool")
             Dim i As Integer = FindToolIndex(Tool.SelectSingleNode("DisplayName").InnerText)
             Dim ToolSetting As ToolSpec = DirectCast(mList(i), ToolSpec)
             ToolSetting.Enabled = (Tool.SelectSingleNode("Enabled").InnerText = "yes")
             ToolSetting.Path.Value = Tool.SelectSingleNode("Path").InnerText
             If isValid(ToolSetting.DisplayName) Then
                 ToolSetting.Enabled = True
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="304" endline="324">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' This function is only used for error reporting, no need to do things fast.
     ''' </summary>
     ''' <param name="LineNumber"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function DoesLineEndWithLineContinuation(ByVal LineNumber As UInteger) As Boolean
         Dim lines() As String
         Using stream As IO.StreamReader = CodeStream
             lines = stream.ReadToEnd().Split(New String() {VB.vbCrLf, VB.vbCr, VB.vbLf}, StringSplitOptions.None)
         End Using
         If lines.Length < LineNumber Then Return False
 
         Dim line As String = lines(CInt(LineNumber - 1UI))
         Do While line.Length > 0 AndAlso Scanner.IsWhiteSpace(line(line.Length - 1))
             line = line.Substring(0, line.Length - 1)
         Loop
         Do While line.Length > 0 AndAlso Scanner.IsWhiteSpace(line(line.Length - 1))
             line = line.Substring(0, line.Length - 1)
         Loop
         Return line.EndsWith(" _")
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="158" endline="194">
<![CDATA[
 
     Public Shared Function GetCorrectMember(ByVal Member As Mono.Cecil.TypeDefinition, ByVal Type As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Dim result As Mono.Cecil.GenericInstanceType = Nothing
         Dim args As New Generic.List(Of Mono.Cecil.TypeReference)
         Dim any_change As Boolean
         Dim genericType As Mono.Cecil.GenericInstanceType = TryCast(Type, Mono.Cecil.GenericInstanceType)
 
         If genericType Is Nothing Then Return Member
 
         result = New Mono.Cecil.GenericInstanceType(Member)
         result.DeclaringType = FindDefinition(Type)
 
         Dim tGI As Mono.Cecil.GenericInstanceType = TryCast(Type, Mono.Cecil.GenericInstanceType)
         If Member.DeclaringType IsNot Nothing AndAlso tGI IsNot Nothing AndAlso Helper.CompareType(Member.DeclaringType, tGI.ElementType) Then
             'Nested generic type
             For i As Integer = 0 To tGI.GenericArguments.Count - 1
                 result.GenericArguments.Add(Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, tGI.GenericArguments(i)))
             Next
             Return result
         End If
 
         For i As Integer = 0 To Member.GenericParameters.Count - 1
             Dim found As Boolean = False
             For j As Integer = 0 To genericType.ElementType.GenericParameters.Count - 1
                 If genericType.ElementType.GenericParameters(j).Name = Member.GenericParameters(i).Name Then
                     result.GenericArguments.Add(Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, genericType.GenericArguments(j)))
                     found = True
                     any_change = True
                     Exit For
                 End If
             Next
 
             If Not found Then Throw New NotImplementedException
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Compiler.vb" startline="423" endline="431">
<![CDATA[
 
     Function GenerateMy() As Boolean
         Dim result As Boolean = True
         Dim generator As New MyGenerator(Me)
 
         result = generator.Generate() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="3977" endline="3991">
<![CDATA[
 
     Overloads Shared Function ToString(ByVal Types As Mono.Cecil.TypeReference()) As String
         Dim result As String = ""
         Dim sep As String = ""
 
         If Types IsNot Nothing Then
             For Each t As Mono.Cecil.TypeReference In Types
                 Helper.Assert(t IsNot Nothing)
                 result &= sep & t.ToString
                 sep = ", "
             Next
         End If
 
         Return "{" & result & "}"
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="167" endline="184">
<![CDATA[
 
     Function CreateImplicitTypes() As Boolean
         Dim result As Boolean = True
 
         For Each Type As TypeDeclaration In Me.Types
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "CreateImplicitTypes " & Type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             Dim tmp As IHasImplicitTypes = TryCast(Type, IHasImplicitTypes)
             If tmp IsNot Nothing Then result = tmp.CreateImplicitTypes AndAlso result
 
             result = CreateImplicitTypes(Type) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="246" endline="263">
<![CDATA[
 
     Function CreateImplicitMembers() As Boolean
         Dim result As Boolean = True
 
         For Each Type As TypeDeclaration In Me.Types
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "CreateImplicitMembers " & Type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             Dim tmp As IHasImplicitMembers = TryCast(Type, IHasImplicitMembers)
             If tmp IsNot Nothing Then result = tmp.CreateImplicitMembers AndAlso result
 
             result = CreateImplicitMembers(Type) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4005" endline="4021">
<![CDATA[
 
     Overloads Shared Function ToString(ByVal Accessibility As ModifierMasks) As String
         Select Case Accessibility
             Case ModifierMasks.Protected Or ModifierMasks.Friend
                 Return "Protected Friend"
             Case ModifierMasks.Protected
                 Return "Protected"
             Case ModifierMasks.Friend
                 Return "Friend"
             Case ModifierMasks.Public
                 Return "Public"
             Case ModifierMasks.Private
                 Return "Private"
             Case Else
                 Return "<unknown>"
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1840" endline="1898">
<![CDATA[
 
     Shared Function IsAccessible(ByVal Context As BaseObject, ByVal CalledMethodAccessability As Mono.Cecil.MethodAttributes, ByVal CalledType As Mono.Cecil.TypeReference) As Boolean
         Dim Compiler As Compiler = Context.Compiler
 
         Helper.Assert(Compiler IsNot Nothing)
         Helper.Assert(CalledType IsNot Nothing)
 
         'Checks it the accessed method / type is accessible from the current compiling code
         '(for attributes that is not contained within a type)
 
         Dim testNested As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(CalledType)
         Dim compiledType As Boolean = Compiler.Assembly.IsDefinedHere(CalledType)
         Dim mostDeclaredType As Mono.Cecil.TypeDefinition = Nothing
 
         Do Until testNested Is Nothing
             mostDeclaredType = testNested
             'If it is a nested private type, it is not accessible.
             If testNested.IsNestedPrivate Then Return False
             'If it is not a nested public type in an external assembly, it is not accessible.
             If compiledType = False AndAlso testNested.IsNestedPublic = False AndAlso testNested.IsNested Then Return False
             testNested = CecilHelper.FindDefinition(testNested.DeclaringType)
         Loop
         Do Until testNested Is Nothing
             mostDeclaredType = testNested
             'If it is a nested private type, it is not accessible.
             If testNested.IsNestedPrivate Then Return False
             'If it is not a nested public type in an external assembly, it is not accessible.
             If compiledType = False AndAlso testNested.IsNestedPublic = False AndAlso testNested.IsNested Then Return False
             testNested = CecilHelper.FindDefinition(testNested.DeclaringType)
         Loop
 
         'If the most external type is not public then it is not accessible.
         If compiledType = False AndAlso mostDeclaredType.IsPublic = False Then Return False
 
         'The type is at least accessible now, check the method.
 
         Dim ac As Mono.Cecil.MethodAttributes = (CalledMethodAccessability And Mono.Cecil.MethodAttributes.MemberAccessMask)
         Dim isPrivate As Boolean = ac = Mono.Cecil.MethodAttributes.Private
         Dim isFriend As Boolean = ac = Mono.Cecil.MethodAttributes.Assembly OrElse ac = Mono.Cecil.MethodAttributes.FamORAssem
         Dim isProtected As Boolean = ac = Mono.Cecil.MethodAttributes.Family OrElse ac = Mono.Cecil.MethodAttributes.FamORAssem
         Dim isPublic As Boolean = ac = Mono.Cecil.MethodAttributes.Public
 
         'If the member is private, the member is not accessible
         '(to be accessible the types must be equal or the caller type must
         'be a nested type of the called type, cases already covered).
         If isPrivate Then Return False
 
         If isFriend AndAlso isProtected Then
             'Friend and Protected
             'If it is an external type it is not accessible.
             Return compiledType
         ElseIf isFriend Then
             'Friend, but not Protected
             'If it is an external type it is not accessible.
             Return compiledType
         ElseIf isProtected Then
             'Protected, but not Friend
             'It is not accessible.
             Return False
         ElseIf isPublic Then
             Return True
         End If
 
         Context.Compiler.Report.ShowMessage(Messages.VBNC99997, Context.Location) '("No accessibility??")
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="499" endline="506">
<![CDATA[
 
     Function MakeArrayType(ByVal Parent As ParsedObject, ByVal ElementType As Mono.Cecil.TypeReference, ByVal Ranks As Integer) As Mono.Cecil.TypeReference
         Dim result As Mono.Cecil.ArrayType
 
         result = New Mono.Cecil.ArrayType(ElementType, Ranks)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\RMhandler.vb" startline="56" endline="65">
<![CDATA[
 
     Friend Overloads Overrides Sub ShowInfo(ByVal Filenames As String())
         Try
             For i As Integer = 0 To UBound(Filenames)
                 RunConverter(" -i " & Chr(34) & Filenames(0) & Chr(34))
             Next
         Catch ex As Exception
             MsgBox(ex.Message)
         End Try
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="199" endline="216">
<![CDATA[
 
     Private Sub BeginExceptFilterBlockCecil()
         Log("BeginExceptFilterBlock")
         Dim ex As New Mono.Cecil.Cil.ExceptionHandler(Mono.Cecil.Cil.ExceptionHandlerType.Filter)
         Dim block As TryBlock = m_ExceptionBlocks.Peek
 
         CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Leave, block.EndBlock)
         If block.EndTry Is Nothing Then
             block.EndTry = CreateAndEmitNop()
         End If
         If block.Handlers.Count > 0 Then
             block.Handlers(block.Handlers.Count - 1).HandlerEnd = CreateAndEmitNop()
         End If
 
         ex.FilterStart = CilBody.Instructions(CilBody.Instructions.Count - 1)
         ex.HandlerStart = ex.FilterStart
         block.Handlers.Add(ex)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="229" endline="245">
<![CDATA[
 
     Private Sub BeginFinallyBlockCecil()
         Log("BeginFinallyBlock")
         Dim ex As New Mono.Cecil.Cil.ExceptionHandler(Mono.Cecil.Cil.ExceptionHandlerType.Finally)
         Dim block As TryBlock = m_ExceptionBlocks.Peek
         CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Leave, block.EndBlock)
         If block.EndTry Is Nothing Then
             block.EndTry = CreateAndEmitNop()
         End If
         If block.Handlers.Count > 0 Then
             block.Handlers(block.Handlers.Count - 1).HandlerEnd = CreateAndEmitNop()
         End If
 
         ex.HandlerStart = CilBody.Instructions(CilBody.Instructions.Count - 1)
         ex.TryEnd = ex.HandlerStart
         block.Handlers.Add(ex)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2254" endline="2292">
<![CDATA[
 
     ''' <summary>
     ''' This function takes a string as an argument and split it on the space character,
     ''' with the " as acceptable character.
     ''' </summary>
     Shared Function ParseLine(ByVal strLine As String) As String()
         Dim strs As New ArrayList
         Dim bInQuote As Boolean
         Dim iStart As Integer
         Dim builder As New System.Text.StringBuilder
 
         For i As Integer = 0 To strLine.Length - 1
             If strLine.Chars(i) = "\"c AndAlso i < strLine.Length - 1 AndAlso strLine.Chars(i + 1) = """"c Then
                 builder.Append(""""c)
                 i += 1
             ElseIf strLine.Chars(i) = """"c Then
                 If strLine.Length - 1 >= i + 1 AndAlso strLine.Chars(i + 1) = """"c Then
                     builder.Append(""""c)
                 Else
                     bInQuote = Not bInQuote
                 End If
             ElseIf bInQuote = False AndAlso strLine.Chars(i) = " "c Then
                 If builder.ToString.Trim() <> "" Then strs.Add(builder.ToString)
                 builder.Length = 0
                 iStart = i + 1
             Else
                 builder.Append(strLine.Chars(i))
             End If
         Next
         If builder.Length > 0 Then strs.Add(builder.ToString)
 
         'Add the strings to the return value
         Dim stt(strs.Count - 1) As String
         For i As Integer = 0 To strs.Count - 1
             stt(i) = DirectCast(strs(i), String)
         Next
 
         Return stt
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3683" endline="3721">
<![CDATA[
 
 #End Region
 
 #Region "   Tabs - Splitting "
 
     Private Sub UpdateEditorOptions(ByVal Extension As String)
 
         Dim EditingSupported As Boolean
         If mHandler Is Nothing Then
             EditingSupported = False
             radSize.Enabled = False
             tSplitName.Text = ""
             cSplitBrw.Enabled = False
         Else
             EditingSupported = mHandler.IsSupported("Editing")
             radSize.Enabled = mHandler.IsSupported("SizeSplit")
             tSplitName.Text = mHandler.GetSplitName(tFile2Split.Text)
             cSplitBrw.Enabled = True
         End If
 
         mnuSave.Enabled = EditingSupported
         mnuSaveX.Enabled = EditingSupported
         mnuSaveSepFiles.Enabled = EditingSupported
         mnuInfo.Enabled = EditingSupported
         cbSize.Enabled = radSize.Enabled
         cSplit.Enabled = EditingSupported
 
         Select Case LCase(Extension)
             Case ".wmv", ".asf"
                 mnuImpSkip.Enabled = CheckForSkipFile("SmartSkip")
                 mnuImpComskip.Enabled = False
             Case ".mpg", ".mpeg"
                 mnuImpSkip.Enabled = CheckForSkipFile("SmartSkip")
                 mnuImpComskip.Enabled = CheckForSkipFile("Comskip")
             Case Else
                 mnuImpSkip.Enabled = False
                 mnuImpComskip.Enabled = False
         End Select
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="119" endline="137">
<![CDATA[
 
     Private Shared Function ChkImg(ByVal Name As String) As Boolean
 
         On Error Resume Next
 
         Dim P As New Process()
         Dim PM As ProcessModule
 
         For Each P In Process.GetProcesses(".")
             For Each PM In P.Modules
                 If Name.ToLower() = PM.ModuleName.ToLower() Then
                     Return True
                     Exit Function
                 End If
             Next
         Next
         Return False
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\StdToolMgr.vb" startline="406" endline="412">
<![CDATA[
 
     Public Sub RefreshPositions()
         mSuspend = True
         mPlayer.Ctlcontrols.play()
         mPlayer.Ctlcontrols.pause()
         mSuspend = False
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2640" endline="2652">
<![CDATA[
 
     Private Sub frmMain_KeyDown(ByVal sender As Object, ByVal e As System.Windows.Forms.KeyEventArgs) Handles MyBase.KeyDown
 
         If Not mFileLoaded Then Exit Sub
 
         Select Case e.KeyCode
             Case Keys.Left, Keys.Right
                 mSuspendPlayerRefresh = True
             Case Else
                 mSuspendPlayerRefresh = False
         End Select
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1493" endline="1503">
<![CDATA[
 
     ''' <summary>
     ''' Load a constant date value on the evaluation stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadDateValue(ByVal Info As EmitInfo, ByVal DateValue As Date)
         Dim emitLong As EmitInfo = Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Int64)
         EmitLoadI8Value(emitLong, DateValue.Ticks)
         Info.ILGen.Emit(OpCodes.Newobj, Helper.GetMethodOrMethodReference(Info.Compiler, Info.Compiler.TypeCache.System_DateTime__ctor_Int64))
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2393" endline="2404">
<![CDATA[
 
     Private Sub ToggleRepeatPlay()
         If mnuLoop.Checked Then
             mRepeatPlay = False
             mnuLoop.Checked = False
             cLoop.Pushed = False
         Else
             mRepeatPlay = True
             mnuLoop.Checked = True
             cLoop.Pushed = True
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3345" endline="3355">
<![CDATA[
 
     Private Sub DeleteSelected()
         With lvPositions
             Dim Segment As ListViewItem
             For Each Segment In .SelectedItems
                 .Items.Remove(Segment)
             Next
         End With
         UpdateSelDur()
         mSelsDirty = True
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\dshowUtil.vb" startline="6" endline="14">
<![CDATA[
     Public Sub New()
         MyBase.New()
 
         'This call is required by the Windows Form Designer.
         InitializeComponent()
 
         'Add any initialization after the InitializeComponent() call
 
     End Sub
 
     'Form overrides dispose to clean up the component list.
     Protected Overloads Overrides Sub Dispose(ByVal disposing As Boolean)
         If disposing Then
             If Not (components Is Nothing) Then
                 components.Dispose()
             End If
         End If
         MyBase.Dispose(disposing)
     End Sub
 
     'Required by the Windows Form Designer
     Private components As System.ComponentModel.IContainer
 
     'NOTE
     'It can be modified using the Windows Form Designer.  
     'Do not modify it using the code editor.
     Friend WithEvents LinkLabel1 As System.Windows.Forms.LinkLabel
     Friend WithEvents Label1 As System.Windows.Forms.Label
     Friend WithEvents Label2 As System.Windows.Forms.Label
     Friend WithEvents Label3 As System.Windows.Forms.Label
     Friend WithEvents tAck As System.Windows.Forms.TextBox
     Friend WithEvents chkRemind As System.Windows.Forms.CheckBox
     Friend WithEvents Label4 As System.Windows.Forms.Label
     <System.Diagnostics.DebuggerStepThrough()> Private Sub InitializeComponent()
         Me.LinkLabel1 = New System.Windows.Forms.LinkLabel
         Me.Label1 = New System.Windows.Forms.Label
         Me.Label2 = New System.Windows.Forms.Label
         Me.Label3 = New System.Windows.Forms.Label
         Me.tAck = New System.Windows.Forms.TextBox
         Me.chkRemind = New System.Windows.Forms.CheckBox
         Me.Label4 = New System.Windows.Forms.Label
         Me.SuspendLayout()
         '
         'LinkLabel1
         '
         Me.LinkLabel1.Location = New System.Drawing.Point(40, 322)
         Me.LinkLabel1.Name = "LinkLabel1"
         Me.LinkLabel1.Size = New System.Drawing.Size(288, 24)
         Me.LinkLabel1.TabIndex = 0
         Me.LinkLabel1.TabStop = True
         Me.LinkLabel1.Text = "Movica Homepage - Suggestions and Help"
         Me.LinkLabel1.TextAlign = System.Drawing.ContentAlignment.MiddleCenter
         '
         'Label1
         '
         Me.Label1.Font = New System.Drawing.Font("Verdana", 30.0!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.Label1.Location = New System.Drawing.Point(104, 0)
         Me.Label1.Name = "Label1"
         Me.Label1.Size = New System.Drawing.Size(163, 48)
         Me.Label1.TabIndex = 1
         Me.Label1.Text = "Movica"
         '
         'Label2
         '
         Me.Label2.Location = New System.Drawing.Point(24, 62)
         Me.Label2.Name = "Label2"
         Me.Label2.Size = New System.Drawing.Size(312, 40)
         Me.Label2.TabIndex = 2
         Me.Label2.Text = "A simple utility to edit .wmv, .wma, .mpeg and .flv movies using AsfBin, MpgTx an" & _
             "d flvtool"
         Me.Label2.TextAlign = System.Drawing.ContentAlignment.MiddleCenter
         '
         'Label3
         '
         Me.Label3.ForeColor = System.Drawing.Color.Gray
         Me.Label3.Location = New System.Drawing.Point(128, 47)
         Me.Label3.Name = "Label3"
         Me.Label3.Size = New System.Drawing.Size(100, 16)
         Me.Label3.TabIndex = 3
         Me.Label3.Text = "Label3"
         Me.Label3.TextAlign = System.Drawing.ContentAlignment.MiddleCenter
         '
         'tAck
         '
         Me.tAck.BorderStyle = System.Windows.Forms.BorderStyle.None
         Me.tAck.ForeColor = System.Drawing.SystemColors.GrayText
         Me.tAck.Location = New System.Drawing.Point(27, 104)
         Me.tAck.Multiline = True
         Me.tAck.Name = "tAck"
         Me.tAck.ScrollBars = System.Windows.Forms.ScrollBars.Vertical
         Me.tAck.Size = New System.Drawing.Size(309, 196)
         Me.tAck.TabIndex = 4
         Me.tAck.Text = "Acknowledgements"
         Me.tAck.TextAlign = System.Windows.Forms.HorizontalAlignment.Center
         '
         'chkRemind
         '
         Me.chkRemind.Location = New System.Drawing.Point(88, 306)
         Me.chkRemind.Name = "chkRemind"
         Me.chkRemind.Size = New System.Drawing.Size(200, 16)
         Me.chkRemind.TabIndex = 5
         Me.chkRemind.Text = "Don't remind me about this version"
         Me.chkRemind.Visible = False
         '
         'Label4
         '
         Me.Label4.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle
         Me.Label4.Location = New System.Drawing.Point(336, 8)
         Me.Label4.Name = "Label4"
         Me.Label4.Size = New System.Drawing.Size(16, 16)
         Me.Label4.TabIndex = 6
         Me.Label4.Text = "X"
         Me.Label4.TextAlign = System.Drawing.ContentAlignment.MiddleCenter
         '
         'frmAbout
         '
         Me.AutoScaleBaseSize = New System.Drawing.Size(5, 13)
         Me.BackColor = System.Drawing.Color.White
         Me.ClientSize = New System.Drawing.Size(362, 351)
         Me.ControlBox = False
         Me.Controls.Add(Me.Label4)
         Me.Controls.Add(Me.chkRemind)
         Me.Controls.Add(Me.tAck)
         Me.Controls.Add(Me.Label3)
         Me.Controls.Add(Me.Label2)
         Me.Controls.Add(Me.Label1)
         Me.Controls.Add(Me.LinkLabel1)
         Me.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog
         Me.KeyPreview = True
         Me.Name = "frmAbout"
         Me.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen
         Me.ResumeLayout(False)
         Me.PerformLayout()
 
     End Sub
 
 #End Region
 
     Private mLinkURL As String = "http
     Private mUpdateRequested As Boolean
     Private mText(2) As String
         InitializeComponent()
 
         'Add any initialization after the InitializeComponent() call
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="198" endline="214">
<![CDATA[
 
     ''' <summary>
     ''' Clone the emitinfo for a left hand side expression.
     ''' </summary>
     ''' <param name="RHSExpression"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function Clone(ByVal Context As ParsedObject, ByVal RHSExpression As Expression) As EmitInfo
         Dim result As New EmitInfo(Me)
 
         result.m_IsRHS = False
         result.m_RHSExpression = RHSExpression
         result.m_DesiredType = Nothing
         result.m_Context = Context
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmManual.vb" startline="202" endline="211">
<![CDATA[
 
 #End Region
 
 #Region "Snapshots"
 
     Private Sub TxtName_KeyDown(ByVal sender As Object, ByVal e As System.Windows.Forms.KeyEventArgs) Handles TxtName.KeyDown
         If e.KeyData = Keys.Enter Then
             TxtDescription.Focus()
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\StdToolMgr.vb" startline="590" endline="598">
<![CDATA[
 
 #End Region
 
 #Region "   Events "
 
     Private Sub VolBar_ValueChanged(ByVal sender As Object, _
     ByVal e As System.EventArgs) Handles VolBar.ValueChanged
         RaiseEvent VolumeChanged(VolBar.Value)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1837" endline="1867">
<![CDATA[
 
     Shared Sub EmitStoreIndirect(ByVal Info As EmitInfo, ByVal ByRefType As Mono.Cecil.TypeReference)
         ByRefType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ByRefType)
         Dim elementtype As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ByRefType)
         Select Case Helper.GetTypeCode(Info.Compiler, elementtype)
             Case TypeCode.SByte, TypeCode.Byte, TypeCode.Boolean
                 Info.ILGen.Emit(OpCodes.Stind_I1)
             Case TypeCode.Int16, TypeCode.UInt16, TypeCode.Char
                 Info.ILGen.Emit(OpCodes.Stind_I2)
             Case TypeCode.Int32, TypeCode.UInt32
                 Info.ILGen.Emit(OpCodes.Stind_I4)
             Case TypeCode.Int64, TypeCode.UInt64
                 Info.ILGen.Emit(OpCodes.Stind_I8)
             Case TypeCode.Single
                 Info.ILGen.Emit(OpCodes.Stind_R4)
             Case TypeCode.Double
                 Info.ILGen.Emit(OpCodes.Stind_R8)
             Case TypeCode.String
                 Info.ILGen.Emit(OpCodes.Stind_Ref)
             Case TypeCode.DateTime, TypeCode.Decimal
                 Info.ILGen.Emit(OpCodes.Stobj, elementtype)
             Case TypeCode.Object
                 If CecilHelper.IsValueType(elementtype) Then
                     Info.ILGen.Emit(OpCodes.Stobj, elementtype)
                 Else
                     Info.ILGen.Emit(OpCodes.Stind_Ref)
                 End If
             Case Else
                 Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End Select
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmDiagnostics.vb" startline="520" endline="539">
<![CDATA[
 
     Private Sub Manual_Fix(ByVal Name As String, ByVal Index As Byte)
 
         Try
             SrvcCntrl.ServiceName = (Name)
             Dim ChkSrvc As Boolean = SrvcCntrl.CanPauseAndContinue
         Catch ex As InvalidOperationException
             LstServices.Items.Item(Index).Checked = False
             Exit Sub
         End Try
 
         If LstServices.Items.Item(Index).SubItems.Item(1).Text = S4 Then
             SrvcCntrl.StartupType = ("Manual")
         End If
 
         LstServices.Items.Item(Index).Checked = False
         LstServices.Items.Item(Index).SubItems.Item(1).Text = S1
         LstServices.Items.Item(Index).SubItems.Item(1).ForeColor = Color.Green
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2336" endline="2344">
<![CDATA[
 
     Private Sub PlaySelectedSegments()
         mPlaySelected = True
         mPlaySelIndex = 0
         Timer.Enabled = True
 
         mPlayer.Ctlcontrols.currentPosition = mPlaySegments(0).Start
         mPlayer.Ctlcontrols.play()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3963" endline="3976">
<![CDATA[
 
     Private Sub ShowProcessStat(ByVal Stat As MessageType)
         Select Case Stat
             Case modMain.MessageType.Failure
                 lMsgStat.Text = mTranslator.LangText(30)
                 lMsgStat.ForeColor = Color.Red
                 picStat.Image = ImageList1.Images(13)
                 'change image
             Case modMain.MessageType.Success
                 lMsgStat.Text = mTranslator.LangText(87)
                 lMsgStat.ForeColor = Color.Blue
                 picStat.Image = ImageList1.Images(12)
         End Select
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3815" endline="3822">
<![CDATA[
 
     Private Sub AddToList(ByVal Value As Integer)
         For Each i As Object In cbSize.Items
             If DirectCast(i, Integer) = Value Then Exit Sub
         Next
         cbSize.Items.Add(Value)
         UpdateEstSize()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3654" endline="3666">
<![CDATA[
 
     Private Sub UpdateSelDur()
         If lvPositions.Items.Count = 0 Then Exit Sub
         Dim Sel As Double
         With lvPositions
             For i As Integer = 0 To .Items.Count - 1
                 If .Items(i).SubItems.Count = 1 Then Exit For
                 Sel += MinToSec(.Items(i).SubItems(1).Text) - MinToSec(.Items(i).Text)
             Next
         End With
 
         statSel.Text = mTranslator.LangText(120) & "
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="851" endline="864">
<![CDATA[
 
     Shared Function GetDefaultGenericConstructor(ByVal closedResolvedType As Mono.Cecil.TypeReference) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim candidates As Mono.Collections.Generic.Collection(Of MethodDefinition)
 
         candidates = CecilHelper.FindDefinition(closedResolvedType).Methods
         result = GetDefaultConstructor(candidates)
 
         If result IsNot Nothing Then
             result = CecilHelper.GetCorrectMember(result, closedResolvedType)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="463" endline="485">
<![CDATA[
 
     ''' <summary>
     ''' - Base classes for classes, modules, structures, enums, interfaces and delegates are set.
     ''' - Implemented interfaces for classes are set.
     ''' - Type parameters for classes and structures are set.
     ''' - Classes, modules, structures, interfaces, enums,  delegates and events should implement IDefinable.DefineTypeHierarchy()
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function DefineTypeHierarchy() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "DefineTypeHierarchy " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             result = DefineTypeHierarchy(type) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\UnaryExpressions\Expressions.vb" startline="53" endline="61">
<![CDATA[
 
 #If DEBUG Then
     Protected MustOverride Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
 #End If
     MustOverride ReadOnly Property Keyword() As KS
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Return tm.CurrentToken.Equals(Enums.UnaryOperators)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="455" endline="463">
<![CDATA[
 
     Function MakeGenericParameter(ByVal Parent As ParsedObject, ByVal OpenParameter As Mono.Cecil.ParameterReference, ByVal ParameterType As Mono.Cecil.TypeReference) As Mono.Cecil.ParameterReference
         Dim result As Mono.Cecil.ParameterReference
 
         'result = New GenericParameterDescriptor(Parent, ParameterType, OpenParameter)
         result = Nothing 
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="63" endline="69">
<![CDATA[
     End Property
 
     Function GetAllDictionaries() As Generic.List(Of TypeDictionary)
         Dim result As New Generic.List(Of TypeDictionary)
         result.AddRange(Values)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3487" endline="3498">
<![CDATA[
 
     Private Function SecToMin(ByVal Sec As Double) As String
 
         Dim TempDt As Date
         TempDt = Date.FromOADate(Sec / 86400)    '24 * 60 * 60
         If Sec >= 3600 Then
             Return TempDt.ToString("HH
         Else
             Return TempDt.ToString("mm
         End If
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\StdToolMgr.vb" startline="629" endline="640">
<![CDATA[
 
     Private Function SecToMin(ByVal Sec As Double) As String
 
         Dim TempDt As Date
         TempDt = Date.FromOADate(Sec / 86400)    '24 * 60 * 60
         If Sec >= 3600 Then
             Return TempDt.ToString("H
         Else
             Return TempDt.ToString("mm
         End If
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="158" endline="169">
<![CDATA[
 
     Private Function IsPositiveStep() As Boolean
         Dim constant As Object = Nothing
 
         If Not m_LoopStepExpression.GetConstant(constant, True) Then Return False
 
         If TypeOf constant Is Decimal Then
             Return CDec(constant) > 0
         Else
             Return CDbl(constant) > 0
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="3872" endline="3911">
<![CDATA[
 
     ''' <summary>
     ''' Creates a vb-like representation of the parameters
     ''' </summary>
     ''' <param name="Params"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Shared Function ToString(ByVal Context As BaseObject, ByVal Params As Mono.Collections.Generic.Collection(Of ParameterDefinition)) As String
         Dim result As New Text.StringBuilder()
 
         result.Append("(")
         For i As Integer = 0 To Params.Count - 1
             Dim t As Mono.Cecil.ParameterDefinition = Params(i)
             Dim tmp As String = String.Empty
             Dim tp As TypeReference
 
             tp = t.ParameterType
             If CecilHelper.IsByRef(tp) Then
                 result.Append("ByRef ")
                 tp = CecilHelper.GetElementType(tp)
             End If
             If t.IsOptional Then
                 result.Append("Optional ")
             End If
             If Helper.IsParamArrayParameter(Context, t) Then
                 result.Append("ParamArray ")
             End If
             result.Append(t.Name)
             If CecilHelper.IsArray(tp) AndAlso CecilHelper.GetArrayRank(tp) = 1 Then
                 result.Append("()")
                 tp = CecilHelper.GetElementType(tp)
             End If
             result.Append(" As ")
             result.Append(ToString(Context, tp))
             If i < Params.Count - 1 Then result.Append(", ")
         Next
         result.Append(")")
 
         Return result.ToString()
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MemberCache.vb" startline="412" endline="456">
<![CDATA[
 
     Private Function IsHidden(ByVal baseMember As Mono.Cecil.MemberReference, ByVal Visibility As MemberVisibility, ByVal exclude As Mono.Collections.Generic.Collection(Of MemberReference)) As Boolean
         Dim current As MemberCacheEntry
         Dim memberParameterTypes As Mono.Cecil.TypeReference() = Nothing
 
         current = Lookup(baseMember.Name, Visibility, True)
 
         If current Is Nothing Then
             Return False
         End If
 
         For i As Integer = 0 To current.Members.Count - 1
             Dim thisMember As Mono.Cecil.MemberReference = current.Members(i)
             If CecilHelper.GetMemberType(thisMember) <> CecilHelper.GetMemberType(baseMember) Then
                 Return True
             End If
 
             If exclude.Contains(thisMember) Then Continue For
 
             Select Case CecilHelper.GetMemberType(thisMember)
                 Case MemberTypes.Constructor, MemberTypes.Event, MemberTypes.Field, MemberTypes.NestedType, MemberTypes.TypeInfo
                     Return True
                 Case MemberTypes.Property, MemberTypes.Method
                     Dim methodAttributes As Mono.Cecil.MethodAttributes
                     Dim isHideBySig, isVirtual, isNewSlot As Boolean
                     Dim isOverrides As Boolean
 
                     methodAttributes = Helper.GetMethodAttributes(thisMember)
                     isHideBySig = CBool(methodAttributes And Reflection.MethodAttributes.HideBySig)
                     isVirtual = CBool(methodAttributes And Reflection.MethodAttributes.Virtual)
                     isNewSlot = CBool(methodAttributes And Reflection.MethodAttributes.NewSlot)
                     isOverrides = isVirtual AndAlso isNewSlot = False
                     If isHideBySig = False AndAlso isOverrides = False Then
                         Return True
                     End If
                     If memberParameterTypes Is Nothing Then memberParameterTypes = Helper.GetTypes(Helper.GetParameters(m_Compiler, baseMember))
                     If Helper.CompareTypes(Helper.GetTypes(Helper.GetParameters(m_Compiler, thisMember)), memberParameterTypes) Then
                         Return True
                     End If
                 Case Else
                     Throw New InternalException("")
             End Select
         Next
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="370" endline="379">
<![CDATA[
 
     Overridable Function DefineOverrides() As Boolean
         Dim result As Boolean = True
 
         If m_MethodOverrides IsNot Nothing Then
             Throw New NotImplementedException
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\EndStatement.vb" startline="42" endline="56">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim m As Object
         Dim method As IMethod
 
         Compiler.Helper.AddCheck("End statements may not be used in programs that are not executable (for example, DLLs). ")
 
         m = FindMethod()
         method = TryCast(m, IMethod)
         If method IsNot Nothing Then
             method.CecilBuilder.ImplAttributes = Mono.Cecil.MethodImplAttributes.NoInlining Or Mono.Cecil.MethodImplAttributes.NoOptimization
         End If
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="270" endline="279">
<![CDATA[
 
     Shared Function IsOnMono() As Boolean
         Dim t As Type = GetType(Integer)
 
         If t.GetType().ToString = "System.MonoType" Then
             Return True
         Else
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MemberCache.vb" startline="554" endline="572">
<![CDATA[
 
     ''' <summary>
     ''' This function returns a COPY of the members list in the cache.
     ''' To be avoided if possible.
     ''' </summary>
     ''' <param name="Name"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function LookupMembersFlattened(ByVal Name As String) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim result As New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim tmp As MemberCacheEntry
 
         tmp = LookupFlattened(Name)
         If tmp IsNot Nothing Then
             result.AddRange(tmp.Members)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="1251" endline="1257">
<![CDATA[
 
     Public Shared Function FindDefinition(ByVal param As ParameterReference) As ParameterDefinition
         If param Is Nothing Then Return Nothing
         Dim pD As ParameterDefinition = TryCast(param, ParameterDefinition)
         If pD IsNot Nothing Then Return pD
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\CMPT890\CS VB JS examples\Examples\VB.NET\examples\MainModule.vb" startline="82" endline="92">
<![CDATA[
 
     Public Const InputFilesDirectory As String = "Inputs"
     Private Shared exeExts As ArrayList
 
     Private Shared Sub deleteNonExecutables(ByVal dir As String)
         For Each f As String In Directory.GetFiles(dir)
             If Not exeExts.Contains(Path.GetExtension(f)) Then
                 File.Delete(f)
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\EventHandlesList.vb" startline="30" endline="39">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         For Each Item As EventMemberSpecifier In Me
             result = Item.ResolveTypeReferences AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2088" endline="2095">
<![CDATA[
 
     Shared Function ResolveStatementCollection(ByVal Collection As IEnumerable, ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         For Each obj As Statement In Collection
             result = obj.ResolveStatement(Info) AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2096" endline="2103">
<![CDATA[
 
     Shared Function GenerateCodeCollection(ByVal Collection As IEnumerable, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         For Each obj As IBaseObject In Collection
             result = obj.GenerateCode(Info) AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="1258" endline="1267">
<![CDATA[
 
     Public Shared Function GetField(ByVal collection As ICollection, ByVal reference As FieldReference) As FieldDefinition
         For Each field As FieldDefinition In collection
             If Not Helper.CompareNameOrdinal(field.Name, reference.Name) Then
                 Continue For
             End If
             Return field
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="1322" endline="1331">
<![CDATA[
 
     Public Shared Function GetEvent(ByVal collection As ICollection, ByVal reference As EventReference) As EventDefinition
         For Each meth As EventDefinition In collection
             If Helper.CompareNameOrdinal(meth.Name, reference.Name) = False Then
                 Continue For
             End If
             Return meth
         Next
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\ImportsClause.vb" startline="27" endline="39">
<![CDATA[
     Function GetNamespaces(ByVal FromWhere As BaseObject, ByVal Name As String) As Generic.List(Of [Namespace])
         Dim result As New Generic.List(Of [Namespace])
         For Each imp As ImportsClause In Me
             If imp.IsNamespaceClause AndAlso imp.AsNamespaceClause.IsNamespaceImport Then
                 Dim ns As [Namespace]
                 ns = FromWhere.Compiler.TypeManager.Namespaces.Item(imp.AsNamespaceClause.NamespaceImported, Name)
                 If ns IsNot Nothing Then
                     result.Add(ns)
                 End If
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="449" endline="485">
<![CDATA[
 
 #End Region
 
 #Region "System Usage"
 
     <DllImport("kernel32", CharSet
     End Function
 
     Private Sub GetCPUUsage()
 
         Dim usageUpdateSpeed As Integer = 1800
         Dim usage As Double
         Dim stopUsage As Boolean = False
 
         If BWCPUUsg.CancellationPending Then
             BWCPUUsg.CancelAsync()
         End If
 
         Dim eIdle, eKernel, eUser, sIdle, sKernel, sUser, cIdle, cKernel, cUser As Int64
         Dim systemTime As Int32
         Dim totalCpuUsage As Double
 
         Do
             GetSystemTimes(sIdle, sKernel, sUser)
             Threading.Thread.Sleep(usageUpdateSpeed)
             GetSystemTimes(eIdle, eKernel, eUser)
             cIdle = (eIdle - sIdle)
             cKernel = (eKernel - sKernel)
             cUser = (eUser - sUser)
             systemTime = Convert.ToInt32(cKernel + cUser)
             totalCpuUsage = (systemTime - cIdle) * (100) / (systemTime)
             usage = totalCpuUsage
             BWCPUUsg.ReportProgress(Convert.ToInt32(totalCpuUsage))
             System.Windows.Forms.Application.DoEvents()
         Loop Until stopUsage OrElse BWCPUUsg.CancellationPending
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="782" endline="798">
<![CDATA[
 
     Shared Function FilterByName(ByVal Context As BaseObject, ByVal collection As ICollection, ByVal Name As String) As ArrayList
         Dim result As New ArrayList
         Dim tmpname As String = ""
         For Each obj As Object In collection
             If TypeOf obj Is INameable Then
                 tmpname = DirectCast(obj, INameable).Name
             ElseIf TypeOf obj Is Mono.Cecil.MemberReference Then
                 tmpname = DirectCast(obj, Mono.Cecil.MemberReference).Name
             Else
                 Context.Compiler.Report.ShowMessage(Messages.VBNC99997, Context.Location)
             End If
             If Helper.CompareName(Name, tmpname) Then result.Add(obj)
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\ImportsClause.vb" startline="40" endline="66">
<![CDATA[
 
     ''' <summary>
     ''' Looks up all the modules imported by all the imports clauses.
     ''' </summary>
     ''' <param name="FromWhere"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function GetModules(ByVal FromWhere As BaseObject) As TypeList
         Dim result As TypeList = Nothing
         For Each imp As ImportsClause In Me
             If imp.IsNamespaceClause Then
                 Dim ns As ImportsNamespaceClause = imp.AsNamespaceClause
                 If ns.IsTypeImport Then
                     'A type cannot contain a module, nothing to do here.
                 ElseIf ns.IsNamespaceImport Then
                     Dim modules As TypeDictionary = FromWhere.Compiler.TypeManager.GetModulesByNamespace(ns.NamespaceImported.ToString)
                     If modules IsNot Nothing AndAlso modules.Count > 0 Then
                         If result Is Nothing Then result = New TypeList
                         result.AddRange(modules.TypesAsArray)
                     End If
                 Else
                     Continue For 'This import was not resolved correctly, don't use it.
                 End If
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2524" endline="2544">
<![CDATA[
 
     Private Function isValidExtension(ByVal Filename As String, _
     Optional ByVal TestExt As String = ".mpg") As Boolean
 
         Dim fi As New FileInfo(Filename)
         Dim Ext As String = LCase(fi.Extension)
 
         If isValidExtenstionSlave(mStdToolMgr.ValidExtenstions(True), Ext) Then
             mMaskFile = (Ext = ".moviclip")
             Return True
         ElseIf isValidExtenstionSlave(".rm|.flv", Ext) Then
             Throw New ArgumentException("Configuration required for " + Filename + vbCrLf + _
             vbCrLf + "Files with extension '" + Ext + "' are supported but require external tools" + _
             vbCrLf + "See the Tools tab to learn more")
         Else
             Throw New ArgumentException("Error in reading file " + Filename + vbCrLf + _
             vbCrLf + "Files with extension '" + Ext + "' are not supported" + _
             vbCrLf + "Only .avi, .wmv, .asf, .mpg, .mpeg, .rm, .flv, .wma, .mp3 and .moviclip files are supported")
         End If
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4767" endline="4790">
<![CDATA[
 
     Shared Function GetOverloadableSignatures(ByVal Compiler As Compiler, ByVal Member As Mono.Cecil.MemberReference) As String()
         Dim result As New Generic.List(Of String)
         Dim params As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         Dim types() As Mono.Cecil.TypeReference
         Dim sep As String = ""
 
         params = Helper.GetParameters(Compiler, Member)
         types = Helper.GetTypes(params)
 
         Dim signature As String = ""
         For i As Integer = 0 To types.Length - 1
             If CecilHelper.IsByRef(types(i)) Then types(i) = CecilHelper.GetElementType(types(i))
             If params(i).IsOptional Then
                 result.Add(Member.Name & "(" & signature & ")")
             End If
             signature &= sep & types(i).Namespace & "." & types(i).Name
             sep = ", "
         Next
 
         result.Add(Member.Name & "(" & signature & ")")
 
         Return result.ToArray
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\MPGhandler.vb" startline="70" endline="89">
<![CDATA[
 
     Private Function GetSaveCommand(ByVal Mode As AbstractMediaHandler.Mode) As String
 
         'Range
         Dim Segment As Segment, Range As String = String.Empty
         For Each Segment In mSegments
             Range += " [" + CFmt(Segment.Start) + "-" + CFmt(Segment.Finish) + "]"
         Next
 
         Dim Temp As String
         If Mode = AbstractMediaHandler.Mode.SaveSeparate Then
             Temp = "-s -f -b " & Chr(34) & StripExtension(mOutFile) & Chr(34) & " " & Chr(34) & mInFile & Chr(34) & Range
         Else
             'command options infile range outfile
             Temp = "-j -f " & Chr(34) & mInFile & Chr(34) & Range & " -o " & Chr(34) & mOutFile & Chr(34)
         End If
 
         Return Temp
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MemberCache.vb" startline="70" endline="92">
<![CDATA[
 
 #If DEBUG Then
     Sub DumpFlattenedCache()
         Console.WriteLine("Cache for
         For i As Integer = 0 To m_FlattenedCacheInsensitive.Length - 1
             Dim entries As MemberCacheEntries = m_FlattenedCacheInsensitive(i)
             Dim access As MemberVisibility = CType(i, MemberVisibility)
             If entries Is Nothing Then
                 Console.WriteLine(" Access
             Else
                 Console.WriteLine(" Access
             End If
             Dim keys As New Generic.List(Of String)(entries.Keys)
             keys.Sort()
             For Each str As String In keys
                 Console.WriteLine("  {0}", str)
                 Dim entry As MemberCacheEntry = entries(str)
                 For Each member As Mono.Cecil.MemberReference In entry.Members
                     Console.WriteLine("   " & CecilHelper.GetMemberType(member).ToString & "
                 Next
             Next
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="1081" endline="1093">
<![CDATA[
 
     Public Shared Function IsPrimitive(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As Boolean
         Select Case Helper.GetTypeCode(Compiler, Type)
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Boolean, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64, TypeCode.Char, TypeCode.Double, TypeCode.Single
                 Return True
             Case Else
                 If Helper.CompareType(Type, Compiler.TypeCache.System_IntPtr) Then
                     Return True
                 Else
                     Return False
                 End If
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="1196" endline="1210">
<![CDATA[
 
     Private Function ExtractShort(ByVal Value As ULong, ByVal Base As IntegerBase) As Short
         Select Case Base
             Case IntegerBase.Decimal
                 Return CShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Short.MaxValue Then
                     Return CShort(Short.MinValue + (CUShort(Value) - Short.MaxValue - 1))
                 Else
                     Return CShort(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3032" endline="3039">
<![CDATA[
 
     Private Function Parse(ByVal Info As ExpressionParseInfo) As Expression
         Dim result As Expression
 
         result = ParseOr_OrElse_Xor(Info)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="960" endline="966">
<![CDATA[
 
     'Cecil's ValueType property returns true for arrays of value types
     Public Shared Function IsValueType(ByVal Type As Mono.Cecil.TypeReference) As Boolean
         If TypeOf Type Is ArrayType Then Return False
         If TypeOf Type Is ByReferenceType Then Return False
         Return Type.IsValueType
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\BaseObject.vb" startline="243" endline="257">
<![CDATA[
     End Property
 
 #If DEBUG Then
     ReadOnly Property ParentTree() As String()
         Get
             Dim result As New Generic.List(Of String)
 
             Dim tmp As BaseObject = Me
             Do Until tmp Is Nothing
                 result.Add(tmp.GetType.Name)
                 tmp = tmp.Parent
             Loop
             Do Until tmp Is Nothing
                 result.Add(tmp.GetType.Name)
                 tmp = tmp.Parent
             Loop
 
             Return result.ToArray
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="428" endline="442">
<![CDATA[
 
     Function ResolveMembers() As Boolean
         Dim result As Boolean = True
 
         For Each type As TypeDeclaration In m_TypeDeclarations
 #If EXTENDEDDEBUG Then
             Dim iCount As Integer
             iCount += 1
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveMembers " & type.FullName & " (" & iCount & " of " & m_TypeDeclarations.Length & " types)")
 #End If
             result = ResolveMembers(type) AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="59" endline="82">
<![CDATA[
     Public Shared Sub Main(ByVal args As String())
         Console.WriteLine("Chapter 1 example 3
 
         ' step 1
         Dim document As New Document(PageSize.A4.rotate())
 
         ' step 2
         ' we create a writer that listens to the document
         ' and directs a PDF-stream to a file
 
         PdfWriter.getInstance(document, New FileOutputStream("Chap0103.pdf"))
 
         ' step 3
         document.open()
 
         ' step 4
         Dim i As Integer
         For i = 0 To 20
             document.add(New Phrase("Hello World, Hello Sun, Hello Moon, Hello Stars, Hello Sea, Hello Land, Hello People. "))
         Next
 
         ' step 5
         document.close()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="535" endline="577">
<![CDATA[
 
     Public Shared Function GetCorrectMember(ByVal Member As MethodDefinition, ByVal Arguments As Mono.Collections.Generic.Collection(Of TypeReference), Optional ByVal Emittable As Boolean = False) As Mono.Cecil.MethodReference
         Dim result As Mono.Cecil.MethodReference
         Dim parameters As Mono.Collections.Generic.Collection(Of GenericParameter) = Member.GenericParameters
         Dim returnType As Mono.Cecil.TypeReference
         Dim reflectableMember As Mono.Cecil.MethodReference
 
         If Member.GenericParameters.Count = 0 Then Return Member
 
         returnType = CecilHelper.ResolveType(Member.ReturnType, parameters, Arguments)
         returnType = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, returnType)
         result = New Mono.Cecil.MethodReference(Member.Name, Member.DeclaringType, returnType, Member.HasThis, Member.ExplicitThis, Member.CallingConvention)
         reflectableMember = New Mono.Cecil.MethodReference(Member.Name, Member.DeclaringType, returnType, Member.HasThis, Member.ExplicitThis, Member.CallingConvention)
         reflectableMember.OriginalMethod = Member
         result.OriginalMethod = Member
 
         For i As Integer = 0 To Member.GenericParameters.Count - 1
             result.GenericParameters.Add(Member.GenericParameters(i))
             reflectableMember.GenericParameters.Add(Member.GenericParameters(i))
         Next
 
         For i As Integer = 0 To Member.Parameters.Count - 1
             Dim pD As Mono.Cecil.ParameterDefinition = Member.Parameters(i)
             Dim pDType As Mono.Cecil.TypeReference
             pDType = InflateType(pD.ParameterType, parameters, Arguments)
             If pDType IsNot pD.ParameterType Then
                 Dim newPD As Mono.Cecil.ParameterDefinition
                 Dim pd2 As Mono.Cecil.TypeReference
                 pDType = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, pDType)
                 newPD = New ParameterDefinition(pD.Name, pD.Attributes, pDType)
                 result.Parameters.Add(newPD)
                 pd2 = Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, pD.ParameterType)
                 reflectableMember.Parameters.Add(New ParameterDefinition(pD.Name, pD.Attributes, pd2))
             Else
                 result.Parameters.Add(pD)
                 reflectableMember.Parameters.Add(pD)
             End If
         Next
 
         result.Annotations.Add("MemberInReflection", reflectableMember)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Index.vb" startline="50" endline="60">
<![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub New(ByVal Obj As IBaseObject)
         MyBase.new()
         If Obj IsNot Nothing Then
             m_Message = "There has been an internal error in the compiler caused by the line
         Else
             m_Message = "There has been an internal error in the compiler."
         End If
         StopOnInternalException()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmAuto.vb" startline="267" endline="290">
<![CDATA[
 
     Private Sub Max_TuneUp(ByVal Name As String, ByVal Setting As Byte)
 
         Try
             SrvcCntrl.ServiceName = (Name)
             Dim ChkSrvc As Boolean = SrvcCntrl.CanPauseAndContinue
         Catch ex As InvalidOperationException
             Exit Sub
         End Try
 
         If Setting = 0 Then
             SrvcCntrl.StartupType = ("Manual")
         ElseIf Setting = 1 Then
             SrvcCntrl.StartupType = ("Disabled")
         End If
 
         Try
             SrvcCntrl.Stop()
             SrvcCntrl.WaitForStatus(ServiceProcess.ServiceControllerStatus.Stopped, TimeSpan.FromSeconds(3))
         Catch ex As InvalidOperationException
         Catch ex As System.ServiceProcess.TimeoutException
         End Try
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmSrvcMngr.vb" startline="174" endline="202">
<![CDATA[
 
 #End Region
 
 #Region "Tools"
 
     Private Sub BtnStart_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles BtnStart.Click, ItmStart.Click
 
         Try
             SrvcCntrl.ServiceName = (ServiceName)
             SrvcCntrl.Start()
             SrvcCntrl.WaitForStatus(ServiceProcess.ServiceControllerStatus.Running, TimeSpan.FromSeconds(3))
 
             LstServices.Items.Item(Index).SubItems.Item(2).Text = SrvcCntrl.Status.ToString
 
             If SrvcCntrl.Status = ServiceProcess.ServiceControllerStatus.Running Then
                 BtnStart.Enabled = ComponentFactory.Krypton.Toolkit.ButtonEnabled.False
                 BtnStop.Enabled = ComponentFactory.Krypton.Toolkit.ButtonEnabled.True
             ElseIf SrvcCntrl.Status = ServiceProcess.ServiceControllerStatus.Stopped Then
                 BtnStart.Enabled = ComponentFactory.Krypton.Toolkit.ButtonEnabled.True
                 BtnStop.Enabled = ComponentFactory.Krypton.Toolkit.ButtonEnabled.False
             End If
 
         Catch ex As System.ServiceProcess.TimeoutException
             MessageBox.Show("The selected Windows service can not be started.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
         Catch ex As InvalidOperationException
             MessageBox.Show("The selected Windows service can not be started.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
         End Try
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmSrvcMngr.vb" startline="203" endline="227">
<![CDATA[
 
     Private Sub BtnStop_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles BtnStop.Click, ItmStop.Click
 
         Try
             SrvcCntrl.ServiceName = (ServiceName)
             SrvcCntrl.Stop()
             SrvcCntrl.WaitForStatus(ServiceProcess.ServiceControllerStatus.Stopped, TimeSpan.FromSeconds(3))
 
             LstServices.Items.Item(Index).SubItems.Item(2).Text = SrvcCntrl.Status.ToString
 
             If SrvcCntrl.Status = ServiceProcess.ServiceControllerStatus.Running Then
                 BtnStart.Enabled = ComponentFactory.Krypton.Toolkit.ButtonEnabled.False
                 BtnStop.Enabled = ComponentFactory.Krypton.Toolkit.ButtonEnabled.True
             ElseIf SrvcCntrl.Status = ServiceProcess.ServiceControllerStatus.Stopped Then
                 BtnStart.Enabled = ComponentFactory.Krypton.Toolkit.ButtonEnabled.True
                 BtnStop.Enabled = ComponentFactory.Krypton.Toolkit.ButtonEnabled.False
             End If
 
         Catch ex As System.ServiceProcess.TimeoutException
             MessageBox.Show("The selected Windows service can not be stopped.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
         Catch ex As InvalidOperationException
             MessageBox.Show("The selected Windows service can not be stopped.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
         End Try
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="72" endline="127">
<![CDATA[
     End Property
 
     Public Overrides Function GetConstant(ByRef result As Object, ByVal ShowError As Boolean) As Boolean
         Dim rvalue As Object = Nothing
         Dim lvalue As Object = Nothing
 
         If Not m_LeftExpression.GetConstant(lvalue, ShowError) Then Return False
         If Not m_RightExpression.GetConstant(rvalue, ShowError) Then Return False
 
         If lvalue Is Nothing Or rvalue Is Nothing Then
             result = Nothing
             Return True
         End If
 
         Dim tlvalue, trvalue As Mono.Cecil.TypeReference
         Dim clvalue, crvalue As TypeCode
         tlvalue = CecilHelper.GetType(Compiler, lvalue)
         clvalue = Helper.GetTypeCode(Compiler, tlvalue)
         trvalue = CecilHelper.GetType(Compiler, rvalue)
         crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
         If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
             result = CBool(lvalue) AndAlso CBool(rvalue)
             Return True
         End If
 
         Dim smallest As Mono.Cecil.TypeReference
         Dim csmallest As TypeCode
         smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
         Helper.Assert(smallest IsNot Nothing)
         csmallest = Helper.GetTypeCode(Compiler, smallest)
 
         Select Case csmallest
             Case TypeCode.Byte
                 result = CByte(lvalue) And CByte(rvalue)
             Case TypeCode.SByte
                 result = CSByte(lvalue) And CSByte(rvalue)
             Case TypeCode.Int16
                 result = CShort(lvalue) And CShort(rvalue)
             Case TypeCode.UInt16
                 result = CUShort(lvalue) And CUShort(rvalue)
             Case TypeCode.Int32
                 result = CInt(lvalue) And CInt(rvalue)
             Case TypeCode.UInt32
                 result = CUInt(lvalue) And CUInt(rvalue)
             Case TypeCode.Int64
                 result = CLng(lvalue) And CLng(rvalue)
             Case TypeCode.UInt64
                 result = CULng(lvalue) And CULng(rvalue)
             Case Else
                 If ShowError Then Show30059()
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2071" endline="2125">
<![CDATA[
 
     Private Sub SaveOutput(Optional ByVal _
         Mode As AbstractMediaHandler.Mode = AbstractMediaHandler.Mode.SaveSelected)
 
         If Not FinishTheList() Then Exit Sub
 
         UpdateHandlerOptions()
 
         dlgSaveFile.InitialDirectory = dlgOpenFile.InitialDirectory
         dlgSaveFile.DefaultExt = mHandler.Extension
         dlgSaveFile.FileName = ""
         dlgSaveFile.Filter = mHandler.Extension(True) + " |*" + mHandler.Extension
 
         If dlgSaveFile.ShowDialog() = Windows.Forms.DialogResult.OK Then
             Me.Refresh()
 
             Dim Filename As String = dlgSaveFile.FileName
             If Filename = mHandler.InputFile Then
                 MsgBox("Output cannot be the same as the input file")
                 Exit Sub
             End If
 
             Dim CutterPath As String
             CutterPath = System.AppDomain.CurrentDomain.BaseDirectory
 
             If Len(Filename) > 0 Then
 
                 mainTabs.SelectedTab = tabTrace
                 statMain.Text = mTranslator.LangText(72)
                 rtfTrace.Clear()
 
                 Try
                     Dim Segments As Segment() = GetSegmentArray(Mode)
 
                     If mHandler.Save(Filename, Segments, Mode) Then
                         UpdateRTF(mTranslator.LangText(87) & vbCrLf & vbCrLf, _
                             modMain.MessageType.Success)
                         ShowProcessStat(modMain.MessageType.Success)
                     Else
                         UpdateRTF(vbCrLf & "Conversion Failed !!" & vbCrLf & vbCrLf, _
                             modMain.MessageType.Failure)
                         ShowProcessStat(modMain.MessageType.Failure)
                     End If
                 Catch ex As Exception
                     MsgBox(ex.Message)
                 End Try
 
                 mSelsDirty = False
                 statMain.Text = mTranslator.LangText(23)
                 If chkBeep.Checked Then Beep()
 
             End If
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="6601" endline="6668">
<![CDATA[
 
     ''' <summary>
     ''' StructureDeclaration  
     '''	[  Attributes  ]  [  StructureModifier+  ]  "Structure" Identifier  [  TypeParameters  ]	StatementTerminator
     '''	[  TypeImplementsClause+  ]
     '''	[  StructMemberDeclaration+  ]
     '''	"End" "Structure"  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseStructureDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As StructureDeclaration
         Dim result As StructureDeclaration = Nothing
         Dim partialType As PartialTypeDeclaration
 
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_TypeParameters As TypeParameters
         Dim m_DeclaringType As TypeDeclaration
         Dim m_Attributes As Attributes
 
         m_DeclaringType = TryCast(Parent, TypeDeclaration)
         Helper.Assert(m_DeclaringType IsNot Nothing OrElse TypeOf Parent Is AssemblyDeclaration)
 
         m_Attributes = Attributes
         m_Modifiers = ParseModifiers(ModifierMasks.StructureModifiers)
 
         tm.AcceptIfNotInternalError(KS.Structure)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptEndOfStatement = False Then
             m_TypeParameters = ParseTypeParameters(result)
             If m_TypeParameters Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeParameters = Nothing
         End If
 
         'Here we have enough information to know if it's a partial type or not
         partialType = GetPartialType(Parent, m_Identifier, m_TypeParameters, m_Modifiers, False, [Namespace])
 
         result = TryCast(partialType, StructureDeclaration)
         If result Is Nothing Then
             If partialType IsNot Nothing Then
                 Helper.AddError(tm.Compiler, tm.CurrentLocation, "Partial types must be either all classes or all structures.")
             Else
                 'Error message has already been shown
             End If
             Return Nothing
         End If
 
         m_Identifier.Parent = result
         If m_TypeParameters IsNot Nothing Then
             m_TypeParameters.Parent = result
         End If
 
         result.Implements = ParseTypeImplementsClauses(result)
         If result.Implements Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If ParseTypeMembers(result) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Structure) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Attributes
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmSrvcMngr.vb" startline="22" endline="54">
<![CDATA[
     End Property
 
     Private Sub FrmSrvcMngr_Load(ByVal sender As Object, ByVal e As System.EventArgs) Handles Me.Load
 
         On Error Resume Next
 
         BtnStart.Image = New Bitmap(DataDir & "Services Manager\start.png")
         BtnStop.Image = New Bitmap(DataDir & "Services Manager\stop.png")
         BtnStartup.Image = New Bitmap(DataDir & "apply.png")
         BtnDelete.Image = New Bitmap(DataDir & "delete.png")
         BtnSearch.Image = New Bitmap(DataDir & "Services Manager\search.png")
         BtnExport.Image = New Bitmap(DataDir & "export.png")
         BtnRefresh.Image = New Bitmap(DataDir & "Services Manager\refresh.png")
         BtnSnapshot.Image = New Bitmap(DataDir & "Services Manager\snapshot.png")
 
         Call Load_Services()
 
         If My.Settings.QueryNet = 0 Then
             BtnSearch.Enabled = ComponentFactory.Krypton.Toolkit.ButtonEnabled.False
             ItmSearch.Enabled = False
         ElseIf My.Settings.QueryNet = 1 Then
             SearchEngine = "http
         ElseIf My.Settings.QueryNet = 2 Then
             SearchEngine = "http
         ElseIf My.Settings.QueryNet = 3 Then
             SearchEngine = "http
         End If
 
         If My.Settings.ViewInfo = False Then
             SplitPnl.Panel2Collapsed = True
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5732" endline="5804">
<![CDATA[
     ''' <summary>
     ''' IfStatement  
     ''' BlockIfStatement  
     '''	   "If" BooleanExpression  [ "Then" ]  StatementTerminator
     '''	        [  Block  ]
     '''	   [  ElseIfStatement+  ]
     '''	   [  ElseStatement  ]
     '''	   "End" "If" StatementTerminator
     ''' ElseIfStatement  
     '''	   "ElseIf" BooleanExpression  [ "Then" ]  StatementTerminator
     '''	        [  Block  ]
     ''' ElseStatement  
     '''	   "Else" StatementTerminator
     '''	        [  Block  ]
     ''' LineIfThenStatement  
     '''	   "If" BooleanExpression "Then" Statements  [ "Else" Statements  ]  StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseIfStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As IfStatement
         Dim result As New IfStatement(Parent)
 
         Dim m_Condition As Expression
         Dim m_TrueCode As CodeBlock
         Dim m_FalseCode As CodeBlock
         Dim m_OneLiner As Boolean
         Dim m_ElseIfs As BaseObjects(Of ElseIfStatement)
 
         tm.AcceptIfNotInternalError(KS.If)
         m_Condition = ParseExpression(result)
         If m_Condition Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Then) = False Then
             m_OneLiner = False 'Cannot be a oneliner if Then is not found.
             If IsOneLiner Then
                 Helper.AddError(Compiler, tm.CurrentLocation, "report error BC30081, 'if' must end with a matching 'end if'")
                 tm.GotoNewline(False)
             Else
                 tm.AcceptEndOfStatement(False, True)
             End If
         Else
             If IsOneLiner = False Then
                 m_OneLiner = Not tm.AcceptEndOfStatement(False, False)
             Else
                 m_OneLiner = True
             End If
         End If
 
         m_TrueCode = ParseCodeBlock(result, m_OneLiner)
         If m_TrueCode Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_ElseIfs = New BaseObjects(Of ElseIfStatement)(result)
         While tm.CurrentToken = KS.ElseIf OrElse (m_OneLiner = False AndAlso tm.CurrentToken = KS.Else AndAlso tm.PeekToken = KS.If)
             Dim newElseIf As ElseIfStatement
             newElseIf = ParseElseIfStatement(result, m_OneLiner)
             m_ElseIfs.Add(newElseIf)
         End While
         While tm.CurrentToken = KS.ElseIf OrElse (m_OneLiner = False AndAlso tm.CurrentToken = KS.Else AndAlso tm.PeekToken = KS.If)
             Dim newElseIf As ElseIfStatement
             newElseIf = ParseElseIfStatement(result, m_OneLiner)
             m_ElseIfs.Add(newElseIf)
         End While
 
         If tm.Accept(KS.Else) Then
             If m_OneLiner = False Then
                 If tm.AcceptEndOfStatement(False, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             m_FalseCode = ParseCodeBlock(result, m_OneLiner)
             If m_FalseCode Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_FalseCode = Nothing
         End If
 
         If m_OneLiner = False Then tm.AcceptIfNotError(KS.End, KS.If)
 
         result.Init(m_Condition, m_FalseCode, m_TrueCode, m_OneLiner, m_ElseIfs)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\EventHandlesList.vb" startline="61" endline="124">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim eventInfo As ResolveInfo = ResolveInfo.Default(Compiler)
         eventInfo.IsEventResolution = True
 
         result = m_Expression.ResolveExpression(eventInfo) AndAlso result
 
         If result = False Then Return False
 
         If m_Expression.Classification.IsEventAccessClassification = False Then
             Return Compiler.Report.ShowMessage(Messages.VBNC30590, Me.Location, m_Second.Name)
         End If
 
         'Helper.NotImplementedYet("Variable must have WithEvents")
 
         Dim declaringType As TypeDeclaration
         Dim handler As MethodDeclaration
 
         declaringType = Me.FindFirstParent(Of TypeDeclaration)()
         handler = Me.FindFirstParent(Of MethodDeclaration)()
 
         Helper.Assert(declaringType IsNot Nothing)
 
         If TypeOf m_First Is MeExpression OrElse TypeOf m_First Is MyBaseExpression Then
             'add AddHandler to all constructors
 
             Dim arhs As New AddOrRemoveHandlerStatement(Me)
             arhs.Init(m_Expression, handler, True, m_First)
 
             declaringType.AddHandlers.Add(arhs)
 
         Else
             'add AddHandler/RemoveHandler to withevents variable's property
             Dim sne As SimpleNameExpression
             sne = TryCast(m_First, SimpleNameExpression)
             'Console.WriteLine(Me.Location.ToString(Compiler))
             Helper.Assert(sne IsNot Nothing)
             Dim propD As Mono.Cecil.PropertyDefinition 'PropertyDescriptor
             Dim propDecl As PropertyDeclaration
 
             If Not sne.Classification.IsPropertyGroupClassification Then
                 Return Compiler.Report.ShowMessage(Messages.VBNC30506, Me.Location)
             End If
             Helper.Assert(sne.Classification.AsPropertyGroup.IsResolved)
             Helper.Assert(sne.Classification.AsPropertyGroup.ResolvedProperty IsNot Nothing)
 
             propD = CecilHelper.FindDefinition(sne.Classification.AsPropertyGroup.ResolvedProperty)
             propDecl = DirectCast(propD.Annotations(Compiler), PropertyDeclaration)
             Helper.Assert(propD IsNot Nothing)
 
             Dim arhs As New AddOrRemoveHandlerStatement(Me)
             Dim instanceExp As MeExpression = Nothing
             If Helper.IsShared(propD) = False Then
                 instanceExp = New MeExpression(Me)
                 result = instanceExp.ResolveExpression(ResolveInfo.Default(Compiler)) AndAlso result
             End If
 
             arhs.Init(m_Expression, handler, True, instanceExp)
             propDecl.Handlers.Add(arhs)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1064" endline="1108">
<![CDATA[
 
     Shared Function EmitLoadArrayElement(ByVal Info As EmitInfo, ByVal ArrayVariable As Expression, ByVal Arguments As ArgumentList) As Boolean
         Dim result As Boolean = True
         Dim ArrayType As Mono.Cecil.TypeReference = ArrayVariable.ExpressionType
         Dim ElementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
         Dim isNonPrimitiveValueType As Boolean = CecilHelper.IsPrimitive(Info.Compiler, ElementType) = False AndAlso CecilHelper.IsValueType(ElementType)
         Dim isArrayGetValue As Boolean = CecilHelper.GetArrayRank(ArrayType) > 1
 
         result = ArrayVariable.GenerateCode(Info) AndAlso result
 
         If isArrayGetValue Then
             result = Arguments.GenerateCode(Info, Helper.CreateArray(Of Mono.Cecil.TypeReference)(Info.Compiler.TypeCache.System_Int32, Arguments.Length)) AndAlso result
             'result = EmitIntegerArray(Info, Arguments) AndAlso result
             Dim getMethod As Mono.Cecil.MethodReference
             getMethod = ArrayElementInitializer.GetGetMethod(Info.Compiler, ArrayType)
             Helper.Assert(getMethod IsNot Nothing, "getMethod for type " & ArrayType.FullName & " could not be found (" & ArrayType.GetType.Name & ")")
             Emitter.EmitCallVirt(Info, getMethod)
             'Emitter.EmitCallOrCallVirt(Info, Info.Compiler.TypeCache.Array_GetValue)
             'If ElementType.IsValueType Then
             '    Emitter.EmitUnbox(Info, ElementType)
             'Else
             '    Emitter.EmitCastClass(Info, Info.Compiler.TypeCache.Object, ElementType)
             'End If
         Else
             Dim elementInfo As EmitInfo = Info.Clone(Info.Context, True, False, Info.Compiler.TypeCache.System_Int32)
             Dim methodtypes(Arguments.Count - 1) As Mono.Cecil.TypeReference
             For i As Integer = 0 To Arguments.Count - 1
                 Dim exp As Expression = Arguments(i).Expression
                 If Info.Compiler.TypeResolution.IsImplicitlyConvertible(Compiler.m_Compiler, exp.ExpressionType, Info.Compiler.TypeCache.System_Int32) = False Then
                     'TODO
                     exp = New CIntExpression(exp, exp)
                 End If
                 result = exp.GenerateCode(elementInfo) AndAlso result
                 methodtypes(i) = Info.Compiler.TypeCache.System_Int32
             Next
 
             If isNonPrimitiveValueType Then
                 Emitter.EmitLoadElementAddress(Info, ElementType, ArrayType)
                 Emitter.EmitLoadObject(Info, ElementType)
             Else
                 Emitter.EmitLoadElement(Info, ArrayType)
             End If
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CDblExpression.vb" startline="87" endline="133">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_R8(Info, expType)
             Case TypeCode.Double
                 'Nothing to do
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30532, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_R8(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_R8(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDouble_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDouble_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDouble_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToDouble_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4156" endline="4212">
<![CDATA[
 
     ''' <summary>
     ''' ConversionOperatorDeclaration    
     '''	[  Attributes  ]  [  ConversionOperatorModifier+  ]  "Operator" "CType" "("  Operand  ")"
     '''		[  "As"  [  Attributes  ]  TypeName  ]  LineTerminator
     '''	[  Block  ]
     '''	"End" "Operator" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseConversionOperatorDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As ConversionOperatorDeclaration
         Dim result As New ConversionOperatorDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_Operator As Token = Nothing
         Dim m_Operand As Operand = Nothing
         Dim m_ReturnTypeAttributes As Attributes = Nothing
         Dim m_TypeName As TypeName = Nothing
         Dim m_Block As CodeBlock = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.ConversionOperatorModifiers)
 
         tm.AcceptIfNotInternalError(KS.Operator)
 
         If vbnc.ConversionOperatorDeclaration.IsOverloadableConversionOperator(tm.CurrentToken) Then
             m_Operator = tm.CurrentToken 
         Else
             Throw New InternalException(result)
         End If
 
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Operand = ParseOperand(result)
         If m_Operand Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(result, m_ReturnTypeAttributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Block = ParseCodeBlock(result, False)
         If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Operator) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Operator, m_Operand, m_ReturnTypeAttributes, m_TypeName, m_Block)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmProfiles.vb" startline="184" endline="199">
<![CDATA[
 
     Private Sub BtnEdit_Click(ByVal sender As Object, ByVal e As System.EventArgs) Handles BtnEdit.Click, ItmEdit.Click
 
         If File.Exists(SelectedProfile) = False Then
             MessageBox.Show("The selected services profile is missing or corrupted.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
             Call Check_Profiles()
             Exit Sub
         End If
 
         Try
             File.SetAttributes(SelectedProfile, FileAttributes.Normal)
             Process.Start("notepad.exe", (SelectedProfile))
         Catch ex As System.ComponentModel.Win32Exception
         End Try
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3537" endline="3556">
<![CDATA[
 
     Private Sub ToggleFastForward()
 
         'Pause the player and reset other buttons
         mPlayer.Ctlcontrols.pause()
         mFRev = False
         MPcontrols.cFRev.Pushed = False
 
         'Start it again
         If mFFwd Then
             mFFwd = False
             mPlayer.settings.rate = 1
         Else
             mFFwd = True
             mPlayer.settings.rate = 2
         End If
         mPlayer.Ctlcontrols.play()
         MPcontrols.cFFwd.Pushed = mFFwd
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\MRUbuffer.vb" startline="58" endline="64">
<![CDATA[
 
     Public Sub fromXML(ByVal XML As XmlNode)
         If XML Is Nothing Then Exit Sub
         For Each Node As XmlNode In XML.SelectNodes("File")
             Add(Node.InnerText)
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmDiagnostics.vb" startline="494" endline="519">
<![CDATA[
 
     Private Sub Essential_Fix(ByVal Name As String, ByVal Index As Byte)
 
         Try
             SrvcCntrl.ServiceName = (Name)
             Dim ChkSrvc As Boolean = SrvcCntrl.CanPauseAndContinue
         Catch ex As InvalidOperationException
             LstServices.Items.Item(Index).Checked = False
             Exit Sub
         End Try
 
         If LstServices.Items.Item(Index).SubItems.Item(1).Text = S2 Then
             Try
                 SrvcCntrl.StartupType = ("Automatic")
                 SrvcCntrl.Start()
                 SrvcCntrl.WaitForStatus(ServiceProcess.ServiceControllerStatus.Running, TimeSpan.FromSeconds(3))
             Catch ex As InvalidOperationException
             Catch ex As System.ServiceProcess.TimeoutException
             End Try
         End If
 
         LstServices.Items.Item(Index).Checked = False
         LstServices.Items.Item(Index).SubItems.Item(1).Text = S1
         LstServices.Items.Item(Index).SubItems.Item(1).ForeColor = Color.Green
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="147" endline="198">
<![CDATA[
 
     Private Class TryBlock
         Public Start As Integer
         Public EndBlock As Mono.Cecil.Cil.Instruction
         Public EndTry As Mono.Cecil.Cil.Instruction
         Public Handlers As New Generic.List(Of Mono.Cecil.Cil.ExceptionHandler)
 
         ReadOnly Property CurrentHandler() As Mono.Cecil.Cil.ExceptionHandler
             Get
                 If Handlers.Count = 0 Then
                     Return Nothing
                 Else
                     Return Handlers(Handlers.Count - 1)
                 End If
             End Get
         End Property
     End Class
 
     Private m_ExceptionBlocks As Generic.Stack(Of TryBlock)
 
     Public Sub BeginCatchBlock(ByVal exceptionType As Mono.Cecil.TypeReference)
         Log("BeginCatchBlock")
         Helper.Assert(Helper.IsEmittableMember(m_Compiler, exceptionType))
 
         If exceptionType Is Nothing Then
             Dim block As TryBlock = m_ExceptionBlocks.Peek
             Dim ex As Mono.Cecil.Cil.ExceptionHandler = block.Handlers(block.Handlers.Count - 1)
             CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Endfilter)
             ex.FilterEnd = CreateAndEmitNop()
             ex.HandlerStart = ex.FilterEnd
         Else
             Dim ex As New Mono.Cecil.Cil.ExceptionHandler(Mono.Cecil.Cil.ExceptionHandlerType.Catch)
             Dim block As TryBlock = m_ExceptionBlocks.Peek
             CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Leave, block.EndBlock)
             Dim handlerStart As Integer = CilBody.Instructions.Count
             If block.Handlers.Count = 0 Then
                 ex.TryEnd = CreateAndEmitNop()
             Else
                 ex.TryEnd = block.Handlers(0).TryEnd
                 CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Nop)
             End If
             If block.EndTry Is Nothing Then
                 block.EndTry = ex.TryEnd
             End If
             If block.Handlers.Count > 0 Then
                 block.Handlers(block.Handlers.Count - 1).HandlerEnd = CilBody.Instructions(CilBody.Instructions.Count - 1) 'CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Nop)
             End If
             ex.HandlerStart = CilBody.Instructions(handlerStart)
             ex.CatchType = exceptionType
             block.Handlers.Add(ex)
             End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2653" endline="2710">
<![CDATA[
 
 #End Region
 
 #Region "   Media Player events "
 
     'Private Sub mPlayer_MouseMoveEvent(ByVal sender As Object, ByVal e As AxWMPLib._WMPOCXEvents_MouseMoveEvent) Handles mPlayer.MouseMoveEvent
     '    If mPlayer.fullScreen Then
     '        'If e.fY > 0.8 * Me.Height Then mPlayer.fullScreen = False
     '    End If
     'End Sub
 
     Private Sub mPlayer_OpenStateChange(ByVal sender As Object, _
     ByVal e As AxWMPLib._WMPOCXEvents_OpenStateChangeEvent) _
     Handles mPlayer.OpenStateChange
 
         Select Case mPlayer.openState
             Case WMPLib.WMPOpenState.wmposMediaOpen
                 ResetFastButtons()
                 statMain.Text = mTranslator.LangText(44)
                 statDur.Text = mTranslator.LangText(121) & "
                 mDisplayControl.Focus()
                 mFileLoaded = True
                 mPlayer.settings.mute = mPlayMuted
                 Waiting(False)
 
                 ReDim mItems(0)
                 MPcontrols.SetToolbarMode(True)
                 If Not mMaskFile Then
                     lvPositions.Items.Clear()
 
                     'Simulate the pressing of the home key to create first entry
                     Dim evnt As New AxWMPLib._WMPOCXEvents_KeyUpEvent(36, 0)
                     mPlayer_KeyUpEvent(mPlayer, evnt)
                 Else
                     PlayAllSelected()
                 End If
 
                 UpdateSelDur()
 
                 If Not mainTabs.SelectedTab Is tabPlayer Then
                     mPlayer.Ctlcontrols.stop()
                 Else
                     Timer.Enabled = mIsAudio        'For the time being starting the timer only for waveform display
                 End If
 
             Case WMPLib.WMPOpenState.wmposMediaChanging
                 statMain.Text = mTranslator.LangText(18)
                 If mPlayer.URL = "" Then
                     lvPositions.Items.Clear()
                 End If
                 MPcontrols.SetToolbarMode(False)
 
             Case Else
                 MPcontrols.SetToolbarMode(False)
 
         End Select
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmDiagnostics.vb" startline="460" endline="493">
<![CDATA[
 
     Private Sub Profile_Fix(ByVal Name As String, ByVal Index As Byte)
 
         Try
             SrvcCntrl.ServiceName = (Name)
             Dim ChkSrvc As Boolean = SrvcCntrl.CanPauseAndContinue
         Catch ex As InvalidOperationException
             LstServices.Items.Item(Index).Checked = False
             Exit Sub
         End Try
 
         If LstServices.Items.Item(Index).SubItems.Item(1).Text = S2 Then
             Try
                 SrvcCntrl.StartupType = ("Automatic")
                 SrvcCntrl.Start()
                 SrvcCntrl.WaitForStatus(ServiceProcess.ServiceControllerStatus.Running, TimeSpan.FromSeconds(3))
             Catch ex As InvalidOperationException
             Catch ex As System.ServiceProcess.TimeoutException
             End Try
         ElseIf LstServices.Items.Item(Index).SubItems.Item(1).Text = S3 Then
             Try
                 SrvcCntrl.StartupType = ("Manual")
                 SrvcCntrl.Stop()
                 SrvcCntrl.WaitForStatus(ServiceProcess.ServiceControllerStatus.Stopped, TimeSpan.FromSeconds(3))
             Catch ex As InvalidOperationException
             Catch ex As System.ServiceProcess.TimeoutException
             End Try
         End If
 
         LstServices.Items.Item(Index).Checked = False
         LstServices.Items.Item(Index).SubItems.Item(1).Text = S1
         LstServices.Items.Item(Index).SubItems.Item(1).ForeColor = Color.Green
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5098" endline="5147">
<![CDATA[
 
     ''' <summary>
     ''' OnErrorStatement  
     ''' ErrorClause  
     '''	   "GoTo"  "-"  "1" |
     '''	   "GoTo"  "0"  |
     '''	   GotoStatement  |
     '''	   "Resume" "Next"
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseOnErrorStatement(ByVal Parent As ParsedObject) As OnErrorStatement
         Dim m_IsResumeNext As Boolean
         Dim m_Label As Token = Nothing
         Dim m_IsGotoMinusOne As Boolean
         Dim m_IsGotoZero As Boolean
 
         tm.AcceptIfNotInternalError(KS.On)
         If tm.Accept(KS.Error) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.Accept(KS.Resume) Then
             If tm.Accept(KS.Next) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             m_IsResumeNext = True
         Else
             If tm.Accept(KS.GoTo) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.CurrentToken.IsIntegerLiteral Then
                 If tm.CurrentToken.IntegralLiteral = 0 Then
                     m_IsGotoZero = True
                 Else
                     m_Label = tm.CurrentToken
                 End If
                 tm.NextToken()
             ElseIf tm.CurrentToken = KS.Minus AndAlso tm.PeekToken.IsIntegerLiteral Then
                 If tm.PeekToken.IntegralLiteral = 1 Then
                     m_IsGotoMinusOne = True
                     tm.NextToken(2)
                 Else
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                     Compiler.Report.ShowMessage(Messages.VBNC90011, tm.CurrentLocation, "-1")
                 End If
             ElseIf tm.CurrentToken.IsIdentifier Then
                 m_Label = tm.CurrentToken
                 tm.NextToken()
             Else
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 Compiler.Report.ShowMessage(Messages.VBNC30203, tm.CurrentLocation)
                 Return Nothing
             End If
         End If
 
         Return New OnErrorStatement(Parent, m_IsResumeNext, m_Label, m_IsGotoMinusOne, m_IsGotoZero)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\StdToolMgr.vb" startline="6" endline="15">
<![CDATA[
     Public Sub New()
         MyBase.New()
 
         'This call is required by the Windows Form Designer.
         InitializeComponent()
 
         'Add any initialization after the InitializeComponent() call
         Me_Load()
 
     End Sub
 
     'UserControl overrides dispose to clean up the component list.
     Protected Overloads Overrides Sub Dispose(ByVal disposing As Boolean)
         If disposing Then
             If Not (components Is Nothing) Then
                 components.Dispose()
             End If
         End If
         MyBase.Dispose(disposing)
     End Sub
 
     'Required by the Windows Form Designer
     Private components As System.ComponentModel.IContainer
 
     'NOTE
     'It can be modified using the Windows Form Designer.  
     'Do not modify it using the code editor.
     Friend WithEvents lplayPos As System.Windows.Forms.Label
     Friend WithEvents tbButtons As System.Windows.Forms.ToolBar
     Friend WithEvents cPlay As System.Windows.Forms.ToolBarButton
     Friend WithEvents cStop As System.Windows.Forms.ToolBarButton
     Friend WithEvents cEnd As System.Windows.Forms.ToolBarButton
     Friend WithEvents cBegin As System.Windows.Forms.ToolBarButton
     Friend WithEvents cSelStrt As System.Windows.Forms.ToolBarButton
     Friend WithEvents cSelEnd As System.Windows.Forms.ToolBarButton
     Friend WithEvents cFFwd As System.Windows.Forms.ToolBarButton
     Friend WithEvents cFRev As System.Windows.Forms.ToolBarButton
     Friend WithEvents sep1 As System.Windows.Forms.ToolBarButton
     Friend WithEvents sep2 As System.Windows.Forms.ToolBarButton
     Friend WithEvents cMute As System.Windows.Forms.ToolBarButton
     Friend WithEvents sep3 As System.Windows.Forms.ToolBarButton
     Friend WithEvents iList As System.Windows.Forms.ImageList
     Friend WithEvents VolBar As System.Windows.Forms.TrackBar
     Friend WithEvents Timer As System.Windows.Forms.Timer
     Friend WithEvents lPos As System.Windows.Forms.Label
     <System.Diagnostics.DebuggerStepThrough()> Private Sub InitializeComponent()
         Me.components = New System.ComponentModel.Container
         Dim resources As System.ComponentModel.ComponentResourceManager = New System.ComponentModel.ComponentResourceManager(GetType(ucMPcontrols))
         Me.lplayPos = New System.Windows.Forms.Label
         Me.tbButtons = New System.Windows.Forms.ToolBar
         Me.cStop = New System.Windows.Forms.ToolBarButton
         Me.cPlay = New System.Windows.Forms.ToolBarButton
         Me.sep1 = New System.Windows.Forms.ToolBarButton
         Me.cBegin = New System.Windows.Forms.ToolBarButton
         Me.cFRev = New System.Windows.Forms.ToolBarButton
         Me.cFFwd = New System.Windows.Forms.ToolBarButton
         Me.cEnd = New System.Windows.Forms.ToolBarButton
         Me.sep2 = New System.Windows.Forms.ToolBarButton
         Me.cSelStrt = New System.Windows.Forms.ToolBarButton
         Me.cSelEnd = New System.Windows.Forms.ToolBarButton
         Me.sep3 = New System.Windows.Forms.ToolBarButton
         Me.cMute = New System.Windows.Forms.ToolBarButton
         Me.iList = New System.Windows.Forms.ImageList(Me.components)
         Me.VolBar = New System.Windows.Forms.TrackBar
         Me.Timer = New System.Windows.Forms.Timer(Me.components)
         Me.lPos = New System.Windows.Forms.Label
         CType(Me.VolBar, System.ComponentModel.ISupportInitialize).BeginInit()
         Me.SuspendLayout()
         '
         'lplayPos
         '
         Me.lplayPos.BackColor = System.Drawing.Color.Beige
         Me.lplayPos.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.lplayPos.Dock = System.Windows.Forms.DockStyle.Top
         Me.lplayPos.Enabled = False
         Me.lplayPos.Location = New System.Drawing.Point(3, 3)
         Me.lplayPos.Name = "lplayPos"
         Me.lplayPos.Size = New System.Drawing.Size(362, 16)
         Me.lplayPos.TabIndex = 0
         '
         'tbButtons
         '
         Me.tbButtons.Appearance = System.Windows.Forms.ToolBarAppearance.Flat
         Me.tbButtons.Buttons.AddRange(New System.Windows.Forms.ToolBarButton() {Me.cStop, Me.cPlay, Me.sep1, Me.cBegin, Me.cFRev, Me.cFFwd, Me.cEnd, Me.sep2, Me.cSelStrt, Me.cSelEnd, Me.sep3, Me.cMute})
         Me.tbButtons.Dock = System.Windows.Forms.DockStyle.Bottom
         Me.tbButtons.DropDownArrows = True
         Me.tbButtons.ImageList = Me.iList
         Me.tbButtons.Location = New System.Drawing.Point(3, 28)
         Me.tbButtons.Name = "tbButtons"
         Me.tbButtons.ShowToolTips = True
         Me.tbButtons.Size = New System.Drawing.Size(362, 28)
         Me.tbButtons.TabIndex = 1
         '
         'cStop
         '
         Me.cStop.ImageIndex = 9
         Me.cStop.Name = "cStop"
         Me.cStop.Tag = "cStop"
         Me.cStop.ToolTipText = "Stop"
         '
         'cPlay
         '
         Me.cPlay.ImageIndex = 1
         Me.cPlay.Name = "cPlay"
         Me.cPlay.Tag = "cPlay"
         Me.cPlay.ToolTipText = "Play / Pause [Space]"
         '
         'sep1
         '
         Me.sep1.Name = "sep1"
         Me.sep1.Style = System.Windows.Forms.ToolBarButtonStyle.Separator
         '
         'cBegin
         '
         Me.cBegin.ImageIndex = 5
         Me.cBegin.Name = "cBegin"
         Me.cBegin.Tag = "cBegin"
         Me.cBegin.ToolTipText = "Jump to start [Ctrl+S]"
         '
         'cFRev
         '
         Me.cFRev.ImageIndex = 3
         Me.cFRev.Name = "cFRev"
         Me.cFRev.Style = System.Windows.Forms.ToolBarButtonStyle.ToggleButton
         Me.cFRev.Tag = "cFRev"
         Me.cFRev.ToolTipText = "Fast Reverse [Ctrl+Dn Arrow]"
         '
         'cFFwd
         '
         Me.cFFwd.ImageIndex = 2
         Me.cFFwd.Name = "cFFwd"
         Me.cFFwd.Style = System.Windows.Forms.ToolBarButtonStyle.ToggleButton
         Me.cFFwd.Tag = "cFFwd"
         Me.cFFwd.ToolTipText = "Fast Forward [Ctrl+Up Arrow]"
         '
         'cEnd
         '
         Me.cEnd.ImageIndex = 4
         Me.cEnd.Name = "cEnd"
         Me.cEnd.Tag = "cEnd"
         Me.cEnd.ToolTipText = "Jump to End [Ctrl+End]"
         '
         'sep2
         '
         Me.sep2.Name = "sep2"
         Me.sep2.Style = System.Windows.Forms.ToolBarButtonStyle.Separator
         '
         'cSelStrt
         '
         Me.cSelStrt.ImageIndex = 7
         Me.cSelStrt.Name = "cSelStrt"
         Me.cSelStrt.Tag = "cSelStrt"
         Me.cSelStrt.ToolTipText = "Mark Selection Start [Home]"
         '
         'cSelEnd
         '
         Me.cSelEnd.ImageIndex = 8
         Me.cSelEnd.Name = "cSelEnd"
         Me.cSelEnd.Tag = "cSelEnd"
         Me.cSelEnd.ToolTipText = "Mark Selection End [End]"
         '
         'sep3
         '
         Me.sep3.Name = "sep3"
         Me.sep3.Style = System.Windows.Forms.ToolBarButtonStyle.Separator
         '
         'cMute
         '
         Me.cMute.ImageIndex = 0
         Me.cMute.Name = "cMute"
         Me.cMute.Style = System.Windows.Forms.ToolBarButtonStyle.ToggleButton
         Me.cMute.Tag = "cMute"
         Me.cMute.ToolTipText = "Mute"
         '
         'iList
         '
         Me.iList.ImageStream = CType(resources.GetObject("iList.ImageStream"), System.Windows.Forms.ImageListStreamer)
         Me.iList.TransparentColor = System.Drawing.Color.Transparent
         Me.iList.Images.SetKeyName(0, "")
         Me.iList.Images.SetKeyName(1, "")
         Me.iList.Images.SetKeyName(2, "")
         Me.iList.Images.SetKeyName(3, "")
         Me.iList.Images.SetKeyName(4, "")
         Me.iList.Images.SetKeyName(5, "")
         Me.iList.Images.SetKeyName(6, "")
         Me.iList.Images.SetKeyName(7, "")
         Me.iList.Images.SetKeyName(8, "")
         Me.iList.Images.SetKeyName(9, "")
         Me.iList.Images.SetKeyName(10, "")
         '
         'VolBar
         '
         Me.VolBar.Location = New System.Drawing.Point(233, 31)
         Me.VolBar.Maximum = 100
         Me.VolBar.Name = "VolBar"
         Me.VolBar.Size = New System.Drawing.Size(80, 45)
         Me.VolBar.SmallChange = 5
         Me.VolBar.TabIndex = 2
         Me.VolBar.TabStop = False
         Me.VolBar.TickFrequency = 5
         Me.VolBar.TickStyle = System.Windows.Forms.TickStyle.None
         '
         'Timer
         '
         '
         'lPos
         '
         Me.lPos.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.lPos.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.lPos.Font = New System.Drawing.Font("Microsoft Sans Serif", 7.0!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.lPos.ForeColor = System.Drawing.SystemColors.ControlDarkDark
         Me.lPos.Location = New System.Drawing.Point(313, 32)
         Me.lPos.Name = "lPos"
         Me.lPos.Size = New System.Drawing.Size(52, 16)
         Me.lPos.TabIndex = 3
         Me.lPos.Text = "0
         Me.lPos.TextAlign = System.Drawing.ContentAlignment.MiddleRight
         '
         'ucMPcontrols
         '
         Me.Controls.Add(Me.lPos)
         Me.Controls.Add(Me.lplayPos)
         Me.Controls.Add(Me.VolBar)
         Me.Controls.Add(Me.tbButtons)
         Me.Name = "ucMPcontrols"
         Me.Padding = New System.Windows.Forms.Padding(3, 3, 3, 0)
         Me.Size = New System.Drawing.Size(368, 56)
         CType(Me.VolBar, System.ComponentModel.ISupportInitialize).EndInit()
         Me.ResumeLayout(False)
         Me.PerformLayout()
 
     End Sub
 
 #End Region
 
 #Region "   Private Variables and Constants "
 
     Friend WithEvents mPlayer As AxWMPLib.AxWindowsMediaPlayer
 
     Private mPenWide As Integer = 2             'Width of the pen
     Private mPenColor As Color = Color.Black    'Color of the pen
     Private mPen As Pen                         'The pen to use for the slider
     Private mBitMap As Bitmap                   'Bitmap that will hold the time graph
 
     Private mSliderW As Integer = 6             'Width of the slider
         InitializeComponent()
 
         'Add any initialization after the InitializeComponent() call
         Me_Load()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="153" endline="208">
<![CDATA[
     End Property
 
 
     ''' <summary>
     ''' Loads the value of the variable.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Friend Function GenerateCodeAsValue(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Info.DesiredType IsNot Nothing)
 
         If m_InstanceExpression IsNot Nothing Then
             result = m_InstanceExpression.GenerateCode(Info) AndAlso result
         End If
 
         If FieldInfo IsNot Nothing Then
             If Info.IsRHS Then
                 Emitter.EmitLoadVariable(Info, FieldInfo)
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             End If
         ElseIf LocalBuilder IsNot Nothing Then
             If Info.IsRHS Then
                 Emitter.EmitLoadVariable(Info, LocalBuilder)
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             End If
         ElseIf ParameterInfo IsNot Nothing Then
             Helper.Assert(m_InstanceExpression Is Nothing)
             If Info.IsRHS Then
                 Emitter.EmitLoadVariable(Info, ParameterInfo)
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             End If
         ElseIf m_ArrayVariable IsNot Nothing Then
             result = Helper.EmitLoadArrayElement(Info, m_ArrayVariable, m_Arguments) AndAlso result
         ElseIf m_Expression IsNot Nothing Then
             result = m_Expression.GenerateCode(Info) AndAlso result
         Else
             Throw New InternalException(Me)
         End If
 
         If CecilHelper.IsByRef(Info.DesiredType) Then
             Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(Info.DesiredType)
             Dim local As Mono.Cecil.Cil.VariableDefinition
             local = Emitter.DeclareLocal(Info, elementType)
 
             Emitter.EmitStoreVariable(Info, local)
             Emitter.EmitLoadVariableLocation(Info, local)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="388" endline="425">
<![CDATA[
 
     Function TypeToKeyword(ByVal Type As Mono.Cecil.TypeReference) As KS
         If Helper.CompareType(Type, Compiler.TypeCache.System_Boolean) Then
             Return KS.Boolean
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Byte) Then
             Return KS.Byte
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Char) Then
             Return KS.Char
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_DateTime) Then
             Return KS.Date
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Decimal) Then
             Return KS.Decimal
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Double) Then
             Return KS.Double
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Int32) Then
             Return KS.Integer
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Int64) Then
             Return KS.Long
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Object) Then
             Return KS.Object
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Int16) Then
             Return KS.Short
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Single) Then
             Return KS.Single
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_String) Then
             Return KS.String
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_SByte) Then
             Return KS.[SByte]
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_UInt16) Then
             Return KS.[UShort]
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_UInt32) Then
             Return KS.[UInteger]
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_UInt64) Then
             Return KS.[ULong]
         Else
             Return KS.None
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="23" endline="70">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim opType As TypeCode = MyBase.OperandTypeCode
 
         ValidateBeforeGenerateCode(Info)
 
         Select Case opType
             Case TypeCode.Boolean, TypeCode.Object
                 If opType = TypeCode.Object Then
                     Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 End If
 
                 Dim loadfalse, loadtrue, endexp As Label
                 loadfalse = Emitter.DefineLabel(Info)
                 loadtrue = Emitter.DefineLabel(Info)
                 endexp = Emitter.DefineLabel(Info)
 
                 result = m_LeftExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfFalse(Info, loadfalse)
 
                 result = m_RightExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 Emitter.MarkLabel(Info, loadfalse) '
                 Emitter.EmitLoadValue(Info, False) 'Load false value
                 Emitter.EmitBranch(Info, endexp)
 
                 Emitter.MarkLabel(Info, loadtrue)
                 Emitter.EmitLoadValue(Info, True) 'Load true value
 
                 Emitter.MarkLabel(Info, endexp) 'The end of the expression
                
                 If opType = TypeCode.Object Then
                     Emitter.EmitBox(Info, Compiler.TypeCache.System_Boolean)
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="4062" endline="4116">
<![CDATA[
 
     Public Sub LoadMask(ByVal File2Open As String)
 
         Dim Mask As MediaMask, FileName As String
         Dim fs As IO.FileStream, fi As IO.FileInfo
         Dim x As New XmlSerializer(GetType(MediaMask))
 
         Try
             fi = New IO.FileInfo(File2Open)
             fs = New IO.FileStream(File2Open, IO.FileMode.Open)
             Mask = DirectCast(x.Deserialize(fs), MediaMask)
         Catch ex As Exception
             MsgBox("Error in reading the MoviClip")
             Exit Sub
         Finally
             fs.Close()
         End Try
 
         statMain.Text = mTranslator.LangText(52)
         'open the movie (if extension is right)
         mMaskFile = True
         If mRepeatPlay = Not Mask.RepeatPlay Then ToggleRepeatPlay()
         Try
             If File.Exists(Mask.FileName) Then
                 FileName = Mask.FileName
             Else
                 Dim LocalName As String = fi.DirectoryName & "\"
                 LocalName += Mask.FileName.Substring(InStrRev(Mask.FileName, "\"))
                 If File.Exists(LocalName) Then
                     FileName = LocalName
                 Else
                     MsgBox("Cannot find file '" & Mask.FileName & "'." & vbCrLf & _
 "Please check to see if the file is available in the orginal location or " & vbCrLf & _
 "alternatively, in the same folder as the MoviClip file", MsgBoxStyle.Exclamation, _
 "Cannot find the Movie")
                     Exit Sub
                 End If
             End If
         Catch ex As Exception
             Exit Sub
         End Try
 
         'Load the position list
         lvPositions.Items.Clear()
         Dim lvItem As ListViewItem
         For Each Seg As Segment In Mask.Segments
             lvItem = lvPositions.Items.Add(SecToMin(Seg.Start))
             lvItem.SubItems.Add(SecToMin(Seg.Finish))
         Next
         mSelsDirty = False
         mMaskFilename = File2Open
 
         OpenFile(FileName, fi.Name.Remove(Len(fi.Name) - 9, 9))
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="192" endline="198">
<![CDATA[
 
     Shared Sub EmitNotEquals(ByVal Info As EmitInfo, ByVal CompareType As Mono.Cecil.TypeReference)
         CompareType = Helper.GetTypeOrTypeBuilder(Info.Compiler, CompareType)
         Info.ILGen.Emit(OpCodes.Ceq)
         Info.ILGen.Emit(OpCodes.Ldc_I4_0)
         Info.ILGen.Emit(OpCodes.Ceq)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="199" endline="216">
<![CDATA[
 
     Private Sub BeginExceptFilterBlockCecil()
         Log("BeginExceptFilterBlock")
         Dim ex As New Mono.Cecil.Cil.ExceptionHandler(Mono.Cecil.Cil.ExceptionHandlerType.Filter)
         Dim block As TryBlock = m_ExceptionBlocks.Peek
 
         CilWorker.Emit(Mono.Cecil.Cil.OpCodes.Leave, block.EndBlock)
         If block.EndTry Is Nothing Then
             block.EndTry = CreateAndEmitNop()
         End If
         If block.Handlers.Count > 0 Then
             block.Handlers(block.Handlers.Count - 1).HandlerEnd = CreateAndEmitNop()
         End If
 
         ex.FilterStart = CilBody.Instructions(CilBody.Instructions.Count - 1)
         ex.HandlerStart = ex.FilterStart
         block.Handlers.Add(ex)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="222" endline="228">
<![CDATA[
 
     Shared Sub EmitLE(ByVal Info As EmitInfo, ByVal CompareType As Mono.Cecil.TypeReference)
         CompareType = Helper.GetTypeOrTypeBuilder(Info.Compiler, CompareType)
         Info.ILGen.Emit(OpCodes.Cgt)
         Info.ILGen.Emit(OpCodes.Ldc_I4_0)
         Info.ILGen.Emit(OpCodes.Ceq)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="641" endline="650">
<![CDATA[
 
     Sub SetAdditionalAttributes()
         Dim cab As Mono.Cecil.CustomAttribute
 
         If Compiler.CommandLine.Define.IsDefined("DEBUG") Then
             cab = New Mono.Cecil.CustomAttribute(Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Diagnostics_DebuggableAttribute__ctor_DebuggingModes))
             cab.ConstructorArguments.Add(New CustomAttributeArgument(Compiler.TypeCache.System_Diagnostics_DebuggableAttribute, System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations Or Diagnostics.DebuggableAttribute.DebuggingModes.Default))
             Me.Compiler.AssemblyBuilderCecil.CustomAttributes.Add(cab)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmSrvcMngr.vb" startline="228" endline="248">
<![CDATA[
 
     Private Sub ItmAutomatic_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles ItmAutomatic.Click
 
         Try
             SrvcCntrl.ServiceName = (ServiceName)
             SrvcCntrl.StartupType = ("Automatic")
 
             ItmAutomatic.Checked = True
             ItmAutomatic.Enabled = False
             ItmManual.Checked = False
             ItmManual.Enabled = True
             ItmDisabled.Checked = False
             ItmDisabled.Enabled = True
 
             LstServices.Items.Item(Index).SubItems.Item(3).Text = Startup(ServiceName)
 
         Catch ex As InvalidOperationException
             MessageBox.Show("The selected Windows service can not be set to Automatic startup.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
         End Try
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmSrvcMngr.vb" startline="249" endline="269">
<![CDATA[
 
     Private Sub ItmManual_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles ItmManual.Click
 
         Try
             SrvcCntrl.ServiceName = (ServiceName)
             SrvcCntrl.StartupType = ("Manual")
 
             ItmAutomatic.Checked = False
             ItmAutomatic.Enabled = True
             ItmManual.Checked = True
             ItmManual.Enabled = False
             ItmDisabled.Checked = False
             ItmDisabled.Enabled = True
 
             LstServices.Items.Item(Index).SubItems.Item(3).Text = Startup(ServiceName)
 
         Catch ex As InvalidOperationException
             MessageBox.Show("The selected Windows service can not be set to Manual startup.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
         End Try
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmSrvcMngr.vb" startline="270" endline="290">
<![CDATA[
 
     Private Sub ItmDisabled_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles ItmDisabled.Click
 
         Try
             SrvcCntrl.ServiceName = (ServiceName)
             SrvcCntrl.StartupType = ("Disabled")
 
             ItmAutomatic.Checked = False
             ItmAutomatic.Enabled = True
             ItmManual.Checked = False
             ItmManual.Enabled = True
             ItmDisabled.Checked = True
             ItmDisabled.Enabled = False
 
             LstServices.Items.Item(Index).SubItems.Item(3).Text = Startup(ServiceName)
 
         Catch ex As InvalidOperationException
             MessageBox.Show("The selected Windows service can not be set to Disabled startup.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
         End Try
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="941" endline="973">
<![CDATA[
 
     Shared Sub EmitLoadElement(ByVal Info As EmitInfo, ByVal ArrayType As Mono.Cecil.TypeReference)
         ArrayType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ArrayType)
         Dim ElementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
         Select Case Helper.GetTypeCode(Info.Compiler, ElementType)
             Case TypeCode.Byte
                 Info.ILGen.Emit(OpCodes.Ldelem_U1)
             Case TypeCode.SByte, TypeCode.Boolean
                 Info.ILGen.Emit(OpCodes.Ldelem_I1)
             Case TypeCode.UInt16, TypeCode.Char
                 Info.ILGen.Emit(OpCodes.Ldelem_U2)
             Case TypeCode.Int16
                 Info.ILGen.Emit(OpCodes.Ldelem_I2)
             Case TypeCode.UInt32
                 Info.ILGen.Emit(OpCodes.Ldelem_U4)
             Case TypeCode.Int32
                 Info.ILGen.Emit(OpCodes.Ldelem_I4)
             Case TypeCode.UInt64, TypeCode.Int64
                 Info.ILGen.Emit(OpCodes.Ldelem_I8)
             Case TypeCode.Single
                 Info.ILGen.Emit(OpCodes.Ldelem_R4)
             Case TypeCode.Double
                 Info.ILGen.Emit(OpCodes.Ldelem_R8)
             Case TypeCode.Object, TypeCode.String, TypeCode.DateTime, TypeCode.Decimal
                 If CecilHelper.IsValueType(ElementType) Then
                     Throw New InternalException("")
                 Else
                     Info.ILGen.Emit(OpCodes.Ldelem_Ref)
                 End If
             Case Else
                 Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End Select
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="974" endline="1006">
<![CDATA[
 
     Shared Sub LoadElement(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         Select Case Helper.GetTypeCode(Info.Compiler, ElementType)
             Case TypeCode.Byte
                 Info.ILGen.Emit(OpCodes.Ldelem_U1)
             Case TypeCode.UInt16, TypeCode.Char
                 Info.ILGen.Emit(OpCodes.Ldelem_U2)
             Case TypeCode.UInt32
                 Info.ILGen.Emit(OpCodes.Ldelem_U4)
             Case TypeCode.UInt64
                 Info.ILGen.Emit(OpCodes.Ldelem_I8)
             Case TypeCode.SByte, TypeCode.Boolean
                 Info.ILGen.Emit(OpCodes.Ldelem_I1)
             Case TypeCode.Int16
                 Info.ILGen.Emit(OpCodes.Ldelem_I2)
             Case TypeCode.Int32
                 Info.ILGen.Emit(OpCodes.Ldelem_I4)
             Case TypeCode.Int64
                 Info.ILGen.Emit(OpCodes.Ldelem_I8)
             Case TypeCode.Single
                 Info.ILGen.Emit(OpCodes.Ldelem_R4)
             Case TypeCode.Double
                 Info.ILGen.Emit(OpCodes.Ldelem_R8)
             Case TypeCode.DateTime, TypeCode.Decimal
                 Info.ILGen.Emit(OpCodes.Ldelema, ElementType)
                 Info.ILGen.Emit(OpCodes.Ldobj, ElementType)
             Case TypeCode.String
                 Info.ILGen.Emit(OpCodes.Ldelem_Ref)
             Case Else
                 Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End Select
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2209" endline="2247">
<![CDATA[
 
     Private Sub mnuImpSkip_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles mnuImpSkip.Click
 
         Dim lvItem As ListViewItem
         Dim SkipXml As New XmlDocument
         Dim TimeStr, TimeEnd As Double
         Dim MaxVal As Double = mPlayer.currentMedia.duration
         SkipXml.Load(mInFile & ".chapters.xml")
         If Not SkipXml Is Nothing Then
             lvPositions.Items.Clear()
             Try
                 lvItem = lvPositions.Items.Add(SecToMin(0))
                 For Each Seg As XmlNode In SkipXml.SelectNodes("cutlist/Region")
                     TimeStr = MinToSec(Seg.SelectSingleNode("start").Attributes.GetNamedItem("comment").InnerText)
                     TimeEnd = MinToSec(Seg.SelectSingleNode("end").Attributes.GetNamedItem("comment").InnerText)
 
                     'Validate
                     If (TimeStr > MaxVal) Or (TimeEnd > MaxVal) Then
                         MsgBox("This file has positions outside the extent of the movie." & vbCrLf & "Please check if you have the correct file", _
                         MsgBoxStyle.Exclamation, "Error in reading skip file")
                         Exit Try
                     End If
 
                     'Add item
                     If TimeStr > 0 Then
                         lvItem.SubItems.Add(SecToMin(TimeStr))
                         lvItem = lvPositions.Items.Add(SecToMin(TimeEnd))
                     Else
                         lvItem.Text = SecToMin(TimeEnd)
                     End If
                 Next
             Catch ex As Exception
                 Debug.WriteLine(ex.Message)
             End Try
 
             lvItem.SubItems.Add(SecToMin(MaxVal))
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmSrvcMngr.vb" startline="317" endline="352">
<![CDATA[
 
     Private Sub BtnExport_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles BtnExport.Click, ItmExport.Click
 
         Dim RN As Integer = RNumber(10000)
         Dim Report_Name As String = (ReportsDir & "services list_" & RN.ToString & ".txt")
 
         If Directory.Exists(ReportsDir) = False Then
             Directory.CreateDirectory(ReportsDir)
         End If
 
         If File.Exists(Report_Name) = True Then
             File.SetAttributes(Report_Name, FileAttributes.Normal)
             File.Delete(Report_Name)
         End If
 
         Dim Writer As New StreamWriter(Report_Name)
 
         Writer.WriteLine("Windows Services List" & vbCrLf)
         Writer.WriteLine("Date
 
         Dim I As Integer
         For I = 0 To LstServices.Items.Count - 1
             Writer.WriteLine(LstServices.Items.Item(I).Text & ">>>" & LstServices.Items.Item(I).SubItems(1).Text & ">>>" & LstServices.Items.Item(I).SubItems(2).Text & ">>>" & LstServices.Items.Item(I).SubItems(3).Text & ">>>" & LstServices.Items.Item(I).SubItems(4).Text & vbCrLf)
         Next
 
         Writer.Close()
         File.SetAttributes(Report_Name, FileAttributes.ReadOnly)
 
         If MessageBox.Show("Installed Windows services were successfully exported." & vbCrLf & "Do you want to open Windows services list?", "Vista Services Optimizer", MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button1, 0, False) = Windows.Forms.DialogResult.Yes Then
             Try
                 Process.Start(Report_Name)
             Catch ex As System.ComponentModel.Win32Exception
             End Try
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\CaseRangeExpression.vb" startline="208" endline="228">
<![CDATA[
     End Property
 
     ReadOnly Property CanBePropertyAccessClassification() As Boolean
         Get
             Select Case m_Classification
                 Case Classifications.PropertyGroup
                     Return True
                 Case Classifications.LateBoundAccess
                     Return True
                 Case Classifications.Type
                     Dim tc As TypeClassification = AsTypeClassification
                     Return tc.CanBeExpression AndAlso tc.Expression.Classification.CanBePropertyAccessClassification
                 Case Classifications.Value, Classifications.Variable, Classifications.EventAccess, _
 Classifications.LateBoundAccess, Classifications.MethodGroup, _
 Classifications.MethodPointer, Classifications.PropertyAccess, Classifications.Void, Classifications.Namespace
                     Return False
                 Case Else
                     Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Location)
                     Return False
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1732" endline="1763">
<![CDATA[
 
     ''' <summary>
     ''' Returns true if a leave instruction is necessary to jump from one statement to the other.
     ''' If ToStatement is nothing then it is assumed a ret instruction is about to be emitted.
     ''' </summary>
     ''' <param name="FromStatement"></param>
     ''' <param name="ToStatement"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function IsLeaveNecessary(ByVal FromStatement As Statement, ByVal ToStatement As Statement) As Boolean
         Dim result As Boolean
 
         If ToStatement Is Nothing Then
             result = FromStatement.FindParentCodeBlock.UpmostBlock.HasUnstructuredExceptionHandling
         End If
 
         If result = False Then
             Dim parentStmt As Statement = FromStatement
             Do Until parentStmt Is ToStatement OrElse parentStmt Is Nothing
                 result = result OrElse TypeOf parentStmt Is TryStatement
                 result = result OrElse TypeOf parentStmt Is SyncLockStatement
                 result = result OrElse TypeOf parentStmt Is ForEachStatement
                 result = result OrElse TypeOf parentStmt Is UsingStatement
                 result = result OrElse TypeOf parentStmt Is CatchStatement
 
                 If result Then Exit Do
 
                 parentStmt = parentStmt.Parent.FindFirstParent(Of Statement)()
             Loop
             Do Until parentStmt Is ToStatement OrElse parentStmt Is Nothing
                 result = result OrElse TypeOf parentStmt Is TryStatement
                 result = result OrElse TypeOf parentStmt Is SyncLockStatement
                 result = result OrElse TypeOf parentStmt Is ForEachStatement
                 result = result OrElse TypeOf parentStmt Is UsingStatement
                 result = result OrElse TypeOf parentStmt Is CatchStatement
 
                 If result Then Exit Do
 
                 parentStmt = parentStmt.Parent.FindFirstParent(Of Statement)()
             Loop
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Compiler.vb" startline="668" endline="705">
<![CDATA[
 
     ReadOnly Property Logo() As String
         Get
             Dim result As New System.Text.StringBuilder
             Dim FileVersion As Diagnostics.FileVersionInfo = Nothing
             Dim Version As AssemblyInformationalVersionAttribute = Nothing
             Dim attrs() As Object = System.Reflection.Assembly.GetExecutingAssembly().GetCustomAttributes(GetType(AssemblyInformationalVersionAttribute), False)
             Dim msg As String = ""
 
             If System.Reflection.Assembly.GetExecutingAssembly.Location <> String.Empty Then
                 FileVersion = Diagnostics.FileVersionInfo.GetVersionInfo(System.Reflection.Assembly.GetExecutingAssembly.Location)
             End If
 
             If attrs IsNot Nothing AndAlso attrs.Length > 0 Then
                 Version = TryCast(attrs(0), AssemblyInformationalVersionAttribute)
             End If
 
             If FileVersion IsNot Nothing Then
                 msg = FileVersion.ProductName & " version " & FileVersion.FileVersion
             End If
             If Version IsNot Nothing Then
                 msg &= " (Mono " & Version.InformationalVersion & ")"
             End If
 
 #If DEBUG Then
             If FileVersion IsNot Nothing Then
                 msg &= " Last Write
             End If
 #End If
 
             result.AppendLine(msg)
             If FileVersion IsNot Nothing Then
                 result.AppendLine(FileVersion.LegalCopyright)
                 result.AppendLine()
             End If
 
             Return result.ToString
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmDiagnostics.vb" startline="193" endline="201">
<![CDATA[
 
     Private Sub BWDiagnostics_RunWorkerCompleted(ByVal sender As Object, ByVal e As System.ComponentModel.RunWorkerCompletedEventArgs) Handles BWDiagnostics.RunWorkerCompleted
 
         BtnExport.Enabled = ComponentFactory.Krypton.Toolkit.ButtonEnabled.True
         LstServices.Visible = True
         TabMain.SelectedIndex = 1
         FrmProgress.Close()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3557" endline="3577">
<![CDATA[
 
     Private Sub ToggleFastReverse()
 
         'Pause the player and reset other buttons
         mPlayer.Ctlcontrols.pause()
         mFFwd = False
         MPcontrols.cFFwd.Pushed = False
 
         'Start it again
         mPlayer.Ctlcontrols.pause()
         If mFRev Then
             mFRev = False
             mPlayer.settings.rate = 1
         Else
             mFRev = True
             mPlayer.settings.rate = -2
         End If
         mPlayer.Ctlcontrols.play()
         MPcontrols.cFRev.Pushed = mFRev
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3203" endline="3215">
<![CDATA[
 
     'To accomodate the fast adjustment of video
     Private Sub lvPositions_KeyUp(ByVal sender As Object, ByVal e As System.Windows.Forms.KeyEventArgs) _
     Handles lvPositions.KeyUp
 
         If lvPositions.SelectedItems.Count <> 1 Then Exit Sub
         If e.KeyCode = Keys.Space Then
             TestSegment()
         Else
             MPcontrols.RefreshPositions()
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="28" endline="34">
<![CDATA[
 
     Public Sub New(ByVal CopyFrom As ConditionalConstants)
         Me.New()
         For Each constant As ConditionalConstant In CopyFrom.Values
             Add(constant)
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="268" endline="277">
<![CDATA[
 
     ReadOnly Property HasNamedArguments() As Boolean
         Get
             For Each argument As Argument In m_Arguments
                 If TypeOf argument Is NamedArgument Then
                     Return True
                 End If
             Next
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="278" endline="288">
<![CDATA[
     End Property
 
     ReadOnly Property HasPositionalArguments() As Boolean
         Get
             For Each argument As Argument In m_Arguments
                 If TypeOf argument Is PositionalArgument Then
                     Return True
                 End If
             Next
             Return False
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3585" endline="3626">
<![CDATA[
 
     Private Sub StartSelection()
 
         Dim CurrPos As Double
         CurrPos = Math.Round(mPlayer.Ctlcontrols.currentPosition, 3)
 
         'Debug.Write(CurrPos)
         'Debug.WriteLine(Timer.Enabled)
 
         Dim Last As Integer = lvPositions.Items.Count - 1
 
         With lvPositions
             If Last < 0 Then
                 'Create new item; because first entry
                 Dim NewItem As New ListViewItem
                 If CurrPos < mReactTime Then
                     NewItem.Text = "0"
                 Else
                     NewItem.Text = SecToMin(CurrPos - mReactTime)
                 End If
                 lvPositions.Items.Add(NewItem)
             ElseIf .Items(Last).SubItems.Count > 1 Then
                 'Create new item; because end exists
                 Dim NewItem As New ListViewItem
                 If CurrPos < mReactTime Then
                     NewItem.Text = "0"
                 Else
                     NewItem.Text = SecToMin(CurrPos - mReactTime)
                 End If
                 lvPositions.Items.Add(NewItem)
             Else
                 'Change start
                 If CurrPos < mReactTime Then
                     .Items(Last).Text = "0"
                 Else
                     .Items(Last).Text = SecToMin(CurrPos - mReactTime)
                 End If
             End If
         End With
         mSelsDirty = True
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3823" endline="3836">
<![CDATA[
 
     Private Sub cSplitBrw_Click(ByVal sender As System.Object, _
     ByVal e As System.EventArgs) Handles cSplitBrw.Click
 
         dlgSaveFile.InitialDirectory = dlgOpenFile.InitialDirectory
         dlgSaveFile.DefaultExt = mHandler.Extension
         dlgSaveFile.FileName = mHandler.GetSplitName(tFile2Split.Text)
         dlgSaveFile.Filter = mHandler.Extension(True) + " |*" + mHandler.Extension
 
         If dlgSaveFile.ShowDialog() = Windows.Forms.DialogResult.OK Then
             tSplitName.Text = dlgSaveFile.FileName
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3578" endline="3584">
<![CDATA[
 
     Private Sub ResetFastButtons()
         mFFwd = False
         mFRev = False
         MPcontrols.cFFwd.Pushed = False
         MPcontrols.cFRev.Pushed = False
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="1195" endline="1346">
<![CDATA[
 
     Class TypeHint
         Public Hint As TypeReference
         Public ArrayElementRestriction As Boolean
         Public GenericArgumentRestriction As Boolean
     End Class
 
     Class TypeHints
         Private m_Candidate As MemberCandidate
         Private m_Hints As New Generic.List(Of TypeHint)
 
         ReadOnly Property Hints As Generic.List(Of TypeHint)
             Get
                 Return m_Hints
             End Get
         End Property
 
         Public Sub New(ByVal Candidate As MemberCandidate)
             m_Candidate = Candidate
         End Sub
 
         Private Function InvolvesMethodTypeParameters(ByVal GenericParameters As Mono.Collections.Generic.Collection(Of GenericParameter), ByVal type As TypeReference) As Boolean
             Dim elementType As GenericInstanceType
             Dim genericParam As GenericParameter
             Dim git As GenericInstanceType
 
             If type Is Nothing Then Return False
 
             genericParam = TryCast(type, GenericParameter)
             If genericParam IsNot Nothing AndAlso GenericParameters.Contains(genericParam) Then Return True
 
             git = TryCast(type, GenericInstanceType)
             If git Is Nothing Then Return False
 
             For i As Integer = 0 To GenericParameters.Count - 1
                 If git.GenericArguments.Contains(GenericParameters(i)) Then Return True
             Next
 
             elementType = TryCast(type.GetElementType(), GenericInstanceType)
             If elementType IsNot type Then Return InvolvesMethodTypeParameters(GenericParameters, elementType)
 
             Return False
         End Function
 
         Public Function GenerateHint(ByVal GenericParameters As Mono.Collections.Generic.Collection(Of GenericParameter), ByVal argument_type As TypeReference, ByVal parameter As ParameterDefinition) As Boolean
             Return GenerateHint(GenericParameters, argument_type, parameter.ParameterType, parameter, False, False)
         End Function
 
         Private Function GenerateHint(ByVal GenericParameters As Mono.Collections.Generic.Collection(Of GenericParameter), ByVal argument_type As TypeReference, ByVal parameter_type As TypeReference, ByVal parameter As ParameterDefinition, ByVal array_element_restriction As Boolean, ByVal generic_argument_restriction As Boolean) As Boolean
 
             'Given an argument type TA for an argument A and a parameter type TP for a parameter P, type hints are generated as follows
             '?	If TP does not involve any method type parameters then no hints are generated.
             If InvolvesMethodTypeParameters(GenericParameters, parameter_type) = False Then Return True
 
             '?	If TP and TA are array types of the same rank, then replace TA and TP with the element types of 
             '   TA and TP and restart this process with an array element restriction.
             Dim arrayA As ArrayType = TryCast(argument_type, ArrayType)
             Dim arrayP As ArrayType = TryCast(parameter_type, ArrayType)
             If arrayA IsNot Nothing AndAlso arrayP IsNot Nothing Then
                 If arrayA.Rank = arrayP.Rank Then
                     Return GenerateHint(GenericParameters, arrayA.ElementType, arrayP.ElementType, parameter, True, generic_argument_restriction)
                 End If
             End If
 
             '?	If TP is a method type parameter, then TA is added as a type hint with the current restriction, if any.
             Dim gp As GenericParameter = TryCast(parameter_type, GenericParameter)
             If gp IsNot Nothing AndAlso GenericParameters.Contains(gp) Then
                 Dim hint As TypeHint = New TypeHint()
                 hint.ArrayElementRestriction = array_element_restriction
                 hint.GenericArgumentRestriction = generic_argument_restriction
                 hint.Hint = argument_type
                 m_Hints.Add(hint)
                 Return True
             End If
 
             '?	If A is a lambda method and TP is a constructed delegate type or System.Linq.Expressions.Expression(Of T), 
             '   where T is a constructed delegate type, for each lambda method parameter type TL and corresponding 
             '   delegate parameter type TD, replace TA with TL and TP with TD and restart the process with no restriction. 
             '   Then replace TA with the return type of the lambda method and TP with the return type of the delegate type 
             '   and restart the process with no restriction.
             '* no lambda support yet *
 
             '?	If A is a method pointer and TP is a constructed delegate type, use the parameter types of TP to determine 
             '   which method pointed is most applicable to TP. If there is a method that is most applicable, replace TA with 
             '   the return type of the method and TP with the return type of the delegate type and restart the process with 
             '   no restriction.
             '* TODO *
 
             '?	Otherwise, TP must be a constructed type. Given TG, the generic type of TP,
             '   ?	If TA is TG, inherits from TG, or implements the type TG exactly once, then for each matching 
             '       type argument TAX from TA and TPX from TP, replace TA with TAX and TP with TPX and restart 
             '       the process with a generic argument restriction.
             Dim tp_git As GenericInstanceType = TryCast(parameter_type, GenericInstanceType)
             Dim ta_git As GenericInstanceType = TryCast(argument_type, GenericInstanceType)
             If tp_git IsNot Nothing AndAlso ta_git IsNot Nothing Then
                 Dim restart As Boolean
                 Dim implement_count As Integer
                 Dim tp_td As TypeDefinition = CecilHelper.FindDefinition(tp_git)
                 Dim ta_td As TypeDefinition = CecilHelper.FindDefinition(ta_git)
                 Dim base As TypeReference = ta_td
                 Dim base_td As TypeDefinition
                 While base IsNot Nothing AndAlso restart = False
                     If base Is tp_td Then restart = True
                     base_td = CecilHelper.FindDefinition(base)
                     If base_td.HasInterfaces Then
                         For i As Integer = 0 To base_td.Interfaces.Count - 1
                             If base_td.Interfaces(i) Is tp_git Then implement_count += 1
                         Next
                     End If
 
                     base = base_td.BaseType
                 End While
                 If restart = False Then
                     restart = implement_count = 1
                 End If
                 If restart Then
                     For i As Integer = 0 To ta_git.GenericArguments.Count - 1
                         If GenerateHint(GenericParameters, ta_git.GenericArguments(i), tp_git.GenericArguments(i), parameter, array_element_restriction, True) = False Then
                             Return False
                         End If
                     Next
                 End If
                 Return True
             End If
 
             '?	Otherwise, type inference fails for the generic method.
             Return False
         End Function
     End Class
 
     Function IsApplicable_ParameterCount() As Boolean
         '(if there are more arguments than parameters and the last parameter is not a 
         'paramarray parameter the method should not be applicable)
         If Arguments.Count > InputParameters.Count Then
             If InputParameters.Count < 1 Then
                 'LogResolutionMessage(Parent.Compiler, "N/A
                 Return False
             End If
             If InputParameters.Count > 0 AndAlso Helper.IsParamArrayParameter(Compiler, InputParameters(InputParameters.Count - 1)) = False Then
                 'LogResolutionMessage(Parent.Compiler, "N/A
                 Return False
             End If
         End If
 
         If Arguments.Count < InputParameters.Count Then
             If InputParameters(Arguments.Count).IsOptional Then Return True 'The remaining parameters must be optional too
             If Arguments.Count + 1 = InputParameters.Count AndAlso Helper.IsParamArrayParameter(Compiler, InputParameters(InputParameters.Count - 1)) Then Return True 'One missing argument for a paramarray argument -> OK
             Return False
         End If
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2965" endline="2984">
<![CDATA[
 
     Private Sub UpdateToolbar(ByVal Enable As Boolean)
         If Enable Then
             cSort.Enabled = True
             cRemove.Enabled = True
             cClear.Enabled = True
             cJoin.Enabled = True
             cUp.Enabled = True
             cDn.Enabled = True
             cInfo.Enabled = True
         Else
             cSort.Enabled = False
             cRemove.Enabled = False
             cClear.Enabled = False
             cJoin.Enabled = False
             cUp.Enabled = False
             cDn.Enabled = False
             cInfo.Enabled = False
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4411" endline="4419">
<![CDATA[
 
     Shared Function IsFirstLessGeneric(ByVal Context As BaseObject) As Boolean
         'A member M is determined to be less generic than a member N using the following steps
         '-	If M has fewer method type parameters than N, then M is less generic than N.
         '-	Otherwise, if for each pair of matching parameters Mj and Nj, Mj and Nj are equally generic with respect to type parameters on the method, or Mj is less generic with respect to type parameters on the method, and at least one Mj is less generic than Nj, then M is less generic than N.
         '-	Otherwise, if for each pair of matching parameters Mj and Nj, Mj and Nj are equally generic with respect to type parameters on the type, or Mj is less generic with respect to type parameters on the type, and at least one Mj is less generic than Nj, then M is less generic than N.
         Context.Compiler.Report.ShowMessage(Messages.VBNC99997, Context.Location)
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmManual.vb" startline="511" endline="524">
<![CDATA[
 
     Private Sub BWManTuneUp_RunWorkerCompleted(ByVal sender As Object, ByVal e As System.ComponentModel.RunWorkerCompletedEventArgs) Handles BWManTuneUp.RunWorkerCompleted
 
         FrmProgress.Close()
 
         If TabMain.SelectedIndex = 0 Then
             LstPerformance.Items.Item(0).Selected = True
         ElseIf TabMain.SelectedIndex = 1 Then
             LstSecurity.Items.Item(0).Selected = True
         ElseIf TabMain.SelectedIndex = 2 Then
             LstNetwork.Items.Item(0).Selected = True
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="66" endline="73">
<![CDATA[
 
     Shared Function GetTypeCharacter(ByVal chr As LiteralTypeCharacters_Characters) As String
         If chr = LiteralTypeCharacters_Characters.None Then
             Return ""
         Else
             Return m_Characters(chr - 1)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\SimpleTypeName.vb" startline="197" endline="213">
<![CDATA[
 
     ''' <summary>
     ''' If not the current token is a newline, then shows the specified message
     ''' and eats the newline. After this sub the current token will be the first after the newline
     ''' Returns false if first symbol isn't a newline
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function FindNewLineAndShowError(ByVal Message As Messages) As Boolean
         If Not AcceptNewLine() Then
             Compiler.Report.ShowMessage(Message, CurrentLocation)
             GotoNewline(True, False)
             Return False
         Else
             Return True
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="1268" endline="1289">
<![CDATA[
 
     Public Shared Function FindDefinition(ByVal method As MethodReference) As MethodDefinition
         If method Is Nothing Then Return Nothing
         Dim type As TypeDefinition
 
         If TypeOf method Is MethodDefinition Then Return DirectCast(method, MethodDefinition)
 
         'If TypeOf method.DeclaringType Is ArrayType Then
         '    type = Compiler.CurrentCompiler.TypeCache.System_Array
         'Else
         type = FindDefinition(method.DeclaringType)
         'End If
         If method.OriginalMethod IsNot Nothing Then
             method = method.OriginalMethod
         Else
             method = method.GetElementMethod
         End If
 
         If TypeOf method Is MethodDefinition Then Return DirectCast(method, MethodDefinition)
 
         Return GetMethod(type, method)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="5977" endline="6045">
<![CDATA[
 
     ''' <summary>
     ''' ForStatement  
     '''	   "For" LoopControlVariable  "="  Expression  "To"  Expression  [  "Step"  Expression  ]  StatementTerminator
     '''	      [ Block  ]
     '''	   "Next" [  NextExpressionList  ]  StatementTerminator
     ''' LoopControlVariable  
     '''	   Identifier  [  ArrayNameModifier  ] "As" TypeName  |
     '''	   Expression
     ''' NextExpressionList  
     '''	   Expression  |
     '''	   NextExpressionList "," Expression
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseForStatement(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As ForStatement
         Dim result As New ForStatement(Parent)
 
         Dim m_LoopControlVariable As LoopControlVariable
         Dim m_LoopStartExpression As Expression
         Dim m_LoopEndExpression As Expression
         Dim m_LoopStepExpression As Expression
         Dim m_NextExpressionList As ExpressionList
         Dim m_Code As CodeBlock
 
         tm.AcceptIfNotInternalError(KS.For)
         m_LoopControlVariable = ParseLoopControlVariable(result)
         If m_LoopControlVariable Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.Equals) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         tm.AcceptNewLine()
 
         m_LoopStartExpression = ParseExpression(result)
         If m_LoopStartExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.To) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_LoopEndExpression = ParseExpression(result)
         If m_LoopEndExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Step) Then
             m_LoopStepExpression = ParseExpression(result)
             If m_LoopStepExpression Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_LoopStepExpression = Nothing
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Code = ParseCodeBlock(result, IsOneLiner)
         If m_Code Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Next) = False Then
             Compiler.Report.ShowMessage(Messages.VBNC30084, tm.CurrentLocation)
             Return result
         End If
 
         If tm.CurrentToken.IsEndOfStatement = False Then
             m_NextExpressionList = New ExpressionList(result)
             If ParseList(Of Expression)(m_NextExpressionList, New ParseDelegate_Parent(Of Expression)(AddressOf ParseExpression), result) = False Then
                 Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         Else
             m_NextExpressionList = Nothing
         End If
 
         result.Init(m_LoopControlVariable, m_LoopStartExpression, m_LoopEndExpression, m_LoopStepExpression, m_NextExpressionList, m_Code)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1048" endline="1058">
<![CDATA[
 
     ''' <summary>
     ''' Emits a Stobj instruction.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ElementType"></param>
     ''' <remarks></remarks>
     Shared Sub EmitStoreObject(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         Info.ILGen.Emit(OpCodes.Stobj, ElementType)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1059" endline="1069">
<![CDATA[
 
     ''' <summary>
     ''' Emits a Ldobj instruction.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ElementType"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadObject(ByVal Info As EmitInfo, ByVal ElementType As Mono.Cecil.TypeReference)
         ElementType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ElementType)
         Info.ILGen.Emit(OpCodes.Ldobj, ElementType)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AliasClause.vb" startline="71" endline="78">
<![CDATA[
 
     Overrides Function ToString() As String
         Dim result As String = ""
         For Each atn As ArrayTypeModifier In m_ArrayTypeModifiers
             result &= atn.ToString
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="3747" endline="3778">
<![CDATA[
 
     Shared Function CompareMethod(ByVal m1 As Mono.Cecil.MethodReference, ByVal m2 As Mono.Cecil.MethodReference) As Boolean
         Dim g1 As Mono.Cecil.GenericInstanceMethod
         Dim g2 As Mono.Cecil.GenericInstanceMethod
 
         If m1 Is Nothing AndAlso m2 Is Nothing Then Return True
         If m1 Is Nothing Xor m2 Is Nothing Then Return False
 
         If m1 Is m2 Then Return True
         If Helper.CompareNameOrdinal(m1.Name, m2.Name) = False Then Return False
         If m1.Parameters.Count <> m2.Parameters.Count Then Return False
         If m1.GenericParameters.Count <> m2.GenericParameters.Count Then Return False
         If Helper.Compare(m1.DeclaringType, m2.DeclaringType) = False Then Return False
 
         For i As Integer = 0 To m1.Parameters.Count - 1
             If Helper.CompareType(m1.Parameters(i).ParameterType, m2.Parameters(i).ParameterType) = False Then Return False
         Next
 
         g1 = TryCast(m1, Mono.Cecil.GenericInstanceMethod)
         g2 = TryCast(m2, Mono.Cecil.GenericInstanceMethod)
 
         If g1 IsNot Nothing AndAlso g2 IsNot Nothing Then
             If g1.GenericArguments.Count <> g2.GenericArguments.Count Then Return False
             For i As Integer = 0 To g1.GenericArguments.Count - 1
                 If Helper.CompareType(g1.GenericArguments(i), g2.GenericArguments(i)) = False Then Return False
             Next
         ElseIf g1 IsNot Nothing Xor g2 IsNot Nothing Then
             Return False
         End If
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="56" endline="71">
<![CDATA[
 
     ''' <summary>
     ''' Returns nothing if the specified key is not found.
     ''' </summary>
     ''' <param name="key"></param>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Default Shadows ReadOnly Property Item(ByVal key As String) As Mono.Cecil.TypeReference
         Get
             If MyBase.ContainsKey(key) Then
                 Return MyBase.Item(key)
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="108" endline="133">
<![CDATA[
 
     Function GetFieldAttributeScope(ByVal TypeDeclaration As TypeDeclaration) As Mono.Cecil.FieldAttributes
         If Me.Is(ModifierMasks.Public) Then
             Return Mono.Cecil.FieldAttributes.Public
         ElseIf Me.Is(ModifierMasks.Friend) Then
             If Me.Is(ModifierMasks.Protected) Then
                 Return Mono.Cecil.FieldAttributes.FamORAssem
             Else
                 Return Mono.Cecil.FieldAttributes.Assembly
             End If
         ElseIf Me.Is(ModifierMasks.Protected) Then
             Return Mono.Cecil.FieldAttributes.Family
         ElseIf Me.Is(ModifierMasks.Private) Then
             Return Mono.Cecil.FieldAttributes.Private
         ElseIf Me.Is(ModifierMasks.Dim) OrElse Me.Is(ModifierMasks.Const) Then
             If TypeOf TypeDeclaration Is StructureDeclaration Then
                 Return Mono.Cecil.FieldAttributes.Public
             Else
                 Return Mono.Cecil.FieldAttributes.Private
             End If
         ElseIf TypeOf TypeDeclaration Is EnumDeclaration Then
             Return Mono.Cecil.FieldAttributes.Public
         Else
             Return Mono.Cecil.FieldAttributes.Private
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\UnaryExpressions\UnaryNotExpression.vb" startline="71" endline="98">
<![CDATA[
 
     Public Overrides Function GetConstant(ByRef result As Object, ByVal ShowError As Boolean) As Boolean
         If Not Expression.GetConstant(result, ShowError) Then Return False
 
         Select Case Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, result))
             Case TypeCode.SByte
                 result = Not CSByte(result)
             Case TypeCode.Byte
                 result = Not CByte(result)
             Case TypeCode.Int16
                 result = Not CShort(result)
             Case TypeCode.Int32
                 result = Not CInt(result)
             Case TypeCode.Int64
                 result = Not CLng(result)
             Case TypeCode.UInt16
                 result = Not CUShort(result)
             Case TypeCode.UInt32
                 result = Not CUInt(result)
             Case TypeCode.UInt64
                 result = Not CULng(result)
             Case Else
                 If ShowError Then Show30059()
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="284" endline="290">
<![CDATA[
 
     Private Function DefineLabelCecil() As Mono.Cecil.Cil.Instruction
         Log("DefineLabel")
         Dim result As Mono.Cecil.Cil.Instruction
         result = CilWorker.Create(Mono.Cecil.Cil.OpCodes.Nop)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" startline="104" endline="129">
<![CDATA[
 
     Private Function CreateAddHandlerCode(ByVal Info As EmitInfo) As Boolean
         Helper.Assert([EventParent].EventField IsNot Nothing)
         If Me.IsShared = False Then
             With Info.ILGen
                 .Emit(OpCodes.Ldarg_0)
                 .Emit(OpCodes.Ldarg_0)
                 .Emit(OpCodes.Ldfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ldarg_1)
                 .EmitCall(OpCodes.Call, Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Delegate__Combine), Nothing)
                 .Emit(OpCodes.Castclass, Helper.GetTypeOrTypeBuilder(Compiler, [EventParent].EventType))
                 .Emit(OpCodes.Stfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ret)
             End With
         Else
             With Info.ILGen
                 .Emit(OpCodes.Ldsfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ldarg_0)
                 .EmitCall(OpCodes.Call, Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Delegate__Combine), Nothing)
                 .Emit(OpCodes.Castclass, Helper.GetTypeOrTypeBuilder(Compiler, [EventParent].EventType))
                 .Emit(OpCodes.Stsfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ret)
             End With
         End If
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="337" endline="393">
<![CDATA[
 
     Shared Function GetTypeConversion(ByVal Parent As ParsedObject, ByVal fromExpr As Expression, ByVal DestinationType As Mono.Cecil.TypeReference, Optional ByVal IsExplicit As Boolean = False) As Expression
         Dim convExp As ConversionExpression
 
         If Helper.CompareType(fromExpr.ExpressionType, DestinationType) Then
             Return fromExpr
         End If
 
         Select Case Helper.GetTypeCode(Parent.Compiler, DestinationType)
             Case TypeCode.Boolean
                 convExp = New CBoolExpression(Parent, fromExpr)
             Case TypeCode.Byte
                 convExp = New CByteExpression(Parent, fromExpr)
             Case TypeCode.Char
                 convExp = New CCharExpression(Parent, fromExpr)
             Case TypeCode.DateTime
                 convExp = New CDateExpression(Parent, fromExpr)
             Case TypeCode.Decimal
                 convExp = New CDecExpression(Parent, fromExpr)
             Case TypeCode.Double
                 convExp = New CDblExpression(Parent, fromExpr)
             Case TypeCode.Int16
                 convExp = New CShortExpression(Parent, fromExpr)
             Case TypeCode.Int32
                 convExp = New CIntExpression(Parent, fromExpr)
             Case TypeCode.Int64
                 convExp = New CLngExpression(Parent, fromExpr)
             Case TypeCode.SByte
                 convExp = New CSByteExpression(Parent, fromExpr)
             Case TypeCode.Single
                 convExp = New CSngExpression(Parent, fromExpr)
             Case TypeCode.String
                 convExp = New CStrExpression(Parent, fromExpr)
             Case TypeCode.UInt16
                 convExp = New CUShortExpression(Parent, fromExpr)
             Case TypeCode.UInt32
                 convExp = New CUIntExpression(Parent, fromExpr)
             Case TypeCode.UInt64
                 convExp = New CULngExpression(Parent, fromExpr)
             Case Else
                 If CecilHelper.IsByRef(DestinationType) AndAlso CecilHelper.IsByRef(fromExpr.ExpressionType) = False Then
                     Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(DestinationType)
                     Dim result As Boolean = True
                     Dim tmp As Expression
                     tmp = GetTypeConversion(Parent, fromExpr, elementType)
                     result = tmp.ResolveExpression(ResolveInfo.Default(Parent.Compiler)) AndAlso result
                     tmp = New GetRefExpression(Parent, tmp)
                     result = tmp.ResolveExpression(ResolveInfo.Default(Parent.Compiler)) AndAlso result
                     If result = False Then Throw New InternalException
                     Return tmp
                 Else
                     convExp = New CTypeExpression(Parent, fromExpr, DestinationType)
                 End If
         End Select
         convExp.IsExplicit = IsExplicit
         Return convExp
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmDiagnostics.vb" startline="108" endline="142">
<![CDATA[
 
     Private Sub BtnExport_Click(ByVal sender As Object, ByVal e As System.EventArgs) Handles BtnExport.Click
 
         Dim Report_Name As String = (ReportsDir & "Services Diagnostics Report_" & RNumber(10000).ToString & ".txt")
 
         If Directory.Exists(ReportsDir) = False Then
             Directory.CreateDirectory(ReportsDir)
         End If
 
         If File.Exists(Report_Name) = True Then
             File.SetAttributes(Report_Name, FileAttributes.Normal)
             File.Delete(Report_Name)
         End If
 
         Dim Writer As New StreamWriter(Report_Name)
 
         Writer.WriteLine("Services Diagnostics Report" & vbCrLf)
         Writer.WriteLine("Date
 
         For Index As Byte = 0 To 28
             Writer.WriteLine(LstServices.Items.Item(Index).Text & "
         Next
 
         Writer.Close()
         File.SetAttributes(Report_Name, FileAttributes.ReadOnly)
 
         If MessageBox.Show("Services Diagnostics report was successfully exported." & vbCrLf & "Do you want to open Services Diagnostics report?", _
         "Vista Services Optimizer", MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button1, 0, False) = Windows.Forms.DialogResult.Yes Then
             Try
                 Process.Start(Report_Name)
             Catch ex As System.ComponentModel.Win32Exception
             End Try
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="346" endline="385">
<![CDATA[
 
     Function RuleArithmeticBitshift(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleStringConcat(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.ShiftLeft, KS.ShiftRight)
             Dim DoLeft As Boolean
             DoLeft = CurrentToken.Equals(KS.ShiftLeft)
             NextToken()
             RuleStringConcat(RSide)
 
             Dim op1 As Double, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Long.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Integer.ToString)
                 bErr = True
             End If
             If op1 < Long.MinValue OrElse op1 > Long.MaxValue Then
                 Compiler.Report.ShowMessage(Messages.VBNC30439, Location, KS.Long.ToString)
             ElseIf op2 < Integer.MinValue OrElse op2 > Integer.MaxValue Then
                 Compiler.Report.ShowMessage(Messages.VBNC30439, Location, KS.Integer.ToString)
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf DoLeft Then
                 LSide = CLng(op1) << CInt(op2)
             Else
                 LSide = CLng(op1) >> CInt(op2)
             End If
         End While
         While CurrentToken.Equals(KS.ShiftLeft, KS.ShiftRight)
             Dim DoLeft As Boolean
             DoLeft = CurrentToken.Equals(KS.ShiftLeft)
             NextToken()
             RuleStringConcat(RSide)
 
             Dim op1 As Double, op2 As Double
             Dim bErr As Boolean
             If ToDouble(LSide, op1) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Long.ToString)
                 bErr = True
             End If
             If ToDouble(RSide, op2) = False Then
                 Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Integer.ToString)
                 bErr = True
             End If
             If op1 < Long.MinValue OrElse op1 > Long.MaxValue Then
                 Compiler.Report.ShowMessage(Messages.VBNC30439, Location, KS.Long.ToString)
             ElseIf op2 < Integer.MinValue OrElse op2 > Integer.MaxValue Then
                 Compiler.Report.ShowMessage(Messages.VBNC30439, Location, KS.Integer.ToString)
             End If
 
             If bErr Then
                 LSide = CDbl(0)
             ElseIf DoLeft Then
                 LSide = CLng(op1) << CInt(op2)
             Else
                 LSide = CLng(op1) >> CInt(op2)
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3301" endline="3345">
<![CDATA[
 
     Private Function ParseComparison(ByVal Info As ExpressionParseInfo) As Expression
         Dim lSide, rSide As Expression
 
         lSide = ParseBitshift(Info)
         While tm.CurrentToken.Equals(KS.NotEqual, KS.LE, KS.LT, KS.GT, KS.GE, KS.Like, KS.IsNot) OrElse _
           (tm.CurrentToken = KS.Equals AndAlso Info.IsLeftSide = False) OrElse _
           (tm.CurrentToken = KS.Is AndAlso Info.IsInTypeOf = False)
             Dim op As KS
             If tm.CurrentToken.IsSymbol Then
                 op = tm.CurrentToken.Symbol
             ElseIf tm.CurrentToken.IsKeyword Then
                 op = tm.CurrentToken.Keyword
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
 
             tm.NextToken()
             tm.AcceptNewLine()
 
             rSide = ParseBitshift(Info)
 
             If op = KS.Equals Then
                 lSide = New EqualsExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.NotEqual Then
                 lSide = New NotEqualsExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.GE Then
                 lSide = New GEExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.GT Then
                 lSide = New GTExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.LE Then
                 lSide = New LEExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.LT Then
                 lSide = New LTExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Is OrElse op = KS.IsNot Then
                 lSide = New Is_IsNotExpression(Info.Parent, lSide, rSide, op)
             ElseIf op = KS.Like Then
                 lSide = New LikeExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
         While tm.CurrentToken.Equals(KS.NotEqual, KS.LE, KS.LT, KS.GT, KS.GE, KS.Like, KS.IsNot) OrElse _
           (tm.CurrentToken = KS.Equals AndAlso Info.IsLeftSide = False) OrElse _
           (tm.CurrentToken = KS.Is AndAlso Info.IsInTypeOf = False)
             Dim op As KS
             If tm.CurrentToken.IsSymbol Then
                 op = tm.CurrentToken.Symbol
             ElseIf tm.CurrentToken.IsKeyword Then
                 op = tm.CurrentToken.Keyword
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
 
             tm.NextToken()
             tm.AcceptNewLine()
 
             rSide = ParseBitshift(Info)
 
             If op = KS.Equals Then
                 lSide = New EqualsExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.NotEqual Then
                 lSide = New NotEqualsExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.GE Then
                 lSide = New GEExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.GT Then
                 lSide = New GTExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.LE Then
                 lSide = New LEExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.LT Then
                 lSide = New LTExpression(Info.Parent, lSide, rSide)
             ElseIf op = KS.Is OrElse op = KS.IsNot Then
                 lSide = New Is_IsNotExpression(Info.Parent, lSide, rSide, op)
             ElseIf op = KS.Like Then
                 lSide = New LikeExpression(Info.Parent, lSide, rSide)
             Else
                 Throw New InternalException(tm.CurrentLocation)
             End If
         End While
 
         Return lSide
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="113" endline="146">
<![CDATA[
     End Property
 
     Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveCode(Info) AndAlso result
 
         If result = False Then Return result
 
         If Me.IsShared = False AndAlso Me.HasMethodBody AndAlso Me.HasExplicitCtorCall = False Then
             CreateDefaultCtorCall()
             CreateDefaultCtorCallCecil()
         ElseIf Code IsNot Nothing AndAlso Me.HasExplicitCtorCall Then
             m_BaseCtorCall = Code.FirstStatement
             If m_BaseCtorCall IsNot Nothing Then Code.RemoveStatement(m_BaseCtorCall)
         End If
 
         If Me.IsShared AndAlso (Me.Modifiers.Mask And Me.Modifiers.AccessibilityMask) <> 0 Then
             Select Case Me.Modifiers.Mask And Me.Modifiers.AccessibilityMask
                 Case ModifierMasks.Private
                     result = Report.ShowMessage(Messages.VBNC30480, Me.Location, "Private")
                 Case ModifierMasks.Protected
                     result = Report.ShowMessage(Messages.VBNC30480, Me.Location, "Protected")
                 Case ModifierMasks.Friend
                     result = Report.ShowMessage(Messages.VBNC30480, Me.Location, "Friend")
                 Case ModifierMasks.Protected Or ModifierMasks.Friend
                     result = Report.ShowMessage(Messages.VBNC30480, Me.Location, "Protected Friend")
                 Case ModifierMasks.Public
                     result = Report.ShowMessage(Messages.VBNC30480, Me.Location, "Public")
             End Select
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="464" endline="520">
<![CDATA[
 
     Public Function [Next]() As Token
         Do
             NextUnconditionally()
 
             If m_Current.IsEndOfCode Then
                 Return m_Current
             End If
 
             If m_Current.IsEndOfFile Then
                 ResetCurrentConstants()
                 Return m_Current
             End If
 
             If TokensSeenOnLine = 1 AndAlso m_Current = KS.Numeral Then
 
                 Me.NextUnconditionally()
 
                 If m_Current.IsEndOfFile Then
                     ResetCurrentConstants()
                     Return m_Current
                 ElseIf m_Current.IsEndOfLine Then
                     EatLine(True)
                     Return Me.Next()
                 End If
 
                 If m_Current = KS.If Then
                     ParseIf()
                 ElseIf m_Current = KS.Else Then
                     ParseElse()
                 ElseIf m_Current = KS.ElseIf Then
                     ParseElseIf()
                 ElseIf m_Current = KS.Const Then
                     ParseConst()
                 ElseIf m_Current.Equals("ExternalSource") Then
                     ParseExternalSource()
                 ElseIf m_Current.Equals("Region") Then
                     ParseRegion()
                 ElseIf m_Current = KS.End Then
                     ParseEnd()
                 Else
                     Compiler.Report.ShowMessage(Messages.VBNC30248, GetCurrentLocation())
                     EatLine(False)
                 End If
             ElseIf IfdOut Then
                 If m_Current.IsEndOfLine = False Then EatLine(False)
                 Continue Do
             Else
                 If m_Current.IsEndOfLineOnly AndAlso m_LastWasNewline Then
                     Continue Do
                 End If
                 m_LastWasNewline = m_Current.IsEndOfLineOnly
                 Return m_Current
             End If
         Loop While m_Current.IsEndOfCode = False AndAlso m_Current.IsEndOfFile = False
         Return m_Current
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="50" endline="64">
<![CDATA[
     End Property
 #End If
 
     ''' <summary>
     ''' Adds the constant to the collection. 
     ''' If the constant already exists, it is replaced.
     ''' </summary>
     ''' <param name="Constant"></param>
     ''' <remarks></remarks>
     Public Shadows Sub Add(ByVal Constant As ConditionalConstant)
         If MyBase.ContainsKey(Constant.Name) Then
             MyBase.Remove(Constant.Name)
         End If
         MyBase.Add(Constant.Name, Constant)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="505" endline="522">
<![CDATA[
 
 
     '
     'Emittable
     ' - 1Declarations/GenericProperty1 shows one case where vbnc and cecil/cil wants different things (method return type shouldn't be inflated for cecil/cil)
     '
     '
 
     Public Shared Function GetCorrectMember(ByVal Member As MethodReference, ByVal Type As TypeReference, Optional ByVal Emittable As Boolean = False) As Mono.Cecil.MethodReference
         Dim mD As MethodDefinition = TryCast(Member, MethodDefinition)
 
         If mD IsNot Nothing Then Return GetCorrectMember(mD, Type, Emittable)
 
         mD = FindDefinition(Member)
         If mD IsNot Nothing Then Return GetCorrectMember(mD, Type, Emittable)
 
         Throw New NotImplementedException
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\LateBoundAccessToValueExpression.vb" startline="67" endline="121">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Select Case Classification.Classification
             Case ExpressionClassification.Classifications.MethodGroup
                 If m_First Is Nothing Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                 Else
                     With Classification.AsMethodGroupClassification
                         If Info.IsRHS Then
                             Dim tmp As ValueClassification = .ReclassifyToValue
                             result = tmp.GenerateCode(Info) AndAlso result
                         Else
                             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                         End If
                     End With
                 End If
             Case ExpressionClassification.Classifications.Variable
                 If m_First Is Nothing Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                 Else
                     With Classification.AsVariableClassification
                         result = .GenerateCode(Info) AndAlso result
                     End With
                 End If
             Case ExpressionClassification.Classifications.Value
                 With Classification.AsValueClassification
                     result = .GenerateCode(Info) AndAlso result
                 End With
             Case ExpressionClassification.Classifications.PropertyGroup
                 With Classification.AsPropertyGroup
                     If Info.IsRHS Then
                         Dim tmp As ValueClassification = .ReclassifyToValue
                         result = tmp.GenerateCode(Info) AndAlso result
                     Else
                         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                     End If
                 End With
             Case ExpressionClassification.Classifications.LateBoundAccess
                 If Info.IsLHS Then
                     If Info.RHSExpression Is Nothing Then
                         LateBoundAccessToExpression.EmitLateCall(Info, Me.Classification.AsLateBoundAccess)
                     Else
                         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                     End If
                 Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                 End If
             Case Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="50" endline="98">
<![CDATA[
 
     ''' <summary>
     ''' Add a new resource. Parses the string and verifies it.
     ''' If there are any messages, they are saved, not shown.
     ''' </summary>
     Overloads Function Add(ByVal str As String) As Boolean
         Dim strItems() As String = Split(str, ",")
         Dim files As String()
         Dim isPublic As Boolean = True
         Dim identifier As String = ""
 
         Select Case strItems.Length
             Case 1
                 files = Compiler.CommandLine.GetFullPaths(strItems(0))
             Case 2
                 files = Compiler.CommandLine.GetFullPaths(strItems(0))
                 identifier = strItems(1)
             Case 3
                 files = Compiler.CommandLine.GetFullPaths(strItems(0))
                 identifier = strItems(1)
                 Select Case strItems(2).ToLower()
                     Case "public"
                         isPublic = True
                     Case "private"
                         isPublic = False
                     Case Else
                         Compiler.Report.SaveMessage(Messages.VBNC2019, Span.CommandLineSpan, "resource", strItems(2))
                         Return False
                 End Select
             Case Else
                 Compiler.Report.SaveMessage(Messages.VBNC2009, Span.CommandLineSpan, str)
                 Return False
         End Select
 
         If files Is Nothing OrElse files.Length = 0 Then
             If m_IsLinkedResources Then
                 Compiler.Report.SaveMessage(Messages.VBNC30145, Span.CommandLineSpan, String.Format("The file '{0}' does not exist.", strItems(0)))
             Else
                 Compiler.Report.SaveMessage(Messages.VBNC31027, Span.CommandLineSpan, strItems(0))
             End If
             Return False
         End If
 
         For Each file As String In files
             Add(New Resource(file, identifier, isPublic))
         Next
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3444" endline="3486">
<![CDATA[
 
     Private Function CreateHandler(ByVal Extension As String) As Boolean
 
         Timer.Enabled = False
         Try
             'Create a handler instance based on extension
             Select Case LCase(Extension)
                 Case ".mpg", ".mpeg"
                     mHandler = New MPGhandler(Me, mInFile)
                     mIsAudio = False
                 Case ".wmv", ".asf"
                     mHandler = New ASFhandler(Me, mInFile)
                     mIsAudio = False
                 Case ".avi"
                     mHandler = New AVIhandler(Me, mInFile)
                     mIsAudio = False
                 Case ".rm"
                     mHandler = New RMhandler(Me, mInFile)
                     mIsAudio = False
                 Case ".flv"
                     mHandler = New FLVhandler(Me, mInFile)
                     mIsAudio = False
                 Case ".mp3"
                     mHandler = New MPGhandler(Me, mInFile, True)
                     mIsAudio = True
                 Case ".wma"
                     mHandler = New ASFhandler(Me, mInFile, True)
                     mIsAudio = True
                 Case Else
                     MsgBox("Filetype not supported
                     mPlayer.URL = ""
                     mHandler = Nothing
                     SwitchVisual(True)
                     Return False
             End Select
         Catch ex As Exception
             MsgBox(ex.Message)
         End Try
 
         SwitchVisual(False)
         Return True
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="178" endline="217">
<![CDATA[
 
     Private Function EmitElementInitializer(ByVal Info As EmitInfo, ByVal Initializer As VariableInitializer, ByVal CurrentDepth As Integer, ByVal ElementIndex As Integer, ByVal ArrayVariable As Mono.Cecil.Cil.VariableDefinition, ByVal ArrayType As Mono.Cecil.TypeReference, ByVal Indices As Generic.List(Of Integer)) As Boolean
         Dim result As Boolean = True
         Dim vi As VariableInitializer = Initializer
         Dim elementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
 
         If vi.IsRegularInitializer Then
             Emitter.EmitLoadVariable(Info, ArrayVariable)
             For i As Integer = 0 To Indices.Count - 1
                 Emitter.EmitLoadValue(Info.Clone(Me, True, False, Compiler.TypeCache.System_Int32), Indices(i))
             Next
             If CecilHelper.IsValueType(elementType) AndAlso CecilHelper.IsPrimitive(Compiler, elementType) = False AndAlso Helper.IsEnum(Compiler, elementType) = False Then
                 Emitter.EmitLoadElementAddress(Info, elementType, ArrayType)
             End If
 
             result = vi.AsRegularInitializer.GenerateCode(Info.Clone(Me, True, False, elementType)) AndAlso result
             If CurrentDepth = 1 Then
                 Emitter.EmitStoreElement(Info, elementType, ArrayType)
             Else
                 Dim setmethod As Mono.Cecil.MethodReference
                 setmethod = New Mono.Cecil.MethodReference("Set", ArrayType, Compiler.TypeCache.System_Void, True, False, Mono.Cecil.MethodCallingConvention.Default)
                 For i As Integer = 0 To CurrentDepth - 1
                     setmethod.Parameters.Add(New Mono.Cecil.ParameterDefinition(Compiler.TypeCache.System_Int32))
                 Next
                 setmethod.Parameters.Add(New Mono.Cecil.ParameterDefinition(CecilHelper.GetElementType(ArrayType)))
                 'setmethod = CecilHelper.FindDefinition(ArrayType).Methods.GetMethod("Set", settypes)
                 Emitter.EmitCallOrCallVirt(Info, setmethod)
             End If
         ElseIf vi.IsArrayElementInitializer Then
             For i As Integer = 0 To vi.AsArrayElementInitializer.Initializers.List.ToArray.GetUpperBound(0)
                 Indices.Add(i)
                 result = EmitElementInitializer(Info, vi.AsArrayElementInitializer.Initializers.List.ToArray()(i), CurrentDepth + 1, i, ArrayVariable, ArrayType, Indices) AndAlso result
                 Indices.RemoveAt(Indices.Count - 1)
             Next
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="101" endline="167">
<![CDATA[
     End Property
 
     Public Function DefineSecurityDeclarations() As Boolean
         Dim result As Boolean = True
         Dim checkedAll As Boolean = True
 
         If m_DefinedSecurityDeclarations Then Return True
 
         If CustomAttributes Is Nothing Then Return True
 
         For i As Integer = 0 To CustomAttributes.Count - 1
             If CustomAttributes(i).ResolvedType Is Nothing Then
                 checkedAll = False
                 Exit For
             End If
         Next
 
         If Not checkedAll Then Return True
 
         For i As Integer = CustomAttributes.Count - 1 To 0 Step -1
             Dim attrib As Attribute = CustomAttributes(i)
 
             If Not Helper.IsSubclassOf(Compiler.TypeCache.System_Security_Permissions_SecurityAttribute, attrib.ResolvedType) Then Continue For
 
             Try
                 Dim sec As Mono.Cecil.SecurityDeclaration
                 Dim secAtt As Mono.Cecil.SecurityAttribute
                 Dim attribInstantiation As Object = Nothing
                 Dim attribInstance As SecurityAttribute
                 Dim attribAction As Mono.Cecil.SecurityAction
                 Dim attribPermissionSetAttribute As PermissionSetAttribute
 
                 If attrib.Instantiate(Messages.VBNC30128, attribInstantiation) = False Then
                     'Attribute.Instantiate prints an error message
                     result = False
                     Continue For
                 End If
 
                 attribInstance = TryCast(attribInstantiation, SecurityAttribute)
                 If attribInstance Is Nothing Then
                     Compiler.Report.ShowMessage(Messages.VBNC30128, attrib.Location, "Security attribute does not inherit from System.Security.Permissions.SecurityAttribute")
                     result = False
                     Continue For
                 End If
 
                 attribAction = CType(attribInstance.Action, Mono.Cecil.SecurityAction)
                 attribPermissionSetAttribute = TryCast(attribInstance, PermissionSetAttribute)
 
                 sec = New Mono.Cecil.SecurityDeclaration(attribAction)
                 secAtt = attrib.GetSecurityAttribute()
                 sec.SecurityAttributes.Add(secAtt)
                 CecilBuilder.SecurityDeclarations.Add(sec)
                 CustomAttributes.Remove(attrib)
                 CecilBuilder.CustomAttributes.Remove(attrib.CecilBuilder)
 
                 Me.MethodAttributes = Mono.Cecil.MethodAttributes.HasSecurity
             Catch ex As Exception
                 Compiler.Report.ShowMessage(Messages.VBNC30128, attrib.Location, attrib.AttributeType.Name, ex.Message)
                 result = False
             End Try
 
         Next
 
         m_DefinedSecurityDeclarations = True
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="46" endline="104">
<![CDATA[
     End Property
 
     Function RuleIdentifier(ByRef Result As Object) As Boolean
         'A value of 0 evaluates as false, anything else as true
         If CurrentToken.Equals(KS.Nothing) Then
             Result = Nothing
             NextToken()
         ElseIf CurrentToken.IsLiteral Then
             Dim tp As TypeCode = Type.GetTypeCode(CurrentToken.LiteralValue.GetType)
             Select Case tp
                 Case TypeCode.String
                     Result = CurrentToken.StringLiteral
                 Case TypeCode.Object
                     Throw New InternalException("Shouldn't happen, Nothing is a keyword.")
                 Case TypeCode.Boolean
                     Throw New InternalException("Shouldn't happen, True and False are keywords.")
                 Case TypeCode.DateTime
                     Result = CurrentToken.DateLiteral
                 Case Else
                     Helper.Assert(Compiler.TypeResolution.IsNumericType(CecilHelper.GetType(Compiler, CurrentToken.LiteralValue)))
                     Result = CDbl(CurrentToken.LiteralValue) 'AsFloatingPointLiteral.Literal
             End Select
             'Result = CurrentToken.Value.Literal
             NextToken()
         ElseIf CurrentToken.IsKeyword Then
             Dim tpType As Mono.Cecil.TypeReference = Compiler.TypeResolution.KeywordToType(CurrentToken.Keyword)
             If tpType Is Nothing Then
                 If CurrentToken.Equals(KS.True) Then
                     Result = True
                     NextToken()
                     Return True
                 ElseIf CurrentToken.Equals(KS.False) Then
                     Result = False
                     NextToken()
                     Return True
                 Else 'TODO
                     Compiler.Report.ShowMessage(Messages.VBNC30201, Location)
                 End If
                 NextToken()
                 Return False
             Else
                 'A builtin type, i.e
                 '#Const a = Integer.MaxValue
                 '#Const a = (user defined type).Constant is not allowed.
                 Throw New InternalException("") 'TODO
             End If
         ElseIf CurrentToken.IsIdentifier Then
             'Find the identifier in the list of defines.
             If CurrentConstants.ContainsKey(CurrentToken.Identifier) Then
                 Result = CurrentConstants.Item(CurrentToken.Identifier).Value
                 NextToken()
             Else
                 Result = Nothing
                 NextToken()
             End If
         End If
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1020" endline="1063">
<![CDATA[
 
     Shared Function EmitStoreArrayElement(ByVal Info As EmitInfo, ByVal ArrayVariable As Expression, ByVal Arguments As ArgumentList) As Boolean
         Dim result As Boolean = True
         Dim ArrayType As Mono.Cecil.TypeReference = ArrayVariable.ExpressionType
         Dim ElementType As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ArrayType)
         Dim isNonPrimitiveValueType As Boolean = CecilHelper.IsPrimitive(Info.Compiler, ElementType) = False AndAlso CecilHelper.IsValueType(ElementType)
         Dim isArraySetValue As Boolean = CecilHelper.GetArrayRank(ArrayType) > 1
         Dim newValue As Expression = Info.RHSExpression
 
         Helper.Assert(newValue IsNot Nothing)
         Helper.Assert(newValue.Classification.IsValueClassification)
 
         result = ArrayVariable.GenerateCode(Info.Clone(Info.Context, True, False, ArrayType)) AndAlso result
 
         If isArraySetValue Then
             result = newValue.GenerateCode(Info.Clone(Info.Context, True, False, ElementType)) AndAlso result
             If CecilHelper.IsValueType(ElementType) Then
                 Emitter.EmitBox(Info, ElementType)
             End If
             result = EmitIntegerArray(Info, Arguments) AndAlso result
             Emitter.EmitCallOrCallVirt(Info, Info.Compiler.TypeCache.System_Array__SetValue)
         Else
             Dim methodtypes As New Generic.List(Of Mono.Cecil.TypeReference)
             Dim elementInfo As EmitInfo = Info.Clone(Info.Context, True, False, Info.Compiler.TypeCache.System_Int32)
             For i As Integer = 0 To Arguments.Count - 1
                 result = Arguments(i).GenerateCode(elementInfo) AndAlso result
                 Emitter.EmitConversion(Arguments(i).Expression.ExpressionType, Info.Compiler.TypeCache.System_Int32, Info)
                 methodtypes.Add(Info.Compiler.TypeCache.System_Int32)
             Next
 
             Dim rInfo As EmitInfo = Info.Clone(Info.Context, True, False, ElementType)
             methodtypes.Add(ElementType)
 
             If isNonPrimitiveValueType Then
                 Emitter.EmitLoadElementAddress(Info, ElementType, ArrayType)
                 result = Info.RHSExpression.Classification.GenerateCode(rInfo) AndAlso result
                 Emitter.EmitStoreObject(Info, ElementType)
             Else
                 result = Info.RHSExpression.Classification.GenerateCode(rInfo) AndAlso result
                 Emitter.EmitStoreElement(Info, ElementType, ArrayType)
             End If
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1438" endline="1492">
<![CDATA[
 
     ''' <summary>
     ''' Loads a nothing constant expression according to the desired type.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadNull(ByVal Info As EmitInfo)
         Helper.Assert(Info.DesiredType IsNot Nothing)
         If CecilHelper.IsGenericParameter(Info.DesiredType) Then ' TypeOf Info.DesiredType Is GenericTypeParameterBuilder OrElse TypeOf Info.DesiredType Is TypeParameterDescriptor Then
             Dim local As Mono.Cecil.Cil.VariableDefinition
             local = DeclareLocal(Info, Info.DesiredType)
             EmitLoadVariableLocation(Info, local)
             EmitInitObj(Info, Info.DesiredType)
             EmitLoadVariable(Info, local)
             'Info.Stack.Push(Info.DesiredType)
             FreeLocal(local)
         ElseIf CecilHelper.IsByRef(Info.DesiredType) Then
             Dim local As Mono.Cecil.Cil.VariableDefinition = DeclareLocal(Info, CecilHelper.GetElementType(Info.DesiredType))
             Info.ILGen.Emit(OpCodes.Ldnull)
             EmitStoreVariable(Info, local)
             EmitLoadVariableLocation(Info, local)
             FreeLocal(local)
         ElseIf CecilHelper.IsClass(Info.DesiredType) OrElse CecilHelper.IsInterface(Info.DesiredType) Then
             Info.ILGen.Emit(OpCodes.Ldnull)
         ElseIf CecilHelper.IsValueType(Info.DesiredType) Then
             Dim DesiredTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, Info.DesiredType)
             Select Case DesiredTypeCode
                 Case TypeCode.Boolean
                     EmitLoadI4Value(Info, CInt(False), Info.DesiredType)
                 Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32
                     EmitLoadI4Value(Info, 0, Info.DesiredType)
                 Case TypeCode.Int64, TypeCode.UInt64
                     EmitLoadI8Value(Info, 0, Info.DesiredType)
                 Case TypeCode.Char
                     EmitLoadI4Value(Info, 0, Info.DesiredType)
                 Case TypeCode.Single
                     EmitLoadR4Value(Info, CSng(0), Info.DesiredType)
                 Case TypeCode.Double
                     EmitLoadR8Value(Info, CDbl(0), Info.DesiredType)
                 Case TypeCode.Object, TypeCode.DateTime, TypeCode.Decimal
                     Dim local As Mono.Cecil.Cil.VariableDefinition
                     local = DeclareLocal(Info, Info.DesiredType)
                     EmitLoadVariable(Info, local)
                     FreeLocal(local)
                 Case TypeCode.String
                     Info.ILGen.Emit(OpCodes.Ldnull)
                 Case Else
                     Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
             End Select
         ElseIf Helper.CompareType(Info.DesiredType, Info.Compiler.TypeCache.System_Enum) Then
             Info.ILGen.Emit(OpCodes.Ldnull)
         Else
             Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeConverter.vb" startline="1183" endline="1219">
<![CDATA[
 
     Public Shared Function ConvertToDouble(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object, ByVal ShowErrors As Boolean) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 result = CDbl(DirectCast(Source, Boolean))
                 Return True
             Case TypeCode.Char
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Char", "Double")
             Case TypeCode.DateTime
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30532, Context.Location)
             Case TypeCode.Decimal
                 result = CDbl(DirectCast(Source, Decimal))
                 Return True
             Case TypeCode.Double
                 result = Source
                 Return True
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 result = CDbl(CLng(Source))
                 Return True
             Case TypeCode.Single
                 result = CDbl(DirectCast(Source, Single))
                 Return True
             Case TypeCode.String
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "String", "Double")
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 result = CDbl(CULng(Source))
                 Return True
             Case TypeCode.DBNull
                 result = 0.0R
                 Return True
         End Select
         If ShowErrors = False Then Return False
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "Double")
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="380" endline="419">
<![CDATA[
 
     Shared Function GetTypeCode(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As TypeCode
         If Helper.IsEnum(Compiler, Type) Then
             Return GetTypeCode(Compiler, Helper.GetEnumType(Compiler, Type))
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Byte) Then
             Return TypeCode.Byte
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Boolean) Then
             Return TypeCode.Boolean
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Char) Then
             Return TypeCode.Char
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_DateTime) Then
             Return TypeCode.DateTime
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_DBNull) Then
             Return TypeCode.DBNull
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Decimal) Then
             Return TypeCode.Decimal
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Double) Then
             Return TypeCode.Double
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Int16) Then
             Return TypeCode.Int16
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Int32) Then
             Return TypeCode.Int32
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Int64) Then
             Return TypeCode.Int64
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_SByte) Then
             Return TypeCode.SByte
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_Single) Then
             Return TypeCode.Single
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_String) Then
             Return TypeCode.String
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_UInt16) Then
             Return TypeCode.UInt16
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_UInt32) Then
             Return TypeCode.UInt32
         ElseIf Helper.CompareType(Type, Compiler.TypeCache.System_UInt64) Then
             Return TypeCode.UInt64
         Else
             Return TypeCode.Object
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4650" endline="4717">
<![CDATA[
 
     ''' <summary>
     ''' ExternalFunctionDeclaration  
     '''	[  Attributes  ]  [  ExternalMethodModifier+  ]  "Declare" [  CharsetModifier  ] "Function" Identifier
     '''		LibraryClause  [  AliasClause  ]  [  (  [  ParameterList  ]  )  ]  [  As  [  Attributes  ]  TypeName  ]
     '''		StatementTerminator
     ''' 
     ''' CharsetModifier  
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseExternalFunctionDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As ExternalFunctionDeclaration
         Dim result As New ExternalFunctionDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers = Nothing
         Dim m_CharsetModifier As KS = KS.None
         Dim m_Identifier As Identifier
         Dim m_LibraryClause As LibraryClause = Nothing
         Dim m_AliasClause As AliasClause = Nothing
         Dim m_ParameterList As ParameterList = Nothing
         Dim m_ReturnTypeAttributes As Attributes = Nothing
         Dim m_TypeName As TypeName = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.ExternalMethodModifiers)
         tm.AcceptIfNotInternalError(KS.Declare)
 
         If tm.CurrentToken.Equals(ModifierMasks.CharSetModifiers) Then
             m_CharsetModifier = tm.CurrentToken.Keyword
             tm.NextToken()
         End If
 
         tm.AcceptIfNotInternalError(KS.Function)
 
         m_Identifier = ParseIdentifier(result)
         If m_Identifier Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_LibraryClause = ParseLibraryClause(result)
         If m_LibraryClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If AliasClause.IsMe(tm) Then
             m_AliasClause = ParseAliasClause(result)
             If m_AliasClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
         If tm.Accept(KS.LParenthesis) Then
             m_ParameterList = New ParameterList(result)
             If tm.Accept(KS.RParenthesis) = False Then
                 If ParseList(Of Parameter)(m_ParameterList, New ParseDelegate_Parent(Of Parameter)(AddressOf ParseParameter), m_ParameterList) = False Then
                     Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 End If
 
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         End If
 
         If tm.Accept(KS.As) Then
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(result, m_ReturnTypeAttributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_CharsetModifier, m_Identifier, m_LibraryClause, m_AliasClause, m_ParameterList, m_ReturnTypeAttributes, m_TypeName)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CDecExpression.vb" startline="84" endline="137">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDecimal_Boolean)
             Case TypeCode.Decimal
                 'Nothing to do
             Case TypeCode.DateTime, TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16
                 Emitter.EmitConv_I4_Overflow(Info, expType)
                 Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_Decimal__ctor_Int32)
             Case TypeCode.Int32
                 Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_Decimal__ctor_Int32)
             Case TypeCode.Int64
                 Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_Decimal__ctor_Int64)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_U8_Overflow_Underflow(Info, expType)
                 Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_Decimal__ctor_UInt64)
             Case TypeCode.Double
                 Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_Decimal__ctor_Double)
             Case TypeCode.Single
                 Dim constant As Object = Nothing
                 If Expression.GetConstant(constant, False) Then
                     'VBC BUG? This seems to be a bug in vbc.exe.
                     Emitter.EmitLoadDecimalValue(Info, New Decimal(CDbl(constant)))
                 Else
                     'CORRECT CODE.
                     Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_Decimal__ctor_Single)
                 End If
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDecimal_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDecimal_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToDecimal_String)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="31" endline="69">
<![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveExpressions(Info) AndAlso result
 
         If Not result Then Return False
 
         If CecilHelper.IsValueType(m_LeftExpression.ExpressionType) AndAlso CecilHelper.IsNullable(m_LeftExpression.ExpressionType) = False Then
             If Keyword = KS.Is Then
                 Compiler.Report.ShowMessage(Messages.VBNC30020, Me.Location, Helper.ToString(Compiler, m_LeftExpression.ExpressionType))
             Else
                 Compiler.Report.ShowMessage(Messages.VBNC31419, Me.Location, Helper.ToString(Compiler, m_LeftExpression.ExpressionType))
             End If
         End If
         If CecilHelper.IsValueType(m_RightExpression.ExpressionType) AndAlso CecilHelper.IsNullable(m_RightExpression.ExpressionType) = False Then
             If Keyword = KS.Is Then
                 Compiler.Report.ShowMessage(Messages.VBNC30020, Me.Location, Helper.ToString(Compiler, m_RightExpression.ExpressionType))
             Else
                 Compiler.Report.ShowMessage(Messages.VBNC31419, Me.Location, Helper.ToString(Compiler, m_RightExpression.ExpressionType))
             End If
         End If
 
         If result = False Then Return False
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         If result AndAlso CecilHelper.IsGenericParameter(m_LeftExpression.ExpressionType) Then
             m_LeftExpression = New BoxExpression(Me, m_LeftExpression, m_LeftExpression.ExpressionType)
             m_DesiredNothingType = Compiler.TypeCache.System_Object
         End If
         If result AndAlso CecilHelper.IsGenericParameter(m_RightExpression.ExpressionType) Then
             m_RightExpression = New BoxExpression(Me, m_RightExpression, m_RightExpression.ExpressionType)
             m_DesiredNothingType = Compiler.TypeCache.System_Object
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ConstructorDeclaration.vb" startline="157" endline="213">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If CBool(MethodImplAttributes And Mono.Cecil.MethodImplAttributes.Runtime) Then
             Return result
         End If
 
         Helper.Assert(Info Is Nothing)
         Dim parent As IType = Me.FindTypeParent
         Info = New EmitInfo(Me)
 
 #If DEBUG Then
         Info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Nop)
 #End If
 
         Dim ParentType As Mono.Cecil.TypeReference
         ParentType = parent.CecilType
         If TypeOf parent Is StructureDeclaration AndAlso Me.IsShared = False Then
             Emitter.EmitLoadMe(Info, parent.CecilType)
             Emitter.EmitInitObj(Info, parent.CecilType)
         ElseIf m_DefaultBaseConstructor IsNot Nothing Then
             Dim params As Mono.Collections.Generic.Collection(Of ParameterDefinition) = m_DefaultBaseConstructor.Parameters
             Emitter.EmitLoadMe(Info, CecilHelper.FindDefinition(ParentType).BaseType)
             For i As Integer = 0 To params.Count - 1
                 Helper.Assert(params(i).IsOptional)
                 Emitter.EmitLoadValue(Info.Clone(Me, True, False, params(i).ParameterType), params(i).Constant)
             Next
 
             Emitter.EmitCall(Info, m_DefaultBaseConstructor)
         ElseIf m_BaseCtorCall IsNot Nothing Then
             result = m_BaseCtorCall.GenerateCode(Info)
         Else
             Helper.Assert(Me.IsShared)
         End If
 
         Dim exCtorCall As Mono.Cecil.MethodReference = ExplicitCtorCall
         If m_BaseCtorCall Is Nothing OrElse (exCtorCall IsNot Nothing AndAlso Helper.CompareType(exCtorCall.DeclaringType, Me.DeclaringType.CecilType) = False) Then
             result = EmitVariableInitialization(Info) AndAlso result
 
             For Each arhs As AddOrRemoveHandlerStatement In Me.DeclaringType.AddHandlers
                 result = arhs.GenerateCode(Info) AndAlso result
             Next
         End If
 
         If Me.IsShared Then
             result = EmitConstantInitialization(Info) AndAlso result
         End If
 
 #If DEBUG Then
         Info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Nop)
 #End If
 
         result = MyBase.GenerateCode(Info) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="360" endline="413">
<![CDATA[
 
     Private Function ResolveArrayInvocation(ByVal Context As ParsedObject, ByVal ArrayType As Mono.Cecil.TypeReference) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(CecilHelper.IsArray(ArrayType))
 
         If m_ArgumentList.HasNamedArguments Then
             Compiler.Report.ShowMessage(Messages.VBNC30075, tm.CurrentLocation)
             Return False
         End If
 
         Dim arrayRank As Integer = CecilHelper.GetArrayRank(ArrayType)
 
         If m_ArgumentList.Count > arrayRank Then
             Compiler.Report.ShowMessage(Messages.VBNC30106, Location)
             Return False
         ElseIf m_ArgumentList.Count < arrayRank Then
             Compiler.Report.ShowMessage(Messages.VBNC30105, Location)
             Return False
         End If
 
         Dim isStrictOn As Boolean = Location.File(Compiler).IsOptionStrictOn
 
         For i As Integer = 0 To m_ArgumentList.Count - 1
             Dim arg As Argument = m_ArgumentList(i)
             Dim argtype As Mono.Cecil.TypeReference = arg.Expression.ExpressionType
 
             If Compiler.TypeResolution.IsImplicitlyConvertible(Context, argtype, Compiler.TypeCache.System_Int32) = False Then
                 If isStrictOn Then
                     Helper.AddError(Me, "Array argument must be implicitly convertible to Integer.")
                     Return False
                 End If
                 Dim exp As Expression
                 exp = Helper.CreateTypeConversion(Me, m_ArgumentList(i).Expression, Compiler.TypeCache.System_Int32, result)
                 If result = False Then Return result
                 m_ArgumentList(i).Expression = exp
             ElseIf Helper.CompareType(argtype, Compiler.TypeCache.System_Int32) = False Then
                 Dim exp As Expression
                 exp = Helper.CreateTypeConversion(Me, m_ArgumentList(i).Expression, Compiler.TypeCache.System_Int32, result)
                 If result = False Then Return result
                 If CecilHelper.IsByRef(exp.ExpressionType) Then
                     exp = New DeRefExpression(Me, exp)
                 End If
                 m_ArgumentList(i).Expression = exp
             End If
         Next
 
         Dim aT As Mono.Cecil.ArrayType = DirectCast(ArrayType, Mono.Cecil.ArrayType)
         m_ExpressionType = aT.ElementType
 
         Classification = New VariableClassification(Me, Me.m_Expression, m_ArgumentList)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\RMhandler.vb" startline="66" endline="112">
<![CDATA[
 
     Private Sub CreatePieces(ByVal JoinAtEnd As Boolean)
 
         Dim Temp As String
         Dim OutFiles(mSegments.Length - 1) As String
         Dim i As Integer
 
         Dim TempOut As String
         If JoinAtEnd Then
             TempOut = System.IO.Path.GetTempPath & "Movicarm-"
         Else
             TempOut = StripExtension(mOutFile)
         End If
 
         Dim cw As IO.StreamWriter
         Try
             cw = New IO.StreamWriter(mCutterPath & "MovicaCmd@@@.cmd", False)
 
             For Each Segment As Segment In mSegments
                 OutFiles(i) = TempOut & CStr(i).PadLeft(3, "0"c) & ".rm"
                 cw.WriteLine(Chr(34) & mCutterPath & mConverter & Chr(34) & " -i " & Chr(34) & mInFile & Chr(34) & " -o " & _
                 Chr(34) & OutFiles(i) & Chr(34) & " -s " + CFmt(Segment.Start, True) + " -e " + CFmt(Segment.Finish, True))
                 i += 1
             Next
 
             If JoinAtEnd Then
                 Temp = Chr(34) & mCutterPath & mConverter & Chr(34)
                 For i = 0 To UBound(OutFiles)
                     Temp += " -i " & Chr(34) & OutFiles(i) & Chr(34) & " "
                 Next
                 Temp += " -o " & Chr(34) & mOutFile & Chr(34)
                 cw.WriteLine(Temp)
             End If
 
             cw.Close()
         Catch ex As Exception
             MsgBox("Error in creating the job file" & vbCrLf & ex.Message)
         Finally
             cw.Close()
         End Try
 
         'Start the process
         mConverter = "MovicaCmd@@@.cmd"
         RunConverter("")
         mConverter = "rmeditor"
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\RMhandler.vb" startline="49" endline="58">
<![CDATA[
 
     Public Function GetSetting(ByVal Category As String, ByVal Name As String, Optional ByVal Value As String = "") As String
         If mDoc Is Nothing Then Return Value
         Try
             Return mDoc.SelectSingleNode("Settings/" & Category & "/" & Name).InnerText
         Catch ex As Exception
             Return Microsoft.VisualBasic.GetSetting("Movica", Category, Name, Value)
         End Try
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeCache.vb" startline="843" endline="875">
<![CDATA[
 
     Public Overrides Sub InitInternalVB()
         MS_VB_CompareMethod = GetVBType("Microsoft.VisualBasic.CompareMethod")
         MS_VB_CS_Conversions = GetVBType("Microsoft.VisualBasic.CompilerServices.Conversions")
         MS_VB_CS_ProjectData = GetVBType("Microsoft.VisualBasic.CompilerServices.ProjectData")
         MS_VB_CS_LikeOperator = GetVBType("Microsoft.VisualBasic.CompilerServices.LikeOperator")
         MS_VB_Strings = GetVBType("Microsoft.VisualBasic.Strings")
         MS_VB_CS_StringType = GetVBType("Microsoft.VisualBasic.CompilerServices.StringType")
         MS_VB_MyGroupCollectionAttribute = GetVBType("Microsoft.VisualBasic.MyGroupCollectionAttribute")
         MS_VB_CallType = GetVBType("Microsoft.VisualBasic.CallType")
         MS_VB_Information = GetVBType("Microsoft.VisualBasic.Information")
         MS_VB_Interaction = GetVBType("Microsoft.VisualBasic.Interaction")
         MS_VB_CS_Versioned = GetVBType("Microsoft.VisualBasic.CompilerServices.Versioned")
         MS_VB_CS_StandardModuleAttribute = GetVBType("Microsoft.VisualBasic.CompilerServices.StandardModuleAttribute")
         MS_VB_CS_Operators = GetVBType("Microsoft.VisualBasic.CompilerServices.Operators")
         MS_VB_CS_ObjectFlowControl = GetVBType("Microsoft.VisualBasic.CompilerServices.ObjectFlowControl")
         If MS_VB_CS_ObjectFlowControl IsNot Nothing Then
             For i As Integer = 0 To MS_VB_CS_ObjectFlowControl.NestedTypes.Count - 1
                 If MS_VB_CS_ObjectFlowControl.NestedTypes(i).Name = "ForLoopControl" Then
                     MS_VB_CS_ObjectFlowControl_ForLoopControl = MS_VB_CS_ObjectFlowControl.NestedTypes(i)
                     Exit For
                 End If
             Next
         End If
         MS_VB_CS_Utils = GetVBType("Microsoft.VisualBasic.CompilerServices.Utils")
         MS_VB_CS_OptionCompareAttribute = GetVBType("Microsoft.VisualBasic.CompilerServices.OptionCompareAttribute")
         MS_VB_CS_OptionTextAttribute = GetVBType("Microsoft.VisualBasic.CompilerServices.OptionTextAttribute")
         MS_VB_CS_StaticLocalInitFlag = GetVBType("Microsoft.VisualBasic.CompilerServices.StaticLocalInitFlag")
         MS_VB_CS_DesignerGeneratedAttribute = GetVBType("Microsoft.VisualBasic.CompilerServices.DesignerGeneratedAttribute")
         MS_VB_CS_IncompleteInitialization = GetVBType("Microsoft.VisualBasic.CompilerServices.IncompleteInitialization")
         MS_VB_CS_NewLateBinding = GetVBType("Microsoft.VisualBasic.CompilerServices.NewLateBinding")
         MS_VB_CS_LateBinding = GetVBType("Microsoft.VisualBasic.CompilerServices.LateBinding")
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\DictionaryAccessExpression.vb" startline="96" endline="152">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Dim firsttp As Mono.Cecil.TypeReference
         If m_FirstPart IsNot Nothing Then
             result = m_FirstPart.ResolveExpression(Info) AndAlso result
             firsttp = m_FirstPart.ExpressionType
         Else
             m_WithStatement = Me.FindFirstParent(Of WithStatement)()
             firsttp = m_WithStatement.WithVariableExpression.ExpressionType
         End If
 
         If Helper.CompareType(Compiler.TypeCache.System_Object, firsttp) Then
             If Location.File(Compiler).IsOptionStrictOn Then
                 Helper.AddError(Me)
                 Return False
             End If
             m_IsLateBound = True
             Classification = New ValueClassification(Me, Compiler.TypeCache.System_Object)
             Return True
         End If
         Dim attr As Mono.Cecil.CustomAttribute = Helper.GetDefaultMemberAttribute(Compiler, firsttp)
         If attr Is Nothing Then Return Compiler.Report.ShowMessage(Messages.VBNC30367, Me.Location, firsttp.Name)
 
         Dim name As String = DirectCast(attr.ConstructorArguments(0).Value, String)
         Dim props As Mono.Collections.Generic.Collection(Of PropertyDefinition)
         Dim pgc As PropertyGroupClassification
         Dim arguments As New ArgumentList(Me)
         Dim instanceExpression As Expression
 
         If m_FirstPart IsNot Nothing Then
             instanceExpression = m_FirstPart
         Else
             instanceExpression = m_WithStatement.WithVariableExpression
         End If
 
         m_SecondExpression = New ConstantExpression(Me, m_SecondPart.Identifier, Compiler.TypeCache.System_String)
 
         props = CecilHelper.FindProperties(CecilHelper.FindDefinition(firsttp).Properties, name)
         pgc = New PropertyGroupClassification(Me, instanceExpression, props)
         arguments.Arguments.Add(New PositionalArgument(arguments, 0, m_SecondExpression))
         If Not pgc.ResolveGroup(arguments) Then
             pgc.ResolveGroup(arguments, True)
             Return False
         End If
 
         m_DefaultProperty = pgc.ResolvedProperty
         Classification = pgc
 
         result = Helper.IsConvertible(Me, m_SecondExpression, m_SecondExpression.ExpressionType, m_DefaultProperty.Parameters(0).ParameterType, True, m_SecondExpression, True, Nothing) AndAlso result
         If result Then
             arguments.Arguments(0).Expression = m_SecondExpression
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CByteExpression.vb" startline="87" endline="138">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_U1(Info, expType)
             Case TypeCode.Byte
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_U1_Overflow(Info, expType)
             Case TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_U1_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_U1_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_U1_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToByte_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToByte_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToByte_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToByte_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CIntExpression.vb" startline="87" endline="138">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_I4(Info, expType)
             Case TypeCode.Int32
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_I4_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_I4_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I4_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I4_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToInteger_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToInteger_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToInteger_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToInt32_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CLngExpression.vb" startline="87" endline="138">
<![CDATA[
     
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_I8(Info, expType)
             Case TypeCode.Int64
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_I8_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_I8_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I8_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I8_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToLong_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToLong_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToLong_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToInt64_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CSByteExpression.vb" startline="87" endline="138">
<![CDATA[
     
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_I1(Info, expType)
             Case TypeCode.SByte
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_I1_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_I1_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I1_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I1_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToSByte_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToSByte_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToSByte_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToSByte_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CShortExpression.vb" startline="87" endline="138">
<![CDATA[
     
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_I2(Info, expType)
             Case TypeCode.Int16
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_I2_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_I2_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I2_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_I2_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToShort_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToShort_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToShort_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToInt16_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CULngExpression.vb" startline="87" endline="138">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_U8(Info, expType)
             Case TypeCode.uInt64
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_U8_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_u8_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_U8_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_U8_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToULong_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToULong_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToULong_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToUInt64_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CUShortExpression.vb" startline="87" endline="138">
<![CDATA[
     
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_U2(Info, expType)
             Case TypeCode.UInt16
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_U2_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Emitter.EmitConv_u2_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_u2_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_U2_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToUShort_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToUShort_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToUShort_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToUInt16_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MyGenerator.vb" startline="218" endline="257">
<![CDATA[
 
     Function GenerateMyUser() As Boolean
         Dim result As Boolean = True
         Dim _MyUserDefine As Define
         Dim _MyUser As String
 
         _MyUserDefine = Compiler.CommandLine.Define("_MYUSERTYPE")
         If _MyUserDefine Is Nothing Then
             Select Case m_MyType
                 Case MyTypes.Console, MyTypes.WindowsFormsWithCustomSubMain, MyTypes.Windows, MyTypes.WindowsForms
                     _MyUser = "Windows"
                 Case MyTypes.Web, MyTypes.WebControl
                     _MyUser = "Web"
                 Case Else
                     _MyUser = String.Empty
             End Select
         Else
             _MyUser = _MyUserDefine.Value
         End If
 
         Dim baseClass As String
         Select Case _MyUser
             Case "Web"
                 baseClass = "Global.Microsoft.VisualBasic.ApplicationServices.WebUser"
             Case "Windows"
                 baseClass = "Global.Microsoft.VisualBasic.ApplicationServices.User"
             Case Else
                 Return True
         End Select
 
         ProjectCode.AppendLine("        Private Shared ReadOnly m_UserObjectProvider As ThreadSafeObjectProvider(Of Z) = New ThreadSafeObjectProvider(Of Z)".Replace("Z", baseClass))
         ProjectCode.AppendLine("        <Global.System.ComponentModel.Design.HelpKeyword(""My.User"")> _")
         ProjectCode.Append("        Friend Shared ReadOnly Property User As ") 
         ProjectCode.AppendLine("            <Global.System.Diagnostics.DebuggerHidden()> _")
         ProjectCode.AppendLine("            Get")
         ProjectCode.AppendLine("                Return m_UserObjectProvider.GetInstance")
         ProjectCode.AppendLine("            End Get")
         ProjectCode.AppendLine("        End Property")
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeConverter.vb" startline="1453" endline="1492">
<![CDATA[
 
     Public Shared Function ConvertToSingle(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object, ByVal ShowErrors As Boolean) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 result = CSng(DirectCast(Source, Boolean))
                 Return True
             Case TypeCode.Char
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Char", "Single")
             Case TypeCode.DateTime
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", "Single")
             Case TypeCode.Decimal
                 result = CSng(DirectCast(Source, Decimal))
                 Return True
             Case TypeCode.Double
                 Dim i As Double = DirectCast(Source, Double)
                 If i >= Single.MinValue AndAlso i <= Single.MaxValue Then
                     result = CSng(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 result = CSng(CLng(Source))
                 Return True
             Case TypeCode.Single
                 result = Source
                 Return True
             Case TypeCode.String
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "String", "Single")
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 result = CSng(CULng(Source))
                 Return True
             Case TypeCode.DBNull
                 result = 0.0!
                 Return True
         End Select
         If ShowErrors = False Then Return False
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "Single")
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\CallStatement.vb" startline="87" endline="128">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression1.ResolveExpression(Info) AndAlso result
         result = Helper.VerifyValueClassification(m_Expression1, Info) AndAlso result
 
         Dim selectstmt As SelectStatement = Me.FindFirstParent(Of SelectStatement)()
 
         m_Expression1 = Helper.CreateTypeConversion(Me, m_Expression1, selectstmt.Test.ExpressionType, result)
 
         If m_Expression2 IsNot Nothing Then
             result = m_Expression2.ResolveExpression(Info) AndAlso result
             result = Helper.VerifyValueClassification(m_Expression2, Info) AndAlso result
             m_Expression2 = Helper.CreateTypeConversion(Me, m_Expression2, selectstmt.Test.ExpressionType, result)
 
             Dim lside, rside As Expression
             lside = New GEExpression(Me, selectstmt.CachedTest, m_Expression1)
             rside = New LEExpression(Me, selectstmt.CachedTest, m_Expression2)
             m_ComparisonExpression = New AndExpression(Me, lside, rside)
         Else
             Select Case m_Comparison
                 Case KS.GT
                     m_ComparisonExpression = New GTExpression(Me, selectstmt.CachedTest, m_Expression1)
                 Case KS.LT
                     m_ComparisonExpression = New LTExpression(Me, selectstmt.CachedTest, m_Expression1)
                 Case KS.GE
                     m_ComparisonExpression = New GEExpression(Me, selectstmt.CachedTest, m_Expression1)
                 Case KS.LE
                     m_ComparisonExpression = New LEExpression(Me, selectstmt.CachedTest, m_Expression1)
                 Case KS.Equals, KS.None
                     m_ComparisonExpression = New EqualsExpression(Me, selectstmt.CachedTest, m_Expression1)
                 Case KS.NotEqual
                     m_ComparisonExpression = New NotEqualsExpression(Me, selectstmt.CachedTest, m_Expression1)
                 Case Else
                     Throw New InternalException(Me)
             End Select
         End If
         result = m_ComparisonExpression.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmProfiles.vb" startline="15" endline="350">
<![CDATA[
 
     Private components As System.ComponentModel.IContainer
 
     <System.Diagnostics.DebuggerStepThrough()> _
     Private Sub InitializeComponent()
         Me.components = New System.ComponentModel.Container
         Dim resources As System.ComponentModel.ComponentResourceManager = New System.ComponentModel.ComponentResourceManager(GetType(FrmProfiles))
         Me.PnlMain = New System.Windows.Forms.Panel
         Me.BoxProfiles = New ComponentFactory.Krypton.Toolkit.KryptonGroup
         Me.PnlProfiles = New System.Windows.Forms.Panel
         Me.LstProfiles = New System.Windows.Forms.ListView
         Me.ColProfiles = New System.Windows.Forms.ColumnHeader
         Me.ColDate = New System.Windows.Forms.ColumnHeader
         Me.ColDescription = New System.Windows.Forms.ColumnHeader
         Me.ConTxtMnu = New System.Windows.Forms.ContextMenuStrip(Me.components)
         Me.ItmPreview = New System.Windows.Forms.ToolStripMenuItem
         Me.ItmApply = New System.Windows.Forms.ToolStripMenuItem
         Me.Sprtr1 = New System.Windows.Forms.ToolStripSeparator
         Me.ItmValidate = New System.Windows.Forms.ToolStripMenuItem
         Me.ItmEdit = New System.Windows.Forms.ToolStripMenuItem
         Me.ItmDelete = New System.Windows.Forms.ToolStripMenuItem
         Me.Sprtr2 = New System.Windows.Forms.ToolStripSeparator
         Me.ItmImport = New System.Windows.Forms.ToolStripMenuItem
         Me.ItmCreate = New System.Windows.Forms.ToolStripMenuItem
         Me.HdrTasks = New ComponentFactory.Krypton.Toolkit.KryptonHeader
         Me.BtnCreate = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnImport = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnDelete = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnEdit = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnValidate = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnApply = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnPreview = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.LblInfo = New System.Windows.Forms.Label
         Me.BtnClose = New System.Windows.Forms.Button
         Me.BWProfiles = New System.ComponentModel.BackgroundWorker
         Me.HdrMain = New ComponentFactory.Krypton.Toolkit.KryptonHeader
         Me.FileDlg = New System.Windows.Forms.OpenFileDialog
         Me.PnlMain.SuspendLayout()
         CType(Me.BoxProfiles, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.BoxProfiles.Panel, System.ComponentModel.ISupportInitialize).BeginInit()
         Me.BoxProfiles.Panel.SuspendLayout()
         Me.BoxProfiles.SuspendLayout()
         Me.PnlProfiles.SuspendLayout()
         Me.ConTxtMnu.SuspendLayout()
         Me.SuspendLayout()
         '
         'PnlMain
         '
         Me.PnlMain.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
                     Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.PnlMain.BackColor = System.Drawing.Color.White
         Me.PnlMain.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.PnlMain.Controls.Add(Me.BoxProfiles)
         Me.PnlMain.Controls.Add(Me.LblInfo)
         Me.PnlMain.Location = New System.Drawing.Point(-2, 49)
         Me.PnlMain.Name = "PnlMain"
         Me.PnlMain.Size = New System.Drawing.Size(663, 500)
         Me.PnlMain.TabIndex = 1
         '
         'BoxProfiles
         '
         Me.BoxProfiles.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
                     Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.BoxProfiles.GroupBackStyle = ComponentFactory.Krypton.Toolkit.PaletteBackStyle.TabOneNote
         Me.BoxProfiles.Location = New System.Drawing.Point(14, 125)
         Me.BoxProfiles.Name = "BoxProfiles"
         Me.BoxProfiles.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Silver
         '
         'BoxProfiles.Panel
         '
         Me.BoxProfiles.Panel.Controls.Add(Me.PnlProfiles)
         Me.BoxProfiles.Panel.Controls.Add(Me.HdrTasks)
         Me.BoxProfiles.Size = New System.Drawing.Size(630, 340)
         Me.BoxProfiles.StateNormal.Border.DrawBorders = CType((((ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Top Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Left) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Right), ComponentFactory.Krypton.Toolkit.PaletteDrawBorders)
         Me.BoxProfiles.StateNormal.Border.Rounding = 3
         Me.BoxProfiles.TabIndex = 1
         '
         'PnlProfiles
         '
         Me.PnlProfiles.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
                     Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.PnlProfiles.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle
         Me.PnlProfiles.Controls.Add(Me.LstProfiles)
         Me.PnlProfiles.Location = New System.Drawing.Point(16, 50)
         Me.PnlProfiles.Name = "PnlProfiles"
         Me.PnlProfiles.Size = New System.Drawing.Size(595, 270)
         Me.PnlProfiles.TabIndex = 1
         '
         'LstProfiles
         '
         Me.LstProfiles.BackColor = System.Drawing.Color.White
         Me.LstProfiles.BorderStyle = System.Windows.Forms.BorderStyle.None
         Me.LstProfiles.Columns.AddRange(New System.Windows.Forms.ColumnHeader() {Me.ColProfiles, Me.ColDate, Me.ColDescription})
         Me.LstProfiles.ContextMenuStrip = Me.ConTxtMnu
         Me.LstProfiles.Dock = System.Windows.Forms.DockStyle.Fill
         Me.LstProfiles.ForeColor = System.Drawing.Color.Black
         Me.LstProfiles.FullRowSelect = True
         Me.LstProfiles.GridLines = True
         Me.LstProfiles.Location = New System.Drawing.Point(0, 0)
         Me.LstProfiles.MultiSelect = False
         Me.LstProfiles.Name = "LstProfiles"
         Me.LstProfiles.Size = New System.Drawing.Size(593, 268)
         Me.LstProfiles.Sorting = System.Windows.Forms.SortOrder.Ascending
         Me.LstProfiles.TabIndex = 1
         Me.LstProfiles.UseCompatibleStateImageBehavior = False
         Me.LstProfiles.View = System.Windows.Forms.View.Details
         '
         'ColProfiles
         '
         Me.ColProfiles.Text = "Services profile"
         Me.ColProfiles.Width = 125
         '
         'ColDate
         '
         Me.ColDate.Text = "Date created"
         Me.ColDate.Width = 125
         '
         'ColDescription
         '
         Me.ColDescription.Text = "Description"
         Me.ColDescription.Width = 330
         '
         'ConTxtMnu
         '
         Me.ConTxtMnu.Font = New System.Drawing.Font("Segoe UI", 9.0!)
         Me.ConTxtMnu.Items.AddRange(New System.Windows.Forms.ToolStripItem() {Me.ItmPreview, Me.ItmApply, Me.Sprtr1, Me.ItmValidate, Me.ItmEdit, Me.ItmDelete, Me.Sprtr2, Me.ItmImport, Me.ItmCreate})
         Me.ConTxtMnu.Name = "ConTxtMnu"
         Me.ConTxtMnu.ShowItemToolTips = False
         Me.ConTxtMnu.Size = New System.Drawing.Size(136, 170)
         '
         'ItmPreview
         '
         Me.ItmPreview.Name = "ItmPreview"
         Me.ItmPreview.Size = New System.Drawing.Size(135, 22)
         Me.ItmPreview.Text = "Preview"
         '
         'ItmApply
         '
         Me.ItmApply.Name = "ItmApply"
         Me.ItmApply.Size = New System.Drawing.Size(135, 22)
         Me.ItmApply.Text = "Apply"
         '
         'Sprtr1
         '
         Me.Sprtr1.Name = "Sprtr1"
         Me.Sprtr1.Size = New System.Drawing.Size(132, 6)
         '
         'ItmValidate
         '
         Me.ItmValidate.Name = "ItmValidate"
         Me.ItmValidate.Size = New System.Drawing.Size(135, 22)
         Me.ItmValidate.Text = "Validate"
         '
         'ItmEdit
         '
         Me.ItmEdit.Name = "ItmEdit"
         Me.ItmEdit.Size = New System.Drawing.Size(135, 22)
         Me.ItmEdit.Text = "Edit"
         '
         'ItmDelete
         '
         Me.ItmDelete.Name = "ItmDelete"
         Me.ItmDelete.Size = New System.Drawing.Size(135, 22)
         Me.ItmDelete.Text = "Delete"
         '
         'Sprtr2
         '
         Me.Sprtr2.Name = "Sprtr2"
         Me.Sprtr2.Size = New System.Drawing.Size(132, 6)
         '
         'ItmImport
         '
         Me.ItmImport.Name = "ItmImport"
         Me.ItmImport.Size = New System.Drawing.Size(135, 22)
         Me.ItmImport.Text = "Import"
         '
         'ItmCreate
         '
         Me.ItmCreate.Name = "ItmCreate"
         Me.ItmCreate.Size = New System.Drawing.Size(135, 22)
         Me.ItmCreate.Text = "New profile"
         '
         'HdrTasks
         '
         Me.HdrTasks.AllowButtonSpecToolTips = True
         Me.HdrTasks.ButtonSpecs.AddRange(New ComponentFactory.Krypton.Toolkit.ButtonSpecAny() {Me.BtnCreate, Me.BtnImport, Me.BtnDelete, Me.BtnEdit, Me.BtnValidate, Me.BtnApply, Me.BtnPreview})
         Me.HdrTasks.Dock = System.Windows.Forms.DockStyle.Top
         Me.HdrTasks.HeaderStyle = ComponentFactory.Krypton.Toolkit.HeaderStyle.Secondary
         Me.HdrTasks.Location = New System.Drawing.Point(0, 0)
         Me.HdrTasks.Name = "HdrTasks"
         Me.HdrTasks.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Silver
         Me.HdrTasks.Size = New System.Drawing.Size(626, 28)
         Me.HdrTasks.StateNormal.Border.DrawBorders = ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom
         Me.HdrTasks.TabIndex = 0
         Me.HdrTasks.TabStop = False
         Me.HdrTasks.Values.Description = ""
         Me.HdrTasks.Values.Heading = ""
         Me.HdrTasks.Values.Image = Nothing
         '
         'BtnCreate
         '
         Me.BtnCreate.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnCreate.Text = " New profile"
         Me.BtnCreate.ToolTipBody = "Create a new services profile."
         Me.BtnCreate.UniqueName = ""
         '
         'BtnImport
         '
         Me.BtnImport.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnImport.Text = " Import"
         Me.BtnImport.ToolTipBody = "Import an existing services profile."
         Me.BtnImport.UniqueName = ""
         '
         'BtnDelete
         '
         Me.BtnDelete.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnDelete.Text = " Delete"
         Me.BtnDelete.ToolTipBody = "Delete the selected services profile."
         Me.BtnDelete.UniqueName = ""
         '
         'BtnEdit
         '
         Me.BtnEdit.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnEdit.Text = " Edit"
         Me.BtnEdit.ToolTipBody = "Edit the selected services profile."
         Me.BtnEdit.UniqueName = ""
         '
         'BtnValidate
         '
         Me.BtnValidate.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnValidate.Text = " Validate"
         Me.BtnValidate.ToolTipBody = "Validate the selected services profile."
         Me.BtnValidate.UniqueName = ""
         '
         'BtnApply
         '
         Me.BtnApply.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnApply.Text = " Apply"
         Me.BtnApply.ToolTipBody = "Apply the selected services profile."
         Me.BtnApply.UniqueName = ""
         '
         'BtnPreview
         '
         Me.BtnPreview.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnPreview.Text = " Preview"
         Me.BtnPreview.ToolTipBody = "Preview the selected services profile."
         Me.BtnPreview.UniqueName = ""
         '
         'LblInfo
         '
         Me.LblInfo.Anchor = CType(((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.LblInfo.Location = New System.Drawing.Point(16, 23)
         Me.LblInfo.Name = "LblInfo"
         Me.LblInfo.Size = New System.Drawing.Size(620, 85)
         Me.LblInfo.TabIndex = 0
         Me.LblInfo.Text = resources.GetString("LblInfo.Text")
         '
         'BtnClose
         '
         Me.BtnClose.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.BtnClose.Location = New System.Drawing.Point(562, 560)
         Me.BtnClose.Name = "BtnClose"
         Me.BtnClose.Size = New System.Drawing.Size(85, 25)
         Me.BtnClose.TabIndex = 2
         Me.BtnClose.Text = "&Close"
         Me.BtnClose.UseVisualStyleBackColor = True
         '
         'BWProfiles
         '
         Me.BWProfiles.WorkerReportsProgress = True
         Me.BWProfiles.WorkerSupportsCancellation = True
         '
         'HdrMain
         '
         Me.HdrMain.Dock = System.Windows.Forms.DockStyle.Top
         Me.HdrMain.Location = New System.Drawing.Point(0, 0)
         Me.HdrMain.Name = "HdrMain"
         Me.HdrMain.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2007Silver
         Me.HdrMain.Size = New System.Drawing.Size(659, 53)
         Me.HdrMain.StateNormal.Back.Color1 = System.Drawing.Color.White
         Me.HdrMain.StateNormal.Back.Color2 = System.Drawing.Color.Gainsboro
         Me.HdrMain.StateNormal.Back.ColorStyle = ComponentFactory.Krypton.Toolkit.PaletteColorStyle.HalfCut
         Me.HdrMain.StateNormal.Border.DrawBorders = ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom
         Me.HdrMain.StateNormal.Content.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.HdrMain.StateNormal.Content.ShortText.Font = New System.Drawing.Font("Calibri", 27.75!, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.HdrMain.TabIndex = 0
         Me.HdrMain.TabStop = False
         Me.HdrMain.Values.Description = ""
         Me.HdrMain.Values.Heading = " Services Profiles"
         Me.HdrMain.Values.Image = Nothing
         '
         'FileDlg
         '
         Me.FileDlg.DefaultExt = "wsp"
         Me.FileDlg.Filter = "Services Profiles|*.wsp"
         Me.FileDlg.Title = "Import services profile"
         '
         'FrmProfiles
         '
         Me.AutoScaleMode = System.Windows.Forms.AutoScaleMode.None
         Me.ClientSize = New System.Drawing.Size(659, 596)
         Me.ControlBox = False
         Me.Controls.Add(Me.HdrMain)
         Me.Controls.Add(Me.BtnClose)
         Me.Controls.Add(Me.PnlMain)
         Me.DoubleBuffered = True
         Me.Font = New System.Drawing.Font("Segoe UI", 9.0!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.ForeColor = System.Drawing.Color.Black
         Me.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None
         Me.KeyPreview = True
         Me.MaximizeBox = False
         Me.MinimizeBox = False
         Me.Name = "FrmProfiles"
         Me.ShowIcon = False
         Me.ShowInTaskbar = False
         Me.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide
         Me.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen
         Me.Text = "Services Profiles"
         Me.PnlMain.ResumeLayout(False)
         CType(Me.BoxProfiles.Panel, System.ComponentModel.ISupportInitialize).EndInit()
         Me.BoxProfiles.Panel.ResumeLayout(False)
         Me.BoxProfiles.Panel.PerformLayout()
         CType(Me.BoxProfiles, System.ComponentModel.ISupportInitialize).EndInit()
         Me.BoxProfiles.ResumeLayout(False)
         Me.PnlProfiles.ResumeLayout(False)
         Me.ConTxtMnu.ResumeLayout(False)
         Me.ResumeLayout(False)
         Me.PerformLayout()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CUIntExpression.vb" startline="87" endline="144">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
                 Emitter.EmitNeg(Info)
                 Emitter.EmitConv_U4(Info, expType)
             Case TypeCode.UInt32
                 'Nothing to do
             Case TypeCode.Char
                 Info.Compiler.Report.ShowMessage(Messages.VBNC32006, Expression.Location, Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Emitter.EmitConv_U4_Overflow(Info, expType)
             Case TypeCode.Byte, TypeCode.UInt16
                 'nothing to do
                 'Emitter.EmitConv_U4_Overflow_Underflow(Info, expType)
             Case TypeCode.UInt32
                 'nothing to do
             Case TypeCode.UInt64
                 'nothing to do
                 Emitter.EmitConv_U4_Overflow_Underflow(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_U4_Overflow(Info, expType)
             Case TypeCode.Single
                 Emitter.EmitConv_R8(Info, expType)
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Math__Round_Double)
                 Emitter.EmitConv_U4_Overflow(Info, Info.Compiler.TypeCache.System_Double)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToUInteger_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToUInteger_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToUInteger_String)
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToUInt32_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" startline="74" endline="127">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Boolean)
             Case TypeCode.String
                 'Nothing to do
             Case TypeCode.Char
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Char)
             Case TypeCode.DateTime
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_DateTime)
             Case TypeCode.SByte, TypeCode.Int16
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Int32)
             Case TypeCode.Int32
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Int32)
             Case TypeCode.Int64
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Int64)
             Case TypeCode.Byte
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Byte)
             Case TypeCode.UInt16, TypeCode.UInt32
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_UInt32)
             Case TypeCode.UInt64
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_UInt64)
             Case TypeCode.Double
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Double)
             Case TypeCode.Single
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Single)
             Case TypeCode.Object
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Char_Array) Then
                     Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_String__ctor_Array)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     'No conversion necessary
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.System_Char_Array) Then
                     Emitter.EmitNew(Info, Info.Compiler.TypeCache.System_String__ctor_Array)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99999, Expression.Location, "Can't convert")
                 End If
             Case TypeCode.Decimal
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToString_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3939" endline="3962">
<![CDATA[
 
     Friend Sub UpdateRTF(ByVal Text As String, ByVal Err As MessageType)
 
         SyncLock Me
             With rtfTrace
                 .SelectionStart = .TextLength
 
                 Select Case Err
                     Case modMain.MessageType.AsUsual
                         .SelectionColor = Color.Black
                     Case modMain.MessageType.Failure
                         .SelectionColor = Color.Red
                     Case modMain.MessageType.Success
                         .SelectionColor = Color.Blue
                 End Select
 
                 .SelectedText = Text
                 .SelectionLength = 0
 
                 .Refresh()
             End With
         End SyncLock
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2170" endline="2186">
<![CDATA[
 
     Private Function FinishTheList() As Boolean
 
         Dim Last As Integer = lvPositions.Items.Count - 1
         If Last < 0 Then Exit Function
 
         If lvPositions.Items(Last).SubItems.Count = 1 Then
             Dim EndPos As String
             EndPos = SecToMin(Math.Round(mPlayer.currentMedia.duration, 3))
             lvPositions.Items(Last).SubItems.Add(EndPos)
         End If
         mPlayer.Ctlcontrols.pause()
 
         UpdateSelDur()
         Return True
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="154" endline="170">
<![CDATA[
     End Property
 
     Private Shared m_FakeGenerator As EmitLog
     ''' <summary>
     ''' The ILGenerator used to emit the code.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property ILGen() As EmitLog
         Get
             If m_FakeGenerator Is Nothing OrElse m_FakeGenerator.Compiler IsNot Compiler Then
                 m_FakeGenerator = New EmitLog(Compiler)
             End If
             m_FakeGenerator.CilBody = CilBody
             Return m_FakeGenerator
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmManual.vb" startline="218" endline="232">
<![CDATA[
 
     Private Sub BtnCSnapshot_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles BtnCSnapshot.Click
 
         If Common.Validate(TxtName, TxtDescription, 0) = 0 Then
             Exit Sub
         End If
 
         If Common.Create_Snapshot((TxtName.Text & ".wss"), TxtDescription.Text) = True Then
             MessageBox.Show("The new services snapshot created successfully.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Information, MessageBoxDefaultButton.Button1, 0, False)
             TxtName.Text = ""
             TxtDescription.Text = ""
             TxtName.Focus()
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2461" endline="2476">
<![CDATA[
 
 #End Region
 
 #Region "   Drag and Drop "
 
     Private Sub frmMain_DragEnter(ByVal sender As Object, _
     ByVal e As System.Windows.Forms.DragEventArgs) _
     Handles MyBase.DragEnter
 
         If (e.Data.GetDataPresent(DataFormats.FileDrop)) Then
             e.Effect = DragDropEffects.Copy
         Else
             e.Effect = DragDropEffects.None
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\dshowUtil.vb" startline="230" endline="240">
<![CDATA[
 
     Private Sub LoadLang()
         If Not mTranslator Is Nothing Then
             chkRemind.Text = mTranslator.LangText(24)
             mText(1) = mTranslator.LangText(14)
             mText(2) = mTranslator.LangText(65)
         Else
             mText(1) = "Acknowledgements"
             mText(2) = "Please click here to get this version "
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="4516" endline="4561">
<![CDATA[
 #End Region
 
 #Region "   Compact Mode "
 
     Private Sub mnuCompact_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles mnuCompact.Click
         Select Case mnuCompact.Checked
             Case True       'Toggle to normal mode
                 mnuCompact.Checked = False
                 panSegments.Visible = True
                 PanelFine.Visible = True
                 Me.MinimumSize = New Size(600, 485)
                 mainTabs.TabPages.Add(Me.tabJoin)
                 mainTabs.TabPages.Add(Me.tabSplit)
                 mainTabs.TabPages.Add(Me.tabTrace)
                 mainTabs.TabPages.Add(Me.tabSettings)
                 mainTabs.TabPages.Add(Me.tabTools)
                 mainTabs.Alignment = TabAlignment.Top
                 'MenuItem1.Visible = True
                 'MenuItem2.Visible = True
                 'MenuItem5.Visible = True
                 'MenuItem7.Visible = True
                 'mnuView.Visible = True
                 MPcontrols.DisplayMode = ucMPcontrols.MPCDisplayMode.Normal
                 tabPlayer.Text = mTranslator.LangText(63)
 
             Case False      'Toggle to compact mode
                 mnuCompact.Checked = True
                 panSegments.Visible = False
                 PanelFine.Visible = False
                 Me.MinimumSize = New Size(350, 240)
                 mainTabs.TabPages.Remove(Me.tabJoin)
                 mainTabs.TabPages.Remove(Me.tabSettings)
                 mainTabs.TabPages.Remove(Me.tabSplit)
                 mainTabs.TabPages.Remove(Me.tabTrace)
                 mainTabs.TabPages.Remove(Me.tabTools)
                 mainTabs.Alignment = TabAlignment.Left
                 'MenuItem1.Visible = False
                 'MenuItem2.Visible = False
                 'MenuItem5.Visible = False
                 'MenuItem7.Visible = False
                 'mnuView.Visible = False
                 MPcontrols.DisplayMode = ucMPcontrols.MPCDisplayMode.Compact
                 tabPlayer.Text = mTranslator.LangText(125)
 
         End Select
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmProfiles.vb" startline="221" endline="240">
<![CDATA[
 
     Private Sub BtnImport_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles BtnImport.Click, ItmImport.Click
 
         If FileDlg.ShowDialog = Windows.Forms.DialogResult.OK Then
 
             If File.Exists(ProfilesDir & FileDlg.SafeFileName) = True Then
                 MessageBox.Show("A services profile with the same name is found.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
                 Exit Sub
             End If
 
             Try
                 File.Copy(FileDlg.FileName, ProfilesDir & FileDlg.SafeFileName)
                 Call Check_Profiles()
             Catch ex As IOException
                 MessageBox.Show("Error importing the selected services profile.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
             End Try
 
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmDiagnostics.vb" startline="274" endline="297">
<![CDATA[
 
     Private Sub Essential_Diagnostics(ByVal Name As String, ByVal Index As Byte)
 
         Try
             SrvcCntrl.ServiceName = (Name)
             Dim ChkSrvc As Boolean = SrvcCntrl.CanPauseAndContinue
         Catch ex As InvalidOperationException
             LstServices.Items.Item(Index).Checked = False
             LstServices.Items.Item(Index).SubItems.Item(1).Text = S5
             LstServices.Items.Item(Index).SubItems.Item(1).ForeColor = Color.DimGray
             Exit Sub
         End Try
 
         If SrvcCntrl.Status = ServiceProcess.ServiceControllerStatus.Running And Service_Startup(Name) = 2 Then
             LstServices.Items.Item(Index).Checked = False
             LstServices.Items.Item(Index).SubItems.Item(1).Text = S1
             LstServices.Items.Item(Index).SubItems.Item(1).ForeColor = Color.Green
         Else
             LstServices.Items.Item(Index).Checked = True
             LstServices.Items.Item(Index).SubItems.Item(1).Text = S2
             LstServices.Items.Item(Index).SubItems.Item(1).ForeColor = Color.Red
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1681" endline="1731">
<![CDATA[
 
     ''' <summary>
     ''' Loads the value of the specified address.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="ByRefType"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadIndirect(ByVal Info As EmitInfo, ByVal ByRefType As Mono.Cecil.TypeReference)
         ByRefType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ByRefType)
         Dim elementtype As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ByRefType)
         Select Case Helper.GetTypeCode(Info.Compiler, elementtype)
             Case TypeCode.Byte
                 Info.ILGen.Emit(OpCodes.Ldind_U1)
             Case TypeCode.SByte
                 Info.ILGen.Emit(OpCodes.Ldind_I1)
             Case TypeCode.UInt16, TypeCode.Char
                 Info.ILGen.Emit(OpCodes.Ldind_U2)
             Case TypeCode.Int16
                 Info.ILGen.Emit(OpCodes.Ldind_I2)
             Case TypeCode.UInt32
                 Info.ILGen.Emit(OpCodes.Ldind_U4)
             Case TypeCode.Int32
                 Info.ILGen.Emit(OpCodes.Ldind_I4)
             Case TypeCode.UInt64
                 Info.ILGen.Emit(OpCodes.Ldind_I8)
             Case TypeCode.Int64
                 Info.ILGen.Emit(OpCodes.Ldind_I8)
             Case TypeCode.Single
                 Info.ILGen.Emit(OpCodes.Ldind_R4)
             Case TypeCode.Double
                 Info.ILGen.Emit(OpCodes.Ldind_R8)
             Case TypeCode.String, TypeCode.DBNull
                 Info.ILGen.Emit(OpCodes.Ldind_Ref)
             Case TypeCode.Object
                 If elementtype.IsValueType Then
                     Info.ILGen.Emit(OpCodes.Ldobj, elementtype)
                 Else
                     Info.ILGen.Emit(OpCodes.Ldind_Ref)
                 End If
             Case TypeCode.Boolean
                 Info.ILGen.Emit(OpCodes.Ldind_I1)
             Case TypeCode.Decimal
                 Info.ILGen.Emit(OpCodes.Ldobj, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Decimal))
             Case Else
                 If elementtype.IsValueType Then
                     Info.ILGen.Emit(OpCodes.Ldobj, elementtype)
                 Else
                     Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Info.Location)
                 End If
         End Select
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmManual.vb" startline="126" endline="172">
<![CDATA[
 
 #End Region
 
 #Region "Tools"
 
     Private Sub BtnLock_Click(ByVal sender As Object, ByVal e As System.EventArgs) Handles BtnLock.Click
 
         If BtnLock.Tag = 0 Then
 
             CboSecCntr.Enabled = True
             CboWinUpdate.Enabled = True
             CboWinDefender.Enabled = True
             CboWinFirewall.Enabled = True
             CboDHCP.Enabled = True
             CboDNS.Enabled = True
             CboDFS.Enabled = True
             CboWorkstation.Enabled = True
 
             BtnLock.ToolTipBody = "Lock the modification of critical services."
             BtnLock.Tag = 1
 
         ElseIf BtnLock.Tag = 1 Then
 
             CboSecCntr.Enabled = False
             CboWinUpdate.Enabled = False
             CboWinDefender.Enabled = False
             CboWinFirewall.Enabled = False
             CboDHCP.Enabled = False
             CboDNS.Enabled = False
             CboDFS.Enabled = False
             CboWorkstation.Enabled = False
 
             BtnLock.ToolTipBody = "Unlock the modification of critical services."
             BtnLock.Tag = 0
 
         End If
 
         Check_Service("wscsvc", CboSecCntr)
         Check_Service("wuauserv", CboWinUpdate)
         Check_Service("WinDefend", CboWinDefender)
         Check_Service("MpsSvc", CboWinFirewall)
         Check_Service("Dhcp", CboDHCP)
         Check_Service("Dnscache", CboDNS)
         Check_Service("DFSR", CboDFS)
         Check_Service("LanmanWorkstation", CboWorkstation)
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MyGenerator.vb" startline="509" endline="559">
<![CDATA[
 
     Function GenerateMyComputer() As Boolean
         Dim result As Boolean = True
         Dim _MyComputerDefine As Define
         Dim _MyComputer As String
 
         _MyComputerDefine = Compiler.CommandLine.Define("_MYCOMPUTERTYPE")
         If _MyComputerDefine Is Nothing Then
             Select Case m_MyType
                 Case MyTypes.Console, MyTypes.WindowsFormsWithCustomSubMain, MyTypes.Windows, MyTypes.WindowsForms
                     _MyComputer = "Windows"
                 Case MyTypes.Web, MyTypes.WebControl
                     _MyComputer = "Web"
                 Case Else
                     _MyComputer = String.Empty
             End Select
         Else
             _MyComputer = _MyComputerDefine.Value
         End If
 
         Dim baseClass As String
         Select Case _MyComputer
             Case "Web"
                 baseClass = "Global.Microsoft.VisualBasic.Devices.ServerComputer"
             Case "Windows"
                 baseClass = "Global.Microsoft.VisualBasic.Devices.Computer"
             Case Else
                 Return True
         End Select
 
         Code.AppendLine("    <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _")
         Code.AppendLine("    <Global.System.CodeDom.Compiler.GeneratedCode(""MyTemplate"", ""10.0.0.0"")> _")
         Code.AppendLine("    Friend Class MyComputer")
         Code.Append("        Inherits ") 
         Code.AppendLine("        <Global.System.Diagnostics.DebuggerHidden()> _")
         Code.AppendLine("        <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _")
         Code.AppendLine("        Public Sub New()")
         Code.AppendLine("        End Sub")
         Code.AppendLine("    End Class")
 
         ProjectCode.AppendLine("        Private Shared ReadOnly m_ComputerObjectProvider As ThreadSafeObjectProvider(Of $GLOBALMY$.MyComputer) = New ThreadSafeObjectProvider(Of $GLOBALMY$.MyComputer)")
         ProjectCode.AppendLine("        <Global.System.ComponentModel.Design.HelpKeyword(""My.Computer"")> _")
         ProjectCode.AppendLine("        Friend Shared ReadOnly Property Computer As $GLOBALMY$.MyComputer")
         ProjectCode.AppendLine("            <Global.System.Diagnostics.DebuggerHidden()> _")
         ProjectCode.AppendLine("            Get")
         ProjectCode.AppendLine("                Return m_ComputerObjectProvider.GetInstance")
         ProjectCode.AppendLine("            End Get")
         ProjectCode.AppendLine("        End Property")
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="924" endline="931">
<![CDATA[
 
     Private Sub emit_padding(ByVal w As IO.BinaryWriter)
         Dim ms As IO.Stream = w.BaseStream
 
         If ((ms.Position Mod 4) <> 0) Then
             w.Write(CShort(0))
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="893" endline="909">
<![CDATA[
 
     ''' <summary>
     ''' Emits a constrained callvirt instructions. 
     ''' Throws an exception if the method is a shared method.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Method"></param>
     ''' <remarks></remarks>
     Shared Sub EmitConstrainedCallVirt(ByVal Info As EmitInfo, ByVal Method As Mono.Cecil.MethodReference, ByVal ConstrainedType As Mono.Cecil.TypeReference)
         Dim OriginalMethod As Mono.Cecil.MethodReference = Method
 
         Helper.Assert(Method IsNot Nothing)
         Helper.Assert(ConstrainedType IsNot Nothing)
 
         EmitConstrained(Info, ConstrainedType)
         EmitCallVirt(Info, Method)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="327" endline="337">
<![CDATA[
 
     ReadOnly Property Identifier() As String
         Get
             If IsKeyword() Then
                 Return Enums.strSpecial(Keyword)
             ElseIf IsIdentifier() Then
                 Return DirectCast(m_TokenObject, String)
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="77" endline="116">
<![CDATA[
     End Property
 
     Public Overrides Function GetConstant(ByRef m_ConstantValue As Object, ByVal lvalue As Object, ByVal rvalue As Object) As Boolean
         Dim shifts As Integer 'This needs to be an integer.
         Dim tmpShifts As Object = Nothing
 
         If Compiler.TypeResolution.CheckNumericRange(rvalue, tmpShifts, Compiler.TypeCache.System_Int32) = False Then
             Return False
         Else
             shifts = CInt(tmpShifts)
         End If
 
         Dim tlvalue As Mono.Cecil.TypeReference
         Dim clvalue As TypeCode
         tlvalue = CecilHelper.GetType(Compiler, lvalue)
         clvalue = Helper.GetTypeCode(Compiler, tlvalue)
 
         Select Case clvalue
             Case TypeCode.Byte
                 m_ConstantValue = CByte(lvalue) << shifts
             Case TypeCode.SByte
                 m_ConstantValue = CSByte(lvalue) << shifts
             Case TypeCode.Int16
                 m_ConstantValue = CShort(lvalue) << shifts
             Case TypeCode.UInt16
                 m_ConstantValue = CUShort(lvalue) << shifts
             Case TypeCode.Int32
                 m_ConstantValue = CInt(lvalue) << shifts
             Case TypeCode.UInt32
                 m_ConstantValue = CUInt(lvalue) << shifts
             Case TypeCode.Int64
                 m_ConstantValue = CLng(lvalue) << shifts
             Case TypeCode.UInt64
                 m_ConstantValue = CULng(lvalue) << shifts
             Case Else
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeConverter.vb" startline="1139" endline="1182">
<![CDATA[
 
     Public Shared Function ConvertToDecimal(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object, ByVal ShowErrors As Boolean) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CDec(i)
                 Return True
             Case TypeCode.Char
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Char", "Decimal")
             Case TypeCode.DateTime
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", "Decimal")
             Case TypeCode.Decimal
                 result = Source
                 Return True
             Case TypeCode.Double
                 Dim i As Double = DirectCast(Source, Double)
                 If i >= Decimal.MinValue AndAlso i <= Decimal.MaxValue Then
                     result = CDec(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 result = CDec(CLng(Source))
                 Return True
             Case TypeCode.Single
                 Dim i As Single = DirectCast(Source, Single)
                 If i >= Decimal.MinValue AndAlso i <= Decimal.MaxValue Then
                     result = CDec(i)
                     Return True
                 End If
             Case TypeCode.String
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "String", "Decimal")
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 result = CDec(CULng(Source))
                 Return True
             Case TypeCode.DBNull
                 result = 0D
                 Return True
         End Select
         If ShowErrors = False Then Return False
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "Decimal")
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\MainForm.cs" startline="52" endline="66">
<![CDATA[
 
 		/// <summary>
 		/// Clean up any resources being used.
 		/// </summary>
 		protected override void Dispose( bool disposing )
 		{
 			if( disposing )
 			{
 				if (components != null) 
 				{
 					components.Dispose();
 				}
 			}
 			base.Dispose( disposing );
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\ExternalSubDeclaration.vb" startline="95" endline="133">
<![CDATA[
 
     Public Overrides Function ResolveMember(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveMember(Info) AndAlso result
 
         Dim attrib As New Attribute(Me)
         attrib.ResolvedType = Compiler.TypeCache.System_Runtime_InteropServices_DllImportAttribute
         attrib.AttributeArguments.PositionalArgumentList.Add(m_LibraryClause.StringLiteral.StringLiteral)
         If m_AliasClause IsNot Nothing Then
             attrib.AttributeArguments.VariablePropertyInitializerList.Add("EntryPoint", m_AliasClause.StringLiteral.LiteralValue)
         Else
             attrib.AttributeArguments.VariablePropertyInitializerList.Add("EntryPoint", Name)
         End If
         attrib.AttributeArguments.VariablePropertyInitializerList.Add("SetLastError", True)
         attrib.AttributeArguments.VariablePropertyInitializerList.Add("PreserveSig", True)
         Select Case m_CharsetModifier
             Case KS.Auto
                 attrib.AttributeArguments.VariablePropertyInitializerList.Add("CharSet", System.Runtime.InteropServices.CharSet.Auto)
             Case KS.Unicode
                 attrib.AttributeArguments.VariablePropertyInitializerList.Add("CharSet", System.Runtime.InteropServices.CharSet.Unicode)
             Case KS.Ansi, KS.None
                 attrib.AttributeArguments.VariablePropertyInitializerList.Add("CharSet", System.Runtime.InteropServices.CharSet.Ansi)
             Case Else
                 Throw New InternalException
         End Select
         Me.AddCustomAttribute(attrib)
 
         For i As Integer = 0 To Signature.Parameters.Count - 1
             If Helper.CompareType(Signature.Parameters(i).ParameterType, Compiler.TypeCache.System_String) AndAlso Signature.Parameters(i).CustomAttributes.Count = 0 Then
                 Signature.Parameters(i).ParameterType = New ByReferenceType(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_String))
                 Signature.Parameters(i).CecilBuilder.MarshalInfo = New Mono.Cecil.MarshalInfo(Mono.Cecil.NativeType.ByValStr)
                 Signature.Parameters(i).CecilBuilder.Attributes = Signature.Parameters(i).CecilBuilder.Attributes Or Mono.Cecil.ParameterAttributes.HasFieldMarshal
             End If
         Next
 
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2142" endline="2151">
<![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     <Diagnostics.Conditional("DEBUG")> _
     Shared Sub Assert(ByVal Condition As Boolean, ByVal Message As String)
         If Condition = False Then
             Diagnostics.Debug.WriteLine(Message)
             If SharedCompiler IsNot Nothing Then SharedCompiler.Report.WriteLine(Report.ReportLevels.Debug, Message)
         End If
         Assert(Condition)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="155" endline="166">
<![CDATA[
 
     Private Sub LnkDiagnostics_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles LnkDiagnostics.Click, BtnDiagnostics.Click, LblDiagnostics_Status.Click
 
         If User_Profile() = False Then
             If FrmUsrProfile.ShowDialog(Me) = Windows.Forms.DialogResult.OK Then
                 FrmDiagnostics.ShowDialog(Me)
             End If
         ElseIf User_Profile() = True Then
             FrmDiagnostics.ShowDialog(Me)
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" startline="79" endline="103">
<![CDATA[
 
     Private Function CreateRemoveHandlerCode(ByVal Info As EmitInfo) As Boolean
         If Me.IsShared = False Then
             With Info.ILGen
                 .Emit(OpCodes.Ldarg_0)
                 .Emit(OpCodes.Ldarg_0)
                 .Emit(OpCodes.Ldfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ldarg_1)
                 .EmitCall(OpCodes.Call, Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Delegate__Remove), Nothing)
                 .Emit(OpCodes.Castclass, Helper.GetTypeOrTypeBuilder(Compiler, [EventParent].EventType))
                 .Emit(OpCodes.Stfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ret)
             End With
         Else
             With Info.ILGen
                 .Emit(OpCodes.Ldsfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ldarg_0)
                 .EmitCall(OpCodes.Call, Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Delegate__Remove), Nothing)
                 .Emit(OpCodes.Castclass, Helper.GetTypeOrTypeBuilder(Compiler, [EventParent].EventType))
                 .Emit(OpCodes.Stsfld, Helper.GetFieldOrFieldBuilder(Compiler, [EventParent].EventField))
                 .Emit(OpCodes.Ret)
             End With
         End If
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Compiler.vb" startline="793" endline="855">
<![CDATA[
 
     Private Function AddResources() As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To CommandLine.Resources.Count - 1
             Dim r As Resource = CommandLine.Resources(i)
             Dim resourceDescription As String = ""
             Dim resourceFile As String = IO.Path.GetFileName(r.Filename)
             Dim resourceName As String = IO.Path.GetFileName(r.Filename)
             Dim attrib As System.Reflection.ResourceAttributes
 
             If r.Identifier <> String.Empty Then
                 resourceName = r.Identifier
             Else
                 resourceName = IO.Path.GetFileName(r.Filename)
             End If
 
             If r.Public Then
                 attrib = System.Reflection.ResourceAttributes.Public
             Else
                 attrib = System.Reflection.ResourceAttributes.Private
             End If
 
             Dim reader As System.Resources.IResourceReader
             Select Case IO.Path.GetExtension(r.Filename).ToLowerInvariant
                 Case ".resx"
                     reader = Nothing 'New System.Resources.ResXResourceReader(r.Filename)
                 Case ".resources"
                     Try
                         reader = New System.Resources.ResourceReader(r.Filename)
                     Catch ex As Exception
                         result = Compiler.Report.ShowMessage(Messages.VBNC31509, Span.CommandLineSpan, r.Filename, ex.Message) AndAlso result
                         Continue For
                     End Try
                 Case Else
                     reader = Nothing
             End Select
 
             'Report.WriteLine("Defining resource, FileName=" & r.Filename & ", Identifier=" & r.Identifier & ", reader is nothing=" & (reader Is Nothing).ToString())
             If reader IsNot Nothing Then
                 Dim cecilStream As New IO.MemoryStream()
                 Dim cecilWriter As New System.Resources.ResourceWriter(cecilStream)
 
                 For Each resource As System.Collections.DictionaryEntry In reader
                     'Report.WriteLine(">" & resource.Key.ToString & "=" & resource.Value.ToString)
                     cecilWriter.AddResource(resource.Key.ToString, resource.Value)
                 Next
                 reader.Dispose()
                 cecilWriter.Generate()
 
                 Dim cecilResource As New Mono.Cecil.EmbeddedResource(resourceName, Mono.Cecil.ManifestResourceAttributes.Public, cecilStream.ToArray()) 'FIXME
 
                 AssemblyBuilderCecil.MainModule.Resources.Add(cecilResource)
                 cecilWriter.Dispose()
                 cecilStream.Dispose()
             Else
                 'Report.WriteLine(">Writing ManifestResource")
                 'ModuleBuilder.DefineManifestResource(resourceName, New IO.FileStream(r.Filename, IO.FileMode.Open, IO.FileAccess.Read, IO.FileShare.Read), attrib)
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Compiler.vb" startline="594" endline="641">
<![CDATA[
 
     Sub ShowExceptionInfo(ByVal ex As Exception)
 #If DEBUG Then
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "-------------------------------------------------------------------------------------------------------------------------")
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Unhandled exception(" & ex.GetType.ToString & ")
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, ex.StackTrace)
         If ex.InnerException Is Nothing Then
             Compiler.Report.WriteLine("InnerException
         Else
             Compiler.Report.WriteLine("InnerException
         End If
         If ex.GetBaseException Is Nothing Then
             Compiler.Report.WriteLine("GetBaseException
         ElseIf ex IsNot ex.GetBaseException Then
             Compiler.Report.WriteLine("GetBaseException
         End If
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Data.Count
         'Find the line which caused the exception
         Dim strLines(), strLine As String
         If ex.StackTrace IsNot Nothing Then
             strLines = ex.StackTrace.Split(New Char() {VB.Chr(13), VB.Chr(10)}, StringSplitOptions.RemoveEmptyEntries)
             For i As Integer = 0 To strLines.GetUpperBound(0)
                 strLine = strLines(i)
                 'Remove -at-
                 strLine = strLine.Substring(strLine.IndexOf("en ") + 3)
                 If strLine.StartsWith("vbnc.", True, Nothing) OrElse strLine.Contains("Cecil") Then
                     strLine = strLine.Substring(strLine.IndexOf(" en ") + 4)
                     strLine = strLine.Replace("
                     strLine = strLine.Replace("
                     strLine &= ")
                     Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, strLine)
                 End If
             Next
         End If
 
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Commandline arguments
         Compiler.Report.Indent()
         For Each arg As String In CommandLine.AllArguments
             If arg.EndsWith(".vb") = False Then
                 Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, arg)
             End If
         Next
         Compiler.Report.Unindent()
         Compiler.Report.WriteLine(ex.Message)
 #Else
         Compiler.Report.ShowMessage(Messages.VBNC99999, Span.CommandLineSpan, "Unexpected error
 #End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CObjExpression.vb" startline="479" endline="511">
<![CDATA[
 
     Public Function FindUserDefinedConversionOperator(Optional ByVal ShowNoOperatorsError As Boolean = True) As Boolean
         Dim result As Boolean = True
         Dim expType As TypeReference = Expression.ExpressionType
         Dim destinationType As TypeReference = Me.ExpressionType
         Dim ops As Generic.List(Of MethodReference)
         Dim isNarrowing As Boolean
 
         ops = Helper.GetWideningConversionOperators(Compiler, expType, destinationType)
 
         If ops Is Nothing OrElse ops.Count = 0 Then
             ops = Helper.GetNarrowingConversionOperators(Compiler, expType, destinationType)
             isNarrowing = True
         End If
 
         If ops Is Nothing OrElse ops.Count = 0 Then
             If ShowNoOperatorsError = False Then Return True
             If CecilHelper.IsNullable(expType) AndAlso CecilHelper.IsNullable(destinationType) AndAlso Compiler.TypeResolver.IsExplicitlyConvertible(Compiler, Helper.GetTypeCode(Compiler, CecilHelper.GetNulledType(expType)), Helper.GetTypeCode(Compiler, CecilHelper.GetNulledType(destinationType))) Then
                 Return Compiler.Report.ShowMessage(Messages.VBNC30512, Expression.Location, Helper.ToString(Me, expType), Helper.ToString(Me, ExpressionType))
             End If
             Return Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Me, expType), Helper.ToString(Me, ExpressionType))
         End If
 
         If ops.Count > 1 Then Return Compiler.Report.ShowMessage(Messages.VBNC30311, Me.Location, Helper.ToString(Me, expType), Helper.ToString(Me, ExpressionType))
 
         If isNarrowing AndAlso IsExplicit = False AndAlso Location.File(Compiler).IsOptionStrictOn Then
             result = Compiler.Report.ShowMessage(Messages.VBNC30512, Me.Location, Helper.ToString(Me, expType), Helper.ToString(Me, ExpressionType)) AndAlso result
         End If
 
         ConversionMethod = ops(0)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="766" endline="822">
<![CDATA[
 
 #End Region
 
 #Region "Services Profiles"
 
     Private Function ApplyProfile() As Boolean
 
         If GameMode() = False Then
 
             If MessageBox.Show("Are you sure you want to apply the selected services profile?", "Vista Services Optimizer", MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button2, 0, False) = Windows.Forms.DialogResult.Yes Then
 
                 If File.Exists(My.Application.CommandLineArgs(0).ToString) = False Then
                     MessageBox.Show("The selected services profile is missing or corrupted.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
                     ApplyProfile = False
                     Exit Function
                 End If
 
                 Dim Reader As New StreamReader(My.Application.CommandLineArgs(0).ToString)
                 Dim Info As String = Reader.ReadToEnd
                 Reader.Close()
 
                 Dim Profile_Info() As String = Info.Split(CChar("!"))
                 UBound(Profile_Info)
 
                 If Not Profile_Info(0).Trim = "1.2" Then
                     MessageBox.Show("The selected services profile is not compatible with" & vbCrLf & "this version of Vista Services Optimizer.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
                     ApplyProfile = False
                     Exit Function
                 End If
 
                 Try
                     Dim ChkProfile As String = Profile_Info(38).Trim
                     BWProfiles.RunWorkerAsync()
                     Try
                         FrmProgress.PicProgress.Image = New Bitmap(DataDir & "services_profiles.png")
                     Catch ex As ArgumentException
                     End Try
                     FrmProgress.LblProgress.Text = "Applying services profile, Please wait..."
                     FrmProgress.ShowDialog(Me)
                 Catch ex As IndexOutOfRangeException
                     MessageBox.Show("The selected services profile is corrupted and can not be used.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
                     ApplyProfile = False
                     Exit Function
                 End Try
 
             Else
                 ApplyProfile = False
                 Exit Function
             End If
 
         ElseIf GameMode() = True Then
             MessageBox.Show("Applying services profiles can not be performed during Gaming Mode.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Information, MessageBoxDefaultButton.Button1, 0, False)
             ApplyProfile = False
             Exit Function
         End If
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1978" endline="1985">
<![CDATA[
 
     Shared Function CreateGenericTypename(ByVal Typename As String, ByVal TypeArgumentCount As Integer) As String
         If TypeArgumentCount = 0 Then
             Return Typename
         Else
             Return String.Concat(Typename, "`", TypeArgumentCount.ToString)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\ASFhandler.vb" startline="10" endline="27">
<![CDATA[
 
     Public Overrides ReadOnly Property Extension(Optional ByVal _
         LongForm As Boolean = False) As String
         Get
             If LongForm Then
                 If mIsAudio Then
                     Return "Windows Audio files"
                 Else
                     Return "Windows Media Files"
                 End If
             Else
                 If mIsAudio Then
                     Return ".wma"
                 Else
                     Return ".wmv"
                 End If
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\MPGhandler.vb" startline="8" endline="25">
<![CDATA[
 
     Public Overrides ReadOnly Property Extension(Optional ByVal _
         LongForm As Boolean = False) As String
         Get
             If LongForm Then
                 If mIsAudio Then
                     Return "MP3 Files"
                 Else
                     Return "MPEG Files"
                 End If
             Else
                 If mIsAudio Then
                     Return ".mp3"
                 Else
                     Return ".mpg"
                 End If
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Infos\ExpressionResolveInfo.vb" startline="32" endline="38">
<![CDATA[
     Shared Function [Default](ByVal Compiler As Compiler) As ResolveInfo
         If DefaultInfo Is Nothing OrElse Compiler Is DefaultInfo.Compiler = False Then
             DefaultInfo = New ResolveInfo(Compiler)
         End If
 
         Return DefaultInfo
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\AVIhandler.vb" startline="9" endline="18">
<![CDATA[
 
     Public Overrides ReadOnly Property Extension(Optional ByVal _
     LongForm As Boolean = False) As String
         Get
             If LongForm Then
                 Return "AVI files"
             Else
                 Return ".avi"
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\dshowUtil.vb" startline="22" endline="31">
<![CDATA[
 
     Public Overrides ReadOnly Property Extension(Optional ByVal _
         LongForm As Boolean = False) As String
         Get
             If LongForm Then
                 Return "Flash movies"
             Else
                 Return ".flv"
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\RMhandler.vb" startline="10" endline="19">
<![CDATA[
 
     Public Overrides ReadOnly Property Extension(Optional ByVal _
         LongForm As Boolean = False) As String
         Get
             If LongForm Then
                 Return "Real Media movies"
             Else
                 Return ".rm"
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="1222" endline="1236">
<![CDATA[
 
     Private Function ExtractLong(ByVal Value As ULong, ByVal Base As IntegerBase) As Long
         Select Case Base
             Case IntegerBase.Decimal
                 Return CLng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Long.MaxValue Then
                     Return CLng(Long.MinValue + (Value - Long.MaxValue - 1))
                 Else
                     Return CLng(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="345" endline="357">
<![CDATA[
 
     ''' <summary>
     ''' Emit a newobj.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Constructor"></param>
     ''' <remarks></remarks>
     Shared Sub EmitNew(ByVal Info As EmitInfo, ByVal Constructor As Mono.Cecil.MethodReference)
         Dim vOriginalConstructor As Mono.Cecil.MethodReference = Constructor
         Helper.Assert(Constructor IsNot Nothing)
         Constructor = CecilHelper.MakeEmittable(Constructor)
         Info.ILGen.Emit(OpCodes.Newobj, Constructor)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\Main.vb" startline="77" endline="87">
<![CDATA[
 
     Public Function ExtSupported(ByVal SelectedFormat As Format, _
         ByVal Extension As String) As Boolean
 
         If Array.IndexOf(SelectedFormat.Extensions, Extension) > -1 Then
             Return True
         Else
             Return False
         End If
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3043" endline="3089">
<![CDATA[
 
     Private Function FindLikeFiles(ByVal Filename As String) As String()
 
         Dim Temp As String()
         Dim fi As New FileInfo(Filename)
         Dim di As DirectoryInfo = fi.Directory
 
         Dim Template As String = fi.Name
         Template = Template.Remove(Template.Length - fi.Extension.Length, _
             fi.Extension.Length)
 
         Dim Started As Boolean, CharVal As Integer
         For i As Integer = Template.Length - 1 To 0 Step -1
             CharVal = Asc(Template.Chars(i))
             If (CharVal < 58) AndAlso (CharVal > 47) Then
                 Started = True
             End If
             If Started Then
                 If (CharVal > 57) Or (CharVal < 48) Then
                     Template = Template.Remove(i, Template.Length - i)
                     Exit For
                 End If
             End If
         Next
 
         Dim mfi As FileInfo, mfis As FileInfo()
         mfis = di.GetFiles(Template + "*")
         Dim MediaGrp As MediaTypes.Format = mTypes.FindFormat(fi.Extension)
 
         Dim j As Integer
         If mfis.Length > 1 Then
             ReDim Temp(mfis.Length - 2)
             For Each mfi In mfis
                 If mfi.FullName <> Filename Then
                     If mTypes.ExtSupported(MediaGrp, mfi.Extension) Then
                         Temp(j) = mfi.FullName
                         j += 1
                     End If
                 End If
             Next
         End If
 
         If j > 0 Then ReDim Preserve Temp(j - 1)
 
         Return Temp
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\MethodGroupToValueExpression.vb" startline="23" endline="30">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Info.DesiredType IsNot Nothing)
         Emitter.EmitLoadNull(Info)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="306" endline="312">
<![CDATA[
 
     Shared Function FindAssembly(ByVal member As Mono.Cecil.MemberReference) As Mono.Cecil.AssemblyDefinition
         Helper.Assert(member IsNot Nothing)
         Dim type As Mono.Cecil.TypeReference = TryCast(member, Mono.Cecil.TypeReference)
         If type IsNot Nothing Then Return FindAssembly(type)
         Return FindAssembly(member.DeclaringType)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="262" endline="271">
<![CDATA[
     End Property
 
     Function IsLiteral() As Boolean
         Select Case m_TokenType
             Case TokenType.DateLiteral, TokenType.CharLiteral, TokenType.DecimalLiteral, TokenType.DoubleLiteral, TokenType.Int16Literal, TokenType.Int32Literal, TokenType.Int64Literal, TokenType.SingleLiteral, TokenType.StringLiteral, TokenType.UInt16Literal, TokenType.UInt32Literal, TokenType.UInt64Literal
                 Return True
             Case Else
                 Return False
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="282" endline="290">
<![CDATA[
 
     Function IsIntegerLiteral() As Boolean
         Select Case m_TokenType
             Case TokenType.Int16Literal, TokenType.Int32Literal, TokenType.Int64Literal, TokenType.UInt16Literal, TokenType.UInt32Literal, TokenType.UInt64Literal
                 Return True
             Case Else
                 Return False
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="408" endline="421">
<![CDATA[
 
     ReadOnly Property UpmostBlock() As CodeBlock
         Get
             Dim result As CodeBlock = Nothing
             Dim tmp As CodeBlock
 
             tmp = Me
             Do Until tmp Is Nothing
                 result = tmp
                 tmp = tmp.FindFirstParent(Of CodeBlock)()
             Loop
             Do Until tmp Is Nothing
                 result = tmp
                 tmp = tmp.FindFirstParent(Of CodeBlock)()
             Loop
 
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="645" endline="656">
<![CDATA[
 
     Private Function IsCombiningCharacter(ByVal chr As Char) As Boolean
         'CombiningCharacter 
         Select Case Char.GetUnicodeCategory(chr)
             Case Globalization.UnicodeCategory.NonSpacingMark 'Mn
                 Return True
             Case Globalization.UnicodeCategory.SpacingCombiningMark 'Mc
                 Return True
             Case Else
                 Return False
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2212" endline="2220">
<![CDATA[
 
     Shared Function IsDebugging() As Boolean
         'Return False
         If Diagnostics.Debugger.IsAttached = False Then Return False
         If Reflection.Assembly.GetEntryAssembly Is Nothing Then Return False
         If Reflection.Assembly.GetEntryAssembly.FullName.Contains("rt") Then Return False
         If AppDomain.CurrentDomain.FriendlyName.Contains("rt") Then Return False
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\BaseObject.vb" startline="165" endline="176">
<![CDATA[
 
     Function FindFirstParent(Of T1, T2)() As IBaseObject
         If Parent Is Nothing Then
             Return Nothing
         ElseIf TypeOf Parent Is T1 Then
             Return CType(CObj(Parent), IBaseObject)
         ElseIf TypeOf Parent Is T2 Then
             Return CType(CObj(Parent), IBaseObject)
         Else
             Return Parent.FindFirstParent(Of T1, T2)()
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\ImportsClause.vb" startline="68" endline="77">
<![CDATA[
     End Property
 
     Public Property Name() As String Implements INameable.Name
         Get
             If Me.IsAliasClause Then
                 Return Me.AsAliasClause.Name
             Else
                 Return ""
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="108" endline="114">
<![CDATA[
 
     Sub Write(Optional ByVal Value As String = "")
         For Each d As Diagnostics.TraceListener In m_Listeners
             d.Write(Value)
         Next
         Console.Write(Value)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeParameterConstraints.vb" startline="36" endline="53">
<![CDATA[
 
     ''' <summary>
     ''' Might very well be nothing.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function ClassConstraint() As Mono.Cecil.TypeReference
         Dim result As Mono.Cecil.TypeReference = Nothing
         For Each constraint As Constraint In m_ConstraintList
             If constraint.Special = KS.None Then
                 If CecilHelper.IsClass(constraint.TypeName.ResolvedType) Then
                     Helper.Assert(result Is Nothing)
                     result = constraint.TypeName.ResolvedType
                 End If
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\AbstractMediaHandler.vb" startline="44" endline="62">
<![CDATA[
     End Property
 
     Private Sub FromXML(ByVal Node As Xml.XmlNode)
         Dim a As ToolSpec
         For Each Tool As XmlNode In Node.SelectNodes("Tool")
             With Tool
                 a = New ToolSpec
                 a.DisplayName = .SelectSingleNode("DisplayName").InnerText
                 a.Desc = .SelectSingleNode("Desc").InnerText
                 a.Path.Value = .SelectSingleNode("Path").InnerText
                 a.Path.Name = .SelectSingleNode("Path").Attributes("Name").InnerText
                 a.Path.Required = (.SelectSingleNode("Path").Attributes("Reqd").InnerText = "yes")
                 a.URL = .SelectSingleNode("URL").InnerText
                 a.Filter = .SelectSingleNode("Filter").InnerText
                 a.Extensions = .SelectSingleNode("Extensions").InnerText
                 mList.Add(a)
             End With
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="426" endline="446">
<![CDATA[
 
     Function IsImplicitlyConvertible(ByVal Context As BaseObject, ByVal FromType As Mono.Cecil.TypeReference, ByVal ToType As Mono.Cecil.TypeReference) As Boolean
         Dim Compiler As Compiler = Context.Compiler
         Dim tpFrom, tpTo As TypeCode
         If Helper.CompareType(Compiler.TypeCache.Nothing, FromType) Then Return True
         If CecilHelper.IsByRef(FromType) Then FromType = CecilHelper.GetElementType(FromType)
         If CecilHelper.IsByRef(ToType) Then ToType = CecilHelper.GetElementType(ToType)
         If CecilHelper.IsNullable(FromType) Then FromType = CecilHelper.GetNulledType(FromType)
         If CecilHelper.IsNullable(ToType) Then ToType = CecilHelper.GetNulledType(ToType)
         tpFrom = Helper.GetTypeCode(Compiler, FromType)
         tpTo = Helper.GetTypeCode(Compiler, ToType)
         If tpTo = TypeCode.Object Then
             Return Helper.IsAssignable(Context, FromType, ToType) ' ToType.IsAssignableFrom(FromType)
         ElseIf Helper.IsEnum(Compiler, ToType) AndAlso Helper.IsEnum(Compiler, FromType) = False Then
             Return False
         ElseIf Helper.IsEnum(Compiler, ToType) AndAlso Helper.IsEnum(Compiler, FromType) Then
             Return Helper.CompareType(ToType, FromType)
         Else
             Return IsImplicitlyConvertible(Compiler, tpFrom, tpTo)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1416" endline="1422">
<![CDATA[
 
     Shared Function GetReturnType(ByVal Member As MemberReference) As TypeReference
         Dim mr As MethodReference = TryCast(Member, MethodReference)
         If mr IsNot Nothing Then Return mr.ReturnType
 
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="858" endline="864">
<![CDATA[
 
     Public Shared Function GetAttributeCtorString(ByVal Attrib As CustomAttribute, ByVal index As Integer) As String
         Dim result As String
         If Attrib.ConstructorArguments.Count - 1 < index Then Return Nothing
         result = TryCast(Attrib.ConstructorArguments(index).Value, String)
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="67" endline="76">
<![CDATA[
     End Property
 
     ReadOnly Property MemberDeclarations() As Generic.List(Of Mono.Cecil.MemberReference)
         Get
             Dim result As New Generic.List(Of Mono.Cecil.MemberReference)
             For Each member As IMember In Me
                 result.Add(member.MemberDescriptor)
             Next
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MemberCache.vb" startline="586" endline="593">
<![CDATA[
 
     Function GetAllMembers() As Generic.List(Of Mono.Cecil.MemberReference)
         Dim result As New Generic.List(Of Mono.Cecil.MemberReference)
         For Each item As MemberCacheEntry In Me.Values
             result.AddRange(item.Members)
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\AssignStatements\MidAssignStatement.vb" startline="55" endline="92">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(m_Target.Classification.IsVariableClassification OrElse m_Target.Classification.IsPropertyAccessClassification)
         Helper.Assert(m_Start.Classification.CanBeValueClassification)
         Helper.Assert(m_Length Is Nothing OrElse m_Length.Classification.CanBeValueClassification)
         Helper.Assert(m_Source.Classification.CanBeValueClassification)
 
         Dim tmpLocal As Mono.Cecil.Cil.VariableDefinition = Nothing
         If m_Target.Classification.IsPropertyAccessClassification Then
             tmpLocal = Emitter.DeclareLocal(Info, Compiler.TypeCache.System_String, "MidTmp" & ObjectID.ToString)
             result = m_Target.GenerateCode(Info.Clone(Me, True, False, tmpLocal.VariableType)) AndAlso result
             Emitter.EmitStoreVariable(Info, tmpLocal)
             Emitter.EmitLoadVariableLocation(Info, tmpLocal)
         Else
             result = m_Target.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_String_ByRef)) AndAlso result
         End If
 
         result = m_Start.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Int32)) AndAlso result
         Emitter.EmitConversion(m_Start.ExpressionType, Compiler.TypeCache.System_Int32, Info)
         If m_Length IsNot Nothing Then
             result = m_Length.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Int32)) AndAlso result
             Emitter.EmitConversion(m_Length.ExpressionType, Compiler.TypeCache.System_Int32, Info)
         Else
             Emitter.EmitLoadI4Value(Info, Integer.MaxValue)
         End If
         result = m_Source.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_String)) AndAlso result
         Emitter.EmitConversion(m_Source.ExpressionType, Compiler.TypeCache.System_String, Info)
 
         Emitter.EmitCallOrCallVirt(Info, Compiler.TypeCache.MS_VB_CS_StringType__MidStmtStr_String_Int32_Int32_String)
 
         If m_Target.Classification.IsPropertyAccessClassification Then
             result = m_Target.GenerateCode(Info.Clone(Me, New LoadLocalExpression(Me, tmpLocal))) AndAlso result
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4268" endline="4349">
<![CDATA[
 
 
     ''' <summary>
     ''' BinaryOperatorDeclaration  
     '''	[  Attributes  ]  [  OperatorModifier+  ]  "Operator"  OverloadableBinaryOperator
     '''		"("  Operand  ","  Operand  ")"  [ "As"  [  Attributes  ]  TypeName  ]  LineTerminator
     '''	[  Block  ]
     '''	"End" "Operator" StatementTerminator
     ''' 
     ''' UnaryOperatorDeclaration  
     '''	[  Attributes  ]  [  OperatorModifier+  ]  "Operator" OverloadableUnaryOperator 
     '''     "("  Operand  ")" 		[  "As" [  Attributes  ]  TypeName  ]  LineTerminator
     '''	[  Block  ]
     '''	"End" "Operator" StatementTerminator
     ''' OverloadableUnaryOperator  
     ''' </summary>
     ''' <remarks></remarks>
 
     Private Function ParseOperatorDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As OperatorDeclaration
         Dim result As New OperatorDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_OperatorSymbol As KS
         Dim m_OperatorIdentifier As String = Nothing
         Dim m_Operand1 As Operand
         Dim m_Operand2 As Operand
         Dim m_TypeName As TypeName
         Dim m_ReturnTypeAttributes As Attributes = Nothing
         Dim m_Block As CodeBlock
 
         m_Modifiers = ParseModifiers(ModifierMasks.OperatorModifiers)
 
         tm.AcceptIfNotInternalError(KS.Operator)
 
         If vbnc.OperatorDeclaration.IsOverloadableOperator(tm.CurrentToken) Then
             If tm.CurrentToken.IsIdentifier Then
                 m_OperatorIdentifier = DirectCast(tm.Reader.TokenData, String)
             Else
                 m_OperatorSymbol = tm.CurrentToken.Symbol
             End If
             tm.NextToken()
         Else
             Throw New InternalException(result)
         End If
 
         If tm.AcceptIfNotError(KS.LParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Operand1 = ParseOperand(result)
         If m_Operand1 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.Comma) Then
             m_Operand2 = ParseOperand(result)
             If m_Operand2 Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Operand2 = Nothing
         End If
 
         If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(result, m_ReturnTypeAttributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
             m_TypeName = ParseTypeName(result)
             If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeName = Nothing
         End If
 
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         m_Block = ParseCodeBlock(result, False)
         If m_Block Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Operator) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_OperatorIdentifier, m_OperatorSymbol, m_Operand1, m_Operand2, m_ReturnTypeAttributes, m_TypeName, m_Block)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" startline="169" endline="228">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = m_ParametersOrType.ResolveTypeReferences AndAlso result
 
         If ImplementsClause IsNot Nothing AndAlso ImplementsClause.ImplementsList.Count > 0 Then
             Dim ism As InterfaceMemberSpecifier
             ism = ImplementsClause.ImplementsList(0)
 
             Helper.Assert(ImplementsClause.ImplementsList.Count = 1)
             Helper.Assert(ism IsNot Nothing)
 
             result = ism.ResolveEarly() AndAlso result
 
             If result = False Then Return result
 
             Helper.Assert(ism.ResolvedEventInfo IsNot Nothing)
 
             Dim eD As Mono.Cecil.EventDefinition = CecilHelper.FindDefinition(ism.ResolvedEventInfo)
 
             If eD IsNot Nothing Then
                 If eD.EventType Is Nothing Then
                     Dim red As RegularEventDeclaration = TryCast(eD.Annotations(Compiler), RegularEventDeclaration)
                     If red IsNot Nothing Then
                         result = red.ResolveTypeReferences AndAlso result
                     End If
                 End If
                 Helper.Assert(eD.EventType IsNot Nothing)
                 EventType = eD.EventType
             Else
                 EventType = ism.ResolvedEventInfo.EventType
             End If
             If m_Variable IsNot Nothing AndAlso m_Variable.VariableType Is Nothing Then
                 m_Variable.VariableType = EventType
             End If
         End If
 
         If EventType IsNot Nothing Then
             'Nothing to do
         ElseIf Type IsNot Nothing Then
             Helper.Assert(EventType Is Nothing)
             EventType = Type.ResolvedType
             If Not m_Variable Is Nothing Then
                 m_Variable.VariableType = EventType
             End If
         ElseIf Parameters IsNot Nothing Then
             Helper.Assert(EventType IsNot Nothing OrElse ImplementsClause IsNot Nothing)
         Else
             Throw New InternalException(Me)
         End If
 
         If m_ImplicitEventDelegate IsNot Nothing Then
             result = m_ImplicitEventDelegate.ResolveTypeReferences AndAlso result
         End If
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="4915" endline="4982">
<![CDATA[
 
     ''' <summary>
     ''' VariableDeclarator  
     '''  	VariableIdentifiers  [  As  [  New  ]  TypeName  [  (  ArgumentList  )  ]  ]  |
     '''     VariableIdentifier   [  As  TypeName  ]  [  =  VariableInitializer  ]
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseVariableDeclarator(ByVal Parent As ParsedObject, ByVal Modifiers As Modifiers, ByVal Info As ParseAttributableInfo, ByVal result As IList, ByVal local As Boolean) As Boolean
         Dim m_VariableIdentifiers As VariableIdentifiers
         Dim m_IsNew As Boolean
         Dim m_TypeName As TypeName
         Dim m_VariableInitializer As VariableInitializer
         Dim m_ArgumentList As ArgumentList
 
         m_VariableIdentifiers = ParseVariableIdentifiers(Parent)
         If m_VariableIdentifiers Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.Accept(KS.As) Then
             m_IsNew = tm.Accept(KS.[New])
             If m_IsNew Then
                 'Arrays not allowed.
                 Dim m_NonArrayTypeName As NonArrayTypeName
                 m_NonArrayTypeName = ParseNonArrayTypeName(Parent)
                 If m_NonArrayTypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 m_TypeName = New TypeName(Parent, m_NonArrayTypeName)
             Else
                 'Arrays allowed.
                 m_TypeName = ParseTypeName(Parent)
                 If m_TypeName Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
         Else
             m_TypeName = Nothing
         End If
 
         If tm.Accept(KS.Equals) Then
             tm.AcceptNewLine()
             m_VariableInitializer = ParseVariableInitializer(Parent)
             If m_VariableInitializer Is Nothing Then Compiler.Report.ShowMessage(Messages.VBNC30201, tm.CurrentLocation)
             m_ArgumentList = Nothing
         ElseIf tm.Accept(KS.LParenthesis) Then
             If tm.Accept(KS.RParenthesis) = False Then
                 m_ArgumentList = ParseArgumentList(Parent)
                 If m_ArgumentList Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 If tm.AcceptIfNotError(KS.RParenthesis) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 m_ArgumentList = New ArgumentList(Parent)
             End If
             m_VariableInitializer = Nothing
         Else
             m_VariableInitializer = Nothing
             m_ArgumentList = Nothing
         End If
 
         'result Dim result As New Generic.List(Of VariableDeclaration)
         For Each identifier As VariableIdentifier In m_VariableIdentifiers
             Dim varD As VariableDeclaration
             If local Then
                 varD = New LocalVariableDeclaration(Parent, Modifiers, identifier, m_IsNew, m_TypeName, m_VariableInitializer, m_ArgumentList)
             Else
                 varD = New TypeVariableDeclaration(Parent, Modifiers, identifier, m_IsNew, m_TypeName, m_VariableInitializer, m_ArgumentList)
             End If
             varD.Location = identifier.Location
             varD.CustomAttributes = Info.Attributes
             result.Add(varD)
         Next
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmProfiles.vb" startline="65" endline="131">
<![CDATA[
 
     Private Sub Check_Profiles()
 
         If Directory.Exists(ProfilesDir) = False Then
             Directory.CreateDirectory(ProfilesDir)
         End If
 
         LstProfiles.Items.Clear()
 
         Dim ProfilesDir_Info As New DirectoryInfo(ProfilesDir)
         Dim Profiles As FileInfo() = ProfilesDir_Info.GetFiles("*.wsp")
         Dim ProfileName As FileInfo
         For Each ProfileName In Profiles
 
             Dim Profile As New ListViewItem
             Profile.Text = Path.GetFileNameWithoutExtension(ProfileName.FullName)
             LstProfiles.Items.Add(Profile)
 
             Dim Reader As New StreamReader(ProfilesDir & ProfileName.Name)
             Dim Info = Reader.ReadToEnd
             Reader.Close()
 
             Dim Profile_Info() As String = Info.Split(CChar("!"))
             UBound(Profile_Info)
 
             Try
                 Dim Profile_Date As New ListViewItem
                 Profile_Date.Text = Profile_Info(2).Trim
                 Profile.SubItems.Add(Profile_Date.Text)
             Catch ex As IndexOutOfRangeException
             End Try
 
             Try
                 Dim Profile_Description As New ListViewItem
                 Profile_Description.Text = Profile_Info(1).Trim
                 Profile.SubItems.Add(Profile_Description.Text)
             Catch ex As IndexOutOfRangeException
             End Try
 
         Next
 
         Try
             LstProfiles.Items.Item(0).Selected = True
             BtnPreview.Enabled = ComponentFactory.Krypton.Toolkit.ButtonEnabled.True
             BtnApply.Enabled = ComponentFactory.Krypton.Toolkit.ButtonEnabled.True
             BtnValidate.Enabled = ComponentFactory.Krypton.Toolkit.ButtonEnabled.True
             BtnEdit.Enabled = ComponentFactory.Krypton.Toolkit.ButtonEnabled.True
             BtnDelete.Enabled = ComponentFactory.Krypton.Toolkit.ButtonEnabled.True
             ItmPreview.Enabled = True
             ItmApply.Enabled = True
             ItmValidate.Enabled = True
             ItmEdit.Enabled = True
             ItmDelete.Enabled = True
         Catch ex As ArgumentOutOfRangeException
             BtnPreview.Enabled = ComponentFactory.Krypton.Toolkit.ButtonEnabled.False
             BtnApply.Enabled = ComponentFactory.Krypton.Toolkit.ButtonEnabled.False
             BtnValidate.Enabled = ComponentFactory.Krypton.Toolkit.ButtonEnabled.False
             BtnEdit.Enabled = ComponentFactory.Krypton.Toolkit.ButtonEnabled.False
             BtnDelete.Enabled = ComponentFactory.Krypton.Toolkit.ButtonEnabled.False
             ItmPreview.Enabled = False
             ItmApply.Enabled = False
             ItmValidate.Enabled = False
             ItmEdit.Enabled = False
             ItmDelete.Enabled = False
         End Try
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="81" endline="117">
<![CDATA[
 
     Public Function IsConstantMethod(ByVal Method As Mono.Cecil.MethodReference, ByVal Parameter As Object, ByRef Result As Object) As Boolean
         If Method.DeclaringType.Namespace IsNot Nothing AndAlso Not CompareNameOrdinal(Method.DeclaringType.Namespace, "Microsoft.VisualBasic") Then Return False
         If Not CompareNameOrdinal(Method.DeclaringType.Name, "Strings") Then Return False
 
 #If EXTENDEDDEBUG Then
         Compiler.Report.WriteLine("IsConstantMethod
 #End If
         Dim isConstant As Boolean
         If IsMethod(Method, "Chr", Compiler.TypeCache.System_Int32, Compiler.TypeCache.System_Char) Then
             If TypeOf Parameter Is Integer = False Then Return False
             Dim intParam As Integer = CInt(Parameter)
             'CHECK
             isConstant = intParam >= 0 AndAlso intParam < 128
             If isConstant Then Result = Microsoft.VisualBasic.Strings.Chr(intParam)
         ElseIf IsMethod(Method, "ChrW", Compiler.TypeCache.System_Int32, Compiler.TypeCache.System_Char) Then
             Helper.Assert(TypeOf Parameter Is Integer)
             isConstant = True
             Result = Microsoft.VisualBasic.Strings.ChrW(CInt(Parameter))
         ElseIf IsMethod(Method, "Asc", Compiler.TypeCache.System_Char, Compiler.TypeCache.System_Int32) Then
             isConstant = TypeOf Parameter Is Char
             If isConstant Then Result = Microsoft.VisualBasic.Asc(CChar(Parameter))
         ElseIf IsMethod(Method, "AscW", Compiler.TypeCache.System_Char, Compiler.TypeCache.System_Int32) Then
             isConstant = TypeOf Parameter Is Char
             If isConstant Then Result = Microsoft.VisualBasic.AscW(CChar(Parameter))
         ElseIf IsMethod(Method, "Asc", Compiler.TypeCache.System_String, Compiler.TypeCache.System_Int32) Then
             isConstant = TypeOf Parameter Is String AndAlso CStr(Parameter) <> ""
             If isConstant Then Result = Microsoft.VisualBasic.Asc(CStr(Parameter))
         ElseIf IsMethod(Method, "AscW", Compiler.TypeCache.System_String, Compiler.TypeCache.System_Int32) Then
             isConstant = TypeOf Parameter Is String AndAlso CStr(Parameter) <> ""
             If isConstant Then Result = Microsoft.VisualBasic.AscW(CStr(Parameter))
         Else
             Return False
         End If
 
         Return isConstant
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="198" endline="248">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_LoopControlVariable.ResolveCode(Info) AndAlso result
         If m_LoopControlVariable.GetVariableDeclaration IsNot Nothing Then
             MyBase.CodeBlock.AddVariable(m_LoopControlVariable.GetVariableDeclaration)
         End If
 
         result = m_InExpression.ResolveExpression(Info) AndAlso result
         If result = False Then Return False
         result = Helper.VerifyValueClassification(m_InExpression, Info) AndAlso result
 
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         If m_NextExpression IsNot Nothing Then
             result = m_NextExpression.ResolveExpression(Info) AndAlso result
             If result = False Then Return False
 
             If m_NextExpression.Classification.IsVariableClassification Then
                 If m_LoopControlVariable.Expression IsNot Nothing Then
                     Dim lcvVar As VariableClassification = Nothing
                     Dim nextExpVar As VariableClassification = m_NextExpression.Classification.AsVariableClassification
 
                     If m_LoopControlVariable.Expression.Classification.IsVariableClassification Then
                         lcvVar = m_LoopControlVariable.Expression.Classification.AsVariableClassification
                     End If
 
                     If lcvVar IsNot Nothing AndAlso lcvVar.LocalVariable Is nextExpVar.LocalVariable Then
                         'OK
                     ElseIf lcvVar IsNot Nothing AndAlso lcvVar.ArrayVariable IsNot Nothing AndAlso lcvVar.ArrayVariable.Classification.IsVariableClassification AndAlso lcvVar.ArrayVariable.Classification.AsVariableClassification.LocalVariable Is nextExpVar.LocalVariable Then
                         'OK
                     Else
                         result = Compiler.Report.ShowMessage(Messages.VBNC30070, m_NextExpression.Location, m_LoopControlVariable.Identifier.Name)
                     End If
                 ElseIf m_NextExpression.Classification.AsVariableClassification.LocalVariable IsNot m_LoopControlVariable.GetVariableDeclaration Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30070, m_NextExpression.Location, m_LoopControlVariable.Identifier.Name)
                 End If
                 Else
                     result = Compiler.Report.ShowMessage(Messages.VBNC30070, m_NextExpression.Location, m_LoopControlVariable.Identifier.Name)
                 End If
             End If
 
             Compiler.Helper.AddCheck("It is not valid to branch into a For Each statement block from outside the block.")
             Compiler.Helper.AddCheck("The loop control variable is specified either through an identifier followed by an As clause or an expression. (...) In the case of an expression, the expression must be classified as a variable. ")
             Compiler.Helper.AddCheck("The enumerator expression must be classified as a value and its type must be a collection type or Object. ")
             Compiler.Helper.AddCheck("If the type of the enumerator expression is Object, then all processing is deferred until run-time. Otherwise, a conversion must exist from the element type of the collection to the type of the loop control variable")
             Compiler.Helper.AddCheck("The loop control variable cannot be used by another enclosing For Each statement. ")
 
             Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="153" endline="227">
<![CDATA[
 
     ''' <summary>
     ''' If there's anything to copy back, creates a boolean array with
     ''' - true if the value can be copied back (the argument is assignable, that is
     ''' Otherwise just loads a null value.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="LateBoundAccess"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Shared Function EmitCopyBacks(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification, ByRef copyBackHints As Boolean(), ByRef copyBacks As Mono.Cecil.Cil.VariableDefinition) As Boolean
         Dim result As Boolean = True
         Dim args As ArgumentList
 
         args = LateBoundAccess.Arguments
 
         If args Is Nothing OrElse args.Count = 0 Then
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_Boolean_Array))
         Else
             copyBackHints = New Boolean(args.Count - 1) {}
             copyBacks = Emitter.DeclareLocal(Info, Info.Compiler.TypeCache.System_Boolean_Array)
 
             Emitter.EmitLoadI4Value(Info, args.Count)
             Emitter.EmitNewArr(Info, Info.Compiler.TypeCache.System_Boolean)
             Emitter.EmitStoreVariable(Info, copyBacks)
             For i As Integer = 0 To args.Count - 1
                 Dim arg As Argument
                 Dim exp As Expression
                 Dim copyBack As Boolean
 
                 arg = args.Arguments(i)
                 exp = arg.Expression
 
                 Emitter.EmitLoadVariable(Info, copyBacks) ' Emitter.EmitDup(Info)
                 Emitter.EmitLoadI4Value(Info, i)
                 If exp Is Nothing Then
                     copyBack = False
                 Else
                     Select Case exp.Classification.Classification
                         Case ExpressionClassification.Classifications.Variable
                             Dim varC As VariableClassification = exp.Classification.AsVariableClassification
                             If varC.LocalBuilder IsNot Nothing Then
                                 copyBack = True
                             ElseIf varC.FieldInfo IsNot Nothing Then
                                 Dim fD As IFieldMember = TryCast(varC.FieldInfo.Annotations(Info.Compiler), IFieldMember)
                                 If fD IsNot Nothing Then
                                     'TODO
                                     copyBack = varC.FieldDefinition.IsLiteral = False AndAlso fD.Modifiers.Is(ModifierMasks.ReadOnly) = False
                                 Else
                                     copyBack = varC.FieldDefinition.IsLiteral = False
                                 End If
                             Else
                                 copyBack = False
                             End If
                         Case ExpressionClassification.Classifications.Value
                             copyBack = False
                         Case ExpressionClassification.Classifications.PropertyAccess
                             copyBack = CecilHelper.FindDefinition(exp.Classification.AsPropertyAccess.ResolvedProperty).SetMethod IsNot Nothing '.CanWrite
                         Case Else
                             Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, LateBoundAccess.Parent.Location)
                     End Select
                 End If
                 copyBackHints(i) = copyBack
                 If copyBack Then
                     Emitter.EmitLoadI4Value(Info, 1)
                 Else
                     Emitter.EmitLoadI4Value(Info, 0)
                 End If
                 Emitter.EmitStoreElement(Info, Info.Compiler.TypeCache.System_Boolean, Info.Compiler.TypeCache.System_Boolean_Array)
             Next
             Emitter.EmitLoadVariable(Info, copyBacks)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="568" endline="620">
<![CDATA[
 
     Public Function GetWidestType(ByVal tp1 As TypeReference, ByVal tp2 As TypeReference, ByVal tp3 As TypeReference) As TypeReference
         Dim cont1(), cont2(), cont3() As Mono.Cecil.TypeReference
 
         Helper.Assert(tp1 IsNot Nothing, "tp1 Is Nothing")
         Helper.Assert(tp2 IsNot Nothing, "tp2 Is Nothing")
 
         If tp1 Is tp2 Then
             If tp3 Is Nothing Then Return tp1
             If tp1 Is tp3 Then Return tp2
         End If
 
         Dim itp1, itp2, itp3 As Mono.Cecil.TypeReference
         itp1 = GetIntegralType(Compiler, tp1)
         itp2 = GetIntegralType(Compiler, tp2)
 
         cont1 = valCanBeContainBy(getTypeIndex(CType(TypeToKeyword(itp1), BuiltInDataTypes)))
         cont2 = valCanBeContainBy(getTypeIndex(CType(TypeToKeyword(itp2), BuiltInDataTypes)))
 
         If tp3 Is Nothing Then
             itp3 = Nothing
             cont3 = Nothing
         Else
             itp3 = GetIntegralType(Compiler, tp3)
             cont3 = valCanBeContainBy(getTypeIndex(CType(TypeToKeyword(itp3), BuiltInDataTypes)))
         End If
 
         If cont1 Is Nothing Or cont2 Is Nothing Then Return Nothing
 
         For i As Integer = 0 To cont1.Length - 1
             For j As Integer = 0 To cont2.Length - 1
                 If Not cont2(j) Is cont1(i) Then Continue For
 
                 If itp3 Is Nothing Then
                     'We've found a type that can contain both input types
                     If cont2(j) Is itp1 Then Return tp1
                     If cont2(j) Is itp2 Then Return tp2
                     'Continue looking, the type we want is neither of the two input types
                 Else
                     For k As Integer = 0 To cont3.Length - 1
                         If Not cont3(k) Is cont2(j) Then Continue For
                         'We've found a type that can contain all three input types
                         If cont3(k) Is itp1 Then Return tp1
                         If cont3(k) Is itp2 Then Return tp2
                         If cont3(k) Is itp3 Then Return tp3
                         'Continue looking, the type we want is neither of the three input types
                     Next
                 End If
             Next
         Next
 
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MemberCache.vb" startline="319" endline="384">
<![CDATA[
 
     Private Sub AddToCache(ByVal cache As MemberCacheEntry, ByVal Visibility As MemberVisibility, ByVal cache_entries As MemberCacheEntries)
         For i As Integer = 0 To cache.Members.Count - 1
             Dim member As Mono.Cecil.MemberReference = cache.Members(i)
             Dim isPublic, isFriend, isProtected, isPrivate As Boolean
             Dim isHidden As Boolean
             Dim cacheentry As MemberCacheEntry = Nothing
             Dim method As Mono.Cecil.MethodReference
 
             isHidden = False
             If m_ShadowedInterfaceMembers IsNot Nothing AndAlso m_ShadowedInterfaceMembers.Contains(member) Then
                 isHidden = True
             ElseIf Me.IsHidden(member, Visibility, cache.Members) Then
                 isHidden = True
                 If m_ShadowedInterfaceMembers IsNot Nothing Then m_ShadowedInterfaceMembers.Add(member)
             End If
 
             If isHidden Then Continue For
 
             isPublic = Helper.IsPublic(member)
             isPrivate = Helper.IsPrivate(member)
             isFriend = Helper.IsFriendOrProtectedFriend(member)
             isProtected = Helper.IsProtectedOrProtectedFriend(member)
 
             isHidden = True
             Select Case Visibility
                 Case MemberVisibility.All
                     isHidden = False
                 Case MemberVisibility.Public
                     isHidden = Not (isPublic)
                 Case MemberVisibility.PublicFriend
                     isHidden = Not (isPublic OrElse isFriend)
                 Case MemberVisibility.PublicProtected
                     isHidden = Not (isPublic OrElse isProtected)
                 Case MemberVisibility.PublicProtectedFriend
                     isHidden = Not (isPublic OrElse isProtected OrElse isFriend)
             End Select
 
             If isHidden Then Continue For
 
             If cache_entries.TryGetValue(cache.Name, cacheentry) = False Then
                 cache_entries.Add(New MemberCacheEntry(member))
             ElseIf cacheentry.Members.Contains(member) = False Then
                 Dim found As Boolean = False
                 For k As Integer = 0 To cacheentry.Members.Count - 1
                     If cacheentry.Members(k) Is member Then
                         found = True
                         Exit For
                     End If
                 Next
 
                 method = TryCast(member, Mono.Cecil.MethodReference)
                 If Not found AndAlso method IsNot Nothing Then
                     For k As Integer = 0 To cacheentry.Members.Count - 1
                         If Helper.CompareMethod(TryCast(cacheentry.Members(k), Mono.Cecil.MethodReference), method) Then
                             found = True
                             Exit For
                         End If
                     Next
                 End If
                 If Not found Then
                     cacheentry.Members.Add(member)
                 End If
             End If
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmProfiles.vb" startline="19" endline="37">
<![CDATA[
     End Property
 
     Private Sub FrmProfiles_Load(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles Me.Load
 
         On Error Resume Next
 
         HdrMain.Values.Image = New Bitmap(DataDir & "services_profiles.png")
 
         BtnPreview.Image = New Bitmap(DataDir & "preview.png")
         BtnApply.Image = New Bitmap(DataDir & "apply.png")
         BtnValidate.Image = New Bitmap(DataDir & "validate.png")
         BtnEdit.Image = New Bitmap(DataDir & "edit.png")
         BtnDelete.Image = New Bitmap(DataDir & "delete.png")
         BtnImport.Image = New Bitmap(DataDir & "import.png")
         BtnCreate.Image = New Bitmap(DataDir & "create.png")
 
         Call Check_Profiles()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="805" endline="892">
<![CDATA[
 
     Private Function ResolveImports(ByVal imps As ImportsClauses, ByVal Name As String) As Boolean
         '---------------------------------------------------------------------------------------------------------
         '* If the (source file / compilation environment) containing the name reference has one or more imports
         '** If the identifier matches the name of an accessible type or type member in exactly one import, 
         '   then the identifier refers to that type or type member. If the identifier matches the name of 
         '   an accessible type or type member in more than one import, a compile-time error occurs.
         '** If the identifier matches the name of a namespace in exactly one import, then the identifier 
         '   refers to that namespace. If the identifier matches the name of a namespace in more than one import, 
         '   a compile-time error occurs.
         '** Otherwise, if the imports contain one or more accessible standard modules, and a member name 
         '   lookup of the identifier produces an accessible match in exactly one standard module, then 
         '   the result is exactly the same as a member access of the form M.E, where M is the standard 
         '   module containing the matching member and E is the identifier. If the identifier matches 
         '   accessible type members in more than one standard module, a compile-time error occurs.
         '---------------------------------------------------------------------------------------------------------
         Dim impmembers As New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim result As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference) = Nothing
         For Each imp As ImportsClause In imps
             If imp.IsNamespaceClause Then
                 If imp.AsNamespaceClause.IsNamespaceImport Then
                     'The specified name can only be a type.
                     If Compiler.TypeManager.TypesByNamespace.ContainsKey(imp.AsNamespaceClause.Name) Then
                         result = Compiler.TypeManager.GetTypesByNamespaceAndName(imp.AsNamespaceClause.Name, Name)
                         'Helper.FilterByName(Compiler.TypeManager.TypesByNamespace(imp.AsNamespaceClause.Name).ToTypeList, Name, result)
                     End If
                 ElseIf imp.AsNamespaceClause.IsTypeImport Then
                     'result.AddRange(Helper.FilterByName(imp.AsNamespaceClause.TypeImported.GetMembers, Name))
                     'result.AddRange(Compiler.TypeManager.GetCache(imp.AsNamespaceClause.TypeImported).LookupMembersFlattened(Name))
                     result = Compiler.TypeManager.GetCache(imp.AsNamespaceClause.TypeImported).LookupMembersFlattened(Name)
                 Else
                     Continue For 'This import was not resolved correctly, so don't use it.
                 End If
             End If
             If result IsNot Nothing AndAlso result.Count > 0 Then
                 If impmembers.Count > 0 Then
                     Return Helper.AddError(Me, "If the identifier matches the name of an accessible type or type member in more than one import, a compile-time error occurs.")
                 End If
                 impmembers.AddRange(result)
                 result = Nothing
             End If
         Next
 
         If impmembers.Count > 0 Then
             'If the identifier matches the name of an accessible type or type member in exactly one import, 
             'then the identifier refers to that type or type member. If the identifier matches the name of 
             'an accessible type or type member in more than one import, a compile-time error occurs.
             If Helper.IsMethodDeclaration(impmembers(0)) Then
                 Classification = New MethodGroupClassification(Me, Nothing, m_TypeArgumentList, Nothing, impmembers)
                 Return True
             End If
             If Helper.IsTypeDeclaration(impmembers(0)) Then
                 Classification = New TypeClassification(Me, impmembers(0))
                 Return True
             End If
             If Helper.IsFieldDeclaration(impmembers(0)) Then
                 Classification = New ValueClassification(Me, DirectCast(impmembers(0), Mono.Cecil.FieldReference), Nothing)
                 Return True
             End If
             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
         End If
 
         Dim nsmembers As Generic.List(Of [Namespace])
         nsmembers = imps.GetNamespaces(Me, Name)
         If nsmembers.Count = 1 Then
             'If the identifier matches the name of a namespace in exactly one import, then the identifier 
             'refers to that namespace. If the identifier matches the name of a namespace in more than one import, 
             'a compile-time error occurs.
             Classification = New NamespaceClassification(Me, nsmembers(0))
             Return True
         ElseIf nsmembers.Count > 1 Then
             Return Helper.AddError(Me)
         End If
 
         'Otherwise, if the imports contain one or more accessible standard modules, and a member name 
         'lookup of the identifier produces an accessible match in exactly one standard module, then 
         'the result is exactly the same as a member access of the form M.E, where M is the standard 
         'module containing the matching member and E is the identifier. If the identifier matches 
         'accessible type members in more than one standard module, a compile-time error occurs.
         Dim modules As TypeList = imps.GetModules(Me)
         Dim found As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         found = Helper.GetMembersOfTypes(Compiler, modules, Name)
         If SetClassificationOfModuleMembers(found) Then
             Return True
         End If
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeConverter.vb" startline="1548" endline="1596">
<![CDATA[
 
     Public Shared Function ConvertToUInt16(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object, ByVal ShowErrors As Boolean) As Boolean
         Const DEST As String = "UShort"
 
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CUShort(i)
                 Return True
             Case TypeCode.Decimal
                 Dim i As Decimal = CDec(Source)
                 If i >= UShort.MinValue AndAlso i <= UShort.MaxValue Then
                     result = CUShort(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Dim i As Long = CLng(Source)
                 If i >= UShort.MinValue AndAlso i <= UShort.MaxValue Then
                     result = CUShort(i)
                     Return True
                 End If
             Case TypeCode.Double, TypeCode.Single
                 Dim i As Double = CDbl(Source)
                 If i >= UShort.MinValue AndAlso i <= UShort.MaxValue Then
                     result = CUShort(i)
                     Return True
                 End If
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Dim i As ULong = CULng(Source)
                 If i >= UShort.MinValue AndAlso i <= UShort.MaxValue Then
                     result = CUShort(i)
                     Return True
                 End If
             Case TypeCode.Char
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, DEST)
             Case TypeCode.DateTime
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", DEST)
             Case TypeCode.String
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, DEST, "String")
             Case TypeCode.DBNull
                 result = 0US
                 Return True
         End Select
         If ShowErrors = False Then Return False
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, DEST)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="112" endline="171">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Helper.Assert(Info.DesiredType IsNot Nothing OrElse Info.RHSExpression IsNot Nothing)
 
         If Info.IsRHS Then
             If Info.DesiredType IsNot Nothing Then
                 If CecilHelper.IsGenericParameter(Info.DesiredType) AndAlso CecilHelper.IsGenericParameter(Me.ExpressionType) Then
                     Helper.Assert(Me.Classification.CanBeValueClassification)
                     Dim tmp As Expression
                     tmp = Me.ReclassifyToValueExpression()
                     result = tmp.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
                     result = tmp.GenerateCode(Info) AndAlso result
                 ElseIf CecilHelper.IsByRef(Info.DesiredType) = False AndAlso CecilHelper.IsGenericParameter(Me.ExpressionType) = False Then
                     If Me.Classification.CanBeValueClassification Then
                         Dim tmp As Expression
                         tmp = Me.ReclassifyToValueExpression()
                         result = tmp.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
                         result = tmp.Classification.GenerateCode(Info) AndAlso result
                     Else
                         Throw New InternalException(Me)
                     End If
                 Else
                     If Me.Classification.IsVariableClassification Then
                         If CecilHelper.IsByRef(Me.ExpressionType) OrElse CecilHelper.IsArray(Me.ExpressionType) Then
                             Emitter.EmitLoadVariable(Info, Me.Classification.AsVariableClassification)
                         Else
                             Emitter.EmitLoadVariableLocation(Info, Me.Classification.AsVariableClassification)
                         End If
                     Else
                         Throw New InternalException(Me)
                     End If
                 End If
             Else
                 If Me.Classification.CanBeValueClassification Then
                     Dim tmp As Expression
                     tmp = Me.ReclassifyToValueExpression()
                     result = tmp.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
                     result = tmp.GenerateCode(Info) AndAlso result
                 Else
                     Throw New InternalException(Me)
                 End If
             End If
         ElseIf Info.IsLHS Then
             If Me.Classification.IsVariableClassification Then
                 result = Me.Classification.AsVariableClassification.GenerateCode(Info) AndAlso result
             ElseIf Me.Classification.IsPropertyGroupClassification Then
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
             ElseIf Me.Classification.IsValueClassification Then
                 Throw New InternalException(Me)
             Else
                 Throw New InternalException(Me)
             End If
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\LocalVariableDeclaration.vb" startline="185" endline="245">
<![CDATA[
 
     Private Function EmitStaticInitializer(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim elseIfLabel As Label
         Dim endIfLabel As Label
 
         If Me.HasInitializer = False Then Return result
 
         elseIfLabel = Emitter.DefineLabel(Info)
         endIfLabel = Emitter.DefineLabel(Info)
 
         'Monitor.Enter(initvar)
         If Not m_FieldBuilderStaticInit.IsStatic Then Emitter.EmitLoadMe(Info, Me.DeclaringType.CecilType)
         Emitter.EmitLoadVariable(Info, m_FieldBuilderStaticInit)
         Emitter.EmitCall(Info, Compiler.TypeCache.System_Threading_Monitor__Enter_Object)
         'Try
         Dim exBlock As Label
         exBlock = Emitter.EmitBeginExceptionBlock(Info)
         '   If initvar.State = 0 Then
         If Not m_FieldBuilderStaticInit.IsStatic Then Emitter.EmitLoadMe(Info, Me.DeclaringType.CecilType)
         Emitter.EmitLoadVariable(Info, m_FieldBuilderStaticInit)
         Emitter.EmitLoadVariable(Info, Compiler.TypeCache.MS_VB_CS_StaticLocalInitFlag__State)
         Emitter.EmitLoadI4Value(Info, 0I)
         Info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Bne_Un_S, elseIfLabel)
         '       initvar.State = 2
         If Not m_FieldBuilderStaticInit.IsStatic Then Emitter.EmitLoadMe(Info, Me.DeclaringType.CecilType)
         Emitter.EmitLoadVariable(Info, m_FieldBuilderStaticInit)
         Emitter.EmitLoadI4Value(Info, 2I)
         Emitter.EmitStoreField(Info, Compiler.TypeCache.MS_VB_CS_StaticLocalInitFlag__State)
         '       (initalization)
         result = EmitVariableInitializer(Info) AndAlso result
         Emitter.EmitBranch(Info, endIfLabel)
         '   ElseIf initvar.State = 2 Then
         Emitter.MarkLabel(Info, elseIfLabel)
         If Not m_FieldBuilderStaticInit.IsStatic Then Emitter.EmitLoadMe(Info, Me.DeclaringType.CecilType)
         Emitter.EmitLoadVariable(Info, m_FieldBuilderStaticInit)
         Emitter.EmitLoadVariable(Info, Compiler.TypeCache.MS_VB_CS_StaticLocalInitFlag__State)
         Emitter.EmitLoadI4Value(Info, 2I)
         Info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Bne_Un_S, endIfLabel)
         '       Throw New IncompleteInitializationException
         Emitter.EmitNew(Info, Compiler.TypeCache.MS_VB_CS_IncompleteInitialization__ctor)
         Emitter.EmitThrow(Info)
         '   End If
         Emitter.MarkLabel(Info, endIfLabel)
         Emitter.EmitLeave(Info, exBlock)
         'Finally
         Info.ILGen.BeginFinallyBlock()
         '   initvar.State = 1
         If Not m_FieldBuilderStaticInit.IsStatic Then Emitter.EmitLoadMe(Info, Me.DeclaringType.CecilType)
         Emitter.EmitLoadVariable(Info, m_FieldBuilderStaticInit)
         Emitter.EmitLoadI4Value(Info, 1I)
         Emitter.EmitStoreField(Info, Compiler.TypeCache.MS_VB_CS_StaticLocalInitFlag__State)
         '   Monitor.Exit(initvar)
         If Not m_FieldBuilderStaticInit.IsStatic Then Emitter.EmitLoadMe(Info, Me.DeclaringType.CecilType)
         Emitter.EmitLoadVariable(Info, m_FieldBuilderStaticInit)
         Emitter.EmitCall(Info, Compiler.TypeCache.System_Threading_Monitor__Exit_Object)
         'End Try
         Info.ILGen.EndExceptionBlock()
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="265" endline="319">
<![CDATA[
 
     Function RuleAdditionSubtractionStringConcat(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleMod(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Minus, KS.Add)
             Dim DoAdd As Boolean
             DoAdd = CurrentToken.Equals(KS.Add)
             NextToken()
             RuleMod(RSide)
 
             Dim bErr As Boolean
             If TypeOf LSide Is String AndAlso TypeOf RSide Is String Then
                 'String concat
                 LSide = CStr(LSide) & CStr(RSide)
             Else
                 Dim op1, op2 As Double
                 If TypeOf LSide Is String Then
                     op1 = Double.Parse(DirectCast(LSide, String))
                     If ToDouble(RSide, op2) = False Then
                         Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                         bErr = True
                     End If
                 ElseIf TypeOf RSide Is String Then
                     op2 = Double.Parse(DirectCast(RSide, String))
                     If ToDouble(LSide, op1) = False Then
                         Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                         bErr = True
                     End If
                 Else
                     If ToDouble(RSide, op2) = False Then
                         Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                         bErr = True
                     End If
                     If ToDouble(LSide, op1) = False Then
                         Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                         bErr = True
                     End If
                 End If
 
 
                 If bErr Then
                     LSide = CDbl(0)
                 ElseIf DoAdd Then
                     LSide = op1 + op2
                 Else
                     LSide = op1 - op2
                 End If
             End If
         End While
         While CurrentToken.Equals(KS.Minus, KS.Add)
             Dim DoAdd As Boolean
             DoAdd = CurrentToken.Equals(KS.Add)
             NextToken()
             RuleMod(RSide)
 
             Dim bErr As Boolean
             If TypeOf LSide Is String AndAlso TypeOf RSide Is String Then
                 'String concat
                 LSide = CStr(LSide) & CStr(RSide)
             Else
                 Dim op1, op2 As Double
                 If TypeOf LSide Is String Then
                     op1 = Double.Parse(DirectCast(LSide, String))
                     If ToDouble(RSide, op2) = False Then
                         Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                         bErr = True
                     End If
                 ElseIf TypeOf RSide Is String Then
                     op2 = Double.Parse(DirectCast(RSide, String))
                     If ToDouble(LSide, op1) = False Then
                         Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                         bErr = True
                     End If
                 Else
                     If ToDouble(RSide, op2) = False Then
                         Compiler.Report.ShowMessage(Messages.VBNC30748, Location, RSide.GetType.ToString, KS.Double.ToString)
                         bErr = True
                     End If
                     If ToDouble(LSide, op1) = False Then
                         Compiler.Report.ShowMessage(Messages.VBNC30748, Location, LSide.GetType.ToString, KS.Double.ToString)
                         bErr = True
                     End If
                 End If
 
 
                 If bErr Then
                     LSide = CDbl(0)
                 ElseIf DoAdd Then
                     LSide = op1 + op2
                 Else
                     LSide = op1 - op2
                 End If
             End If
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeConverter.vb" startline="1597" endline="1645">
<![CDATA[
 
     Public Shared Function ConvertToUInt32(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object, ByVal ShowErrors As Boolean) As Boolean
         Const DEST As String = "UInteger"
 
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CUInt(i)
                 Return True
             Case TypeCode.Decimal
                 Dim i As Decimal = CDec(Source)
                 If i >= UInteger.MinValue AndAlso i <= UInteger.MaxValue Then
                     result = CUInt(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Dim i As Long = CLng(Source)
                 If i >= UInteger.MinValue AndAlso i <= UInteger.MaxValue Then
                     result = CUInt(i)
                     Return True
                 End If
             Case TypeCode.Double, TypeCode.Single
                 Dim i As Double = CDbl(Source)
                 If i >= UInteger.MinValue AndAlso i <= UInteger.MaxValue Then
                     result = CUInt(i)
                     Return True
                 End If
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Dim i As ULong = CULng(Source)
                 If i >= UInteger.MinValue AndAlso i <= UInteger.MaxValue Then
                     result = CUInt(i)
                     Return True
                 End If
             Case TypeCode.Char
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, DEST)
             Case TypeCode.DateTime
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", DEST)
             Case TypeCode.String
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, DEST, "String")
             Case TypeCode.DBNull
                 result = 0UI
                 Return True
         End Select
         If ShowErrors = False Then Return False
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, DEST)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1512" endline="1571">
<![CDATA[
 
     Shared Function ApplyTypeArguments(ByVal Parent As ParsedObject, ByVal OpenType As Mono.Cecil.TypeReference, ByVal TypeParameters As Mono.Collections.Generic.Collection(Of TypeReference), ByVal TypeArguments As Mono.Collections.Generic.Collection(Of TypeReference)) As Mono.Cecil.TypeReference
         Dim result As Mono.Cecil.TypeReference = Nothing
 
         If OpenType Is Nothing Then Return Nothing
 
         Helper.Assert(TypeParameters IsNot Nothing AndAlso TypeArguments IsNot Nothing)
         Helper.Assert(TypeParameters.Count = TypeArguments.Count)
 
         If CecilHelper.IsGenericParameter(OpenType) Then
             For i As Integer = 0 To TypeParameters.Count - 1
                 If Helper.CompareName(TypeParameters(i).Name, OpenType.Name) Then
                     result = TypeArguments(i)
                     Exit For
                 End If
             Next
             Helper.Assert(result IsNot Nothing)
         ElseIf CecilHelper.IsGenericType(OpenType) Then
             Dim typeParams As Mono.Collections.Generic.Collection(Of TypeReference)
             Dim typeArgs As New Mono.Collections.Generic.Collection(Of TypeReference)(Nothing)
 
             typeParams = CecilHelper.GetGenericArguments(OpenType)
 
             For i As Integer = 0 To typeParams.Count - 1
                 For j As Integer = 0 To TypeParameters.Count - 1
                     If Helper.CompareName(typeParams(i).Name, TypeParameters(j).Name) Then
                         typeArgs.Add(TypeArguments(j))
                         Exit For
                     End If
                 Next
                 If typeArgs.Count - 1 < i Then typeArgs.Add(typeParams(i))
             Next
 
             Helper.Assert(typeArgs.Count = typeParams.Count AndAlso typeArgs.Count > 0)
 
             result = Parent.Compiler.TypeManager.MakeGenericType(Parent, OpenType, typeArgs)
         ElseIf CecilHelper.IsGenericTypeDefinition(OpenType) Then
             Parent.Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
         ElseIf CecilHelper.ContainsGenericParameters(OpenType) Then
             If CecilHelper.IsArray(OpenType) Then
                 Dim elementType As Mono.Cecil.TypeReference
                 elementType = CecilHelper.GetElementType(OpenType)
                 elementType = ApplyTypeArguments(Parent, elementType, TypeParameters, TypeArguments)
                 result = New Mono.Cecil.ArrayType(elementType, CecilHelper.GetArrayRank(OpenType))
             ElseIf CecilHelper.IsByRef(OpenType) Then
                 Dim elementType As Mono.Cecil.TypeReference
                 elementType = CecilHelper.GetElementType(OpenType)
                 elementType = ApplyTypeArguments(Parent, elementType, TypeParameters, TypeArguments)
                 result = Parent.Compiler.TypeManager.MakeByRefType(Parent, elementType)
             Else
                 Parent.Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             End If
         Else
             result = OpenType
         End If
 
         Helper.Assert(result IsNot Nothing)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="1059" endline="1113">
<![CDATA[
 
     Private Function SetVersion(ByVal Name As Mono.Cecil.AssemblyNameDefinition, ByVal Attribute As Attribute, ByVal Location As Span) As Boolean
         Dim result As Version
         Dim version As String = ""
 
         If Attribute.Arguments IsNot Nothing AndAlso Attribute.Arguments.Length = 1 Then
             version = TryCast(Attribute.Arguments()(0), String)
         Else
             Return ShowInvalidVersionMessage(version, Location)
         End If
 
         Try
             Dim parts() As String
             Dim major, minor, build, revision As UShort
             parts = version.Split("."c)
 
             If parts.Length > 4 Then
                 Return ShowInvalidVersionMessage(version, Location)
             End If
 
             If Not UShort.TryParse(parts(0), major) Then
                 Return ShowInvalidVersionMessage(version, Location)
             End If
 
             If Not UShort.TryParse(parts(1), minor) Then
                 Return ShowInvalidVersionMessage(version, Location)
             End If
 
             If parts.Length < 3 Then
                 'Use 0
             ElseIf parts(2) = "*" Then
                 build = CUShort((Date.Now - New Date(2000, 1, 1)).TotalDays)
                 revision = CUShort((Date.Now.Hour * 3600 + Date.Now.Minute * 60 + Date.Now.Second) / 2)
             ElseIf Not UShort.TryParse(parts(2), build) Then
                 Return ShowInvalidVersionMessage(version, Location)
             End If
 
             If parts.Length < 4 Then
                 'Use 0
             ElseIf parts.Length > 3 Then
                 If parts(3) = "*" Then
                     revision = CUShort((Date.Now.Hour * 3600 + Date.Now.Minute * 60 + Date.Now.Second) / 2)
                 ElseIf Not UShort.TryParse(parts(3), revision) Then
                     Return ShowInvalidVersionMessage(version, Location)
                 End If
             End If
 
             result = New Version(major, minor, build, revision)
         Catch ex As Exception
             Return ShowInvalidVersionMessage(version, Location)
         End Try
 
         Name.Version = result
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\BaseObject.vb" startline="138" endline="144">
<![CDATA[
 
     Friend Function FindMethod() As IBaseObject
         Dim found As IBaseObject
         found = FindFirstParent(Of IMethod)()
         If found Is Nothing Then found = FindFirstParent(Of PropertyDeclaration)()
         Return found
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Classes\SrvcProfile.vb" startline="6" endline="14">
<![CDATA[
     Protected Overrides Sub Dispose(ByVal disposing As Boolean)
         Try
             If disposing AndAlso components IsNot Nothing Then
                 components.Dispose()
             End If
         Finally
             MyBase.Dispose(disposing)
         End Try
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmAuto.vb" startline="6" endline="14">
<![CDATA[
     Protected Overrides Sub Dispose(ByVal disposing As Boolean)
         Try
             If disposing AndAlso components IsNot Nothing Then
                 components.Dispose()
             End If
         Finally
             MyBase.Dispose(disposing)
         End Try
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmAuto.vb" startline="6" endline="14">
<![CDATA[
     Protected Overrides Sub Dispose(ByVal disposing As Boolean)
         Try
             If disposing AndAlso components IsNot Nothing Then
                 components.Dispose()
             End If
         Finally
             MyBase.Dispose(disposing)
         End Try
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmDiagnostics.vb" startline="6" endline="14">
<![CDATA[
     Protected Overrides Sub Dispose(ByVal disposing As Boolean)
         Try
             If disposing AndAlso components IsNot Nothing Then
                 components.Dispose()
             End If
         Finally
             MyBase.Dispose(disposing)
         End Try
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmGameMode.vb" startline="6" endline="14">
<![CDATA[
     Protected Overrides Sub Dispose(ByVal disposing As Boolean)
         Try
             If disposing AndAlso components IsNot Nothing Then
                 components.Dispose()
             End If
         Finally
             MyBase.Dispose(disposing)
         End Try
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="6" endline="14">
<![CDATA[
     Protected Overrides Sub Dispose(ByVal disposing As Boolean)
         Try
             If disposing AndAlso components IsNot Nothing Then
                 components.Dispose()
             End If
         Finally
             MyBase.Dispose(disposing)
         End Try
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmManual.vb" startline="6" endline="14">
<![CDATA[
     Protected Overrides Sub Dispose(ByVal disposing As Boolean)
         Try
             If disposing AndAlso components IsNot Nothing Then
                 components.Dispose()
             End If
         Finally
             MyBase.Dispose(disposing)
         End Try
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmManual.vb" startline="6" endline="14">
<![CDATA[
     Protected Overrides Sub Dispose(ByVal disposing As Boolean)
         Try
             If disposing AndAlso components IsNot Nothing Then
                 components.Dispose()
             End If
         Finally
             MyBase.Dispose(disposing)
         End Try
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmProfiles.vb" startline="6" endline="14">
<![CDATA[
     Protected Overrides Sub Dispose(ByVal disposing As Boolean)
         Try
             If disposing AndAlso components IsNot Nothing Then
                 components.Dispose()
             End If
         Finally
             MyBase.Dispose(disposing)
         End Try
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmProfiles.vb" startline="6" endline="14">
<![CDATA[
     Protected Overrides Sub Dispose(ByVal disposing As Boolean)
         Try
             If disposing AndAlso components IsNot Nothing Then
                 components.Dispose()
             End If
         Finally
             MyBase.Dispose(disposing)
         End Try
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmProfiles.vb" startline="6" endline="14">
<![CDATA[
     Protected Overrides Sub Dispose(ByVal disposing As Boolean)
         Try
             If disposing AndAlso components IsNot Nothing Then
                 components.Dispose()
             End If
         Finally
             MyBase.Dispose(disposing)
         End Try
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmSrvcMngr.vb" startline="6" endline="14">
<![CDATA[
     Protected Overrides Sub Dispose(ByVal disposing As Boolean)
         Try
             If disposing AndAlso components IsNot Nothing Then
                 components.Dispose()
             End If
         Finally
             MyBase.Dispose(disposing)
         End Try
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmSrvcMngr.vb" startline="6" endline="14">
<![CDATA[
     Protected Overrides Sub Dispose(ByVal disposing As Boolean)
         Try
             If disposing AndAlso components IsNot Nothing Then
                 components.Dispose()
             End If
         Finally
             MyBase.Dispose(disposing)
         End Try
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\AboutBox.cs" startline="56" endline="69">
<![CDATA[
         }
 
         public string AssemblyDescription
         {
             get
             {
                 // Get all Description attributes on this assembly
                 object[] attributes = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(AssemblyDescriptionAttribute), false);
                 // If there aren't any Description attributes, return an empty string
                 if (attributes.Length == 0)
                     return "";
                 // If there is a Description attribute, return its value
                 return ((AssemblyDescriptionAttribute)attributes[0]).Description;
             }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\AboutBox.cs" startline="70" endline="83">
<![CDATA[
         }
 
         public string AssemblyProduct
         {
             get
             {
                 // Get all Product attributes on this assembly
                 object[] attributes = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(AssemblyProductAttribute), false);
                 // If there aren't any Product attributes, return an empty string
                 if (attributes.Length == 0)
                     return "";
                 // If there is a Product attribute, return its value
                 return ((AssemblyProductAttribute)attributes[0]).Product;
             }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\AboutBox.cs" startline="84" endline="97">
<![CDATA[
         }
 
         public string AssemblyCopyright
         {
             get
             {
                 // Get all Copyright attributes on this assembly
                 object[] attributes = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(AssemblyCopyrightAttribute), false);
                 // If there aren't any Copyright attributes, return an empty string
                 if (attributes.Length == 0)
                     return "";
                 // If there is a Copyright attribute, return its value
                 return ((AssemblyCopyrightAttribute)attributes[0]).Copyright;
             }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\AboutBox.cs" startline="98" endline="111">
<![CDATA[
         }
 
         public string AssemblyCompany
         {
             get
             {
                 // Get all Company attributes on this assembly
                 object[] attributes = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(AssemblyCompanyAttribute), false);
                 // If there aren't any Company attributes, return an empty string
                 if (attributes.Length == 0)
                     return "";
                 // If there is a Company attribute, return its value
                 return ((AssemblyCompanyAttribute)attributes[0]).Company;
             }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="490" endline="496">
<![CDATA[
 
     Shared Function IsInterface(ByVal Context As BaseObject, ByVal Type As Mono.Cecil.TypeReference) As Boolean
         If TypeOf Type Is Mono.Cecil.GenericParameter Then Return False
         If TypeOf Type Is Mono.Cecil.ArrayType Then Return False
         If TypeOf Type Is ByReferenceType Then Return False
         Return CecilHelper.FindDefinition(Type).IsInterface
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="497" endline="503">
<![CDATA[
 
     Shared Function IsEnum(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As Boolean
         If TypeOf Type Is Mono.Cecil.GenericParameter Then Return False
         If TypeOf Type Is Mono.Cecil.ArrayType Then Return False
         If TypeOf Type Is ByReferenceType Then Return False
         Return CecilHelper.FindDefinition(Type).IsEnum
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2080" endline="2087">
<![CDATA[
 
     Shared Function ResolveTypeReferences(ByVal ParamArray Collection As ParsedObject()) As Boolean
         Dim result As Boolean = True
         For Each obj As ParsedObject In Collection
             If obj IsNot Nothing Then result = obj.ResolveTypeReferences AndAlso result
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4218" endline="4240">
<![CDATA[
 
     Overloads Shared Function ToString(ByVal Context As BaseObject, ByVal Member As PropertyReference) As String
         Dim builder As New Text.StringBuilder()
         Dim pd As PropertyDefinition = CecilHelper.FindDefinition(Member)
 
         builder.Append(ToString(GetAccessibility(pd)))
         builder.Append(" ")
         If pd.GetMethod Is Nothing Then
             builder.Append("WriteOnly ")
         ElseIf pd.SetMethod Is Nothing Then
             builder.Append("ReadOnly ")
         End If
         If IsDefaultProperty(Context.Compiler, pd) Then
             builder.Append("Default ")
         End If
         builder.Append("Property ")
         builder.Append(Member.Name)
         builder.Append(Helper.ToString(Context, Helper.GetParameters(Context, Member)))
         builder.Append(" As ")
         builder.Append(Helper.ToString(Context, pd.PropertyType))
 
         Return builder.ToString()
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MethodBaseDeclaration.vb" startline="388" endline="450">
<![CDATA[
 
     Private Function GeneratePropertyHandlers() As Boolean
         Dim result As Boolean = True
         Dim propD As PropertyDeclaration
 
         propD = DirectCast(Parent, PropertyDeclaration)
 
         Dim isGet As Boolean
         Dim isSet As Boolean
         isGet = TypeOf Me Is PropertyGetDeclaration
         isSet = TypeOf Me Is PropertySetDeclaration
 
         Helper.Assert(isGet Xor isSet)
 
         Dim info As New EmitInfo(Me)
         Dim meType As Mono.Cecil.TypeReference = Helper.GetTypeOrTypeBuilder(Compiler, Me.FindFirstParent(Of TypeDeclaration).CecilType)
         If isGet Then
             If Me.IsShared = False Then
                 Emitter.EmitLoadMe(info, meType)
             End If
             Emitter.EmitLoadVariable(info, propD.HandlesField.FieldBuilder)
             Emitter.EmitRet(info)
         Else
             Dim endRemoveLabel As Label
             Dim endAddLabel As Label
 
             endRemoveLabel = Emitter.DefineLabel(info)
             endAddLabel = Emitter.DefineLabel(info)
 
             'Remove old handlers
             If Me.IsShared = False Then
                 Emitter.EmitLoadMe(info, meType)
             End If
             Emitter.EmitLoadVariable(info, propD.HandlesField.FieldBuilder)
             Emitter.EmitBranchIfFalse(info, endRemoveLabel)
             For Each item As AddOrRemoveHandlerStatement In propD.Handlers
                 result = item.GenerateCode(info, False) AndAlso result
             Next
             Emitter.MarkLabel(info, endRemoveLabel)
 
             'Store the variable
             If Me.IsShared = False Then
                 Emitter.EmitLoadMe(info, meType)
             End If
             Emitter.EmitLoadParameter(info, Me.GetParameters()(0))
             Emitter.EmitStoreField(info, propD.HandlesField.FieldBuilder)
 
             'Add new handlers
             If Me.IsShared = False Then
                 Emitter.EmitLoadMe(info, meType)
             End If
             Emitter.EmitLoadVariable(info, propD.HandlesField.FieldBuilder)
             Emitter.EmitBranchIfFalse(info, endAddLabel)
             For Each item As AddOrRemoveHandlerStatement In propD.Handlers
                 result = item.GenerateCode(info, True) AndAlso result
             Next
             Emitter.MarkLabel(info, endAddLabel)
 
             Emitter.EmitRet(info)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="1006" endline="1058">
<![CDATA[
 
     Private Sub SignWithKeyFileMono(ByVal result As Mono.Cecil.AssemblyNameDefinition, ByVal KeyFile As String, ByVal DelaySign As Boolean, ByVal blob As Byte())
         Dim CryptoConvert As Type
         Dim FromCapiKeyBlob As System.Reflection.MethodInfo
         Dim ToCapiPublicKeyBlob As System.Reflection.MethodInfo
         Dim FromCapiPrivateKeyBlob As System.Reflection.MethodInfo
         Dim RSA As Type
         Dim mscorlib As System.Reflection.Assembly = GetType(Integer).Assembly
 
 #If DEBUG Then
         Compiler.Report.WriteLine("Signing on Mono")
 #End If
 
         Try
             RSA = mscorlib.GetType("System.Security.Cryptography.RSA")
             CryptoConvert = mscorlib.GetType("Mono.Security.Cryptography.CryptoConvert")
             FromCapiKeyBlob = CryptoConvert.GetMethod("FromCapiKeyBlob", System.Reflection.BindingFlags.Public Or System.Reflection.BindingFlags.Static Or System.Reflection.BindingFlags.ExactBinding, Nothing, New Type() {GetType(Byte())}, Nothing)
             ToCapiPublicKeyBlob = CryptoConvert.GetMethod("ToCapiPublicKeyBlob", System.Reflection.BindingFlags.Static Or System.Reflection.BindingFlags.Public Or System.Reflection.BindingFlags.ExactBinding, Nothing, New Type() {RSA}, Nothing)
             FromCapiPrivateKeyBlob = CryptoConvert.GetMethod("FromCapiPrivateKeyBlob", System.Reflection.BindingFlags.Static Or System.Reflection.BindingFlags.Public Or System.Reflection.BindingFlags.ExactBinding, Nothing, New Type() {GetType(Byte())}, Nothing)
 
             If DelaySign Then
                 If blob.Length = 16 Then
                     result.PublicKey = blob
 #If DEBUG Then
                     Compiler.Report.WriteLine("Delay signed 1")
 #End If
                 Else
                     Dim publickey() As Byte
                     Dim fromCapiResult As Object
                     Dim publicKeyHeader As Byte() = New Byte() {&H0, &H24, &H0, &H0, &H4, &H80, &H0, &H0, &H94, &H0, &H0, &H0}
                     Dim encodedPublicKey() As Byte
 
                     fromCapiResult = FromCapiKeyBlob.Invoke(Nothing, New Object() {blob})
                     publickey = CType(ToCapiPublicKeyBlob.Invoke(Nothing, New Object() {fromCapiResult}), Byte())
 
                     ReDim encodedPublicKey(11 + publickey.Length)
                     Buffer.BlockCopy(publicKeyHeader, 0, encodedPublicKey, 0, 12)
                     Buffer.BlockCopy(publickey, 0, encodedPublicKey, 12, publickey.Length)
                     result.PublicKey = encodedPublicKey
 #If DEBUG Then
                     Compiler.Report.WriteLine("Delay signed 2")
 #End If
                 End If
             Else
                 FromCapiPrivateKeyBlob.Invoke(Nothing, New Object() {blob})
                 'FIXME
                 'result.KeyPair = New StrongNameKeyPair(blob)
                 result.PublicKey = blob
             End If
         Catch ex As Exception
             Helper.AddError(Me, "Invalid key file
         End Try
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\dshowUtil.vb" startline="136" endline="204">
<![CDATA[
 
     Private Sub CreatePieces(ByVal JoinAtEnd As Boolean)
 
         Dim i As Integer
         Array.Sort(mKeyFrames)
 
         Dim TempOut As String
         If JoinAtEnd Then
             TempOut = System.IO.Path.GetTempPath & "Movicaflv-"
         Else
             TempOut = StripExtension(mOutFile)
         End If
 
         Dim cw, jw As IO.StreamWriter
         Try
             'Create the job file for splitter
             cw = New IO.StreamWriter(System.AppDomain.CurrentDomain.BaseDirectory & "MovicaCmd@@@.cmd", False)
             cw.WriteLine("@echo off")
             cw.WriteLine("echo Creating pieces using flvtool...")
             For i = 0 To mSegments.Length - 1
                 cw.WriteLine("echo Processing segment " & CStr(i))
                 cw.WriteLine("flvtool2 -Cioa " & GetKeyframe(mSegments(i).Start) & " " & CStr(CInt((mSegments(i).Finish * 1000)) & _
                 " " & Chr(34) & mInFile & Chr(34) & " " & Chr(34) & TempOut & CStr(i + 1).PadLeft(3, "0"c) & ".flv" & Chr(34)))
                 cw.WriteLine("echo      Updating metadata ")
                 cw.WriteLine("flvtool2 -U " & Chr(34) & TempOut & CStr(i + 1).PadLeft(3, "0"c) & ".flv" & Chr(34))
             Next
 
             If JoinAtEnd Then
                 'The joiner section
                 cw.WriteLine("echo.")
                 cw.WriteLine("echo Joining segments together ...")
                 jw = New IO.StreamWriter(System.AppDomain.CurrentDomain.BaseDirectory & "MovicaJoin.@@@", False)
 
 
                 cw.WriteLine("flvjoin MovicaJoin.@@@")
                 jw.WriteLine(mOutFile)
                 For i = 0 To mSegments.Length - 1
                     jw.WriteLine(TempOut & CStr(i + 1).PadLeft(3, "0"c) & ".flv")
                 Next
 
                 'Delete the temp pieces
                 'cw.WriteLine("echo.")
                 'cw.WriteLine("echo Deleting temp files...")
                 'For i = 0 To mSegments.Length - 1
                 '    cw.WriteLine("del " & Chr(34) & TempOut & CStr(i + 1).PadLeft(3, "0"c) & ".flv" & Chr(34))
                 'Next
                 cw.WriteLine("echo Job exiting....")
 
                 jw.Close()
             End If
 
             cw.Close()
 
             'Start the process
             mConverter = "MovicaCmd@@@.cmd"
             RunConverter("")
 
         Catch ex As Exception
             MsgBox("Error in creating the job file" & vbCrLf & ex.Message)
         End Try
 
         Try 'Only useful when there is an exception; there has to be a better way to do this though
             cw.Close()
             jw.Close()
         Catch ex As Exception
             'ignore
         End Try
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\VariableToValueExpression.vb" startline="50" endline="105">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim isByRef As Boolean = CecilHelper.IsByRef(Info.DesiredType)
 
         If m_Variable.InstanceExpression IsNot Nothing Then
             Dim exp As Mono.Cecil.TypeReference = m_Variable.InstanceExpression.ExpressionType
             If CecilHelper.IsValueType(exp) AndAlso CecilHelper.IsByRef(exp) = False Then
                 exp = CecilHelper.MakeByRefType(exp)
             End If
             result = m_Variable.InstanceExpression.GenerateCode(Info.Clone(Me, exp)) AndAlso result
         End If
 
         If m_Variable.FieldInfo IsNot Nothing Then
             If Info.IsRHS Then
                 Emitter.EmitLoadVariable(Info, m_Variable.FieldInfo)
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
             End If
         ElseIf m_Variable.LocalBuilder IsNot Nothing Then
             If Info.IsRHS Then
                 Emitter.EmitLoadVariable(Info, m_Variable.LocalBuilder)
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
             End If
         ElseIf m_Variable.ParameterInfo IsNot Nothing Then
             Helper.Assert(m_Variable.InstanceExpression Is Nothing)
             If Info.IsRHS Then
                 Emitter.EmitLoadParameter(Info, m_Variable.ParameterInfo)
                 If CecilHelper.IsByRef(m_Variable.ParameterInfo.ParameterType) Then
                     Emitter.EmitLoadIndirect(Info, m_Variable.ParameterInfo.ParameterType)
                 End If
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
             End If
         ElseIf m_Variable.ArrayVariable IsNot Nothing Then
             result = Helper.EmitLoadArrayElement(Info, m_Variable.ArrayVariable, m_Variable.Arguments) AndAlso result
         ElseIf m_Variable.Expression IsNot Nothing Then
             result = m_Variable.Expression.GenerateCode(Info) AndAlso result
         ElseIf m_Variable.Method IsNot Nothing Then
             Emitter.EmitLoadVariable(Info, m_Variable.Method.DefaultReturnVariable)
         Else
             Throw New InternalException(Me)
         End If
 
         If CecilHelper.IsByRef(Info.DesiredType) Then
             Dim elementType As Mono.Cecil.TypeReference = Helper.GetTypeOrTypeBuilder(Compiler, CecilHelper.GetElementType(Info.DesiredType))
             Dim local As Mono.Cecil.Cil.VariableDefinition
             local = Emitter.DeclareLocal(Info, elementType)
 
             Emitter.EmitStoreVariable(Info, local)
             Emitter.EmitLoadVariableLocation(Info, local)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CBoolExpression.vb" startline="34" endline="88">
<![CDATA[
 
     Overloads Shared Function GenerateCode(ByVal Conversion As ConversionExpression, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim expType As Mono.Cecil.TypeReference = Nothing
         Dim expTypeCode As TypeCode
         Dim Expression As Expression = Conversion.Expression
 
         result = GenerateCodeForExpression(Conversion, Info, expTypeCode, expType) AndAlso result
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 'Nothing to do
             Case TypeCode.Char, TypeCode.DateTime
                 Info.Compiler.Report.ShowMessage(Messages.VBNC30311, Expression.Location, Helper.ToString(Expression, expType), Helper.ToString(Expression, expType))
                 result = False
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.SByte, TypeCode.Int16, TypeCode.Int32
                 Emitter.EmitLoadI4Value(Info, 0I, expType)
                 Emitter.EmitGT_Un(Info, expType)
             Case TypeCode.Int64
                 Emitter.EmitLoadI8Value(Info, 0L, expType)
                 Emitter.EmitGT_Un(Info, expType)
             Case TypeCode.UInt64
                 Emitter.EmitLoadI8Value(Info, 0UL, expType)
                 Emitter.EmitGT_Un(Info, expType)
             Case TypeCode.Double
                 Emitter.EmitLoadR8Value(Info, 0.0, expType)
                 Emitter.EmitEquals(Info, expType)
                 Emitter.EmitLoadI4Value(Info, 0I, Info.Compiler.TypeCache.System_Boolean)
                 Emitter.EmitEquals(Info, Info.Compiler.TypeCache.System_Boolean)
             Case TypeCode.Single
                 Emitter.EmitLoadR4Value(Info, 0.0!, expType)
                 Emitter.EmitEquals(Info, expType)
                 Emitter.EmitLoadI4Value(Info, 0I, Info.Compiler.TypeCache.System_Boolean)
                 Emitter.EmitEquals(Info, Info.Compiler.TypeCache.System_Boolean)
             Case TypeCode.Object
                 Helper.Assert(Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object IsNot Nothing, "MS_VB_CS_Conversions_ToBoolean__Object Is Nothing")
                 If Helper.CompareType(expType, Info.Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 ElseIf Helper.CompareType(expType, Info.Compiler.TypeCache.Nothing) Then
                     Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 Else
                     Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
                 End If
             Case TypeCode.String
                 Helper.Assert(Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_String IsNot Nothing, "MS_VB_CS_Conversions_ToBoolean__String Is Nothing")
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_String)
             Case TypeCode.Decimal
                 Helper.Assert(Info.Compiler.TypeCache.System_Convert__ToBoolean_Decimal IsNot Nothing, "System_Convert_ToBoolean__Decimal Is Nothing")
                 Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Convert__ToBoolean_Decimal)
             Case Else
                 Return Info.Compiler.Report.ShowMessage(Messages.VBNC99997, Expression.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="23" endline="70">
<![CDATA[
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim opType As TypeCode = MyBase.OperandTypeCode
 
         ValidateBeforeGenerateCode(Info)
 
         Select Case opType
             Case TypeCode.Boolean, TypeCode.Object
                 If opType = TypeCode.Object Then
                     Helper.Assert(Helper.CompareType(OperandType, Compiler.TypeCache.System_Object))
                 End If
 
                 Dim loadfalse, loadtrue, endexp As Label
                 loadfalse = Emitter.DefineLabel(Info)
                 loadtrue = Emitter.DefineLabel(Info)
                 endexp = Emitter.DefineLabel(Info)
 
                 result = m_LeftExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfFalse(Info, loadfalse)
 
                 result = m_RightExpression.GenerateCode(Info) AndAlso result
                 If opType = TypeCode.Object Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_Conversions__ToBoolean_Object)
                 End If
                 Emitter.EmitBranchIfTrue(Info, loadtrue)
 
                 Emitter.MarkLabel(Info, loadfalse) '
                 Emitter.EmitLoadValue(Info, False) 'Load false value
                 Emitter.EmitBranch(Info, endexp)
 
                 Emitter.MarkLabel(Info, loadtrue)
                 Emitter.EmitLoadValue(Info, True) 'Load true value
 
                 Emitter.MarkLabel(Info, endexp) 'The end of the expression
                
                 If opType = TypeCode.Object Then
                     Emitter.EmitBox(Info, Compiler.TypeCache.System_Boolean)
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="123" endline="185">
<![CDATA[
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim beginEx As Label
 
         Dim startIteration As Label
 
         result = m_LoopControlVariable.GenerateCode(Info) AndAlso result 'Creates the localbuilder if necessary
 
         m_Enumerator = Emitter.DeclareLocal(Info, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Collections_IEnumerator))
         EndLabel = Emitter.DefineLabel(Info)
         m_NextIteration = Emitter.DefineLabel(Info)
         startIteration = Emitter.DefineLabel(Info)
 
         beginEx = Emitter.EmitBeginExceptionBlock(Info)
 
         Compiler.Helper.AddCheck("Check correct type of foreach loop container.")
         Helper.Assert(Helper.CompareType(Compiler.TypeCache.System_Object, m_InExpression.ExpressionType) OrElse Helper.IsAssignable(Me, m_InExpression.ExpressionType, Compiler.TypeCache.System_Collections_IEnumerable))
 
         'Load the container variable and get the enumerator
         result = m_InExpression.GenerateCode(Info.Clone(Me, True, False, m_InExpression.ExpressionType)) AndAlso result
         Emitter.EmitCastClass(Info, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Collections_IEnumerable))
         Emitter.EmitCallVirt(Info, Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Collections_IEnumerable__GetEnumerator))
         Emitter.EmitStoreVariable(Info, m_Enumerator)
 
         'Jump to the next iteration
         Emitter.EmitBranch(Info, m_NextIteration)
 
         'Mark the beginning of the code
         Emitter.MarkLabel(Info, startIteration)
 
         Emitter.EmitNop(Info)
         Dim cge As New CompilerGeneratedExpression(Me, New CompilerGeneratedExpression.GenerateCodeDelegate(AddressOf GenerateCode_LoadCurrentLoopVariable), m_LoopControlVariable.VariableType)
         result = m_LoopControlVariable.EmitStoreVariable(Info.Clone(Me, cge)) AndAlso result
 
         result = CodeBlock.GenerateCode(Info) AndAlso result
 
         'Move to the next element
         Emitter.MarkLabel(Info, m_NextIteration)
         Emitter.EmitNop(Info)
         Emitter.EmitLoadVariable(Info, m_Enumerator)
         Emitter.EmitCallVirt(Info, Helper.GetMethodOrMethodReference(Compiler, Compiler.TypeCache.System_Collections_IEnumerator__MoveNext))
         'Jump to the code for the next element
         Emitter.EmitBranchIfTrue(Info, startIteration)
         'End of try code.
         'Emitter.EmitLeave(Info, beginEx)
 
         'Dispose of the enumerator if it is disposable.
         Emitter.EmitBeginFinallyBlock(Info)
         Dim EndFinally As Label = Emitter.DefineLabel(info)
         Emitter.EmitLoadVariable(Info, m_Enumerator)
         Emitter.EmitIsInst(Info, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Collections_IEnumerator), Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_IDisposable))
         Emitter.EmitBranchIfFalse(Info, EndFinally)
         Emitter.EmitLoadVariable(Info, m_Enumerator)
         Emitter.EmitIsInst(Info, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Collections_IEnumerator), Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_IDisposable))
         Emitter.EmitCallVirt(Info, Compiler.TypeCache.System_IDisposable__Dispose)
         Emitter.MarkLabel(info, EndFinally)
         Emitter.EmitEndExceptionBlock(Info)
 
         Emitter.MarkLabel(Info, EndLabel)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="118" endline="126">
<![CDATA[
 #End Region
 
     Shared Function CreateList(ByVal types As System.Collections.IEnumerable) As TypeList
         Dim result As New TypeList
         For Each t As IType In types
             result.Add(t.CecilType)
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="372" endline="379">
<![CDATA[
 
     Shared Function GetNames(ByVal List As IEnumerable) As String()
         Dim result As New Generic.List(Of String)
         For Each item As INameable In List
             result.Add(item.Name)
         Next
         Return result.ToArray
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2196" endline="2203">
<![CDATA[
 
     Private Sub MenuItem6_Click(ByVal sender As System.Object, _
 ByVal e As System.EventArgs) Handles MenuItem6.Click
         Dim frm As New frmAbout
         If Me.TopMost Then frm.TopMost = True
         frm.ShowNormal()
         frm = Nothing
     End Sub
]]>
</clone_fragment>
<clone_fragment file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="59" endline="82">
<![CDATA[
     Public Shared Sub Main(ByVal args As String())
         Console.WriteLine("Chapter 1 example 3
 
         ' step 1
         Dim document As New Document(PageSize.A4.rotate())
 
         ' step 2
         ' we create a writer that listens to the document
         ' and directs a PDF-stream to a file
 
         PdfWriter.getInstance(document, New FileOutputStream("Chap0103.pdf"))
 
         ' step 3
         document.open()
 
         ' step 4
         Dim i As Integer
         For i = 0 To 20
             document.add(New Phrase("Hello World, Hello Sun, Hello Moon, Hello Stars, Hello Sea, Hello Land, Hello People. "))
         Next
 
         ' step 5
         document.close()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeImplementsClauses.vb" startline="55" endline="72">
<![CDATA[
     End Property
 
     Function FoundAsType() As Mono.Cecil.TypeReference 'Descriptor
         Dim found As Object = FoundObject
         If TypeOf found Is IType Then
             Return DirectCast(found, IType).CecilType
             'ElseIf TypeOf found Is Type Then
             '    Return DirectCast(found, Type)
             'ElseIf TypeOf found Is TypeDescriptor Then
             '    Return DirectCast(found, TypeDescriptor)
         ElseIf TypeOf found Is TypeParameter Then
             Return DirectCast(found, TypeParameter).CecilBuilder
         ElseIf TypeOf found Is Mono.Cecil.TypeReference Then
             Return DirectCast(found, Mono.Cecil.TypeReference)
         Else
             Throw New InternalException("")
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="505" endline="525">
<![CDATA[
 
     Private Sub TmrUsg_Tick(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles TmrUsg.Tick
 
         On Error Resume Next
 
         Dim SysDrv As String = System.Environment.SystemDirectory.Substring(0, 2)
         Dim TotalDrv As ULong = CULng(My.Computer.FileSystem.GetDriveInfo(SysDrv).TotalSize / 1024 / 1024)
         Dim FreeDrv As ULong = CULng(My.Computer.FileSystem.GetDriveInfo(SysDrv).AvailableFreeSpace / 1024 / 1024)
         Dim UsedDrv As ULong = (TotalDrv - FreeDrv)
         Dim DrvUsg As Integer = CInt((UsedDrv / TotalDrv) * 100)
         TrkDrvUsg.Value = DrvUsg
         LblDrvUsg.Text = ("System drive usage
 
         Dim TotalMem As ULong = (My.Computer.Info.TotalPhysicalMemory)
         Dim FreeMem As ULong = (My.Computer.Info.AvailablePhysicalMemory)
         Dim UsedMem As ULong = TotalMem - FreeMem
         Dim MemUsg As Integer = CInt((UsedMem / TotalMem) * 100)
         TrkMemUsg.Value = MemUsg
         LblMemUsg.Text = ("Memory usage
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Classes\SrvcProfile.vb" startline="98" endline="127">
<![CDATA[
 
     Private Sub LstComponents_SelectedIndexChanged(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles LstComponents.SelectedIndexChanged
 
         Dim CRight As String = " 2010 Smart PC Utilities, Ltd. All rights reserved."
 
         With LstComponents
 
             If .SelectedIndex = 0 Then
                 LblComponents.Text = ("Vista Services Optimizer enables to tweak Windows services in an easy and safe way with simple mouse clicks." & vbCrLf & vbCrLf & CRight)
             ElseIf .SelectedIndex = 1 Then
                 LblComponents.Text = ("Smart Rescue Center enables to undo any changes made by Vista Services Optimizer to Windows services settings." & vbCrLf & vbCrLf & CRight)
             ElseIf .SelectedIndex = 2 Then
                 LblComponents.Text = ("Quick Control enables to use common Vista Services Optimizer functions directly from your desktop." & vbCrLf & vbCrLf & CRight)
             ElseIf .SelectedIndex = 3 Then
                 LblComponents.Text = ("Web Update enables to download and install the latest Vista Services Optimizer updates." & vbCrLf & vbCrLf & CRight)
             ElseIf .SelectedIndex = 4 Then
                 LblComponents.Text = ("Service Controller component provides Windows services controlling functions like starting and stopping services." & vbCrLf & vbCrLf & CRight)
             ElseIf .SelectedIndex = 5 Then
                 LblComponents.Text = ("Glass Button component provides rich GUI elements using button controls with glass effects." & vbCrLf & vbCrLf & CRight)
             ElseIf .SelectedIndex = 6 Then
                 LblComponents.Text = ("Tracker component provides current system usage information in a graphical way." & vbCrLf & vbCrLf & CRight)
             ElseIf .SelectedIndex = 7 Then
                 LblComponents.Text = ("MDI Client Controller component provides the capabilities of Multiple Documents Interface (MDI) to Vista Services Optimizer." & vbCrLf & vbCrLf & CRight)
             ElseIf .SelectedIndex = 8 Then
                 LblComponents.Text = ("Krypton Toolkit component provides rich GUI elements using buttons, checkbox controls and radio button controls." & vbCrLf & vbCrLf & "? 2009 Component Factory Pty, Ltd. All rights reserved.")
             End If
 
         End With
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\DotAccessExpression.vb" startline="89" endline="96">
<![CDATA[
     Function FindFirstParentOfCodeBlock(Of T)() As T
         Dim cb As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
         If cb IsNot Nothing Then
             Return cb.FindFirstParent(Of T)()
         Else
             Return Nothing
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="58" endline="66">
<![CDATA[
 
     Public Overrides ReadOnly Property RightOperandTypeCode() As System.TypeCode
         Get
             If MyBase.OperandTypeCode = TypeCode.Object Then
                 Return TypeCode.Object
             Else
                 Return TypeCode.Int32
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeArityList.vb" startline="35" endline="44">
<![CDATA[
 
     ReadOnly Property AsTypeArray() As Type()
         Get
             Dim t As Type = GetType(System.Collections.Generic.Dictionary(Of ,))
             Dim result(m_TypeParameters.Length - 1) As Type
             For i As Integer = 0 To result.Length - 1
                 'result(i) = m_TypeParameters(i).Parameters
             Next
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="317" endline="346">
<![CDATA[
 
     Public Function GetKS(ByVal value As Char(), ByVal length As Integer) As KS
         Dim list As Generic.List(Of KW) = Nothing
         Dim ch0 As Char
 
         If length < 2 OrElse length > 14 Then Return KS.None
         ch0 = value(0)
         If ch0 >= "a"c AndAlso ch0 <= "z"c Then ch0 = VB.Chr(VB.Asc(ch0) - 32)
 
         If Not m_Keywords(length - 2).TryGetValue(ch0, list) Then Return KS.None
 
         If list Is Nothing Then Return KS.None
 
         For i As Integer = 0 To list.Count - 1
             Dim kwL As String = list(i).KeywordL
             For c As Integer = 1 To length - 1
                 Dim kc As Char = value(c)
 
                 If kc >= "A"c AndAlso kc <= "Z"c Then kc = VB.Chr(VB.Asc(kc) + 32)
 
                 If kwL(c) = kc Then
                     If c = length - 1 Then Return list(i).KS
                     Continue For
                 End If
                 Exit For
             Next
         Next
 
         Return KS.None
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="386" endline="423">
<![CDATA[
 
     Function RuleRelational(ByRef Result As Object) As Boolean
         Dim LSide As Object = Nothing, RSide As Object = Nothing
 
         If RuleArithmeticBitshift(LSide) = False Then Return False
 
         While CurrentToken.Equals(KS.Equals, KS.NotEqual, KS.GT, KS.LT, KS.GE, KS.LE)
             Dim DoWhat As KS = CurrentToken.Symbol
             NextToken()
             RuleArithmeticBitshift(RSide)
 
             'Compiler.Report.WriteLine(String.Format("RuleRelational
             Try
                 Select Case DoWhat
                     Case KS.Equals
                         LSide = Microsoft.VisualBasic.CompilerServices.Operators.ConditionalCompareObjectEqual(LSide, RSide, True)
                     Case KS.NotEqual
                         LSide = Microsoft.VisualBasic.CompilerServices.Operators.ConditionalCompareObjectNotEqual(LSide, RSide, True)
                     Case KS.GT
                         LSide = Microsoft.VisualBasic.CompilerServices.Operators.ConditionalCompareObjectGreater(LSide, RSide, True)
                     Case KS.LT
                         LSide = Microsoft.VisualBasic.CompilerServices.Operators.ConditionalCompareObjectLess(LSide, RSide, True)
                     Case KS.GE
                         LSide = Microsoft.VisualBasic.CompilerServices.Operators.ConditionalCompareObjectGreaterEqual(LSide, RSide, True)
                     Case KS.LE
                         LSide = Microsoft.VisualBasic.CompilerServices.Operators.ConditionalCompareObjectLessEqual(LSide, RSide, True)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             Catch ex As Exception
                 Helper.AddError(Me, ex.Message & VB.vbNewLine & ex.StackTrace)
                 Return False
             End Try
         End While
         While CurrentToken.Equals(KS.Equals, KS.NotEqual, KS.GT, KS.LT, KS.GE, KS.LE)
             Dim DoWhat As KS = CurrentToken.Symbol
             NextToken()
             RuleArithmeticBitshift(RSide)
 
             'Compiler.Report.WriteLine(String.Format("RuleRelational
             Try
                 Select Case DoWhat
                     Case KS.Equals
                         LSide = Microsoft.VisualBasic.CompilerServices.Operators.ConditionalCompareObjectEqual(LSide, RSide, True)
                     Case KS.NotEqual
                         LSide = Microsoft.VisualBasic.CompilerServices.Operators.ConditionalCompareObjectNotEqual(LSide, RSide, True)
                     Case KS.GT
                         LSide = Microsoft.VisualBasic.CompilerServices.Operators.ConditionalCompareObjectGreater(LSide, RSide, True)
                     Case KS.LT
                         LSide = Microsoft.VisualBasic.CompilerServices.Operators.ConditionalCompareObjectLess(LSide, RSide, True)
                     Case KS.GE
                         LSide = Microsoft.VisualBasic.CompilerServices.Operators.ConditionalCompareObjectGreaterEqual(LSide, RSide, True)
                     Case KS.LE
                         LSide = Microsoft.VisualBasic.CompilerServices.Operators.ConditionalCompareObjectLessEqual(LSide, RSide, True)
                     Case Else
                         Throw New InternalException(Me)
                 End Select
             Catch ex As Exception
                 Helper.AddError(Me, ex.Message & VB.vbNewLine & ex.StackTrace)
                 Return False
             End Try
         End While
 
         Result = LSide
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2996" endline="3003">
<![CDATA[
 
     Private Function ParseExpression(ByVal Info As ExpressionParseInfo) As Expression
         Dim result As Expression = Nothing
 
         result = ParseOr_OrElse_Xor(Info)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="72" endline="127">
<![CDATA[
     End Property
 
     Public Overrides Function GetConstant(ByRef result As Object, ByVal ShowError As Boolean) As Boolean
         Dim rvalue As Object = Nothing
         Dim lvalue As Object = Nothing
 
         If Not m_LeftExpression.GetConstant(lvalue, ShowError) Then Return False
         If Not m_RightExpression.GetConstant(rvalue, ShowError) Then Return False
 
         If lvalue Is Nothing Or rvalue Is Nothing Then
             result = Nothing
             Return True
         End If
 
         Dim tlvalue, trvalue As Mono.Cecil.TypeReference
         Dim clvalue, crvalue As TypeCode
         tlvalue = CecilHelper.GetType(Compiler, lvalue)
         clvalue = Helper.GetTypeCode(Compiler, tlvalue)
         trvalue = CecilHelper.GetType(Compiler, rvalue)
         crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
         If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
             result = CBool(lvalue) AndAlso CBool(rvalue)
             Return True
         End If
 
         Dim smallest As Mono.Cecil.TypeReference
         Dim csmallest As TypeCode
         smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
         Helper.Assert(smallest IsNot Nothing)
         csmallest = Helper.GetTypeCode(Compiler, smallest)
 
         Select Case csmallest
             Case TypeCode.Byte
                 result = CByte(lvalue) And CByte(rvalue)
             Case TypeCode.SByte
                 result = CSByte(lvalue) And CSByte(rvalue)
             Case TypeCode.Int16
                 result = CShort(lvalue) And CShort(rvalue)
             Case TypeCode.UInt16
                 result = CUShort(lvalue) And CUShort(rvalue)
             Case TypeCode.Int32
                 result = CInt(lvalue) And CInt(rvalue)
             Case TypeCode.UInt32
                 result = CUInt(lvalue) And CUInt(rvalue)
             Case TypeCode.Int64
                 result = CLng(lvalue) And CLng(rvalue)
             Case TypeCode.UInt64
                 result = CULng(lvalue) And CULng(rvalue)
             Case Else
                 If ShowError Then Show30059()
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmDiagnostics.vb" startline="298" endline="321">
<![CDATA[
 
     Private Sub Manual_Diagnostics(ByVal Name As String, ByVal Index As Byte)
 
         Try
             SrvcCntrl.ServiceName = (Name)
             Dim ChkSrvc As Boolean = SrvcCntrl.CanPauseAndContinue
         Catch ex As InvalidOperationException
             LstServices.Items.Item(Index).Checked = False
             LstServices.Items.Item(Index).SubItems.Item(1).Text = S5
             LstServices.Items.Item(Index).SubItems.Item(1).ForeColor = Color.DimGray
             Exit Sub
         End Try
 
         If Service_Startup(Name) = 2 OrElse Service_Startup(Name) = 3 Then
             LstServices.Items.Item(Index).Checked = False
             LstServices.Items.Item(Index).SubItems.Item(1).Text = S1
             LstServices.Items.Item(Index).SubItems.Item(1).ForeColor = Color.Green
         Else
             LstServices.Items.Item(Index).Checked = True
             LstServices.Items.Item(Index).SubItems.Item(1).Text = S4
             LstServices.Items.Item(Index).SubItems.Item(1).ForeColor = Color.Red
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="870" endline="912">
<![CDATA[
     End Property
 
     Function IsNarrowingInternal(ByVal ExceptObject As Boolean, ByVal error_lines As Generic.List(Of String)) As Boolean
         For j As Integer = 0 To InputParameters.Count - 1
             Dim arg As Argument
             Dim param As Mono.Cecil.ParameterDefinition
             Dim IsConvertible As Boolean
             Dim elementType As Mono.Cecil.TypeReference
             Dim initializer As Expression
 
             param = InputParameters(j)
             arg = ExactArguments(j)
 
             If arg Is Nothing Then Continue For
 
             If ExceptObject AndAlso Helper.CompareType(arg.Expression.ExpressionType, Compiler.TypeCache.System_Object) Then Continue For
 
             If IsParamArray AndAlso j = InputParameters.Count - 1 AndAlso ParamArrayExpression IsNot Nothing Then
                 'To match the automatically created array for the paramarray parameter each argument has to be 
                 'implicitly convertible to the element type of the paramarray parameter type.
                 IsConvertible = True
                 elementType = CType(param.ParameterType, Mono.Cecil.ArrayType).ElementType
                 For k As Integer = 0 To ParamArrayExpression.ArrayElementInitalizer.Initializers.Count - 1
                     initializer = ParamArrayExpression.ArrayElementInitalizer.Initializers(k).AsRegularInitializer
                     If Not Helper.IsConvertible(arg, initializer, initializer.ExpressionType, elementType, False, Nothing, False, True, False) Then
                         If error_lines IsNot Nothing Then
                             error_lines.Add(String.Format("'{0}'
                         End If
                         Return True
                     End If
                 Next
             Else
                 If Not Helper.IsConvertible(arg, arg.Expression, arg.Expression.ExpressionType, param.ParameterType, False, Nothing, False, True, False) Then
                     If error_lines IsNot Nothing Then
                         error_lines.Add(String.Format("'{0}'
                     End If
                     Return True
                 End If
             End If
         Next
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\DirectCastExpression.vb" startline="33" endline="70">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If CecilHelper.IsGenericParameter(ExpressionType) Then
             result = Expression.GenerateCode(Info.Clone(Me, True, False, Expression.ExpressionType)) AndAlso result
             If Helper.CompareType(Expression.ExpressionType, ExpressionType) = False Then
                 Emitter.EmitUnbox_Any(Info, ExpressionType)
             End If
         Else
             If CecilHelper.IsValueType(Expression.ExpressionType) Then
                 If Helper.CompareType(ExpressionType, Expression.ExpressionType) Then
                     result = Expression.GenerateCode(Info.Clone(Me, True, False, Expression.ExpressionType)) AndAlso result
                 ElseIf Helper.IsEnum(Compiler, ExpressionType) Then
                     result = Expression.GenerateCode(Info.Clone(Me, True, False, Expression.ExpressionType)) AndAlso result
                     Emitter.EmitConversion(Expression.ExpressionType, Helper.GetEnumType(Compiler, ExpressionType), Info)
                 Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC99999, Me.Location, ExpressionType.FullName & " - " & Expression.ExpressionType.FullName)
                 End If
             ElseIf CecilHelper.IsGenericParameter(ExpressionType) = False AndAlso CecilHelper.IsClass(Expression.ExpressionType) AndAlso CecilHelper.IsValueType(ExpressionType) Then
                 result = Expression.GenerateCode(Info.Clone(Me, True, False, Expression.ExpressionType)) AndAlso result
                 Emitter.EmitUnbox(Info, ExpressionType)
                 Emitter.EmitLoadObject(Info, ExpressionType)
             ElseIf CecilHelper.IsGenericParameter(Expression.ExpressionType) Then
                 result = Expression.GenerateCode(Info.Clone(Me, True, False, Expression.ExpressionType)) AndAlso result
                 If Helper.CompareType(Expression.ExpressionType, ExpressionType) = False Then
                     Emitter.EmitBox(Info, Expression.ExpressionType)
                     Emitter.EmitCastClass(Info, ExpressionType)
                 End If
             Else
                 result = Expression.GenerateCode(Info.Clone(Me, True, False, Expression.ExpressionType)) AndAlso result
                 If Helper.CompareType(Expression.ExpressionType, ExpressionType) = False Then
                     Emitter.EmitCastClass(Info, ExpressionType)
                 End If
             End If
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeConverter.vb" startline="1646" endline="1694">
<![CDATA[
 
     Public Shared Function ConvertToUInt64(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object, ByVal ShowErrors As Boolean) As Boolean
         Const DEST As String = "ULong"
 
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CULng(i)
                 Return True
             Case TypeCode.Decimal
                 Dim i As Decimal = CDec(Source)
                 If i >= ULong.MinValue AndAlso i <= ULong.MaxValue Then
                     result = CULng(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Dim i As Long = CLng(Source)
                 If i >= ULong.MinValue AndAlso i <= ULong.MaxValue Then
                     result = CULng(i)
                     Return True
                 End If
             Case TypeCode.Double, TypeCode.Single
                 Dim i As Double = CDbl(Source)
                 If i >= ULong.MinValue AndAlso i <= ULong.MaxValue Then
                     result = CULng(i)
                     Return True
                 End If
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Dim i As ULong = CULng(Source)
                 If i >= ULong.MinValue AndAlso i <= ULong.MaxValue Then
                     result = CULng(i)
                     Return True
                 End If
             Case TypeCode.Char
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, DEST)
             Case TypeCode.DateTime
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", DEST)
             Case TypeCode.String
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, DEST, "String")
             Case TypeCode.DBNull
                 result = 0UL
                 Return True
         End Select
         If ShowErrors = False Then Return False
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, DEST)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1271" endline="1340">
<![CDATA[
 
 
     ''' <summary>
     ''' Returns true if the type has a default property
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function HasDefaultProperty(ByVal Context As BaseObject, ByVal tp As Mono.Cecil.TypeReference, ByRef properties As Mono.Collections.Generic.Collection(Of Mono.Cecil.PropertyReference)) As Boolean
         Dim Compiler As Compiler = Context.Compiler
         Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
         Dim defaultName As String = Nothing
 
         If tp Is Nothing Then Return False
 
         If properties Is Nothing Then properties = New Mono.Collections.Generic.Collection(Of Mono.Cecil.PropertyReference)
         members = Compiler.TypeManager.GetCache(tp).GetAllMembers()
 
         For i As Integer = 0 To members.Count - 1
             Dim p As Mono.Cecil.PropertyReference = TryCast(members(i), Mono.Cecil.PropertyReference)
             Dim pD As PropertyDeclaration
 
             If p Is Nothing Then Continue For
 
             If p.Annotations.Contains(Compiler) Then
                 pD = DirectCast(p.Annotations(Compiler), PropertyDeclaration)
                 If pD.Modifiers.Is(ModifierMasks.Default) Then
                     AddPropertyUnlessSignatureMatches(properties, p)
                 End If
                 Continue For
             End If
 
             Dim p2 As Mono.Cecil.PropertyReference = CecilHelper.FindDefinition(p)
             If p2.Annotations.Contains(Compiler) Then
                 pD = DirectCast(p2.Annotations(Compiler), PropertyDeclaration)
                 If pD.Modifiers.Is(ModifierMasks.Default) Then
                     AddPropertyUnlessSignatureMatches(properties, p)
                 End If
                 Continue For
             End If
 
             'OPTIMIZATION
             Dim pDef As Mono.Cecil.TypeDefinition = CecilHelper.FindDefinition(p.DeclaringType)
             Dim defaultAttribute As Mono.Cecil.CustomAttribute = Helper.GetDefaultMemberAttribute(Compiler, pDef)
             If defaultAttribute Is Nothing Then Continue For
             If defaultAttribute.ConstructorArguments.Count <> 1 Then Continue For
             If TypeOf defaultAttribute.ConstructorArguments(0).Value Is String = False Then Continue For
             defaultName = DirectCast(defaultAttribute.ConstructorArguments(0).Value, String)
 
             If Helper.CompareNameOrdinal(p.Name, defaultName) Then
                 AddPropertyUnlessSignatureMatches(properties, p)
             End If
         Next
 
         If Helper.CompareType(Compiler.TypeCache.System_Object, tp) = False Then
             If CecilHelper.IsInterface(tp) Then
                 Dim interfaces As Mono.Collections.Generic.Collection(Of TypeReference) = CecilHelper.GetInterfaces(tp, False)
                 Dim result As Boolean
                 If interfaces IsNot Nothing Then
                     For i As Integer = 0 To interfaces.Count - 1
                         result = HasDefaultProperty(Context, interfaces(i), properties) OrElse result
                     Next
                 End If
                 Return properties.Count > 0
             Else
                 Return HasDefaultProperty(Context, CecilHelper.GetBaseType(tp), properties)
             End If
         End If
 
         Return properties.Count > 0
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="622" endline="679">
<![CDATA[
 
     Sub SelectMostApplicable()
         'Find most applicable methods.
         Dim expandedArgumentTypes(m_Candidates.Count - 1)() As Mono.Cecil.TypeReference
 
         For i As Integer = 0 To m_Candidates.Count - 1
             If m_Candidates(i).RemovedBy IsNot Nothing Then Continue For
 
             For j As Integer = i + 1 To m_Candidates.Count - 1
                 If m_Candidates(j) Is Nothing Then Continue For
                 If m_Candidates(j).RemovedBy IsNot Nothing Then Continue For
 
                 Dim candidateI As MemberCandidate = m_Candidates(i)
                 Dim candidateJ As MemberCandidate = m_Candidates(j)
 
                 Helper.Assert(candidateI.ExactArguments IsNot Nothing)
                 Helper.Assert(candidateJ.ExactArguments IsNot Nothing)
 
                 Dim a, b As Boolean
 
                 If candidateI.IsParamArray Then
                     If candidateI.ApplicableExpandedAndUnexpanded Then
                         expandedArgumentTypes(i) = candidateI.DefinedParametersTypes
                     Else
                         expandedArgumentTypes(i) = candidateI.TypesInInvokedOrder
                     End If
                 Else
                     expandedArgumentTypes(i) = candidateI.DefinedParametersTypes
                 End If
                 If candidateJ.IsParamArray Then
                     If candidateJ.ApplicableExpandedAndUnexpanded Then
                         expandedArgumentTypes(j) = candidateJ.DefinedParametersTypes
                     Else
                         expandedArgumentTypes(j) = candidateJ.TypesInInvokedOrder
                     End If
                 Else
                     expandedArgumentTypes(j) = candidateJ.DefinedParametersTypes
                 End If
 
                 a = Helper.IsFirstMoreApplicable(m_Parent, Arguments.Arguments, expandedArgumentTypes(i), expandedArgumentTypes(j))
                 b = Helper.IsFirstMoreApplicable(m_Parent, Arguments.Arguments, expandedArgumentTypes(j), expandedArgumentTypes(i))
 
                 If a Xor b Then
                     If a = False Then
                         Log("NOT MOST APPLICABLE
                         m_Candidates(i).RemovedBy = "SelectMostApplicable"
                         Exit For
                     Else
                         Log("NOT MOST APPLICABLE
                         m_Candidates(j).RemovedBy = "SelectMostApplicable"
                     End If
                 Else
                     Log("EQUALLY APPLICABLE
                 End If
             Next
         Next
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="271" endline="358">
<![CDATA[
 
     Public Shared Function InflateType(ByVal original As TypeReference, ByVal container As TypeReference) As TypeReference
         Dim spec As TypeSpecification = TryCast(original, TypeSpecification)
         Dim array As ArrayType = TryCast(original, ArrayType)
         Dim reference As ByReferenceType = TryCast(original, ByReferenceType)
         Dim genericType As GenericInstanceType = TryCast(original, GenericInstanceType)
         Dim originalDef As TypeDefinition = TryCast(original, TypeDefinition)
         Dim parameters As Mono.Collections.Generic.Collection(Of GenericParameter)
         Dim arguments As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim genericCollection As GenericInstanceType = TryCast(container, GenericInstanceType)
         Dim containerDef As TypeDefinition
 
         If genericCollection Is Nothing Then
             Return original
             Throw New ArgumentException("The type to inflate with isn't generic.")
         End If
 
         If originalDef IsNot Nothing Then
             If originalDef.GenericParameters.Count = 0 Then Return original
             Dim result As New GenericInstanceType(originalDef)
             For i As Integer = 0 To originalDef.GenericParameters.Count - 1
                 Dim tG As GenericParameter = originalDef.GenericParameters(i)
                 If tG.Owner Is originalDef Then
                     result.GenericArguments.Add(InflateType(originalDef.GenericParameters(i), container))
                 Else
                     result.GenericArguments.Add(originalDef.GenericParameters(i))
                 End If
             Next
             Return result
         End If
 
         containerDef = CecilHelper.FindDefinition(container)
 
         If containerDef IsNot Nothing Then
             parameters = containerDef.GenericParameters
         Else
             parameters = genericCollection.ElementType.GenericParameters
         End If
         arguments = genericCollection.GenericArguments
 
         If parameters.Count <> arguments.Count Then
             Throw New System.ArgumentException("Parameters and Arguments must have the same number of elements.")
         End If
 
         Dim genParam As GenericParameter = TryCast(original, GenericParameter)
         If genParam IsNot Nothing Then
             If Not TypeOf genParam.Owner Is TypeReference Then Return genParam
             Helper.Assert(genParam.Position < arguments.Count)
             Return arguments.Item(genParam.Position)
         End If
 
         If genericType IsNot Nothing Then
             Dim result As New GenericInstanceType(genericType.ElementType)
             'originalDef = CecilHelper.FindDefinition(original)
             'For i As Integer = 0 To originalDef.GenericParameters.Count - 1
             '    For j As Integer = 0 To parameters.Count - 1
             '        If parameters(j) Is originalDef.GenericParameters(i) Then
             '            result.GenericArguments.Add(InflateType(originalDef.GenericParameters(i), container))
             '            Exit For
             '        End If
             '    Next
             'Next
             For i As Integer = 0 To genericType.GenericArguments.Count - 1
                 result.GenericArguments.Add(InflateType(genericType.GenericArguments(i), container))
             Next
             'Helper.Assert(result.GenericArguments.Count = parameters.Count)
             Return result
         End If
 
         If spec IsNot Nothing Then
             Dim resolved As TypeReference = InflateType(spec.ElementType, container)
 
             If resolved Is spec.ElementType Then
                 Return spec
             End If
 
 
             If array IsNot Nothing Then
                 Return New ArrayType(resolved, array.Dimensions.Count)
             ElseIf reference IsNot Nothing Then
                 Return New ByReferenceType(resolved)
             Else
                 Throw New System.NotImplementedException()
             End If
         Else
             Return original
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="6210" endline="6308">
<![CDATA[
     ''' <summary>
     ''' ClassDeclaration  
     '''	[  Attributes  ]  [  ClassModifier+  ]  "Class"  Identifier  [  TypeParameters  ]  StatementTerminator
     '''	[  ClassBase  ]
     '''	[  TypeImplementsClause+  ]
     '''	[  ClassMemberDeclaration+  ]
     '''	"End" "Class" StatementTerminator
     ''' 
     ''' ClassBase 
     ''' </summary>
     ''' <param name="Parent">Should be the declaring type of the assembly itself it is not a nested type.</param>
     ''' <param name="Attributes"></param>
     ''' <param name="Namespace"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseClassDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As ClassDeclaration
         Dim result As ClassDeclaration
         Dim partialType As PartialTypeDeclaration
 
         Dim m_Attributes As Attributes
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim m_TypeParameters As TypeParameters
         Dim m_Inherits As NonArrayTypeName
         Dim m_DeclaringType As TypeDeclaration
 
         m_DeclaringType = TryCast(Parent, TypeDeclaration)
         Helper.Assert(m_DeclaringType IsNot Nothing OrElse TypeOf Parent Is AssemblyDeclaration)
 
         m_Attributes = Attributes
         m_Modifiers = ParseModifiers(ModifierMasks.ClassModifiers)
 
         tm.AcceptIfNotInternalError(KS.Class)
 
         m_Identifier = ParseIdentifier(CType(Nothing, ParsedObject))
         If m_Identifier Is Nothing Then
             ShowIdentifierExpected(tm.CurrentLocation())
             Return Nothing
         End If
 
         If tm.AcceptEndOfStatement = False Then
             m_TypeParameters = ParseTypeParameters(Nothing)
             If m_TypeParameters Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_TypeParameters = Nothing
         End If
 
         'Here we have enough information to know if it's a partial type or not
         partialType = GetPartialType(Parent, m_Identifier, m_TypeParameters, m_Modifiers, True, [Namespace])
 
         result = TryCast(partialType, ClassDeclaration)
         If result Is Nothing Then
             If partialType IsNot Nothing Then
                 Helper.AddError(tm.Compiler, tm.CurrentLocation, "Partial types must be either all classes or all structures.")
             Else
                 'Error message has already been shown
             End If
             Return Nothing
         End If
 
         m_Identifier.Parent = result
         If m_TypeParameters IsNot Nothing Then
             m_TypeParameters.Parent = result
         End If
 
         If tm.Accept(KS.Inherits) Then
             m_Inherits = ParseNonArrayTypeName(result)
             If m_Inherits Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_Inherits = Nothing
         End If
         If m_Inherits IsNot Nothing Then result.AddInheritsClause(m_Inherits)
 
         If TypeImplementsClauses.IsMe(tm) Then
             result.Implements = ParseTypeImplementsClauses(result)
             If result.Implements Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         End If
 
         If ParseTypeMembers(result) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If tm.AcceptIfNotError(KS.End, KS.Class) = False Then
             tm.GotoNewline(False)
         End If
         If tm.AcceptEndOfStatement(, True) = False Then
             tm.GotoNewline(True)
         End If
 
         If Attributes IsNot Nothing Then
             If result.CustomAttributes IsNot Nothing Then
                 result.CustomAttributes.AddRange(Attributes)
             Else
                 result.CustomAttributes = Attributes
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="69" endline="124">
<![CDATA[
 
     Public Shared Function GetMembers(ByVal Type As Mono.Cecil.TypeReference) As Mono.Collections.Generic.Collection(Of MemberReference)
         Dim tD As Mono.Cecil.TypeDefinition
         Dim result As Mono.Collections.Generic.Collection(Of MemberReference)
 
         Dim tG As Mono.Cecil.GenericParameter = TryCast(Type, GenericParameter)
         If tG IsNot Nothing Then Return GetMembers(tG)
 
         Dim arr As Mono.Cecil.ArrayType = TryCast(Type, ArrayType)
         If arr IsNot Nothing Then
             result = New Mono.Collections.Generic.Collection(Of MemberReference)()
             For Each member As MemberReference In GetMembers(BaseObject.m_Compiler.TypeCache.System_Array)
                 'result.Add(GetCorrectMember(member, Type))
                 result.Add(member)
             Next
             Return result
         End If
 
         tD = FindDefinition(Type)
 
         result = New Mono.Collections.Generic.Collection(Of MemberReference)(tD.Events.Count + tD.Methods.Count + tD.Properties.Count + tD.NestedTypes.Count + tD.Fields.Count)
 
         For i As Integer = 0 To tD.Events.Count - 1
             Dim item As EventDefinition = tD.Events(i)
             'I don't think events need to call GetCorrectMember
             result.Add(item)
         Next
 
         For i As Integer = 0 To tD.Methods.Count - 1
             Dim item As MethodReference = tD.Methods(i)
             If Helper.CompareType(item.DeclaringType, Type) = False Then item = GetCorrectMember(item, Type)
             result.Add(item)
         Next
 
         For i As Integer = 0 To tD.Properties.Count - 1
             Dim pd As PropertyDefinition = tD.Properties(i)
             Dim item As PropertyReference = pd
             If Helper.CompareType(item.DeclaringType, Type) = False Then item = GetCorrectMember(pd, Type)
             result.Add(item)
         Next
 
         For i As Integer = 0 To tD.NestedTypes.Count - 1
             Dim item As TypeReference = tD.NestedTypes(i)
             If Helper.CompareType(item.DeclaringType, Type) = False Then item = GetCorrectMember(item, Type)
             result.Add(item)
         Next
 
         For i As Integer = 0 To tD.Fields.Count - 1
             Dim fd As FieldDefinition = tD.Fields(i)
             Dim item As FieldReference = fd
             If Helper.CompareType(item.DeclaringType, Type) = False Then item = GetCorrectMember(fd, Type)
             result.Add(item)
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4493" endline="4523">
<![CDATA[
 
     Shared Function GetPropertyAttributes(ByVal [Property] As Mono.Cecil.PropertyReference) As Mono.Cecil.MethodAttributes
         Dim result As Mono.Cecil.MethodAttributes
         Dim getA, setA As Mono.Cecil.MethodAttributes
         Dim getM, setM As Mono.Cecil.MethodDefinition
         Dim prop As Mono.Cecil.PropertyDefinition = CecilHelper.FindDefinition([Property])
 
         getM = CecilHelper.FindDefinition(prop.GetMethod)
         setM = CecilHelper.FindDefinition(prop.SetMethod)
 
         Helper.Assert(getM IsNot Nothing OrElse setM IsNot Nothing)
 
         If getM IsNot Nothing Then
             getA = getM.Attributes
         End If
 
         If setM IsNot Nothing Then
             setA = setM.Attributes
         End If
 
         result = setA Or getA
 
         Dim visibility As Mono.Cecil.MethodAttributes
         visibility = result And Mono.Cecil.MethodAttributes.MemberAccessMask
         If visibility = Mono.Cecil.MethodAttributes.MemberAccessMask Then
             visibility = Mono.Cecil.MethodAttributes.Public
             result = (result And (Not Mono.Cecil.MethodAttributes.MemberAccessMask)) Or visibility
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2671" endline="2714">
<![CDATA[
 
     Shared Function GetMostEncompassedType(ByVal Compiler As Compiler, ByVal Types As Generic.List(Of TypeReference)) As TypeReference
         Dim result() As Boolean
 
         '?	If an intrinsic widening conversion exists from a type A to a type B, and if neither A nor B are interfaces, then A is encompassed by B, and B encompasses A.
         '?	The most encompassing type in a set of types is the one type that encompasses all other types in the set. 
         '   If no single type encompasses all other types, then the set has no most encompassing type. 
         '   In intuitive terms, the most encompassing type is the ?largest? type in the set?the one type to 
         '   which each of the other types can be converted through a widening conversion.
         '?	The most encompassed type in a set of types is the one type that is encompassed by all other types in the set. 
         '   If no single type is encompassed by all other types, then the set has no most encompassed type. 
         '   In intuitive terms, the most encompassed type is the ?smallest? type in the set?the one type that 
         '   can be converted to each of the other types through a narrowing conversion.
 
         If Types Is Nothing OrElse Types.Count = 0 Then Return Nothing
         If Types.Count = 1 Then Return Types(0)
 
         ReDim result(Types.Count - 1)
         For i As Integer = 0 To result.Length - 1
             result(i) = True
         Next
 
         For i As Integer = 0 To result.Length - 1
             For j As Integer = i + 1 To result.Length - 1
                 If result(j) AndAlso IsFirstEncompassingSecond(Compiler, Types(i), Types(j)) Then
                     result(j) = False
                 ElseIf result(i) AndAlso IsFirstEncompassingSecond(Compiler, Types(j), Types(i)) Then
                     result(i) = False
                 End If
             Next
         Next
 
         Dim count As Integer
         Dim index As Integer
         For i As Integer = 0 To result.Length - 1
             If result(i) Then
                 count += 1
                 index = i
             End If
         Next
 
         If count <> 1 Then Return Nothing
         Return Types(index)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2552" endline="2639">
<![CDATA[
 
 #End Region
 
 #Region "   Keyboard shortcuts "
 
     Private Sub frmMain_KeyUp(ByVal sender As Object, _
     ByVal e As System.Windows.Forms.KeyEventArgs) Handles MyBase.KeyUp
 
         If Not mFileLoaded Then Exit Sub
 
         Select Case e.KeyCode
 
             Case Keys.Home     'Keys.Home
                 'Start selection
                 StartSelection()
 
             Case Keys.End     'Keys.End - end Selection
                 'End Selection
                 EndSelection()
 
             Case Keys.Delete    'Keys.Delete
                 If e.Control Then           'Control Delete
                     If lvPositions.Items.Count = 0 Then Exit Sub
                     lvPositions.Items.RemoveAt(lvPositions.Items.Count - 1)
                 End If
 
             Case Keys.Space     'Keys.Space
                 If mPlayer.playState <> 2 Then
                     mPlayer.Ctlcontrols.pause()
                 Else
                     mPlayer.Ctlcontrols.play()
                 End If
                 mDisplayControl.Focus()
 
             Case Keys.Left        'Left Arrow
                 If e.Control Then           'Control Left Arrow
                     mPlayer.Ctlcontrols.currentPosition -= 2
                 End If
 
             Case Keys.Right        'Right Arrow
                 If e.Control Then           'Control Right Arrow
                     mPlayer.Ctlcontrols.currentPosition += 2
                 End If
 
             Case Keys.Up        'Up Arrow
                 If e.Control Then
                     'Control+Up = Increase speed
                     ToggleFastForward()
                 ElseIf e.Alt Then
                     'change tuner resolution - coarser
                     If lvPositions.SelectedItems.Count = 1 Then
                         With FineResolution
                             Dim NewRes As Single = .Value
                             NewRes += CSng(0.01)
                             If NewRes <= .Maximum Then .Value = NewRes
                         End With
                     End If
                 Else
                     'Change volume
                     If mPlayer.playState = WMPLib.WMPPlayState.wmppsPlaying Then MPcontrols.IncreaseVolume()
                 End If
 
             Case Keys.Down       'Down Arrow
                 If e.Control Then
                     'Control+Down = Decrease speed
                     ToggleFastReverse()
                 ElseIf e.Alt Then
                     'change tuner resolution - finer
                     If lvPositions.SelectedItems.Count = 1 Then
                         With FineResolution
                             Dim NewRes As Single = .Value
                             NewRes -= CSng(0.01)
                             If NewRes >= .Minimum Then .Value = NewRes
                         End With
                     End If
                 Else
                     'Change volume
                     If mPlayer.playState = WMPLib.WMPPlayState.wmppsPlaying Then MPcontrols.DecreaseVolume()
                 End If
 
             Case Keys.Enter
                 If e.Alt Then
                     mPlayer.fullScreen = True
                 End If
 
         End Select
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmSrvcMngr.vb" startline="291" endline="309">
<![CDATA[
 
     Private Sub BtnDelete_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles BtnDelete.Click, ItmDelete.Click
 
         If MessageBox.Show("Are you sure you want to delete the selected Windows service?", "Vista Services Optimizer", MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation, MessageBoxDefaultButton.Button2, 0, False) = Windows.Forms.DialogResult.Yes Then
 
             Try
                 SrvcCntrl.ServiceName = (ServiceName)
                 SrvcCntrl.Stop()
                 SrvcCntrl.WaitForStatus(ServiceProcess.ServiceControllerStatus.Stopped, TimeSpan.FromSeconds(3))
             Catch ex As InvalidOperationException
             End Try
 
             Shell("sc delete " & ServiceName, AppWinStyle.Hide, True, 1000)
             MessageBox.Show("The selected Windows service deleted successfully.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Information, MessageBoxDefaultButton.Button1, 0, False)
             Call Load_Services()
 
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="182" endline="193">
<![CDATA[
     End Property
 
     Private Sub LoadProjectConstants()
         'Set the project level defines
         Dim Constant As ConditionalConstant
         For Each def As Define In Compiler.CommandLine.Define
             Constant = New ConditionalConstant(def.Symbol, def.ObjectValue)
             m_ProjectConstants.Add(Constant)
         Next
 
         ResetCurrentConstants()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="216" endline="227">
<![CDATA[
     End Property
 
     ReadOnly Property AsSpecial() As KS
         Get
             If IsKeyword() Then
                 Return Keyword
             ElseIf IsSymbol() Then
                 Return Symbol
             Else
                 Return KS.None
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="59" endline="67">
<![CDATA[
 
     Private Function GetValueType(ByVal tp As Mono.Cecil.TypeReference) As Mono.Cecil.TypeReference
         Helper.Assert(tp IsNot Nothing)
         If TypeOf tp Is ByReferenceType Then
             Return tp.GetElementType
         Else
             Return tp
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3302" endline="3312">
<![CDATA[
 
     Private Sub lvPositions_GotFocus(ByVal sender As Object, _
     ByVal e As System.EventArgs) Handles lvPositions.GotFocus, lvFiles.GotFocus
 
         Dim ListView As ListView = DirectCast(sender, ListView)
         If ListView.Items.Count = 0 Then Exit Sub
         If ListView.SelectedIndices.Count = 0 Then
             ListView.Items(0).Selected = True
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="3992" endline="4004">
<![CDATA[
 
     Overloads Shared Function ToString(ByVal Types As Type()) As String
         Dim result As String = ""
         Dim sep As String = ""
 
         For Each t As Type In Types
             Helper.Assert(t IsNot Nothing)
             result &= sep & t.ToString
             sep = ", "
         Next
 
         Return "{" & result & "}"
     End Function
]]>
</clone_fragment>
<clone_fragment file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="60" endline="89">
<![CDATA[
     Public Shared Sub Main(ByVal args As String())
         Console.WriteLine("Chapter 2 example 8
 
         ' step 1
         Dim Document As New Document()
 
         ' step 2
         ' we create a writer that listens to the document
         ' and directs a PDF-stream to a file
         Dim Writer As PdfWriter = PdfWriter.getInstance(Document, New FileOutputStream("Chap0208.pdf"))
 
         ' step 3
         Document.open()
 
         ' step 4
         ' we add some content
         Dim text As String = "Some.text.to.show.the.splitting.action.of.the.interface."
         Dim Split As New Chap0208()
         Dim ck As New Chunk(text, FontFactory.getFont(FontFactory.HELVETICA, 24))
         Dim p As New Paragraph(24, ck)
         Document.add(New Paragraph("Normal split."))
         Document.add(p)
         ck = New Chunk(text, FontFactory.getFont(FontFactory.HELVETICA, 24))
         ck.setSplitCharacter(Split)
         p = New Paragraph(24, ck)
         Document.add(New Paragraph("The dot '.' is the split character."))
         Document.add(p)
         ' step 5
         Document.close()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="566" endline="577">
<![CDATA[
 
     Shared Function GetInstanceConstructors(ByVal type As Mono.Cecil.TypeReference) As Mono.Collections.Generic.Collection(Of Mono.Cecil.MethodReference)
         Dim result As New Mono.Collections.Generic.Collection(Of Mono.Cecil.MethodReference)
         Dim ctors As Mono.Collections.Generic.Collection(Of MethodReference) = CecilHelper.GetConstructors(type)
 
         For i As Integer = 0 To ctors.Count - 1
             Dim ctor As Mono.Cecil.MethodReference = DirectCast(ctors(i), Mono.Cecil.MethodReference)
             If Helper.IsShared(ctor) = False Then result.Add(ctor)
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\AboutBox.cs" startline="27" endline="47">
<![CDATA[
 
         #region Assembly Attibute Accessors
 
         public string AssemblyTitle
         {
             get
             {
                 // Get all Title attributes on this assembly
                 object[] attributes = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(AssemblyTitleAttribute), false);
                 // If there is at least one Title attribute
                 if (attributes.Length > 0)
                 {
                     // Select the first one
                     AssemblyTitleAttribute titleAttribute = (AssemblyTitleAttribute)attributes[0];
                     // If it is not an empty string, return it
                     if (titleAttribute.Title != "")
                         return titleAttribute.Title;
                 }
                 // If there was no Title attribute, or if the Title attribute was the empty string, return the .exe name
                 return System.IO.Path.GetFileNameWithoutExtension(Assembly.GetExecutingAssembly().CodeBase);
             }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmGameMode.vb" startline="218" endline="227">
<![CDATA[
 
     Private Sub ChkPrinter_CheckedChanged(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles ChkPrinter.CheckedChanged
 
         If ChkPrinter.Checked = True Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Printer", 1, Microsoft.Win32.RegistryValueKind.DWord)
         ElseIf ChkPrinter.Checked = False Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Printer", 0, Microsoft.Win32.RegistryValueKind.DWord)
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmGameMode.vb" startline="228" endline="237">
<![CDATA[
 
     Private Sub ChkScanner_CheckedChanged(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles ChkScanner.CheckedChanged
 
         If ChkScanner.Checked = True Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Scanner", 1, Microsoft.Win32.RegistryValueKind.DWord)
         ElseIf ChkScanner.Checked = False Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Scanner", 0, Microsoft.Win32.RegistryValueKind.DWord)
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmGameMode.vb" startline="238" endline="247">
<![CDATA[
 
     Private Sub ChkTabletPC_CheckedChanged(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles ChkTabletPC.CheckedChanged
 
         If ChkTabletPC.Checked = True Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "TabletPC", 1, Microsoft.Win32.RegistryValueKind.DWord)
         ElseIf ChkTabletPC.Checked = False Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "TabletPC", 0, Microsoft.Win32.RegistryValueKind.DWord)
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmGameMode.vb" startline="248" endline="257">
<![CDATA[
 
     Private Sub ChkThemes_CheckedChanged(ByVal sender As Object, ByVal e As System.EventArgs) Handles ChkThemes.CheckedChanged
 
         If ChkThemes.Checked = True Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Themes", 1, Microsoft.Win32.RegistryValueKind.DWord)
         ElseIf ChkThemes.Checked = False Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Themes", 0, Microsoft.Win32.RegistryValueKind.DWord)
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmGameMode.vb" startline="258" endline="267">
<![CDATA[
 
     Private Sub ChkAero_CheckedChanged(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles ChkAero.CheckedChanged
 
         If ChkAero.Checked = True Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Aero", 1, Microsoft.Win32.RegistryValueKind.DWord)
         ElseIf ChkAero.Checked = False Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Aero", 0, Microsoft.Win32.RegistryValueKind.DWord)
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmGameMode.vb" startline="268" endline="277">
<![CDATA[
 
     Private Sub ChkNetShare_CheckedChanged(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles ChkNetShare.CheckedChanged
 
         If ChkNetShare.Checked = True Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "NetShare", 1, Microsoft.Win32.RegistryValueKind.DWord)
         ElseIf ChkNetShare.Checked = False Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "NetShare", 0, Microsoft.Win32.RegistryValueKind.DWord)
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmGameMode.vb" startline="278" endline="287">
<![CDATA[
 
     Private Sub ChkWinSearch_CheckedChanged(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles ChkWinSearch.CheckedChanged
 
         If ChkWinSearch.Checked = True Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "WinSearch", 1, Microsoft.Win32.RegistryValueKind.DWord)
         ElseIf ChkWinSearch.Checked = False Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "WinSearch", 0, Microsoft.Win32.RegistryValueKind.DWord)
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmGameMode.vb" startline="288" endline="297">
<![CDATA[
 
     Private Sub ChkMediaCntr_CheckedChanged(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles ChkMediaCntr.CheckedChanged
 
         If ChkMediaCntr.Checked = True Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "MediaCntr", 1, Microsoft.Win32.RegistryValueKind.DWord)
         ElseIf ChkMediaCntr.Checked = False Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "MediaCntr", 0, Microsoft.Win32.RegistryValueKind.DWord)
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmGameMode.vb" startline="298" endline="307">
<![CDATA[
 
     Private Sub ChkWinUpdate_CheckedChanged(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles ChkWinUpdate.CheckedChanged
 
         If ChkWinUpdate.Checked = True Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "WinUpdate", 1, Microsoft.Win32.RegistryValueKind.DWord)
         ElseIf ChkWinUpdate.Checked = False Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "WinUpdate", 0, Microsoft.Win32.RegistryValueKind.DWord)
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmGameMode.vb" startline="308" endline="317">
<![CDATA[
 
     Private Sub ChkDefrag_CheckedChanged(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles ChkDefrag.CheckedChanged
 
         If ChkDefrag.Checked = True Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Defrag", 1, Microsoft.Win32.RegistryValueKind.DWord)
         ElseIf ChkDefrag.Checked = False Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Defrag", 0, Microsoft.Win32.RegistryValueKind.DWord)
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmGameMode.vb" startline="318" endline="327">
<![CDATA[
 
     Private Sub ChkDiagnostics_CheckedChanged(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles ChkDiagnostics.CheckedChanged
 
         If ChkDiagnostics.Checked = True Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Diagnostics", 1, Microsoft.Win32.RegistryValueKind.DWord)
         ElseIf ChkDiagnostics.Checked = False Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Diagnostics", 0, Microsoft.Win32.RegistryValueKind.DWord)
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmGameMode.vb" startline="328" endline="337">
<![CDATA[
 
     Private Sub ChkOther_CheckedChanged(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles ChkOther.CheckedChanged
 
         If ChkOther.Checked = True Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Other", 1, Microsoft.Win32.RegistryValueKind.DWord)
         ElseIf ChkOther.Checked = False Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Other", 0, Microsoft.Win32.RegistryValueKind.DWord)
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AliasClause.vb" startline="113" endline="186">
<![CDATA[
     End Property
 
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim arraytype As Mono.Cecil.TypeReference = Info.DesiredType
         Dim elementtype As Mono.Cecil.TypeReference = CecilHelper.GetElementType(arraytype)
         Dim tmpvar As Mono.Cecil.Cil.VariableDefinition = Emitter.DeclareLocal(Info, Helper.GetTypeOrTypeBuilder(Compiler, arraytype))
         Dim elementInfo As EmitInfo = Info.Clone(Me, True, False, elementtype)
         Dim indexInfo As EmitInfo = Info.Clone(Me, True, False, Compiler.TypeCache.System_Int32)
 
         'Create the array.
         ArrayCreationExpression.EmitArrayCreation(Info, arraytype, m_Elements)
 
         'Save it into a temporary variable.
         Emitter.EmitStoreVariable(Info, tmpvar)
 
         'Calculate the total number of elements.
         Dim elements As Integer = 1
         For i As Integer = 0 To m_Elements.Count - 1
             elements *= m_Elements(i)
         Next
         If m_Elements.Count = 0 AndAlso elements = 1 Then elements = 0
 
         'Create a list of the current indices.
         Dim indices As New Generic.List(Of Integer)
         For i As Integer = 0 To m_Elements.Count - 1
             indices.Add(0)
         Next
 
         'Get the set method, if it is a multidimensional array.
         Dim method As Mono.Cecil.MethodReference = Nothing
         If m_Elements.Count > 1 Then
             method = GetSetMethod(Compiler, arraytype)
         End If
 
         'Store every element into its index in the array.
         For i As Integer = 1 To elements
             'Load the array variable.
             Emitter.EmitLoadVariable(Info, tmpvar)
             'Load all the indices.
             For j As Integer = 0 To indices.Count - 1
                 Emitter.EmitLoadI4Value(indexInfo, indices(j))
             Next
             If CecilHelper.IsValueType(elementtype) AndAlso CecilHelper.IsPrimitive(Compiler, elementtype) = False AndAlso Helper.IsEnum(Compiler, elementtype) = False Then
                 Emitter.EmitLoadElementAddress(Info, elementtype, arraytype)
             End If
             'Get the element expression.
             Dim elementExpression As Expression
             elementExpression = GetRegularInitializer(indices)
             'Generate the element expression
             result = elementExpression.GenerateCode(elementInfo) AndAlso result
             'Store the element in the arry.
             If m_Elements.Count > 1 Then
                 Emitter.EmitCallVirt(elementInfo, method)
             Else
                 Emitter.EmitStoreElement(elementInfo, elementtype, arraytype)
             End If
             'Increment the indices.
             For j As Integer = indices.Count - 1 To 0 Step -1
                 If indices(j) + 1 = m_Elements(j) Then
                     indices(j) = 0
                 Else
                     indices(j) += 1
                     Exit For
                 End If
             Next
         Next
 
         'Load the final array onto the stack.
         Emitter.EmitLoadVariable(Info, tmpvar)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeConverter.vb" startline="1269" endline="1317">
<![CDATA[
 
     Public Shared Function ConvertToInt32(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object, ByVal ShowErrors As Boolean) As Boolean
         Const DEST As String = "Integer"
 
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CInt(i)
                 Return True
             Case TypeCode.Decimal
                 Dim i As Decimal = CDec(Source)
                 If i >= Integer.MinValue AndAlso i <= Integer.MaxValue Then
                     result = CInt(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Dim i As Long = CLng(Source)
                 If i >= Integer.MinValue AndAlso i <= Integer.MaxValue Then
                     result = CInt(i)
                     Return True
                 End If
             Case TypeCode.Double, TypeCode.Single
                 Dim i As Double = CDbl(Source)
                 If i >= Integer.MinValue AndAlso i <= Integer.MaxValue Then
                     result = CInt(i)
                     Return True
                 End If
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Dim i As ULong = CULng(Source)
                 If i >= Integer.MinValue AndAlso i <= Integer.MaxValue Then
                     result = CInt(i)
                     Return True
                 End If
             Case TypeCode.Char
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, DEST)
             Case TypeCode.DateTime
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", DEST)
             Case TypeCode.String
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, DEST, "String")
             Case TypeCode.DBNull
                 result = 0I
                 Return True
         End Select
         If ShowErrors = False Then Return False
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, DEST)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeConverter.vb" startline="1220" endline="1268">
<![CDATA[
 
     Public Shared Function ConvertToInt16(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object, ByVal ShowErrors As Boolean) As Boolean
         Const DEST As String = "Short"
 
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CShort(i)
                 Return True
             Case TypeCode.Decimal
                 Dim i As Decimal = CDec(Source)
                 If i >= Short.MinValue AndAlso i <= Short.MaxValue Then
                     result = CShort(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Dim i As Long = CLng(Source)
                 If i >= Short.MinValue AndAlso i <= Short.MaxValue Then
                     result = CShort(i)
                     Return True
                 End If
             Case TypeCode.Double, TypeCode.Single
                 Dim i As Double = CDbl(Source)
                 If i >= Short.MinValue AndAlso i <= Short.MaxValue Then
                     result = CShort(i)
                     Return True
                 End If
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Dim i As ULong = CULng(Source)
                 If i >= Short.MinValue AndAlso i <= Short.MaxValue Then
                     result = CShort(i)
                     Return True
                 End If
             Case TypeCode.Char
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, DEST)
             Case TypeCode.DateTime
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", DEST)
             Case TypeCode.String
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, DEST, "String")
             Case TypeCode.DBNull
                 result = 0S
                 Return True
         End Select
         If ShowErrors = False Then Return False
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, DEST)
     End Function
]]>
</clone_fragment>
<clone_fragment file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="530" endline="541">
<![CDATA[
     End Property
 
     Overridable ReadOnly Property IsOneLiner() As Boolean
         Get
             If TypeOf Me.Parent Is CodeBlock Then
                 Return DirectCast(Me.Parent, CodeBlock).IsOneLiner
             ElseIf TypeOf Me.Parent Is Statement Then
                 Return DirectCast(Me.Parent, Statement).IsOneLiner
             Else
                 Return False
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="4397" endline="4405">
<![CDATA[
 
     Private Sub mnuArr_Click(ByVal sender As System.Object, ByVal e As System.EventArgs)
         Dim Filename As String = DirectCast(DirectCast(sender, MenuItem).Tag, String)
         If File.Exists(Filename) Then
             OpenFile(Filename)
         Else
             MsgBox(Replace(mTranslator.LangText(117), "{1}", Filename))
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="170" endline="179">
<![CDATA[
 
     Function IdentiferOrKeywordIdentifier() As String
         If IsKeyword() Then
             Return Identifier
         ElseIf IsIdentifier() Then
             Return Identifier
         Else
             Throw New InternalException()
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="33" endline="42">
<![CDATA[
 
     Public Overrides Function ToString() As String
         If Me.IsIdentifier Then
             Return Me.Identifier
         ElseIf Me.IsKeyword Then
             Return Me.Identifier
         Else
             Return "<Token>"
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\IniFile.vb" startline="37" endline="48">
<![CDATA[
     End Property
 
     Public Function GetString(ByVal Section As String, _
       ByVal Key As String, ByVal [Default] As String) As String
         ' Returns a string from your INI file
         Dim intCharCount As Integer
         Dim objResult As New System.Text.StringBuilder(256)
         intCharCount = GetPrivateProfileString(Section, Key, _
            [Default], objResult, objResult.Capacity, strFilename)
         If intCharCount > 0 Then GetString = _
            Left(objResult.ToString, intCharCount)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="1185" endline="1195">
<![CDATA[
 
     Private Function ExtractUInt(ByVal Value As ULong, ByVal Base As IntegerBase) As UInteger
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUInt(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="1211" endline="1221">
<![CDATA[
 
     Private Function ExtractUShort(ByVal Value As ULong, ByVal Base As IntegerBase) As UShort
         Select Case Base
             Case IntegerBase.Decimal
                 Return CUShort(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CUShort(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\CMPT890\CS VB JS examples\Examples\VB.NET\examples\Chap0209.vb" startline="45" endline="55">
<![CDATA[
     Public Shared Sub Main(ByVal args As String())
         Console.WriteLine("Chapter 8 example 1
 
         Dim document As New com.lowagie.text.Document()
         Dim FileOutputStream As java.io.FileOutputStream
         FileOutputStream = New java.io.FileOutputStream("Chap0801.rtf")
         RtfWriter.getInstance(document, FileOutputStream)
         document.open()
         document.add(New Paragraph("Hello World"))
         document.close()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="59" endline="82">
<![CDATA[
     Public Shared Sub Main(ByVal args As String())
         Console.WriteLine("Chapter 1 example 3
 
         ' step 1
         Dim document As New Document(PageSize.A4.rotate())
 
         ' step 2
         ' we create a writer that listens to the document
         ' and directs a PDF-stream to a file
 
         PdfWriter.getInstance(document, New FileOutputStream("Chap0103.pdf"))
 
         ' step 3
         document.open()
 
         ' step 4
         Dim i As Integer
         For i = 0 To 20
             document.add(New Phrase("Hello World, Hello Sun, Hello Moon, Hello Stars, Hello Sea, Hello Land, Hello People. "))
         Next
 
         ' step 5
         document.close()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\My Project\Application.Designer.vb" startline="25" endline="31">
<![CDATA[
         Public Sub New()
             MyBase.New(Global.Microsoft.VisualBasic.ApplicationServices.AuthenticationMode.Windows)
             Me.IsSingleInstance = true
             Me.EnableVisualStyles = true
             Me.SaveMySettingsOnExit = true
             Me.ShutDownStyle = Global.Microsoft.VisualBasic.ApplicationServices.ShutdownMode.AfterMainFormCloses
         End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmAuto.vb" startline="11" endline="17">
<![CDATA[
     Private Sub FrmCProfile_Load(ByVal sender As Object, ByVal e As System.EventArgs) Handles Me.Load
 
         On Error Resume Next
         HdrMain.Values.Image = New Bitmap(DataDir & "profile.png")
         LnkProfiles.Values.Image = New Bitmap(DataDir & "shield.png")
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1362" endline="1437">
<![CDATA[
 
     ''' <summary>
     ''' Loads a constant value onto the stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Value">The value to emit. Set to DBNull.Value to emit a nothing value.</param>
     ''' <remarks></remarks>
     Overloads Shared Sub EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As Object)
         Helper.Assert(Info.IsRHS, "Not RHS")
         Helper.Assert(Info.DesiredType IsNot Nothing, "No desired type")
 
         If Value Is Nothing Then Value = DBNull.Value
 
         Dim ActualType As Mono.Cecil.TypeReference = CecilHelper.GetType(Info.Compiler, Value)
         Dim ActualTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, ActualType)
         Dim DesiredType As Mono.Cecil.TypeReference = Info.DesiredType
         Dim DesiredTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, DesiredType)
 
 #If EXTENDEDDEBUG Then
         Info.Compiler.Report.WriteLine(String.Format("Emitter.EmitLoadValue (EmitInfo, Object)
 #End If
 
         Select Case ActualTypeCode
             Case TypeCode.DBNull
                 EmitLoadNull(Info)
                 Return
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32
                 EmitLoadValue(Info, CInt(Value))
                 Return
             Case TypeCode.Int64
                 EmitLoadI8Value(Info, CLng(Value))
                 Return
             Case TypeCode.Single
                 Emitter.EmitLoadR4Value(Info, CSng(Value))
                 Return
             Case TypeCode.Double
                 Info.ILGen.Emit(OpCodes.Ldc_R8, CDbl(Value))
                 Return
             Case TypeCode.String
                 Info.ILGen.Emit(OpCodes.Ldstr, CStr(Value))
                 Return
             Case TypeCode.Byte
                 EmitLoadI4Value(Info, CInt(Value), Info.Compiler.TypeCache.System_Byte)
                 Return
             Case TypeCode.UInt16
                 EmitLoadI4Value(Info, CInt(Value), Info.Compiler.TypeCache.System_UInt16)
                 Return
             Case TypeCode.UInt32
                 EmitLoadI4Value(Info, CUInt(Value))
                 Return
             Case TypeCode.UInt64
                 EmitLoadI8Value(Info, CULng(Value))
                 Return
             Case TypeCode.Decimal
                 EmitLoadDecimalValue(Info, CDec(Value))
                 Return
             Case TypeCode.DateTime
                 EmitLoadDateValue(Info, CDate(Value))
                 Return
             Case TypeCode.Char
                 EmitLoadI4Value(Info, Microsoft.VisualBasic.AscW(CChar(Value)), Info.Compiler.TypeCache.System_Char)
                 Return
             Case TypeCode.Boolean
                 If CBool(Value) Then
                     EmitLoadI4Value(Info, 1, Info.Compiler.TypeCache.System_Boolean)
                 Else
                     EmitLoadI4Value(Info, 0, Info.Compiler.TypeCache.System_Boolean)
                 End If
                 Return
             Case Else
                 Info.Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Missed case
                 Helper.Stop()
         End Select
 
         Helper.Stop()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\Properties\Resources.Designer.cs" startline="39" endline="51">
<![CDATA[
         
         /// <summary>
         ///   Returns the cached ResourceManager instance used by this class.
         /// </summary>
         [global
         internal static global
             get {
                 if ((resourceMan == null)) {
                     global
                     resourceMan = temp;
                 }
                 return resourceMan;
             }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2163" endline="2174">
<![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     <Diagnostics.Conditional("DEBUG")> _
     Shared Sub AssertNotNothing(ByVal Value As IEnumerable)
         If Value Is Nothing Then
             Helper.Stop()
         Else
             For Each obj As Object In Value
                 If obj Is Nothing Then Helper.Stop()
             Next
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmDiagnostics.vb" startline="58" endline="80">
<![CDATA[
 
     Private Sub BtnFix_Click(ByVal sender As Object, ByVal e As System.EventArgs) Handles BtnFix.Click
 
         On Error Resume Next
 
         If My.Settings.Snapshots = True Then
 
             Dim RN As Integer = RNumber(10000)
             Dim Snapshot_Name As String = ("snapshot_" & RN.ToString & ".wss")
 
             If File.Exists(SnapshotsDir & Snapshot_Name) = True Then
                 File.SetAttributes((SnapshotsDir & Snapshot_Name), FileAttributes.Normal)
                 File.Delete(SnapshotsDir & Snapshot_Name)
             End If
             Common.Create_Snapshot(Snapshot_Name, "Automatic services snapshot")
         End If
 
         BWFix.RunWorkerAsync()
         FrmProgress.PicProgress.Image = New Bitmap(DataDir & "services_diagnostics.png")
         FrmProgress.LblProgress.Text = "Applying services settings, Please wait..."
         FrmProgress.ShowDialog(Me)
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MyGenerator.vb" startline="156" endline="217">
<![CDATA[
 
     Function GenerateMyApplication() As Boolean
         Dim result As Boolean = True
         Dim _MyApplicationDefine As Define
         Dim _MyApplication As String
 
         _MyApplicationDefine = Compiler.CommandLine.Define("_MYAPPLICATIONTYPE")
         If _MyApplicationDefine Is Nothing Then
             Select Case m_MyType
                 Case MyTypes.Console, MyTypes.WindowsFormsWithCustomSubMain
                     _MyApplication = "Console"
                 Case MyTypes.Windows
                     _MyApplication = "Windows"
                 Case MyTypes.WindowsForms
                     _MyApplication = "WindowsForms"
                 Case Else
                     _MyApplication = String.Empty
             End Select
         Else
             _MyApplication = _MyApplicationDefine.Value
         End If
 
         Dim baseClass As String
         Select Case _MyApplication
             Case "Console"
                 baseClass = "Global.Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase"
             Case "Windows"
                 baseClass = "Global.Microsoft.VisualBasic.ApplicationServices.ApplicationBase"
             Case "WindowsForms"
                 baseClass = "Global.Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase"
             Case Else
                 Return True
         End Select
 
         Code.AppendLine("    <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _")
         Code.AppendLine("    <Global.System.CodeDom.Compiler.GeneratedCode(""MyTemplate"", ""10.0.0.0"")> _")
         Code.AppendLine("    Friend Class MyApplication")
         Code.Append("        Inherits ") 
         'Code.AppendLine("        Public Sub New()")
         'Code.AppendLine("        End Sub")
         If Compiler.CommandLine.Target = CommandLine.Targets.Winexe AndAlso baseClass = "Global.Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase" Then
             Code.AppendLine("        <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Advanced)> _")
             Code.AppendLine("        <Global.System.Diagnostics.DebuggerHidden()> _")
             Code.AppendLine("        <Global.System.STAThread()> _")
             Code.AppendLine("        Friend Shared Sub Main(ByVal Args As String())")
             Code.AppendLine("            Global.System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(Global.Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering)")
             Code.AppendLine("            $GLOBALMY$.MyProject.Application.Run(Args)")
             Code.AppendLine("        End Sub")
         End If
         Code.AppendLine("    End Class")
 
         ProjectCode.AppendLine("        Private Shared ReadOnly m_AppObjectProvider As ThreadSafeObjectProvider(Of $GLOBALMY$.MyApplication) = New ThreadSafeObjectProvider(Of $GLOBALMY$.MyApplication)")
         ProjectCode.AppendLine("        <Global.System.ComponentModel.Design.HelpKeyword(""My.Application"")> _")
         ProjectCode.AppendLine("        Friend Shared ReadOnly Property Application As $GLOBALMY$.MyApplication")
         ProjectCode.AppendLine("            <Global.System.Diagnostics.DebuggerHidden()> _")
         ProjectCode.AppendLine("            Get")
         ProjectCode.AppendLine("                Return m_AppObjectProvider.GetInstance")
         ProjectCode.AppendLine("            End Get")
         ProjectCode.AppendLine("        End Property")
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmDiagnostics.vb" startline="238" endline="273">
<![CDATA[
 
     Private Sub MediaCntr_Diagnostics(ByVal Name As String, ByVal Index As Byte, ByVal Setting As String)
 
         Try
             SrvcCntrl.ServiceName = (Name)
             Dim ChkSrvc As Boolean = SrvcCntrl.CanPauseAndContinue
         Catch ex As InvalidOperationException
             LstServices.Items.Item(Index).Checked = False
             LstServices.Items.Item(Index).SubItems.Item(1).Text = S5
             LstServices.Items.Item(Index).SubItems.Item(1).ForeColor = Color.DimGray
             Exit Sub
         End Try
 
         If My.Settings(Setting) = 1 Then
             If Service_Startup(Name) = 2 Then
                 LstServices.Items.Item(Index).Checked = False
                 LstServices.Items.Item(Index).SubItems.Item(1).Text = S1
                 LstServices.Items.Item(Index).SubItems.Item(1).ForeColor = Color.Green
             Else
                 LstServices.Items.Item(Index).Checked = True
                 LstServices.Items.Item(Index).SubItems.Item(1).Text = S2
                 LstServices.Items.Item(Index).SubItems.Item(1).ForeColor = Color.DarkOrange
             End If
         ElseIf My.Settings(Setting) = 2 Then
             If Service_Startup(Name) = 3 OrElse Service_Startup(Name) = 4 Then
                 LstServices.Items.Item(Index).Checked = False
                 LstServices.Items.Item(Index).SubItems.Item(1).Text = S1
                 LstServices.Items.Item(Index).SubItems.Item(1).ForeColor = Color.Green
             Else
                 LstServices.Items.Item(Index).Checked = True
                 LstServices.Items.Item(Index).SubItems.Item(1).Text = S3
                 LstServices.Items.Item(Index).SubItems.Item(1).ForeColor = Color.DarkOrange
             End If
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Modules\Common.vb" startline="187" endline="252">
<![CDATA[
 
     Friend Function CheckGMProfile() As Boolean
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Printer", 0) = 1 Then
             CheckGMProfile = True
             Exit Function
         End If
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Scanner", 0) = 1 Then
             CheckGMProfile = True
             Exit Function
         End If
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "TabletPC", 0) = 1 Then
             CheckGMProfile = True
             Exit Function
         End If
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Themes", 0) = 1 Then
             CheckGMProfile = True
             Exit Function
         End If
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Aero", 0) = 1 Then
             CheckGMProfile = True
             Exit Function
         End If
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "NetShare", 0) = 1 Then
             CheckGMProfile = True
             Exit Function
         End If
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "WinSearch", 0) = 1 Then
             CheckGMProfile = True
             Exit Function
         End If
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "MediaCntr", 0) = 1 Then
             CheckGMProfile = True
             Exit Function
         End If
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "WinUpdate", 0) = 1 Then
             CheckGMProfile = True
             Exit Function
         End If
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Defrag", 0) = 1 Then
             CheckGMProfile = True
             Exit Function
         End If
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Diagnostics", 0) = 1 Then
             CheckGMProfile = True
             Exit Function
         End If
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Other", 0) = 1 Then
             CheckGMProfile = True
             Exit Function
         End If
 
         CheckGMProfile = False
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmAuto.vb" startline="35" endline="66">
<![CDATA[
 
     Private Sub BtnOptimize_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles BtnOptimize.Click
 
         On Error Resume Next
 
         If GameMode() = False Then
 
             If My.Settings.Snapshots = True Then
 
                 Dim RN As Integer = RNumber(10000)
                 Dim Snapshot_Name As String = ("snapshot_" & RN.ToString & ".wss")
 
                 If File.Exists(SnapshotsDir & Snapshot_Name) = True Then
                     File.SetAttributes((SnapshotsDir & Snapshot_Name), FileAttributes.Normal)
                     File.Delete(SnapshotsDir & Snapshot_Name)
                 End If
 
                 Common.Create_Snapshot(Snapshot_Name, "Automatic services snapshot")
 
             End If
 
             BWAutoTuneUp.RunWorkerAsync()
             FrmProgress.PicProgress.Image = New Bitmap(DataDir & "auto_tuneup.png")
             FrmProgress.LblProgress.Text = "Applying services settings, Please wait..."
             FrmProgress.ShowDialog(FrmMain)
 
         ElseIf GameMode() = True Then
             MessageBox.Show("Automatic TuneUp can not be performed during Gaming Mode.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Information, MessageBoxDefaultButton.Button1, 0, False)
 
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmManual.vb" startline="75" endline="105">
<![CDATA[
 
     Private Sub BtnOptimize_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles BtnOptimize.Click
 
         On Error Resume Next
 
         If GameMode() = False Then
 
             If My.Settings.Snapshots = True Then
 
                 Dim RN As Integer = RNumber(10000)
                 Dim Snapshot_Name As String = ("snapshot_" & RN.ToString & ".wss")
 
                 If File.Exists(SnapshotsDir & Snapshot_Name) = True Then
                     File.SetAttributes((SnapshotsDir & Snapshot_Name), FileAttributes.Normal)
                     File.Delete(SnapshotsDir & Snapshot_Name)
                 End If
 
                 Common.Create_Snapshot(Snapshot_Name, "Automatic services snapshot")
 
             End If
 
             BWManTuneUp.RunWorkerAsync()
             FrmProgress.PicProgress.Image = New Bitmap(DataDir & "manual_tuneup.png")
             FrmProgress.LblProgress.Text = "Applying services settings, Please wait..."
             FrmProgress.ShowDialog(FrmMain)
 
         ElseIf GameMode() = True Then
             MessageBox.Show("Manual TuneUp can not be performed during Gaming Mode.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Information, MessageBoxDefaultButton.Button1, 0, False)
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeConverter.vb" startline="1318" endline="1366">
<![CDATA[
 
     Public Shared Function ConvertToInt64(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object, ByVal ShowErrors As Boolean) As Boolean
         Const DEST As String = "Long"
 
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CLng(i)
                 Return True
             Case TypeCode.Decimal
                 Dim i As Decimal = CDec(Source)
                 If i >= Long.MinValue AndAlso i <= Long.MaxValue Then
                     result = CLng(i)
                     Return True
                 End If
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Dim i As Long = CLng(Source)
                 If i >= Long.MinValue AndAlso i <= Long.MaxValue Then
                     result = CLng(i)
                     Return True
                 End If
             Case TypeCode.Double, TypeCode.Single
                 Dim i As Double = CDbl(Source)
                 If i >= Long.MinValue AndAlso i <= Long.MaxValue Then
                     result = CLng(i)
                     Return True
                 End If
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Dim i As ULong = CULng(Source)
                 If i >= Long.MinValue AndAlso i <= Long.MaxValue Then
                     result = CLng(i)
                     Return True
                 End If
             Case TypeCode.Char
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, DEST)
             Case TypeCode.DateTime
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", DEST)
             Case TypeCode.String
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, DEST, "String")
             Case TypeCode.DBNull
                 result = 0L
                 Return True
         End Select
         If ShowErrors = False Then Return False
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, DEST)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="54" endline="79">
<![CDATA[
     End Property
 
     Public Overrides Function GetConstant(ByRef m_ConstantValue As Object, ByVal lvalue As Object, ByVal rvalue As Object) As Boolean
         If lvalue Is Nothing Then lvalue = 0
         If rvalue Is Nothing Then rvalue = 0
 
         Dim tlvalue, trvalue As Mono.Cecil.TypeReference
         Dim clvalue, crvalue As TypeCode
         tlvalue = CecilHelper.GetType(Compiler, lvalue)
         clvalue = Helper.GetTypeCode(Compiler, tlvalue)
         trvalue = CecilHelper.GetType(Compiler, rvalue)
         crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
         Helper.Assert(Compiler.TypeResolution.IsNumericType(tlvalue) AndAlso Compiler.TypeResolution.IsNumericType(trvalue))
 
         'An exponent operator always returns a double result.
         Select Case clvalue
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, _
              TypeCode.Int64, TypeCode.UInt64, TypeCode.Double, TypeCode.Single, TypeCode.Decimal
                 m_ConstantValue = Math.Pow(CDbl(lvalue), CDbl(rvalue))
             Case Else
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeConverter.vb" startline="881" endline="935">
<![CDATA[
 
     Public Shared Function ConvertToBoolean(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object, ByVal ShowErrors As Boolean) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 result = Source
                 Return True
             Case TypeCode.Byte
                 result = CBool(DirectCast(Source, Byte))
                 Return True
             Case TypeCode.Char
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Char", "Boolean")
             Case TypeCode.DateTime
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", "Boolean")
             Case TypeCode.Decimal
                 result = CBool(DirectCast(Source, Decimal))
                 Return True
             Case TypeCode.Double
                 result = CBool(DirectCast(Source, Double))
                 Return True
             Case TypeCode.Int16
                 result = CBool(DirectCast(Source, Short))
                 Return True
             Case TypeCode.Int32
                 result = CBool(DirectCast(Source, Integer))
                 Return True
             Case TypeCode.Int64
                 result = CBool(DirectCast(Source, Long))
                 Return True
             Case TypeCode.SByte
                 result = CBool(DirectCast(Source, SByte))
                 Return True
             Case TypeCode.Single
                 result = CBool(DirectCast(Source, Single))
                 Return True
             Case TypeCode.String
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Byte", "String")
             Case TypeCode.UInt16
                 result = CBool(DirectCast(Source, UShort))
                 Return True
             Case TypeCode.UInt32
                 result = CBool(DirectCast(Source, UInteger))
                 Return True
             Case TypeCode.UInt64
                 result = CBool(DirectCast(Source, ULong))
                 Return True
             Case TypeCode.DBNull
                 result = CBool(Nothing)
                 Return True
         End Select
         If ShowErrors = False Then Return False
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "Boolean")
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2126" endline="2169">
<![CDATA[
 
     Private Function GetSegmentArray(ByVal Mode As AbstractMediaHandler.Mode) _
         As Segment()
 
         If lvPositions.Items.Count = 0 Then Return Nothing
 
         Dim Segments(lvPositions.Items.Count - 1) As Segment
 
         Select Case Mode
             Case AbstractMediaHandler.Mode.DeleteSelected
                 'Start from zero if the entry does not start from zero
                 Dim Offset As Integer = 1
                 If MinToSec(lvPositions.Items(0).Text) > 0 Then
                     ReDim Segments(lvPositions.Items.Count)
                     Segments(0) = New Segment
                     Segments(0).Start = 0
                     Segments(0).Finish = MinToSec(lvPositions.Items(0).Text)
                     Offset = 0
                 End If
                 Dim i As Integer
                 For i = 1 To lvPositions.Items.Count - 1
                     Segments(i - Offset) = New Segment
                     Segments(i - Offset).Start = MinToSec(lvPositions.Items(i - 1).SubItems(1).Text)
                     Segments(i - Offset).Finish = MinToSec(lvPositions.Items(i).Text)
                 Next
                 If lvPositions.Items(i - 1).SubItems(1).Text = SecToMin(Math.Round(mPlayer.currentMedia.duration, 3)) Then
                     'The tail piece is not needed
                     ReDim Preserve Segments(lvPositions.Items.Count - 1)
                 Else
                     Segments(i - Offset) = New Segment
                     Segments(i - Offset).Start = MinToSec(lvPositions.Items(i - 1).SubItems(1).Text)
                     Segments(i - Offset).Finish = Math.Round(mPlayer.currentMedia.duration, 3)
                 End If
             Case Else
                 For i As Integer = 0 To lvPositions.Items.Count - 1
                     Segments(i) = New Segment
                     Segments(i).Start = MinToSec(lvPositions.Items(i).Text)
                     Segments(i).Finish = MinToSec(lvPositions.Items(i).SubItems(1).Text)
                 Next
         End Select
 
         Return Segments
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Compiler.vb" startline="364" endline="422">
<![CDATA[
 
     Private Function Compile_Resolve() As Boolean
         Dim result As Boolean = True
 
         result = CommandLine.Imports.ResolveCode(ResolveInfo.Default(Me)) AndAlso result
         VerifyConsistency(result, "ResolveCode")
         If result = False Then Return result
 
         result = CommandLine.Files.Resolve(ResolveInfo.Default(Me)) AndAlso result
         VerifyConsistency(result, "Resolve")
         If result = False Then Return result
 
         result = theAss.CreateImplicitTypes AndAlso result
         VerifyConsistency(result, "CreateImplicitTypes")
         If result = False Then Return result
 
         result = theAss.ResolveBaseTypes AndAlso result
         VerifyConsistency(result, "ResolveBaseTypes")
         If result = False Then Return result
 
         result = theAss.ResolveTypeReferences AndAlso result
         VerifyConsistency(result, "ResolveTypeReferences")
         If result = False Then Return result
 
         m_TypeCache.InitInternalVBMembers()
 
         result = theAss.CreateMyGroupMembers AndAlso result
         VerifyConsistency(result, "CreateMyGroupMembers")
         If result = False Then Return result
 
         result = theAss.CreateImplicitMembers AndAlso result
         VerifyConsistency(result, "CreateImplicitMembers")
         If result = False Then Return result
 
         result = theAss.ResolveMembers AndAlso result
         VerifyConsistency(result, "ResolveMembers")
         If result = False Then Return result
 
         result = theAss.DefineConstants AndAlso result
         VerifyConsistency(result, "DefineConstants")
         If result = False Then Return result
 
         result = theAss.DefineOptionalParameters AndAlso result
         VerifyConsistency(result, "DefineOptionalParameters")
         If result = False Then Return result
 
         result = theAss.CreateImplicitSharedConstructors AndAlso result
         VerifyConsistency(result, "CreateImplicitSharedConstructors")
         If result = False Then Return result
 
         result = theAss.ResolveCode(ResolveInfo.Default(Me)) AndAlso result
         VerifyConsistency(result, "ResovleCode")
 
         result = theAss.DefineSecurityDeclarations AndAlso result
         VerifyConsistency(result, "DefineSecurityDeclarations")
         If result = False Then Return result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="127" endline="134">
<![CDATA[
 
     Shared Sub EmitBranchOrLeave(ByVal Info As EmitInfo, ByVal Label As Label, ByVal FromStatement As Statement, ByVal ToStatement As Statement)
         If IsLeaveNecessary(FromStatement, ToStatement) Then
             EmitLeave(Info, Label)
         Else
             EmitBranch(Info, Label)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1353" endline="1361">
<![CDATA[
 
     Shared Sub EmitLoadValueConstantOrValueAddress(ByVal Info As EmitInfo, ByVal Value As Object)
         Helper.Assert(Info.DesiredType IsNot Nothing, "EmitInfo.DesiredType must be set!")
         If CecilHelper.IsByRef(Info.DesiredType) Then
             EmitLoadValueAddress(Info, Value)
         Else
             EmitLoadValue(Info, Value)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\My Project\Settings.Designer.vb" startline="37" endline="54">
<![CDATA[
 #End If
 #End Region
         
         Public Shared ReadOnly Property [Default]() As MySettings
             Get
                 
 #If _MyType = "WindowsForms" Then
                If Not addedHandler Then
                     SyncLock addedHandlerLockObject
                         If Not addedHandler Then
                             AddHandler My.Application.Shutdown, AddressOf AutoSaveSettings
                             addedHandler = True
                         End If
                     End SyncLock
                 End If
 #End If
                 Return defaultInstance
             End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmProfiles.vb" startline="356" endline="405">
<![CDATA[
 
 #End Region
 
 #Region "Apply Profile"
 
     Private Sub BtnApply_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles BtnApply.Click, ItmApply.Click
 
         If GameMode() = False Then
 
             If MessageBox.Show("Are you sure you want to apply the selected services profile?", "Vista Services Optimizer", MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button2, 0, False) = Windows.Forms.DialogResult.Yes Then
 
                 If File.Exists(SelectedProfile) = False Then
                     MessageBox.Show("The selected services profile is missing or corrupted.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
                     Call Check_Profiles()
                     Exit Sub
                 End If
 
                 Dim Reader As New StreamReader(SelectedProfile)
                 Dim Info As String = Reader.ReadToEnd
                 Reader.Close()
 
                 Dim Profile_Info() As String = Info.Split(CChar("!"))
                 UBound(Profile_Info)
 
                 If Not Profile_Info(0).Trim = "1.2" Then
                     MessageBox.Show("The selected services profile is not compatible with" & vbCrLf & "this version of Vista Services Optimizer.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
                     Exit Sub
                 End If
 
                 Try
                     Dim ChkProfile As String = Profile_Info(38).Trim
                     Try
                         FrmProgress.PicProgress.Image = New Bitmap(DataDir & "services_profiles.png")
                     Catch ex As ArgumentException
                     End Try
                     FrmProgress.LblProgress.Text = "Applying services profile, Please wait..."
                     BWProfiles.RunWorkerAsync()
                     FrmProgress.ShowDialog(FrmMain)
                 Catch ex As IndexOutOfRangeException
                     MessageBox.Show("The selected services profile is corrupted and can not be used.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
                     Exit Sub
                 End Try
             End If
 
         ElseIf GameMode() = True Then
             MessageBox.Show("Applying services profiles can not be performed during Gaming Mode.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Information, MessageBoxDefaultButton.Button1, 0, False)
             Exit Sub
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="79" endline="142">
<![CDATA[
     End Property
 
     Public Overrides Function GetConstant(ByRef result As Object, ByVal lvalue As Object, ByVal rvalue As Object) As Boolean
         Dim tlvalue, trvalue As Mono.Cecil.TypeReference
         Dim clvalue, crvalue As TypeCode
 
         tlvalue = CecilHelper.GetType(Compiler, lvalue)
         clvalue = Helper.GetTypeCode(Compiler, tlvalue)
         trvalue = CecilHelper.GetType(Compiler, rvalue)
         crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
         If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
             result = CBool(lvalue) = CBool(rvalue)
             Return True
         ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
             result = CDate(lvalue) = CDate(rvalue)
             Return True
         ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
             result = CChar(lvalue) = CChar(rvalue)
             Return True
         ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
             result = CStr(lvalue) = CStr(rvalue)
             Return True
         ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
          clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
             result = CStr(lvalue) = CStr(rvalue)
             Return True
         End If
 
         Dim smallest As Mono.Cecil.TypeReference
         Dim csmallest As TypeCode
         smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
         Helper.Assert(smallest IsNot Nothing)
         csmallest = Helper.GetTypeCode(Compiler, smallest)
 
         Select Case csmallest
             Case TypeCode.Byte
                 result = CByte(lvalue) = CByte(rvalue)
             Case TypeCode.SByte
                 result = CSByte(lvalue) = CSByte(rvalue)
             Case TypeCode.Int16
                 result = CShort(lvalue) = CShort(rvalue)
             Case TypeCode.UInt16
                 result = CUShort(lvalue) = CUShort(rvalue)
             Case TypeCode.Int32
                 result = CInt(lvalue) = CInt(rvalue)
             Case TypeCode.UInt32
                 result = CUInt(lvalue) = CUInt(rvalue)
             Case TypeCode.Int64
                 result = CLng(lvalue) = CLng(rvalue)
             Case TypeCode.UInt64
                 result = CULng(lvalue) = CULng(rvalue)
             Case TypeCode.Double
                 result = CDbl(lvalue) = CDbl(rvalue)
             Case TypeCode.Single
                 result = CSng(lvalue) = CSng(rvalue)
             Case TypeCode.Decimal
                 result = CDec(lvalue) = CDec(rvalue)
             Case Else
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="64" endline="120">
<![CDATA[
 
     ''' <summary>
     ''' Can be called multiple times. (Will just exit).
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function ParseFileHeader(ByVal CodeFile As CodeFile, ByVal [Assembly] As AssemblyDeclaration) As Boolean
         Dim result As Boolean = True
 
         Dim m_OptionExplicit As OptionExplicitStatement = CodeFile.OptionExplicit
         Dim m_OptionStrict As OptionStrictStatement = CodeFile.OptionStrict
         Dim m_OptionCompare As OptionCompareStatement = CodeFile.OptionCompare
         Dim m_OptionInfer As OptionInferStatement = CodeFile.OptionInfer
         Dim m_Imports As ImportsClauses = CodeFile.Imports
 
         While tm.CurrentToken.Equals(KS.Option)
             If OptionExplicitStatement.IsMe(tm) Then
                 If m_OptionExplicit IsNot Nothing Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30225, tm.CurrentLocation, "Explicit") AndAlso result
                 End If
                 m_OptionExplicit = ParseOptionExplicitStatement(CodeFile)
                 If m_OptionExplicit Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf OptionStrictStatement.IsMe(tm) Then
                 If m_OptionStrict IsNot Nothing Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30225, tm.CurrentLocation, "Strict") AndAlso result
                 End If
                 m_OptionStrict = ParseOptionStrictStatement(CodeFile)
                 If m_OptionStrict Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf OptionCompareStatement.IsMe(tm) Then
                 If m_OptionCompare IsNot Nothing Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30225, tm.CurrentLocation, "Compare") AndAlso result
                 End If
                 m_OptionCompare = ParseOptionCompareStatement(CodeFile)
                 If m_OptionCompare Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf OptionInferStatement.IsMe(tm) Then
                 If m_OptionInfer IsNot Nothing Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30225, tm.CurrentLocation, "Infer") AndAlso result
                 End If
                 m_OptionInfer = ParseOptionInferStatement(CodeFile)
                 If m_OptionInfer Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 result = Compiler.Report.ShowMessage(Messages.VBNC30206, tm.CurrentLocation) AndAlso result
                 tm.GotoNewline(False)
             End If
         End While
         While tm.CurrentToken.Equals(KS.Option)
             If OptionExplicitStatement.IsMe(tm) Then
                 If m_OptionExplicit IsNot Nothing Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30225, tm.CurrentLocation, "Explicit") AndAlso result
                 End If
                 m_OptionExplicit = ParseOptionExplicitStatement(CodeFile)
                 If m_OptionExplicit Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf OptionStrictStatement.IsMe(tm) Then
                 If m_OptionStrict IsNot Nothing Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30225, tm.CurrentLocation, "Strict") AndAlso result
                 End If
                 m_OptionStrict = ParseOptionStrictStatement(CodeFile)
                 If m_OptionStrict Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf OptionCompareStatement.IsMe(tm) Then
                 If m_OptionCompare IsNot Nothing Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30225, tm.CurrentLocation, "Compare") AndAlso result
                 End If
                 m_OptionCompare = ParseOptionCompareStatement(CodeFile)
                 If m_OptionCompare Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf OptionInferStatement.IsMe(tm) Then
                 If m_OptionInfer IsNot Nothing Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30225, tm.CurrentLocation, "Infer") AndAlso result
                 End If
                 m_OptionInfer = ParseOptionInferStatement(CodeFile)
                 If m_OptionInfer Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 result = Compiler.Report.ShowMessage(Messages.VBNC30206, tm.CurrentLocation) AndAlso result
                 tm.GotoNewline(False)
             End If
         End While
 
         If m_Imports Is Nothing Then m_Imports = New ImportsClauses([Assembly])
         Dim tmpImportsStatements As Generic.List(Of ImportsStatement)
         tmpImportsStatements = ParseImportsStatements([Assembly])
         For Each imp As ImportsStatement In tmpImportsStatements
             m_Imports.AddRange(imp.Clauses)
         Next
 
         CodeFile.Init(m_OptionCompare, m_OptionStrict, m_OptionExplicit, m_OptionInfer, m_Imports)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AliasClause.vb" startline="527" endline="578">
<![CDATA[
 
     Private Function GetAttribute(ByVal security As Boolean) As Mono.Cecil.ICustomAttribute
         Dim result As ICustomAttribute
         Dim customAttribute As CustomAttribute = Nothing
         Dim securityAttribute As SecurityAttribute = Nothing
         Dim parameters As Mono.Collections.Generic.Collection(Of ParameterDefinition) = Helper.GetParameters(Compiler, m_ResolvedTypeConstructor)
 
         Helper.Assert(m_ResolvedTypeConstructor IsNot Nothing)
         Helper.Assert(m_Arguments IsNot Nothing)
         Helper.Assert(parameters.Count = m_Arguments.Length)
         Helper.Assert(m_Properties IsNot Nothing AndAlso m_PropertyValues IsNot Nothing AndAlso m_Properties.Count = m_PropertyValues.Count)
         Helper.Assert(m_Fields IsNot Nothing AndAlso m_FieldValues IsNot Nothing AndAlso m_Fields.Count = m_FieldValues.Count)
 
         m_ResolvedTypeConstructor = Helper.GetMethodOrMethodReference(Compiler, m_ResolvedTypeConstructor)
 
         Dim cecilArguments As Object()
         ReDim cecilArguments(m_Arguments.Length - 1)
         Array.Copy(m_Arguments, cecilArguments, m_Arguments.Length)
         For i As Integer = 0 To cecilArguments.Length - 1
             Dim type As Mono.Cecil.TypeReference
             type = TryCast(cecilArguments(i), Mono.Cecil.TypeReference)
             If type IsNot Nothing Then
                 cecilArguments(i) = Helper.GetTypeOrTypeReference(Compiler, type)
             End If
         Next
 
         Try
             If security Then
                 securityAttribute = New SecurityAttribute(Me.AttributeType)
                 result = securityAttribute
             Else
                 customAttribute = New Mono.Cecil.CustomAttribute(Helper.GetMethodOrMethodReference(Compiler, m_ResolvedTypeConstructor))
                 result = customAttribute
             End If
 
             For i As Integer = 0 To m_Fields.Count - 1
                 result.Fields.Add(New Mono.Cecil.CustomAttributeNamedArgument(m_Fields(i).Name, New CustomAttributeArgument(Helper.GetTypeOrTypeReference(Compiler, m_Fields(i).FieldType), m_FieldValues(i))))
             Next
             For i As Integer = 0 To m_Properties.Count - 1
                 result.Properties.Add(New Mono.Cecil.CustomAttributeNamedArgument(m_Properties(i).Name, New CustomAttributeArgument(Helper.GetTypeOrTypeReference(Compiler, m_Properties(i).PropertyType), m_PropertyValues(i))))
             Next
             If customAttribute IsNot Nothing Then
                 For i As Integer = 0 To cecilArguments.Length - 1
                     customAttribute.ConstructorArguments.Add(New CustomAttributeArgument(Helper.GetTypeOrTypeReference(Compiler, parameters(i).ParameterType), cecilArguments(i)))
                 Next
             End If
         Catch ex As Exception
             Throw
         End Try
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="637" endline="736">
<![CDATA[
 
     Private Function GetMeClassification(ByVal members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference), ByVal type As IType) As ExpressionClassification
         Dim result As ExpressionClassification
         Dim first As Mono.Cecil.MemberReference = members(0)
 
         'Otherwise, if the type is the immediately enclosing type and the lookup identifies a non-shared 
         'type member, then the result is the same as a member access of the form Me.E, where E is 
         'the identifier.
 
 
         '* If E is classified as a variable or value, the type of which is T, and I is the name of an accessible 
         '  member of E, then E.I is evaluated and classified as follows
 
         '** If I is the keyword New and E is an instance expression (Me, MyBase, or MyClass), then the result is 
         '   a method group representing the instance constructors of the type of E with an associated 
         '   instance expression of E and no type argument list. Otherwise, a compile-time error occurs.
         '(not applicable)
 
         '** If I identifies one or more methods, then the result is a method group with the associated type 
         '   argument list and an associated instance expression of E.
         If Helper.IsMethodDeclaration(first) Then
             result = New MethodGroupClassification(Me, CreateMeExpression, m_TypeArgumentList, Nothing, members)
             Return result
         End If
 
         '** If I identifies one or more properties, then the result is a property group with an 
         '   associated instance expression of E.
         If Helper.IsPropertyDeclaration(first) Then
             result = New PropertyGroupClassification(Me, CreateMeExpression, members)
             Return result
         End If
 
         If members.Count > 1 Then
             Compiler.Report.WriteLine("Found " & members.Count & " members for SimpleNameExpression = " & Me.ToString & ", " & Me.Location.ToString(Compiler))
             For i As Integer = 0 To members.Count - 1
                 Compiler.Report.WriteLine(">#" & (i + 1).ToString & ".MemberType=" & CecilHelper.GetMemberType(members(i)).ToString & ",DeclaringType=" & members(i).DeclaringType.FullName)
             Next
             Helper.Stop()
         End If
 
         '** If I identifies a shared variable or an instance variable, and if the variable is read-only, 
         '   and the reference occurs outside a constructor of the class in which the variable is declared 
         '   appropriate for the kind of variable (shared or instance), then the result is the value of the 
         '   variable I in the object referenced by E. 
         '   If T is a reference type, then the result is the variable 
         '   I in the object referenced by E. 
         '   Otherwise, if T is a value type and the expression E is classified 
         '   as a variable, the result is a variable; otherwise the result is a value.
         If Helper.IsFieldDeclaration(first) Then
             Dim var As Mono.Cecil.FieldReference = DirectCast(first, Mono.Cecil.FieldReference)
             Dim varD As Mono.Cecil.FieldDefinition = CecilHelper.FindDefinition(var)
             Helper.Assert(Parent.FindFirstParent(Of EnumDeclaration)() Is Nothing)
 
             Dim ctorParent As ConstructorDeclaration
             Dim methodParent As IMethod
             Dim typeParent As TypeDeclaration
             Dim isNotInCtorAndReadOnly As Boolean
             ctorParent = FindFirstParent(Of ConstructorDeclaration)()
             methodParent = FindFirstParent(Of IMethod)()
             typeParent = FindFirstParent(Of TypeDeclaration)()
 
             isNotInCtorAndReadOnly = varD.IsInitOnly AndAlso (ctorParent Is Nothing OrElse ctorParent.Modifiers.Is(ModifierMasks.Shared) <> varD.IsStatic) AndAlso (typeParent Is Nothing OrElse typeParent.IsShared <> varD.IsStatic)
 
             If isNotInCtorAndReadOnly Then ' >?? (Parent.FindFirstParent(Of IMethod).Modifiers.Is(KS.Shared) <> var.IsStatic) Then
                 Return New ValueClassification(Me, var, CreateMeExpression)
             ElseIf TypeOf type Is ClassDeclaration Then
                 Return New VariableClassification(Me, var, CreateMeExpression)
             ElseIf TypeOf type Is StructureDeclaration Then
                 Return New VariableClassification(Me, var, CreateMeExpression)
             Else
                 Throw New InternalException(Me)
             End If
         End If
 
         '** If I identifies an event, the result is an event access with an associated instance expression of E.
         If Helper.IsEventDeclaration(first) Then
             If TypeOf first Is Mono.Cecil.EventReference Then
                 Return New EventAccessClassification(Me, DirectCast(first, Mono.Cecil.EventReference), CreateMeExpression)
             Else
                 Throw New InternalException(Me)
             End If
         End If
 
         '** If I identifies a constant, then the result is the value of that constant.
         If CecilHelper.GetMemberType(first) = MemberTypes.Field AndAlso CecilHelper.FindDefinition(DirectCast(first, Mono.Cecil.FieldReference)).IsLiteral Then
             Return New ValueClassification(Me, DirectCast(first, Mono.Cecil.FieldReference), Nothing)
         End If
 
         '** If I identifies an enumeration member, then the result is the value of that enumeration member.
         '(not applicable)
 
         '** If T is Object, then the result is a late-bound member lookup classified as a late-bound access 
         '   with an associated instance expression of E.
         '(not applicable)
 
         '** Otherwise, E.I is an invalid member reference, and a compile-time error occurs.
         Helper.AddError(Me)
 
         Return Nothing
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\UnaryExpressions\Expressions.vb" startline="62" endline="120">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim operandType As TypeCode
 
         result = m_Expression.ResolveExpression(Info) AndAlso result
 
         If result = False Then Return False
 
         If m_Expression.Classification.IsValueClassification = False Then
             If m_Expression.Classification.CanBeValueClassification Then
                 m_Expression = m_Expression.ReclassifyToValueExpression
                 result = m_Expression.ResolveExpression(Info) AndAlso result
             Else
                 result = Helper.AddError(Me, "Value must be value classification.") AndAlso result
             End If
         End If
 
         operandType = Me.OperandTypeCode
 
         If operandType = TypeCode.Empty Then
             Compiler.Report.ShowMessage(Messages.VBNC30487, Location, Enums.strSpecial(Me.Keyword), Helper.ToString(Expression, Expression.ExpressionType))
             result = False
         Else
             'If X is an intrinsic types, look up the result type in our operator tables and use that.
             'If X is not an intrinsic type, do overload resolution on the set of operators to be considered.
             Dim destinationType As Mono.Cecil.TypeReference
             Dim isRightIntrinsic As Boolean = Helper.GetTypeCode(Compiler, m_Expression.ExpressionType) <> TypeCode.Object OrElse Helper.CompareType(Compiler.TypeCache.System_Object, Me.m_Expression.ExpressionType)
 
             If isRightIntrinsic Then
                 m_ExpressionType = Compiler.TypeResolution.TypeCodeToType(Me.ExpressionTypeCode)
                 If Helper.GetTypeCode(Compiler, m_Expression.ExpressionType) <> operandType Then
                     Dim ctypeexp As CTypeExpression
                     destinationType = Compiler.TypeResolution.TypeCodeToType(operandType)
                     ctypeexp = New CTypeExpression(Me, m_Expression, destinationType)
                     result = ctypeexp.ResolveExpression(Info) AndAlso result
                     m_Expression = ctypeexp
                 End If
                 Classification = New ValueClassification(Me)
             Else
                 Dim methods As New Generic.List(Of Mono.Cecil.MethodReference)
                 Dim methodClassification As MethodGroupClassification
 
                 methods = Helper.GetUnaryOperators(Compiler, CType(Me.Keyword, UnaryOperators), Me.m_Expression.ExpressionType)
 
                 methodClassification = New MethodGroupClassification(Me, Nothing, Nothing, New Expression() {Me.m_Expression}, methods.ToArray)
                 result = methodClassification.ResolveGroup(New ArgumentList(Me, New Expression() {Me.m_Expression})) AndAlso result
                 result = methodClassification.SuccessfullyResolved AndAlso result
                 m_ExpressionType = methodClassification.ResolvedMethodInfo.ReturnType
                 Classification = methodClassification
             End If
 
             If Location.File(Compiler).IsOptionStrictOn AndAlso Helper.CompareType(m_Expression.ExpressionType, Compiler.TypeCache.System_Object) Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC30038, Me.Location, Enums.strSpecial(Keyword))
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmDiagnostics.vb" startline="143" endline="192">
<![CDATA[
 
 #End Region
 
 #Region "Services Diagnostics"
 
     Private Sub BWDiagnostics_DoWork(ByVal sender As Object, ByVal e As System.ComponentModel.DoWorkEventArgs) Handles BWDiagnostics.DoWork
 
         System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls = False
         TabMain.SelectedIndex = 0
 
         Profile_Diagnostics("Uxsms", 0, "WinAero")
         Profile_Diagnostics("Spooler", 1, "Printer")
         Profile_Diagnostics("stisvc", 2, "Scanner")
         Profile_Diagnostics("TabletInputService", 3, "TabletPC")
         Profile_Diagnostics("WinDefend", 4, "WinDefender")
         Profile_Diagnostics("MpsSvc", 5, "WinFirewall")
         Profile_Diagnostics("PcaSvc", 6, "Compatibility")
 
         Profile_Diagnostics("Dhcp", 7, "Internet")
         Profile_Diagnostics("Dnscache", 8, "Internet")
         Profile_Diagnostics("DFSR", 9, "Internet")
         Profile_Diagnostics("LanmanWorkstation", 10, "Internet")
 
         Profile_Diagnostics("Browser", 11, "Network")
         Profile_Diagnostics("FDResPub", 12, "Network")
         Profile_Diagnostics("LanmanServer", 13, "Network")
         Profile_Diagnostics("lmhosts", 14, "Network")
 
         Profile_Diagnostics("SDRSVC", 15, "WinBackup")
         Profile_Diagnostics("Wlansvc", 16, "WirelessNet")
         MediaCntr_Diagnostics("ehstart", 17, "MediaCntr")
 
         Essential_Diagnostics("BFE", 19)
         Essential_Diagnostics("slsvc", 20)
         Essential_Diagnostics("SysMain", 21)
         Essential_Diagnostics("ProfSvc", 22)
         Essential_Diagnostics("power", 23)
         Essential_Diagnostics("Eventlog", 25)
         Essential_Diagnostics("CryptSvc", 28)
 
         Manual_Diagnostics("BITS", 18)
         Manual_Diagnostics("msiserver", 24)
         Manual_Diagnostics("TrustedInstaller", 26)
         Manual_Diagnostics("AppMgmt", 27)
 
         Threading.Thread.Sleep(3000)
         SrvcCntrl.Close()
         Application.ExitThread()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\VariableDeclaration.vb" startline="137" endline="199">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         If result = False Then Return result
 
         If m_VariableInitializer IsNot Nothing Then result = m_VariableInitializer.ResolveTypeReferences() AndAlso result
 
         If m_TypeName IsNot Nothing Then result = m_TypeName.ResolveTypeReferences AndAlso result
 
         If result = False Then Return result
 
         If m_VariableType Is Nothing Then 'the declaration might have been created with the type already.
             If m_TypeName IsNot Nothing Then
                 m_VariableType = m_TypeName.ResolvedType
 
                 If m_IsNew Then
                     If m_TypeName.IsNonArrayTypeName = False Then
                         result = Helper.AddError(Me) AndAlso result
                     End If
                     m_NewExpression = New DelegateOrObjectCreationExpression(Me, m_TypeName.AsNonArrayTypeName, m_ArgumentList)
                 End If
             ElseIf m_VariableIdentifier Is Nothing Then
                 'Do nothing, we've been created by an event that hasn't ResolveTypeReferences yet.
             ElseIf m_VariableIdentifier.Identifier.HasTypeCharacter Then
                 m_VariableType = TypeCharacters.TypeCharacterToType(Compiler, m_VariableIdentifier.Identifier.TypeCharacter)
             Else
                 If Me.Location.File(Compiler).IsOptionStrictOn Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30209, Me.Location) AndAlso result
                 Else
                     result = Compiler.Report.ShowMessage(Messages.VBNC42020, Me.Location) AndAlso result
                 End If
                 m_VariableType = Compiler.TypeCache.System_Object
             End If
         End If
 
         If m_VariableIdentifier IsNot Nothing AndAlso m_VariableIdentifier.HasArrayNameModifier Then
             If CecilHelper.IsArray(m_VariableType) Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC31087, Location) AndAlso result
             Else
                 If m_VariableIdentifier.ArrayNameModifier.IsArraySizeInitializationModifier Then
                     m_VariableType = m_VariableIdentifier.ArrayNameModifier.AsArraySizeInitializationModifier.CreateArrayType(m_VariableType)
                 ElseIf m_VariableIdentifier.ArrayNameModifier.IsArrayTypeModifiers Then
                     m_VariableType = m_VariableIdentifier.ArrayNameModifier.AsArrayTypeModifiers.CreateArrayType(m_VariableType)
                 Else
                     Throw New InternalException(Me)
                 End If
             End If
         End If
 
         If m_VariableIdentifier IsNot Nothing AndAlso m_VariableIdentifier.IsNullable Then
             result = CecilHelper.CreateNullableType(Me, m_VariableType, m_VariableType) AndAlso result
         End If
 
         If m_NewExpression IsNot Nothing Then result = m_NewExpression.ResolveTypeReferences AndAlso result
 
         'Helper.Assert(m_FieldType IsNot Nothing)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Classes\SrvcProfile.vb" startline="13" endline="65">
<![CDATA[
 
     Protected Friend Sub Apply_Profile(ByVal Path As String)
 
         Dim Reader As New StreamReader(Path)
         Dim Info = Reader.ReadToEnd
         Reader.Close()
 
         Dim Profile_Info() As String = Info.Split(CChar("!"))
         UBound(Profile_Info)
 
         Apply("Themes", Profile_Info(3).Trim)
         Apply("Uxsms", Profile_Info(4).Trim)
         Apply("ehstart", Profile_Info(5).Trim)
         Apply("WMPNetworkSvc", Profile_Info(6).Trim)
         Apply("WSearch", Profile_Info(7).Trim)
         Apply("PcaSvc", Profile_Info(8).Trim)
         Apply("DPS", Profile_Info(9).Trim)
         Apply("Spooler", Profile_Info(10).Trim)
         Apply("stisvc", Profile_Info(11).Trim)
         Apply("TabletInputService", Profile_Info(12).Trim)
         Apply("SENS", Profile_Info(13).Trim)
         Apply("seclogon", Profile_Info(14).Trim)
         Apply("WerSvc", Profile_Info(15).Trim)
         Apply("defragsvc", Profile_Info(16).Trim)
 
         Apply("wscsvc", Profile_Info(17).Trim)
         Apply("wuauserv", Profile_Info(18).Trim)
         Apply("WinDefend", Profile_Info(19).Trim)
         Apply("MpsSvc", Profile_Info(20).Trim)
         Apply("SDRSVC", Profile_Info(21).Trim)
         Apply("RemoteRegistry", Profile_Info(22).Trim)
         Apply("PolicyAgent", Profile_Info(23).Trim)
 
         Apply("Dhcp", Profile_Info(24).Trim)
         Apply("Dnscache", Profile_Info(25).Trim)
         Apply("DFSR", Profile_Info(26).Trim)
         Apply("LanmanWorkstation", Profile_Info(27).Trim)
         Apply("LanmanServer", Profile_Info(30).Trim)
         Apply("Browser", Profile_Info(28).Trim)
         Apply("FDResPub", Profile_Info(29).Trim)
         Apply("lmhosts", Profile_Info(31).Trim)
         Apply("TermService", Profile_Info(32).Trim)
         Apply("upnphost", Profile_Info(33).Trim)
         Apply("CscService", Profile_Info(34).Trim)
         Apply("iphlpsvc", Profile_Info(35).Trim)
         Apply("WebClient", Profile_Info(36).Trim)
         Apply("W32Time", Profile_Info(37).Trim)
         Apply("Wlansvc", Profile_Info(38).Trim)
 
         System.Threading.Thread.Sleep(2000)
         SrvcCntrl.Close()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\RegularEventDeclaration.vb" startline="81" endline="168">
<![CDATA[
     End Property
 
     Public Function CreateRegularEventMembers() As Boolean
         Dim result As Boolean = True
 
         'An event creates the following members.
         '1 - if the event is not an explicit delegate, and not an implemented interface event, a nested delegate in the 
         '    parent called (name)EventHandler.
         '    the parameters to the delegate are the same as for the event 
         '    accessability is the same as for the event.
         '2 - a private variable in the parent called (name)Event of type (name)EventHandler.
         '    (unless it is an interface)
         '3 - an add_(name) method in the parent with 1 parameter of type (name)EventHandler.
         '    accessability is the same as for the event.
         '4 - an remove_(name) method in the parent with 1 parameter of type (name)EventHandler.
         '    accessability is the same as for the event.
         '5 - possibly a raise_(name) method in the parent as well.
         '    accessability is the same as for the event.
         '    this method seems to be created only for custom events.
         '6 - an event in the parent called (name) with the add, remove and raise methods of 3, 4 & 5
         '    accessability is the same as for the event.
 
         'TODO
         Helper.Assert(m_ElementsCreated = False)
         If m_ElementsCreated Then Return result
         m_ElementsCreated = True
 
         Dim addMethod As RegularEventHandlerDeclaration
         Dim removeMethod As RegularEventHandlerDeclaration
         Dim type As TypeName = Nothing
 
         If Me.Type IsNot Nothing Then type = New TypeName(Me, Me.Type)
 
         'Create the delegate, if necessary.
         If ImplementsClause IsNot Nothing AndAlso ImplementsClause.ImplementsList.Count > 0 Then
             'Nothing to do here
         ElseIf Me.Parameters IsNot Nothing Then
             m_ImplicitEventDelegate = New DelegateDeclaration(DeclaringType, DeclaringType.Namespace, New SubSignature(Me, Me.Name & "EventHandler", Me.Parameters.Clone()))
             m_ImplicitEventDelegate.Modifiers = Me.Modifiers
             result = m_ImplicitEventDelegate.CreateDefinition() AndAlso result
             result = m_ImplicitEventDelegate.CreateDelegateMembers AndAlso result
 
             EventType = m_ImplicitEventDelegate.CecilType
             DeclaringType.Members.Add(m_ImplicitEventDelegate)
         ElseIf type IsNot Nothing Then
             'nothing to do
         Else
             Throw New InternalException(Me)
         End If
 
         'Create the variable.
         If DeclaringType.IsInterface = False Then
             Dim eventVariableModifiers As Modifiers
             m_Variable = New TypeVariableDeclaration(DeclaringType)
             eventVariableModifiers = New Modifiers(ModifierMasks.Private)
             If Me.IsShared Then eventVariableModifiers.AddModifiers(ModifierMasks.Shared)
             If m_ImplicitEventDelegate IsNot Nothing Then
                 m_Variable.Modifiers = eventVariableModifiers
                 m_Variable.Name = Me.Name & "Event"
                 m_Variable.VariableType = m_ImplicitEventDelegate.CecilType
             Else
                 m_Variable.Modifiers = eventVariableModifiers
                 m_Variable.Name = Me.Name & "Event"
             End If
             result = m_Variable.CreateDefinition AndAlso result
             DeclaringType.Members.Add(m_Variable)
         End If
 
         'Create the add method
         addMethod = New RegularEventHandlerDeclaration(Me, Me.Modifiers, KS.AddHandler, Me.Identifier)
         result = addMethod.CreateDefinition AndAlso result
         DeclaringType.Members.Add(addMethod)
 
         'Create the remove method
         removeMethod = New RegularEventHandlerDeclaration(Me, Me.Modifiers, KS.RemoveHandler, Me.Identifier)
         result = removeMethod.CreateDefinition AndAlso result
         DeclaringType.Members.Add(removeMethod)
 
         Helper.Assert(addMethod IsNot Nothing)
         Helper.Assert(addMethod.Name <> "")
         Helper.Assert(removeMethod IsNot Nothing)
         Helper.Assert(removeMethod.Name <> "")
 
         MyBase.AddMethod = addMethod
         MyBase.RemoveMethod = removeMethod
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1339" endline="1352">
<![CDATA[
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="Value"></param>
     ''' <remarks></remarks>
     Shared Sub EmitLoadValueAddress(ByVal Info As EmitInfo, ByVal Value As Object)
         Helper.Assert(CecilHelper.IsByRef(Info.DesiredType))
         EmitLoadValue(Info.Clone(Info.Context, CecilHelper.GetElementType(Info.DesiredType)), Value)
         Dim local As Mono.Cecil.Cil.VariableDefinition = DeclareLocal(Info, Helper.GetTypeOrTypeBuilder(Info.Compiler, CecilHelper.GetElementType(Info.DesiredType)))
         EmitStoreVariable(Info, local)
         EmitLoadVariableLocation(Info, local)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="1170" endline="1184">
<![CDATA[
 
     Private Function ExtractInt(ByVal Value As ULong, ByVal Base As IntegerBase) As Integer
         Select Case Base
             Case IntegerBase.Decimal
                 Return CInt(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 If Value > Integer.MaxValue Then
                     Return CInt(Integer.MinValue + (CUInt(Value) - Integer.MaxValue - 1))
                 Else
                     Return CInt(Value)
                 End If
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="76" endline="138">
<![CDATA[
     End Property
 
     Public Overrides Function GetConstant(ByRef result As Object, ByVal lvalue As Object, ByVal rvalue As Object) As Boolean
         Dim tlvalue, trvalue As Mono.Cecil.TypeReference
         Dim clvalue, crvalue As TypeCode
         tlvalue = CecilHelper.GetType(Compiler, lvalue)
         clvalue = Helper.GetTypeCode(Compiler, tlvalue)
         trvalue = CecilHelper.GetType(Compiler, rvalue)
         crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
         If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
             result = CBool(lvalue) >= CBool(rvalue)
             Return True
         ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
             result = CDate(lvalue) >= CDate(rvalue)
             Return True
         ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
             result = CChar(lvalue) >= CChar(rvalue)
             Return True
         ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
             result = CStr(lvalue) >= CStr(rvalue)
             Return True
         ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
          clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
             result = CStr(lvalue) >= CStr(rvalue)
             Return True
         End If
 
         Dim smallest As Mono.Cecil.TypeReference
         Dim csmallest As TypeCode
         smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
         Helper.Assert(smallest IsNot Nothing)
         csmallest = Helper.GetTypeCode(Compiler, smallest)
 
         Select Case csmallest
             Case TypeCode.Byte
                 result = CByte(lvalue) >= CByte(rvalue)
             Case TypeCode.SByte
                 result = CSByte(lvalue) >= CSByte(rvalue)
             Case TypeCode.Int16
                 result = CShort(lvalue) >= CShort(rvalue)
             Case TypeCode.UInt16
                 result = CUShort(lvalue) >= CUShort(rvalue)
             Case TypeCode.Int32
                 result = CInt(lvalue) >= CInt(rvalue)
             Case TypeCode.UInt32
                 result = CUInt(lvalue) >= CUInt(rvalue)
             Case TypeCode.Int64
                 result = CLng(lvalue) >= CLng(rvalue)
             Case TypeCode.UInt64
                 result = CULng(lvalue) >= CULng(rvalue)
             Case TypeCode.Double
                 result = CDbl(lvalue) >= CDbl(rvalue)
             Case TypeCode.Single
                 result = CSng(lvalue) >= CSng(rvalue)
             Case TypeCode.Decimal
                 result = CDec(lvalue) >= CDec(rvalue)
             Case Else
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" startline="489" endline="577">
<![CDATA[
 
     Public Overrides Function GetConstant(ByRef result As Object, ByVal ShowError As Boolean) As Boolean
         If Helper.CompareType(Compiler.TypeCache.Nothing, Expression.ExpressionType) Then
             Select Case Helper.GetTypeCode(Compiler, Me.ExpressionType)
                 Case TypeCode.Boolean
                     result = CBool(Nothing)
                 Case TypeCode.Byte
                     result = CByte(Nothing)
                 Case TypeCode.Char
                     result = CChar(Nothing)
                 Case TypeCode.DateTime
                     result = CDate(Nothing)
                 Case TypeCode.Decimal
                     result = CDec(Nothing)
                 Case TypeCode.Double
                     result = CDbl(Nothing)
                 Case TypeCode.Int16
                     result = CShort(Nothing)
                 Case TypeCode.Int32
                     result = CInt(Nothing)
                 Case TypeCode.Int64
                     result = CLng(Nothing)
                 Case TypeCode.SByte
                     result = CSByte(Nothing)
                 Case TypeCode.Single
                     result = CSng(Nothing)
                 Case TypeCode.UInt16
                     result = CUShort(Nothing)
                 Case TypeCode.UInt32
                     result = CUInt(Nothing)
                 Case TypeCode.UInt64
                     result = CULng(Nothing)
                 Case Else
                     result = Nothing
             End Select
             Return True
         End If
 
         If Not Expression.GetConstant(result, ShowError) Then Return False
 
         Select Case Helper.GetTypeCode(Compiler, Me.ExpressionType)
             Case TypeCode.String
                 Select Case Helper.GetTypeCode(Compiler, Me.Expression.ExpressionType)
                     Case TypeCode.Char
                         result = CStr(result)
                         Return True
                     Case TypeCode.String
                         Return True
                     Case Else
                         If ShowError Then Show30059()
                         Return False
                 End Select
             Case TypeCode.Byte
                 Return ConvertToByte(result, ShowError)
             Case TypeCode.SByte
                 Return ConvertToSByte(result, ShowError)
             Case TypeCode.Int16
                 Return ConvertToShort(result, ShowError)
             Case TypeCode.UInt16
                 Return ConvertToUShort(result, ShowError)
             Case TypeCode.Int32
                 Return ConvertToInt32(result, ShowError)
             Case TypeCode.UInt32
                 Return ConvertToUInt32(result, ShowError)
             Case TypeCode.Int64
                 Return ConvertToLong(result, ShowError)
             Case TypeCode.UInt64
                 Return ConvertToULong(result, ShowError)
             Case TypeCode.Single
                 Return ConvertToSingle(result, ShowError)
             Case TypeCode.Double
                 Return ConvertToDouble(result, ShowError)
             Case TypeCode.Decimal
                 Return ConvertToDecimal(result, ShowError)
             Case TypeCode.DateTime
                 Return ConvertToDate(result, ShowError)
             Case TypeCode.Char
                 Return ConvertToChar(result, ShowError)
             Case TypeCode.String
                 Return ConvertToString(result, ShowError)
             Case TypeCode.Boolean
                 Return ConvertToBoolean(result, ShowError)
             Case Else
                 If ShowError Then Show30059()
                 Return False
         End Select
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="65" endline="152">
<![CDATA[
 
     ''' <summary>
     ''' Creates an object array (always).
     ''' - initializes it with the arguments (if any). 
     ''' - adds the rhs expression (if supplied).
     ''' Leaves a reference to the object array on the stack.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="LateBoundAccess"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Shared Function EmitArguments(ByVal Info As EmitInfo, ByVal LateBoundAccess As LateBoundAccessClassification, ByRef arguments As Mono.Cecil.Cil.VariableDefinition) As Boolean
         Dim result As Boolean = True
 
         Dim argCount As Integer
         Dim elementCount As Integer
         Dim args As ArgumentList
 
         Dim namedCount As Integer
 
         args = LateBoundAccess.Arguments
         If args IsNot Nothing Then argCount = args.Count
 
         elementCount = argCount
         If Info.RHSExpression IsNot Nothing Then elementCount += 1
 
         arguments = Emitter.DeclareLocal(Info, Info.Compiler.TypeCache.System_Object_Array)
 
         Emitter.EmitLoadI4Value(Info, elementCount)
         Emitter.EmitNewArr(Info, Info.Compiler.TypeCache.System_Object)
 
         Emitter.EmitStoreVariable(Info, arguments)
 
         For i As Integer = 0 To argCount - 1
             Dim arg As Argument = args.Arguments(i)
             If TypeOf arg Is NamedArgument Then namedCount += 1
             Emitter.EmitLoadVariable(Info, arguments)
             Emitter.EmitLoadI4Value(Info, i)
             If arg.Expression Is Nothing Then
                 Emitter.EmitLoadVariable(Info, Info.Compiler.TypeCache.System_Reflection_Missing__Value)
             Else
                 result = arg.GenerateCode(Info.Clone(Info.Context, True, False, arg.Expression.ExpressionType)) AndAlso result
                 If CecilHelper.IsValueType(arg.Expression.ExpressionType) Then
                     Emitter.EmitBox(Info, arg.Expression.ExpressionType)
                 End If
             End If
             Emitter.EmitStoreElement(Info, Info.Compiler.TypeCache.System_Object, Info.Compiler.TypeCache.System_Object_Array)
         Next
 
         If elementCount <> argCount Then
             Emitter.EmitLoadVariable(Info, arguments)
             Emitter.EmitLoadI4Value(Info, elementCount - 1)
             result = Info.RHSExpression.GenerateCode(Info.Clone(Info.Context, True, False, Info.RHSExpression.ExpressionType)) AndAlso result
             If CecilHelper.IsValueType(Info.RHSExpression.ExpressionType) Then
                 Emitter.EmitBox(Info, Info.RHSExpression.ExpressionType)
             End If
             Emitter.EmitStoreElement(Info, Info.Compiler.TypeCache.System_Object, Info.Compiler.TypeCache.System_Object_Array)
         End If
 
         Emitter.EmitLoadVariable(Info, arguments)
 
         If namedCount > 0 Then
             Dim namedArguments As Mono.Cecil.Cil.VariableDefinition
             namedArguments = Emitter.DeclareLocal(Info, Info.Compiler.TypeCache.System_String_Array)
             Emitter.EmitLoadI4Value(Info, namedCount)
             Emitter.EmitNewArr(Info, Info.Compiler.TypeCache.System_String)
             Emitter.EmitStoreVariable(Info, namedArguments)
 
             Dim iNamed As Integer
             For i As Integer = 0 To argCount - 1
                 Dim arg As NamedArgument = TryCast(args.Arguments(i), NamedArgument)
                 If arg Is Nothing Then Continue For
 
                 Emitter.EmitLoadVariable(Info, namedArguments)
                 Emitter.EmitLoadI4Value(Info, iNamed)
                 Emitter.EmitLoadValue(Info, arg.Name)
                 Emitter.EmitStoreElement(Info, Info.Compiler.TypeCache.System_String, Info.Compiler.TypeCache.System_String_Array)
 
                 iNamed += 1
             Next
 
             Emitter.EmitLoadVariable(Info, namedArguments)
         Else
             Emitter.EmitLoadNull(Info.Clone(Info.Context, Info.Compiler.TypeCache.System_String_Array))
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="1938" endline="1962">
<![CDATA[
 
     Private Sub frmMain_Closing(ByVal sender As Object, _
     ByVal e As System.ComponentModel.CancelEventArgs) Handles MyBase.Closing
 
         If DirtyCheck() Then
             e.Cancel = True
         Else
             mSettings.SaveSetting("Joining", "AutoDetect", chkAuto.Checked.ToString)
             mSettings.SaveSetting("Joining", "AutoDelete", chkDel.Checked.ToString)
             mSettings.SaveSetting("Advanced", "KeepHistory", chkKeepMRU.Checked.ToString)
             mSettings.SaveSetting("Advanced", "CheckUpdate", chkUpdate.Checked.ToString)
             mSettings.SaveSetting("Advanced", "FrameAccurate", chkFrameAccurate.Checked.ToString)
             mSettings.SaveSetting("Advanced", "BeepWhenDone", chkBeep.Checked.ToString)
             mSettings.SaveSetting("Player", "Mute", MPcontrols.cMute.Pushed.ToString)
             mSettings.SaveSetting("Player", "Volume", MPcontrols.VolBar.Value.ToString)
             mSettings.SaveSetting("Player", "OnTop", chkOnTop.Checked.ToString)
             If Not chkDialogView.Checked Then
                 mSettings.SaveSetting("View", "DialogView", "Default")
             End If
             mSettings.SaveSetting("View", "WindowState", Me.WindowState.ToString)
             mSettings.SaveSetting("View", "SelectedTab", mainTabs.SelectedTab.Name)
             SaveToolMgr()
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="39" endline="49">
<![CDATA[
 
 #If DEBUG Then
     ReadOnly Property AsString() As String
         Get
             Dim result As String = String.Empty
             For Each item As Generic.KeyValuePair(Of String, ConditionalConstant) In Me
                 If result <> String.Empty Then result &= ";"
                 result &= item.Key & "=" & CStr(item.Value.Value)
             Next
             Return result
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2469" endline="2489">
<![CDATA[
 
     ''' <summary>
     ''' Converts the value into how it would look in a source file. 
     ''' I.E
     ''' </summary>
     ''' <param name="Value"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function ValueToCodeConstant(ByVal Value As Object) As String
         If TypeOf Value Is String Then
             Return """" & Value.ToString.Replace("""", """""") & """"
         ElseIf TypeOf Value Is Char Then
             Return """" & Value.ToString.Replace("""", """""") & """c"
         ElseIf TypeOf Value Is Date Then
             Return "#" & Value.ToString & "#"
         ElseIf Value Is Nothing Then
             Return KS.Nothing.ToString
         Else
             Return Value.ToString
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="32" endline="46">
<![CDATA[
 
     Shared Sub MarkSequencePoint(ByVal Info As EmitInfo, ByVal Location As Span)
         If Location.File(Info.Compiler) Is Nothing Then Return
         If Location.Line <= 0 Then Return
 
         Dim s As Mono.Cecil.Cil.SequencePoint
         Dim instr As Mono.Cecil.Cil.Instruction
         s = New Mono.Cecil.Cil.SequencePoint(Location.File(Info.Compiler).SymbolDocument)
         instr = Info.ILGen.CreateAndEmitNop()
         instr.SequencePoint = s
         s.StartLine = CInt(Location.Line)
         s.StartColumn = Location.Column
         s.EndLine = CInt(Location.Line)
         s.EndColumn = Location.EndColumn
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeCache.vb" startline="31" endline="64">
<![CDATA[
     End Property
 
 #If DEBUG Then
     'This method will generate the other partial TypeCache class.
     Shared Sub Generate()
         Dim path As String = "..\source\General\"
         Dim file As String = path & "TypeCache.in"
         Dim filename As String = IO.Path.GetFullPath(file)
         Dim content As String = IO.File.ReadAllText(filename)
         Dim lines As String() = content.Split(New String() {VB.vbCr, VB.vbLf, VB.vbCrLf}, StringSplitOptions.RemoveEmptyEntries)
 
         Dim cecil As New System.Text.StringBuilder
         Dim all As New System.Text.StringBuilder
 
         all.AppendLine(VB.Join(content.Substring(0, content.IndexOf("''") - 1).Split(New String() {VB.vbCr, VB.vbLf, VB.vbCrLf}, StringSplitOptions.RemoveEmptyEntries), Environment.NewLine))
 
         cecil.AppendLine("Public Partial Class CecilTypeCache")
         cecil.AppendLine(Generate(lines))
         cecil.AppendLine("End Class")
 
         all.AppendLine(cecil.ToString)
 
         IO.File.WriteAllText(path & "TypeCache.Generated.vb", all.ToString)
 
         IO.File.Copy(IO.Path.Combine(path, "TypeCache.vb"), IO.Path.Combine(path, "TypeCache.vb.old"), True)
 
         Dim oldContents As String = IO.File.ReadAllText(IO.Path.Combine(path, "TypeCache.vb"))
         Dim iStart As Integer = oldContents.IndexOf("'START" & " SRE") + ("'START " & "SRE").Length + 2
         Dim iEnd As Integer = oldContents.IndexOf("'END SRE", iStart) - 2
         oldContents = oldContents.Remove(iStart, iEnd - iStart)
         oldContents = oldContents.Insert(iStart, all.ToString())
         IO.File.WriteAllText(IO.Path.Combine(path, "TypeCache.vb"), oldContents)
         System.Diagnostics.Debug.WriteLine("Written TypeCache.vb, saved to TypeCache.vb.old")
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\BaseObject.vb" startline="275" endline="285">
<![CDATA[
     End Property
 #End If
 
     ''' <summary>
     ''' Get the token manager used for quick token management.
     ''' </summary>
     Friend Overridable ReadOnly Property tm() As tm
         Get
             Helper.Assert(Compiler IsNot Nothing)
             Return Compiler.tm
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="639" endline="653">
<![CDATA[
 
     Private Sub BtnAutoUpdate_Click(ByVal sender As Object, ByVal e As System.EventArgs) Handles BtnAutoUpdate.Click, LblAutoUpdate_Status.Click
 
         If My.Settings.AutoUpdate = True Then
             My.Settings.AutoUpdate = False
             Shell("schtasks /Change /TN WebUpdate /DISABLE", AppWinStyle.Hide)
         ElseIf My.Settings.AutoUpdate = False Then
             My.Settings.AutoUpdate = True
             Shell("schtasks /Change /TN WebUpdate /ENABLE", AppWinStyle.Hide)
         End If
 
         My.Settings.Save()
         Call Check_Status()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="364" endline="389">
<![CDATA[
 
     Private Sub BtnHelp_Click(ByVal sender As Object, ByVal e As System.EventArgs) Handles BtnHelp.Click
 
         Dim Child As Form
         For Each Child In Me.MdiChildren
             If Child.Text = "Automatic TuneUp" Then
                 Help.ShowHelp(Me, (Application.StartupPath & "\Help.chm"), HelpNavigator.Topic, "Automatic TuneUp.htm")
                 Exit Sub
             ElseIf Child.Text = "Manual TuneUp" Then
                 Help.ShowHelp(Me, (Application.StartupPath & "\Help.chm"), HelpNavigator.Topic, "Manual TuneUp.htm")
                 Exit Sub
             ElseIf Child.Text = "Gaming Mode" Then
                 Help.ShowHelp(Me, (Application.StartupPath & "\Help.chm"), HelpNavigator.Topic, "Gaming Mode.htm")
                 Exit Sub
             ElseIf Child.Text = "Services Profiles" Then
                 Help.ShowHelp(Me, (Application.StartupPath & "\Help.chm"), HelpNavigator.Topic, "Services Profiles.htm")
                 Exit Sub
             ElseIf Child.Text = "Services Manager" Then
                 Help.ShowHelp(Me, (Application.StartupPath & "\Help.chm"), HelpNavigator.Topic, "Services Manager.htm")
                 Exit Sub
             End If
         Next
 
         Help.ShowHelp(Me, (Application.StartupPath & "\Help.chm"), HelpNavigator.Topic, "Welcome.htm")
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3741" endline="3814">
<![CDATA[
 
     Private Sub cSplit_Click(ByVal sender As System.Object, _
     ByVal e As System.EventArgs) Handles cSplit.Click
 
         Dim SplitName As String
         If mFileLoaded = False Then Exit Sub
         If Len(Trim(tSplitName.Text)) = 0 Then
             MsgBox("Please specify name for split parts")
             Exit Sub
         Else
             SplitName = Trim(tSplitName.Text)
         End If
 
         'Validation
         If radTime.Checked Then
             Dim Duration As Double
             Duration = numHr.Value * 3600 + numMin.Value * 60 + numSec.Value
             If Duration > mPlayer.currentMedia.duration Then
                 MsgBox("Duration cannot be greater than media play time")
                 Exit Sub
             End If
             If Duration <= 0 Then
                 MsgBox("Duration should be at least 1 second !!")
                 Exit Sub
             End If
         End If
 
         If radPieces.Checked Then
             If numPcs.Value <= 1 Then
                 MsgBox("Number of parts required should be more than 1")
                 Exit Sub
             End If
         End If
 
         If radSize.Checked Then
             Dim Value As Integer = CInt(Val(cbSize.Text))
             If Value <= 0 Then
                 MsgBox("Please use non-zero numeric values")
                 Exit Sub
             End If
             AddToList(Value)
         End If
 
         'Running the split
         mainTabs.SelectedTab = tabTrace
         rtfTrace.SelectedText = vbCrLf
         statMain.Text = mTranslator.LangText(72)
         If chkKeepMRU.Checked Then rtfTrace.Clear()
 
         Dim Result As Boolean
         If radTime.Checked Then
             Dim Duration As Double
             Duration = numHr.Value * 3600 + numMin.Value * 60 + numSec.Value
             Result = mHandler.Split(SplitName, Duration, mPlayer.currentMedia.duration)
         End If
         If radPieces.Checked Then
             Result = mHandler.Split(SplitName, CShort(numPcs.Value), _
             mPlayer.currentMedia.duration)
         End If
         If radSize.Checked Then
             Result = mHandler.Split(SplitName, CInt(Val(cbSize.Text)))
         End If
 
         If Result Then
             UpdateRTF(vbCrLf & "Success !" & vbCrLf, modMain.MessageType.Success)
             ShowProcessStat(modMain.MessageType.Success)
         Else
             UpdateRTF(vbCrLf & "Failure !" & vbCrLf, modMain.MessageType.Failure)
             ShowProcessStat(modMain.MessageType.Failure)
         End If
         statMain.Text = mTranslator.LangText(23)
         If chkBeep.Checked Then Beep()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeConverter.vb" startline="810" endline="880">
<![CDATA[
 
     ''' <summary>
     ''' Converts the source to the destination type. Compiletime conversions are the only ones that succeeds.
     ''' Returns nothing if no conversion possible.
     ''' </summary>
     ''' <param name="Source"></param>
     ''' <param name="Destination"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Shared Function ConvertTo(ByVal Context As ParsedObject, ByVal Source As Object, ByVal Destination As Mono.Cecil.TypeReference, ByRef result As Object, ByVal ShowErrors As Boolean) As Boolean
         If Destination Is Nothing OrElse Source Is Nothing Then
             result = Source
             Return True
         End If
 
         Helper.Assert(Source IsNot Nothing)
         Helper.Assert(Destination IsNot Nothing)
 
         If TypeOf Destination Is ByReferenceType Then
             Destination = DirectCast(Destination, ByReferenceType).ElementType
         End If
 
         Dim dtc As TypeCode = Helper.GetTypeCode(Context.Compiler, Destination)
         Dim stc As TypeCode = Helper.GetTypeCode(Context.Compiler, CecilHelper.GetType(Context.Compiler, Source))
 
         'Console.WriteLine("ConvertTo
 
         If dtc = stc Then
             result = Source
             Return True
         End If
 
         Select Case dtc
             Case TypeCode.Boolean
                 Return ConvertToBoolean(Context, Source, stc, result, ShowErrors)
             Case TypeCode.Byte
                 Return ConvertToByte(Context, Source, stc, result, ShowErrors)
             Case TypeCode.Char
                 Return ConvertToChar(Context, Source, stc, result, ShowErrors)
             Case TypeCode.DateTime
                 Return ConvertToDateTime(Context, Source, stc, result, ShowErrors)
             Case TypeCode.Decimal
                 Return ConvertToDecimal(Context, Source, stc, result, ShowErrors)
             Case TypeCode.Double
                 Return ConvertToDouble(Context, Source, stc, result, ShowErrors)
             Case TypeCode.Int16
                 Return ConvertToInt16(Context, Source, stc, result, ShowErrors)
             Case TypeCode.Int32
                 Return ConvertToInt32(Context, Source, stc, result, ShowErrors)
             Case TypeCode.Int64
                 Return ConvertToInt64(Context, Source, stc, result, ShowErrors)
             Case TypeCode.SByte
                 Return ConvertToSByte(Context, Source, stc, result, ShowErrors)
             Case TypeCode.Single
                 Return ConvertToSingle(Context, Source, stc, result, ShowErrors)
             Case TypeCode.String
                 Return ConvertToString(Context, Source, stc, result, ShowErrors)
             Case TypeCode.UInt16
                 Return ConvertToUInt16(Context, Source, stc, result, ShowErrors)
             Case TypeCode.UInt32
                 Return ConvertToUInt32(Context, Source, stc, result, ShowErrors)
             Case TypeCode.UInt64
                 Return ConvertToUInt64(Context, Source, stc, result, ShowErrors)
             Case TypeCode.Object
                 result = Source
                 Return True
             Case Else
                 'This should never happen 
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, CObj(dtc).ToString())
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="359" endline="427">
<![CDATA[
 
     Public Shared Function InflateType(ByVal original As TypeReference, ByVal parameters As Mono.Collections.Generic.Collection(Of GenericParameter), ByVal arguments As Mono.Collections.Generic.Collection(Of TypeReference)) As TypeReference
         Dim spec As TypeSpecification = TryCast(original, TypeSpecification)
         Dim array As ArrayType = TryCast(original, ArrayType)
         Dim reference As ByReferenceType = TryCast(original, ByReferenceType)
         Dim genericType As GenericInstanceType = TryCast(original, GenericInstanceType)
         Dim originalDef As TypeDefinition = TryCast(original, TypeDefinition)
 
         If parameters Is Nothing AndAlso arguments Is Nothing Then Return original
 
         If originalDef IsNot Nothing Then
             If originalDef.GenericParameters.Count = 0 Then Return original
             Dim result As New GenericInstanceType(originalDef)
             For i As Integer = 0 To originalDef.GenericParameters.Count - 1
                 Dim tG As GenericParameter = originalDef.GenericParameters(i)
                 If tG.Owner Is originalDef Then
                     result.GenericArguments.Add(InflateType(originalDef.GenericParameters(i), parameters, arguments))
                 Else
                     result.GenericArguments.Add(originalDef.GenericParameters(i))
                 End If
             Next
             Return result
         End If
 
         If parameters.Count <> arguments.Count Then
             Throw New System.ArgumentException("Parameters and Arguments must have the same number of elements.")
         End If
 
         Dim genParam As GenericParameter = TryCast(original, GenericParameter)
         If genParam IsNot Nothing Then
             If Not TypeOf genParam.Owner Is TypeReference Then
                 For i As Integer = 0 To parameters.Count - 1
                     If parameters(i).Owner Is genParam.Owner AndAlso parameters(i).Position = genParam.Position Then
                         Return arguments(i)
                     End If
                 Next
                 Return genParam
             End If
             Helper.Assert(genParam.Position < arguments.Count)
             Return arguments.Item(genParam.Position)
         End If
 
         If genericType IsNot Nothing Then
             Dim result As New GenericInstanceType(CecilHelper.FindDefinition(genericType.ElementType))
             For i As Integer = 0 To result.ElementType.GenericParameters.Count - 1
                 result.GenericArguments.Add(InflateType(genericType.GenericArguments(i), parameters, arguments))
             Next
             Return result
         End If
 
         If spec IsNot Nothing Then
             Dim resolved As TypeReference = InflateType(spec.ElementType, parameters, arguments)
 
             If resolved Is spec.ElementType Then
                 Return spec
             End If
 
 
             If array IsNot Nothing Then
                 Return New ArrayType(resolved, array.Dimensions.Count)
             ElseIf reference IsNot Nothing Then
                 Return New ByReferenceType(resolved)
             Else
                 Throw New System.NotImplementedException()
             End If
         Else
             Return original
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\MRUbuffer.vb" startline="40" endline="46">
<![CDATA[
             Get
                 If Object.ReferenceEquals(resourceMan, Nothing) Then
                     Dim temp As Global.System.Resources.ResourceManager = New Global.System.Resources.ResourceManager("Editor.Resources", GetType(Resources).Assembly)
                     resourceMan = temp
                 End If
                 Return resourceMan
             End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Modules\Common.vb" startline="40" endline="46">
<![CDATA[
             Get
                 If Object.ReferenceEquals(resourceMan, Nothing) Then
                     Dim temp As Global.System.Resources.ResourceManager = New Global.System.Resources.ResourceManager("ServicesOptimizer.Resources", GetType(Resources).Assembly)
                     resourceMan = temp
                 End If
                 Return resourceMan
             End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1930" endline="1976">
<![CDATA[
 
     Shared Function SwitchVersionedMethods(ByVal Info As EmitInfo, ByVal UnversionedMethod As Mono.Cecil.MethodReference) As Mono.Cecil.MethodReference
         If Info.Compiler.CommandLine.VBVersion <> CommandLine.VBVersions.V8 Then Return UnversionedMethod
 
         Dim tc As CecilTypeCache = Info.Compiler.TypeCache
         Dim check(4) As Mono.Cecil.MethodDefinition
         Dim replace(4) As Mono.Cecil.MethodDefinition
         Dim unv(4) As Mono.Cecil.MethodDefinition
 
         check(0) = tc.MS_VB_Information__IsNumeric
         check(1) = tc.MS_VB_Information__SystemTypeName
         check(2) = tc.MS_VB_Information__TypeName
         check(3) = tc.MS_VB_Information__VbTypeName
         check(4) = tc.MS_VB_Interaction__CallByName
 
         replace(0) = tc.MS_VB_CS_Versioned__IsNumeric
         replace(1) = tc.MS_VB_CS_Versioned__SystemTypeName
         replace(2) = tc.MS_VB_CS_Versioned__TypeName
         replace(3) = tc.MS_VB_CS_Versioned__VbTypeName
         replace(4) = tc.MS_VB_CS_Versioned__CallByName
 
         For i As Integer = 0 To check.Length - 1
             If check(i) Is UnversionedMethod Then Return replace(i)
         Next
 
         For i As Integer = 0 To check.Length - 1
             unv(i) = CecilHelper.FindDefinition(UnversionedMethod)
             If check(i) Is unv(i) Then Return replace(i)
         Next
 
         For i As Integer = 0 To check.Length - 1
             If unv(i) Is Nothing Then Continue For
             If check(i) Is Nothing Then Continue For
             If Helper.CompareName(unv(i).Name, check(i).Name) = False Then Continue For
             If Helper.CompareName(unv(i).DeclaringType.Name, check(i).DeclaringType.Name) = False Then Continue For
             If Helper.CompareName(unv(i).DeclaringType.Namespace, check(i).DeclaringType.Namespace) = False Then Continue For
             'There shouldn't be any need to check parameters, since these methods aren't overloaded
             Return replace(i)
         Next
 
 
         'Check if the object comparison above is true for cecil as well (that is if same method may have multiple object references)
         'This will assert while compiling the compiler if object comparison doesn't hold for cecil.
         Helper.Assert(UnversionedMethod.Name <> "IsNumeric")
 
         Return UnversionedMethod
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4079" endline="4155">
<![CDATA[
 
     Overloads Shared Function ToString(ByVal Context As BaseObject, ByVal Member As MethodReference) As String
         Dim builder As New Text.StringBuilder()
         Dim isSub As Boolean = Helper.CompareType(Member.ReturnType, Context.Compiler.TypeCache.System_Void)
 
         builder.Append(ToString(GetAccessibility(Member)))
         builder.Append(" ")
         If Helper.CompareNameOrdinal(Member.Name, ".ctor") Then
             builder.Append("Sub New(")
             builder.Append(Helper.ToString(Context, Helper.GetParameters(Context, Member)))
             builder.Append(")")
         Else
             If isSub Then
                 builder.Append("Sub ")
             Else
                 builder.Append("Function ")
             End If
             builder.Append(Member.Name)
             If Member.HasGenericParameters Then
                 builder.Append("(Of ")
                 For i As Integer = 0 To Member.GenericParameters.Count - 1
                     Dim gp As GenericParameter = Member.GenericParameters(i)
                     Dim constraints As New Text.StringBuilder
                     Dim constraintCount As Integer
 
                     If i > 0 Then builder.Append(", ")
                     builder.Append(gp.Name)
 
                     If gp.HasNotNullableValueTypeConstraint Then
                         If constraintCount > 0 Then constraints.Append(", ")
                         constraints.Append("Structure")
                         constraintCount += 1
                     End If
                     If gp.HasDefaultConstructorConstraint AndAlso gp.HasNotNullableValueTypeConstraint = False Then
                         If constraintCount > 0 Then constraints.Append(", ")
                         constraints.Append("New")
                         constraintCount += 1
                     End If
                     If gp.HasReferenceTypeConstraint Then
                         If constraintCount > 0 Then constraints.Append(", ")
                         constraints.Append("Class")
                         constraintCount += 1
                     End If
                     For c As Integer = 0 To gp.Constraints.Count - 1
                         If Helper.CompareType(Context.Compiler.TypeCache.System_ValueType, gp.Constraints(i)) Then Continue For
                         If constraintCount > 0 Then constraints.Append(", ")
                         constraints.Append(gp.Constraints(i).Name)
                         constraintCount += 1
                     Next
                     If constraintCount > 0 Then
                         builder.Append(" As ")
                         If constraintCount > 1 Then builder.Append("{")
                         builder.Append(constraints)
                         If constraintCount > 1 Then builder.Append("}")
                     End If
                 Next
                 builder.Append(")")
             End If
             'builder.Append("(")
             'For i As Integer = 0 To Member.Parameters.Count - 1
             'If i > 0 Then builder.Append(", ")
             'Dim param As ParameterDefinition = Member.Parameters(i)
             'If CecilHelper.IsByRef(param.ParameterType) Then builder.Append("ByRef ")
             'builder.Append(param.Name)
             'builder.Append(" As ")
             'builder.Append(Helper.ToString(Context, param.ParameterType))
             builder.Append(Helper.ToString(Context, Member.Parameters))
             'Next
             'builder.Append(")")
             If isSub = False Then
                 builder.Append(" As ")
                 builder.Append(Helper.ToString(Context, Member.ReturnType))
             End If
         End If
 
         Return builder.ToString()
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\BoundList.vb" startline="92" endline="143">
<![CDATA[
 
     Shared Function GetDecimalConstant(ByVal Compiler As Compiler, ByVal Field As Mono.Cecil.FieldDefinition, ByRef value As Decimal) As Boolean
         Dim decAttrs As Mono.Collections.Generic.Collection(Of CustomAttribute)
         decAttrs = CecilHelper.GetCustomAttributes(Field.CustomAttributes, Compiler.TypeCache.System_Runtime_CompilerServices_DecimalConstantAttribute)
         If decAttrs IsNot Nothing AndAlso decAttrs.Count = 1 Then
             Dim attr As Mono.Cecil.CustomAttribute = decAttrs(0)
             Dim scale As Byte, sign As Byte
             Dim hi1 As Integer, mid1 As Integer, low1 As Integer
             Dim isUnsigned As Boolean
 
             If attr.ConstructorArguments.Count <> 5 Then Return False
             If TypeOf attr.ConstructorArguments(0).Value Is Byte = False Then Return False
             If TypeOf attr.ConstructorArguments(1).Value Is Byte = False Then Return False
 
             scale = DirectCast(attr.ConstructorArguments(0).Value, Byte)
             sign = DirectCast(attr.ConstructorArguments(1).Value, Byte)
 
             If TypeOf attr.ConstructorArguments(2).Value Is Integer Then
                 hi1 = DirectCast(attr.ConstructorArguments(2).Value, Integer)
                 isUnsigned = False
             ElseIf TypeOf attr.ConstructorArguments(2).Value Is UInteger Then
                 hi1 = BitConverter.ToInt32(BitConverter.GetBytes(DirectCast(attr.ConstructorArguments(2).Value, UInteger)), 0)
                 isUnsigned = True
             Else
                 Return False
             End If
 
             If TypeOf attr.ConstructorArguments(3).Value Is Integer Then
                 If isUnsigned Then Return False
                 mid1 = DirectCast(attr.ConstructorArguments(3).Value, Integer)
             ElseIf TypeOf attr.ConstructorArguments(3).Value Is UInteger Then
                 If isUnsigned = False Then Return False
                 mid1 = BitConverter.ToInt32(BitConverter.GetBytes(DirectCast(attr.ConstructorArguments(3).Value, UInteger)), 0)
             Else
                 Return False
             End If
 
             If TypeOf attr.ConstructorArguments(4).Value Is Integer Then
                 If isUnsigned Then Return False
                 low1 = DirectCast(attr.ConstructorArguments(4).Value, Integer)
             ElseIf TypeOf attr.ConstructorArguments(4).Value Is UInteger Then
                 If isUnsigned = False Then Return False
                 low1 = BitConverter.ToInt32(BitConverter.GetBytes(DirectCast(attr.ConstructorArguments(4).Value, UInteger)), 0)
             Else
                 Return False
             End If
 
             value = New Decimal(low1, mid1, hi1, sign <> 0, scale)
             Return True
         End If
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="59" endline="82">
<![CDATA[
     Public Shared Sub Main(ByVal args As String())
         Console.WriteLine("Chapter 1 example 3
 
         ' step 1
         Dim document As New Document(PageSize.A4.rotate())
 
         ' step 2
         ' we create a writer that listens to the document
         ' and directs a PDF-stream to a file
 
         PdfWriter.getInstance(document, New FileOutputStream("Chap0103.pdf"))
 
         ' step 3
         document.open()
 
         ' step 4
         Dim i As Integer
         For i = 0 To 20
             document.add(New Phrase("Hello World, Hello Sun, Hello Moon, Hello Stars, Hello Sea, Hello Land, Hello People. "))
         Next
 
         ' step 5
         document.close()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="54" endline="79">
<![CDATA[
     End Property
 
     Public Overrides Function GetConstant(ByRef m_ConstantValue As Object, ByVal lvalue As Object, ByVal rvalue As Object) As Boolean
         If lvalue Is Nothing Then lvalue = 0
         If rvalue Is Nothing Then rvalue = 0
 
         Dim tlvalue, trvalue As Mono.Cecil.TypeReference
         Dim clvalue, crvalue As TypeCode
         tlvalue = CecilHelper.GetType(Compiler, lvalue)
         clvalue = Helper.GetTypeCode(Compiler, tlvalue)
         trvalue = CecilHelper.GetType(Compiler, rvalue)
         crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
         Helper.Assert(Compiler.TypeResolution.IsNumericType(tlvalue) AndAlso Compiler.TypeResolution.IsNumericType(trvalue))
 
         'An exponent operator always returns a double result.
         Select Case clvalue
             Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, _
              TypeCode.Int64, TypeCode.UInt64, TypeCode.Double, TypeCode.Single, TypeCode.Decimal
                 m_ConstantValue = Math.Pow(CDbl(lvalue), CDbl(rvalue))
             Case Else
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\Main.vb" startline="13" endline="66">
<![CDATA[
     Sub New()
         ReDim Formats(5)
 
         'Windows Media
         Formats(0) = New Format
         With Formats(0)
             .Name = "Windows Video Format"
             ReDim .Extensions(1)
             .Extensions(0) = ".wmv"
             .Extensions(1) = ".asf"
         End With
 
         'MPEG
         Formats(1) = New Format
         With Formats(1)
             .Name = "MPEG Format"
             ReDim .Extensions(1)
             .Extensions(0) = ".mpg"
             .Extensions(1) = ".mpeg"
         End With
 
         'Real Media
         Formats(2) = New Format
         With Formats(2)
             .Name = "Real Media"
             ReDim .Extensions(0)
             .Extensions(0) = ".rm"
         End With
 
         'Flash Video
         Formats(3) = New Format
         With Formats(3)
             .Name = "Flash Video"
             ReDim .Extensions(0)
             .Extensions(0) = ".flv"
         End With
 
         'Windows Audio
         Formats(4) = New Format
         With Formats(4)
             .Name = "Windows Audio"
             ReDim .Extensions(0)
             .Extensions(0) = ".wma"
         End With
 
         'MP3
         Formats(5) = New Format
         With Formats(5)
             .Name = "MP3 Files"
             ReDim .Extensions(0)
             .Extensions(0) = ".mp3"
         End With
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\OperatorDeclaration.vb" startline="45" endline="134">
<![CDATA[
 
     Shadows Sub Init(ByVal Modifiers As Modifiers, ByVal Identifier As String, ByVal Symbol As KS, ByVal Operand1 As Operand, ByVal Operand2 As Operand, ByVal ReturnTypeAttributes As Attributes, ByVal TypeName As TypeName, ByVal Block As CodeBlock)
 
         Helper.Assert(Identifier Is Nothing Xor Symbol = KS.None)
 
         Dim mySignature As New FunctionSignature(Me)
         Dim parameters As New ParameterList(Me)
         Dim name As String
 
         parameters.Add(New Parameter(parameters, Operand1.Name, Operand1.TypeName))
         If Operand2 IsNot Nothing Then
             parameters.Add(New Parameter(parameters, Operand2.Name, Operand2.TypeName))
         End If
 
 
         If Identifier IsNot Nothing Then
             Dim opname As String
             opname = Identifier
             If Helper.CompareName(opname, "IsTrue") Then
                 name = "op_True"
             ElseIf Helper.CompareName(opname, "IsFalse") Then
                 name = "op_False"
             Else
                 Throw New InternalException(Me)
             End If
         Else
             Select Case Symbol
                 Case KS.Add
                     If Operand2 IsNot Nothing Then
                         name = "op_Addition"
                     Else
                         name = "op_UnaryPlus"
                     End If
                 Case KS.Minus
                     If Operand2 IsNot Nothing Then
                         name = "op_Subtraction"
                     Else
                         name = "op_UnaryNegation"
                     End If
                 Case KS.Mult
                     name = "op_Multiply"
                 Case KS.IntDivision
                     name = "op_IntegerDivision"
                 Case KS.RealDivision
                     name = "op_Division"
                 Case KS.Concat
                     name = "op_Concatenate"
                 Case KS.Like
                     name = "op_Like"
                 Case KS.Mod
                     name = "op_Modulus"
                 Case KS.And
                     name = "op_BitwiseAnd"
                 Case KS.Or
                     name = "op_BitwiseOr"
                 Case KS.Xor
                     name = "op_ExclusiveOr"
                 Case KS.Power
                     name = "op_Exponent"
                 Case KS.ShiftLeft
                     name = "op_LeftShift"
                 Case KS.ShiftRight
                     name = "op_RightShift"
                 Case KS.Equals
                     name = "op_Equality"
                 Case KS.NotEqual
                     name = "op_Inequality"
                 Case KS.GT
                     name = "op_GreaterThan"
                 Case KS.LT
                     name = "op_LessThan"
                 Case KS.GE
                     name = "op_GreaterThanOrEqual"
                 Case KS.LE
                     name = "op_LessThanOrEqual"
                 Case KS.Not
                     name = "op_OnesComplement"
                 Case Else
                     Throw New InternalException(Me)
             End Select
         End If
         Helper.Assert(name <> "")
         mySignature.Init(name, Nothing, parameters, ReturnTypeAttributes, TypeName, Me.Location)
 
         'm_Operator = [Operator]
         m_Operand1 = Operand1
         m_Operand2 = Operand2
 
         MyBase.Init(Modifiers, mySignature, Block)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2118" endline="2133">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' If there is only one shared compiler, that one is returned, otherwise nothing is returned.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared ReadOnly Property SharedCompiler() As Compiler
         Get
             If m_SharedCompilers.Count = 1 Then
                 Return m_SharedCompilers(0)
             Else
                 Return Nothing
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\StructureDeclaration.vb" startline="299" endline="359">
<![CDATA[
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         result = MyBase.ResolveTypeReferences AndAlso result
 
         If File IsNot Nothing AndAlso File.IsOptionCompareText AndAlso m_AddedCompareTextAttribute = False Then
             m_AddedCompareTextAttribute = True
             AddCustomAttribute(New Attribute(Me, Compiler.TypeCache.MS_VB_CS_OptionTextAttribute))
         End If
 
         m_StaticVariables = New Generic.List(Of LocalVariableDeclaration)
         For Each method As MethodDeclaration In m_Members.GetSpecificMembers(Of MethodDeclaration)()
             If method.Code IsNot Nothing Then method.Code.FindStaticVariables(m_StaticVariables)
         Next
         For Each prop As PropertyDeclaration In m_Members.GetSpecificMembers(Of PropertyDeclaration)()
             If prop.GetDeclaration IsNot Nothing AndAlso prop.GetDeclaration.Code IsNot Nothing Then prop.GetDeclaration.Code.FindStaticVariables(m_StaticVariables)
             If prop.SetDeclaration IsNot Nothing AndAlso prop.SetDeclaration.Code IsNot Nothing Then prop.SetDeclaration.Code.FindStaticVariables(m_StaticVariables)
         Next
 
         'Create nested generic type parameters
         If Me.IsNestedType Then
             Dim parentType As TypeDeclaration = DeclaringType
             Dim parentGenericType As GenericTypeDeclaration
             Dim stack As New Generic.Stack(Of TypeParameter)
             Dim insertAt As Integer = 0
 
             Do
                 parentGenericType = TryCast(parentType, GenericTypeDeclaration)
                 If parentGenericType IsNot Nothing AndAlso parentGenericType.TypeParameters IsNot Nothing Then
                     For i As Integer = parentGenericType.TypeParameters.Parameters.Count - 1 To 0 Step -1
                         stack.Push(parentGenericType.TypeParameters.Parameters(i))
                     Next
                 End If
                 parentType = parentType.DeclaringType
             Loop While parentType IsNot Nothing
 
             Dim typeParameter As TypeParameter
 
             Do While stack.Count > 0
                 typeParameter = stack.Pop
                 CecilType.GenericParameters.Insert(insertAt, typeParameter.Clone(typeParameter.CecilBuilder, CecilType, CecilType.GenericParameters.Count))
                 insertAt += 1
             Loop
             Do While stack.Count > 0
                 typeParameter = stack.Pop
                 CecilType.GenericParameters.Insert(insertAt, typeParameter.Clone(typeParameter.CecilBuilder, CecilType, CecilType.GenericParameters.Count))
                 insertAt += 1
             Loop
 
             Dim enumDecl As EnumDeclaration = TryCast(Me, EnumDeclaration)
             If enumDecl IsNot Nothing AndAlso CecilType.GenericParameters.Count > 0 Then
                 Dim enumFieldType As New Mono.Cecil.GenericInstanceType(CecilType)
                 For i As Integer = 0 To CecilType.GenericParameters.Count - 1
                     enumFieldType.GenericArguments.Add(CecilType.GenericParameters(i))
                 Next
                 For i As Integer = 0 To enumDecl.Members.Count - 1
                     Dim enumField As EnumMemberDeclaration = TryCast(enumDecl.Members(i), EnumMemberDeclaration)
                     If enumField Is Nothing Then Continue For
                     enumField.FieldBuilder.FieldType = enumFieldType
                 Next
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="59" endline="82">
<![CDATA[
     Public Shared Sub Main(ByVal args As String())
         Console.WriteLine("Chapter 1 example 3
 
         ' step 1
         Dim document As New Document(PageSize.A4.rotate())
 
         ' step 2
         ' we create a writer that listens to the document
         ' and directs a PDF-stream to a file
 
         PdfWriter.getInstance(document, New FileOutputStream("Chap0103.pdf"))
 
         ' step 3
         document.open()
 
         ' step 4
         Dim i As Integer
         For i = 0 To 20
             document.add(New Phrase("Hello World, Hello Sun, Hello Moon, Hello Stars, Hello Sea, Hello Land, Hello People. "))
         Next
 
         ' step 5
         document.close()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2293" endline="2345">
<![CDATA[
 
     ''' <summary>
     ''' Get the type attribute from the scope
     ''' </summary>
     ''' <param name="Modifiers"></param>
     ''' <param name="isNested"></param>
     ''' <returns></returns>
     ''' <remarks>
     ''' Scope
     ''' Private = private
     ''' Protected = family
     ''' Protected Friend = famorassem
     ''' Friend = assembly
     ''' Public = public
     ''' </remarks>
     Shared Function getTypeAttributeScopeFromScope(ByVal Modifiers As Modifiers, ByVal isNested As Boolean) As Mono.Cecil.TypeAttributes
         If Not isNested Then
             'If vbnc.Modifiers.IsNothing(Modifiers) = False Then
             If Modifiers.Is(ModifierMasks.Public) Then
                 Return Mono.Cecil.TypeAttributes.Public
             Else
                 Return Mono.Cecil.TypeAttributes.NotPublic
             End If
             'Else
             '  Return TypeAttributes.NotPublic
             'End If
         Else
             'If vbnc.Modifiers.IsNothing(Modifiers) = False Then
             If Modifiers.Is(ModifierMasks.Public) Then
                 Return Mono.Cecil.TypeAttributes.NestedPublic
             ElseIf Modifiers.Is(ModifierMasks.Friend) Then
                 If Modifiers.Is(ModifierMasks.Protected) Then
                     Return Mono.Cecil.TypeAttributes.NestedFamORAssem
                     '0Return Reflection.TypeAttributes.NotPublic
                     'Return Reflection.TypeAttributes.VisibilityMask
                 Else
                     Return Mono.Cecil.TypeAttributes.NestedAssembly
                     'Return Reflection.TypeAttributes.NotPublic
                 End If
             ElseIf Modifiers.Is(ModifierMasks.Protected) Then
                 Return Mono.Cecil.TypeAttributes.NestedFamily
                 'Return Reflection.TypeAttributes.NotPublic
             ElseIf Modifiers.Is(ModifierMasks.Private) Then
                 Return Mono.Cecil.TypeAttributes.NestedPrivate
             Else
                 'Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Default scope set to public...")
                 Return Mono.Cecil.TypeAttributes.NestedPublic
             End If
             ' Else
             'Return Reflection.TypeAttributes.NestedPublic
             'End If
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4318" endline="4398">
<![CDATA[
 
     Shared Function IsFirstMoreApplicable(ByVal Context As BaseObject, ByVal Arguments As Generic.List(Of Argument), ByVal MTypes As Mono.Cecil.TypeReference(), ByVal NTypes() As Mono.Cecil.TypeReference) As Boolean
         Dim Compiler As Compiler = Context.Compiler
         Dim result As Boolean = True
         'A member M is considered more applicable than N if their signatures are different and, 
         'for each pair of parameters Mj and Nj that matches an argument Aj, 
         'one of the following conditions is true
         '*	Mj and Nj have identical types, or
         '*	There exists a widening conversion from the type of Mj to the type Nj, or
         '*	Aj is the literal 0, Mj is a numeric type and Nj is an enumerated type, or
         '*	Mj is Byte and Nj is SByte, or
         '*  Mj is Short and Nj is UShort, or
         '*	Mj is Integer and Nj is UInteger, or 
         '*	Mj is Long and Nj is ULong.
 
         'LAMESPEC?
         'I've found that the previous section must be
         '*	Mj is Byte and Nj is SByte, or
         '*  Mj is Short/Byte and Nj is UShort, or
         '*	Mj is Integer/Short/Byte and Nj is UInteger, or 
         '*	Mj is Long/Integer/Short/Byte and Nj is ULong.
         'example that doesn't work otherwise
         ' Two methods with parameter types Int32 and UInt64 which is passed in a UInt16.
 
         'A member M is considered more applicable than N if their signatures are different 
         If Helper.CompareTypes(MTypes, NTypes) Then
             'Signatures are not different so none is more applicable
             Return False
         End If
 
         For i As Integer = 0 To Arguments.Count - 1
             Dim is1stMoreApplicable As Boolean
             Dim isEqual, isWidening, isLiteral0 As Boolean
             Dim isMByte, isMShort, isMInteger, isMLong As Boolean
             Dim isNByte, isNShort, isNInteger, isNLong As Boolean
             'Dim isMSigned, isNUnsigned As Boolean 'Names are not accurate for Byte/SByte
 
             If MTypes.Length - 1 < i OrElse NTypes.Length - 1 < i Then Exit For
 
             '*	Mj and Nj have identical types, or
             isEqual = Helper.CompareType(MTypes(i), NTypes(i))
 
             '*	There exists a widening conversion from the type of Mj to the type Nj, or
             'isWidening = Compiler.TypeResolution.IsImplicitlyConvertible(Context, MTypes(i), NTypes(i))
             isWidening = Helper.IsConvertible(Arguments(i), Arguments(i).Expression, MTypes(i), NTypes(i), False, Nothing, False, True, False)
 
             '*	Aj is the literal 0, Mj is a numeric type and Nj is an enumerated type, or
             isLiteral0 = IsLiteral0Expression(Compiler, Arguments(i).Expression) AndAlso Compiler.TypeResolution.IsNumericType(MTypes(i)) AndAlso Helper.IsEnum(Compiler, NTypes(i))
 
             isMByte = Helper.CompareType(MTypes(i), Compiler.TypeCache.System_Byte)
             isMShort = isMByte = False AndAlso Helper.CompareType(MTypes(i), Compiler.TypeCache.System_Int16)
             isMInteger = isMByte = False AndAlso isMShort = False AndAlso Helper.CompareType(MTypes(i), Compiler.TypeCache.System_Int32)
             isMLong = isMByte = False AndAlso isMShort = False AndAlso isMInteger = False AndAlso Helper.CompareType(MTypes(i), Compiler.TypeCache.System_Int64)
 
             isNByte = Helper.CompareType(NTypes(i), Compiler.TypeCache.System_SByte)
             isNShort = isNByte = False AndAlso Helper.CompareType(NTypes(i), Compiler.TypeCache.System_UInt16)
             isNInteger = isNByte = False AndAlso isNShort = False AndAlso Helper.CompareType(NTypes(i), Compiler.TypeCache.System_UInt32)
             isNLong = isNByte = False AndAlso isNShort = False AndAlso isNInteger = False AndAlso Helper.CompareType(NTypes(i), Compiler.TypeCache.System_UInt64)
 
             ''*	Mj is Byte and Nj is SByte, or
             'isByte = Helper.CompareType(MTypes(i), Compiler.TypeCache.System_Byte) AndAlso Helper.CompareType(NTypes(i), Compiler.TypeCache.System_SByte)
 
             ''*	Mj is Short and Nj is UShort, or
             'isShort = Helper.CompareType(MTypes(i), Compiler.TypeCache.System_Int16) AndAlso Helper.CompareType(NTypes(i), Compiler.TypeCache.System_UInt16)
 
             ''*	Mj is Integer and Nj is UInteger, or 
             'isInteger = Helper.CompareType(MTypes(i), Compiler.TypeCache.System_Int32) AndAlso Helper.CompareType(NTypes(i), Compiler.TypeCache.System_UInt32)
 
             ''*	Mj is Long and Nj is ULong.
             'isLong = Helper.CompareType(MTypes(i), Compiler.TypeCache.System_Int64) AndAlso Helper.CompareType(NTypes(i), Compiler.TypeCache.System_UInt64)
 
             is1stMoreApplicable = isEqual OrElse isWidening OrElse isLiteral0
             is1stMoreApplicable = is1stMoreApplicable OrElse (isMByte AndAlso isNByte)
             is1stMoreApplicable = is1stMoreApplicable OrElse ((isMByte OrElse isMShort) AndAlso isNShort)
             is1stMoreApplicable = is1stMoreApplicable OrElse ((isMByte OrElse isMShort OrElse isMInteger) AndAlso isNInteger)
             is1stMoreApplicable = is1stMoreApplicable OrElse ((isMByte OrElse isMShort OrElse isMInteger OrElse isMLong) AndAlso isNLong)
             result = is1stMoreApplicable AndAlso result
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="63" endline="141">
<![CDATA[
     End Property
 
     Public Overrides Function GetConstant(ByRef result As Object, ByVal lvalue As Object, ByVal rvalue As Object) As Boolean
         Dim tlvalue, trvalue As Mono.Cecil.TypeReference
         Dim clvalue, crvalue As TypeCode
 
         tlvalue = CecilHelper.GetType(Compiler, lvalue)
         clvalue = Helper.GetTypeCode(Compiler, tlvalue)
         trvalue = CecilHelper.GetType(Compiler, rvalue)
         crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
         Dim csmallest As TypeCode
         csmallest = vbnc.TypeConverter.GetBinaryOperandType(Compiler, Me.Keyword, tlvalue, trvalue)
 
         Select Case csmallest
             Case TypeCode.Byte
                 If CByte(lvalue) < CByte(rvalue) Then
                     result = CSByte(lvalue) - CSByte(rvalue)
                 Else
                     result = CByte(lvalue) - CByte(rvalue)
                 End If
             Case TypeCode.SByte
                 Dim tmp As Short = CShort(lvalue) - CShort(rvalue)
                 If tmp < SByte.MinValue OrElse tmp > SByte.MaxValue Then
                     result = tmp
                 Else
                     result = CSByte(tmp)
                 End If
             Case TypeCode.Int16
                 Dim tmp As Integer = CInt(lvalue) - CInt(rvalue)
                 If tmp > Short.MaxValue OrElse tmp < Short.MinValue Then
                     result = tmp
                 Else
                     result = CShort(tmp)
                 End If
             Case TypeCode.UInt16
                 If CUShort(lvalue) < CUShort(rvalue) Then
                     result = CShort(lvalue) - CShort(rvalue)
                 Else
                     result = CUShort(lvalue) - CUShort(rvalue)
                 End If
             Case TypeCode.Int32
                 Dim tmp As Long = CLng(lvalue) - CLng(rvalue)
                 If tmp > Integer.MaxValue OrElse tmp < Integer.MinValue Then
                     result = tmp
                 Else
                     result = CInt(tmp)
                 End If
             Case TypeCode.UInt32
                 If CUInt(lvalue) < CUInt(rvalue) Then
                     result = CInt(lvalue) - CInt(rvalue)
                 Else
                     result = CUInt(lvalue) - CUInt(rvalue)
                 End If
             Case TypeCode.Int64
                 Dim tmp As Double = CLng(lvalue) - CLng(rvalue)
                 If tmp < Long.MinValue OrElse tmp > Long.MaxValue Then
                     result = tmp
                 Else
                     result = CLng(tmp)
                 End If
             Case TypeCode.UInt64
                 If CULng(lvalue) < CULng(rvalue) Then
                     result = CLng(lvalue) - CLng(rvalue)
                 Else
                     result = CULng(lvalue) - CULng(rvalue)
                 End If
             Case TypeCode.Double
                 result = CDbl(lvalue) - CDbl(rvalue) 'No overflow possible
             Case TypeCode.Single
                 result = CSng(lvalue) - CSng(rvalue) 'No overflow possible
             Case TypeCode.Decimal
                 result = CDec(lvalue) - CDec(rvalue)
             Case Else
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="143" endline="224">
<![CDATA[
 
     Public Shared Function GetAttributes(ByVal m_Declaration As MethodBaseDeclaration) As Mono.Cecil.MethodAttributes
         Dim result As Mono.Cecil.MethodAttributes
         Dim cd As ConstructorDeclaration = TryCast(m_Declaration, ConstructorDeclaration)
 
         If cd IsNot Nothing Then Return GetAttributes(cd)
 
         result = m_Declaration.Modifiers.GetMethodAttributeScope
 
         'If Modifiers.IsNothing(m_Declaration.Modifiers) = False Then
         If m_Declaration.IsShared Then
             result = result Or Mono.Cecil.MethodAttributes.Static
         End If
         If m_Declaration.Modifiers.Is(ModifierMasks.MustOverride) Then
             If m_Declaration.Modifiers.Is(ModifierMasks.Overrides) = False Then
                 result = result Or Mono.Cecil.MethodAttributes.NewSlot
             End If
             result = result Or Mono.Cecil.MethodAttributes.Abstract Or Mono.Cecil.MethodAttributes.Virtual Or Mono.Cecil.MethodAttributes.CheckAccessOnOverride
         End If
         If m_Declaration.Modifiers.Is(ModifierMasks.NotOverridable) Then
             result = result Or Mono.Cecil.MethodAttributes.Final
         End If
         If m_Declaration.Modifiers.Is(ModifierMasks.Overridable) Then
             result = result Or Mono.Cecil.MethodAttributes.NewSlot Or Mono.Cecil.MethodAttributes.Virtual Or Mono.Cecil.MethodAttributes.CheckAccessOnOverride
         End If
         If m_Declaration.Modifiers.Is(ModifierMasks.Overrides) Then
             result = result Or Mono.Cecil.MethodAttributes.Virtual Or Mono.Cecil.MethodAttributes.CheckAccessOnOverride
         End If
         If m_Declaration.Modifiers.Is(ModifierMasks.Overloads) Then
             result = result Or Mono.Cecil.MethodAttributes.HideBySig
         End If
         'End If
 
         If TypeOf m_Declaration.Parent Is PropertyDeclaration Then
             result = result Or Mono.Cecil.MethodAttributes.SpecialName
         End If
 
         If TypeOf m_Declaration Is ExternalSubDeclaration Then
             result = result Or Mono.Cecil.MethodAttributes.Static
         End If
 
         If m_Declaration.HandlesOrImplements IsNot Nothing Then
             If m_Declaration.HandlesOrImplements.ImplementsClause IsNot Nothing Then
                 result = result Or Mono.Cecil.MethodAttributes.Virtual Or Mono.Cecil.MethodAttributes.CheckAccessOnOverride
                 If m_Declaration.Modifiers.Is(ModifierMasks.Overrides) = False Then
                     result = result Or Mono.Cecil.MethodAttributes.NewSlot
                 End If
                 If m_Declaration.Modifiers.Is(ModifierMasks.Overridable) = False AndAlso m_Declaration.Modifiers.Is(ModifierMasks.MustOverride) = False AndAlso m_Declaration.Modifiers.Is(ModifierMasks.Overrides) = False Then
                     result = result Or Mono.Cecil.MethodAttributes.Final
                 End If
             End If
         End If
 
         If TypeOf m_Declaration.Parent Is EventDeclaration Then
             If DirectCast(m_Declaration.Parent, EventDeclaration).ImplementsClause IsNot Nothing Then
                 result = result Or Mono.Cecil.MethodAttributes.Virtual Or Mono.Cecil.MethodAttributes.NewSlot Or Mono.Cecil.MethodAttributes.CheckAccessOnOverride Or Mono.Cecil.MethodAttributes.Final
             End If
         End If
 
         If m_Declaration.DeclaringType.IsInterface Then
             result = result Or Mono.Cecil.MethodAttributes.Abstract Or Mono.Cecil.MethodAttributes.Virtual Or Mono.Cecil.MethodAttributes.CheckAccessOnOverride Or Mono.Cecil.MethodAttributes.NewSlot
         End If
         If TypeOf m_Declaration Is OperatorDeclaration OrElse TypeOf m_Declaration Is ConversionOperatorDeclaration Then
             result = result Or Mono.Cecil.MethodAttributes.SpecialName
         ElseIf TypeOf m_Declaration Is EventHandlerDeclaration Then
             result = result Or Mono.Cecil.MethodAttributes.SpecialName
         End If
 
         If m_Declaration.CustomAttributes IsNot Nothing AndAlso m_Declaration.CustomAttributes.IsDefined(m_Declaration.Compiler.TypeCache.System_Runtime_InteropServices_DllImportAttribute) Then
             result = result Or Mono.Cecil.MethodAttributes.PInvokeImpl
         End If
 
         If TypeOf m_Declaration Is ExternalSubDeclaration Then
             result = result Or Mono.Cecil.MethodAttributes.PInvokeImpl
         End If
 
         If m_Declaration.HasSecurityCustomAttribute Then
             result = result Or Mono.Cecil.MethodAttributes.HasSecurity
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\DotAccessExpression.vb" startline="97" endline="117">
<![CDATA[
 
     ''' <summary>
     ''' Get the parent code block. Might be nothing!
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function FindParentCodeBlock() As CodeBlock
         If TypeOf Parent Is CodeBlock Then
             Return DirectCast(Parent, CodeBlock)
         Else
             If TypeOf Parent Is Expression Then
                 Return DirectCast(Parent, Expression).FindParentCodeBlock
             ElseIf TypeOf Parent Is BlockStatement Then
                 Return DirectCast(Parent, BlockStatement).CodeBlock
             ElseIf TypeOf Parent Is Statement Then
                 Return DirectCast(Parent, Statement).FindParentCodeBlock
             Else
                 Return Nothing
             End If
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="1274" endline="1299">
<![CDATA[
 
     Overloads Shared Function EmitLoadValue(ByVal Info As EmitInfo, ByVal Value As Decimal) As Boolean
         Dim DesiredTypeCode As TypeCode = Helper.GetTypeCode(Info.Compiler, Info.DesiredType)
         Helper.Assert(Info.DesiredType IsNot Nothing)
         If Math.Truncate(Value) = Value Then
             If Value <= Integer.MaxValue AndAlso Value >= Integer.MinValue Then
                 Return EmitLoadValue(Info, CInt(Value))
             ElseIf Value <= Long.MaxValue AndAlso Value >= Long.MinValue Then
                 Return EmitLoadValue(Info, CLng(Value))
             ElseIf Value <= ULong.MaxValue AndAlso Value >= Long.MinValue Then
                 Return EmitLoadValue(Info, CULng(Value))
             End If
         End If
 
         Dim tmp As EmitInfo = Info.Clone(Info.Context, CType(Nothing, Mono.Cecil.TypeReference))
 
         Select Case DesiredTypeCode
             Case TypeCode.Single
                 EmitLoadValue(tmp, CSng(Value))
                 Return True
             Case TypeCode.Double
                 EmitLoadValue(tmp, CDbl(Value))
                 Return True
         End Select
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="76" endline="138">
<![CDATA[
     End Property
 
     Public Overrides Function GetConstant(ByRef result As Object, ByVal lvalue As Object, ByVal rvalue As Object) As Boolean
         Dim tlvalue, trvalue As Mono.Cecil.TypeReference
         Dim clvalue, crvalue As TypeCode
         tlvalue = CecilHelper.GetType(Compiler, lvalue)
         clvalue = Helper.GetTypeCode(Compiler, tlvalue)
         trvalue = CecilHelper.GetType(Compiler, rvalue)
         crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
         If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
             result = CBool(lvalue) >= CBool(rvalue)
             Return True
         ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
             result = CDate(lvalue) >= CDate(rvalue)
             Return True
         ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
             result = CChar(lvalue) >= CChar(rvalue)
             Return True
         ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
             result = CStr(lvalue) >= CStr(rvalue)
             Return True
         ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
          clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
             result = CStr(lvalue) >= CStr(rvalue)
             Return True
         End If
 
         Dim smallest As Mono.Cecil.TypeReference
         Dim csmallest As TypeCode
         smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
         Helper.Assert(smallest IsNot Nothing)
         csmallest = Helper.GetTypeCode(Compiler, smallest)
 
         Select Case csmallest
             Case TypeCode.Byte
                 result = CByte(lvalue) >= CByte(rvalue)
             Case TypeCode.SByte
                 result = CSByte(lvalue) >= CSByte(rvalue)
             Case TypeCode.Int16
                 result = CShort(lvalue) >= CShort(rvalue)
             Case TypeCode.UInt16
                 result = CUShort(lvalue) >= CUShort(rvalue)
             Case TypeCode.Int32
                 result = CInt(lvalue) >= CInt(rvalue)
             Case TypeCode.UInt32
                 result = CUInt(lvalue) >= CUInt(rvalue)
             Case TypeCode.Int64
                 result = CLng(lvalue) >= CLng(rvalue)
             Case TypeCode.UInt64
                 result = CULng(lvalue) >= CULng(rvalue)
             Case TypeCode.Double
                 result = CDbl(lvalue) >= CDbl(rvalue)
             Case TypeCode.Single
                 result = CSng(lvalue) >= CSng(rvalue)
             Case TypeCode.Decimal
                 result = CDec(lvalue) >= CDec(rvalue)
             Case Else
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="1009" endline="1072">
<![CDATA[
 
     Public Shared Function GetInterfaces(ByVal Type As Mono.Cecil.TypeReference, ByVal checkBase As Boolean) As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim genericType As Mono.Cecil.GenericInstanceType = TryCast(Type, Mono.Cecil.GenericInstanceType)
         Dim result As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim tmp As Mono.Cecil.TypeReference
         Dim tD As Mono.Cecil.TypeDefinition
         Dim tG As Mono.Cecil.GenericParameter = TryCast(Type, Mono.Cecil.GenericParameter)
 
         If tG IsNot Nothing Then
             If tG.Constraints.Count = 0 Then Return Nothing
             result = New Mono.Collections.Generic.Collection(Of TypeReference)
             For i As Integer = 0 To tG.Constraints.Count - 1
                 For Each t As TypeReference In GetInterfaces(tG.Constraints(i), checkBase)
                     result.Add(t)
                 Next
             Next
             Return result
         End If
 
         Dim arrD As Mono.Cecil.ArrayType = TryCast(Type, Mono.Cecil.ArrayType)
         If arrD IsNot Nothing Then
             result = New Mono.Collections.Generic.Collection(Of TypeReference)
             For Each tp As TypeReference In GetInterfaces(BaseObject.m_Compiler.TypeCache.System_Array, False)
                 result.Add(tp)
             Next
             For Each tp As TypeDefinition In New TypeDefinition() {BaseObject.m_Compiler.TypeCache.System_Collections_Generic_ICollection1, BaseObject.m_Compiler.TypeCache.System_Collections_Generic_IEnumerable1, BaseObject.m_Compiler.TypeCache.System_Collections_Generic_IList1}
                 Dim newTP As New GenericInstanceType(tp)
                 newTP.GenericArguments.Add(arrD.ElementType)
                 result.Add(newTP)
             Next
             Return result
         End If
 
         tD = FindDefinition(Type)
 
         result = New Mono.Collections.Generic.Collection(Of TypeReference)
         For i As Integer = 0 To tD.Interfaces.Count - 1
             result.Add(InflateType(tD.Interfaces(i), Type))
         Next
 
         If genericType IsNot Nothing Then
             For i As Integer = 0 To result.Count - 1
                 tmp = CecilHelper.ResolveType(result(i), CecilHelper.FindDefinition(genericType).GenericParameters, genericType.GenericArguments)
                 result.Item(i) = tmp
             Next
         End If
 
         If checkBase Then
             Dim bT As Mono.Cecil.TypeReference
 
             bT = tD.BaseType
             If bT IsNot Nothing Then
                 If genericType IsNot Nothing Then
                     bT = CecilHelper.GetCorrectMember(bT, genericType)
                 End If
 
                 For Each t As Mono.Cecil.TypeReference In GetInterfaces(bT, checkBase)
                     result.Add(t)
                 Next
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4156" endline="4217">
<![CDATA[
 
     Overloads Shared Function ToString(ByVal Context As BaseObject, ByVal Member As TypeReference) As String
         Dim typeDefinition As TypeDefinition
 
         If Member Is Nothing Then Return "Nothing"
 
         typeDefinition = TryCast(Member, TypeDefinition)
         If typeDefinition IsNot Nothing AndAlso Helper.IsDelegate(Context.Compiler, typeDefinition) Then
             Dim builder As New Text.StringBuilder()
             Dim delegateType As Mono.Cecil.TypeDefinition = DirectCast(Member, Mono.Cecil.TypeDefinition)
             Dim invoke As Mono.Cecil.MethodReference = GetInvokeMethod(Context.Compiler, delegateType)
 
             builder.Append("Delegate ")
             builder.Append(ToString(Context, invoke))
             If Helper.CompareType(invoke.ReturnType, Context.Compiler.TypeCache.System_Void) Then
                 builder.Replace("Delegate Sub " + invoke.Name + "(", "Delegate Sub " + delegateType.Name + "(")
             Else
                 builder.Replace("Delegate Function " + invoke.Name + "(", "Delegate Function " + delegateType.Name + "(")
             End If
             Return builder.ToString()
         ElseIf CecilHelper.IsNullable(Member) Then
             Return ToString(Context, CecilHelper.GetNulledType(Member)) & "?"
         Else
             If Helper.CompareType(Member, Context.Compiler.TypeCache.System_Byte) Then
                 Return "Byte"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_Boolean) Then
                 Return "Boolean"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_Char) Then
                 Return "Char"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_DateTime) Then
                 Return "Date"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_DBNull) Then
                 Return "System.DBNull"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_Decimal) Then
                 Return "Decimal"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_Double) Then
                 Return "Double"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_Int16) Then
                 Return "Short"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_Int32) Then
                 Return "Integer"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_Int64) Then
                 Return "Long"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_SByte) Then
                 Return "SByte"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_Single) Then
                 Return "Single"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_String) Then
                 Return "String"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_UInt16) Then
                 Return "UShort"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_UInt32) Then
                 Return "UInteger"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_UInt64) Then
                 Return "ULong"
             ElseIf Helper.CompareType(Member, Context.Compiler.TypeCache.System_Object) Then
                 Return "Object"
             Else
                 Return Member.ToString()
             End If
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\NamespaceDictionary.vb" startline="158" endline="181">
<![CDATA[
 
     ''' <summary>
     ''' Looks up the specified error code and returns the string
     ''' </summary>
     ''' <param name="ErrorCode"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function LookupErrorCode(ByVal ErrorCode As Integer) As String
         Dim result As Object
 
         If m_Resources Is Nothing Then
             m_Resources = New ResourceManager("vbnc.Errors", System.Reflection.Assembly.GetExecutingAssembly())
         End If
 
         result = m_Resources.GetObject(ErrorCode.ToString)
 
         If result Is Nothing Then
             Console.WriteLine("Could not find the error message corresponding with the error code
             Return ErrorCode.ToString
         Else
             Return result.ToString
         End If
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4553" endline="4561">
<![CDATA[
 
     Shared Function GetPropertyAccess(ByVal [Property] As Mono.Cecil.PropertyReference) As Mono.Cecil.MethodAttributes
         Dim result As Mono.Cecil.MethodAttributes
 
         result = GetPropertyAttributes([Property])
         result = result And Mono.Cecil.MethodAttributes.MemberAccessMask
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4562" endline="4570">
<![CDATA[
 
     Shared Function GetEventAccess(ByVal [Event] As Mono.Cecil.EventReference) As Mono.Cecil.MethodAttributes
         Dim result As Mono.Cecil.MethodAttributes
 
         result = GetEventAttributes([Event])
         result = result And Mono.Cecil.MethodAttributes.MemberAccessMask
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\RMhandler.vb" startline="16" endline="25">
<![CDATA[
 
     Public Property SectionXML(ByVal Name As String) As XmlNode
         Get
             If mDoc Is Nothing Then Return Nothing
             Try
                 Return mDoc.SelectSingleNode("Settings/" & Name)
             Catch ex As Exception
                 Return Nothing
             End Try
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\Main.vb" startline="12" endline="62">
<![CDATA[
 
     Sub Main()
 
         Application.EnableVisualStyles()
 
         mSettings = New SimpleSettings
 
         Dim Splash As New frmAbout
         Splash.Show()
         Splash.Refresh()
 
         Try
             mTranslator = New Translator.frmTranslator("Movica")
         Catch ex As Exception
             MsgBox("An error with the language files is preventing Movica from starting")
             End
         End Try
 
         Dim CheckOnline As Boolean = Not (mSettings.GetSetting("Advanced", "CheckUpdate") = "False")
         If CheckOnline Then
             Dim LastCheck As Date = Date.Parse(mSettings.GetSetting("Advanced", "LastUpdtCheck", "1/1/2000"))
             If Now() > LastCheck.AddDays(1) Then
                 mSettings.SaveSetting("Advanced", "LastUpdtCheck", Now.ToShortDateString)
                 If CheckUpdate(True, True) Then End
             End If
         End If
 
         mMRU.Enabled = (mSettings.GetSetting("Advanced", "KeepHistory") = "True")
         mMRU.fromXML(mSettings.SectionXML("RecentFiles"))
 
         Dim frm As New frmMain
 
         ' Initializes the bass object
         Un4seen.Bass.BassNet.Registration("apps.feedback@gmail.com", "2X3252023152222")
         If Bass.BASS_Init(-1, 44100, Un4seen.Bass.BASSInit.BASS_DEVICE_DEFAULT, frm.Handle, Nothing) = False Then
             'If Bass.BASS_Init(-1, 44100, 0, 0, Nothing) = False Then
             'Need to show an error message
             MsgBox("BASS Init Error! Audio file editing will not work. Restarting Movica might help")
         Else
             Bass.BASS_PluginLoad("basswma.dll")
         End If
 
         Splash.Close()
         Splash.Dispose()
         frm.ShowDialog()
 
         mSettings.SectionXML("RecentFiles") = mMRU.toXML
         mSettings.Save()
         Bass.BASS_PluginFree(0)
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmDiagnostics.vb" startline="202" endline="237">
<![CDATA[
 
     Private Sub Profile_Diagnostics(ByVal Name As String, ByVal Index As Byte, ByVal Setting As String)
 
         Try
             SrvcCntrl.ServiceName = (Name)
             Dim ChkSrvc As Boolean = SrvcCntrl.CanPauseAndContinue
         Catch ex As InvalidOperationException
             LstServices.Items.Item(Index).Checked = False
             LstServices.Items.Item(Index).SubItems.Item(1).Text = S5
             LstServices.Items.Item(Index).SubItems.Item(1).ForeColor = Color.DimGray
             Exit Sub
         End Try
 
         If My.Settings(Setting) = 1 Then
             If SrvcCntrl.Status = ServiceProcess.ServiceControllerStatus.Running And Service_Startup(Name) = 2 Then
                 LstServices.Items.Item(Index).Checked = False
                 LstServices.Items.Item(Index).SubItems.Item(1).Text = S1
                 LstServices.Items.Item(Index).SubItems.Item(1).ForeColor = Color.Green
             Else
                 LstServices.Items.Item(Index).Checked = True
                 LstServices.Items.Item(Index).SubItems.Item(1).Text = S2
                 LstServices.Items.Item(Index).SubItems.Item(1).ForeColor = Color.DarkOrange
             End If
         ElseIf My.Settings(Setting) = 2 Then
             If Service_Startup(Name) = 3 OrElse Service_Startup(Name) = 4 Then
                 LstServices.Items.Item(Index).Checked = False
                 LstServices.Items.Item(Index).SubItems.Item(1).Text = S1
                 LstServices.Items.Item(Index).SubItems.Item(1).ForeColor = Color.Green
             Else
                 LstServices.Items.Item(Index).Checked = True
                 LstServices.Items.Item(Index).SubItems.Item(1).Text = S3
                 LstServices.Items.Item(Index).SubItems.Item(1).ForeColor = Color.DarkOrange
             End If
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2452" endline="2460">
<![CDATA[
 
     Private Sub Mpcontrols_SliderMoved(ByVal Start As Double) _
     Handles MPcontrols.SliderMoved
         mPlayer.Ctlcontrols.currentPosition = Start
         If mPlayer.playState = WMPLib.WMPPlayState.wmppsPaused Then
             mPlayer.Ctlcontrols.play()
             mPlayer.Ctlcontrols.pause()
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmSrvcMngr.vb" startline="380" endline="399">
<![CDATA[
 
     Private Sub Load_Services()
 
         LstServices.Items.Clear()
         Dim Services() As ServiceProcess.ServiceController
         Dim ItmService As ListViewItem
 
         Dim I As Integer
         Services = ServiceProcess.ServiceController.GetServices
         For I = 0 To (Services.Length - 1)
             ItmService = LstServices.Items.Add(Services(I).DisplayName)
             ItmService.SubItems.Add(Services(I).ServiceName)
             ItmService.SubItems.Add(Services(I).Status.ToString)
             ItmService.SubItems.Add(Startup(Services(I).ServiceName))
             ItmService.SubItems.Add(Company(Services(I).ServiceName))
         Next
 
         LstServices.Items(0).Selected = True
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\BaseObject.vb" startline="286" endline="292">
<![CDATA[
     End Property
 
     Overridable Function ResolveCode(ByVal Info As ResolveInfo) As Boolean Implements IBaseObject.ResolveCode
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "ResolveInfo ignored for '" & Me.GetType.ToString & "'")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         'Return ResolveCode()
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\BaseObject.vb" startline="303" endline="314">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' Define = create a builder for the object.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     <Obsolete("Throws NotImplementedException() - The class you are using does not override this method!")> _
     Overridable Function Define() As Boolean Implements IBaseObject.Define
         Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "The class " & Me.GetType.ToString & " does not implement Define()")
         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="341" endline="387">
<![CDATA[
 
     ''' <summary>
     ''' Returns the type of the specified keyword. Throws an internalexception if the keyword isn't a type.
     ''' </summary>
     ''' <param name="Keyword"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ''' 
     Function KeywordToType(ByVal Keyword As KS) As Mono.Cecil.TypeReference
         Select Case Keyword
             Case KS.Boolean
                 Return Compiler.TypeCache.System_Boolean
             Case KS.Byte
                 Return Compiler.TypeCache.System_Byte
             Case KS.Char
                 Return Compiler.TypeCache.System_Char
             Case KS.Date
                 Return Compiler.TypeCache.System_DateTime
             Case KS.Decimal
                 Return Compiler.TypeCache.System_Decimal
             Case KS.Double
                 Return Compiler.TypeCache.System_Double
             Case KS.Integer
                 Return Compiler.TypeCache.System_Int32
             Case KS.Long
                 Return Compiler.TypeCache.System_Int64
             Case KS.Object
                 Return Compiler.TypeCache.System_Object
             Case KS.Single
                 Return Compiler.TypeCache.System_Single
             Case KS.Short
                 Return Compiler.TypeCache.System_Int16
             Case KS.String
                 Return Compiler.TypeCache.System_String
             Case KS.[SByte]
                 Return Compiler.TypeCache.System_SByte
             Case KS.[UShort]
                 Return Compiler.TypeCache.System_UInt16
             Case KS.[UInteger]
                 Return Compiler.TypeCache.System_UInt32
             Case KS.[ULong]
                 Return Compiler.TypeCache.System_UInt64
             Case Else
                 'Throw New InternalException("Don't know if this can actually happen, though. KS = " & Keyword.ToString)
                 Return Nothing
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2196" endline="2207">
<![CDATA[
 
     <Diagnostics.DebuggerHidden()> Shared Sub AddWarning(Optional ByVal Message As String = "(No message provided)")
         Dim msg As String
         msg = "A warning message should have been shown
         Diagnostics.Debug.WriteLine(msg)
         Console.WriteLine(msg)
         If IsDebugging() Then
             'Helper.Stop()
         Else
             'Throw New NotImplementedException(msg)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\CMPT890\CS VB JS examples\Examples\VB.NET\examples\MainModule.vb" startline="32" endline="43">
<![CDATA[
 
     Private Shared Sub ExecuteExample(ByVal Typ As Type, ByVal Name As String, ByVal Arguments As Object())
         Try
             Call Typ.InvokeMember(Name, BindingFlags.InvokeMethod, Nothing, Nothing, Arguments)
         Catch ee As Exception
             If StopOnError Then
                 Throw ee
             Else
                 Console.WriteLine(ee.Message)
             End If
 		end try
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="600" endline="625">
<![CDATA[
 
     Private Sub BtnGameMode_Click(ByVal sender As Object, ByVal e As System.EventArgs) Handles BtnGameMode.Click, LblGameMode_Status.Click
 
         If GameMode() = False Then
             If CheckGMProfile() = False Then
                 MessageBox.Show("To use Gaming Mode, you need to setup your Gaming Mode profile.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Warning, MessageBoxDefaultButton.Button1, 0, False)
                 LnkGameMode.PerformClick()
                 Exit Sub
             End If
         End If
 
         Try
             FrmProgress.PicProgress.Image = New Bitmap(DataDir & "game_mode.png")
         Catch ex As ArgumentException
         End Try
 
         If GameMode() = True Then
             FrmProgress.LblProgress.Text = "Turning off Gaming Mode, Please wait..."
         ElseIf GameMode() = False Then
             FrmProgress.LblProgress.Text = "Turning on Gaming Mode, Please wait..."
         End If
 
         FrmGameMode.BWGameMode.RunWorkerAsync()
         FrmProgress.ShowDialog(Me)
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\CMPT890\CS VB JS examples\Examples\VB.NET\examples\Chap0209.vb" startline="74" endline="155">
<![CDATA[
 End Class
 
 Public Class Chap0209
     Public Shared Sub Main(ByVal args As String())
         Console.WriteLine("Chapter 2 example 9
 
         ' step 1
         Dim Document As New Document()
 
         ' step 2
         ' we create a writer that listens to the document
         ' and directs a PDF-stream to a file
         Dim Writer As PdfWriter = PdfWriter.getInstance(Document, New FileOutputStream("Chap0209.pdf"))
 
         ' step 3
         Document.open()
 
         ' step 4
         ' we create an Event and add it to the writer
         Dim pageEvent As New Glossary()
         Writer.setPageEvent(pageEvent)
 
         ' we add some content
         Dim f(13) As String
         f(0) = "Courier"
         f(1) = "Courier Bold"
         f(2) = "Courier Italic"
         f(3) = "Courier Bold Italic"
         f(4) = "Helvetica"
         f(5) = "Helvetica bold"
         f(6) = "Helvetica italic"
         f(7) = "Helvetica bold italic"
         f(8) = "Times New Roman"
         f(9) = "Times New Roman bold"
         f(10) = "Times New Roman italic"
         f(11) = "Times New Roman bold italic"
         f(12) = "Symbol"
         f(13) = "Zapfdingbats"
 
         Dim fonts(13) As Font
         fonts(0) = FontFactory.getFont(FontFactory.COURIER, 12, Font.NORMAL)
         fonts(1) = FontFactory.getFont(FontFactory.COURIER, 12, Font.BOLD)
         fonts(2) = FontFactory.getFont(FontFactory.COURIER, 12, Font.ITALIC)
         fonts(3) = FontFactory.getFont(FontFactory.COURIER, 12, Font.BOLD Or Font.ITALIC)
         fonts(4) = FontFactory.getFont(FontFactory.HELVETICA, 12, Font.NORMAL)
         fonts(5) = FontFactory.getFont(FontFactory.HELVETICA, 12, Font.BOLD)
         fonts(6) = FontFactory.getFont(FontFactory.HELVETICA, 12, Font.ITALIC)
         fonts(7) = FontFactory.getFont(FontFactory.HELVETICA, 12, Font.BOLD Or Font.ITALIC)
         fonts(8) = FontFactory.getFont(FontFactory.TIMES_ROMAN, 12, Font.NORMAL)
         fonts(9) = FontFactory.getFont(FontFactory.TIMES_ROMAN, 12, Font.BOLD)
         fonts(10) = FontFactory.getFont(FontFactory.TIMES_ROMAN, 12, Font.ITALIC)
         fonts(11) = FontFactory.getFont(FontFactory.TIMES_ROMAN, 12, Font.BOLD Or Font.ITALIC)
         fonts(12) = FontFactory.getFont(FontFactory.SYMBOL, 12, Font.NORMAL)
         fonts(13) = FontFactory.getFont(FontFactory.ZAPFDINGBATS, 12, Font.NORMAL)
 
         Dim i As Integer
         For i = 0 To 13
             Dim chunk As New Chunk("This is font ", fonts(i))
             Dim p As New Paragraph(chunk)
             p.add(New Phrase(New Chunk(f(i), fonts(i)).setGenericTag(f(i))))
             Document.add(p)
             If i Mod 4 = 3 Then
                 Document.newPage()
             End If
         Next
 
         ' we add the glossary
         Document.newPage()
         Dim Glossary As TreeMap = pageEvent.getGlossary()
         Dim it As Iterator = Glossary.keySet().iterator()
         While it.hasNext()
             Dim key As String = DirectCast(it.next(), String)
             Dim page As Integer = DirectCast(Glossary.get(key), Integer)
             Dim g As New Paragraph(key)
             g.add(" 
             g.add(CStr(page))
             Document.add(g)
         End While
         While it.hasNext()
             Dim key As String = DirectCast(it.next(), String)
             Dim page As Integer = DirectCast(Glossary.get(key), Integer)
             Dim g As New Paragraph(key)
             g.add(" 
             g.add(CStr(page))
             Document.add(g)
         End While
 
         ' step 5
         Document.close()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2047" endline="2056">
<![CDATA[
 
     Private Sub mnuExit_Click(ByVal sender As System.Object, _
 ByVal e As System.EventArgs) Handles mnuExit.Click
 
         If MsgBox(mTranslator.LangText(118), _
         MsgBoxStyle.YesNo, "Exit ?") = MsgBoxResult.Yes Then
             Me.Close()
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmGameMode.vb" startline="39" endline="63">
<![CDATA[
 
     Private Sub FrmGameMode_Shown(ByVal sender As Object, ByVal e As System.EventArgs) Handles Me.Shown
 
         If GameMode() = True And File.Exists(GMFile) = True Then
             BtnSwitch.Text = " Turn &off Gaming Mode"
         ElseIf GameMode() = True And File.Exists(GMFile) = False Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer", "GameMode", 0, Microsoft.Win32.RegistryValueKind.DWord)
             Call FrmMain.Check_Status()
         End If
 
         If GameMode() = True Then
             Try
                 BtnSwitch.Image = New Bitmap(DataDir & "stop.png")
             Catch ex As ArgumentException
             End Try
         ElseIf GameMode() = False Then
             Try
                 BtnSwitch.Image = New Bitmap(DataDir & "start.png")
             Catch ex As ArgumentException
             End Try
         End If
 
         Call Load_Profile()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmDiagnostics.vb" startline="40" endline="57">
<![CDATA[
 
     Private Sub BtnDiagnose_Click(ByVal sender As Object, ByVal e As System.EventArgs) Handles BtnDiagnose.Click
 
         If GameMode() = False Then
 
             BWDiagnostics.RunWorkerAsync()
             Try
                 FrmProgress.PicProgress.Image = New Bitmap(DataDir & "services_diagnostics.png")
             Catch ex As ArgumentException
             End Try
             FrmProgress.LblProgress.Text = "Diagnosing Windows services, Please wait..."
             FrmProgress.ShowDialog(Me)
 
         ElseIf GameMode() = True Then
             MessageBox.Show("Services Diagnostics can not be performed during Gaming Mode.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Information, MessageBoxDefaultButton.Button1, 0, False)
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Compiler.vb" startline="245" endline="255">
<![CDATA[
     End Property
 
     Private Function CreateTestOutputFilename(ByVal Filename As String, ByVal TestType As String) As String
         Dim dir As String
         dir = IO.Path.GetDirectoryName(Filename)
         If dir = "" Then dir = Environment.CurrentDirectory
         'dir = IO.Path.Combine(IO.Path.GetDirectoryName(Filename), "testoutput")
 
         If IO.Directory.Exists(dir) = False Then IO.Directory.CreateDirectory(dir)
         Return IO.Path.Combine(dir, IO.Path.GetFileName(Filename) & "." & TestType & ".output.xml")
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="626" endline="638">
<![CDATA[
 
     Private Sub BtnSnapshots_Click(ByVal sender As Object, ByVal e As System.EventArgs) Handles BtnSnapshots.Click, LblSnapshots_Status.Click
 
         If My.Settings.Snapshots = True Then
             My.Settings.Snapshots = False
         ElseIf My.Settings.Snapshots = False Then
             My.Settings.Snapshots = True
         End If
 
         My.Settings.Save()
         Call Check_Status()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\StdToolMgr.vb" startline="6" endline="15">
<![CDATA[
     Public Sub New()
         MyBase.New()
 
         'This call is required by the Windows Form Designer.
         InitializeComponent()
 
         'Add any initialization after the InitializeComponent() call
         Me_Load()
 
     End Sub
 
     'UserControl overrides dispose to clean up the component list.
     Protected Overloads Overrides Sub Dispose(ByVal disposing As Boolean)
         If disposing Then
             If Not (components Is Nothing) Then
                 components.Dispose()
             End If
         End If
         MyBase.Dispose(disposing)
     End Sub
 
     'Required by the Windows Form Designer
     Private components As System.ComponentModel.IContainer
 
     'NOTE
     'It can be modified using the Windows Form Designer.  
     'Do not modify it using the code editor.
     Friend WithEvents lplayPos As System.Windows.Forms.Label
     Friend WithEvents tbButtons As System.Windows.Forms.ToolBar
     Friend WithEvents cPlay As System.Windows.Forms.ToolBarButton
     Friend WithEvents cStop As System.Windows.Forms.ToolBarButton
     Friend WithEvents cEnd As System.Windows.Forms.ToolBarButton
     Friend WithEvents cBegin As System.Windows.Forms.ToolBarButton
     Friend WithEvents cSelStrt As System.Windows.Forms.ToolBarButton
     Friend WithEvents cSelEnd As System.Windows.Forms.ToolBarButton
     Friend WithEvents cFFwd As System.Windows.Forms.ToolBarButton
     Friend WithEvents cFRev As System.Windows.Forms.ToolBarButton
     Friend WithEvents sep1 As System.Windows.Forms.ToolBarButton
     Friend WithEvents sep2 As System.Windows.Forms.ToolBarButton
     Friend WithEvents cMute As System.Windows.Forms.ToolBarButton
     Friend WithEvents sep3 As System.Windows.Forms.ToolBarButton
     Friend WithEvents iList As System.Windows.Forms.ImageList
     Friend WithEvents VolBar As System.Windows.Forms.TrackBar
     Friend WithEvents Timer As System.Windows.Forms.Timer
     Friend WithEvents lPos As System.Windows.Forms.Label
     <System.Diagnostics.DebuggerStepThrough()> Private Sub InitializeComponent()
         Me.components = New System.ComponentModel.Container
         Dim resources As System.ComponentModel.ComponentResourceManager = New System.ComponentModel.ComponentResourceManager(GetType(ucMPcontrols))
         Me.lplayPos = New System.Windows.Forms.Label
         Me.tbButtons = New System.Windows.Forms.ToolBar
         Me.cStop = New System.Windows.Forms.ToolBarButton
         Me.cPlay = New System.Windows.Forms.ToolBarButton
         Me.sep1 = New System.Windows.Forms.ToolBarButton
         Me.cBegin = New System.Windows.Forms.ToolBarButton
         Me.cFRev = New System.Windows.Forms.ToolBarButton
         Me.cFFwd = New System.Windows.Forms.ToolBarButton
         Me.cEnd = New System.Windows.Forms.ToolBarButton
         Me.sep2 = New System.Windows.Forms.ToolBarButton
         Me.cSelStrt = New System.Windows.Forms.ToolBarButton
         Me.cSelEnd = New System.Windows.Forms.ToolBarButton
         Me.sep3 = New System.Windows.Forms.ToolBarButton
         Me.cMute = New System.Windows.Forms.ToolBarButton
         Me.iList = New System.Windows.Forms.ImageList(Me.components)
         Me.VolBar = New System.Windows.Forms.TrackBar
         Me.Timer = New System.Windows.Forms.Timer(Me.components)
         Me.lPos = New System.Windows.Forms.Label
         CType(Me.VolBar, System.ComponentModel.ISupportInitialize).BeginInit()
         Me.SuspendLayout()
         '
         'lplayPos
         '
         Me.lplayPos.BackColor = System.Drawing.Color.Beige
         Me.lplayPos.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.lplayPos.Dock = System.Windows.Forms.DockStyle.Top
         Me.lplayPos.Enabled = False
         Me.lplayPos.Location = New System.Drawing.Point(3, 3)
         Me.lplayPos.Name = "lplayPos"
         Me.lplayPos.Size = New System.Drawing.Size(362, 16)
         Me.lplayPos.TabIndex = 0
         '
         'tbButtons
         '
         Me.tbButtons.Appearance = System.Windows.Forms.ToolBarAppearance.Flat
         Me.tbButtons.Buttons.AddRange(New System.Windows.Forms.ToolBarButton() {Me.cStop, Me.cPlay, Me.sep1, Me.cBegin, Me.cFRev, Me.cFFwd, Me.cEnd, Me.sep2, Me.cSelStrt, Me.cSelEnd, Me.sep3, Me.cMute})
         Me.tbButtons.Dock = System.Windows.Forms.DockStyle.Bottom
         Me.tbButtons.DropDownArrows = True
         Me.tbButtons.ImageList = Me.iList
         Me.tbButtons.Location = New System.Drawing.Point(3, 28)
         Me.tbButtons.Name = "tbButtons"
         Me.tbButtons.ShowToolTips = True
         Me.tbButtons.Size = New System.Drawing.Size(362, 28)
         Me.tbButtons.TabIndex = 1
         '
         'cStop
         '
         Me.cStop.ImageIndex = 9
         Me.cStop.Name = "cStop"
         Me.cStop.Tag = "cStop"
         Me.cStop.ToolTipText = "Stop"
         '
         'cPlay
         '
         Me.cPlay.ImageIndex = 1
         Me.cPlay.Name = "cPlay"
         Me.cPlay.Tag = "cPlay"
         Me.cPlay.ToolTipText = "Play / Pause [Space]"
         '
         'sep1
         '
         Me.sep1.Name = "sep1"
         Me.sep1.Style = System.Windows.Forms.ToolBarButtonStyle.Separator
         '
         'cBegin
         '
         Me.cBegin.ImageIndex = 5
         Me.cBegin.Name = "cBegin"
         Me.cBegin.Tag = "cBegin"
         Me.cBegin.ToolTipText = "Jump to start [Ctrl+S]"
         '
         'cFRev
         '
         Me.cFRev.ImageIndex = 3
         Me.cFRev.Name = "cFRev"
         Me.cFRev.Style = System.Windows.Forms.ToolBarButtonStyle.ToggleButton
         Me.cFRev.Tag = "cFRev"
         Me.cFRev.ToolTipText = "Fast Reverse [Ctrl+Dn Arrow]"
         '
         'cFFwd
         '
         Me.cFFwd.ImageIndex = 2
         Me.cFFwd.Name = "cFFwd"
         Me.cFFwd.Style = System.Windows.Forms.ToolBarButtonStyle.ToggleButton
         Me.cFFwd.Tag = "cFFwd"
         Me.cFFwd.ToolTipText = "Fast Forward [Ctrl+Up Arrow]"
         '
         'cEnd
         '
         Me.cEnd.ImageIndex = 4
         Me.cEnd.Name = "cEnd"
         Me.cEnd.Tag = "cEnd"
         Me.cEnd.ToolTipText = "Jump to End [Ctrl+End]"
         '
         'sep2
         '
         Me.sep2.Name = "sep2"
         Me.sep2.Style = System.Windows.Forms.ToolBarButtonStyle.Separator
         '
         'cSelStrt
         '
         Me.cSelStrt.ImageIndex = 7
         Me.cSelStrt.Name = "cSelStrt"
         Me.cSelStrt.Tag = "cSelStrt"
         Me.cSelStrt.ToolTipText = "Mark Selection Start [Home]"
         '
         'cSelEnd
         '
         Me.cSelEnd.ImageIndex = 8
         Me.cSelEnd.Name = "cSelEnd"
         Me.cSelEnd.Tag = "cSelEnd"
         Me.cSelEnd.ToolTipText = "Mark Selection End [End]"
         '
         'sep3
         '
         Me.sep3.Name = "sep3"
         Me.sep3.Style = System.Windows.Forms.ToolBarButtonStyle.Separator
         '
         'cMute
         '
         Me.cMute.ImageIndex = 0
         Me.cMute.Name = "cMute"
         Me.cMute.Style = System.Windows.Forms.ToolBarButtonStyle.ToggleButton
         Me.cMute.Tag = "cMute"
         Me.cMute.ToolTipText = "Mute"
         '
         'iList
         '
         Me.iList.ImageStream = CType(resources.GetObject("iList.ImageStream"), System.Windows.Forms.ImageListStreamer)
         Me.iList.TransparentColor = System.Drawing.Color.Transparent
         Me.iList.Images.SetKeyName(0, "")
         Me.iList.Images.SetKeyName(1, "")
         Me.iList.Images.SetKeyName(2, "")
         Me.iList.Images.SetKeyName(3, "")
         Me.iList.Images.SetKeyName(4, "")
         Me.iList.Images.SetKeyName(5, "")
         Me.iList.Images.SetKeyName(6, "")
         Me.iList.Images.SetKeyName(7, "")
         Me.iList.Images.SetKeyName(8, "")
         Me.iList.Images.SetKeyName(9, "")
         Me.iList.Images.SetKeyName(10, "")
         '
         'VolBar
         '
         Me.VolBar.Location = New System.Drawing.Point(233, 31)
         Me.VolBar.Maximum = 100
         Me.VolBar.Name = "VolBar"
         Me.VolBar.Size = New System.Drawing.Size(80, 45)
         Me.VolBar.SmallChange = 5
         Me.VolBar.TabIndex = 2
         Me.VolBar.TabStop = False
         Me.VolBar.TickFrequency = 5
         Me.VolBar.TickStyle = System.Windows.Forms.TickStyle.None
         '
         'Timer
         '
         '
         'lPos
         '
         Me.lPos.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.lPos.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.lPos.Font = New System.Drawing.Font("Microsoft Sans Serif", 7.0!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.lPos.ForeColor = System.Drawing.SystemColors.ControlDarkDark
         Me.lPos.Location = New System.Drawing.Point(313, 32)
         Me.lPos.Name = "lPos"
         Me.lPos.Size = New System.Drawing.Size(52, 16)
         Me.lPos.TabIndex = 3
         Me.lPos.Text = "0
         Me.lPos.TextAlign = System.Drawing.ContentAlignment.MiddleRight
         '
         'ucMPcontrols
         '
         Me.Controls.Add(Me.lPos)
         Me.Controls.Add(Me.lplayPos)
         Me.Controls.Add(Me.VolBar)
         Me.Controls.Add(Me.tbButtons)
         Me.Name = "ucMPcontrols"
         Me.Padding = New System.Windows.Forms.Padding(3, 3, 3, 0)
         Me.Size = New System.Drawing.Size(368, 56)
         CType(Me.VolBar, System.ComponentModel.ISupportInitialize).EndInit()
         Me.ResumeLayout(False)
         Me.PerformLayout()
 
     End Sub
 
 #End Region
 
 #Region "   Private Variables and Constants "
 
     Friend WithEvents mPlayer As AxWMPLib.AxWindowsMediaPlayer
 
     Private mPenWide As Integer = 2             'Width of the pen
     Private mPenColor As Color = Color.Black    'Color of the pen
     Private mPen As Pen                         'The pen to use for the slider
     Private mBitMap As Bitmap                   'Bitmap that will hold the time graph
 
     Private mSliderW As Integer = 6             'Width of the slider
         InitializeComponent()
 
         'Add any initialization after the InitializeComponent() call
         Me_Load()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\DotAccessExpression.vb" startline="147" endline="158">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' The type of the expression.
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overridable ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             Return Nothing
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="755" endline="766">
<![CDATA[
 
     Private Sub EatComment()
         Select Case CurrentChar()
             Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'Traditional VB comment
                 EatLine(False) 'do not eat newline, it needs to be added as a token
                 Return
             Case Else
                 REM is taken care of some other place.
                 'Function should never be called if not a comment
                 Throw New InternalException("EatComment called with no comment.")
         End Select
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1674" endline="1727">
<![CDATA[
 
     Shared Function GetBinaryOperators(ByVal Compiler As Compiler, ByVal Op As BinaryOperators, ByVal Type As Mono.Cecil.TypeReference) As Generic.List(Of Mono.Cecil.MethodReference)
         Dim opNameAlternatives As String() = Nothing
 
         Select Case Op
             Case BinaryOperators.And
                 opNameAlternatives = New String() {"op_BitwiseAnd", "op_LogicalAnd"}
             Case BinaryOperators.Like
                 opNameAlternatives = New String() {"op_Like"}
             Case BinaryOperators.Mod
                 opNameAlternatives = New String() {"op_Modulus"}
             Case BinaryOperators.Or
                 opNameAlternatives = New String() {"op_BitwiseOr", "op_LogicalOr"}
             Case BinaryOperators.XOr
                 opNameAlternatives = New String() {"op_ExclusiveOr"}
             Case BinaryOperators.LT
                 opNameAlternatives = New String() {"op_LessThan"}
             Case BinaryOperators.GT
                 opNameAlternatives = New String() {"op_GreaterThan"}
             Case BinaryOperators.Equals
                 opNameAlternatives = New String() {"op_Equality"}
             Case BinaryOperators.NotEqual
                 opNameAlternatives = New String() {"op_Inequality"}
             Case BinaryOperators.LE
                 opNameAlternatives = New String() {"op_LessThanOrEqual"}
             Case BinaryOperators.GE
                 opNameAlternatives = New String() {"op_GreaterThanOrEqual"}
             Case BinaryOperators.Concat
                 opNameAlternatives = New String() {"op_Concatenate"}
             Case BinaryOperators.Mult
                 opNameAlternatives = New String() {"op_Multiply"}
             Case BinaryOperators.Add
                 opNameAlternatives = New String() {"op_Addition"}
             Case BinaryOperators.Minus
                 opNameAlternatives = New String() {"op_Subtraction"}
             Case BinaryOperators.Power
                 opNameAlternatives = New String() {"op_Exponent"}
             Case BinaryOperators.RealDivision
                 opNameAlternatives = New String() {"op_Division"}
             Case BinaryOperators.IntDivision
                 opNameAlternatives = New String() {"op_IntegerDivision"}
             Case BinaryOperators.ShiftLeft
                 'See
                 opNameAlternatives = New String() {"op_LeftShift", "op_SignedRightShift"}
             Case BinaryOperators.ShiftRight
                 opNameAlternatives = New String() {"op_RightShift", "op_UnsignedRightShift"}
             Case BinaryOperators.IsTrue
                 opNameAlternatives = New String() {"op_True"}
             Case BinaryOperators.IsFalse
                 opNameAlternatives = New String() {"op_False"}
         End Select
 
         Return GetOperators(Compiler, opNameAlternatives, Type)
     End Function
]]>
</clone_fragment>
<clone_fragment file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="59" endline="82">
<![CDATA[
     Public Shared Sub Main(ByVal args As String())
         Console.WriteLine("Chapter 1 example 3
 
         ' step 1
         Dim document As New Document(PageSize.A4.rotate())
 
         ' step 2
         ' we create a writer that listens to the document
         ' and directs a PDF-stream to a file
 
         PdfWriter.getInstance(document, New FileOutputStream("Chap0103.pdf"))
 
         ' step 3
         document.open()
 
         ' step 4
         Dim i As Integer
         For i = 0 To 20
             document.add(New Phrase("Hello World, Hello Sun, Hello Moon, Hello Stars, Hello Sea, Hello Land, Hello People. "))
         Next
 
         ' step 5
         document.close()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MemberCache.vb" startline="129" endline="136">
<![CDATA[
 
     Public Sub Clear(ByVal Visibility As MemberVisibility)
         m_CacheInsensitive(Visibility) = Nothing
         m_FlattenedCacheInsensitive(Visibility) = Nothing
         m_LoadedNames(Visibility) = Nothing
         m_LoadedAll(Visibility) = False
         m_ShadowedInterfaceMembers = Nothing
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="84" endline="171">
<![CDATA[
     End Property
 
     Public Overrides Function GetConstant(ByRef m_ConstantValue As Object, ByVal lvalue As Object, ByVal rvalue As Object) As Boolean
         Dim tlvalue, trvalue As Mono.Cecil.TypeReference
         Dim clvalue, crvalue As TypeCode
 
         tlvalue = CecilHelper.GetType(Compiler, lvalue)
         clvalue = Helper.GetTypeCode(Compiler, tlvalue)
         trvalue = CecilHelper.GetType(Compiler, rvalue)
         crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
         If clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
             m_ConstantValue = CStr(lvalue) & CStr(rvalue)
             Return True
         End If
 
         Dim csmallest As TypeCode
         csmallest = vbnc.TypeConverter.GetBinaryAddResultType(clvalue, crvalue)
 
         Select Case csmallest
             Case TypeCode.Byte
                 Dim tmp As UShort = CUShort(lvalue) + CUShort(rvalue)
                 If tmp < Byte.MinValue OrElse tmp > Byte.MaxValue Then
                     m_ConstantValue = tmp
                 Else
                     m_ConstantValue = CByte(tmp)
                 End If
             Case TypeCode.SByte
                 Dim tmp As Short = CShort(lvalue) + CShort(rvalue)
                 If tmp < SByte.MinValue OrElse tmp > SByte.MaxValue Then
                     m_ConstantValue = tmp
                 Else
                     m_ConstantValue = CSByte(tmp)
                 End If
             Case TypeCode.Int16
                 Dim tmp As Integer = CInt(lvalue) + CInt(rvalue)
                 If tmp > Short.MaxValue OrElse tmp < Short.MinValue Then
                     m_ConstantValue = tmp
                 Else
                     m_ConstantValue = CShort(tmp)
                 End If
             Case TypeCode.UInt16
                 Dim tmp As UInteger = CUInt(lvalue) + CUInt(rvalue)
                 If tmp > UShort.MaxValue Then
                     m_ConstantValue = tmp
                 Else
                     m_ConstantValue = CUShort(tmp)
                 End If
             Case TypeCode.Int32
                 Dim tmp As Long = CLng(lvalue) + CLng(rvalue)
                 If tmp > Integer.MaxValue OrElse tmp < Integer.MinValue Then
                     m_ConstantValue = tmp
                 Else
                     m_ConstantValue = CInt(tmp)
                 End If
             Case TypeCode.UInt32
                 Dim tmp As ULong = CULng(lvalue) + CULng(rvalue)
                 If tmp > UInteger.MaxValue Then
                     m_ConstantValue = tmp
                 Else
                     m_ConstantValue = CUInt(tmp)
                 End If
             Case TypeCode.Int64
                 Dim tmp As Double = CLng(lvalue) + CLng(rvalue)
                 If tmp < Long.MinValue OrElse tmp > Long.MaxValue Then
                     m_ConstantValue = tmp
                 Else
                     m_ConstantValue = CLng(tmp)
                 End If
             Case TypeCode.UInt64
                 Dim tmp As Double = CULng(lvalue) + CULng(rvalue)
                 If tmp < ULong.MinValue OrElse tmp > ULong.MaxValue Then
                     m_ConstantValue = tmp
                 Else
                     m_ConstantValue = CULng(tmp)
                 End If
             Case TypeCode.Double
                 m_ConstantValue = CDbl(lvalue) + CDbl(rvalue) 'No overflow possible
             Case TypeCode.Single
                 m_ConstantValue = CSng(lvalue) + CSng(rvalue) 'No overflow possible
             Case TypeCode.Decimal
                 m_ConstantValue = CDec(lvalue) + CDec(rvalue)
             Case Else
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="620" endline="639">
<![CDATA[
 
     Shared Function GetVisibility(ByVal Attributes As Mono.Cecil.MethodAttributes) As ModifierMasks
         Dim attrib As Mono.Cecil.MethodAttributes = Attributes And Mono.Cecil.MethodAttributes.MemberAccessMask
         Select Case attrib
             Case Mono.Cecil.MethodAttributes.Private, Mono.Cecil.MethodAttributes.CompilerControlled
                 Return ModifierMasks.Private
             Case Mono.Cecil.MethodAttributes.FamANDAssem
                 Throw New NotImplementedException
             Case Mono.Cecil.MethodAttributes.Assembly
                 Return ModifierMasks.Friend
             Case Mono.Cecil.MethodAttributes.Family
                 Return ModifierMasks.Protected
             Case Mono.Cecil.MethodAttributes.FamORAssem
                 Return ModifierMasks.Protected Or ModifierMasks.Friend
             Case Mono.Cecil.MethodAttributes.Public
                 Return ModifierMasks.Public
             Case Else
                 Throw New InternalException(String.Format("Attributes
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MyGenerator.vb" startline="487" endline="508">
<![CDATA[
 
     Function GenerateMyLog() As Boolean
         Dim result As Boolean = True
 
         If m_MyType <> MyTypes.Web Then Return True
 
         Dim code As String
         code = "" & _
         "        Private Shared ReadOnly m_LogObjectProvider As ThreadSafeObjectProvider(Of Global.Microsoft.VisualBasic.Logging.AspLog) = New ThreadSafeObjectProvider(Of Global.Microsoft.VisualBasic.Logging.AspLog)" & VB.vbNewLine & _
         "        <Global.System.ComponentModel.Design.HelpKeyword(""My.Application.Log"")> _" & VB.vbNewLine & _
         "        Friend Shared ReadOnly Property Log As Global.Microsoft.VisualBasic.Logging.AspLog" & VB.vbNewLine & _
         "            Get" & VB.vbNewLine & _
         "                Return MyProject.m_LogObjectProvider.GetInstance" & VB.vbNewLine & _
         "            End Get" & VB.vbNewLine & _
         "        End Property" & VB.vbNewLine
 
         ProjectCode.AppendLine(code)
 
         'ProjectCodeCctor.AppendLine("            m_LogObjectProvider = New ThreadSafeObjectProvider(Of Global.Microsoft.VisualBasic.Logging.AspLog)")
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MyGenerator.vb" startline="560" endline="584">
<![CDATA[
 
     Function GenerateMyRequest() As Boolean
         Dim result As Boolean = True
 
         If m_MyType <> MyTypes.Web Then Return True
 
         Dim code As String
         code = "" & _
         "        <Global.System.ComponentModel.Design.HelpKeyword(""My.Request"")> _" & VB.vbNewLine & _
         "        Friend Shared ReadOnly Property Request As Global.System.Web.HttpRequest" & VB.vbNewLine & _
         "            Get" & VB.vbNewLine & _
         "                Dim current As Global.System.Web.HttpContext" & VB.vbNewLine & _
         "                current = Global.System.Web.HttpContext.Current" & VB.vbNewLine & _
         "                If current IsNot Nothing Then" & VB.vbNewLine & _
         "                    Return current.Request" & VB.vbNewLine & _
         "                Else" & VB.vbNewLine & _
         "                    Return Nothing" & VB.vbNewLine & _
         "                End If" & VB.vbNewLine & _
         "            End Get" & VB.vbNewLine & _
         "        End Property" & VB.vbNewLine
 
         ProjectCode.AppendLine(code)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MyGenerator.vb" startline="591" endline="615">
<![CDATA[
 
     Function GenerateMyResponse() As Boolean
         Dim result As Boolean = True
 
         If m_MyType <> MyTypes.Web Then Return True
 
         Dim code As String
         code = "" & _
         "        <Global.System.ComponentModel.Design.HelpKeyword(""My.Response"")> _" & VB.vbNewLine & _
         "        Friend Shared ReadOnly Property Response As Global.System.Web.HttpResponse" & VB.vbNewLine & _
         "            Get" & VB.vbNewLine & _
         "                Dim current As Global.System.Web.HttpContext" & VB.vbNewLine & _
         "                current = Global.System.Web.HttpContext.Current" & VB.vbNewLine & _
         "                If current IsNot Nothing Then" & VB.vbNewLine & _
         "                    Return current.Response    " & VB.vbNewLine & _
         "                Else" & VB.vbNewLine & _
         "                    Return Nothing" & VB.vbNewLine & _
         "                End If" & VB.vbNewLine & _
         "            End Get" & VB.vbNewLine & _
         "        End Property" & VB.vbNewLine
 
         ProjectCode.AppendLine(code)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeImplementsClauses.vb" startline="148" endline="222">
<![CDATA[
 
     Function Resolve() As Boolean
         Dim result As Boolean = True
         Dim tmp As TypeNameResolutionInfo
 
         Dim glob As GlobalExpression = TryCast(Name, GlobalExpression)
         Dim id As Identifier = TryCast(Name, Identifier)
         Dim qi As QualifiedIdentifier = TryCast(Name, QualifiedIdentifier)
         Dim ctn As ConstructedTypeName = TryCast(Name, ConstructedTypeName)
 
         If ctn IsNot Nothing Then
             qi = ctn.QualifiedIdentifier
             Helper.Assert(TypeArgumentCount > 0)
         End If
 
         If qi IsNot Nothing Then
             If qi.IsFirstQualifiedIdentifier Then
                 If Token.IsSomething(qi.Second) Then
                     tmp = New TypeNameResolutionInfo(qi.FirstAsQualifiedIdentifier, FromWhere, 0)
                 Else
                     tmp = New TypeNameResolutionInfo(qi.FirstAsQualifiedIdentifier, FromWhere, Me.TypeArgumentCount)
                     tmp.IsAttributeTypeName = Me.IsAttributeTypeName
                 End If
                 'Helper.Assert(qi.Second IsNot Nothing) 'A qualified identifier can perfectly be only an identifier
             ElseIf qi.IsFirstGlobal Then
                 Helper.Assert(TypeArgumentCount = 0)
                 tmp = New TypeNameResolutionInfo(qi.FirstAsGlobal, FromWhere)
                 'Helper.Assert(qi.Second IsNot Nothing)
             ElseIf qi.IsFirstIdentifier Then
                 If Token.IsSomething(qi.Second) = False Then
                     tmp = New TypeNameResolutionInfo(qi.FirstAsIdentifier, FromWhere, Me.TypeArgumentCount)
                     tmp.IsAttributeTypeName = Me.IsAttributeTypeName
                 Else
                     tmp = New TypeNameResolutionInfo(qi.FirstAsIdentifier, FromWhere, 0)
                 End If
             Else
                 Throw New InternalException(FromWhere)
             End If
 
             tmp.IsImportsResolution = Me.IsImportsResolution
             result = tmp.Resolve AndAlso result
             If result = False Then Return result
 
             If Token.IsSomething(qi.Second) = False Then
                 Me.m_FoundObjects = tmp.m_FoundObjects
             Else
                 If Me.IsAttributeTypeName Then
                     result = ResolveQualifiedName(tmp, qi.Second.IdentiferOrKeywordIdentifier & "Attribute", qi.Second.IdentiferOrKeywordIdentifier, Me.TypeArgumentCount) AndAlso result
                 Else
                     result = ResolveQualifiedName(tmp, qi.Second.IdentiferOrKeywordIdentifier, Nothing, Me.TypeArgumentCount) AndAlso result
                 End If
             End If
         ElseIf glob IsNot Nothing Then
             m_FoundObjects.Add(glob)
             result = True
         ElseIf id IsNot Nothing Then
             If Me.IsImportsResolution Then
                 result = Me.CheckOutermostNamespace(id.Name, Me.TypeArgumentCount) AndAlso result
             Else
                 Dim names() As String
                 If Me.IsAttributeTypeName Then
                     names = New String() {id.Name & "Attribute", id.Name}
                 Else
                     names = New String() {id.Name}
                 End If
                 result = ResolveUnqualifiedName(names, Me.TypeArgumentCount) AndAlso result
             End If
         ElseIf ctn IsNot Nothing Then
             Return Name.Compiler.Report.ShowMessage(Messages.VBNC99997, Name.Location)
         Else
             Return Name.Compiler.Report.ShowMessage(Messages.VBNC99997, Name.Location)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Classes\SrvcProfile.vb" startline="11" endline="97">
<![CDATA[
     Private Sub FrmAbout_Load(ByVal sender As Object, ByVal e As System.EventArgs) Handles Me.Load
 
         Try
             HdrMain.Values.Image = New Bitmap(DataDir & "about.png")
         Catch ex As ArgumentException
         End Try
 
         TabMain.SelectedIndex = 0
         LblVersion.Text = ("Product version
 
         With LstComponents
 
             .Items.Clear()
             .Items.Add("Vista Services Optimizer - v" & Application.ProductVersion)
 
             Dim ComName As String
             Dim Info As FileVersionInfo
 
             ComName = (Application.StartupPath & "\RescueCenter.exe")
             If File.Exists(ComName) = True Then
                 Info = FileVersionInfo.GetVersionInfo(ComName)
                 .Items.Add("Smart Rescue Center - v" & Info.FileVersion)
             ElseIf File.Exists(ComName) = False Then
                 .Items.Add("Smart Rescue Center - NOT Found")
             End If
 
             ComName = (Application.StartupPath & "\QuickControl.exe")
             If File.Exists(ComName) = True Then
                 Info = FileVersionInfo.GetVersionInfo(ComName)
                 .Items.Add("Quick Control - v" & Info.FileVersion)
             ElseIf File.Exists(ComName) = False Then
                 .Items.Add("Quick Control - NOT Found")
             End If
 
             ComName = (Application.StartupPath & "\WebUpdate.exe")
             If File.Exists(ComName) = True Then
                 Info = FileVersionInfo.GetVersionInfo(ComName)
                 .Items.Add("Web Update - v" & Info.FileVersion)
             ElseIf File.Exists(ComName) = False Then
                 .Items.Add("Web Update - NOT Found")
             End If
 
             ComName = (Application.StartupPath & "\ServiceController.DLL")
             If File.Exists(ComName) = True Then
                 Info = FileVersionInfo.GetVersionInfo(ComName)
                 .Items.Add("Service Controller DLL - v" & Info.FileVersion)
             ElseIf File.Exists(ComName) = False Then
                 .Items.Add("Service Controller DLL - NOT Found")
             End If
 
             ComName = (Application.StartupPath & "\GlassButton.DLL")
             If File.Exists(ComName) = True Then
                 Info = FileVersionInfo.GetVersionInfo(ComName)
                 .Items.Add("Glass Button DLL - v" & Info.FileVersion)
             ElseIf File.Exists(ComName) = False Then
                 .Items.Add("Glass Button DLL - NOT Found")
             End If
 
             ComName = (Application.StartupPath & "\Tracker.DLL")
             If File.Exists(ComName) = True Then
                 Info = FileVersionInfo.GetVersionInfo(ComName)
                 .Items.Add("Tracker DLL - v" & Info.FileVersion)
             ElseIf File.Exists(ComName) = False Then
                 .Items.Add("Tracker DLL - NOT Found")
             End If
 
             ComName = (Application.StartupPath & "\MdiClientController.DLL")
             If File.Exists(ComName) = True Then
                 Info = FileVersionInfo.GetVersionInfo(ComName)
                 .Items.Add("MDI Client Controller DLL - v" & Info.FileVersion)
             ElseIf File.Exists(ComName) = False Then
                 .Items.Add("MDI Client Controller DLL - NOT Found")
             End If
 
             ComName = (Application.StartupPath & "\ComponentFactory.Krypton.Toolkit.DLL")
             If File.Exists(ComName) = True Then
                 Info = FileVersionInfo.GetVersionInfo(ComName)
                 .Items.Add("Krypton Toolkit DLL - v" & Info.FileVersion)
             ElseIf File.Exists(ComName) = False Then
                 .Items.Add("Krypton Toolkit DLL - NOT Found")
             End If
 
             .SelectedIndex = 0
 
         End With
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AliasClause.vb" startline="149" endline="204">
<![CDATA[
 
     Function Instantiate(ByVal errorNumber As Messages, ByRef instantiation As Object) As Boolean
         Dim attribModule As Mono.Cecil.ModuleDefinition = TryCast(ResolvedType.Scope, Mono.Cecil.ModuleDefinition)
         Dim attribAssembly As Assembly
         Dim attribType As Type
         Dim attribInstance As Object
 
         If attribModule Is Nothing Then
             Return Compiler.Report.ShowMessage(errorNumber, Location, "The attribute isn't defined in an assembly.")
         End If
 
         attribAssembly = System.Reflection.Assembly.Load(attribModule.Assembly.Name.FullName)
 
         If attribAssembly Is Nothing Then
             Return Compiler.Report.ShowMessage(errorNumber, Location, String.Format("Could not load the assembly '{0}' where this attribute is stored.", attribModule.Assembly.Name.FullName))
         End If
 
         attribType = attribAssembly.GetType(ResolvedType.FullName, False, False)
 
         If attribType Is Nothing Then
             Return Compiler.Report.ShowMessage(errorNumber, Location, String.Format("Could not load the type '{0}' from the assembly '{1}'.", ResolvedType.FullName, attribAssembly.FullName))
         End If
 
         Dim args As Object()
         ReDim args(Me.m_Arguments.Length)
         ReDim args(Me.m_Arguments.Length - 1)
         For i As Integer = 0 To m_Arguments.Length - 1
             args(i) = ConvertArgument(m_Arguments(i), m_ResolvedTypeConstructor.Parameters(i).ParameterType)
         Next
         attribInstance = Activator.CreateInstance(attribType, args)
 
         For i As Integer = 0 To m_Fields.Count - 1
             Dim fieldInfo As FieldInfo
             fieldInfo = attribType.GetField(m_Fields(i).Name, BindingFlags.Instance Or BindingFlags.Public)
             If fieldInfo Is Nothing Then
                 Return Compiler.Report.ShowMessage(errorNumber, Location, String.Format("Could not find the field '{0}' on the type '{1}'.", m_Fields(i).Name, attribType.FullName))
             End If
 
             fieldInfo.SetValue(attribInstance, m_FieldValues(i))
         Next
 
         For i As Integer = 0 To m_Properties.Count - 1
             Dim propInfo As PropertyInfo
             propInfo = attribType.GetProperty(m_Properties(i).Name, Type.EmptyTypes)
             If propInfo Is Nothing Then
                 Return Compiler.Report.ShowMessage(errorNumber, Location, String.Format("Could not find the property '{0}' on the type '{1}'.", m_Properties(i).Name, attribType.FullName))
             End If
             If propInfo.CanWrite = False Then
                 Return Compiler.Report.ShowMessage(errorNumber, Location, String.Format("The property '{0}' on the type '{1}' is ReadOnly.", propInfo.Name, attribType.FullName))
             End If
             propInfo.SetValue(attribInstance, m_PropertyValues(i), Nothing)
         Next
 
         instantiation = attribInstance
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\AssignStatements\AddAssignStatement.vb" startline="77" endline="144">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_LSide.ResolveExpression(Info) AndAlso result
         result = m_RSide.ResolveExpression(Info) AndAlso result
 
         If result = False Then Return result
 
         If TypeOf m_LSide Is InstanceExpression Then
             result = Compiler.Report.ShowMessage(Messages.VBNC30062, Location) AndAlso result
         End If
 
         If RSide.Classification.IsValueClassification Then
             'do nothing
         ElseIf RSide.Classification.IsMethodPointerClassification Then
             ''result = RSide.ResolveAddressOfExpression(m_LSide.ExpressionType) AndAlso result
             'If result Then
             m_RSide = m_RSide.ReclassifyMethodPointerToValueExpression(m_LSide.ExpressionType)
             result = m_RSide.ResolveExpression(Info) AndAlso result
             'End If
         ElseIf RSide.Classification.CanBeValueClassification Then
             RSide = RSide.ReclassifyToValueExpression()
             result = RSide.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
             If result AndAlso RSide.Classification.IsPropertyGroupClassification Then
                 RSide = RSide.ReclassifyToPropertyAccessExpression
                 result = RSide.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
             End If
         Else
             Helper.ShowClassificationError(Compiler, RSide.Location, RSide.Classification, "expression")
             result = False
         End If
 
         If result = False Then Return result
 
         If LSide.Classification.IsVariableClassification OrElse LSide.Classification.IsPropertyAccessClassification Then
             'do nothing
         ElseIf LSide.Classification.CanBePropertyAccessClassification Then
             m_LSide = LSide.ReclassifyToPropertyAccessExpression
             result = LSide.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
             If result = False Then
                 Return result
             End If
         Else
             Helper.ShowClassificationError(Compiler, LSide.Location, LSide.Classification, "expression")
             result = False
         End If
 
         If result = False Then Return result
 
         If CecilHelper.IsGenericType(m_LSide.ExpressionType) AndAlso Helper.CompareType(Compiler.TypeCache.System_Nullable1, CecilHelper.GetGenericTypeDefinition(m_LSide.ExpressionType)) Then
             Dim lTypeArg As Mono.Collections.Generic.Collection(Of Mono.Cecil.TypeReference)
             lTypeArg = CecilHelper.GetGenericArguments(m_LSide.ExpressionType)
             If lTypeArg.Count = 1 AndAlso Helper.CompareType(lTypeArg(0), m_RSide.ExpressionType) Then
                 Dim objCreation As DelegateOrObjectCreationExpression
                 objCreation = New DelegateOrObjectCreationExpression(Me)
                 objCreation.Init(m_LSide.ExpressionType, New ArgumentList(objCreation, m_RSide))
                 result = objCreation.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
                 m_RSide = objCreation
             End If
         End If
 
         If result = False Then Return result
 
         result = CreateTypeConversion() AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\OptionStrictStatement.vb" startline="126" endline="211">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim expCount As Integer
 
         result = m_Expression.ResolveExpression(Info) AndAlso result
         result = m_ArraySizeInitModifier.ResolveCode(Info) AndAlso result
 
         If CecilHelper.IsByRef(m_Expression.ExpressionType) Then
             m_Expression = m_Expression.DereferenceByRef
         End If
 
         m_ArrayType = m_Expression.ExpressionType
         m_IsObjectArray = Helper.CompareType(Compiler.TypeCache.System_Object, m_ArrayType)
 
         expCount = m_ArraySizeInitModifier.BoundList.Expressions.Length
 
         If m_IsObjectArray Then
             m_Rank = expCount
             m_ElementType = Compiler.TypeCache.System_Object
             If m_Rank = 1 Then
                 m_ArrayType = CecilHelper.MakeArrayType(m_ElementType)
             Else
                 m_ArrayType = CecilHelper.MakeArrayType(m_ElementType, m_Rank)
             End If
         ElseIf CecilHelper.IsArray(m_ArrayType) = False Then
             Return Helper.AddError(Me)
         Else
             m_Rank = CecilHelper.GetArrayRank(m_ArrayType)
             m_ElementType = CecilHelper.GetElementType(m_ArrayType)
             If expCount <> m_Rank Then
                 Return Helper.AddError(Me)
             End If
         End If
 
         If Me.IsPreserve Then
             Dim assign As New AssignmentStatement(Me)
             Dim arr As CompilerGeneratedExpression
 
             arr = New CompilerGeneratedExpression(Me, New CompilerGeneratedExpression.GenerateCodeDelegate(AddressOf GenerateCodeForPreserve), m_ArrayType)
 
             For i As Integer = 0 To expCount - 1
                 Dim add As New ConstantExpression(Me, 1, Compiler.TypeCache.System_Int32)
                 Dim exp As Expression
                 Dim addExp As Expression
 
                 exp = Helper.CreateTypeConversion(Me, m_ArraySizeInitModifier.BoundList.Expressions(i), Compiler.TypeCache.System_Int32, result)
                 If result = False Then Return result
 
                 addExp = New BinaryAddExpression(Me, exp, add)
                 result = addExp.ResolveExpression(Info) AndAlso result
                 m_ArraySizeInitModifier.BoundList.Expressions(i) = addExp
             Next
 
             assign.Init(m_Expression, arr)
             result = assign.ResolveStatement(Info) AndAlso result
             m_AssignStatement = assign
         Else
             Dim assign As New AssignmentStatement(Me)
             Dim arr As New ArrayCreationExpression(Me)
             Dim exps() As Expression
 
             exps = m_ArraySizeInitModifier.BoundList.Expressions
             arr.Init(m_Expression.ExpressionType, exps, Nothing)
 
             assign.Init(m_Expression, arr)
             result = assign.ResolveStatement(Info) AndAlso result
             m_AssignStatement = assign
         End If
 
         If m_Expression.Classification.IsPropertyGroupClassification Then
             m_Expression = m_Expression.ReclassifyToPropertyAccessExpression()
             result = m_Expression.ResolveExpression(Info) AndAlso result
         ElseIf m_Expression.Classification.IsVariableClassification Then
         ElseIf m_Expression.Classification.IsPropertyAccessClassification Then
         Else
             Return Helper.AddError(Me, "Redim clause must be classifiable as a property access or variable.")
         End If
         If IsPreserve Then
             If m_Expression.Classification.CanBeValueClassification = False Then
                 Return Helper.AddError(Me, "Redim Preserve clause must be classifiable as a value.")
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Compiler.vb" startline="856" endline="939">
<![CDATA[
 
     ''' <summary>
     ''' Sets the entry point / Main function of the assembly
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function SetMain() As Boolean
         Dim result As Boolean = True
 
         Try
             If CommandLine.Target = vbnc.CommandLine.Targets.Library Then Return True
             If CommandLine.Target = vbnc.CommandLine.Targets.Module Then Return True
 
             'Find the main function
             Dim lstMethods As New Generic.List(Of Mono.Cecil.MethodDefinition)
             Dim mainClass As TypeDeclaration = Nothing
             Dim mainCecil As Mono.Cecil.MethodDefinition = Nothing
             Dim hasMainMethod As Boolean
 
             result = FindMainClass(mainClass) AndAlso result
             result = FindMainMethod(mainClass, lstMethods, hasMainMethod) AndAlso result
 
             If result = False Then Return result
 
             If lstMethods.Count = 0 AndAlso CommandLine.Target = vbnc.CommandLine.Targets.Winexe AndAlso mainClass IsNot Nothing AndAlso vbnc.Helper.IsSubclassOf(TypeCache.System_Windows_Forms_Form, mainClass.CecilType) Then
                 'In this case we need to create our own main method
                 'Dim mainBuilder As MethodBuilder
                 Dim formConstructor As ConstructorDeclaration
                 'Dim ilGen As ILGenerator
 
                 formConstructor = mainClass.DefaultInstanceConstructor
 
                 If formConstructor IsNot Nothing Then
                     mainCecil = New Mono.Cecil.MethodDefinition("Main", Mono.Cecil.MethodAttributes.Public Or Mono.Cecil.MethodAttributes.Static Or Mono.Cecil.MethodAttributes.HideBySig, Helper.GetTypeOrTypeReference(Me, TypeCache.System_Void))
                     mainCecil.Body.GetILProcessor.Emit(Mono.Cecil.Cil.OpCodes.Newobj, formConstructor.CecilBuilder)
                     mainCecil.Body.GetILProcessor.Emit(Mono.Cecil.Cil.OpCodes.Call, Helper.GetMethodOrMethodReference(Me, TypeCache.System_Windows_Forms_Application__Run))
                     mainCecil.Body.GetILProcessor.Emit(Mono.Cecil.Cil.OpCodes.Ret)
                     mainClass.CecilType.Methods.Add(mainCecil)
                     lstMethods.Add(mainCecil)
                 End If
             End If
 
             'Set the entry point of the assembly
             If lstMethods.Count > 1 Then
                 Dim name As String
                 If mainClass IsNot Nothing Then name = mainClass.Name Else name = AssemblyBuilderCecil.Name.Name
                 Report.ShowMessageNoLocation(Messages.VBNC30738, name)
                 Return False
             ElseIf lstMethods.Count = 0 Then
                 If hasMainMethod Then
                     Dim name As String
                     If mainClass IsNot Nothing Then name = mainClass.Name Else name = AssemblyBuilderCecil.Name.Name
                     Report.ShowMessageNoLocation(Messages.VBNC30737, name)
                     Return False
                 Else
                     Dim name As String
                     If mainClass IsNot Nothing Then name = mainClass.Name Else name = AssemblyBuilderCecil.Name.Name
                     Report.ShowMessageNoLocation(Messages.VBNC30420, name)
                     Return False
                 End If
             Else
                 Dim entryMethod As Mono.Cecil.MethodDefinition = lstMethods(0)
                 If mainCecil Is Nothing Then
                     mainCecil = entryMethod
                 End If
                 Dim foundSTAThreadAttribute As Boolean = False
                 For i As Integer = 0 To mainCecil.CustomAttributes.Count - 1
                     If Helper.CompareMethod(mainCecil.CustomAttributes(0).Constructor, TypeCache.System_STAThreadAttribute__ctor) = False Then
                         foundSTAThreadAttribute = True
                         Exit For
                     End If
                 Next
                 If foundSTAThreadAttribute = False Then
                     mainCecil.CustomAttributes.Add(New Mono.Cecil.CustomAttribute(Helper.GetMethodOrMethodReference(Compiler, TypeCache.System_STAThreadAttribute__ctor)))
                 End If
                 AssemblyBuilderCecil.EntryPoint = entryMethod
             End If
 
         Catch ex As Exception
             Throw
         End Try
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmManual.vb" startline="21" endline="74">
<![CDATA[
     End Property
 
     Private Sub FrmManual_Load(ByVal sender As Object, ByVal e As System.EventArgs) Handles Me.Load
 
         On Error Resume Next
         
         HdrMain.Values.Image = New Bitmap(DataDir & "manual_tuneup.png")
         BtnLock.Image = New Bitmap(DataDir & "lock.png")
         BtnRefresh.Image = New Bitmap(DataDir & "refresh.png")
         BtnSearch.Image = New Bitmap(DataDir & "search.png")
         BtnCProfile.Image = New Bitmap(DataDir & "profile.png")
 
         Call Services_Status()
         LstPerformance.Items.Item(0).Selected = True
 
         If My.Settings.ViewInfo = False Then
             BoxInfo.Visible = False
             TabMain.Size = New Size(TabMain.Size.Width, (TabMain.Size.Height + BoxInfo.Size.Height))
         ElseIf My.Settings.ViewInfo = True Then
             PnlStatus.BackgroundImage = New Bitmap(DataDir & "services_manager.png")
         End If
 
         If My.Settings.QueryNet = 0 And My.Settings.BlackViper = False Then
             BtnSearch.Enabled = ComponentFactory.Krypton.Toolkit.ButtonEnabled.False
             Exit Sub
         End If
 
         If My.Settings.QueryNet = 0 Then
             ConTxtMnu.Items.RemoveAt(0)
         ElseIf My.Settings.QueryNet = 1 Then
             ConTxtMnu.Items(0).Text = "Google search engine"
             Search_Engine = "http
         ElseIf My.Settings.QueryNet = 2 Then
             ConTxtMnu.Items(0).Text = "Yahoo search engine"
             Search_Engine = "http
         ElseIf My.Settings.QueryNet = 3 Then
             ConTxtMnu.Items(0).Text = "Bing search engine"
             Search_Engine = "http
         End If
 
         If My.Settings.BlackViper = True Then
             Dim OSVer As String = My.Computer.Info.OSVersion.Substring(0, 3)
             If OSVer = "6.0" Then
                 BlackViper = "http
             ElseIf OSVer = "6.1" Then
                 BlackViper = "http
             Else
                 BlackViper = "http
             End If
         ElseIf My.Settings.BlackViper = False Then
             ConTxtMnu.Items.RemoveAt(1)
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="491" endline="568">
<![CDATA[
 
     Private Function ResolveMethodInvocation() As Boolean
         Dim result As Boolean = True
         Dim mgc As MethodGroupClassification = m_Expression.Classification.AsMethodGroupClassification
 
         'If the method group only contains one method and that method takes no arguments and is a function, 
         'then the method group is interpreted as an invocation expression 
         'with an empty argument list and the result is used as the target of an index expression.
 
         Dim reclassifyToIndex As Boolean
         If mgc.Group.Count = 1 AndAlso m_ArgumentList.Count > 0 Then
             Dim method As Mono.Cecil.MethodReference = TryCast(mgc.Group(0), Mono.Cecil.MethodReference)
 
             reclassifyToIndex = method IsNot Nothing
             reclassifyToIndex = reclassifyToIndex AndAlso method.ReturnType IsNot Nothing
             reclassifyToIndex = reclassifyToIndex AndAlso Helper.CompareType(method.ReturnType, Compiler.TypeCache.System_Void) = False
             reclassifyToIndex = reclassifyToIndex AndAlso Helper.GetParameters(Compiler, method).Count = 0
 
         End If
 
         If reclassifyToIndex Then
             Return ResolveReclassifyToValueThenIndex()
         Else
             result = mgc.ResolveGroup(m_ArgumentList)
             If result Then
                 If Not mgc.VerifyGroup(m_ArgumentList, True) Then Return False
             Else
                 mgc.ResolveGroup(m_ArgumentList, True)
                 Return False
             End If
         End If
 
         Helper.StopIfDebugging(result = False)
 
         If mgc.IsLateBound Then
             Dim lba As LateBoundAccessClassification = New LateBoundAccessClassification(Me, mgc.InstanceExpression, Nothing, mgc.Resolver.MethodName)
             lba.LateBoundType = mgc.Resolver.MethodDeclaringType
             lba.Arguments = m_ArgumentList
             Classification = lba
         ElseIf mgc.ResolvedMethodInfo IsNot Nothing Then
             Dim methodInfo As Mono.Cecil.MethodReference = mgc.ResolvedMethodInfo
 
             If String.IsNullOrEmpty(Compiler.CommandLine.VBRuntime) AndAlso Compiler.Assembly.IsDefinedHere(methodInfo) AndAlso CecilHelper.FindDefinition(methodInfo).IsStatic AndAlso Helper.CompareName(methodInfo.Name, "AscW") Then
                 Dim methodParameters As Mono.Collections.Generic.Collection(Of ParameterDefinition) = Helper.GetParameters(Compiler, methodInfo)
 
                 If methodParameters.Count <> 0 AndAlso Helper.CompareType(methodParameters(0).ParameterType, Compiler.TypeCache.System_Char) Then
                     m_AscWExpression = ArgumentList(0).Expression
                     m_ExpressionType = Compiler.TypeCache.System_Int32
                     Classification = New ValueClassification(Me, m_ExpressionType)
 
                     Return result
                 End If
             End If
 
             If mgc.InstanceExpression Is Nothing AndAlso CecilHelper.IsStatic(methodInfo) = False Then
                 Dim mae As MemberAccessExpression = TryCast(m_Expression, MemberAccessExpression)
                 If mae IsNot Nothing AndAlso mae.FirstExpression.Classification.IsTypeClassification AndAlso mae.FirstExpression.Classification.AsTypeClassification.CanBeExpression Then
                     Dim exp As Expression = Nothing
                     result = mae.FirstExpression.Classification.AsTypeClassification.CreateAliasExpression(mae.FirstExpression, exp) AndAlso result
                     mgc.InstanceExpression = exp
                 Else
                     result = Report.ShowMessage(Messages.VBNC30469, Me.Location)
                 End If
             End If
 
             If methodInfo.ReturnType Is Nothing OrElse Helper.CompareType(methodInfo.ReturnType, Compiler.TypeCache.System_Void) Then
                 Classification = New VoidClassification(Me)
             Else
                 Classification = New ValueClassification(Me, methodInfo.ReturnType)
             End If
         ElseIf mgc.ResolvedConstructor IsNot Nothing Then
             Classification = New VoidClassification(Me)
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeImplementsClauses.vb" startline="680" endline="784">
<![CDATA[
 
     Private Function CheckImports(ByVal R As String, ByVal [Imports] As ImportsClauses, ByVal TypeArgumentCount As Integer) As Boolean
         '---------------------------------------------------------------------------------------------------------
         '*	If the source file containing the name reference has one or more imports
         '**	If R matches the name of an accessible type in exactly one import, then the unqualified name refers to 
         '** that type. If R matches the name of an accessible type in more than one import and all are not the 
         '** same entity, a compile-time error occurs.
         '**	If R matches the name of a namespace in exactly one import, then the unqualified name refers to that
         '** namespace. If R matches the name of a namespace in more than one import and all are not the same entity, a 
         '** compile-time error occurs.
         '**	If the imports contain one or more accessible standard modules, and R matches the name of an accessible 
         '** nested type in exactly one standard module, then the unqualified name refers to that type. If R matches 
         '** the name of accessible nested types in more than one standard module, a compile-time error occurs.
         '---------------------------------------------------------------------------------------------------------
         ' (...)
         '---------------------------------------------------------------------------------------------------------
         '* If the compilation environment defines one or more imports
         '**	If R matches the name of an accessible type in exactly one import, then the unqualified name refers to 
         '** that type. If R matches the name of an accessible type in more than one import, a compile-time error 
         '** occurs.
         '**	If R matches the name of a namespace in exactly one import, then the unqualified name refers to that
         '** namespace. If R matches the name of a namespace in more than one import, a compile-time error occurs.
         '**	If the imports contain one or more accessible standard modules, and R matches the name of an accessible
         '** nested type in exactly one standard module, then the unqualified name refers to that type. If R matches the        '** name of accessible nested types in more than one standard module, a compile-time error occurs.
         '---------------------------------------------------------------------------------------------------------
         Dim nsclauses As New Generic.List(Of ImportsNamespaceClause)
         For Each imp As ImportsClause In [Imports]
             If imp.IsNamespaceClause Then nsclauses.Add(imp.AsNamespaceClause)
         Next
 
         Dim tpFound As New Generic.List(Of Object)
         Dim genericR As String = Helper.CreateGenericTypename(R, TypeArgumentCount)
         '**	If R matches the name of an accessible type in exactly one import, then the unqualified name refers to 
         '** that type. If R matches the name of an accessible type in more than one import, a compile-time error 
         '** occurs.
 
         For Each nsimp As ImportsNamespaceClause In nsclauses
             If nsimp.IsTypeImport Then
                 Dim tp As Mono.Cecil.TypeReference
                 tp = CecilHelper.GetNestedType(nsimp.TypeImported, genericR)
                 If tp IsNot Nothing Then tpFound.Add(tp)
             ElseIf nsimp.IsNamespaceImport Then
                 Dim nsName As String = nsimp.NamespaceImported.FullName
                 If FromWhere.Compiler.TypeManager.TypesByNamespace.ContainsKey(nsName) Then
                     Dim foundType As Mono.Cecil.TypeReference
                     foundType = FromWhere.Compiler.TypeManager.TypesByNamespace(nsName).Item(genericR)
                     If foundType IsNot Nothing Then tpFound.Add(foundType)
                 End If
             Else
                 Continue For
             End If
         Next
         If tpFound.Count = 1 Then
             m_FoundObjects.Add(tpFound(0))
             Return True
         ElseIf tpFound.Count > 0 Then
             Helper.AddError(Name)
             Return False
         End If
 
         '**	If R matches the name of a namespace in exactly one import, then the unqualified name refers to that
         '** namespace. If R matches the name of a namespace in more than one import, a compile-time error occurs.
         'Helper.Stop()
         For Each nsimp As ImportsNamespaceClause In nsclauses
             If nsimp.IsNamespaceImport Then
                 Dim nsName As String = nsimp.NamespaceImported.FullName
                 Dim nsCombined As String = String.Concat(nsName, ".", Helper.CreateGenericTypename(R, TypeArgumentCount))
                 If FromWhere.Compiler.TypeManager.Namespaces.ContainsKey(nsCombined) Then
                     tpFound.Add(FromWhere.Compiler.TypeManager.Namespaces(nsCombined))
                 End If
             ElseIf nsimp.IsTypeImport Then
                 'Skip this
             Else
                 Continue For
             End If
         Next
         If tpFound.Count = 1 Then
             m_FoundObjects.Add(tpFound(0))
             Return True
         ElseIf tpFound.Count > 0 Then
             Helper.AddError(Name)
             Return False
         End If
 
         '**	If the imports contain one or more accessible standard modules, and R matches the name of an accessible
         '** nested type in exactly one standard module, then the unqualified name refers to that type. If R matches the                 '** name of accessible nested types in more than one standard module, a compile-time error occurs.
         'Helper.Stop()
         Dim modules As New TypeList
         For Each nsimp As ImportsNamespaceClause In nsclauses
             If nsimp.IsTypeImport Then
                 Dim tp As Mono.Cecil.TypeReference
                 tp = CecilHelper.GetNestedType(nsimp.TypeImported, genericR)
                 If tp IsNot Nothing AndAlso Helper.IsModule(FromWhere.Compiler, tp) Then modules.Add(tp)
             ElseIf nsimp.IsNamespaceImport Then
                 Dim nsName As String = nsimp.NamespaceImported.FullName
                 Dim importedModules As TypeDictionary = FromWhere.Compiler.TypeManager.GetModulesByNamespace(nsName)
                 If importedModules IsNot Nothing Then modules.AddRange(importedModules.ToTypeList)
             Else
                 Continue For
             End If
         Next
         If CheckModules(modules, R, TypeArgumentCount) Then Return True
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ErrorStatement.vb" startline="91" endline="139">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Select Case m_ExitWhat
             Case KS.Sub
                 m_Container = Me.FindFirstParent(Of IMethod)()
                 If m_Container Is Nothing Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30065, Location) AndAlso result
                 ElseIf (TypeOf m_Container Is SubDeclaration = False AndAlso TypeOf m_Container Is ConstructorDeclaration = False) OrElse TypeOf m_Container Is FunctionDeclaration = True Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30065, Location) AndAlso result
                 End If
             Case KS.Property
                 m_Container = Me.FindFirstParent(Of IMethod)()
                 If m_Container Is Nothing Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30066, Location) AndAlso result
                 ElseIf TypeOf m_Container Is PropertyDeclaration = False AndAlso TypeOf m_Container Is PropertyHandlerDeclaration = False Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30066, Location) AndAlso result
                 End If
             Case KS.Function
                 m_Container = Me.FindFirstParent(Of IMethod)()
                 If m_Container Is Nothing Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30067, Location) AndAlso result
                 ElseIf TypeOf m_Container Is FunctionDeclaration = False Then
                     result = Compiler.Report.ShowMessage(Messages.VBNC30067, Location) AndAlso result
                 End If
             Case KS.Do
                 m_Container = Me.FindFirstParent(Of DoStatement)()
                 If m_Container Is Nothing Then Compiler.Report.ShowMessage(Messages.VBNC30089, Location)
             Case KS.Try
                 m_Container = Me.FindFirstParent(Of TryStatement)()
                 If m_Container Is Nothing Then Compiler.Report.ShowMessage(Messages.VBNC30393, Location)
             Case KS.For
                 m_Container = Me.FindFirstParent(Of ForStatement, ForEachStatement)()
                 If m_Container Is Nothing Then Compiler.Report.ShowMessage(Messages.VBNC30096, Location)
             Case KS.While
                 m_Container = Me.FindFirstParent(Of WhileStatement)()
                 If m_Container Is Nothing Then Compiler.Report.ShowMessage(Messages.VBNC30097, Location)
             Case KS.Select
                 m_Container = Me.FindFirstParent(Of SelectStatement)()
                 If m_Container Is Nothing Then Compiler.Report.ShowMessage(Messages.VBNC30099, Location)
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         result = m_Container IsNot Nothing AndAlso result
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="150" endline="242">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim falseLabel As Label = Emitter.DefineLabel(Info)
         Dim endLabel As Label = Emitter.DefineLabel(Info)
         Dim local As Mono.Cecil.Cil.VariableDefinition
         Dim vose As ValueOnStackExpression
         Dim type_conversion As Expression
         Dim nullable_type As GenericInstanceType = Nothing
         Dim has_value As MethodReference
         Dim get_value As MethodReference
 
         If ThirdPart IsNot Nothing Then
             result = Condition.GenerateCode(Info) AndAlso result
             Emitter.EmitBranchIfFalse(Info, falseLabel)
             result = SecondPart.GenerateCode(Info) AndAlso result
             Emitter.EmitBranch(Info, endLabel)
             Emitter.MarkLabel(Info, falseLabel)
             result = ThirdPart.GenerateCode(Info) AndAlso result
         Else
             'Emit condition, and store the result in a local variable
             local = Emitter.DeclareLocal(Info, Condition.ExpressionType)
             result = Condition.GenerateCode(Info) AndAlso result
             Emitter.EmitStoreVariable(Info, local)
 
             'If the first operand (condition) is nullable and the second is not, the result is the dominant type 
             'between the nulled type of the first operand and the type of the second operand.
             'This means that for this case
             ' - True condition
             ' - False condition
             'For the normal case
             ' - Both conditions
 
             'conditions
             If CecilHelper.IsNullable(Condition.ExpressionType) Then
                 nullable_type = New GenericInstanceType(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Nullable1))
                 nullable_type.GenericArguments.Add(Helper.GetTypeOrTypeReference(Compiler, CecilHelper.GetNulledType(Condition.ExpressionType)))
 
                 'Call Nullable`1.HasValue to check the condition
                 has_value = New MethodReference("get_HasValue", Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Boolean))
                 has_value.DeclaringType = nullable_type
                 has_value.HasThis = True
                 Emitter.EmitLoadVariableLocation(Info, local)
                 Emitter.EmitCall(Info, has_value)
                 Emitter.EmitBranchIfFalse(Info, falseLabel)
             Else
                 Emitter.EmitLoadVariable(Info, local)
                 Emitter.EmitBranchIfFalse(Info, falseLabel)
             End If
 
             'true branch
             If CecilHelper.IsNullable(Condition.ExpressionType) AndAlso CecilHelper.IsNullable(m_ExpressionType) = False Then
                 'denullify
                 get_value = New MethodReference("GetValueOrDefault", Compiler.TypeCache.System_Nullable1.GenericParameters(0))
                 get_value.DeclaringType = nullable_type
                 get_value.HasThis = True
                 Emitter.EmitLoadVariableLocation(Info, local)
                 Emitter.EmitCall(Info, get_value)
                 'convert to proper type
                 vose = New ValueOnStackExpression(Me, CecilHelper.GetNulledType(Condition.ExpressionType))
             Else
                 Emitter.EmitLoadVariable(Info, local)
                 vose = New ValueOnStackExpression(Me, Condition.ExpressionType)
             End If
             type_conversion = Helper.CreateTypeConversion(Me, vose, m_ExpressionType, result)
             result = type_conversion.GenerateCode(Info) AndAlso result
             Emitter.EmitBranch(Info, endLabel)
 
             'false branch
             Emitter.MarkLabel(Info, falseLabel)
             result = SecondPart.GenerateCode(Info) AndAlso result
             If CecilHelper.IsNullable(SecondPart.ExpressionType) AndAlso CecilHelper.IsNullable(m_ExpressionType) = False Then
                 nullable_type = New GenericInstanceType(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Nullable1))
                 nullable_type.GenericArguments.Add(Helper.GetTypeOrTypeReference(Compiler, CecilHelper.GetNulledType(SecondPart.ExpressionType)))
 
                 'denullify
                 get_value = New MethodReference("GetValueOrDefault", Compiler.TypeCache.System_Nullable1.GenericParameters(0))
                 get_value.DeclaringType = nullable_type
                 get_value.HasThis = True
                 Emitter.EmitLoadVariableLocation(Info, local)
                 Emitter.EmitCall(Info, get_value)
                 'convert to proper type
                 vose = New ValueOnStackExpression(Me, CecilHelper.GetNulledType(SecondPart.ExpressionType))
             Else
                 vose = New ValueOnStackExpression(Me, SecondPart.ExpressionType)
             End If
             type_conversion = Helper.CreateTypeConversion(Me, vose, m_ExpressionType, result)
             result = type_conversion.GenerateCode(Info) AndAlso result
         End If
         Emitter.MarkLabel(Info, endLabel)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="6410" endline="6502">
<![CDATA[
 
     ''' <summary>
     ''' EnumDeclaration  
     '''	[  Attributes  ]  [  TypeModifier+  ]  "Enum"  Identifier  [  "As"  IntegralTypeName  ]  StatementTerminator
     '''	   EnumMemberDeclaration+
     '''	"End" "Enum"  StatementTerminator
     ''' 
     ''' LAMESPEC
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseEnumDeclaration(ByVal Parent As ParsedObject, ByVal Attributes As Attributes, ByVal [Namespace] As String) As EnumDeclaration
         Dim result As EnumDeclaration
         Dim m_Modifiers As Modifiers
         Dim m_Identifier As Identifier
         Dim has_error As Boolean
         Dim location As Span
 
         m_Modifiers = ParseModifiers(ModifierMasks.TypeModifiers)
 
         location = tm.CurrentLocation
         tm.AcceptIfNotInternalError(KS.Enum)
 
         m_Identifier = ParseIdentifier()
         If m_Identifier Is Nothing Then
             ShowIdentifierExpected(location)
             tm.GotoNewline(True)
             m_Identifier = New Identifier("dummy")
             has_error = True
         ElseIf m_Identifier.HasTypeCharacter Then
             Compiler.Report.ShowMessage(Messages.VBNC30468, location)
             has_error = True
         End If
 
         result = New EnumDeclaration(Parent, [Namespace], m_Identifier)
         result.Location = location
 
         If tm.Accept(KS.As) Then
             If tm.CurrentToken.IsKeyword Then
                 Select Case tm.CurrentToken.Keyword
                     Case KS.Byte
                         result.EnumConstantType = Compiler.TypeCache.System_Byte
                     Case KS.SByte
                         result.EnumConstantType = Compiler.TypeCache.System_SByte
                     Case KS.Short
                         result.EnumConstantType = Compiler.TypeCache.System_Int16
                     Case KS.UShort
                         result.EnumConstantType = Compiler.TypeCache.System_UInt16
                     Case KS.Integer
                         result.EnumConstantType = Compiler.TypeCache.System_Int32
                     Case KS.UInteger
                         result.EnumConstantType = Compiler.TypeCache.System_UInt32
                     Case KS.Long
                         result.EnumConstantType = Compiler.TypeCache.System_Int64
                     Case KS.ULong
                         result.EnumConstantType = Compiler.TypeCache.System_UInt64
                     Case Else
                         'Just set anything that will cause the correct error to be shown
                         result.EnumConstantType = Compiler.TypeCache.System_Object
                 End Select
                 tm.NextToken()
             Else
                 result.EnumType = ParseNonArrayTypeName(result)
                 If result.EnumType Is Nothing AndAlso has_error = False Then
                     Compiler.Report.ShowMessage(Messages.VBNC30182, tm.CurrentLocation)
                     tm.GotoNewline(True)
                     has_error = True
                 End If
             End If
         End If
 
         If tm.AcceptEndOfStatement(, Not has_error) = False AndAlso has_error = False Then
             tm.GotoNewline(True)
             has_error = True
         End If
 
         If ParseEnumMembers(result) = False AndAlso has_error = False Then
             tm.GotoNewline(True)
             has_error = True
         End If
 
         If Not has_error AndAlso result.Members.Count = 0 Then
             Compiler.Report.ShowMessage(Messages.VBNC30280, result.Location, result.Name)
             has_error = True
         End If
 
         If tm.AcceptIfNotError(KS.End, KS.Enum) = False Then tm.GotoNewline(True)
         If tm.AcceptEndOfStatement(, True) = False Then tm.GotoNewline(True)
 
         result.CustomAttributes = Attributes
         result.Modifiers = m_Modifiers
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3598" endline="3682">
<![CDATA[
 
     ''' <summary>
     ''' RegularPropertyMemberDeclaration  
     '''	[  Attributes  ]  [  PropertyModifier+  ] "Property" FunctionSignature  [  ImplementsClause  ]
     '''		LineTerminator
     '''	PropertyAccessorDeclaration+
     '''	"End" "Property" StatementTerminator
     ''' </summary>
     ''' <remarks></remarks>
     Private Function ParseRegularPropertyMemberDeclaration(ByVal Parent As TypeDeclaration, ByVal Info As ParseAttributableInfo) As RegularPropertyDeclaration
         Dim result As New RegularPropertyDeclaration(Parent)
 
         Dim m_Modifiers As Modifiers
         Dim m_Signature As FunctionSignature
         Dim m_ImplementsClause As MemberImplementsClause
         Dim m_Attributes As New Attributes(result)
         Dim m_Get As PropertyGetDeclaration = Nothing
         Dim m_Set As PropertySetDeclaration = Nothing
 
         m_Modifiers = ParseModifiers(ModifierMasks.PropertyModifiers)
 
         tm.AcceptIfNotInternalError(KS.Property)
 
         m_Signature = ParseFunctionSignature(result)
         If m_Signature Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         result.Signature = m_Signature
 
         If tm.AcceptEndOfStatement() = False Then
             m_ImplementsClause = ParseImplementsClause(result)
             If m_ImplementsClause Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Else
             m_ImplementsClause = Nothing
         End If
 
         Do
             m_Attributes = ParseAttributes(result)
             If PropertyGetDeclaration.IsMe(tm) Then
                 If m_Get IsNot Nothing Then
                     Compiler.Report.ShowMessage(Messages.VBNC30443, tm.CurrentLocation)
                 End If
                 m_Get = ParsePropertyGetMember(result, New ParseAttributableInfo(Compiler, m_Attributes), m_Signature, m_ImplementsClause, m_Modifiers.Mask)
                 If m_Get Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 m_Attributes = Nothing
             ElseIf PropertySetDeclaration.IsMe(tm) Then
                 If m_Set IsNot Nothing Then
                     Compiler.Report.ShowMessage(Messages.VBNC30444, tm.CurrentLocation)
                 End If
                 m_Set = ParsePropertySetMember(result, New ParseAttributableInfo(Compiler, m_Attributes), m_Signature, m_ImplementsClause, m_Modifiers.Mask)
                 If m_Set Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 m_Attributes = Nothing
             Else
                 If m_Attributes IsNot Nothing AndAlso m_Attributes.Count > 0 Then
                     'Hanging attributes.
                     Compiler.Report.ShowMessage(Messages.VBNC99997, tm.CurrentLocation)
                 End If
                 Exit Do
             End If
         Loop
 
         If tm.AcceptIfNotError(KS.End, KS.Property) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         If tm.AcceptEndOfStatement(, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
         If m_Modifiers.Is(ModifierMasks.ReadOnly) AndAlso m_Get Is Nothing Then
             Compiler.Report.ShowMessage(Messages.VBNC30126, m_Signature.Location)
         End If
         If m_Modifiers.Is(ModifierMasks.WriteOnly) AndAlso m_Set Is Nothing Then
             Compiler.Report.ShowMessage(Messages.VBNC30125, m_Signature.Location)
         End If
 
         If m_Modifiers.Is(ModifierMasks.ReadOnly) = False AndAlso m_Modifiers.Is(ModifierMasks.WriteOnly) = False Then
             If m_Get Is Nothing Then
                 Compiler.Report.ShowMessage(Messages.VBNC30124, m_Signature.Location)
             End If
             If m_Set Is Nothing Then
                 Compiler.Report.ShowMessage(Messages.VBNC30124, m_Signature.Location)
             End If
         End If
 
 
         result.CustomAttributes = Info.Attributes
         result.Init(m_Modifiers, m_Signature, m_Get, m_Set, m_ImplementsClause)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmGameMode.vb" startline="338" endline="380">
<![CDATA[
 
 #End Region
 
 #Region "Gaming Mode"
 
     Private Sub BtnSwitch_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles BtnSwitch.Click
 
         If GameMode() = False Then
             If CheckGMProfile() = False Then
                 MessageBox.Show("To use Gaming Mode, you need to select at least one option.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Exclamation, MessageBoxDefaultButton.Button1, 0, False)
                 Exit Sub
             End If
         End If
 
         Try
             FrmProgress.PicProgress.Image = New Bitmap(DataDir & "game_mode.png")
         Catch ex As ArgumentException
         End Try
 
         If GameMode() = True Then
             FrmProgress.LblProgress.Text = "Turning off Gaming Mode, Please wait..."
         ElseIf GameMode() = False Then
             FrmProgress.LblProgress.Text = "Turning on Gaming Mode, Please wait..."
         End If
 
         BWGameMode.RunWorkerAsync()
         FrmProgress.ShowDialog(FrmMain)
 
         If GameMode() = True Then
             Try
                 BtnSwitch.Image = New Bitmap(DataDir & "stop.png")
             Catch ex As ArgumentException
             End Try
             BtnSwitch.Text = " Turn &off Gaming Mode"
         ElseIf GameMode() = False Then
             Try
                 BtnSwitch.Image = New Bitmap(DataDir & "start.png")
             Catch ex As ArgumentException
             End Try
             BtnSwitch.Text = " Turn &on Gaming Mode"
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="82" endline="145">
<![CDATA[
     End Property
 
     Public Overrides Function GetConstant(ByRef m_ConstantValue As Object, ByVal lvalue As Object, ByVal rvalue As Object) As Boolean
         Dim tlvalue, trvalue As Mono.Cecil.TypeReference
         Dim clvalue, crvalue As TypeCode
 
         tlvalue = CecilHelper.GetType(Compiler, lvalue)
         clvalue = Helper.GetTypeCode(Compiler, tlvalue)
         trvalue = CecilHelper.GetType(Compiler, rvalue)
         crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
         If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
             m_ConstantValue = CBool(lvalue) <= CBool(rvalue)
             Return True
         ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
             m_ConstantValue = CDate(lvalue) <= CDate(rvalue)
             Return True
         ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
             m_ConstantValue = CChar(lvalue) <= CChar(rvalue)
             Return True
         ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
             m_ConstantValue = CStr(lvalue) <= CStr(rvalue)
             Return True
         ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
          clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
             m_ConstantValue = CStr(lvalue) <= CStr(rvalue)
             Return True
         End If
 
         Dim smallest As Mono.Cecil.TypeReference
         Dim csmallest As TypeCode
         smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
         Helper.Assert(smallest IsNot Nothing)
         csmallest = Helper.GetTypeCode(Compiler, smallest)
 
         Select Case csmallest
             Case TypeCode.Byte
                 m_ConstantValue = CByte(lvalue) <= CByte(rvalue)
             Case TypeCode.SByte
                 m_ConstantValue = CSByte(lvalue) <= CSByte(rvalue)
             Case TypeCode.Int16
                 m_ConstantValue = CShort(lvalue) <= CShort(rvalue)
             Case TypeCode.UInt16
                 m_ConstantValue = CUShort(lvalue) <= CUShort(rvalue)
             Case TypeCode.Int32
                 m_ConstantValue = CInt(lvalue) <= CInt(rvalue)
             Case TypeCode.UInt32
                 m_ConstantValue = CUInt(lvalue) <= CUInt(rvalue)
             Case TypeCode.Int64
                 m_ConstantValue = CLng(lvalue) <= CLng(rvalue)
             Case TypeCode.UInt64
                 m_ConstantValue = CULng(lvalue) <= CULng(rvalue)
             Case TypeCode.Double
                 m_ConstantValue = CDbl(lvalue) <= CDbl(rvalue)
             Case TypeCode.Single
                 m_ConstantValue = CSng(lvalue) <= CSng(rvalue)
             Case TypeCode.Decimal
                 m_ConstantValue = CDec(lvalue) <= CDec(rvalue)
             Case Else
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="72" endline="127">
<![CDATA[
     End Property
 
     Public Overrides Function GetConstant(ByRef result As Object, ByVal ShowError As Boolean) As Boolean
         Dim rvalue As Object = Nothing
         Dim lvalue As Object = Nothing
 
         If Not m_LeftExpression.GetConstant(lvalue, ShowError) Then Return False
         If Not m_RightExpression.GetConstant(rvalue, ShowError) Then Return False
 
         If lvalue Is Nothing Or rvalue Is Nothing Then
             result = Nothing
             Return True
         End If
 
         Dim tlvalue, trvalue As Mono.Cecil.TypeReference
         Dim clvalue, crvalue As TypeCode
         tlvalue = CecilHelper.GetType(Compiler, lvalue)
         clvalue = Helper.GetTypeCode(Compiler, tlvalue)
         trvalue = CecilHelper.GetType(Compiler, rvalue)
         crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
         If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
             result = CBool(lvalue) AndAlso CBool(rvalue)
             Return True
         End If
 
         Dim smallest As Mono.Cecil.TypeReference
         Dim csmallest As TypeCode
         smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
         Helper.Assert(smallest IsNot Nothing)
         csmallest = Helper.GetTypeCode(Compiler, smallest)
 
         Select Case csmallest
             Case TypeCode.Byte
                 result = CByte(lvalue) And CByte(rvalue)
             Case TypeCode.SByte
                 result = CSByte(lvalue) And CSByte(rvalue)
             Case TypeCode.Int16
                 result = CShort(lvalue) And CShort(rvalue)
             Case TypeCode.UInt16
                 result = CUShort(lvalue) And CUShort(rvalue)
             Case TypeCode.Int32
                 result = CInt(lvalue) And CInt(rvalue)
             Case TypeCode.UInt32
                 result = CUInt(lvalue) And CUInt(rvalue)
             Case TypeCode.Int64
                 result = CLng(lvalue) And CLng(rvalue)
             Case TypeCode.UInt64
                 result = CULng(lvalue) And CULng(rvalue)
             Case Else
                 If ShowError Then Show30059()
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\RMhandler.vb" startline="8" endline="15">
<![CDATA[
     Sub New()
     Private mDoc As New XmlDocument
     Private mPath As String = Application.StartupPath & "\"
 
     Sub New()
         Try
             mDoc.Load(mPath & "Settings.xml")
         Catch ex As Exception
             'mDoc is nothing
             mDoc.LoadXml(My.Resources.FactorySettings)
         End Try
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeConverter.vb" startline="564" endline="614">
<![CDATA[
 
     Shared Function GetBinaryResultType(ByVal op As KS, ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Select Case op
             Case KS.And
                 Return GetAndResultType(op1, op2)
             Case KS.AndAlso
                 Return GetAndAlsoResultType(op1, op2)
             Case KS.Or
                 Return GetOrResultType(op1, op2)
             Case KS.OrElse
                 Return GetOrElseResultType(op1, op2)
             Case KS.Xor
                 Return GetXorResultType(op1, op2)
             Case KS.Add
                 Return GetBinaryAddResultType(op1, op2)
             Case KS.Minus
                 Return GetBinarySubResultType(op1, op2)
             Case KS.Mult
                 Return GetMultResultType(op1, op2)
             Case KS.RealDivision
                 Return GetRealDivResultType(op1, op2)
             Case KS.IntDivision
                 Return GetIntDivResultType(op1, op2)
             Case KS.Power
                 Return GetExpOperandType(op1, op2)
             Case KS.Concat
                 Return GetConcatResultType(op1, op2)
             Case KS.GE
                 Return GetGEResultType(op1, op2)
             Case KS.GT
                 Return GetGTResultType(op1, op2)
             Case KS.LE
                 Return GetLEResultType(op1, op2)
             Case KS.LT
                 Return GetLTResultType(op1, op2)
             Case KS.Equals
                 Return GetEqualsResultType(op1, op2)
             Case KS.NotEqual
                 Return GetNotEqualsResultType(op1, op2)
             Case KS.ShiftLeft, KS.ShiftRight
                 Return GetShiftResultType(op1, op2)
             Case KS.Mod
                 Return GetModResultType(op1, op2)
             Case KS.Like
                 Return GetLikeResultType(op1, op2)
             Case KS.Is, KS.IsNot
                 Return GetIsIsNotResultType(op1, op2)
             Case Else
                 Throw New NotImplementedException()
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeConverter.vb" startline="727" endline="777">
<![CDATA[
 
     Private Shared Function GetBinaryOperandType(ByVal op As KS, ByVal op1 As TypeCode, ByVal op2 As TypeCode) As TypeCode
         Select Case op
             Case KS.And
                 Return GetAndResultType(op1, op2)
             Case KS.AndAlso
                 Return GetAndAlsoResultType(op1, op2)
             Case KS.Or
                 Return GetOrResultType(op1, op2)
             Case KS.OrElse
                 Return GetOrElseResultType(op1, op2)
             Case KS.Xor
                 Return GetXorResultType(op1, op2)
             Case KS.Add
                 Return GetBinaryAddResultType(op1, op2)
             Case KS.Minus
                 Return GetBinarySubResultType(op1, op2)
             Case KS.Mult
                 Return GetMultResultType(op1, op2)
             Case KS.RealDivision
                 Return GetRealDivResultType(op1, op2)
             Case KS.IntDivision
                 Return GetIntDivResultType(op1, op2)
             Case KS.Power
                 Return GetExpOperandType(op1, op2)
             Case KS.Concat
                 Return GetConcatOperandType(op1, op2)
             Case KS.GE
                 Return GetGEOperandType(op1, op2)
             Case KS.GT
                 Return GetGTOperandType(op1, op2)
             Case KS.LE
                 Return GetLEOperandType(op1, op2)
             Case KS.LT
                 Return GetLTOperandType(op1, op2)
             Case KS.Equals
                 Return GetEqualsOperandType(op1, op2)
             Case KS.NotEqual
                 Return GetNotEqualsOperandType(op1, op2)
             Case KS.ShiftLeft, KS.ShiftRight
                 Return GetShiftResultType(op1, op2)
             Case KS.Mod
                 Return GetModResultType(op1, op2)
             Case KS.Like
                 Return GetLikeOperandType(op1, op2)
             Case KS.Is, KS.IsNot
                 Return GetIsIsNotOperandType(op1, op2)
             Case Else
                 Throw New NotImplementedException()
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmAuto.vb" startline="85" endline="153">
<![CDATA[
 
     Private Sub LnkExport_LinkClicked(ByVal sender As Object, ByVal e As System.EventArgs) Handles LnkExport.LinkClicked
 
         Dim Report_Name As String = (ReportsDir & "Services Status Report_" & RNumber(10000).ToString & ".txt")
 
         If Directory.Exists(ReportsDir) = False Then
             Directory.CreateDirectory(ReportsDir)
         End If
 
         If File.Exists(Report_Name) = True Then
             File.SetAttributes(Report_Name, FileAttributes.Normal)
             File.Delete(Report_Name)
         End If
 
         Dim Writer As New StreamWriter(Report_Name)
 
         With Writer
 
             .WriteLine("Windows Services Status Report" & vbCrLf)
             .WriteLine("Date
 
             .WriteLine(ServiceStatus("Uxsms") & vbCrLf)
             .WriteLine(ServiceStatus("Spooler") & vbCrLf)
             .WriteLine(ServiceStatus("stisvc") & vbCrLf)
             .WriteLine(ServiceStatus("TabletInputService") & vbCrLf)
             .WriteLine(ServiceStatus("WinDefend") & vbCrLf)
             .WriteLine(ServiceStatus("MpsSvc") & vbCrLf)
             .WriteLine(ServiceStatus("PcaSvc") & vbCrLf & vbCrLf)
 
             .WriteLine(ServiceStatus("Dhcp") & vbCrLf)
             .WriteLine(ServiceStatus("Dnscache") & vbCrLf)
             .WriteLine(ServiceStatus("DFSR") & vbCrLf)
             .WriteLine(ServiceStatus("LanmanWorkstation") & vbCrLf & vbCrLf)
 
             .WriteLine(ServiceStatus("Browser") & vbCrLf)
             .WriteLine(ServiceStatus("FDResPub") & vbCrLf)
             .WriteLine(ServiceStatus("LanmanServer") & vbCrLf)
             .WriteLine(ServiceStatus("lmhosts") & vbCrLf & vbCrLf)
 
             .WriteLine(ServiceStatus("SDRSVC") & vbCrLf)
             .WriteLine(ServiceStatus("Wlansvc") & vbCrLf)
             .WriteLine(ServiceStatus("ehstart"))
 
             If MaxOpt = 1 Then
                 .WriteLine(vbCrLf)
                 .WriteLine(ServiceStatus("WSearch") & vbCrLf)
                 .WriteLine(ServiceStatus("seclogon") & vbCrLf)
                 .WriteLine(ServiceStatus("RemoteRegistry") & vbCrLf)
                 .WriteLine(ServiceStatus("PolicyAgent") & vbCrLf)
                 .WriteLine(ServiceStatus("CscService") & vbCrLf)
                 .WriteLine(ServiceStatus("WebClient") & vbCrLf)
                 .WriteLine(ServiceStatus("W32Time") & vbCrLf)
                 .WriteLine(ServiceStatus("IKEEXT"))
             End If
 
             .Close()
 
         End With
 
         File.SetAttributes(Report_Name, FileAttributes.ReadOnly)
 
         If MessageBox.Show("Windows services status report was successfully exported." & vbCrLf & "Do you want to open Windows services status report?", "Vista Services Optimizer", MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button1, 0, False) = Windows.Forms.DialogResult.Yes Then
             Try
                 Process.Start(Report_Name)
             Catch ex As System.ComponentModel.Win32Exception
             End Try
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="97" endline="175">
<![CDATA[
     End Property
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_AscWExpression IsNot Nothing Then
             result = m_AscWExpression.GenerateCode(Info.Clone(Me, True, False, Compiler.TypeCache.System_Char)) AndAlso result
 
             Return result
         End If
 
         If m_InvocationMethod IsNot Nothing Then
             result = Helper.EmitArgumentsAndCallOrCallVirt(Info, m_Expression, m_ArgumentList, m_InvocationMethod) AndAlso result
             Return True
         End If
 
         If m_IsLateBoundArray Then
             Return Compiler.Report.ShowMessage(Messages.VBNC99997, Location)
             Return True
         End If
 
         If Classification.IsLateBoundClassification Then
             result = LateBoundAccessToExpression.EmitLateCall(Info, Classification.AsLateBoundAccess) AndAlso result
         Else
             Select Case m_Expression.Classification.Classification
                 Case ExpressionClassification.Classifications.MethodGroup
                     With m_Expression.Classification.AsMethodGroupClassification
                         result = Helper.EmitArgumentsAndCallOrCallVirt(Info, .InstanceExpression, m_ArgumentList, .ResolvedMethod)
                     End With
                 Case ExpressionClassification.Classifications.Value
                     If Info.IsRHS Then
                         If Me.Classification.IsVariableClassification Then
                             result = Me.Classification.GenerateCode(Info) AndAlso result
                         ElseIf Me.Classification.IsPropertyAccessClassification Then
                             result = Me.Classification.AsPropertyAccess.GenerateCode(Info) AndAlso result
                         Else
                             result = m_Expression.GenerateCode(Info) AndAlso result
                         End If
                     Else
                         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                     End If
                 Case ExpressionClassification.Classifications.PropertyAccess
                     If Info.IsRHS Then
                         If Me.Classification.IsVariableClassification Then
                             result = Me.Classification.GenerateCode(Info) AndAlso result
                         Else
                             result = m_Expression.GenerateCode(Info) AndAlso result
                         End If
                     Else
                         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                     End If
                 Case ExpressionClassification.Classifications.PropertyGroup
                     'Helper.NotImplemented()
                     Dim pgC As PropertyGroupClassification
                     pgC = m_Expression.Classification.AsPropertyGroup
                     result = pgC.GenerateCodeAsValue(Info) AndAlso result
                 Case ExpressionClassification.Classifications.Variable
                     If Info.IsRHS Then
                         If Classification.IsValueClassification Then
                             result = Classification.AsValueClassification.GenerateCode(Info) AndAlso result
                         ElseIf Classification.IsPropertyGroupClassification Then
                             result = Classification.AsPropertyGroup.GenerateCodeAsValue(Info) AndAlso result
                         ElseIf Classification.IsPropertyAccessClassification Then
                             result = Classification.AsPropertyAccess.GenerateCode(Info) AndAlso result
                         Else
                             result = Classification.AsVariableClassification.GenerateCodeAsValue(Info) AndAlso result
                         End If
                     Else
                         result = Classification.GenerateCode(Info) AndAlso result
                     End If
                 Case ExpressionClassification.Classifications.LateBoundAccess
                     result = LateBoundAccessToExpression.EmitLateCall(Info, Classification.AsLateBoundAccess) AndAlso result
                 Case Else
                     Throw New InternalException(Me)
             End Select
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="1237" endline="1247">
<![CDATA[
 
     Private Function ExtractULong(ByVal Value As ULong, ByVal Base As IntegerBase) As ULong
         Select Case Base
             Case IntegerBase.Decimal
                 Return CULng(Value)
             Case IntegerBase.Hex, IntegerBase.Octal
                 Return CULng(Value)
             Case Else
                 Throw New InternalException("Unknown base
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="286" endline="363">
<![CDATA[
 
     Private Shared Function User_Profile() As Boolean
 
         If My.Settings.WinAero = 1 OrElse My.Settings.WinAero = 2 Then
         Else
             User_Profile = False
             Exit Function
         End If
 
         If My.Settings.Printer = 1 OrElse My.Settings.Printer = 2 Then
         Else
             User_Profile = False
             Exit Function
         End If
 
         If My.Settings.Scanner = 1 OrElse My.Settings.Scanner = 2 Then
         Else
             User_Profile = False
             Exit Function
         End If
 
         If My.Settings.TabletPC = 1 OrElse My.Settings.TabletPC = 2 Then
         Else
             User_Profile = False
             Exit Function
         End If
 
         If My.Settings.WinDefender = 1 OrElse My.Settings.WinDefender = 2 Then
         Else
             User_Profile = False
             Exit Function
         End If
 
         If My.Settings.WinFirewall = 1 OrElse My.Settings.WinFirewall = 2 Then
         Else
             User_Profile = False
             Exit Function
         End If
 
         If My.Settings.Compatibility = 1 OrElse My.Settings.Compatibility = 2 Then
         Else
             User_Profile = False
             Exit Function
         End If
 
         If My.Settings.Internet = 1 OrElse My.Settings.Internet = 2 Then
         Else
             User_Profile = False
             Exit Function
         End If
 
         If My.Settings.Network = 1 OrElse My.Settings.Network = 2 Then
         Else
             User_Profile = False
             Exit Function
         End If
 
         If My.Settings.WinBackup = 1 OrElse My.Settings.WinBackup = 2 Then
         Else
             User_Profile = False
             Exit Function
         End If
 
         If My.Settings.WirelessNet = 1 OrElse My.Settings.WirelessNet = 2 Then
         Else
             User_Profile = False
             Exit Function
         End If
 
         If My.Settings.MediaCntr = 1 OrElse My.Settings.MediaCntr = 2 Then
         Else
             User_Profile = False
             Exit Function
         End If
 
         User_Profile = True
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\ConstructedTypeName.vb" startline="96" endline="191">
<![CDATA[
     End Property
 
     Public Overrides Function ResolveTypeReferences() As Boolean
         Dim result As Boolean = True
 
         If m_TypeArgumentList IsNot Nothing Then result = m_TypeArgumentList.ResolveTypeReferences AndAlso result
         If m_ConstructedTypeName IsNot Nothing Then result = m_ConstructedTypeName.ResolveTypeReferences AndAlso result
 
         If result = False Then Return False
 
         If m_ConstructedTypeName IsNot Nothing Then
             Dim cache As MemberCache
             Dim entry As MemberCacheEntry
             Dim argumentCount As Integer
             Dim tp As TypeReference
             Dim git As GenericInstanceType
             Dim tpGit As Mono.Cecil.GenericInstanceType
             Dim allArguments As New Generic.List(Of TypeReference)
             Dim declType As TypeReference
             Dim declGit As GenericInstanceType
 
             tp = m_ConstructedTypeName.ResolvedType
             tpGit = TryCast(tp, GenericInstanceType)
             cache = Compiler.TypeManager.GetCache(CecilHelper.GetGenericTypeDefinition(m_ConstructedTypeName.ResolvedType))
 
             'Get the generic arguments
             declType = tp
             While declType IsNot Nothing
                 declGit = TryCast(declType, GenericInstanceType)
                 If declGit IsNot Nothing Then
                     allArguments.InsertRange(0, declGit.GenericArguments)
                 End If
                 declType = declType.DeclaringType
             End While
             While declType IsNot Nothing
                 declGit = TryCast(declType, GenericInstanceType)
                 If declGit IsNot Nothing Then
                     allArguments.InsertRange(0, declGit.GenericArguments)
                 End If
                 declType = declType.DeclaringType
             End While
 
             If m_TypeArgumentList IsNot Nothing Then
                 argumentCount = allArguments.Count + m_TypeArgumentList.Count
             Else
                 argumentCount = allArguments.Count
             End If
 
             If m_TypeArgumentList IsNot Nothing Then
                 For i As Integer = 0 To m_TypeArgumentList.Count - 1
                     allArguments.Add(m_TypeArgumentList(i).ResolvedType)
                 Next
             End If
 
             entry = cache.LookupFlattened(Helper.CreateGenericTypename(m_QualifiedIdentifier.Name, If(m_TypeArgumentList IsNot Nothing, m_TypeArgumentList.Count, 0)), Me.FindFirstParent_IType.CecilType)
 
             If entry Is Nothing OrElse entry.Members.Count = 0 Then
                 Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                 Return False
             ElseIf entry.Members.Count > 1 Then
                 Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                 Return False
             Else
                 Dim memberType As Mono.Cecil.TypeReference = TryCast(entry.Members(0), Mono.Cecil.TypeReference)
                 If memberType IsNot Nothing Then
                     git = New GenericInstanceType(CecilHelper.GetGenericTypeDefinition(memberType))
                     git.GenericArguments.AddRange(allArguments)
                 Else
                     Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                     Return False
                 End If
             End If
 
             If git IsNot Nothing Then
                 m_ResolvedType = git
             Else
                 m_ResolvedType = cache.Type
             End If
         ElseIf m_TypeArgumentList IsNot Nothing Then
             Dim nri As New TypeNameResolutionInfo(Me, Me, m_TypeArgumentList.Count)
             result = nri.Resolve AndAlso result
 
             If result = False Then Return result
 
             If nri.FoundOnlyOneObject Then
                 If nri.FoundIs(Of IType)() Then
                     m_OpenResolvedType = nri.FoundAs(Of IType).CecilType
                 ElseIf nri.FoundIs(Of Mono.Cecil.TypeReference)() Then
                     m_OpenResolvedType = nri.FoundAsType
                 Else
                     Helper.AddError(Me)
                 End If
                 m_ClosedResolvedType = Compiler.TypeManager.MakeGenericType(Me, m_OpenResolvedType, m_TypeArgumentList.ArgumentCollection)
                 m_ResolvedType = m_ClosedResolvedType
             Else
                 Helper.AddError(Me)
             End If
         Else
             Helper.Stop()
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmManual.vb" startline="129" endline="201">
<![CDATA[
 
 #End Region
 
 #Region "Save Settings"
 
     Private Sub BtnOK_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles BtnOK.Click
 
         If ChkAutoUpdate.Checked = True Then
             My.Settings.AutoUpdate = True
             Shell("schtasks /Change /TN WebUpdate /ENABLE", AppWinStyle.Hide)
         ElseIf ChkAutoUpdate.Checked = False Then
             My.Settings.AutoUpdate = False
             Shell("schtasks /Change /TN WebUpdate /DISABLE", AppWinStyle.Hide)
         End If
 
         If ChkAutoStart.Checked = True Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Run", "Vista Services Optimizer", ("""" & Application.StartupPath & "\QuickControl.exe" & """"))
         ElseIf ChkAutoStart.Checked = False Then
             My.Computer.Registry.CurrentUser.OpenSubKey("SOFTWARE\Microsoft\Windows\CurrentVersion\Run", True).DeleteValue("Vista Services Optimizer", False)
         End If
 
         If ChkSnapshots.Checked = True Then
             My.Settings.Snapshots = True
         ElseIf ChkSnapshots.Checked = False Then
             My.Settings.Snapshots = False
         End If
 
         If CboTime.SelectedIndex = 0 Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\Software\Smart PC Utilities\Services Optimizer", "Time", "2", Microsoft.Win32.RegistryValueKind.String)
         ElseIf CboTime.SelectedIndex = 1 Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\Software\Smart PC Utilities\Services Optimizer", "Time", "3", Microsoft.Win32.RegistryValueKind.String)
         ElseIf CboTime.SelectedIndex = 2 Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\Software\Smart PC Utilities\Services Optimizer", "Time", "4", Microsoft.Win32.RegistryValueKind.String)
         ElseIf CboTime.SelectedIndex = 3 Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\Software\Smart PC Utilities\Services Optimizer", "Time", "7", Microsoft.Win32.RegistryValueKind.String)
         ElseIf CboTime.SelectedIndex = 4 Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\Software\Smart PC Utilities\Services Optimizer", "Time", "14", Microsoft.Win32.RegistryValueKind.String)
         ElseIf CboTime.SelectedIndex = 5 Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\Software\Smart PC Utilities\Services Optimizer", "Time", "30", Microsoft.Win32.RegistryValueKind.String)
         ElseIf CboTime.SelectedIndex = 6 Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\Software\Smart PC Utilities\Services Optimizer", "Time", "60", Microsoft.Win32.RegistryValueKind.String)
         ElseIf CboTime.SelectedIndex = 7 Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\Software\Smart PC Utilities\Services Optimizer", "Time", "90", Microsoft.Win32.RegistryValueKind.String)
         ElseIf CboTime.SelectedIndex = -1 Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\Software\Smart PC Utilities\Services Optimizer", "Time", "0", Microsoft.Win32.RegistryValueKind.String)
         End If
 
         If ChkViewInfo.Checked = True Then
             My.Settings.ViewInfo = True
         ElseIf ChkViewInfo.Checked = False Then
             My.Settings.ViewInfo = False
         End If
 
         If ChkBlackViper.Checked = True Then
             My.Settings.BlackViper = True
         ElseIf ChkBlackViper.Checked = False Then
             My.Settings.BlackViper = False
         End If
 
         If CboQueryNet.SelectedIndex = 0 Then
             My.Settings.QueryNet = 1
         ElseIf CboQueryNet.SelectedIndex = 1 Then
             My.Settings.QueryNet = 2
         ElseIf CboQueryNet.SelectedIndex = 2 Then
             My.Settings.QueryNet = 3
         ElseIf CboQueryNet.SelectedIndex = -1 Then
             My.Settings.QueryNet = 0
         End If
 
         My.Settings.Save()
         Call FrmMain.Check_Status()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="193" endline="287">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_Expression.ResolveExpression(New ResolveInfo(Info.Compiler, True, , False)) AndAlso result
         If result = False Then Return False
         If m_ArgumentList IsNot Nothing Then result = m_ArgumentList.ResolveCode(ResolveInfo.Default(Info.Compiler)) AndAlso result
 
         If result = False Then Return False
         'Check the classification of the arguments, can be value, variable, propertyaccess
         For i As Integer = 0 To m_ArgumentList.Count - 1
             If m_ArgumentList(i).Expression IsNot Nothing Then
                 Select Case m_ArgumentList(i).Expression.Classification.Classification
                     Case ExpressionClassification.Classifications.Value
                         'ok
                     Case ExpressionClassification.Classifications.Variable
                         'ok
                     Case ExpressionClassification.Classifications.PropertyAccess
                         'ok
                     Case ExpressionClassification.Classifications.MethodPointer
                         'ok?
                     Case ExpressionClassification.Classifications.PropertyGroup
                         m_ArgumentList(i).Expression = m_ArgumentList(i).Expression.ReclassifyToPropertyAccessExpression
                         result = m_ArgumentList(i).Expression.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
                     Case Else
                         'reclassify to value
                         If m_ArgumentList(i).Expression.Classification.CanBeValueClassification Then
                             m_ArgumentList(i).Expression = m_ArgumentList(i).Expression.ReclassifyToValueExpression
                             result = m_ArgumentList(i).Expression.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
                         Else
                             Helper.AddError(Me)
                         End If
                 End Select
             End If
         Next
 
         If result = False Then Return result
 
         Select Case m_Expression.Classification.Classification
             Case ExpressionClassification.Classifications.LateBoundAccess
                 Dim lae As LateBoundAccessClassification = m_Expression.Classification.AsLateBoundAccess
                 lae.Arguments = m_ArgumentList
                 Classification = lae
             Case ExpressionClassification.Classifications.MethodGroup
                 'This is an invocation expression.
                 result = ResolveMethodInvocation() AndAlso result
 
             Case ExpressionClassification.Classifications.Value
                 If CecilHelper.IsArray(m_Expression.ExpressionType) Then
                     result = ResolveArrayInvocation(Me, m_Expression.ExpressionType) AndAlso result
                 Else
                     result = ResolveIndexInvocation(Me, m_Expression.ExpressionType) AndAlso result
                 End If
             Case ExpressionClassification.Classifications.PropertyAccess
                 If CecilHelper.IsArray(m_Expression.ExpressionType) Then
                     result = ResolveArrayInvocation(Me, m_Expression.ExpressionType) AndAlso result
                 Else
                     result = ResolveIndexInvocation(Me, m_Expression.ExpressionType) AndAlso result
                 End If
             Case ExpressionClassification.Classifications.PropertyGroup
                 result = ResolvePropertyGroupInvocation() AndAlso result
             Case ExpressionClassification.Classifications.Variable
                 'This is an index expression.
 
                 '                An index expression results in an array element or reclassifies a property group into a property access. An index expression consists of, in order, an expression, an opening parenthesis, an index argument list, and a closing parenthesis. The target of the index expression must be classified as either a property group or a value. An index expression is processed as follows
                 '	If the target expression is classified as a value and if its type is not an array type, Object, or System.Array, the type must have a default property. The index is performed on a property group that represents all of the default properties of the type. Although it is not valid to declare a parameterless default property in Visual Basic, other languages may allow declaring such a property. Consequently, indexing a property with no arguments is allowed.
                 '	If the expression results in a value of an array type, the number of arguments in the argument list must be the same as the rank of the array type and may not include named arguments. If any of the indexes are invalid at run time, a System.IndexOutOfRangeException exception is thrown. Each expression must be implicitly convertible to type Integer. The result of the index expression is the variable at the specified index and is classified as a variable.
                 '	If the expression is classified as a property group, overload resolution is used to determine whether one of the properties is applicable to the index argument list. If the property group only contains one property that has a Get accessor and if that accessor takes no arguments, then the property group is interpreted as an index expression with an empty argument list. The result is used as the target of the current index expression. If no properties are applicable, then a compile-time error occurs. Otherwise, the expression results in a property access with the associated instance expression (if any) of the property group.
                 '	If the expression is classified as a late-bound property group or as a value whose type is Object or System.Array, the processing of the index expression is deferred until run time and the indexing is late-bound. The expression results in a late-bound property access typed as Object. The associated instance expression is either the target expression, if it is a value, or the associated instance expression of the property group. At run time the expression is processed as follows
                 '	If the expression is classified as a late-bound property group, the expression may result in a method group, a property group, or a value (if the member is an instance or shared variable). If the result is a method group or property group, overload resolution is applied to the group to determine the correct method for the argument list. If overload resolution fails, a System.Reflection.AmbiguousMatchException exception is thrown. Then the result is processed either as a property access or as an invocation and the result is returned. If the invocation is of a subroutine, the result is Nothing.
                 '	If the run-time type of the target expression is an array type or System.Array, the result of the index expression is the value of the variable at the specified index. 
                 '	Otherwise, the run-time type of the expression must have a default property and the index is performed on the property group that represents all of the default properties on the type. If the type has no default property, then a System.MissingMemberException exception is thrown.
 
                 Dim varexp As VariableClassification = m_Expression.Classification.AsVariableClassification
                 Dim expType As Mono.Cecil.TypeReference = varexp.Type
                 If CecilHelper.IsByRef(expType) Then
                     m_Expression = m_Expression.DereferenceByRef
                     expType = m_Expression.ExpressionType
                 End If
 
                 result = ResolveIndexInvocation(Me, expType) AndAlso result
             Case Else
                 Helper.AddError(Me, "Some error...")
         End Select
 
         If result = False Then Return result
 
         If m_ExpressionType Is Nothing Then
             m_ExpressionType = Classification.GetType(True)
         End If
 
         Helper.Assert(m_ExpressionType IsNot Nothing)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="76" endline="138">
<![CDATA[
     End Property
 
     Public Overrides Function GetConstant(ByRef result As Object, ByVal lvalue As Object, ByVal rvalue As Object) As Boolean
         Dim tlvalue, trvalue As Mono.Cecil.TypeReference
         Dim clvalue, crvalue As TypeCode
         tlvalue = CecilHelper.GetType(Compiler, lvalue)
         clvalue = Helper.GetTypeCode(Compiler, tlvalue)
         trvalue = CecilHelper.GetType(Compiler, rvalue)
         crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
         If clvalue = TypeCode.Boolean AndAlso crvalue = TypeCode.Boolean Then
             result = CBool(lvalue) >= CBool(rvalue)
             Return True
         ElseIf clvalue = TypeCode.DateTime AndAlso crvalue = TypeCode.DateTime Then
             result = CDate(lvalue) >= CDate(rvalue)
             Return True
         ElseIf clvalue = TypeCode.Char AndAlso crvalue = TypeCode.Char Then
             result = CChar(lvalue) >= CChar(rvalue)
             Return True
         ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.String Then
             result = CStr(lvalue) >= CStr(rvalue)
             Return True
         ElseIf clvalue = TypeCode.String AndAlso crvalue = TypeCode.Char OrElse _
          clvalue = TypeCode.Char AndAlso crvalue = TypeCode.String Then
             result = CStr(lvalue) >= CStr(rvalue)
             Return True
         End If
 
         Dim smallest As Mono.Cecil.TypeReference
         Dim csmallest As TypeCode
         smallest = Compiler.TypeResolution.GetSmallestIntegralType(tlvalue, trvalue)
         Helper.Assert(smallest IsNot Nothing)
         csmallest = Helper.GetTypeCode(Compiler, smallest)
 
         Select Case csmallest
             Case TypeCode.Byte
                 result = CByte(lvalue) >= CByte(rvalue)
             Case TypeCode.SByte
                 result = CSByte(lvalue) >= CSByte(rvalue)
             Case TypeCode.Int16
                 result = CShort(lvalue) >= CShort(rvalue)
             Case TypeCode.UInt16
                 result = CUShort(lvalue) >= CUShort(rvalue)
             Case TypeCode.Int32
                 result = CInt(lvalue) >= CInt(rvalue)
             Case TypeCode.UInt32
                 result = CUInt(lvalue) >= CUInt(rvalue)
             Case TypeCode.Int64
                 result = CLng(lvalue) >= CLng(rvalue)
             Case TypeCode.UInt64
                 result = CULng(lvalue) >= CULng(rvalue)
             Case TypeCode.Double
                 result = CDbl(lvalue) >= CDbl(rvalue)
             Case TypeCode.Single
                 result = CSng(lvalue) >= CSng(rvalue)
             Case TypeCode.Decimal
                 result = CDec(lvalue) >= CDec(rvalue)
             Case Else
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="220" endline="262">
<![CDATA[
 
     Function TypeCodeToType(ByVal Code As TypeCode) As Mono.Cecil.TypeReference
         Select Case Code
             Case TypeCode.Boolean
                 Return Compiler.TypeCache.System_Boolean
             Case TypeCode.Byte
                 Return Compiler.TypeCache.System_Byte
             Case TypeCode.Char
                 Return Compiler.TypeCache.System_Char
             Case TypeCode.DateTime
                 Return Compiler.TypeCache.System_DateTime
             Case TypeCode.DBNull
                 Throw New InternalException("")
             Case TypeCode.Decimal
                 Return Compiler.TypeCache.System_Decimal
             Case TypeCode.Double
                 Return Compiler.TypeCache.System_Double
             Case TypeCode.Empty
                 Throw New InternalException("")
             Case TypeCode.Int16
                 Return Compiler.TypeCache.System_Int16
             Case TypeCode.Int32
                 Return Compiler.TypeCache.System_Int32
             Case TypeCode.Int64
                 Return Compiler.TypeCache.System_Int64
             Case TypeCode.Object
                 Return Compiler.TypeCache.System_Object
             Case TypeCode.SByte
                 Return Compiler.TypeCache.System_SByte
             Case TypeCode.Single
                 Return Compiler.TypeCache.System_Single
             Case TypeCode.String
                 Return Compiler.TypeCache.System_String
             Case TypeCode.UInt16
                 Return Compiler.TypeCache.System_UInt16
             Case TypeCode.UInt32
                 Return Compiler.TypeCache.System_UInt32
             Case TypeCode.UInt64
                 Return Compiler.TypeCache.System_UInt64
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmGameMode.vb" startline="138" endline="217">
<![CDATA[
 
 #End Region
 
 #Region "Gaming Mode Profile"
 
     Private Sub Load_Profile()
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Printer", 0) = 1 Then
             ChkPrinter.Checked = True
         Else
             ChkPrinter.Checked = False
         End If
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Scanner", 0) = 1 Then
             ChkScanner.Checked = True
         Else
             ChkScanner.Checked = False
         End If
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "TabletPC", 0) = 1 Then
             ChkTabletPC.Checked = True
         Else
             ChkTabletPC.Checked = False
         End If
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Themes", 0) = 1 Then
             ChkThemes.Checked = True
         Else
             ChkThemes.Checked = False
         End If
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Aero", 0) = 1 Then
             ChkAero.Checked = True
         Else
             ChkAero.Checked = False
         End If
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "NetShare", 0) = 1 Then
             ChkNetShare.Checked = True
         Else
             ChkNetShare.Checked = False
         End If
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "WinSearch", 0) = 1 Then
             ChkWinSearch.Checked = True
         Else
             ChkWinSearch.Checked = False
         End If
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "MediaCntr", 0) = 1 Then
             ChkMediaCntr.Checked = True
         Else
             ChkMediaCntr.Checked = False
         End If
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "WinUpdate", 0) = 1 Then
             ChkWinUpdate.Checked = True
         Else
             ChkWinUpdate.Checked = False
         End If
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Defrag", 0) = 1 Then
             ChkDefrag.Checked = True
         Else
             ChkDefrag.Checked = False
         End If
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Diagnostics", 0) = 1 Then
             ChkDiagnostics.Checked = True
         Else
             ChkDiagnostics.Checked = False
         End If
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer\Game Mode", "Other", 0) = 1 Then
             ChkOther.Checked = True
         Else
             ChkOther.Checked = False
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmSrvcMngr.vb" startline="20" endline="123">
<![CDATA[
 
 #End Region
 
 #Region "Read Profile"
 
     Private Sub FrmUsrProfile_Shown(ByVal sender As Object, ByVal e As System.EventArgs) Handles Me.Shown
 
         If My.Settings.WinAero = 1 Then
             CboWinAero.SelectedIndex = 0
         ElseIf My.Settings.WinAero = 2 Then
             CboWinAero.SelectedIndex = 1
         Else
             CboWinAero.SelectedIndex = -1
         End If
 
         If My.Settings.Printer = 1 Then
             CboPrinter.SelectedIndex = 0
         ElseIf My.Settings.Printer = 2 Then
             CboPrinter.SelectedIndex = 1
         Else
             CboPrinter.SelectedIndex = -1
         End If
 
         If My.Settings.Scanner = 1 Then
             CboScanner.SelectedIndex = 0
         ElseIf My.Settings.Scanner = 2 Then
             CboScanner.SelectedIndex = 1
         Else
             CboScanner.SelectedIndex = -1
         End If
 
         If My.Settings.TabletPC = 1 Then
             CboTabletPC.SelectedIndex = 0
         ElseIf My.Settings.TabletPC = 2 Then
             CboTabletPC.SelectedIndex = 1
         Else
             CboTabletPC.SelectedIndex = -1
         End If
 
         If My.Settings.WinDefender = 1 Then
             CboWinDefender.SelectedIndex = 0
         ElseIf My.Settings.WinDefender = 2 Then
             CboWinDefender.SelectedIndex = 1
         Else
             CboWinDefender.SelectedIndex = -1
         End If
 
         If My.Settings.WinFirewall = 1 Then
             CboWinFirewall.SelectedIndex = 0
         ElseIf My.Settings.WinFirewall = 2 Then
             CboWinFirewall.SelectedIndex = 1
         Else
             CboWinFirewall.SelectedIndex = -1
         End If
 
         If My.Settings.Compatibility = 1 Then
             CboCompatibility.SelectedIndex = 0
         ElseIf My.Settings.Compatibility = 2 Then
             CboCompatibility.SelectedIndex = 1
         Else
             CboCompatibility.SelectedIndex = -1
         End If
 
         If My.Settings.Internet = 1 Then
             CboInternet.SelectedIndex = 0
         ElseIf My.Settings.Internet = 2 Then
             CboInternet.SelectedIndex = 1
         Else
             CboInternet.SelectedIndex = -1
         End If
 
         If My.Settings.Network = 1 Then
             CboNetwork.SelectedIndex = 0
         ElseIf My.Settings.Network = 2 Then
             CboNetwork.SelectedIndex = 1
         Else
             CboNetwork.SelectedIndex = -1
         End If
 
         If My.Settings.WinBackup = 1 Then
             CboWinBackup.SelectedIndex = 0
         ElseIf My.Settings.WinBackup = 2 Then
             CboWinBackup.SelectedIndex = 1
         Else
             CboWinBackup.SelectedIndex = -1
         End If
 
         If My.Settings.WirelessNet = 1 Then
             CboWirelessNet.SelectedIndex = 0
         ElseIf My.Settings.WirelessNet = 2 Then
             CboWirelessNet.SelectedIndex = 1
         Else
             CboWirelessNet.SelectedIndex = -1
         End If
 
         If My.Settings.MediaCntr = 1 Then
             CboMediaCntr.SelectedIndex = 0
         ElseIf My.Settings.MediaCntr = 2 Then
             CboMediaCntr.SelectedIndex = 1
         Else
             CboMediaCntr.SelectedIndex = -1
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="64" endline="70">
<![CDATA[
 
     Function GetLabel(ByVal Info As EmitInfo) As Label
         If m_LabelBuilder.HasValue = False Then
             m_LabelBuilder = Emitter.DefineLabel(Info)
         End If
         Return m_LabelBuilder.Value
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="1868" endline="1921">
<![CDATA[
 
     Private Sub LoadSettings()
 
         Select Case mSettings.GetSetting("View", "SelectedTab")
             Case "tabJoin"
                 mainTabs.SelectedTab = tabJoin
             Case "tabSplit"
                 mainTabs.SelectedTab = tabSplit
             Case Else
                 mainTabs.SelectedTab = tabPlayer
         End Select
 
         If mSettings.GetSetting("Joining", "AutoDetect") = "True" Then
             chkAuto.Checked = True
         End If
 
         If mSettings.GetSetting("Advanced", "KeepHistory") = "True" Then
             chkKeepMRU.Checked = True
         End If
 
         If mSettings.GetSetting("Advanced", "FrameAccurate", "True") = "True" Then
             chkFrameAccurate.Checked = True
         End If
 
         If mSettings.GetSetting("View", "DialogView") = "Default" Then
             chkDialogView.Checked = False
         End If
 
         If mSettings.GetSetting("View", "WindowState") = "Maximized" Then
             Me.WindowState = FormWindowState.Maximized
         End If
 
         MPcontrols.VolBar.Value = CInt(mSettings.GetSetting("Player", "Volume", "50"))
 
         If mSettings.GetSetting("Player", "Mute") = "True" Then
             mPlayMuted = True
             MPcontrols.Mute = True
         End If
 
         If mSettings.GetSetting("Player", "OnTop", "True") = "True" Then
             chkOnTop.Checked = True
         End If
 
         If mSettings.GetSetting("Advanced", "CheckUpdate") = "True" Then
             chkUpdate.Checked = True
         End If
 
         If mSettings.GetSetting("Advanced", "BeepWhenDone") = "True" Then
             chkBeep.Checked = True
         End If
 
         LoadLangList()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="58" endline="66">
<![CDATA[
 
     Public Overrides ReadOnly Property RightOperandTypeCode() As System.TypeCode
         Get
             If MyBase.OperandTypeCode = TypeCode.Object Then
                 Return TypeCode.Object
             Else
                 Return TypeCode.Int32
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3930" endline="3938">
<![CDATA[
 
     Dim StrStd, StrErr As New System.Text.StringBuilder
     Private Sub BufferOutput(ByVal Text As String, ByVal Err As Boolean)
         If Err Then
             StrErr.Append(Text & vbCrLf)
         Else
             StrStd.Append(Text & vbCrLf)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmProfiles.vb" startline="149" endline="183">
<![CDATA[
 
 #End Region
 
 #Region "Tasks"
 
     Private Sub BtnValidate_Click(ByVal sender As Object, ByVal e As System.EventArgs) Handles BtnValidate.Click, ItmValidate.Click
 
         If File.Exists(SelectedProfile) = False Then
             MessageBox.Show("The selected services profile is missing or corrupted.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
             Call Check_Profiles()
             Exit Sub
         End If
 
         Dim Reader As New StreamReader(SelectedProfile)
         Dim Info As String = Reader.ReadToEnd
         Reader.Close()
 
         Dim Profile_Info() As String = Info.Split(CChar("!"))
         UBound(Profile_Info)
 
         If Not Profile_Info(0).Trim = "1.2" Then
             MessageBox.Show("The selected services profile is not compatible with" & vbCrLf & "this version of Vista Services Optimizer.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
             Exit Sub
         End If
 
         Try
             Dim ChkProfile As String = Profile_Info(38).Trim
         Catch ex As IndexOutOfRangeException
             MessageBox.Show("The selected services profile is corrupted and can not be used.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
             Exit Sub
         End Try
 
         MessageBox.Show("The selected services profile status is OK.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Information, MessageBoxDefaultButton.Button1, 0, False)
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="3926" endline="3976">
<![CDATA[
 
     Shared Function GetMethodName(ByVal Method As MethodReference) As String
         Select Case Method.Name
             Case "op_BitwiseAnd", "op_LogicalAnd"
                 Return "And"
             Case "op_Like"
                 Return "Like"
             Case "op_Modulus"
                 Return "Mod"
             Case "op_BitwiseOr", "op_LogicalOr"
                 Return "Or"
             Case "op_ExclusiveOr"
                 Return "XOr"
             Case "op_LessThan"
                 Return "<"
             Case "op_GreaterThan"
                 Return ">"
             Case "op_Equality"
                 Return "="
             Case "op_Inequality"
                 Return "<>"
             Case "op_LessThanOrEqual"
                 Return "<="
             Case "op_GreaterThanOrEqual"
                 Return ">="
             Case "op_Concatenate"
                 Return "&"
             Case "op_Multiply"
                 Return "*"
             Case "op_Addition"
                 Return "+"
             Case "op_Subtraction"
                 Return "-"
             Case "op_Exponent"
                 Return "^"
             Case "op_Division"
                 Return "/"
             Case "op_IntegerDivision"
                 Return "\"
             Case "op_LeftShift", "op_SignedRightShift"
                 Return "<<"
             Case "op_RightShift", "op_UnsignedRightShift"
                 Return ">>"
             Case "op_True"
                 Return "IsTrue"
             Case "op_False"
                 Return "IsFalse"
             Case Else
                 Return Method.Name
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4436" endline="4453">
<![CDATA[
 
     Shared Function GetMethodAccessibilityString(ByVal Attributes As Mono.Cecil.MethodAttributes) As String
         Attributes = Attributes And Mono.Cecil.MethodAttributes.MemberAccessMask
         Select Case Attributes
             Case Mono.Cecil.MethodAttributes.Public
                 Return "Public"
             Case Mono.Cecil.MethodAttributes.Private
                 Return "Private"
             Case Mono.Cecil.MethodAttributes.FamANDAssem, Mono.Cecil.MethodAttributes.FamORAssem
                 Return "Protected Friend"
             Case Mono.Cecil.MethodAttributes.Family
                 Return "Protected"
             Case Mono.Cecil.MethodAttributes.Assembly
                 Return "Friend"
             Case Else
                 Return "Public"
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2805" endline="2820">
<![CDATA[
 
 
     ''' <summary>
     ''' Creates a CType expression containing the specified FromExpression if necessary.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <param name="FromExpression"></param>
     ''' <param name="DestinationType"></param>
     ''' <param name="result"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function CreateTypeConversion(ByVal Parent As ParsedObject, ByVal FromExpression As Expression, ByVal DestinationType As Mono.Cecil.TypeReference, ByRef result As Boolean) As Expression
         Dim res As Expression = Nothing
         result = IsConvertible(Parent, FromExpression, FromExpression.ExpressionType, DestinationType, True, res, True, Nothing)
         Return res
     End Function
]]>
</clone_fragment>
<clone_fragment file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="57" endline="77">
<![CDATA[
     Public Shared Sub Main(ByVal args As String())
         Console.WriteLine("Chapter 2 example 4
 
         ' step 1
         Dim Document As New Document()
 
         ' step 2
         ' we create a writer that listens to the document
         ' and directs a PDF-stream to a file
         PdfWriter.getInstance(Document, New FileOutputStream("Chap0204.pdf"))
 
         ' step 3
         Document.open()
 
         ' step 4
         Document.add(New Phrase(16, vbCrLf & vbCrLf & vbCrLf))
         Document.add(New Phrase(-16, "Hello, this is a very long phrase to show you the somewhat odd effect of a negative leading. You can write from bottom to top. This is not fully supported. It's something between a feature and a bug."))
 
         ' step 5
         Document.close()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="59" endline="82">
<![CDATA[
     Public Shared Sub Main(ByVal args As String())
         Console.WriteLine("Chapter 1 example 3
 
         ' step 1
         Dim document As New Document(PageSize.A4.rotate())
 
         ' step 2
         ' we create a writer that listens to the document
         ' and directs a PDF-stream to a file
 
         PdfWriter.getInstance(document, New FileOutputStream("Chap0103.pdf"))
 
         ' step 3
         document.open()
 
         ' step 4
         Dim i As Integer
         For i = 0 To 20
             document.add(New Phrase("Hello World, Hello Sun, Hello Moon, Hello Stars, Hello Sea, Hello Land, Hello People. "))
         Next
 
         ' step 5
         document.close()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="25" endline="45">
<![CDATA[
     Public Shared Sub Main(ByVal args As String())
         Console.WriteLine("Chapter 1 example 1
 
         ' step 1
         Dim document As New Document()
 
         ' step 2
         ' we create a writer that listens to the document
         ' and directs a PDF-stream to a file
 
         PdfWriter.getInstance(document, New FileStream("Chap0101.pdf", FileMode.Create))
 
         ' step 3
         document.open()
 
         ' step 4
         document.add(New Paragraph("Hello World"))
 
         ' step 5
         document.close()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\Main.vb" startline="180" endline="186">
<![CDATA[
     End Property
 
     '*********************** Constructor ***********************
     Public Sub New()
         FileName = String.Empty
         __RepeatPlaySpecified = True
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmProfiles.vb" startline="200" endline="220">
<![CDATA[
 
     Private Sub BtnDelete_Click(ByVal sender As Object, ByVal e As System.EventArgs) Handles BtnDelete.Click, ItmDelete.Click
 
         If File.Exists(SelectedProfile) = False Then
             MessageBox.Show("The selected services profile is missing or corrupted.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
             Call Check_Profiles()
             Exit Sub
         End If
 
         If MessageBox.Show("Are you sure you want to delete the selected services profile?", "Vista Services Optimizer", MessageBoxButtons.YesNo, MessageBoxIcon.Exclamation, MessageBoxDefaultButton.Button2, 0, False) = Windows.Forms.DialogResult.Yes Then
             Try
                 File.SetAttributes(SelectedProfile, FileAttributes.Normal)
                 File.Delete(SelectedProfile)
                 Call Check_Profiles()
             Catch ex As IOException
                 MessageBox.Show("Error deleting the selected services profile.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
                 Call Check_Profiles()
             End Try
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4630" endline="4749">
<![CDATA[
 
     ''' <summary>
     ''' Adds all the members to the derived class members, unless they are shadowed or overridden
     ''' </summary>
     ''' <param name="DerivedClassMembers"></param>
     ''' <param name="BaseClassMembers"></param>
     ''' <remarks></remarks>
     Shared Sub AddMembers(ByVal Compiler As Compiler, ByVal Type As Type, ByVal DerivedClassMembers As Generic.List(Of Mono.Cecil.MemberReference), ByVal BaseClassMembers As Mono.Cecil.MemberReference())
         Dim shadowed As New Generic.List(Of String)
         Dim overridden As New Generic.List(Of String)
 
         If BaseClassMembers.Length = 0 Then Return
 
         Helper.Assert(Type IsNot Nothing)
         Dim logging As Boolean
 
         If Type.BaseType IsNot Nothing Then
             logging = False 'Type.BaseType.Name = "Form"
         End If
 
         LogAddMessage(Compiler, "", logging)
 
         If Type.BaseType IsNot Nothing Then
             LogAddMessage(Compiler, String.Format("Adding members to type '{0}' from its base type '{1}'", Type.Name, Type.BaseType.Name), logging)
         Else
             LogAddMessage(Compiler, String.Format("Adding members to type '{0}' from its unknown base type", Type.Name), logging)
         End If
 
         For Each member As Mono.Cecil.MemberReference In DerivedClassMembers
             Select Case CecilHelper.GetMemberType(member)
                 Case MemberTypes.Constructor
                     'Constructors are not added.
                 Case MemberTypes.Event
                     'Events can only be shadows
                     shadowed.Add(member.Name)
                 Case MemberTypes.Field
                     shadowed.Add(member.Name)
                 Case MemberTypes.Method
                     Dim mInfo As Mono.Cecil.MethodDefinition = CecilHelper.FindDefinition(DirectCast(member, Mono.Cecil.MethodReference))
                     If mInfo.IsHideBySig Then
                         overridden.AddRange(GetOverloadableSignatures(Compiler, mInfo))
                     Else
                         shadowed.Add(mInfo.Name)
                     End If
                 Case MemberTypes.NestedType
                     shadowed.Add(member.Name)
                 Case MemberTypes.Property
                     Dim pInfo As Mono.Cecil.PropertyReference = DirectCast(member, Mono.Cecil.PropertyReference)
                     If CBool(Helper.GetPropertyAttributes(pInfo) And Mono.Cecil.MethodAttributes.HideBySig) Then
                         overridden.AddRange(GetOverloadableSignatures(Compiler, pInfo))
                     Else
                         shadowed.Add(pInfo.Name)
                     End If
                 Case MemberTypes.TypeInfo
                     shadowed.Add(member.Name)
                 Case Else
                     Throw New InternalException("")
             End Select
         Next
 
         For i As Integer = 0 To shadowed.Count - 1
             LogAddMessage(Compiler, "Shadows
             shadowed(i) = shadowed(i).ToLowerInvariant
         Next
         For i As Integer = 0 To overridden.Count - 1
             LogAddMessage(Compiler, "Overridden
             overridden(i) = overridden(i).ToLowerInvariant
         Next
 
         For Each member As Mono.Cecil.MemberReference In BaseClassMembers
             Dim name As String = member.Name.ToLowerInvariant
 
             If shadowed.Contains(name) Then
                 LogAddMessage(Compiler, "Discarded (shadowed)
                 Continue For
             End If
 
 
             Select Case CecilHelper.GetMemberType(member)
                 Case MemberTypes.Constructor
                     LogAddMessage(Compiler, "Discarded (constructor)
                     Continue For 'Constructors are not added
                 Case MemberTypes.Method, MemberTypes.Property
                     Dim signatures As String()
                     Dim found As Boolean
 
                     If IsAccessibleExternal(Compiler, member) = False Then
                         LogAddMessage(Compiler, "Discarted (not accessible)
                         Continue For
                     End If
 
                     found = False
                     signatures = GetOverloadableSignatures(Compiler, member)
                     For Each signature As String In signatures
                         name = signature.ToLowerInvariant
                         If overridden.Contains(name) Then
                             found = True
                             Exit For
                         End If
                     Next
                     If found = True Then
                         LogAddMessage(Compiler, "Discarded (overridden, " & CecilHelper.GetMemberType(member).ToString() & ")
                         Continue For
                     End If
                 Case MemberTypes.Event, MemberTypes.Field, MemberTypes.NestedType, MemberTypes.TypeInfo
                     If IsAccessibleExternal(Compiler, member) = False Then
                         LogAddMessage(Compiler, "Discarted (not accessible)
                         Continue For
                     End If
                 Case Else
                     Throw New InternalException("")
             End Select
 
             'Not shadowed nor overriden
             LogAddMessage(Compiler, "Added (" & CecilHelper.GetMemberType(member).ToString & ")
             DerivedClassMembers.Add(member)
         Next
 
         LogAddMessage(Compiler, "", logging)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="1537" endline="1608">
<![CDATA[
 
     Private Function ParseAssemblyMembers(ByVal Parent As AssemblyDeclaration, ByVal RootNamespace As String) As Boolean
         Dim result As Boolean = True
         Dim currentNameSpace As String = RootNamespace
         Dim currentNamespaces As New Generic.List(Of QualifiedIdentifier)
 
         While True
             Dim attributes As Attributes = Nothing
 
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(Parent, attributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
                 If tm.AcceptEndOfStatement Then
                     For Each attrib As Attribute In attributes
                         If attrib.IsAssembly = False AndAlso attrib.IsModule = False Then
                             If attrib.Location.File(Compiler).DoesLineEndWithLineContinuation(attrib.Location.Line) Then
                                 result = Compiler.Report.ShowMessage(Messages.VBNC30203, attrib.Location) AndAlso result
                             Else
                                 result = Compiler.Report.ShowMessage(Messages.VBNC32035, attrib.Location) AndAlso result
                             End If
                         End If
                     Next
                     Parent.Attributes.AddRange(attributes)
                     Continue While
                 End If
             End If
 
             Dim newType As TypeDeclaration
             newType = ParseTypeDeclaration(Parent, attributes, currentNameSpace)
             If newType IsNot Nothing Then
                 If Not Parent.Members.Contains(newType) Then
                     'This may be false for partial types
                     Parent.Members.Add(newType)
                 End If
             ElseIf tm.Accept(KS.Namespace) Then
                 Dim qi As QualifiedIdentifier
                 qi = ParseQualifiedIdentifier(Parent)
                 If qi Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 currentNamespaces.Add(qi)
                 currentNameSpace = RootNamespace
                 If currentNamespaces.Count > 0 Then
                     If currentNameSpace <> "" Then currentNameSpace &= "."
                     For i As Integer = 0 To currentNamespaces.Count - 2
                         currentNameSpace &= currentNamespaces(i).Name & "."
                     Next
                     currentNameSpace &= currentNamespaces(currentNamespaces.Count - 1).Name
                 End If
                 If tm.AcceptNewLine(True, True, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf tm.Accept(KS.End, KS.Namespace) Then
                 If tm.AcceptNewLine(True, False, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 If currentNamespaces.Count >= 1 Then
                     currentNamespaces.RemoveAt(currentNamespaces.Count - 1)
                     currentNameSpace = RootNamespace
                     If currentNamespaces.Count > 0 Then
                         If currentNameSpace <> "" Then currentNameSpace &= "."
                         For i As Integer = 0 To currentNamespaces.Count - 2
                             currentNameSpace &= currentNamespaces(i).Name & "."
                         Next
                         currentNameSpace &= currentNamespaces(currentNamespaces.Count - 1).Name
                     End If
                 Else
                     result = Compiler.Report.ShowMessage(Messages.VBNC30623, tm.CurrentLocation)
                 End If
             Else
                 If attributes IsNot Nothing AndAlso attributes.Count > 0 Then
                     Helper.AddError(Compiler, tm.CurrentLocation, "Hanging attributes.")
                 End If
                 Exit While
             End If
         End While
         While True
             Dim attributes As Attributes = Nothing
 
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(Parent, attributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
 
                 If tm.AcceptEndOfStatement Then
                     For Each attrib As Attribute In attributes
                         If attrib.IsAssembly = False AndAlso attrib.IsModule = False Then
                             If attrib.Location.File(Compiler).DoesLineEndWithLineContinuation(attrib.Location.Line) Then
                                 result = Compiler.Report.ShowMessage(Messages.VBNC30203, attrib.Location) AndAlso result
                             Else
                                 result = Compiler.Report.ShowMessage(Messages.VBNC32035, attrib.Location) AndAlso result
                             End If
                         End If
                     Next
                     Parent.Attributes.AddRange(attributes)
                     Continue While
                 End If
             End If
 
             Dim newType As TypeDeclaration
             newType = ParseTypeDeclaration(Parent, attributes, currentNameSpace)
             If newType IsNot Nothing Then
                 If Not Parent.Members.Contains(newType) Then
                     'This may be false for partial types
                     Parent.Members.Add(newType)
                 End If
             ElseIf tm.Accept(KS.Namespace) Then
                 Dim qi As QualifiedIdentifier
                 qi = ParseQualifiedIdentifier(Parent)
                 If qi Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 currentNamespaces.Add(qi)
                 currentNameSpace = RootNamespace
                 If currentNamespaces.Count > 0 Then
                     If currentNameSpace <> "" Then currentNameSpace &= "."
                     For i As Integer = 0 To currentNamespaces.Count - 2
                         currentNameSpace &= currentNamespaces(i).Name & "."
                     Next
                     currentNameSpace &= currentNamespaces(currentNamespaces.Count - 1).Name
                 End If
                 If tm.AcceptNewLine(True, True, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf tm.Accept(KS.End, KS.Namespace) Then
                 If tm.AcceptNewLine(True, False, True) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 If currentNamespaces.Count >= 1 Then
                     currentNamespaces.RemoveAt(currentNamespaces.Count - 1)
                     currentNameSpace = RootNamespace
                     If currentNamespaces.Count > 0 Then
                         If currentNameSpace <> "" Then currentNameSpace &= "."
                         For i As Integer = 0 To currentNamespaces.Count - 2
                             currentNameSpace &= currentNamespaces(i).Name & "."
                         Next
                         currentNameSpace &= currentNamespaces(currentNamespaces.Count - 1).Name
                     End If
                 Else
                     result = Compiler.Report.ShowMessage(Messages.VBNC30623, tm.CurrentLocation)
                 End If
             Else
                 If attributes IsNot Nothing AndAlso attributes.Count > 0 Then
                     Helper.AddError(Compiler, tm.CurrentLocation, "Hanging attributes.")
                 End If
                 Exit While
             End If
         End While
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArgumentList.vb" startline="93" endline="179">
<![CDATA[
 
     ''' <summary>
     ''' This function only verifies the expression type of the argument,
     ''' it does not expand paramarray arguments nor optional arguments
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function VerifyArguments(ByVal parameters As Mono.Collections.Generic.Collection(Of ParameterDefinition), ByVal ShowErrors As Boolean) As Boolean
         Dim result As Boolean = True
 
 #If EXTENDEDDEBUG Then
         Compiler.Report.WriteLine(Me.Location.ToString & "
 #End If
         For i As Integer = 0 To m_Arguments.Count - 1
             Dim exp As Expression
             Dim arg As Argument = m_Arguments(i)
             Dim par As Mono.Cecil.ParameterDefinition = parameters(i)
 
             If Helper.CompareType(arg.Expression.ExpressionType, Compiler.TypeCache.DelegateUnresolvedType) Then
                 Dim aoe As AddressOfExpression = TryCast(arg.Expression, AddressOfExpression)
                 Dim delegateType As Mono.Cecil.TypeReference = par.ParameterType
 
                 Helper.Assert(aoe IsNot Nothing)
                 Helper.Assert(delegateType IsNot Nothing)
 
                 result = aoe.Resolve(delegateType, True) AndAlso result
 
                 Dim del As DelegateOrObjectCreationExpression
                 del = New DelegateOrObjectCreationExpression(Me)
                 del.Init(delegateType, New ArgumentList(del, aoe))
                 result = del.ResolveExpression(ResolveInfo.Default(Compiler)) AndAlso result
                 m_Arguments(i).Expression = del
             End If
 
             If CecilHelper.IsByRef(par.ParameterType) AndAlso CecilHelper.IsByRef(arg.Expression.ExpressionType) = False AndAlso CecilHelper.IsValueType(CecilHelper.GetElementType(par.ParameterType)) = False Then
                 If arg.Expression.Classification.IsPropertyAccessClassification Then
                     Dim propRef As PropertyReference = arg.Expression.Classification.AsPropertyAccess.Property
                     Dim propDef As PropertyDefinition = CecilHelper.FindDefinition(propRef)
                     If propDef.GetMethod Is Nothing Then
                         If ShowErrors Then Compiler.Report.ShowMessage(Messages.VBNC30524, m_Arguments(i).Location, propDef.Name)
                         result = False
                     End If
                     exp = arg.Expression
                 ElseIf Helper.CompareType(arg.Expression.ExpressionType, Compiler.TypeCache.Nothing) = False Then
                     exp = New GetRefExpression(Me, arg.Expression)
                 Else
                     exp = arg.Expression
                 End If
             ElseIf CecilHelper.IsByRef(par.ParameterType) AndAlso CecilHelper.IsByRef(arg.Expression.ExpressionType) AndAlso Helper.CompareType(CecilHelper.GetElementType(par.ParameterType), CecilHelper.GetElementType(arg.Expression.ExpressionType)) Then
                 exp = arg.Expression
             ElseIf CecilHelper.IsByRef(par.ParameterType) AndAlso Helper.CompareType(arg.Expression.ExpressionType, CecilHelper.GetElementType(par.ParameterType)) = False AndAlso (arg.Expression.Classification.IsVariableClassification OrElse arg.Expression.Classification.IsPropertyAccessClassification) Then
                 Dim varTmp As LocalVariableDeclaration
                 Dim assignA, assignB As AssignmentStatement
                 Dim block As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
                 Dim thisStatement As Statement = Me.FindFirstParent(Of Statement)()
 
                 varTmp = New LocalVariableDeclaration(Me.Parent)
                 varTmp.Init(Nothing, "VB$tmp", CecilHelper.GetElementType(par.ParameterType))
                 'result = varTmp.ResolveMember(ResolveInfo.Default(Compiler)) AndAlso result
 
                 assignA = New AssignmentStatement(Me.Parent)
                 assignA.Init(New VariableExpression(assignA, varTmp), arg.Expression)
                 result = assignA.ResolveStatement(ResolveInfo.Default(Compiler)) AndAlso result
 
                 assignB = New AssignmentStatement(Me.Parent)
                 assignB.Init(arg.Expression, New VariableExpression(assignB, varTmp))
                 result = assignB.ResolveStatement(ResolveInfo.Default(Compiler)) AndAlso result
 
                 block.AddVariable(varTmp)
                 block.AddStatementBefore(assignA, thisStatement)
                 block.AddStatementAfter(assignB, thisStatement)
 
                 exp = New GetRefExpression(Me, New VariableExpression(Me, varTmp))
             Else
 #If EXTENDEDDEBUG Then
                 Compiler.Report.WriteLine("VerifyArguments, needs convertion from " & arg.Expression.ExpressionType.FullName & " to " & par.ParameterType.FullName)
 #End If
                 exp = Nothing
                 result = Helper.IsConvertible(arg, arg.Expression, arg.Expression.ExpressionType, par.ParameterType, True, exp, ShowErrors, Nothing) AndAlso result
             End If
             If exp IsNot arg.Expression Then
                 m_Arguments(i) = New PositionalArgument(Me, i, exp)
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Modules\Common.vb" startline="63" endline="154">
<![CDATA[
 
 #End Region
 
 #Region "File Validation"
 
     Friend Function Validate(ByVal TxtName As TextBox, ByVal TxtDescription As TextBox, ByVal Type As Byte) As Byte
 
         If Type = 0 Then
             If Directory.Exists(SnapshotsDir) = False Then
                 Directory.CreateDirectory(SnapshotsDir)
             End If
         ElseIf Type = 1 Then
             If Directory.Exists(ProfilesDir) = False Then
                 Directory.CreateDirectory(ProfilesDir)
             End If
         End If
 
         If TxtName.Text.Trim = "" Then
             If Type = 0 Then
                 MessageBox.Show("Please enter the name of the services snapshot.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
             ElseIf Type = 1 Then
                 MessageBox.Show("Please enter the name of the services profile.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
             End If
             TxtName.Focus()
             Validate = 0
             Exit Function
 
         ElseIf Not TxtName.Text.Trim = "" Then
             If TxtName.Text.Contains("?") = True OrElse _
            TxtName.Text.Contains("/") = True OrElse _
            TxtName.Text.Contains("\") = True OrElse _
            TxtName.Text.Contains("*") = True OrElse _
            TxtName.Text.Contains("|") = True OrElse _
            TxtName.Text.Contains("
            TxtName.Text.Contains("<") = True OrElse _
            TxtName.Text.Contains(">") = True OrElse _
            TxtName.Text.Contains("""") = True Then
                 If Type = 0 Then
                     MessageBox.Show("Illegal character(s) found in the name of the services snapshot.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
                 ElseIf Type = 1 Then
                     MessageBox.Show("Illegal character(s) found in the name of the services profile.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
                 End If
                 TxtName.Focus()
                 Validate = 0
                 Exit Function
             End If
         End If
 
         Dim File_Path As String = ""
 
         If Type = 0 Then
             File_Path = (SnapshotsDir & TxtName.Text & ".wss")
         ElseIf Type = 1 Then
             File_Path = (ProfilesDir & TxtName.Text & ".wsp")
         End If
 
         If File.Exists(File_Path) = True Then
             If Type = 0 Then
                 MessageBox.Show("A services snapshot with the same name is found.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
             ElseIf Type = 1 Then
                 MessageBox.Show("A services profile with the same name is found.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
             End If
             TxtName.Focus()
             Validate = 0
             Exit Function
         End If
 
         If TxtDescription.Text.Trim = "" Then
             If Type = 0 Then
                 MessageBox.Show("Please enter the description of the services snapshot.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
             ElseIf Type = 1 Then
                 MessageBox.Show("Please enter the description of the services profile.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
             End If
             TxtDescription.Focus()
             Validate = 0
             Exit Function
         ElseIf Not TxtDescription.Text.Trim = "" Then
             If TxtDescription.Text.Contains("!") = True Then
                 If Type = 0 Then
                     MessageBox.Show("Illegal character(s) found in the description of the services snapshot.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
                 ElseIf Type = 1 Then
                     MessageBox.Show("Illegal character(s) found in the description of the services profile.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Error, MessageBoxDefaultButton.Button1, 0, False)
                 End If
                 TxtDescription.Focus()
                 Validate = 0
                 Exit Function
             End If
         End If
 
         Validate = 1
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="651" endline="726">
<![CDATA[
 
     Public Shared Function MakeEmittable(ByVal Method As MethodReference) As MethodReference
         Dim result As MethodReference
         Dim genM As GenericInstanceMethod = TryCast(Method, GenericInstanceMethod)
         Dim tG As GenericInstanceType = TryCast(Method.DeclaringType, GenericInstanceType)
 
         If genM Is Nothing AndAlso tG Is Nothing Then
             If Method.DeclaringType.GenericParameters.Count > 0 Then
                 tG = New GenericInstanceType(Method.DeclaringType)
                 For i As Integer = 0 To Method.DeclaringType.GenericParameters.Count - 1
                     tG.GenericArguments.Add(Method.DeclaringType.GenericParameters(i))
                 Next
 
                 Dim mR As New Mono.Cecil.MethodReference(Method.Name, tG, Method.ReturnType, Method.HasThis, Method.ExplicitThis, Method.CallingConvention)
                 For i As Integer = 0 To Method.Parameters.Count - 1
                     Dim param As Mono.Cecil.ParameterDefinition
                     param = New Mono.Cecil.ParameterDefinition(Method.Parameters(i).ParameterType)
                     mR.Parameters.Add(param)
                 Next
                 Return mR
             End If
         End If
 
         Dim mD As MethodDefinition = FindDefinition(Method)
 
         If mD Is Nothing Then
             If TypeOf Method.DeclaringType Is ArrayType Then
                 Dim arrayType As TypeReference
                 arrayType = Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, Method.DeclaringType)
                 result = New MethodReference(Method.Name, Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, Method.DeclaringType), Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, Method.ReturnType), Method.HasThis, Method.ExplicitThis, Method.CallingConvention)
                 For i As Integer = 0 To Method.Parameters.Count - 1
                     Dim pType As Mono.Cecil.TypeReference
                     pType = Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, Method.Parameters(i).ParameterType)
                     If pType Is Method.Parameters(i).ParameterType Then
                         result.Parameters.Add(Method.Parameters(i))
                     Else
                         result.Parameters.Add(New ParameterDefinition(pType))
                     End If
                 Next
                 Return result
             End If
             Helper.Assert(mD IsNot Nothing)
             Return Nothing
         End If
 
         If mD Is Method AndAlso mD.DeclaringType.Module Is Compiler.CurrentCompiler.ModuleBuilderCecil Then
             Return mD
         End If
 
         If genM IsNot Nothing Then
             Dim gimResult As New GenericInstanceMethod(Helper.GetMethodOrMethodReference(BaseObject.m_Compiler, mD))
             gimResult.OriginalMethod = mD
             gimResult.ReturnType = Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, mD.ReturnType)
             For i As Integer = 0 To genM.GenericArguments.Count - 1
                 gimResult.GenericArguments.Add(Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, genM.GenericArguments(i)))
             Next
             Return gimResult
         End If
 
         result = New MethodReference(Method.Name, Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, Method.DeclaringType), Helper.GetTypeOrTypeReference(BaseObject.m_Compiler, mD.ReturnType), Method.HasThis, Method.ExplicitThis, Method.CallingConvention)
         For i As Integer = 0 To mD.Parameters.Count - 1
             Dim pType As Mono.Cecil.TypeReference
             pType = Helper.GetTypeOrTypeReference(Compiler.CurrentCompiler, mD.Parameters(i).ParameterType)
             If pType Is mD.Parameters(i).ParameterType Then
                 result.Parameters.Add(mD.Parameters(i))
             Else
                 result.Parameters.Add(New ParameterDefinition(pType))
             End If
         Next
         If mD.GenericParameters IsNot Nothing AndAlso mD.GenericParameters.Count > 0 Then
             For i As Integer = 0 To mD.GenericParameters.Count - 1
                 result.GenericParameters.Add(mD.GenericParameters(i))
             Next
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmSrvcMngr.vb" startline="124" endline="243">
<![CDATA[
 
 #End Region
 
 #Region "Save Profile"
 
     Private Sub BtnOK_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles BtnOK.Click
 
         If CboWinAero.SelectedIndex = 0 Then
             My.Settings.WinAero = 1
         ElseIf CboWinAero.SelectedIndex = 1 Then
             My.Settings.WinAero = 2
         Else
             ErrorMsg(CboWinAero)
             Exit Sub
         End If
 
         If CboPrinter.SelectedIndex = 0 Then
             My.Settings.Printer = 1
         ElseIf CboPrinter.SelectedIndex = 1 Then
             My.Settings.Printer = 2
         Else
             ErrorMsg(CboPrinter)
             Exit Sub
         End If
 
         If CboScanner.SelectedIndex = 0 Then
             My.Settings.Scanner = 1
         ElseIf CboScanner.SelectedIndex = 1 Then
             My.Settings.Scanner = 2
         Else
             ErrorMsg(CboScanner)
             Exit Sub
         End If
 
         If CboTabletPC.SelectedIndex = 0 Then
             My.Settings.TabletPC = 1
         ElseIf CboTabletPC.SelectedIndex = 1 Then
             My.Settings.TabletPC = 2
         Else
             ErrorMsg(CboTabletPC)
             Exit Sub
         End If
 
         If CboWinDefender.SelectedIndex = 0 Then
             My.Settings.WinDefender = 1
         ElseIf CboWinDefender.SelectedIndex = 1 Then
             My.Settings.WinDefender = 2
         Else
             ErrorMsg(CboWinDefender)
             Exit Sub
         End If
 
         If CboWinFirewall.SelectedIndex = 0 Then
             My.Settings.WinFirewall = 1
         ElseIf CboWinFirewall.SelectedIndex = 1 Then
             My.Settings.WinFirewall = 2
         Else
             ErrorMsg(CboWinFirewall)
             Exit Sub
         End If
 
         If CboCompatibility.SelectedIndex = 0 Then
             My.Settings.Compatibility = 1
         ElseIf CboCompatibility.SelectedIndex = 1 Then
             My.Settings.Compatibility = 2
         Else
             ErrorMsg(CboCompatibility)
             Exit Sub
         End If
 
         If CboInternet.SelectedIndex = 0 Then
             My.Settings.Internet = 1
         ElseIf CboInternet.SelectedIndex = 1 Then
             My.Settings.Internet = 2
         Else
             ErrorMsg(CboInternet)
             Exit Sub
         End If
 
         If CboNetwork.SelectedIndex = 0 Then
             My.Settings.Network = 1
         ElseIf CboNetwork.SelectedIndex = 1 Then
             My.Settings.Network = 2
         Else
             ErrorMsg(CboNetwork)
             Exit Sub
         End If
 
         If CboWinBackup.SelectedIndex = 0 Then
             My.Settings.WinBackup = 1
         ElseIf CboWinBackup.SelectedIndex = 1 Then
             My.Settings.WinBackup = 2
         Else
             ErrorMsg(CboWinBackup)
             Exit Sub
         End If
 
         If CboWirelessNet.SelectedIndex = 0 Then
             My.Settings.WirelessNet = 1
         ElseIf CboWirelessNet.SelectedIndex = 1 Then
             My.Settings.WirelessNet = 2
         Else
             ErrorMsg(CboWirelessNet)
             Exit Sub
         End If
 
         If CboMediaCntr.SelectedIndex = 0 Then
             My.Settings.MediaCntr = 1
         ElseIf CboMediaCntr.SelectedIndex = 1 Then
             My.Settings.MediaCntr = 2
         Else
             ErrorMsg(CboMediaCntr)
             Exit Sub
         End If
 
         My.Settings.Save()
         Call FrmMain.Check_Status()
         Me.DialogResult = Windows.Forms.DialogResult.OK
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmSrvcMngr.vb" startline="82" endline="167">
<![CDATA[
 
     Private Sub LstServices_SelectedIndexChanged(ByVal sender As Object, ByVal e As System.EventArgs) Handles LstServices.SelectedIndexChanged
 
         ServiceName = " "
 
         Dim I, Indx As Integer
         For I = 0 To LstServices.SelectedItems.Count - 1
             Indx = LstServices.SelectedItems(I).Index
             DisplayName = (LstServices.Items.Item(Indx).Text)
             ServiceName = (LstServices.Items.Item(Indx).SubItems.Item(1).Text)
             Index = Indx
         Next
 
         Try
             SrvcCntrl.ServiceName = (ServiceName)
 
             If SrvcCntrl.Status = ServiceProcess.ServiceControllerStatus.Running Then
                 BtnStart.Enabled = ComponentFactory.Krypton.Toolkit.ButtonEnabled.False
                 BtnStop.Enabled = ComponentFactory.Krypton.Toolkit.ButtonEnabled.True
                 ItmStart.Enabled = False
                 ItmStop.Enabled = True
             ElseIf SrvcCntrl.Status = ServiceProcess.ServiceControllerStatus.Stopped Then
                 BtnStart.Enabled = ComponentFactory.Krypton.Toolkit.ButtonEnabled.True
                 BtnStop.Enabled = ComponentFactory.Krypton.Toolkit.ButtonEnabled.False
                 ItmStart.Enabled = True
                 ItmStop.Enabled = False
             End If
 
             If Common.Service_Startup(ServiceName) = 2 Then
                 ItmAutomatic.Checked = True
                 ItmAutomatic.Enabled = False
                 ItmManual.Checked = False
                 ItmManual.Enabled = True
                 ItmDisabled.Checked = False
                 ItmDisabled.Enabled = True
             ElseIf Common.Service_Startup(ServiceName) = 3 Then
                 ItmAutomatic.Checked = False
                 ItmAutomatic.Enabled = True
                 ItmManual.Checked = True
                 ItmManual.Enabled = False
                 ItmDisabled.Checked = False
                 ItmDisabled.Enabled = True
             ElseIf Common.Service_Startup(ServiceName) = 4 Then
                 ItmAutomatic.Checked = False
                 ItmAutomatic.Enabled = True
                 ItmManual.Checked = False
                 ItmManual.Enabled = True
                 ItmDisabled.Checked = True
                 ItmDisabled.Enabled = False
             End If
 
             If My.Settings.ViewInfo = True Then
 
                 TxtInfo.Text = vbCrLf & "Description
 
                 Dim Dependencies As New ServiceProcess.ServiceController
                 Dependencies.ServiceName = (ServiceName)
 
                 Dim DependOn() As ServiceProcess.ServiceController = Dependencies.ServicesDependedOn
                 If DependOn.Length = 0 Then
                     TxtInfo.Text = TxtInfo.Text & "None"
                 Else
                     Dim II As Integer
                     For II = 0 To DependOn.Length - 1
                         TxtInfo.Text = TxtInfo.Text & DependOn(II).DisplayName & "; "
                     Next
                 End If
 
                 TxtInfo.Text = TxtInfo.Text & vbCrLf & vbCrLf & "System components depending on this service
 
                 Dim Dependent() As ServiceProcess.ServiceController = Dependencies.DependentServices
                 If Dependent.Length = 0 Then
                     TxtInfo.Text = TxtInfo.Text & "None"
                 Else
                     Dim III As Integer
                     For III = 0 To Dependent.Length - 1
                         TxtInfo.Text = TxtInfo.Text & Dependent(III).DisplayName & "; "
                     Next
                 End If
 
             End If
 
         Catch ex As InvalidOperationException
         End Try
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="662" endline="761">
<![CDATA[
 
 #End Region
 
 #Region "Tips"
 
     Private Sub SetTip()
 
         If Tip = 0 Then
             Try
                 PicTips.Image = New Bitmap(DataDir & "open_source.png")
             Catch ex As ArgumentException
                 PicTips.Image = Nothing
             End Try
             LblTips.Text = "Vista Services Optimizer is an open source software, you can use it for any purpose, change it to suit your needs and share the changes with the world."
             Tip = 1
 
         ElseIf Tip = 1 Then
             Try
                 PicTips.Image = New Bitmap(DataDir & "game_mode.png")
             Catch ex As ArgumentException
                 PicTips.Image = Nothing
             End Try
             LblTips.Text = "In Gaming Mode, unneeded Windows functions will be temporary turned off, this will make your system run faster and more reliable."
             Tip = 2
 
         ElseIf Tip = 2 Then
             Try
                 PicTips.Image = New Bitmap(DataDir & "rescue.png")
             Catch ex As ArgumentException
                 PicTips.Image = Nothing
             End Try
             LblTips.Text = "Automatic Snapshots automatically creates complete snapshots of Windows services settings, this will help restore Windows default settings in case of problems."
             Tip = 3
 
         ElseIf Tip = 3 Then
             Try
                 PicTips.Image = New Bitmap(DataDir & "toolbar.png")
             Catch ex As ArgumentException
                 PicTips.Image = Nothing
             End Try
             LblTips.Text = "You can launch Vista Services Optimizer directly form your favorite web browser using Smart PC Utilities toolbar."
             Tip = 4
 
         ElseIf Tip = 4 Then
             Try
                 PicTips.Image = New Bitmap(DataDir & "services_profiles.png")
             Catch ex As ArgumentException
                 PicTips.Image = Nothing
             End Try
             LblTips.Text = "Services Profiles can store and apply your different Windows services settings, this will save you a lot of time when dealing with multiple computers or users."
             Tip = 5
 
         ElseIf Tip = 5 Then
             Try
                 PicTips.Image = New Bitmap(DataDir & "search_web.png")
             Catch ex As ArgumentException
                 PicTips.Image = Nothing
             End Try
             LblTips.Text = "You can use Google, Yahoo, Bing and Blackviper.com to get information about Windows services, this will help you determine which Windows service you need and which you do not."
             Tip = 6
 
         ElseIf Tip = 6 Then
             Try
                 PicTips.Image = New Bitmap(DataDir & "auto_update.png")
             Catch ex As ArgumentException
                 PicTips.Image = Nothing
             End Try
             LblTips.Text = "Turning on Automatic Update will ensure that Vista Services Optimizer is always up-to-date by downloading and installing the latest available updates automatically."
             Tip = 7
 
         ElseIf Tip = 7 Then
             Try
                 PicTips.Image = New Bitmap(DataDir & "user_profile.png")
             Catch ex As ArgumentException
                 PicTips.Image = Nothing
             End Try
             LblTips.Text = "You should setup your user profile in the way that is suitable for you, as this will affect the behavior of Services Diagnostics and Automatic TuneUp features."
             Tip = 8
 
         ElseIf Tip = 8 Then
             Try
                 PicTips.Image = New Bitmap(DataDir & "manual_tuneup.png")
             Catch ex As ArgumentException
                 PicTips.Image = Nothing
             End Try
             LblTips.Text = "For experienced persons who are familiar with Windows services and their functions, they can use Manual TuneUp and Services Manager which will give them more control."
             Tip = 9
 
         ElseIf Tip = 9 Then
             Try
                 PicTips.Image = New Bitmap(DataDir & "contribute.png")
             Catch ex As ArgumentException
                 PicTips.Image = Nothing
             End Try
             LblTips.Text = "If you like Vista Services Optimizer, you can help us to make it better by donations, testing, developing or recommending it to your friends."
             Tip = 0
 
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmManual.vb" startline="11" endline="17">
<![CDATA[
     Private Sub FrmOptions_Load(ByVal sender As Object, ByVal e As System.EventArgs) Handles Me.Load
         Try
             HdrMain.Values.Image = New Bitmap(DataDir & "options.png")
             BtnUserProfile.Image = New Bitmap(DataDir & "usr_profile.png")
         Catch ex As ArgumentException
         End Try
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\DelegateDeclaration.vb" startline="56" endline="164">
<![CDATA[
 
     Function CreateDelegateMembers() As Boolean
         Dim result As Boolean = True
         Dim ReturnType As TypeName
         Dim Parameters As ParameterList = m_Signature.Parameters
 
         If m_ImplicitElementsCreated Then Return True
         m_ImplicitElementsCreated = True
 
         Helper.Assert(Me.Members.Count = 0)
 
         If TypeOf m_Signature Is FunctionSignature Then
             ReturnType = DirectCast(m_Signature, FunctionSignature).TypeName
             If ReturnType Is Nothing Then ReturnType = New TypeName(Me, Compiler.TypeCache.System_Object)
         Else
             ReturnType = Nothing
         End If
 
         'Create the constructor
         m_Constructor = New ConstructorDeclaration(Me)
         m_Constructor.Init(Nothing)
         m_Constructor.Signature.Parameters.Add("TargetObject", Compiler.TypeCache.System_Object)
         m_Constructor.Signature.Parameters.Add("TargetMethod", Compiler.TypeCache.System_IntPtr)
         result = m_Constructor.CreateDefinition() AndAlso result
 
         m_Constructor.MethodAttributes = Mono.Cecil.MethodAttributes.Public Or Mono.Cecil.MethodAttributes.SpecialName Or Mono.Cecil.MethodAttributes.RTSpecialName
         m_Constructor.MethodImplAttributes = Mono.Cecil.MethodImplAttributes.Runtime
 
         Members.Add(m_Constructor)
 
         Dim paramCount As Integer
         If Parameters IsNot Nothing Then paramCount = Parameters.Count
 
         Dim invokeParameters As ParameterList
         Dim beginInvokeParameters As ParameterList
         Dim endInvokeParameters As ParameterList
 
         Dim invokeSignature As SubSignature
         Dim beginInvokeSignature As FunctionSignature
         Dim endInvokeSignature As SubSignature
 
         'Invoke takes same types as delegate, and same return type
         'BeginInvoke takes same types as delegate + AsyncCallback + Object, and return type is IAsyncResult
         'EndInvoke takes byref types of delegate + IAsyncResult, and same return type
 
         If ReturnType Is Nothing Then
             m_Invoke = New SubDeclaration(Me)
             m_EndInvoke = New SubDeclaration(Me)
         Else
             m_Invoke = New FunctionDeclaration(Me)
             m_EndInvoke = New FunctionDeclaration(Me)
         End If
         m_BeginInvoke = New FunctionDeclaration(Me)
 
         invokeParameters = New ParameterList(m_Invoke)
         beginInvokeParameters = New ParameterList(m_BeginInvoke)
         endInvokeParameters = New ParameterList(m_EndInvoke)
 
         For i As Integer = 0 To paramCount - 1
             invokeParameters.Add(Parameters(i).Clone(invokeParameters))
             beginInvokeParameters.Add(Parameters(i).Clone(beginInvokeParameters))
             If Parameters(i).Modifiers.Is(ModifierMasks.ByRef) Then
                 endInvokeParameters.Add(Parameters(i).Clone(endInvokeParameters))
             End If
         Next
         beginInvokeParameters.Add(New Parameter(beginInvokeParameters, "DelegateCallback", Compiler.TypeCache.System_AsyncCallback))
         beginInvokeParameters.Add(New Parameter(beginInvokeParameters, "DelegateAsyncState", Compiler.TypeCache.System_Object))
         endInvokeParameters.Add(New Parameter(endInvokeParameters, "DelegateAsyncResult", Compiler.TypeCache.System_IAsyncResult))
 
         If ReturnType Is Nothing Then
             invokeSignature = New SubSignature(m_Invoke, STR_Invoke, invokeParameters)
             endInvokeSignature = New SubSignature(m_EndInvoke, STR_EndInvoke, endInvokeParameters)
         Else
             invokeSignature = New FunctionSignature(m_Invoke)
             DirectCast(invokeSignature, FunctionSignature).Init(STR_Invoke, Nothing, invokeParameters, Nothing, ReturnType, Me.Location)
             endInvokeSignature = New FunctionSignature(m_EndInvoke)
             DirectCast(endInvokeSignature, FunctionSignature).Init(STR_EndInvoke, Nothing, endInvokeParameters, Nothing, ReturnType, Me.Location)
         End If
         beginInvokeSignature = New FunctionSignature(m_BeginInvoke, STR_BeginInvoke, beginInvokeParameters, Compiler.TypeCache.System_IAsyncResult, Me.Location)
 
         m_Invoke.Init(New Modifiers(), invokeSignature, Nothing, Nothing)
         result = m_Invoke.CreateDefinition AndAlso result
         m_BeginInvoke.Init(New Modifiers(), beginInvokeSignature, Nothing, Nothing)
         result = m_BeginInvoke.CreateDefinition AndAlso result
         m_EndInvoke.Init(New Modifiers(), endInvokeSignature, Nothing, Nothing)
         result = m_EndInvoke.CreateDefinition AndAlso result
 
         Dim attr As Mono.Cecil.MethodAttributes
         Dim implattr As Mono.Cecil.MethodImplAttributes = Mono.Cecil.MethodImplAttributes.Runtime
         attr = Mono.Cecil.MethodAttributes.Public Or Mono.Cecil.MethodAttributes.NewSlot Or Mono.Cecil.MethodAttributes.Virtual Or Mono.Cecil.MethodAttributes.CheckAccessOnOverride
 
         'If Me.DeclaringType IsNot Nothing AndAlso Me.DeclaringType.TypeDescriptor.IsInterface Then
         '    attr = attr Or MethodAttributes.CheckAccessOnOverride
         'End If
 
         m_Invoke.MethodAttributes = attr
         m_BeginInvoke.MethodAttributes = attr
         m_EndInvoke.MethodAttributes = attr
 
         m_Invoke.MethodImplAttributes = implattr
         m_BeginInvoke.MethodImplAttributes = implattr
         m_EndInvoke.MethodImplAttributes = implattr
 
         Members.Add(m_BeginInvoke)
         Members.Add(m_EndInvoke)
         Members.Add(m_Invoke)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\MainForm.cs" startline="67" endline="202">
<![CDATA[
 
 		#region Windows Form Designer generated code
 		/// <summary>
 		/// Required method for Designer support - do not modify
 		/// the contents of this method with the code editor.
 		/// </summary>
 		private void InitializeComponent()
 		{
             this.components = new System.ComponentModel.Container();
             System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainForm));
             this.keyFobView = new System.Windows.Forms.ListView();
             this.columnHeader1 = new System.Windows.Forms.ColumnHeader();
             this.columnHeader2 = new System.Windows.Forms.ColumnHeader();
             this.columnHeader3 = new System.Windows.Forms.ColumnHeader();
             this.DoneButton = new System.Windows.Forms.Button();
             this.numericUpDown1 = new System.Windows.Forms.NumericUpDown();
             this.label1 = new System.Windows.Forms.Label();
             this.pluginListView = new System.Windows.Forms.ListView();
             this.columnHeader7 = new System.Windows.Forms.ColumnHeader();
             this.notifyIcon = new System.Windows.Forms.NotifyIcon(this.components);
             this.columnHeader4 = new System.Windows.Forms.ColumnHeader();
             ((System.ComponentModel.ISupportInitialize)(this.numericUpDown1)).BeginInit();
             this.SuspendLayout();
             // 
             // keyFobView
             // 
             this.keyFobView.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
             this.columnHeader1,
             this.columnHeader2,
             this.columnHeader3});
             this.keyFobView.FullRowSelect = true;
             this.keyFobView.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.Nonclickable;
             this.keyFobView.Location = new System.Drawing.Point(13, 12);
             this.keyFobView.Name = "keyFobView";
             this.keyFobView.Size = new System.Drawing.Size(330, 123);
             this.keyFobView.TabIndex = 0;
             this.keyFobView.View = System.Windows.Forms.View.Details;
             // 
             // columnHeader1
             // 
             this.columnHeader1.Text = "KeyFob Id";
             this.columnHeader1.Width = 70;
             // 
             // columnHeader2
             // 
             this.columnHeader2.Text = "Presence";
             this.columnHeader2.Width = 121;
             // 
             // columnHeader3
             // 
             this.columnHeader3.Text = "Security Status";
             this.columnHeader3.Width = 135;
             // 
             // DoneButton
             // 
             this.DoneButton.AccessibleDescription = "Closes this Form";
             this.DoneButton.AccessibleName = "Done";
             this.DoneButton.DialogResult = System.Windows.Forms.DialogResult.OK;
             this.DoneButton.FlatStyle = System.Windows.Forms.FlatStyle.Popup;
             this.DoneButton.Location = new System.Drawing.Point(268, 360);
             this.DoneButton.Name = "DoneButton";
             this.DoneButton.Size = new System.Drawing.Size(75, 23);
             this.DoneButton.TabIndex = 4;
             this.DoneButton.Text = "&Done";
             this.DoneButton.Click += new System.EventHandler(this.DoneButton_Click);
             // 
             // numericUpDown1
             // 
             this.numericUpDown1.Location = new System.Drawing.Point(108, 146);
             this.numericUpDown1.Name = "numericUpDown1";
             this.numericUpDown1.Size = new System.Drawing.Size(40, 20);
             this.numericUpDown1.TabIndex = 2;
             // 
             // label1
             // 
             this.label1.AutoSize = true;
             this.label1.Location = new System.Drawing.Point(12, 148);
             this.label1.Name = "label1";
             this.label1.Size = new System.Drawing.Size(90, 13);
             this.label1.TabIndex = 1;
             this.label1.Text = "Presence Window";
             this.label1.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
             // 
             // pluginListView
             // 
             this.pluginListView.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
             this.columnHeader7,
             this.columnHeader4});
             this.pluginListView.FullRowSelect = true;
             this.pluginListView.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.Nonclickable;
             this.pluginListView.Location = new System.Drawing.Point(13, 176);
             this.pluginListView.Name = "pluginListView";
             this.pluginListView.Size = new System.Drawing.Size(330, 178);
             this.pluginListView.TabIndex = 3;
             this.pluginListView.View = System.Windows.Forms.View.Details;
             // 
             // columnHeader7
             // 
             this.columnHeader7.Text = "Plugin Name";
             this.columnHeader7.Width = 250;
             // 
             // notifyIcon
             // 
             this.notifyIcon.Icon = ((System.Drawing.Icon)(resources.GetObject("notifyIcon.Icon")));
             this.notifyIcon.Text = "notifyIcon";
             this.notifyIcon.Visible = true;
             // 
             // columnHeader4
             // 
             this.columnHeader4.Text = "Enabled";
             this.columnHeader4.Width = 68;
             // 
             // MainForm
             // 
             this.ClientSize = new System.Drawing.Size(355, 392);
             this.ControlBox = false;
             this.Controls.Add(this.pluginListView);
             this.Controls.Add(this.label1);
             this.Controls.Add(this.numericUpDown1);
             this.Controls.Add(this.DoneButton);
             this.Controls.Add(this.keyFobView);
             this.MaximizeBox = false;
             this.MinimizeBox = false;
             this.Name = "MainForm";
             this.ShowInTaskbar = false;
             this.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide;
             this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
             this.Text = "USB Wireless Security";
             this.TopMost = true;
             this.WindowState = System.Windows.Forms.FormWindowState.Minimized;
             this.Load += new System.EventHandler(this.Form1_Load);
             ((System.ComponentModel.ISupportInitialize)(this.numericUpDown1)).EndInit();
             this.ResumeLayout(false);
             this.PerformLayout();
 
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="526" endline="599">
<![CDATA[
 
 #End Region
 
 #Region "Program Status"
 
     Protected Friend Sub Check_Status()
 
         On Error Resume Next
 
         Dim Ok_Status As New Bitmap(DataDir & "ok_status.png")
         Dim Info_Status As New Bitmap(DataDir & "info_status.png")
         Dim Warning_Status As New Bitmap(DataDir & "warning_status.png")
         Dim Critical_Status As New Bitmap(DataDir & "critical_status.png")
 
         If User_Profile() = True Then
             If GameMode() = False Then
                 BWDiagnostics.RunWorkerAsync()
             ElseIf GameMode() = True Then
                 BtnDiagnostics.Values.Image = Info_Status
                 ToolTip.SetToolTip(BtnDiagnostics, "Run Services Diagnostics")
                 LblDiagnostics_Status.ForeColor = Color.Orange
                 LblDiagnostics_Status.Text = "turned off"
             End If
         ElseIf User_Profile() = False Then
             BtnDiagnostics.Values.Image = Warning_Status
             ToolTip.SetToolTip(BtnDiagnostics, "Setup your user profile")
             LblDiagnostics_Status.ForeColor = Color.Orange
             LblDiagnostics_Status.Text = "not configured"
         End If
 
         If GameMode() = True Then
             BtnGameMode.Values.Image = Ok_Status
             ToolTip.SetToolTip(BtnGameMode, "Turn off Gaming Mode")
             LblGameMode_Status.ForeColor = Color.RoyalBlue
             LblGameMode_Status.Text = "turned on"
         ElseIf GameMode() = False Then
             If CheckGMProfile() = False Then
                 BtnGameMode.Values.Image = Warning_Status
                 ToolTip.SetToolTip(BtnGameMode, "Setup your Gaming Mode profile")
                 LblGameMode_Status.ForeColor = Color.Orange
                 LblGameMode_Status.Text = "not configured"
             ElseIf CheckGMProfile() = True Then
                 BtnGameMode.Values.Image = Info_Status
                 ToolTip.SetToolTip(BtnGameMode, "Turn on Gaming Mode")
                 LblGameMode_Status.ForeColor = Color.Orange
                 LblGameMode_Status.Text = "turned off"
             End If
         End If
 
         If My.Settings.Snapshots = True Then
             BtnSnapshots.Values.Image = Ok_Status
             ToolTip.SetToolTip(BtnSnapshots, "Turn off Automatic Snapshots")
             LblSnapshots_Status.ForeColor = Color.RoyalBlue
             LblSnapshots_Status.Text = "turned on"
         ElseIf My.Settings.Snapshots = False Then
             BtnSnapshots.Values.Image = Critical_Status
             ToolTip.SetToolTip(BtnSnapshots, "Turn on Automatic Snapshots")
             LblSnapshots_Status.ForeColor = Color.Red
             LblSnapshots_Status.Text = "turned off"
         End If
 
         If My.Settings.AutoUpdate = True Then
             BtnAutoUpdate.Values.Image = Ok_Status
             ToolTip.SetToolTip(BtnAutoUpdate, "Turn off Automatic Update")
             LblAutoUpdate_Status.ForeColor = Color.RoyalBlue
             LblAutoUpdate_Status.Text = "turned on"
         ElseIf My.Settings.AutoUpdate = False Then
             BtnAutoUpdate.Values.Image = Warning_Status
             ToolTip.SetToolTip(BtnAutoUpdate, "Turn on Automatic Update")
             LblAutoUpdate_Status.ForeColor = Color.Orange
             LblAutoUpdate_Status.Text = "turned off"
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Index.vb" startline="89" endline="95">
<![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub New(ByVal strMsg As String)
         MyBase.new()
         m_Message = "There has been an internal error in the compiler
         StopOnInternalException()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Index.vb" startline="39" endline="49">
<![CDATA[
 
     <Diagnostics.DebuggerHidden()> _
     Sub New(ByVal Location As Span)
         MyBase.new()
         'If Location IsNot Nothing Then
         m_Message = "There has been an internal error in the compiler caused by the line
         'Else
         'm_Message = "There has been an internal error in the compiler."
         'End If
         StopOnInternalException()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmProfiles.vb" startline="11" endline="31">
<![CDATA[
     Private Sub FrmSplash_Load(ByVal sender As Object, ByVal e As System.EventArgs) Handles Me.Load
 
         Try
             If My.Application.CommandLineArgs(0).ToString = "/DOAUTOTUNEUP" OrElse _
             My.Application.CommandLineArgs(0).ToString = "/DOGAMEMODE" OrElse _
             My.Application.CommandLineArgs(0).ToString = "/USERPROFILE" OrElse _
             Path.GetExtension(My.Application.CommandLineArgs(0).ToString.ToLower) = ".wsp" Then
                 Me.Opacity = 0
                 Exit Sub
             End If
         Catch ex As ArgumentOutOfRangeException
         End Try
 
         Try
             Me.BackgroundImage = New Bitmap(DataDir & "splash.jpg")
         Catch ex As ArgumentException
         End Try
 
         LblVersion.Text = "Version
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\dshowUtil.vb" startline="25" endline="140">
<![CDATA[
 
     'Required by the Windows Form Designer
     Private components As System.ComponentModel.IContainer
 
     'NOTE
     'It can be modified using the Windows Form Designer.  
     'Do not modify it using the code editor.
     Friend WithEvents LinkLabel1 As System.Windows.Forms.LinkLabel
     Friend WithEvents Label1 As System.Windows.Forms.Label
     Friend WithEvents Label2 As System.Windows.Forms.Label
     Friend WithEvents Label3 As System.Windows.Forms.Label
     Friend WithEvents tAck As System.Windows.Forms.TextBox
     Friend WithEvents chkRemind As System.Windows.Forms.CheckBox
     Friend WithEvents Label4 As System.Windows.Forms.Label
     <System.Diagnostics.DebuggerStepThrough()> Private Sub InitializeComponent()
         Me.LinkLabel1 = New System.Windows.Forms.LinkLabel
         Me.Label1 = New System.Windows.Forms.Label
         Me.Label2 = New System.Windows.Forms.Label
         Me.Label3 = New System.Windows.Forms.Label
         Me.tAck = New System.Windows.Forms.TextBox
         Me.chkRemind = New System.Windows.Forms.CheckBox
         Me.Label4 = New System.Windows.Forms.Label
         Me.SuspendLayout()
         '
         'LinkLabel1
         '
         Me.LinkLabel1.Location = New System.Drawing.Point(40, 322)
         Me.LinkLabel1.Name = "LinkLabel1"
         Me.LinkLabel1.Size = New System.Drawing.Size(288, 24)
         Me.LinkLabel1.TabIndex = 0
         Me.LinkLabel1.TabStop = True
         Me.LinkLabel1.Text = "Movica Homepage - Suggestions and Help"
         Me.LinkLabel1.TextAlign = System.Drawing.ContentAlignment.MiddleCenter
         '
         'Label1
         '
         Me.Label1.Font = New System.Drawing.Font("Verdana", 30.0!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.Label1.Location = New System.Drawing.Point(104, 0)
         Me.Label1.Name = "Label1"
         Me.Label1.Size = New System.Drawing.Size(163, 48)
         Me.Label1.TabIndex = 1
         Me.Label1.Text = "Movica"
         '
         'Label2
         '
         Me.Label2.Location = New System.Drawing.Point(24, 62)
         Me.Label2.Name = "Label2"
         Me.Label2.Size = New System.Drawing.Size(312, 40)
         Me.Label2.TabIndex = 2
         Me.Label2.Text = "A simple utility to edit .wmv, .wma, .mpeg and .flv movies using AsfBin, MpgTx an" & _
             "d flvtool"
         Me.Label2.TextAlign = System.Drawing.ContentAlignment.MiddleCenter
         '
         'Label3
         '
         Me.Label3.ForeColor = System.Drawing.Color.Gray
         Me.Label3.Location = New System.Drawing.Point(128, 47)
         Me.Label3.Name = "Label3"
         Me.Label3.Size = New System.Drawing.Size(100, 16)
         Me.Label3.TabIndex = 3
         Me.Label3.Text = "Label3"
         Me.Label3.TextAlign = System.Drawing.ContentAlignment.MiddleCenter
         '
         'tAck
         '
         Me.tAck.BorderStyle = System.Windows.Forms.BorderStyle.None
         Me.tAck.ForeColor = System.Drawing.SystemColors.GrayText
         Me.tAck.Location = New System.Drawing.Point(27, 104)
         Me.tAck.Multiline = True
         Me.tAck.Name = "tAck"
         Me.tAck.ScrollBars = System.Windows.Forms.ScrollBars.Vertical
         Me.tAck.Size = New System.Drawing.Size(309, 196)
         Me.tAck.TabIndex = 4
         Me.tAck.Text = "Acknowledgements"
         Me.tAck.TextAlign = System.Windows.Forms.HorizontalAlignment.Center
         '
         'chkRemind
         '
         Me.chkRemind.Location = New System.Drawing.Point(88, 306)
         Me.chkRemind.Name = "chkRemind"
         Me.chkRemind.Size = New System.Drawing.Size(200, 16)
         Me.chkRemind.TabIndex = 5
         Me.chkRemind.Text = "Don't remind me about this version"
         Me.chkRemind.Visible = False
         '
         'Label4
         '
         Me.Label4.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle
         Me.Label4.Location = New System.Drawing.Point(336, 8)
         Me.Label4.Name = "Label4"
         Me.Label4.Size = New System.Drawing.Size(16, 16)
         Me.Label4.TabIndex = 6
         Me.Label4.Text = "X"
         Me.Label4.TextAlign = System.Drawing.ContentAlignment.MiddleCenter
         '
         'frmAbout
         '
         Me.AutoScaleBaseSize = New System.Drawing.Size(5, 13)
         Me.BackColor = System.Drawing.Color.White
         Me.ClientSize = New System.Drawing.Size(362, 351)
         Me.ControlBox = False
         Me.Controls.Add(Me.Label4)
         Me.Controls.Add(Me.chkRemind)
         Me.Controls.Add(Me.tAck)
         Me.Controls.Add(Me.Label3)
         Me.Controls.Add(Me.Label2)
         Me.Controls.Add(Me.Label1)
         Me.Controls.Add(Me.LinkLabel1)
         Me.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog
         Me.KeyPreview = True
         Me.Name = "frmAbout"
         Me.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen
         Me.ResumeLayout(False)
         Me.PerformLayout()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Modules\Common.vb" startline="176" endline="186">
<![CDATA[
 
     Friend Function GameMode() As Boolean
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer", "GameMode", 0) = 1 OrElse _
         My.Computer.Registry.GetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Blue Shield", "GameMode", 0) = 1 Then
             GameMode = True
         Else
             GameMode = False
         End If
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmManual.vb" startline="46" endline="128">
<![CDATA[
 
 #End Region
 
 #Region "Read Settings"
 
     Private Sub FrmOptions_Shown(ByVal sender As Object, ByVal e As System.EventArgs) Handles Me.Shown
 
         If My.Settings.AutoUpdate = True Then
             ChkAutoUpdate.Checked = True
         ElseIf My.Settings.AutoUpdate = False Then
             ChkAutoUpdate.Checked = False
         End If
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run", "Vista Services Optimizer", "") = ("""" & Application.StartupPath & "\QuickControl.exe" & """") Then
             ChkAutoStart.Checked = True
         Else
             ChkAutoStart.Checked = False
         End If
 
         If My.Settings.Snapshots = True Then
             ChkSnapshots.Checked = True
         ElseIf My.Settings.Snapshots = False Then
             ChkSnapshots.Checked = False
         End If
 
         If My.Computer.Registry.GetValue("HKEY_CURRENT_USER\Software\Smart PC Utilities\Services Optimizer", "Time", "") = "2" Then
             ChkDelSnapshots.Checked = True
             CboTime.SelectedIndex = 0
         ElseIf My.Computer.Registry.GetValue("HKEY_CURRENT_USER\Software\Smart PC Utilities\Services Optimizer", "Time", "") = "3" Then
             ChkDelSnapshots.Checked = True
             CboTime.SelectedIndex = 1
         ElseIf My.Computer.Registry.GetValue("HKEY_CURRENT_USER\Software\Smart PC Utilities\Services Optimizer", "Time", "") = "4" Then
             ChkDelSnapshots.Checked = True
             CboTime.SelectedIndex = 2
         ElseIf My.Computer.Registry.GetValue("HKEY_CURRENT_USER\Software\Smart PC Utilities\Services Optimizer", "Time", "") = "7" Then
             ChkDelSnapshots.Checked = True
             CboTime.SelectedIndex = 3
         ElseIf My.Computer.Registry.GetValue("HKEY_CURRENT_USER\Software\Smart PC Utilities\Services Optimizer", "Time", "") = "14" Then
             ChkDelSnapshots.Checked = True
             CboTime.SelectedIndex = 4
         ElseIf My.Computer.Registry.GetValue("HKEY_CURRENT_USER\Software\Smart PC Utilities\Services Optimizer", "Time", "") = "30" Then
             ChkDelSnapshots.Checked = True
             CboTime.SelectedIndex = 5
         ElseIf My.Computer.Registry.GetValue("HKEY_CURRENT_USER\Software\Smart PC Utilities\Services Optimizer", "Time", "") = "60" Then
             ChkDelSnapshots.Checked = True
             CboTime.SelectedIndex = 6
         ElseIf My.Computer.Registry.GetValue("HKEY_CURRENT_USER\Software\Smart PC Utilities\Services Optimizer", "Time", "") = "90" Then
             ChkDelSnapshots.Checked = True
             CboTime.SelectedIndex = 7
         Else
             ChkDelSnapshots.Checked = False
         End If
 
         If My.Settings.ViewInfo = True Then
             ChkViewInfo.Checked = True
         ElseIf My.Settings.ViewInfo = False Then
             ChkViewInfo.Checked = False
         End If
 
         If My.Settings.BlackViper = True Then
             ChkBlackViper.Checked = True
         ElseIf My.Settings.BlackViper = False Then
             ChkBlackViper.Checked = False
         End If
 
         If My.Settings.QueryNet = 0 Then
             ChkQueryNet.Checked = False
         ElseIf My.Settings.QueryNet = 1 Then
             ChkQueryNet.Checked = True
             CboQueryNet.SelectedIndex = 0
         ElseIf My.Settings.QueryNet = 2 Then
             ChkQueryNet.Checked = True
             CboQueryNet.SelectedIndex = 1
         ElseIf My.Settings.QueryNet = 3 Then
             ChkQueryNet.Checked = True
             CboQueryNet.SelectedIndex = 2
         End If
 
         TxtName.Text = ""
         TxtDescription.Text = ""
         BtnOK.Focus()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeConverter.vb" startline="370" endline="394">
<![CDATA[
 
     Shared Function GetErrorNumberForConversion(ByVal tp1 As TypeCode, ByVal tp2 As TypeCode, ByVal Implicit As Boolean) As Integer
         Select Case GetConversionResultType(tp1, tp2)
             Case "X"c
                 Throw New NotImplementedException
             Case "I"c
                 Return 0
             Case "0"c
                 Return 0
             Case "1"c
                 Return 30311
             Case "2"c
                 Return 32007
             Case "3"c
                 Return 30533
             Case "4"c
                 Return 32006
             Case "5"c
                 Return 30532
             Case "6"c
                 Return 30533
             Case Else
                 Throw New NotImplementedException
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="295" endline="407">
<![CDATA[
 
     Private Function GenerateUnstructuredEnd(ByVal Method As IMethod, ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
         Dim retvar As Mono.Cecil.Cil.VariableDefinition = Method.DefaultReturnVariable
 
         'Add a label to the end of the code as the last item in the switch.
 
         If retvar IsNot Nothing Then
             Emitter.EmitLeave(Info, Me.EndMethodLabel)
         Else
             Emitter.EmitLeave(Info, Me.EndMethodLabel)
         End If
 
         Me.UnstructuredExceptionLabels.Add(UnstructuredSwitchHandlerEnd)
 
         Dim tmpVar As Mono.Cecil.Cil.VariableDefinition = Emitter.DeclareLocal(Info, Compiler.TypeCache.System_Int32)
         If Me.HasResume Then
             'Increment the instruction pointer index with one, then jump to the switch
             Emitter.MarkLabel(Info, ResumeNextExceptionHandler)
             Emitter.EmitLoadI4Value(Info, -1)
             Emitter.EmitStoreVariable(Info, VB_ResumeTarget)
             Emitter.EmitLoadVariable(Info, VB_CurrentInstruction)
             Emitter.EmitLoadI4Value(Info, 1)
             Emitter.EmitAdd(Info, Compiler.TypeCache.System_Int32)
             Emitter.EmitStoreVariable(Info, tmpVar)
             Emitter.EmitLeave(Info, UnstructuredResumeHandler)
         End If
 
         'Emit the actual handler 
         Emitter.MarkLabel(Info, UnstructuredResumeNextHandler)
         Emitter.EmitLoadI4Value(Info, -1)
         Emitter.EmitStoreVariable(Info, VB_ActiveHandler)
         Emitter.EmitLoadVariable(Info, VB_ResumeTarget)
         Emitter.EmitStoreVariable(Info, tmpVar)
         Emitter.MarkLabel(Info, UnstructuredResumeHandler)
         Emitter.EmitLoadI4Value(Info, 0)
         Emitter.EmitStoreVariable(Info, VB_ResumeTarget)
         Emitter.EmitLoadVariable(Info, tmpVar)
         Emitter.EmitSwitch(Info, UnstructuredExceptionLabels.ToArray)
 
         Emitter.MarkLabel(Info, UnstructuredSwitchHandlerEnd)
         Emitter.EmitLeave(Info, EndMethodLabel)
 
         'Emit the handler selector
         Dim handlers() As Label = UnstructuredExceptionHandlers.ToArray
         Dim endHandlers As Label = Emitter.DefineLabel(Info)
         Dim removedLabel As Label = handlers(0)
         handlers(0) = endHandlers
         Emitter.MarkLabel(Info, VB_ActiveHandlerLabel)
 
         If VB_CurrentInstruction IsNot Nothing Then
             Emitter.EmitLoadVariable(Info, VB_CurrentInstruction)
             Emitter.EmitStoreVariable(Info, VB_ResumeTarget)
         End If
         Emitter.EmitLoadVariable(Info, VB_ActiveHandler)
         Emitter.EmitSwitch(Info, handlers)
         Emitter.EmitLeave(Info, EndMethodLabel)
         Emitter.MarkLabel(Info, endHandlers)
         Emitter.EmitLeave(Info, removedLabel)
 
         'Catch the exception
 
         'create a filter, only handle the exception if it is of type Exception, 
         'if it was not raised when in the unstructured handler and if there actually
         'is a registered exception handler.
         Info.ILGen.BeginExceptFilterBlock()
         Emitter.EmitIsInst(Info, Compiler.TypeCache.System_Object, Compiler.TypeCache.System_Exception)
         Emitter.EmitLoadNull(Info.Clone(Me, True, False, Compiler.TypeCache.System_Exception))
         Emitter.EmitGT_Un(Info, Compiler.TypeCache.System_Exception) 'TypeOf ... Is System.Exception
 
         Emitter.EmitLoadVariable(Info, Me.VB_ActiveHandler)
         Emitter.EmitLoadI4Value(Info, 0)
         Emitter.EmitGT(Info, Compiler.TypeCache.System_Int32) 'if a handler is registered.
         Emitter.EmitAnd(Info, Compiler.TypeCache.System_Boolean)
 
         Emitter.EmitLoadVariable(Info, Me.VB_ResumeTarget)
         Emitter.EmitLoadI4Value(Info, 0)
         Emitter.EmitEquals(Info, Compiler.TypeCache.System_Int32) 'if code is in a unstructured handler or not
         Emitter.EmitAnd(Info, Compiler.TypeCache.System_Boolean)
 
         'create the catch block
         Info.ILGen.BeginCatchBlock(CType(Nothing, Mono.Cecil.TypeReference))
         Emitter.EmitCastClass(Info, Compiler.TypeCache.System_Exception)
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__SetProjectError_Exception)
         Emitter.EmitLeave(Info, VB_ActiveHandlerLabel)
 
         Info.ILGen.EndExceptionBlock()
 
         'Create an internal exception if the code gets here.
         Emitter.MarkLabel(Info, m_InternalExceptionLocation)
         Emitter.EmitLoadI4Value(Info, -2146828237)
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__CreateProjectError_Int32)
         Emitter.EmitThrow(Info)
 
         Emitter.MarkLabel(Info, EndMethodLabel)
 
         Dim veryMethodEnd As Label = Emitter.DefineLabel(Info)
         Emitter.EmitLoadVariable(Info.Clone(Me, True, False, Compiler.TypeCache.System_Boolean), VB_ResumeTarget)
         Emitter.EmitBranchIfFalse(Info, veryMethodEnd)
         Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ProjectData__ClearProjectError)
         Emitter.MarkLabel(Info, veryMethodEnd)
 
         If retvar IsNot Nothing Then
             Emitter.MarkLabel(Info, m_EndOfMethodLabel.Value)
             Emitter.EmitLoadVariable(Info, retvar)
             Info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Ret)
         Else
             Emitter.MarkLabel(Info, m_EndOfMethodLabel.Value)
             Info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Ret)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeConverter.vb" startline="936" endline="1021">
<![CDATA[
 
     Public Shared Function ConvertToByte(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object, ByVal ShowErrors As Boolean) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CByte(i)
                 Return True
             Case TypeCode.Byte
                 result = Source
                 Return True
             Case TypeCode.Char
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, "Byte")
             Case TypeCode.DateTime
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", "Byte")
             Case TypeCode.Decimal
                 Dim i As Decimal = DirectCast(Source, Decimal)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.Double
                 Dim i As Double = DirectCast(Source, Double)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.Int16
                 Dim i As Short = DirectCast(Source, Short)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.Int32
                 Dim i As Integer = DirectCast(Source, Integer)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.Int64
                 Dim i As Long = DirectCast(Source, Long)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.SByte
                 Dim i As SByte = DirectCast(Source, SByte)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.Single
                 Dim i As Single = DirectCast(Source, Single)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.String
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Byte", "String")
             Case TypeCode.UInt16
                 Dim i As UShort = DirectCast(Source, UShort)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.UInt32
                 Dim i As UInteger = DirectCast(Source, UInteger)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.UInt64
                 Dim i As ULong = DirectCast(Source, ULong)
                 If i >= Byte.MinValue AndAlso i <= Byte.MaxValue Then
                     result = CByte(i)
                     Return True
                 End If
             Case TypeCode.DBNull
                 result = CByte(0)
                 Return True
         End Select
         If ShowErrors = False Then Return False
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "Byte")
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="56" endline="119">
<![CDATA[
     End Property
 
     Public Overrides Function GetConstant(ByRef m_ConstantValue As Object, ByVal lvalue As Object, ByVal rvalue As Object) As Boolean
         Dim tlvalue, trvalue As Mono.Cecil.TypeReference
         Dim clvalue, crvalue As TypeCode
 
         tlvalue = CecilHelper.GetType(Compiler, lvalue)
         clvalue = Helper.GetTypeCode(Compiler, tlvalue)
         trvalue = CecilHelper.GetType(Compiler, rvalue)
         crvalue = Helper.GetTypeCode(Compiler, trvalue)
 
         Dim csmallest As TypeCode
         csmallest = TypeConverter.GetRealDivResultType(clvalue, crvalue)
 
         If CDbl(rvalue) = 0 Then
             m_ConstantValue = Double.NaN
             Return False
         End If
 
         Select Case csmallest
             Case TypeCode.Byte
                 m_ConstantValue = CByte(lvalue) / CByte(rvalue)
             Case TypeCode.SByte
                 If CSByte(lvalue) = SByte.MinValue AndAlso CSByte(rvalue) = -1 Then
                     m_ConstantValue = CShort(lvalue) / CShort(rvalue)
                 Else
                     m_ConstantValue = CSByte(lvalue) / CSByte(rvalue)
                 End If
             Case TypeCode.Int16
                 If CShort(lvalue) = Short.MinValue AndAlso CShort(rvalue) = -1 Then
                     m_ConstantValue = CInt(lvalue) / CInt(rvalue)
                 Else
                     m_ConstantValue = CShort(lvalue) / CShort(rvalue)
                 End If
             Case TypeCode.UInt16
                 m_ConstantValue = CUShort(lvalue) / CUShort(rvalue)
             Case TypeCode.Int32
                 If CInt(lvalue) = Integer.MinValue AndAlso CInt(rvalue) = -1 Then
                     m_ConstantValue = CLng(lvalue) / CLng(rvalue)
                 Else
                     m_ConstantValue = CInt(lvalue) / CInt(rvalue)
                 End If
             Case TypeCode.UInt32
                 m_ConstantValue = CUInt(lvalue) / CUInt(rvalue)
             Case TypeCode.Int64
                 If CLng(lvalue) = Long.MinValue AndAlso CLng(rvalue) = -1 Then
                     m_ConstantValue = CDec(lvalue) / CDec(rvalue)
                 Else
                     m_ConstantValue = CLng(lvalue) / CLng(rvalue)
                 End If
             Case TypeCode.UInt64
                 m_ConstantValue = CULng(lvalue) / CULng(rvalue)
             Case TypeCode.Double
                 m_ConstantValue = CDbl(lvalue) / CDbl(rvalue)
             Case TypeCode.Single
                 m_ConstantValue = CSng(lvalue) / CSng(rvalue)
             Case TypeCode.Decimal
                 m_ConstantValue = CDec(lvalue) / CDec(rvalue)
             Case Else
                 Return False
         End Select
 
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="410" endline="526">
<![CDATA[
 
     Sub SelectLessGeneric()
         '
         'A member M is determined to be less generic than a member N as follows
         '1.	If, for each pair of matching parameters Mj and Nj, Mj is less or equally 
         '   generic than Nj with respect to type parameters on the method, and at least 
         '   one Mj is less generic with respect to type parameters on the method.
         '2.	Otherwise, if for each pair of matching parameters Mj and Nj, Mj is less or equally generic than Nj 
         '   with respect to type parameters on the type, and at least one Mj is less generic with respect to 
         '   type parameters on the type, then M is less generic than N.
         '
         'A parameter M is considered to be equally generic to a parameter N if their types Mt and Nt
         'both refer to type parameters or both don't refer to type parameters.
         'M is considered to be less generic than N if Mt does not refer to a type parameter and Nt does.
         '
 
         Dim gpType As Mono.Collections.Generic.Collection(Of GenericParameter) = Nothing
         Dim gp() As Mono.Collections.Generic.Collection(Of GenericParameter) = Nothing
 
         For i As Integer = 0 To m_Candidates.Count - 1
             If m_Candidates(i).IsRemoved("SelectLessGeneric") Then Continue For
 
             For j As Integer = i + 1 To m_Candidates.Count - 1
                 If m_Candidates(j).IsRemoved("SelectLessGeneric") Then Continue For
 
                 Dim candidateI As MemberCandidate = m_Candidates(i)
                 Dim candidateJ As MemberCandidate = m_Candidates(j)
                 Dim parametersI As Mono.Collections.Generic.Collection(Of ParameterDefinition) = Helper.GetOriginalParameters(candidateI.Member)
                 Dim parametersJ As Mono.Collections.Generic.Collection(Of ParameterDefinition) = Helper.GetOriginalParameters(candidateJ.Member)
                 Dim paramCount As Integer = Math.Min(parametersI.Count, parametersJ.Count)
                 Dim gpI As Mono.Collections.Generic.Collection(Of GenericParameter)
                 Dim gpJ As Mono.Collections.Generic.Collection(Of GenericParameter)
                 Dim timesLessGenericI As Integer
                 Dim timesLessGenericJ As Integer
 
                 'Not sure if the # of parameters can be different between I and J here
                 If paramCount = 0 Then Continue For
 
                 If gp Is Nothing Then ReDim gp(m_Candidates.Count - 1)
 
                 gpI = gp(i)
                 gpJ = gp(j)
 
                 If gpI Is Nothing Then
                     gp(i) = Helper.GetGenericParameters(candidateI.Member)
                     gpI = gp(i)
                 End If
                 If gpJ Is Nothing Then
                     gp(j) = Helper.GetGenericParameters(candidateJ.Member)
                     gpJ = gp(j)
                 End If
 
                 '1.	If, for each pair of matching parameters Mj and Nj, Mj is less or equally 
                 '   generic than Nj with respect to type parameters on the method, and at least 
                 '   one Mj is less generic with respect to type parameters on the method.
 
                 For p As Integer = 0 To paramCount - 1
                     Dim paramI As ParameterDefinition = parametersI(p)
                     Dim paramJ As ParameterDefinition = parametersJ(p)
                     Dim containsI As Boolean = ContainsGenericParameters(paramI.ParameterType, gpI)
                     Dim containsJ As Boolean = ContainsGenericParameters(paramJ.ParameterType, gpJ)
 
                     If containsI = False AndAlso containsJ = True Then
                         timesLessGenericI += 1
                     ElseIf containsI = True AndAlso containsJ = False Then
                         timesLessGenericJ += 1
                     End If
                 Next
 
                 If timesLessGenericI > 0 AndAlso timesLessGenericJ = 0 Then
                     Log("MORE METHOD GENERIC
                     m_Candidates(j).RemovedBy = "SelectLessGeneric"
                     Exit For
                 ElseIf timesLessGenericI = 0 AndAlso timesLessGenericJ > 0 Then
                     Log("MORE METHOD GENERIC
                     m_Candidates(i).RemovedBy = "SelectLessGeneric"
                     Exit For
                 End If
 
                 '2.	Otherwise, if for each pair of matching parameters Mj and Nj, Mj is less or equally generic than Nj 
                 '   with respect to type parameters on the type, and at least one Mj is less generic with respect to 
                 '   type parameters on the type, then M is less generic than N.
                 timesLessGenericI = 0
                 timesLessGenericJ = 0
 
                 If gpType Is Nothing Then
                     gpType = CecilHelper.FindDefinition(m_Candidates(i).Member.DeclaringType).GenericParameters
                 End If
 
                 'Not sure if the # of parameters can be different between I and J here
                 For p As Integer = 0 To paramCount - 1
                     Dim paramI As ParameterDefinition = parametersI(p)
                     Dim paramJ As ParameterDefinition = parametersJ(p)
                     Dim containsI As Boolean = ContainsGenericParameters(paramI.ParameterType, gpType)
                     Dim containsJ As Boolean = ContainsGenericParameters(paramJ.ParameterType, gpType)
 
                     If containsI = False AndAlso containsJ = True Then
                         timesLessGenericI += 1
                     ElseIf containsI = True AndAlso containsJ = False Then
                         timesLessGenericJ += 1
                     End If
                 Next
 
                 If timesLessGenericI > 0 AndAlso timesLessGenericJ = 0 Then
                     Log("MORE TYPE GENERIC
                     m_Candidates(j).RemovedBy = "SelectLessGeneric"
                     Exit For
                 ElseIf timesLessGenericI = 0 AndAlso timesLessGenericJ > 0 Then
                     Log("MORE TYPE GENERIC
                     m_Candidates(i).RemovedBy = "SelectLessGeneric"
                     Exit For
                 End If
 
                 Log("EQUALLY GENERIC
             Next
         Next
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MyGenerator.vb" startline="49" endline="155">
<![CDATA[
     End Property
 
     Function Generate() As Boolean
         Dim result As Boolean = True
         Dim _MyTypeDefine As Define
         Dim _MyType As String
 
         If String.IsNullOrEmpty(Compiler.CommandLine.VBRuntime) Then Return result
 
         _MyTypeDefine = Compiler.CommandLine.Define("_MYTYPE")
         If _MyTypeDefine Is Nothing Then
             _MyType = String.Empty
         Else
             _MyType = _MyTypeDefine.ValueAsString
         End If
 
         If _MyType = String.Empty Then
             m_MyType = MyTypes.Windows
         ElseIf [Enum].IsDefined(GetType(MyTypes), _MyType) Then
             m_MyType = CType([Enum].Parse(GetType(MyTypes), _MyType, False), MyTypes)
         Else
             m_MyType = MyTypes.Empty
         End If
 
         If m_MyType = MyTypes.Empty Then
             Return True
         End If
 
         If Compiler.CommandLine.RootNamespace <> "" Then
             m_GlobalMy = "Global." & Compiler.CommandLine.RootNamespace & ".My"
         Else
             m_GlobalMy = "Global" & ".My"
         End If
 
         result = GenerateMyApplication() AndAlso result
         result = GenerateMyComputer() AndAlso result
         result = GenerateMyForms() AndAlso result
         result = GenerateMyLog() AndAlso result
         result = GenerateMyRequest() AndAlso result
         result = GenerateMyResources() AndAlso result
         result = GenerateMyResponse() AndAlso result
         result = GenerateMySettings() AndAlso result
         result = GenerateMyUser() AndAlso result
         result = GenerateMyWebServices() AndAlso result
 
         If Code.Length > 0 OrElse m_MyType = MyTypes.Custom Then
             Dim projectPrepend As New System.Text.StringBuilder()
             projectPrepend.AppendLine("    <Global.System.CodeDom.Compiler.GeneratedCode(""MyTemplate"", ""10.0.0.0"")> _")
             projectPrepend.AppendLine("    <Global.Microsoft.VisualBasic.HideModuleName> _")
             projectPrepend.AppendLine("    Friend Module MyProject")
             projectPrepend.AppendLine("        <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _")
             projectPrepend.AppendLine("        <Global.System.Runtime.InteropServices.ComVisible(False)> _")
             projectPrepend.AppendLine("        Friend NotInheritable Class ThreadSafeObjectProvider(Of T As New)")
             projectPrepend.AppendLine("            ")
             projectPrepend.AppendLine("            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _")
             projectPrepend.AppendLine("            <Global.System.Diagnostics.DebuggerHidden> _")
             projectPrepend.AppendLine("            Public Sub New()")
             projectPrepend.AppendLine("            End Sub")
             projectPrepend.AppendLine("            ")
             If Compiler.CommandLine.Target = CommandLine.Targets.Library Then
                 projectPrepend.AppendLine("            Private ReadOnly m_Context As New Global.Microsoft.VisualBasic.MyServices.Internal.ContextValue(Of T)")
                 projectPrepend.AppendLine("            Friend ReadOnly Property GetInstance As T")
                 projectPrepend.AppendLine("                Get")
                 projectPrepend.AppendLine("                    Dim tmp as T = m_Context.Value")
                 projectPrepend.AppendLine("                    If tmp Is Nothing Then")
                 projectPrepend.AppendLine("                        tmp = Global.System.Activator.CreateInstance(Of T)")
                 projectPrepend.AppendLine("                        m_Context.Value = tmp")
                 projectPrepend.AppendLine("                    End If")
                 projectPrepend.AppendLine("                    Return tmp")
                 projectPrepend.AppendLine("                End Get")
                 projectPrepend.AppendLine("            End Property")
             Else
                 projectPrepend.AppendLine("            <Global.System.Runtime.CompilerServices.CompilerGenerated> _")
                 projectPrepend.AppendLine("            <Global.System.ThreadStatic> _")
                 projectPrepend.AppendLine("            Private Shared m_ThreadStaticValue As T")
                 projectPrepend.AppendLine("            ")
                 projectPrepend.AppendLine("            Friend ReadOnly Property GetInstance As T")
                 projectPrepend.AppendLine("                Get")
                 projectPrepend.AppendLine("                    If (m_ThreadStaticValue Is Nothing) Then")
                 projectPrepend.AppendLine("                        m_ThreadStaticValue = Global.System.Activator.CreateInstance(Of T)")
                 projectPrepend.AppendLine("                    End If")
                 projectPrepend.AppendLine("                    Return m_ThreadStaticValue")
                 projectPrepend.AppendLine("                End Get")
                 projectPrepend.AppendLine("            End Property")
             End If
             projectPrepend.AppendLine("        End Class")
             ProjectCode.Insert(0, projectPrepend)
             ProjectCode.AppendLine("    End Module")
 
             Code.Insert(0, "Namespace My" & Environment.NewLine)
             Code.Insert(0, "    Imports System" & Environment.NewLine)
             Code.Append(ProjectCode)
             Code.AppendLine("End Namespace")
 
             Code.Replace("$GLOBALMY$", m_GlobalMy)
 
 #If DEBUG AndAlso False Then
             Dim counter As Integer = 1
             For Each line As String In VB.Split(Code.ToString, VB.vbNewLine)
                 Compiler.Report.WriteLine(counter & "
                 counter += 1
             Next
 #End If
             Compiler.CommandLine.Files.Add(New CodeFile("<MyGenerator>", "<MyGenerator>", Compiler, Code.ToString))
         End If
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" startline="578" endline="651">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_ResolvedDestinationType Is Nothing Then
             result = m_DestinationType.ResolveTypeReferences AndAlso result
             m_ResolvedDestinationType = m_DestinationType.ResolvedType
         End If
 
         result = MyBase.ResolveExpressionInternal(Info) AndAlso result
 
         If m_ConversionType <> CTypeConversionType.Undetermined Then Return result
 
         Select Case Helper.GetTypeCode(Compiler, Me.ExpressionType)
             Case TypeCode.Boolean
                 result = CBoolExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.Byte
                 result = CByteExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.Char
                 result = CCharExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.DateTime
                 result = CDateExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.Decimal
                 result = CDecExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.Double
                 result = CDblExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.Int16
                 result = CShortExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.Int32
                 result = CIntExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.Int64
                 result = CLngExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.SByte
                 result = CSByteExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.Single
                 result = CSngExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.String
                 result = CStrExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.UInt16
                 result = CUShortExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.UInt32
                 result = CUIntExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.UInt64
                 result = CULngExpression.Validate(Info, Me) AndAlso result
             Case TypeCode.Object, TypeCode.DBNull
                 If Helper.CompareType(Me.ExpressionType, Compiler.TypeCache.System_Object) Then
                     result = CObjExpression.Validate(Info, Expression) AndAlso result
                 ElseIf Helper.CompareType(Me.ExpressionType, Compiler.TypeCache.System_Char_Array) AndAlso Helper.CompareType(Expression.ExpressionType, Compiler.TypeCache.System_String) Then
                     If Location.File(Compiler).IsOptionStrictOn Then
                         result = Compiler.Report.ShowMessage(Messages.VBNC30512, Location, Helper.ToString(Expression, Expression.ExpressionType), Helper.ToString(Expression, Me.ExpressionType))
                     Else
                         m_IsStringToCharArray = True
                     End If
                 ElseIf Helper.CompareType(Me.Expression.ExpressionType, Compiler.TypeCache.Nothing) Then
                     'OK
                 ElseIf Helper.CompareType(Me.Expression.ExpressionType, Compiler.TypeCache.System_Object) Then
                     'OK
                 ElseIf Compiler.TypeResolver.IsImplicitlyConvertible(Me, Me.Expression.ExpressionType, Me.ExpressionType) Then
                     'OK
                 ElseIf Helper.CompareType(Compiler.TypeCache.System_Array, Me.Expression.ExpressionType) AndAlso CecilHelper.IsArray(Me.ExpressionType) Then
                     'System.Array -> array type OK
                 ElseIf CecilHelper.IsArray(Me.ExpressionType) AndAlso CecilHelper.IsArray(Me.Expression.ExpressionType) Then
                     'OKish
                 ElseIf Location.File(Compiler).IsOptionStrictOn = False AndAlso CecilHelper.IsInterface(Me.Expression.ExpressionType) Then
                     'OKish
                 Else
                     result = FindUserDefinedConversionOperator(Not IsExplicit) AndAlso result
                 End If
             Case Else
                 Throw New InternalException(Me)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeConverter.vb" startline="1367" endline="1452">
<![CDATA[
 
     Public Shared Function ConvertToSByte(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object, ByVal ShowErrors As Boolean) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 Dim i As Boolean = DirectCast(Source, Boolean)
                 result = CSByte(i)
                 Return True
             Case TypeCode.Byte
                 Dim i As Byte = DirectCast(Source, Byte)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.Char
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32006, Context.Location, "SByte")
             Case TypeCode.DateTime
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Date", "SByte")
             Case TypeCode.Decimal
                 Dim i As Decimal = DirectCast(Source, Decimal)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.Double
                 Dim i As Double = DirectCast(Source, Double)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.Int16
                 Dim i As Short = DirectCast(Source, Short)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.Int32
                 Dim i As Integer = DirectCast(Source, Integer)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.Int64
                 Dim i As Long = DirectCast(Source, Long)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.SByte
                 result = Source
                 Return True
             Case TypeCode.Single
                 Dim i As Single = DirectCast(Source, Single)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.String
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "SByte", "String")
             Case TypeCode.UInt16
                 Dim i As UShort = DirectCast(Source, UShort)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.UInt32
                 Dim i As UInteger = DirectCast(Source, UInteger)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.UInt64
                 Dim i As ULong = DirectCast(Source, ULong)
                 If i >= SByte.MinValue AndAlso i <= SByte.MaxValue Then
                     result = CSByte(i)
                     Return True
                 End If
             Case TypeCode.DBNull
                 result = CSByte(0)
                 Return True
         End Select
         If ShowErrors = False Then Return False
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "SByte")
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="97" endline="118">
<![CDATA[
 
     ''' <summary>
     ''' 
     ''' </summary>
     ''' <param name="IncludePath"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Overloads Function ToString(ByVal IncludePath As Boolean, ByVal Compiler As Compiler) As String
         If m_Line < 0 Then
             Return "(in the commandline)"
         End If
 
         If Not File(Compiler) Is Nothing Then
             If IncludePath Then
                 Return String.Format("{0} ({1},{2})", File(Compiler).FileName, Line.ToString, Column.ToString)
             Else
                 Return String.Format("{0} ({1},{2})", File(Compiler).FileNameToReport, Line.ToString, Column.ToString)
             End If
         Else
             Return String.Format("({0},{1})", Line.ToString, Column.ToString)
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="1145" endline="1154">
<![CDATA[
 
     ''' <summary>
     ''' Checks whether the specified Type is defined in the current compiling assembly
     ''' </summary>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsDefinedHere(ByVal Member As Mono.Cecil.MemberReference) As Boolean
         Helper.Assert(Member IsNot Nothing)
         Return Member.DeclaringType.Module.Assembly Is Compiler.AssemblyBuilderCecil
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\CMPT890\CS VB JS examples\Examples\VB.NET\examples\Chap0209.vb" startline="64" endline="80">
<![CDATA[
     Public Shared Sub Main(ByVal args As String())
         Console.WriteLine("Chapter 7 example 3
 
         ' step 1
         Dim Document As New Document(PageSize.A4, 80, 50, 30, 65)
 
         ' step 2
         ' we create a writer that listens to the document
         ' and directs a XML-stream to a file
         PdfWriter.getInstance(Document, New FileOutputStream("Chap0703.pdf"))
 
         ' step 3
         Dim parser As SAXParser = SAXParserFactory.newInstance().newSAXParser()
 
         ' step 4
         parser.parse("Chap0703.xml", New SAXmyHandler(Document, New TagMap("tagmap0703.xml")))
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="19" endline="79">
<![CDATA[
     Private Sub FrmMain_Load(ByVal sender As Object, ByVal e As System.EventArgs) Handles Me.Load
 
         Try
             If My.Application.CommandLineArgs(0).ToString = "/AUTOTUNEUP" Then
                 LnkAutoTuneUp.PerformClick()
             ElseIf My.Application.CommandLineArgs(0).ToString = "/MANUALTUNEUP" Then
                 LnkManualTuneUp.PerformClick()
             ElseIf My.Application.CommandLineArgs(0).ToString = "/GAMEMODE" Then
                 LnkGameMode.PerformClick()
             ElseIf My.Application.CommandLineArgs(0).ToString = "/PROFILES" Then
                 LnkProfiles.PerformClick()
             ElseIf My.Application.CommandLineArgs(0).ToString = "/MANAGER" Then
                 LnkSrvcMngr.PerformClick()
             ElseIf My.Application.CommandLineArgs(0).ToString = "/DOAUTOTUNEUP" Then
                 Me.Opacity = 0
                 Me.ShowInTaskbar = False
                 LnkAutoTuneUp.PerformClick()
                 FrmAuto.BtnOptimize.PerformClick()
                 Me.Close()
             ElseIf My.Application.CommandLineArgs(0).ToString = "/DOGAMEMODE" Then
                 Me.Opacity = 0
                 Me.ShowInTaskbar = False
                 BtnGameMode.PerformClick()
                 Me.Close()
             ElseIf My.Application.CommandLineArgs(0).ToString = "/USERPROFILE" Then
                 Me.Opacity = 0
                 FrmUsrProfile.ShowDialog(Me)
                 Me.Close()
             ElseIf Path.GetExtension(My.Application.CommandLineArgs(0).ToString.ToLower) = ".wsp" Then
                 Me.Opacity = 0
                 Me.ShowInTaskbar = False
                 If ApplyProfile() = False Then
                     Me.Close()
                 End If
                 Exit Sub
             End If
         Catch ex As ArgumentOutOfRangeException
         End Try
 
         Try
             HdrMain.Values.Image = New Bitmap(DataDir & "vso.png")
             BtnHelp.Image = New Bitmap(DataDir & "help.png")
             PnlSide.BackgroundImage = New Bitmap(DataDir & "side.jpg")
             PnlHdr.BackgroundImage = New Bitmap(DataDir & "hdr.jpg")
             LnkHome.Image = New Bitmap(DataDir & "home.png")
             LnkDiagnostics.Image = New Bitmap(DataDir & "services_diagnostics.png")
             LnkAutoTuneUp.Image = New Bitmap(DataDir & "auto_tuneup.png")
             LnkManualTuneUp.Image = New Bitmap(DataDir & "manual_tuneup.png")
             LnkGameMode.Image = New Bitmap(DataDir & "game_mode.png")
             LnkProfiles.Image = New Bitmap(DataDir & "services_profiles.png")
             LnkSrvcMngr.Image = New Bitmap(DataDir & "services_manager.png")
             LnkRescueCntr.Image = New Bitmap(DataDir & "rescue_center.png")
         Catch ex As ArgumentException
         End Try
 
         LblWinInfo.Text = CStr(My.Computer.Registry.GetValue("HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion", "ProductName", "") & _
         " (" & My.Computer.Info.OSVersion & ") " & My.Computer.Registry.GetValue("HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion", "CSDVersion", ""))
         LblCPUInfo.Text = CStr(My.Computer.Registry.GetValue("HKEY_LOCAL_MACHINE\HARDWARE\DESCRIPTION\System\CentralProcessor\0", "ProcessorNameString", ""))
         LblMemInfo.Text = "Physical Memory
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmDiagnostics.vb" startline="322" endline="454">
<![CDATA[
 
 #End Region
 
 #Region "Services Fix"
 
     Private Sub BWFix_DoWork(ByVal sender As Object, ByVal e As System.ComponentModel.DoWorkEventArgs) Handles BWFix.DoWork
 
         System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls = False
         TabMain.SelectedIndex = 0
 
         If LstServices.Items.Item(0).Checked = True Then
             Profile_Fix("Uxsms", 0)
         End If
 
         If LstServices.Items.Item(1).Checked = True Then
             Profile_Fix("Spooler", 1)
         End If
 
         If LstServices.Items.Item(2).Checked = True Then
             Profile_Fix("stisvc", 2)
         End If
 
         If LstServices.Items.Item(3).Checked = True Then
             Profile_Fix("TabletInputService", 3)
         End If
 
         If LstServices.Items.Item(4).Checked = True Then
             Profile_Fix("WinDefend", 4)
         End If
 
         If LstServices.Items.Item(5).Checked = True Then
             Profile_Fix("MpsSvc", 5)
         End If
 
         If LstServices.Items.Item(6).Checked = True Then
             Profile_Fix("PcaSvc", 6)
         End If
 
         If LstServices.Items.Item(7).Checked = True Then
             Profile_Fix("Dhcp", 7)
         End If
 
         If LstServices.Items.Item(8).Checked = True Then
             Profile_Fix("Dnscache", 8)
         End If
 
         If LstServices.Items.Item(9).Checked = True Then
             Profile_Fix("DFSR", 9)
         End If
 
         If LstServices.Items.Item(10).Checked = True Then
             Profile_Fix("LanmanWorkstation", 10)
         End If
 
         If LstServices.Items.Item(11).Checked = True Then
             Profile_Fix("LanmanServer", 13)
             Profile_Fix("Browser", 11)
         End If
 
         If LstServices.Items.Item(12).Checked = True Then
             Profile_Fix("FDResPub", 12)
         End If
 
         If LstServices.Items.Item(13).Checked = True Then
             Profile_Fix("Browser", 11)
             Profile_Fix("LanmanServer", 13)
         End If
 
         If LstServices.Items.Item(14).Checked = True Then
             Profile_Fix("lmhosts", 14)
         End If
 
         If LstServices.Items.Item(15).Checked = True Then
             Profile_Fix("SDRSVC", 15)
         End If
 
         If LstServices.Items.Item(16).Checked = True Then
             Profile_Fix("Wlansvc", 16)
         End If
 
         If LstServices.Items.Item(17).Checked = True Then
             Profile_Fix("ehstart", 17)
         End If
 
         If LstServices.Items.Item(18).Checked = True Then
             Manual_Fix("BITS", 18)
         End If
 
         If LstServices.Items.Item(19).Checked = True Then
             Essential_Fix("BFE", 19)
         End If
 
         If LstServices.Items.Item(20).Checked = True Then
             Essential_Fix("slsvc", 20)
         End If
 
         If LstServices.Items.Item(21).Checked = True Then
             Essential_Fix("SysMain", 21)
         End If
 
         If LstServices.Items.Item(22).Checked = True Then
             Essential_Fix("ProfSvc", 22)
         End If
 
         If LstServices.Items.Item(23).Checked = True Then
             Essential_Fix("power", 23)
         End If
 
         If LstServices.Items.Item(24).Checked = True Then
             Manual_Fix("msiserver", 24)
         End If
 
         If LstServices.Items.Item(25).Checked = True Then
             Essential_Fix("Eventlog", 25)
         End If
 
         If LstServices.Items.Item(26).Checked = True Then
             Manual_Fix("TrustedInstaller", 26)
         End If
 
         If LstServices.Items.Item(27).Checked = True Then
             Manual_Fix("AppMgmt", 27)
         End If
 
         If LstServices.Items.Item(28).Checked = True Then
             Essential_Fix("CryptSvc", 28)
         End If
 
         Threading.Thread.Sleep(1500)
         SrvcCntrl.Close()
         Application.ExitThread()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\PropertyGroupToPropertyAccessExpression.vb" startline="35" endline="42">
<![CDATA[
 
     Shared Function IsMe(ByVal tm As tm) As Boolean
         Dim result As Boolean = True
 
         result = LiteralExpression.IsMe(tm) OrElse ParenthesizedExpression.IsMe(tm) OrElse InstanceExpression.IsMe(tm) OrElse SimpleNameExpression.IsMe(tm) OrElse AddressOfExpression.IsMe(tm)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2575" endline="2670">
<![CDATA[
 
     Shared Function IsAssignable(ByVal Context As BaseObject, ByVal FromType As Mono.Cecil.TypeReference, ByVal ToType As Mono.Cecil.TypeReference) As Boolean
         Dim Compiler As Compiler = Context.Compiler
         'If TypeOf FromType Is TypeDescriptor Then FromType = FromType.UnderlyingSystemType
         'If TypeOf ToType Is TypeDescriptor Then ToType = ToType.UnderlyingSystemType
 #If EXTENDEDDEBUG Then
         Compiler.Report.WriteLine("IsAssignable (FromType 
 #End If
         If FromType Is ToType Then
             Return True
         ElseIf Helper.CompareType(FromType, Compiler.TypeCache.Nothing) Then
             Return True
         ElseIf Helper.CompareType(FromType, ToType) Then
             Return True
         ElseIf CecilHelper.IsArray(FromType) = True AndAlso CecilHelper.IsArray(ToType) = True AndAlso FromType.FullName Is Nothing AndAlso ToType.FullName Is Nothing AndAlso FromType.Name.Equals(ToType.Name, StringComparison.Ordinal) Then
             Return True
         ElseIf CompareType(ToType, Compiler.TypeCache.System_Object) Then
             Return True
             'ElseIf TypeOf ToType Is GenericTypeParameterBuilder AndAlso TypeOf FromType Is Type Then
             '    Return ToType.Name = FromType.Name
             'ElseIf ToType.GetType Is Compiler.TypeCache.System_Reflection_Emit_TypeBuilderInstantiation Then
             '    'ElseIf ToType.GetType.Name = "TypeBuilderInstantiation" Then
             '    If Helper.CompareType(Helper.GetTypeOrTypeBuilder(FromType), ToType) Then
             '        Return True
             '    Else
             '        Return False
             '    End If
             '    Return True
             '    'ElseIf TypeOf ToType Is TypeDescriptor = False AndAlso TypeOf FromType Is TypeDescriptor = False AndAlso ToType.IsAssignableFrom(FromType) Then
             '    '    Return True
         ElseIf TypeOf FromType Is GenericParameter Then
             Dim gp As GenericParameter = DirectCast(FromType, GenericParameter)
             If gp.HasConstraints Then
                 For i As Integer = 0 To gp.Constraints.Count - 1
                     If Helper.IsAssignable(Context, gp.Constraints(i), ToType) Then Return True
                 Next
             End If
             Return False
         ElseIf IsInterface(Context, ToType) Then
             Dim ifaces As Mono.Collections.Generic.Collection(Of TypeReference) = CecilHelper.GetInterfaces(FromType, True)
             If ifaces IsNot Nothing Then
                 For i As Integer = 0 To ifaces.Count - 1
                     Dim iface As Mono.Cecil.TypeReference = ifaces(i)
                     If Helper.CompareType(iface, ToType) Then Return True
                     If Helper.IsAssignable(Context, iface, ToType) Then Return True
                     If Helper.IsSubclassOf(ToType, iface) Then Return True
                 Next
             End If
             If IsInterface(Context, FromType) AndAlso CecilHelper.IsGenericType(FromType) AndAlso CecilHelper.IsGenericType(ToType) Then
                 Dim baseFromI, baseToI As Mono.Cecil.TypeReference
                 baseFromI = CecilHelper.GetGenericTypeDefinition(FromType)
                 baseToI = CecilHelper.GetGenericTypeDefinition(ToType)
                 If Helper.CompareType(baseFromI, baseToI) Then
                     Dim fromArgs, toArgs As Mono.Collections.Generic.Collection(Of TypeReference)
                     fromArgs = CecilHelper.GetGenericArguments(FromType)
                     toArgs = CecilHelper.GetGenericArguments(ToType)
                     If fromArgs.Count = toArgs.Count Then
                         For i As Integer = 0 To toArgs.Count - 1
                             If Helper.IsAssignable(Context, fromArgs(i), toArgs(i)) = False Then Return False
                         Next
                         Return True
                     End If
                 End If
             End If
             Return False
         ElseIf Helper.IsEnum(Compiler, FromType) AndAlso Compiler.TypeResolution.IsImplicitlyConvertible(Context, GetEnumType(Compiler, FromType), ToType) Then
             Return True
         ElseIf ToType.FullName IsNot Nothing AndAlso FromType.FullName IsNot Nothing AndAlso ToType.FullName.Equals(FromType.FullName, StringComparison.Ordinal) Then
             Return True
         ElseIf Helper.CompareType(Compiler.TypeCache.System_UInt32, ToType) AndAlso Helper.CompareType(Compiler.TypeCache.System_UInt16, FromType) Then
             Return True
         ElseIf Helper.CompareType(FromType, Compiler.TypeCache.System_Object) Then
             Return False
         ElseIf TypeOf FromType Is Mono.Cecil.ArrayType AndAlso Helper.Compare(ToType, Compiler.TypeCache.System_Array) Then
             Return True
         ElseIf CecilHelper.IsArray(FromType) AndAlso CecilHelper.IsArray(ToType) Then
             Dim fromArray As ArrayType = DirectCast(FromType, ArrayType)
             Dim toArray As ArrayType = DirectCast(ToType, ArrayType)
             Dim fromElement As Mono.Cecil.TypeReference = CecilHelper.GetElementType(FromType)
             Dim toElement As Mono.Cecil.TypeReference = CecilHelper.GetElementType(ToType)
             If CecilHelper.IsValueType(fromElement) Xor CecilHelper.IsValueType(toElement) Then
                 Return False
             ElseIf fromArray.Rank <> toArray.Rank Then
                 Return False
             Else
                 Return Helper.IsAssignable(Context, fromElement, toElement)
             End If
         ElseIf Helper.IsSubclassOf(ToType, FromType) Then
             Return True
         ElseIf Helper.IsSubclassOf(FromType, ToType) Then
             Return False
         Else
             'Helper.NotImplementedYet("Don't know if it possible to convert from " & FromType.Name & " to " & ToType.Name)
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmProfiles.vb" startline="15" endline="350">
<![CDATA[
 
     Private components As System.ComponentModel.IContainer
 
     <System.Diagnostics.DebuggerStepThrough()> _
     Private Sub InitializeComponent()
         Me.components = New System.ComponentModel.Container
         Dim resources As System.ComponentModel.ComponentResourceManager = New System.ComponentModel.ComponentResourceManager(GetType(FrmProfiles))
         Me.PnlMain = New System.Windows.Forms.Panel
         Me.BoxProfiles = New ComponentFactory.Krypton.Toolkit.KryptonGroup
         Me.PnlProfiles = New System.Windows.Forms.Panel
         Me.LstProfiles = New System.Windows.Forms.ListView
         Me.ColProfiles = New System.Windows.Forms.ColumnHeader
         Me.ColDate = New System.Windows.Forms.ColumnHeader
         Me.ColDescription = New System.Windows.Forms.ColumnHeader
         Me.ConTxtMnu = New System.Windows.Forms.ContextMenuStrip(Me.components)
         Me.ItmPreview = New System.Windows.Forms.ToolStripMenuItem
         Me.ItmApply = New System.Windows.Forms.ToolStripMenuItem
         Me.Sprtr1 = New System.Windows.Forms.ToolStripSeparator
         Me.ItmValidate = New System.Windows.Forms.ToolStripMenuItem
         Me.ItmEdit = New System.Windows.Forms.ToolStripMenuItem
         Me.ItmDelete = New System.Windows.Forms.ToolStripMenuItem
         Me.Sprtr2 = New System.Windows.Forms.ToolStripSeparator
         Me.ItmImport = New System.Windows.Forms.ToolStripMenuItem
         Me.ItmCreate = New System.Windows.Forms.ToolStripMenuItem
         Me.HdrTasks = New ComponentFactory.Krypton.Toolkit.KryptonHeader
         Me.BtnCreate = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnImport = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnDelete = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnEdit = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnValidate = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnApply = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnPreview = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.LblInfo = New System.Windows.Forms.Label
         Me.BtnClose = New System.Windows.Forms.Button
         Me.BWProfiles = New System.ComponentModel.BackgroundWorker
         Me.HdrMain = New ComponentFactory.Krypton.Toolkit.KryptonHeader
         Me.FileDlg = New System.Windows.Forms.OpenFileDialog
         Me.PnlMain.SuspendLayout()
         CType(Me.BoxProfiles, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.BoxProfiles.Panel, System.ComponentModel.ISupportInitialize).BeginInit()
         Me.BoxProfiles.Panel.SuspendLayout()
         Me.BoxProfiles.SuspendLayout()
         Me.PnlProfiles.SuspendLayout()
         Me.ConTxtMnu.SuspendLayout()
         Me.SuspendLayout()
         '
         'PnlMain
         '
         Me.PnlMain.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
                     Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.PnlMain.BackColor = System.Drawing.Color.White
         Me.PnlMain.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.PnlMain.Controls.Add(Me.BoxProfiles)
         Me.PnlMain.Controls.Add(Me.LblInfo)
         Me.PnlMain.Location = New System.Drawing.Point(-2, 49)
         Me.PnlMain.Name = "PnlMain"
         Me.PnlMain.Size = New System.Drawing.Size(663, 500)
         Me.PnlMain.TabIndex = 1
         '
         'BoxProfiles
         '
         Me.BoxProfiles.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
                     Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.BoxProfiles.GroupBackStyle = ComponentFactory.Krypton.Toolkit.PaletteBackStyle.TabOneNote
         Me.BoxProfiles.Location = New System.Drawing.Point(14, 125)
         Me.BoxProfiles.Name = "BoxProfiles"
         Me.BoxProfiles.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Silver
         '
         'BoxProfiles.Panel
         '
         Me.BoxProfiles.Panel.Controls.Add(Me.PnlProfiles)
         Me.BoxProfiles.Panel.Controls.Add(Me.HdrTasks)
         Me.BoxProfiles.Size = New System.Drawing.Size(630, 340)
         Me.BoxProfiles.StateNormal.Border.DrawBorders = CType((((ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Top Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Left) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Right), ComponentFactory.Krypton.Toolkit.PaletteDrawBorders)
         Me.BoxProfiles.StateNormal.Border.Rounding = 3
         Me.BoxProfiles.TabIndex = 1
         '
         'PnlProfiles
         '
         Me.PnlProfiles.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
                     Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.PnlProfiles.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle
         Me.PnlProfiles.Controls.Add(Me.LstProfiles)
         Me.PnlProfiles.Location = New System.Drawing.Point(16, 50)
         Me.PnlProfiles.Name = "PnlProfiles"
         Me.PnlProfiles.Size = New System.Drawing.Size(595, 270)
         Me.PnlProfiles.TabIndex = 1
         '
         'LstProfiles
         '
         Me.LstProfiles.BackColor = System.Drawing.Color.White
         Me.LstProfiles.BorderStyle = System.Windows.Forms.BorderStyle.None
         Me.LstProfiles.Columns.AddRange(New System.Windows.Forms.ColumnHeader() {Me.ColProfiles, Me.ColDate, Me.ColDescription})
         Me.LstProfiles.ContextMenuStrip = Me.ConTxtMnu
         Me.LstProfiles.Dock = System.Windows.Forms.DockStyle.Fill
         Me.LstProfiles.ForeColor = System.Drawing.Color.Black
         Me.LstProfiles.FullRowSelect = True
         Me.LstProfiles.GridLines = True
         Me.LstProfiles.Location = New System.Drawing.Point(0, 0)
         Me.LstProfiles.MultiSelect = False
         Me.LstProfiles.Name = "LstProfiles"
         Me.LstProfiles.Size = New System.Drawing.Size(593, 268)
         Me.LstProfiles.Sorting = System.Windows.Forms.SortOrder.Ascending
         Me.LstProfiles.TabIndex = 1
         Me.LstProfiles.UseCompatibleStateImageBehavior = False
         Me.LstProfiles.View = System.Windows.Forms.View.Details
         '
         'ColProfiles
         '
         Me.ColProfiles.Text = "Services profile"
         Me.ColProfiles.Width = 125
         '
         'ColDate
         '
         Me.ColDate.Text = "Date created"
         Me.ColDate.Width = 125
         '
         'ColDescription
         '
         Me.ColDescription.Text = "Description"
         Me.ColDescription.Width = 330
         '
         'ConTxtMnu
         '
         Me.ConTxtMnu.Font = New System.Drawing.Font("Segoe UI", 9.0!)
         Me.ConTxtMnu.Items.AddRange(New System.Windows.Forms.ToolStripItem() {Me.ItmPreview, Me.ItmApply, Me.Sprtr1, Me.ItmValidate, Me.ItmEdit, Me.ItmDelete, Me.Sprtr2, Me.ItmImport, Me.ItmCreate})
         Me.ConTxtMnu.Name = "ConTxtMnu"
         Me.ConTxtMnu.ShowItemToolTips = False
         Me.ConTxtMnu.Size = New System.Drawing.Size(136, 170)
         '
         'ItmPreview
         '
         Me.ItmPreview.Name = "ItmPreview"
         Me.ItmPreview.Size = New System.Drawing.Size(135, 22)
         Me.ItmPreview.Text = "Preview"
         '
         'ItmApply
         '
         Me.ItmApply.Name = "ItmApply"
         Me.ItmApply.Size = New System.Drawing.Size(135, 22)
         Me.ItmApply.Text = "Apply"
         '
         'Sprtr1
         '
         Me.Sprtr1.Name = "Sprtr1"
         Me.Sprtr1.Size = New System.Drawing.Size(132, 6)
         '
         'ItmValidate
         '
         Me.ItmValidate.Name = "ItmValidate"
         Me.ItmValidate.Size = New System.Drawing.Size(135, 22)
         Me.ItmValidate.Text = "Validate"
         '
         'ItmEdit
         '
         Me.ItmEdit.Name = "ItmEdit"
         Me.ItmEdit.Size = New System.Drawing.Size(135, 22)
         Me.ItmEdit.Text = "Edit"
         '
         'ItmDelete
         '
         Me.ItmDelete.Name = "ItmDelete"
         Me.ItmDelete.Size = New System.Drawing.Size(135, 22)
         Me.ItmDelete.Text = "Delete"
         '
         'Sprtr2
         '
         Me.Sprtr2.Name = "Sprtr2"
         Me.Sprtr2.Size = New System.Drawing.Size(132, 6)
         '
         'ItmImport
         '
         Me.ItmImport.Name = "ItmImport"
         Me.ItmImport.Size = New System.Drawing.Size(135, 22)
         Me.ItmImport.Text = "Import"
         '
         'ItmCreate
         '
         Me.ItmCreate.Name = "ItmCreate"
         Me.ItmCreate.Size = New System.Drawing.Size(135, 22)
         Me.ItmCreate.Text = "New profile"
         '
         'HdrTasks
         '
         Me.HdrTasks.AllowButtonSpecToolTips = True
         Me.HdrTasks.ButtonSpecs.AddRange(New ComponentFactory.Krypton.Toolkit.ButtonSpecAny() {Me.BtnCreate, Me.BtnImport, Me.BtnDelete, Me.BtnEdit, Me.BtnValidate, Me.BtnApply, Me.BtnPreview})
         Me.HdrTasks.Dock = System.Windows.Forms.DockStyle.Top
         Me.HdrTasks.HeaderStyle = ComponentFactory.Krypton.Toolkit.HeaderStyle.Secondary
         Me.HdrTasks.Location = New System.Drawing.Point(0, 0)
         Me.HdrTasks.Name = "HdrTasks"
         Me.HdrTasks.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Silver
         Me.HdrTasks.Size = New System.Drawing.Size(626, 28)
         Me.HdrTasks.StateNormal.Border.DrawBorders = ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom
         Me.HdrTasks.TabIndex = 0
         Me.HdrTasks.TabStop = False
         Me.HdrTasks.Values.Description = ""
         Me.HdrTasks.Values.Heading = ""
         Me.HdrTasks.Values.Image = Nothing
         '
         'BtnCreate
         '
         Me.BtnCreate.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnCreate.Text = " New profile"
         Me.BtnCreate.ToolTipBody = "Create a new services profile."
         Me.BtnCreate.UniqueName = ""
         '
         'BtnImport
         '
         Me.BtnImport.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnImport.Text = " Import"
         Me.BtnImport.ToolTipBody = "Import an existing services profile."
         Me.BtnImport.UniqueName = ""
         '
         'BtnDelete
         '
         Me.BtnDelete.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnDelete.Text = " Delete"
         Me.BtnDelete.ToolTipBody = "Delete the selected services profile."
         Me.BtnDelete.UniqueName = ""
         '
         'BtnEdit
         '
         Me.BtnEdit.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnEdit.Text = " Edit"
         Me.BtnEdit.ToolTipBody = "Edit the selected services profile."
         Me.BtnEdit.UniqueName = ""
         '
         'BtnValidate
         '
         Me.BtnValidate.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnValidate.Text = " Validate"
         Me.BtnValidate.ToolTipBody = "Validate the selected services profile."
         Me.BtnValidate.UniqueName = ""
         '
         'BtnApply
         '
         Me.BtnApply.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnApply.Text = " Apply"
         Me.BtnApply.ToolTipBody = "Apply the selected services profile."
         Me.BtnApply.UniqueName = ""
         '
         'BtnPreview
         '
         Me.BtnPreview.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnPreview.Text = " Preview"
         Me.BtnPreview.ToolTipBody = "Preview the selected services profile."
         Me.BtnPreview.UniqueName = ""
         '
         'LblInfo
         '
         Me.LblInfo.Anchor = CType(((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.LblInfo.Location = New System.Drawing.Point(16, 23)
         Me.LblInfo.Name = "LblInfo"
         Me.LblInfo.Size = New System.Drawing.Size(620, 85)
         Me.LblInfo.TabIndex = 0
         Me.LblInfo.Text = resources.GetString("LblInfo.Text")
         '
         'BtnClose
         '
         Me.BtnClose.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.BtnClose.Location = New System.Drawing.Point(562, 560)
         Me.BtnClose.Name = "BtnClose"
         Me.BtnClose.Size = New System.Drawing.Size(85, 25)
         Me.BtnClose.TabIndex = 2
         Me.BtnClose.Text = "&Close"
         Me.BtnClose.UseVisualStyleBackColor = True
         '
         'BWProfiles
         '
         Me.BWProfiles.WorkerReportsProgress = True
         Me.BWProfiles.WorkerSupportsCancellation = True
         '
         'HdrMain
         '
         Me.HdrMain.Dock = System.Windows.Forms.DockStyle.Top
         Me.HdrMain.Location = New System.Drawing.Point(0, 0)
         Me.HdrMain.Name = "HdrMain"
         Me.HdrMain.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2007Silver
         Me.HdrMain.Size = New System.Drawing.Size(659, 53)
         Me.HdrMain.StateNormal.Back.Color1 = System.Drawing.Color.White
         Me.HdrMain.StateNormal.Back.Color2 = System.Drawing.Color.Gainsboro
         Me.HdrMain.StateNormal.Back.ColorStyle = ComponentFactory.Krypton.Toolkit.PaletteColorStyle.HalfCut
         Me.HdrMain.StateNormal.Border.DrawBorders = ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom
         Me.HdrMain.StateNormal.Content.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.HdrMain.StateNormal.Content.ShortText.Font = New System.Drawing.Font("Calibri", 27.75!, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.HdrMain.TabIndex = 0
         Me.HdrMain.TabStop = False
         Me.HdrMain.Values.Description = ""
         Me.HdrMain.Values.Heading = " Services Profiles"
         Me.HdrMain.Values.Image = Nothing
         '
         'FileDlg
         '
         Me.FileDlg.DefaultExt = "wsp"
         Me.FileDlg.Filter = "Services Profiles|*.wsp"
         Me.FileDlg.Title = "Import services profile"
         '
         'FrmProfiles
         '
         Me.AutoScaleMode = System.Windows.Forms.AutoScaleMode.None
         Me.ClientSize = New System.Drawing.Size(659, 596)
         Me.ControlBox = False
         Me.Controls.Add(Me.HdrMain)
         Me.Controls.Add(Me.BtnClose)
         Me.Controls.Add(Me.PnlMain)
         Me.DoubleBuffered = True
         Me.Font = New System.Drawing.Font("Segoe UI", 9.0!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.ForeColor = System.Drawing.Color.Black
         Me.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None
         Me.KeyPreview = True
         Me.MaximizeBox = False
         Me.MinimizeBox = False
         Me.Name = "FrmProfiles"
         Me.ShowIcon = False
         Me.ShowInTaskbar = False
         Me.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide
         Me.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen
         Me.Text = "Services Profiles"
         Me.PnlMain.ResumeLayout(False)
         CType(Me.BoxProfiles.Panel, System.ComponentModel.ISupportInitialize).EndInit()
         Me.BoxProfiles.Panel.ResumeLayout(False)
         Me.BoxProfiles.Panel.PerformLayout()
         CType(Me.BoxProfiles, System.ComponentModel.ISupportInitialize).EndInit()
         Me.BoxProfiles.ResumeLayout(False)
         Me.PnlProfiles.ResumeLayout(False)
         Me.ConTxtMnu.ResumeLayout(False)
         Me.ResumeLayout(False)
         Me.PerformLayout()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="1109" endline="1241">
<![CDATA[
 
     ''' <summary>
     ''' Emits the instanceexpression (if any), the arguments (if any), the optional arguments (if any) and then calls the method (virt or not).
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <param name="InstanceExpression"></param>
     ''' <param name="Arguments"></param>
     ''' <param name="Method"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function EmitArgumentsAndCallOrCallVirt(ByVal Info As EmitInfo, ByVal InstanceExpression As Expression, ByVal Arguments As ArgumentList, ByVal Method As Mono.Cecil.MethodReference) As Boolean
         Dim result As Boolean = True
         Dim needsConstrained As Boolean
         Dim constrainedLocal As Mono.Cecil.Cil.VariableDefinition = Nothing
 
         needsConstrained = InstanceExpression IsNot Nothing AndAlso CecilHelper.IsGenericParameter(InstanceExpression.ExpressionType)
 
         Helper.Assert(Method IsNot Nothing)
 
         If InstanceExpression IsNot Nothing AndAlso CecilHelper.FindDefinition(Method).IsStatic = False Then
             Dim ieDesiredType As Mono.Cecil.TypeReference
             Dim ieInfo As EmitInfo
 
             If needsConstrained Then
                 ieDesiredType = InstanceExpression.ExpressionType
             Else
                 ieDesiredType = Method.DeclaringType
                 If CecilHelper.IsValueType(ieDesiredType) Then
                     ieDesiredType = Info.Compiler.TypeManager.MakeByRefType(CType(Info.Method, ParsedObject), ieDesiredType)
                 End If
             End If
 
             ieInfo = Info.Clone(Info.Context, True, False, ieDesiredType)
 
             Dim derefExp As DeRefExpression = TryCast(InstanceExpression, DeRefExpression)
             If needsConstrained AndAlso derefExp IsNot Nothing Then
                 result = derefExp.Expression.GenerateCode(Info.Clone(Info.Context, True, False, derefExp.Expression.ExpressionType)) AndAlso result
             Else
                 Dim getRef As GetRefExpression = TryCast(InstanceExpression, GetRefExpression)
                 If getRef IsNot Nothing AndAlso CecilHelper.IsValueType(getRef.Expression.ExpressionType) AndAlso Helper.CompareType(Method.DeclaringType, Info.Compiler.TypeCache.System_Object) Then
                     result = getRef.Expression.GenerateCode(ieInfo) AndAlso result
                     Emitter.EmitBox(Info, getRef.Expression.ExpressionType)
                 Else
                     result = InstanceExpression.GenerateCode(ieInfo) AndAlso result
                 End If
 
                 If needsConstrained Then
                     constrainedLocal = Emitter.DeclareLocal(Info, InstanceExpression.ExpressionType)
                     Emitter.EmitStoreVariable(Info, constrainedLocal)
                     Emitter.EmitLoadVariableLocation(Info, constrainedLocal)
                 End If
             End If
 
         End If
 
         Dim copyBacksA As Generic.List(Of Mono.Cecil.Cil.VariableDefinition) = Nothing
         Dim copyBacksB As Generic.List(Of Expression) = Nothing
 
         If Arguments IsNot Nothing Then
             Dim methodParameters As Mono.Collections.Generic.Collection(Of ParameterDefinition)
             methodParameters = Helper.GetParameters(Info.Compiler, Method)
 
             For i As Integer = 0 To methodParameters.Count - 1
                 Dim arg As Argument
                 Dim exp As Expression
                 Dim local As Mono.Cecil.Cil.VariableDefinition
                 Dim propAccess As PropertyAccessClassification
 
                 If CecilHelper.IsByRef(methodParameters(i).ParameterType) = False Then Continue For
 
                 arg = Arguments.Arguments(i)
                 exp = arg.Expression
 
                 If exp Is Nothing Then Continue For
 
                 If exp.Classification Is Nothing Then Continue For
                 If exp.Classification.IsPropertyAccessClassification = False Then Continue For
 
                 propAccess = exp.Classification.AsPropertyAccess
 
                 If copyBacksA Is Nothing Then
                     copyBacksA = New Generic.List(Of Mono.Cecil.Cil.VariableDefinition)
                     copyBacksB = New Generic.List(Of Expression)
                 End If
                 local = Emitter.DeclareLocal(Info, CecilHelper.GetElementType(methodParameters(i).ParameterType))
                 copyBacksA.Add(local)
                 If CecilHelper.FindDefinition(propAccess.Property).SetMethod Is Nothing Then
                     copyBacksB.Add(Nothing)
                 Else
                     copyBacksB.Add(exp)
                 End If
 
                 result = arg.GenerateCode(Info, methodParameters(i)) AndAlso result
                 Emitter.EmitStoreVariable(Info, local)
                 arg.Expression = New LoadLocalExpression(arg, local)
             Next
 
             result = Arguments.GenerateCode(Info, methodParameters) AndAlso result
         End If
 
         If needsConstrained Then
             Emitter.EmitConstrainedCallVirt(Info, Method, InstanceExpression.ExpressionType)
         ElseIf InstanceExpression IsNot Nothing AndAlso (TypeOf InstanceExpression Is MyClassExpression OrElse TypeOf InstanceExpression Is MyBaseExpression) Then
             Emitter.EmitCall(Info, Method)
         Else
             Emitter.EmitCallOrCallVirt(Info, Method)
         End If
 
         If copyBacksA IsNot Nothing Then
             For i As Integer = 0 To copyBacksA.Count - 1
                 Dim local As Mono.Cecil.Cil.VariableDefinition = copyBacksA(i)
                 Dim exp As Expression = copyBacksB(i)
 
                 If exp Is Nothing Then Continue For
 
                 result = exp.GenerateCode(Info.Clone(Info.Context, New LoadLocalExpression(exp, local))) AndAlso result
             Next
         End If
 
         If constrainedLocal IsNot Nothing Then
             Emitter.FreeLocal(constrainedLocal)
         End If
 
         If Info.DesiredType IsNot Nothing AndAlso CecilHelper.IsByRef(Info.DesiredType) Then
             Dim tmp As Mono.Cecil.Cil.VariableDefinition
             tmp = Emitter.DeclareLocal(Info, CecilHelper.GetElementType(Info.DesiredType))
             Emitter.EmitStoreVariable(Info, tmp)
             Emitter.EmitLoadVariableLocation(Info, tmp)
             Emitter.FreeLocal(tmp)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeConverter.vb" startline="1022" endline="1082">
<![CDATA[
 
     Public Shared Function ConvertToChar(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object, ByVal ShowErrors As Boolean) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Boolean", "Char")
             Case TypeCode.Byte
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "Byte")
             Case TypeCode.Char
                 result = Source
                 Return True
             Case TypeCode.DateTime
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "DateTime", "Char")
             Case TypeCode.Decimal
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Decimal", "Char")
             Case TypeCode.Double
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Double", "Char")
             Case TypeCode.Int16
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "Short")
             Case TypeCode.Int32
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "Integer")
             Case TypeCode.Int64
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "Long")
             Case TypeCode.SByte
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "SByte")
             Case TypeCode.Single
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Single", "Char")
             Case TypeCode.String
                 If ShowErrors = False Then Return False
                 Dim str As String = DirectCast(Source, String)
                 If str.Length >= 1 Then
                     result = str(0)
                 Else
                     result = CChar(Nothing)
                 End If
                 Return True
             Case TypeCode.UInt16
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "UShort")
             Case TypeCode.UInt32
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "UInteger")
             Case TypeCode.UInt64
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC32007, Context.Location, "ULong")
             Case TypeCode.DBNull
                 result = VB.Chr(0)
                 Return True
         End Select
         If ShowErrors = False Then Return False
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "Char")
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\OperatorDeclaration.vb" startline="147" endline="164">
<![CDATA[
     End Property
 
     ''' <summary>
     ''' OverloadableBinaryOperator  
     '''	"+" | "-" | "*" |  "/"  |  "\"  |  "&amp;" |  "Like"  |  "Mod"  |  "And"  |  "Or" |  "Xor"  |
     '''	"^" | "&lt;&lt;" |  "&gt;&gt;" | "="  |  "&lt;&gt;" | "&gt;" |  "&lt;" |  "&gt;="  |  "&lt;="
     ''' </summary>
     ''' <param name="token"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function IsOverloadableBinaryOperator(ByVal token As Token) As Boolean
         Return token = KS.Add OrElse token = KS.Minus OrElse token = KS.Mult _
         OrElse token = KS.IntDivision OrElse token = KS.RealDivision OrElse token = KS.Concat _
         OrElse token = KS.Like OrElse token = KS.Mod OrElse token = KS.And OrElse token = KS.Or _
         OrElse token = KS.Xor OrElse token = KS.Power OrElse token = KS.ShiftLeft _
         OrElse token = KS.ShiftRight OrElse token = KS.Equals OrElse token = KS.NotEqual _
         OrElse token = KS.GT OrElse token = KS.LT OrElse token = KS.GE OrElse token = KS.LE
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="117" endline="123">
<![CDATA[
     End Property
 
     Property Type() As Mono.Cecil.TypeReference
         Get
             Helper.Assert(m_Type IsNot Nothing)
             Return m_Type
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="90" endline="96">
<![CDATA[
     End Property
 
     Overrides ReadOnly Property ExpressionType() As Mono.Cecil.TypeReference
         Get
             Helper.Assert(m_ExpressionType IsNot Nothing)
             Return m_ExpressionType
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\SubSignature.vb" startline="133" endline="139">
<![CDATA[
     End Property
 
     ReadOnly Property Parameters() As ParameterList
         Get
             Helper.Assert(m_ParameterList IsNot Nothing)
             Return m_ParameterList
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="870" endline="879">
<![CDATA[
 
     ''' <summary>
     ''' Returns true if this constructor has any parameter, default or normal parameter.
     ''' </summary>
     ''' <param name="Constructor"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Shared Function HasParameters(ByVal Constructor As Mono.Cecil.MethodDefinition) As Boolean
         Return Constructor.Parameters.Count > 0
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmManual.vb" startline="391" endline="437">
<![CDATA[
 
 #End Region
 
 #Region "Services Status"
 
     Private Sub Services_Status()
 
         Check_Service("Themes", CboThemes)
         Check_Service("UxSms", CboWinAero)
         Check_Service("ehstart", CboMediaCntr)
         Check_Service("WMPNetworkSvc", CboMediaShare)
         Check_Service("WSearch", CboWinSearch)
         Check_Service("PcaSvc", CboCompatibility)
         Check_Service("DPS", CboDiagnostics)
         Check_Service("Spooler", CboPrinter)
         Check_Service("stisvc", CboScanner)
         Check_Service("TabletInputService", CboTabletPC)
         Check_Service("SENS", CboSystemEvent)
         Check_Service("seclogon", CboSecondLogon)
         Check_Service("WerSvc", CboErrReport)
         Check_Service("defragsvc", CboDefrag)
 
         Check_Service("wscsvc", CboSecCntr)
         Check_Service("wuauserv", CboWinUpdate)
         Check_Service("WinDefend", CboWinDefender)
         Check_Service("MpsSvc", CboWinFirewall)
         Check_Service("SDRSVC", CboWinBackup)
         Check_Service("RemoteRegistry", CboRmtReg)
         Check_Service("PolicyAgent", CboIPSec)
 
         Check_Service("Dhcp", CboDHCP)
         Check_Service("Dnscache", CboDNS)
         Check_Service("DFSR", CboDFS)
         Check_Service("LanmanWorkstation", CboWorkstation)
         Check_Service("Browser", CboComputerBrowser)
         Check_Service("FDResPub", CboFunctionDiscovery)
         Check_Service("LanmanServer", CboServer)
         Check_Service("lmhosts", CboNetBIOSHelper)
         Check_Service("TermService", CboTerminal)
         Check_Service("upnphost", CboUPnP)
         Check_Service("CscService", CboOfflineFiles)
         Check_Service("iphlpsvc", CboIPv6)
         Check_Service("WebClient", CboWebClient)
         Check_Service("W32Time", CboWinTime)
         Check_Service("Wlansvc", CboWirelessNet)
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmManual.vb" startline="460" endline="510">
<![CDATA[
 
 #End Region
 
 #Region "Manual TuneUp"
 
     Private Sub BWManTuneUp_DoWork(ByVal sender As Object, ByVal e As System.ComponentModel.DoWorkEventArgs) Handles BWManTuneUp.DoWork
 
         Apply_Setting("Themes", CboThemes)
         Apply_Setting("UxSms", CboWinAero)
         Apply_Setting("ehstart", CboMediaCntr)
         Apply_Setting("WMPNetworkSvc", CboMediaShare)
         Apply_Setting("WSearch", CboWinSearch)
         Apply_Setting("PcaSvc", CboCompatibility)
         Apply_Setting("DPS", CboDiagnostics)
         Apply_Setting("Spooler", CboPrinter)
         Apply_Setting("stisvc", CboScanner)
         Apply_Setting("TabletInputService", CboTabletPC)
         Apply_Setting("SENS", CboSystemEvent)
         Apply_Setting("seclogon", CboSecondLogon)
         Apply_Setting("WerSvc", CboErrReport)
         Apply_Setting("defragsvc", CboDefrag)
 
         Apply_Setting("wscsvc", CboSecCntr)
         Apply_Setting("wuauserv", CboWinUpdate)
         Apply_Setting("WinDefend", CboWinDefender)
         Apply_Setting("MpsSvc", CboWinFirewall)
         Apply_Setting("SDRSVC", CboWinBackup)
         Apply_Setting("RemoteRegistry", CboRmtReg)
         Apply_Setting("PolicyAgent", CboIPSec)
 
         Apply_Setting("Dhcp", CboDHCP)
         Apply_Setting("Dnscache", CboDNS)
         Apply_Setting("DFSR", CboDFS)
         Apply_Setting("LanmanWorkstation", CboWorkstation)
         Apply_Setting("LanmanServer", CboServer)
         Apply_Setting("Browser", CboComputerBrowser)
         Apply_Setting("FDResPub", CboFunctionDiscovery)
         Apply_Setting("lmhosts", CboNetBIOSHelper)
         Apply_Setting("TermService", CboTerminal)
         Apply_Setting("upnphost", CboUPnP)
         Apply_Setting("CscService", CboOfflineFiles)
         Apply_Setting("iphlpsvc", CboIPv6)
         Apply_Setting("WebClient", CboWebClient)
         Apply_Setting("W32Time", CboWinTime)
         Apply_Setting("Wlansvc", CboWirelessNet)
 
         System.Threading.Thread.Sleep(2000)
         SrvcCntrl.Close()
         Application.ExitThread()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\CMPT890\CS VB JS examples\Examples\VB.NET\examples\MainModule.vb" startline="135" endline="185">
<![CDATA[
 
     Public Shared Sub ExecuteAllExamples()
         init()
 
         Call ExecuteExample(GetType(Chap0703)) 'Create first for source file
 
         Call ExecuteExample(GetType(Chap0101))
         'Call ExecuteExample(GetType(Chap0102))
         Call ExecuteExample(GetType(Chap0103))
         Call ExecuteExample(GetType(Chap0104))
         'Call ExecuteExample(GetType(Chap0105.main(nothing)	'servelet
         Call ExecuteExample(GetType(Chap0106))
         Call ExecuteExample(GetType(Chap0107))
         Call ExecuteExample(GetType(Chap0108))
         Call ExecuteExample(GetType(Chap0109))
         Call ExecuteExample(GetType(Chap0110))
         Call ExecuteExample(GetType(Chap0111))
         Call ExecuteExample(GetType(Chap0112))
         ' Call ExecuteExample(GetType(Chap0201))
         ' Call ExecuteExample(GetType(Chap0201a))
         'Call ExecuteExample(GetType(Chap0202))
         Call ExecuteExample(GetType(Chap0203))
         Call ExecuteExample(GetType(Chap0204))
         Call ExecuteExample(GetType(Chap0205))
         Call ExecuteExample(GetType(Chap0206))
         Call ExecuteExample(GetType(Chap0207))
         Call ExecuteExample(GetType(Chap0208))
         Call ExecuteExample(GetType(Chap0209))
 
         Call ExecuteExample(GetType(Chap0801))
         'Call ExecuteExample(GetType(Chap0802))
         Call ExecuteExample(GetType(Chap0803))
         Call ExecuteExample(GetType(Chap0804))
 
         If True Then
             Dim a() As String = {"Chap0101.pdf", "Chap0102.pdf", "Chap0103.pdf", "concat.pdf"}
             Call ExecuteExample(GetType(concat_pdf), "main", New Object() {a})
         End If
         If True Then
             Dim a() As String = {"concat.pdf", "split1.pdf", "split2.pdf", "2"}
             Call ExecuteExample(GetType(split_pdf), "main", New Object() {a})
         End If
         If True Then
             Dim a() As String = {"concat.pdf", "handout.pdf", "2"}
             Call ExecuteExample(GetType(handout_pdf), "main", New Object() {a})
         End If
         If True Then
             Dim a() As String = {"Chap0101.pdf", "encrypted.pdf", "user", "master", "00000000", "128"}
             Call ExecuteExample(GetType(encrypt_pdf), "main", New Object() {a})
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeConverter.vb" startline="1493" endline="1547">
<![CDATA[
 
     Public Shared Function ConvertToString(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object, ByVal ShowErrors As Boolean) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Boolean", "String")
             Case TypeCode.Byte
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Byte", "String")
             Case TypeCode.Char
                 result = CStr(DirectCast(Source, Char))
                 Return True
             Case TypeCode.DateTime
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Date", "String")
             Case TypeCode.Decimal
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Decimal", "String")
             Case TypeCode.Double
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Double", "String")
             Case TypeCode.Int16
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Short", "String")
             Case TypeCode.Int32
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Integer", "String")
             Case TypeCode.Int64
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Long", "String")
             Case TypeCode.SByte
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "SByte", "String")
             Case TypeCode.Single
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "Single", "String")
             Case TypeCode.String
                 result = Source
                 Return True
             Case TypeCode.UInt16
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "UShort", "String")
             Case TypeCode.UInt32
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "UInteger", "String")
             Case TypeCode.UInt64
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "ULong", "String")
             Case TypeCode.DBNull
                 result = Nothing
                 Return True
         End Select
         If ShowErrors = False Then Return False
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "String")
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="416" endline="429">
<![CDATA[
 
     Overloads Function Equals(ByVal obj As Token) As Boolean
         If Me.IsIdentifier AndAlso obj.IsIdentifier Then
             Return Me.Equals(obj.Identifier)
         ElseIf Me.IsLiteral AndAlso obj.IsLiteral Then
             Return Me.LiteralValue.Equals(obj.LiteralValue)
         ElseIf Me.IsKeyword AndAlso obj.IsKeyword Then
             Return Me.Keyword = obj.Keyword
         ElseIf Me.IsSymbol AndAlso obj.IsSymbol Then
             Return Me.Symbol = obj.Symbol
         Else
             Return False
         End If
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\IfExpression.vb" startline="72" endline="149">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = Condition.ResolveExpression(Info) AndAlso result
         result = SecondPart.ResolveExpression(Info) AndAlso result
 
         If ThirdPart IsNot Nothing Then
             result = ThirdPart.ResolveExpression(Info) AndAlso result
         End If
 
         If Not result Then Return result
 
         If ThirdPart IsNot Nothing Then
             If Compiler.TypeResolution.IsImplicitlyConvertible(Me, Condition.ExpressionType, Compiler.TypeCache.System_Boolean) = False AndAlso Location.File(Compiler).IsOptionStrictOn Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC30512, Condition.Location, Condition.ExpressionType.Name, Compiler.TypeCache.System_Boolean.Name) AndAlso result
             Else
                 Condition = Helper.CreateTypeConversion(Me, Condition, Compiler.TypeCache.System_Boolean, result)
             End If
 
             If Helper.CompareType(SecondPart.ExpressionType, ThirdPart.ExpressionType) = False Then
                 If Compiler.TypeResolution.IsImplicitlyConvertible(Me, SecondPart.ExpressionType, ThirdPart.ExpressionType) Then
                     m_ExpressionType = ThirdPart.ExpressionType
                     SecondPart = Helper.CreateTypeConversion(Me, SecondPart, m_ExpressionType, result)
                 ElseIf Compiler.TypeResolution.IsImplicitlyConvertible(Me, ThirdPart.ExpressionType, SecondPart.ExpressionType) Then
                     m_ExpressionType = SecondPart.ExpressionType
                     ThirdPart = Helper.CreateTypeConversion(Me, ThirdPart, m_ExpressionType, result)
                 Else
                     result = Compiler.Report.ShowMessage(Messages.VBNC33106, Me.Location) AndAlso result
                 End If
             Else
                 m_ExpressionType = SecondPart.ExpressionType
             End If
         Else
             If Condition.ExpressionType.IsValueType AndAlso CecilHelper.IsNullable(Condition.ExpressionType) = False Then
                 Return Compiler.Report.ShowMessage(Messages.VBNC33107, Condition.Location) AndAlso result
             End If
 
             If TypeOf SecondPart Is NothingConstantExpression Then
                 If TypeOf Condition Is NothingConstantExpression Then
                     m_ExpressionType = Compiler.TypeCache.System_Object
                 Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC30512, Condition.Location, Condition.ExpressionType.Name, "Integer")
                 End If
             ElseIf TypeOf Condition Is NothingConstantExpression Then
                 If Helper.CompareType(SecondPart.ExpressionType, Compiler.TypeCache.System_Int32) Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC33110, Me.Location)
                 Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC30512, Condition.Location, SecondPart.ExpressionType.Name, "Integer")
                 End If
             Else
                 If Helper.CompareType(SecondPart.ExpressionType, Condition.ExpressionType) = False Then
                     Dim condType As TypeReference = Condition.ExpressionType
 
                     If CecilHelper.IsNullable(Condition.ExpressionType) AndAlso Not CecilHelper.IsNullable(SecondPart.ExpressionType) Then
                         condType = CecilHelper.GetNulledType(condType)
                     End If
 
                     If Compiler.TypeResolution.IsImplicitlyConvertible(Me, SecondPart.ExpressionType, condType) Then
                         m_ExpressionType = condType
                         SecondPart = Helper.CreateTypeConversion(Me, SecondPart, m_ExpressionType, result)
                     ElseIf Compiler.TypeResolution.IsImplicitlyConvertible(Me, condType, SecondPart.ExpressionType) Then
                         m_ExpressionType = SecondPart.ExpressionType
                     Else
                         result = Compiler.Report.ShowMessage(Messages.VBNC33110, Me.Location) AndAlso result
                     End If
                 Else
                     m_ExpressionType = SecondPart.ExpressionType
                 End If
             End If
         End If
 
         If result Then
             Me.Classification = New ValueClassification(Me, Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\DotAccessExpression.vb" startline="60" endline="164">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim refInfo As EmitInfo = Info.Clone(Me, Me.ExpressionType)
 
         Select Case m_Expression.Classification.Classification
             Case ExpressionClassification.Classifications.Variable
                 Dim varC As VariableClassification = m_Expression.Classification.AsVariableClassification
 
                 If varC.InstanceExpression IsNot Nothing Then
                     Dim desiredType As Mono.Cecil.TypeReference
                     desiredType = varC.InstanceExpression.ExpressionType
                     If CecilHelper.IsValueType(desiredType) AndAlso CecilHelper.IsByRef(desiredType) = False Then
                         desiredType = CecilHelper.MakeByRefType(desiredType)
                     End If
                     result = varC.InstanceExpression.GenerateCode(Info.Clone(Me, desiredType)) AndAlso result
                     'result = varC.InstanceExpression.GenerateCode(refInfo) AndAlso result
                 End If
 
                 If varC.LocalBuilder IsNot Nothing Then
                     Emitter.EmitLoadVariableLocation(refInfo, varC.LocalBuilder)
                 ElseIf varC.ParameterInfo IsNot Nothing Then
                     Emitter.EmitLoadVariableLocation(refInfo, varC.ParameterInfo)
                 ElseIf varC.FieldInfo IsNot Nothing Then
                     If varC.FieldDefinition.IsLiteral Then
                         Dim local As Mono.Cecil.Cil.VariableDefinition
                         local = Emitter.DeclareLocal(Info, varC.FieldInfo.FieldType)
                         Emitter.EmitLoadVariable(Info, varC.FieldInfo)
                         Emitter.EmitStoreVariable(Info, local)
                         Emitter.EmitLoadVariableLocation(refInfo, local)
                     Else
                         Emitter.EmitLoadVariableLocation(refInfo, varC.FieldInfo)
                     End If
                 ElseIf varC.ArrayVariable IsNot Nothing Then
                     Dim arrtype As Mono.Cecil.TypeReference = varC.ArrayVariable.ExpressionType
                     Dim elementtype As Mono.Cecil.TypeReference = CecilHelper.GetElementType(arrtype)
                     Dim isnonprimitivevaluetype As Boolean = CecilHelper.IsPrimitive(Compiler, elementtype) = False AndAlso CecilHelper.IsValueType(elementtype)
 
                     result = varC.ArrayVariable.GenerateCode(Info.Clone(Me, True, False, arrtype)) AndAlso result
 
                     Dim methodtypes As New Generic.List(Of Mono.Cecil.TypeReference)
 
                     Dim elementInfo As EmitInfo = Info.Clone(Me, True, False, Compiler.TypeCache.System_Int32)
                     For i As Integer = 0 To varC.Arguments.Count - 1
                         result = varC.Arguments(i).GenerateCode(elementInfo) AndAlso result
                         Emitter.EmitConversion(varC.Arguments(i).Expression.ExpressionType, Compiler.TypeCache.System_Int32, Info)
                         methodtypes.Add(Compiler.TypeCache.System_Int32)
                     Next
 
                     Dim rInfo As EmitInfo = Info.Clone(Me, True, False, elementtype)
                     methodtypes.Add(elementtype)
 
                     If CecilHelper.GetArrayRank(arrtype) = 1 Then
                         If isnonprimitivevaluetype Then
                             Emitter.EmitLoadElementAddress(Info, elementtype, arrtype)
                             'result = Info.RHSExpression.Classification.GenerateCode(rInfo) AndAlso result
                             'Emitter.EmitStoreObject(Info, elementtype)
                         Else
                             Emitter.EmitLoadElementAddress(Info, elementtype, arrtype)
                             'result = Info.RHSExpression.Classification.GenerateCode(rInfo) AndAlso result
                             'Emitter.EmitStoreElement(Info, elementtype, arrtype)
                         End If
                     Else
                         Dim method As Mono.Cecil.MethodReference = ArrayElementInitializer.GetAddressMethod(Compiler, arrtype)
                         Emitter.EmitCallVirt(Info, method)
                     End If
                 ElseIf varC.Expression IsNot Nothing Then
                     If TypeOf varC.Expression Is MeExpression Then
                         Dim local As Mono.Cecil.Cil.VariableDefinition
                         local = Emitter.DeclareLocal(Info, varC.Expression.ExpressionType)
                         Emitter.EmitLoadMe(Info, varC.Expression.ExpressionType)
                         Emitter.EmitStoreVariable(Info, local)
                         Emitter.EmitLoadVariableLocation(refInfo, local)
                     ElseIf TypeOf varC.Expression Is GetRefExpression AndAlso varC.Expression IsNot Me Then
                         result = varC.Expression.GenerateCode(Info) AndAlso result
                     Else
                         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
                     End If
                 ElseIf varC.Method IsNot Nothing Then
                     If varC.Method.DefaultReturnVariable Is Nothing Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
                     Else
                         Emitter.EmitLoadVariableLocation(refInfo, varC.Method.DefaultReturnVariable)
                     End If
                 Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
                 End If
             Case ExpressionClassification.Classifications.Value
                 result = m_Expression.GenerateCode(Info.Clone(Me, m_Expression.ExpressionType)) AndAlso result
 
                 Dim local As Mono.Cecil.Cil.VariableDefinition
                 local = Emitter.DeclareLocal(Info, m_Expression.ExpressionType)
                 Emitter.EmitStoreVariable(Info, local)
                 Emitter.EmitLoadVariableLocation(Info, local)
             Case ExpressionClassification.Classifications.PropertyAccess
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             Case ExpressionClassification.Classifications.MethodPointer
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             Case Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeConverter.vb" startline="1083" endline="1138">
<![CDATA[
 
     Public Shared Function ConvertToDateTime(ByVal Context As ParsedObject, ByVal Source As Object, ByVal SourceTypeCode As TypeCode, ByRef result As Object, ByVal ShowErrors As Boolean) As Boolean
         Select Case SourceTypeCode
             Case TypeCode.Boolean
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Boolean", "Date")
             Case TypeCode.Byte
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Byte", "Date")
             Case TypeCode.Char
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Char", "Date")
             Case TypeCode.DateTime
                 result = Source
                 Return True
             Case TypeCode.Decimal
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Decimal", "Date")
             Case TypeCode.Double
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30533, Context.Location)
             Case TypeCode.Int16
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Short", "Date")
             Case TypeCode.Int32
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Integer", "Date")
             Case TypeCode.Int64
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Long", "Date")
             Case TypeCode.SByte
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "SByte", "Date")
             Case TypeCode.Single
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "Single", "Date")
             Case TypeCode.String
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30060, Context.Location, "String", "Date")
             Case TypeCode.UInt16
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "UShort", "Date")
             Case TypeCode.UInt32
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "UInteger", "Date")
             Case TypeCode.UInt64
                 If ShowErrors = False Then Return False
                 Return Context.Compiler.Report.ShowMessage(Messages.VBNC30311, Context.Location, "ULong", "Date")
             Case TypeCode.DBNull
                 If ShowErrors = False Then Return False
                 result = New Date()
                 Return True
         End Select
         If ShowErrors = False Then Return False
         Return Context.Compiler.Report.ShowMessage(Messages.VBNC30439, Context.Location, "Date")
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="662" endline="681">
<![CDATA[
 
     Private Function IsAlphaCharacter(ByVal chr As Char) As Boolean
         'AlphaCharacter 
         Select Case Char.GetUnicodeCategory(chr) 'Alpha Character
             Case Globalization.UnicodeCategory.UppercaseLetter 'Lu
                 Return True
             Case Globalization.UnicodeCategory.LowercaseLetter 'Ll
                 Return True
             Case Globalization.UnicodeCategory.TitlecaseLetter  'Lt
                 Return True
             Case Globalization.UnicodeCategory.ModifierLetter 'Lm
                 Return True
             Case Globalization.UnicodeCategory.OtherLetter 'Lo
                 Return True
             Case Globalization.UnicodeCategory.LetterNumber 'Nl
                 Return True
             Case Else
                 Return False
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\TryCastExpression.vb" startline="132" endline="223">
<![CDATA[
     End Property
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         If m_NonArrayTypeName IsNot Nothing Then result = m_NonArrayTypeName.ResolveCode(Info) AndAlso result
         If m_ArgumentList IsNot Nothing Then result = m_ArgumentList.ResolveCode(Info) AndAlso result
 
         Helper.Assert(m_ResolvedType IsNot Nothing)
         If m_IsDelegateCreationExpression = False Then
             If TypeOf m_ResolvedType Is Mono.Cecil.GenericParameter = False Then
                 m_IsDelegateCreationExpression = Helper.CompareType(CecilHelper.FindDefinition(m_ResolvedType).BaseType, Compiler.TypeCache.System_MulticastDelegate)
             End If
         End If
 
         If m_ArgumentList IsNot Nothing Then
             result = m_ArgumentList.ResolveCode(Info) AndAlso result
         Else
             m_ArgumentList = New ArgumentList(Me)
         End If
 
         If result = False Then Return result
 
         If m_IsDelegateCreationExpression Then
             Dim type As Mono.Cecil.TypeReference = m_ResolvedType
             If m_ArgumentList.Count <> 1 Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC32008, Me.Location, type.FullName) AndAlso result
             End If
             If result AndAlso m_ArgumentList(0).Expression.Classification.IsMethodPointerClassification = False Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC32008, Me.Location, type.FullName) AndAlso result
             End If
             If result Then
                 result = m_ArgumentList(0).Expression.ResolveAddressOfExpression(type, True) AndAlso result
                 Classification = New ValueClassification(Me, type)
             End If
         Else
             Dim resolvedType As Mono.Cecil.TypeReference = m_ResolvedType
             Dim isCoClass As Boolean = False
 
             If CecilHelper.IsInterface(resolvedType) Then
                 Dim coClass As TypeReference = Helper.GetCoClassType(Compiler, resolvedType)
                 If coClass Is Nothing Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC30375, Me.Location)
                 Else
                     m_ResolvedType = coClass
                     resolvedType = m_ResolvedType
 
                     If CecilHelper.IsValueType(resolvedType) = False AndAlso CecilHelper.IsClass(resolvedType) = False Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC31094, Me.Location, resolvedType.Name)
                     End If
 
                     Dim ctors As Mono.Collections.Generic.Collection(Of MethodReference)
                     ctors = CecilHelper.GetConstructors(resolvedType)
                     If ctors Is Nothing OrElse ctors.Count = 0 Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC30251, Me.Location, resolvedType.Name)
                     End If
                     isCoClass = True
                 End If
             End If
 
             If isCoClass = False AndAlso CecilHelper.IsValueType(resolvedType) AndAlso m_ArgumentList.Count = 0 Then
                 'Nothing to resolve. A structure with no parameters can always be created.
                 m_IsValueTypeInitializer = True
             ElseIf CecilHelper.IsGenericParameter(resolvedType) Then
                 If m_ArgumentList.Count > 0 Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC32085, Me.Location)
                 End If
                 If (CecilHelper.GetGenericParameterAttributes(resolvedType) And Mono.Cecil.GenericParameterAttributes.DefaultConstructorConstraint) = 0 AndAlso (CecilHelper.GetGenericParameterAttributes(resolvedType) And Mono.Cecil.GenericParameterAttributes.NotNullableValueTypeConstraint) = 0 Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC32046, Me.Location)
                 End If
                 m_IsGenericConstructor = True
             ElseIf CecilHelper.IsClass(resolvedType) OrElse CecilHelper.IsValueType(resolvedType) Then
                 Dim ctors As Mono.Collections.Generic.Collection(Of Mono.Cecil.MethodReference)
 
                 ctors = CecilHelper.GetConstructors(resolvedType)
                 m_MethodClassification = New MethodGroupClassification(Me, Nothing, Nothing, Nothing, ctors)
                 result = m_MethodClassification.AsMethodGroupClassification.ResolveGroup(m_ArgumentList, , False) AndAlso result
                 If result = False Then
                     'Show the error
                     result = m_MethodClassification.AsMethodGroupClassification.ResolveGroup(m_ArgumentList, True, False) AndAlso result
                 Else
                     result = m_ArgumentList.ReplaceAndVerifyArguments(m_MethodClassification.FinalArguments, m_MethodClassification.ResolvedMethod, True) AndAlso result
                 End If
             Else
                 Compiler.Report.ShowMessage(Messages.VBNC99999, Me.Location, String.Format("Delegate type {0} is neither ValueType, GenericParameter nor Class. This is a problem in the compiler, please file a bug report here
             End If
 
             Classification = New ValueClassification(Me, resolvedType)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="3779" endline="3850">
<![CDATA[
 
     Shared Function CompareType(ByVal t1 As Mono.Cecil.TypeReference, ByVal t2 As Mono.Cecil.TypeReference) As Boolean
         If t1 Is t2 Then Return True
         If t1 Is Nothing OrElse t2 Is Nothing Then Return False
 
         Dim g1 As Mono.Cecil.GenericParameter = TryCast(t1, Mono.Cecil.GenericParameter)
         Dim g2 As Mono.Cecil.GenericParameter = TryCast(t2, Mono.Cecil.GenericParameter)
 
         If g1 IsNot Nothing AndAlso g2 IsNot Nothing Then
             Return Helper.CompareNameOrdinal(g1.Name, g2.Name) AndAlso Helper.Compare(g1.Owner, g2.Owner)
         ElseIf g1 IsNot Nothing Xor g2 IsNot Nothing Then
             Return False
         End If
 
         Dim gi1 As Mono.Cecil.GenericInstanceType = TryCast(t1, Mono.Cecil.GenericInstanceType)
         Dim gi2 As Mono.Cecil.GenericInstanceType = TryCast(t2, Mono.Cecil.GenericInstanceType)
 
         If gi1 IsNot Nothing AndAlso gi2 IsNot Nothing Then
             If gi1 Is gi2 Then Return True
             If Not Helper.CompareType(gi1.GetElementType, gi2.GetElementType) Then Return False
             If gi1.GenericArguments.Count <> gi2.GenericArguments.Count Then Return False
             For i As Integer = 0 To gi1.GenericArguments.Count - 1
                 If Helper.CompareType(gi1.GenericArguments(i), gi2.GenericArguments(i)) = False Then
                     Return False
                 End If
             Next
             Helper.Assert(gi1.FullName = gi2.FullName)
             Return True
         ElseIf gi1 IsNot Nothing Xor gi2 IsNot Nothing Then
             Return False
         End If
 
         Dim a1 As Mono.Cecil.ArrayType = TryCast(t1, Mono.Cecil.ArrayType)
         Dim a2 As Mono.Cecil.ArrayType = TryCast(t2, Mono.Cecil.ArrayType)
         If a1 IsNot Nothing AndAlso a2 IsNot Nothing Then
             If a1.Dimensions.Count <> a2.Dimensions.Count Then Return False
             For i As Integer = 0 To a1.Dimensions.Count - 1
                 If a1.Dimensions(i).LowerBound.HasValue Xor a2.Dimensions(i).LowerBound.HasValue Then Return False
                 If a1.Dimensions(i).UpperBound.HasValue Xor a2.Dimensions(i).UpperBound.HasValue Then Return False
 
                 If a1.Dimensions(i).LowerBound.HasValue AndAlso a2.Dimensions(i).LowerBound.HasValue Then
                     If a1.Dimensions(i).LowerBound.Value <> a2.Dimensions(i).LowerBound.Value Then Return False
                 End If
 
                 If a1.Dimensions(i).UpperBound.HasValue AndAlso a2.Dimensions(i).UpperBound.HasValue Then
                     If a1.Dimensions(i).UpperBound.Value <> a2.Dimensions(i).UpperBound.Value Then Return False
                 End If
             Next
             Return CompareType(a1.ElementType, a2.ElementType)
         ElseIf a1 IsNot Nothing Xor a2 IsNot Nothing Then
             'Only one of them is an array
             Return False
         End If
 
         Dim r1 As ByReferenceType = TryCast(t1, ByReferenceType)
         Dim r2 As ByReferenceType = TryCast(t2, ByReferenceType)
         If r1 IsNot Nothing AndAlso r2 IsNot Nothing Then
             Return Helper.CompareType(r1.ElementType, r2.ElementType)
         ElseIf r1 IsNot Nothing Xor r2 IsNot Nothing Then
             Return False
         End If
 
         If t1.IsNested AndAlso t2.IsNested AndAlso CompareType(t1.DeclaringType, t2.DeclaringType) = False Then
             Return False
         End If
 
         If CecilHelper.FindDefinition(t1) Is CecilHelper.FindDefinition(t2) Then Return True
         If t1.FullName IsNot Nothing AndAlso t2.FullName IsNot Nothing AndAlso Helper.CompareNameOrdinal(t1.FullName, t2.FullName) Then Return True
         Helper.Assert(t1.FullName.Equals(t2.FullName) = False)
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="632" endline="644">
<![CDATA[
 
     Private Function IsSeparatorCharacter(ByVal chr As Char) As Boolean
         'Separator 
         Return chr = "("c OrElse _
                 chr = ")"c OrElse _
                 chr = "{"c OrElse _
                 chr = "}"c OrElse _
                 chr = "!"c OrElse _
                 chr = "#"c OrElse _
                 chr = ","c OrElse _
                 chr = "."c OrElse _
                 chr = "
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="3499" endline="3515">
<![CDATA[
 
     Private Function MinToSec(ByVal Min As String) As Double
 
         Dim Temp As String()
 
         Temp = Split(Min, "
 
         Select Case UBound(Temp)
             Case 0
                 Return Val(Temp(0))
             Case 1
                 Return (Val(Temp(0)) * 60) + Val(Temp(1))
             Case 2
                 Return (Val(Temp(0)) * 3600) + (Val(Temp(1)) * 60) + Val(Temp(2))
         End Select
 
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="54" endline="96">
<![CDATA[
 
     Shared Sub New()
     Private Shared m_ImplicitlyConvertedIntrinsicTypes As New Generic.Dictionary(Of Mono.Cecil.TypeReference, TypeCode())
 
     Shared Function GetIntrinsicTypesImplicitlyConvertibleFrom(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As TypeCode()
         Dim result As TypeCode() = Nothing
 
         If m_ImplicitlyConvertedIntrinsicTypes.TryGetValue(Type, result) Then
             Return result
         End If
 
         If Helper.CompareType(Type, Compiler.TypeCache.System_Char_Array) Then
             result = New TypeCode() {TypeCode.String}
         End If
 
         If result IsNot Nothing Then
             m_ImplicitlyConvertedIntrinsicTypes.Add(Type, result)
         End If
 
         Return result
     End Function
 
     Shared Sub New()
         Dim highest As Integer
 
         Dim tmp As Array = System.Enum.GetValues(GetType(TypeCode))
         highest = CInt(tmp.GetValue(tmp.GetUpperBound(0)))
 
         ReDim Conversion(highest, highest)
         For i As Integer = 0 To highest
             For j As Integer = 0 To highest
                 Conversion(i, j) = New TypeConversionInfo
                 If j = TypeCode.Object OrElse j = i Then
                     Conversion(i, j).Conversion = ConversionType.Implicit
                 ElseIf i = TypeCode.Char OrElse j = TypeCode.Char Then
                     Conversion(i, j).Conversion = ConversionType.None
                 ElseIf i = TypeCode.DateTime OrElse j = TypeCode.DateTime Then
                     Conversion(i, j).Conversion = ConversionType.None
                 ElseIf i = TypeCode.DBNull OrElse j = TypeCode.DBNull Then
                     Conversion(i, j).Conversion = ConversionType.None
                 Else
                     Conversion(i, j).Conversion = ConversionType.Explicit
                 End If
             Next
         Next
 
         setImplicit(TypeCode.SByte, New TypeCode() {TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.Byte, New TypeCode() {TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.Int16, New TypeCode() {TypeCode.Int32, TypeCode.Int64, TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.UInt16, New TypeCode() {TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.Int32, New TypeCode() {TypeCode.Int64, TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.UInt32, New TypeCode() {TypeCode.Int64, TypeCode.UInt64, TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.Int64, New TypeCode() {TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.UInt64, New TypeCode() {TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.Decimal, New TypeCode() {TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.Single, New TypeCode() {TypeCode.Double})
         setImplicit(TypeCode.Double, New TypeCode() {})
         setImplicit(TypeCode.Char, New TypeCode() {TypeCode.String})
         setImplicit(TypeCode.DBNull, New TypeCode() {TypeCode.String})
 
         Conversion(TypeCode.DateTime, TypeCode.String).Conversion = ConversionType.Explicit
         Conversion(TypeCode.Byte, TypeCode.Byte).BinaryAddResult = TypeCode.Byte
         Conversion(TypeCode.Boolean, TypeCode.Boolean).BinaryAddResult = TypeCode.SByte
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="271" endline="329">
<![CDATA[
 
     Function DoOperatorOverloading(ByVal ShowErrors As Boolean) As Boolean
         Dim result As Boolean = True
         Dim methods As New Generic.List(Of Mono.Cecil.MethodReference)
         Dim methodClassification As MethodGroupClassification
         Dim arguments As ArgumentList
 
         If Me.Keyword = KS.AndAlso OrElse Me.Keyword = KS.OrElse Then
             If ShowErrors Then
                 If Me.Keyword = KS.AndAlso AndAlso (Me.LeftTypeCode = TypeCode.DBNull OrElse Me.RightTypeCode = TypeCode.DBNull) Then
                     Compiler.Report.ShowMessage(Messages.VBNC30452, Location, "And", Helper.ToString(Compiler, Me.LeftType), Helper.ToString(Compiler, Me.RightType))
                 ElseIf Me.Keyword = KS.OrElse AndAlso (Me.LeftTypeCode = TypeCode.DBNull OrElse Me.RightTypeCode = TypeCode.DBNull) Then
                     Compiler.Report.ShowMessage(Messages.VBNC30452, Location, "Or", Helper.ToString(Compiler, Me.LeftType), Helper.ToString(Compiler, Me.RightType))
                 Else
                     Compiler.Report.ShowMessage(Messages.VBNC30452, Location, Enums.strSpecial(Me.Keyword), Helper.ToString(Compiler, Me.LeftType), Helper.ToString(Compiler, Me.RightType))
                 End If
             End If
             Return False
         End If
 
         If Me.Keyword = KS.Minus Then
             'This is a special case, because Date has a custom - operator that takes (Date, Date), and both string and object
             'are implicitly convertible to Date, so if we don't special case it we'll end up using that operator
             If (Me.LeftTypeCode = TypeCode.String OrElse Helper.CompareType(Me.LeftType, Compiler.TypeCache.System_Object)) AndAlso Me.RightTypeCode = TypeCode.DateTime Then
                 If ShowErrors Then
                     Compiler.Report.ShowMessage(Messages.VBNC30452, Location, "-", Helper.ToString(Compiler, Me.LeftType), Helper.ToString(Compiler, Me.RightType))
                 End If
                 Return False
             ElseIf Me.LeftTypeCode = TypeCode.DateTime AndAlso (Me.RightTypeCode = TypeCode.String OrElse Helper.CompareType(Me.RightType, Compiler.TypeCache.System_Object)) Then
                 If ShowErrors Then
                     Compiler.Report.ShowMessage(Messages.VBNC30452, Location, "-", Helper.ToString(Compiler, Me.LeftType), Helper.ToString(Compiler, Me.RightType))
                 End If
                 Return False
             End If
         End If
 
         methods = Helper.GetBinaryOperators(Compiler, CType(Me.Keyword, BinaryOperators), Me.LeftType)
         If Helper.CompareType(Me.LeftType, Me.RightType) = False Then
             Dim methods2 As New Generic.List(Of Mono.Cecil.MethodReference)
             methods2 = Helper.GetBinaryOperators(Compiler, CType(Me.Keyword, BinaryOperators), Me.RightType)
             For Each method As Mono.Cecil.MethodReference In methods2
                 If methods.Contains(method) = False Then methods.Add(method)
             Next
         End If
         If methods.Count = 0 Then
             If ShowErrors Then Compiler.Report.ShowMessage(Messages.VBNC30452, Me.Location, Enums.strSpecial(Me.Keyword), Helper.ToString(Compiler, Me.LeftType), Helper.ToString(Compiler, Me.RightType))
             Return False
         End If
         methodClassification = New MethodGroupClassification(Me, Nothing, Nothing, New Expression() {Me.m_LeftExpression, Me.m_RightExpression}, methods.ToArray)
         arguments = New ArgumentList(Me, Me.m_LeftExpression, m_RightExpression)
         result = methodClassification.ResolveGroup(arguments, ShowErrors, False) AndAlso result
         result = methodClassification.SuccessfullyResolved AndAlso result
         If result = False Then Return result
         result = methodClassification.VerifyGroup(arguments, ShowErrors) AndAlso result
         If result = False Then Return result
         m_ExpressionType = methodClassification.ResolvedMethodInfo.ReturnType
         Classification = methodClassification
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="1412" endline="1507">
<![CDATA[
 
     ''' <summary>
     ''' Parses type members for classes, modules and structures.
     ''' Never returns nothing.
     ''' </summary>
     ''' <param name="Parent"></param>
     ''' <remarks></remarks>
     Private Function ParseTypeMembers(ByVal Parent As TypeDeclaration) As Boolean
         Dim result As Boolean = True
         Dim isModuleDeclaration As Boolean = TypeOf Parent Is ModuleDeclaration
 
         Helper.Assert(TypeOf Parent Is ClassDeclaration OrElse isModuleDeclaration OrElse TypeOf Parent Is StructureDeclaration)
 
         Dim newMembers As New Generic.List(Of IMember)
         While True
             Dim attributes As Attributes = Nothing
 
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(Parent, attributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             Dim newType As TypeDeclaration
             newType = ParseTypeDeclaration(Parent, attributes, Parent.Namespace)
             If newType IsNot Nothing Then
                 Parent.Members.Add(newType)
                 Continue While
             End If
 
             Dim newMember As IMember
 
             'Class and Structure declarations
             If isModuleDeclaration = False AndAlso OperatorDeclaration.IsMe(tm) Then
                 newMember = ParseOperatorDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf isModuleDeclaration = False AndAlso ConversionOperatorDeclaration.IsMe(tm) Then
                 newMember = ParseConversionOperatorDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 'Class, Structure and Module declarations
             ElseIf RegularEventDeclaration.IsMe(tm) Then
                 newMember = ParseRegularEventDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf CustomEventDeclaration.IsMe(tm) Then
                 newMember = ParseCustomEventMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf VariableDeclaration.IsMe(tm) Then
                 Dim tmp As Generic.List(Of TypeVariableDeclaration)
                 tmp = ParseTypeVariableMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If tmp Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 For Each item As TypeVariableDeclaration In tmp
                     newMembers.Add(item)
                 Next
                 newMember = Nothing
             ElseIf ConstantDeclaration.IsMe(tm) Then
                 Dim tmp As Generic.List(Of ConstantDeclaration)
                 tmp = ParseConstantMemberDeclarations(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If tmp Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 For Each item As ConstantDeclaration In tmp
                     newMembers.Add(item)
                 Next
                 newMember = Nothing
             ElseIf ExternalSubDeclaration.IsMe(tm) Then
                 newMember = ParseExternalSubDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf ExternalFunctionDeclaration.IsMe(tm) Then
                 newMember = ParseExternalFunctionDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf SubDeclaration.IsMe(tm) Then
                 newMember = ParseSubDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf FunctionDeclaration.IsMe(tm) Then
                 newMember = ParseFunctionDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf RegularPropertyDeclaration.IsMe(tm) Then
                 newMember = ParseRegularPropertyMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf MustOverridePropertyDeclaration.IsMe(tm) Then
                 newMember = ParseMustOverridePropertyMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf ConstructorDeclaration.IsMe(tm) Then
                 newMember = ParseConstructorMember(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 If attributes IsNot Nothing AndAlso attributes.Count > 0 Then
                     Helper.AddError(Compiler, tm.CurrentLocation, "Hanging attributes.")
                 End If
                 Exit While
             End If
 
             If newMember IsNot Nothing Then newMembers.Add(newMember)
             If newMembers.Count = 0 Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Parent.Members.AddRange(newMembers)
             newMembers.Clear()
         End While
         While True
             Dim attributes As Attributes = Nothing
 
             If vbnc.Attributes.IsMe(tm) Then
                 If ParseAttributes(Parent, attributes) = False Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             End If
 
             Dim newType As TypeDeclaration
             newType = ParseTypeDeclaration(Parent, attributes, Parent.Namespace)
             If newType IsNot Nothing Then
                 Parent.Members.Add(newType)
                 Continue While
             End If
 
             Dim newMember As IMember
 
             'Class and Structure declarations
             If isModuleDeclaration = False AndAlso OperatorDeclaration.IsMe(tm) Then
                 newMember = ParseOperatorDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf isModuleDeclaration = False AndAlso ConversionOperatorDeclaration.IsMe(tm) Then
                 newMember = ParseConversionOperatorDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 'Class, Structure and Module declarations
             ElseIf RegularEventDeclaration.IsMe(tm) Then
                 newMember = ParseRegularEventDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf CustomEventDeclaration.IsMe(tm) Then
                 newMember = ParseCustomEventMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf VariableDeclaration.IsMe(tm) Then
                 Dim tmp As Generic.List(Of TypeVariableDeclaration)
                 tmp = ParseTypeVariableMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If tmp Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 For Each item As TypeVariableDeclaration In tmp
                     newMembers.Add(item)
                 Next
                 newMember = Nothing
             ElseIf ConstantDeclaration.IsMe(tm) Then
                 Dim tmp As Generic.List(Of ConstantDeclaration)
                 tmp = ParseConstantMemberDeclarations(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If tmp Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 For Each item As ConstantDeclaration In tmp
                     newMembers.Add(item)
                 Next
                 newMember = Nothing
             ElseIf ExternalSubDeclaration.IsMe(tm) Then
                 newMember = ParseExternalSubDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf ExternalFunctionDeclaration.IsMe(tm) Then
                 newMember = ParseExternalFunctionDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf SubDeclaration.IsMe(tm) Then
                 newMember = ParseSubDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf FunctionDeclaration.IsMe(tm) Then
                 newMember = ParseFunctionDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf RegularPropertyDeclaration.IsMe(tm) Then
                 newMember = ParseRegularPropertyMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf MustOverridePropertyDeclaration.IsMe(tm) Then
                 newMember = ParseMustOverridePropertyMemberDeclaration(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             ElseIf ConstructorDeclaration.IsMe(tm) Then
                 newMember = ParseConstructorMember(Parent, New ParseAttributableInfo(Compiler, attributes))
                 If newMember Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Else
                 If attributes IsNot Nothing AndAlso attributes.Count > 0 Then
                     Helper.AddError(Compiler, tm.CurrentLocation, "Hanging attributes.")
                 End If
                 Exit While
             End If
 
             If newMember IsNot Nothing Then newMembers.Add(newMember)
             If newMembers.Count = 0 Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
             Parent.Members.AddRange(newMembers)
             newMembers.Clear()
         End While
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="2852" endline="2964">
<![CDATA[
 
 #End Region
 
 #Region "   Tabs - Joining "
 
     Private Sub ToolBar1_ButtonClick(ByVal sender As System.Object, ByVal e As System.Windows.Forms.ToolBarButtonClickEventArgs) Handles tbJoin.ButtonClick
 
         Select Case DirectCast(e.Button.Tag, String)
             Case "Open"
                 OpenFilesForJoining()
 
             Case "Join"
                 If lvFiles.Items.Count = 0 Then Exit Sub
 
                 Dim fi As New FileInfo(lvFiles.Items(0).Text)
                 mInFile = fi.FullName
                 If Not CreateHandler(fi.Extension) Then Exit Sub
                 mPlayer.URL = ""
 
                 UpdateHandlerOptions()
 
                 dlgSaveFile.InitialDirectory = dlgOpenFile.InitialDirectory
                 dlgSaveFile.DefaultExt = mHandler.Extension
                 dlgSaveFile.FileName = ""
                 dlgSaveFile.Filter = mHandler.Extension(True) + " |*" + mHandler.Extension
 
                 If dlgSaveFile.ShowDialog() = Windows.Forms.DialogResult.OK Then
                     Me.Refresh()
                     Dim Filename As String = dlgSaveFile.FileName
 
                     Dim Temp As String()
                     With lvFiles
                         ReDim Temp(.Items.Count - 1)
                         For i As Integer = 0 To .Items.Count - 1
                             Temp(i) = .Items(i).Text
                         Next
 
                         statMain.Text = Replace(mTranslator.LangText(38), "{%1}", CStr(.Items.Count))
                         'statMain.Text = "Joining " + CStr(.Items.Count) + " files. Please wait..."
 
                         mainTabs.SelectedTab = tabTrace
                         rtfTrace.SelectedText = vbCrLf
 
                         If chkKeepMRU.Checked Then rtfTrace.Clear()
 
                         If mHandler.Join(Temp, Filename) Then
                             UpdateRTF(vbCrLf & "Success!!" & vbCrLf, _
                                 modMain.MessageType.Success)
                             ShowProcessStat(modMain.MessageType.Success)
                             If chkDel.Checked Then
                                 'Send all the files to the recycle bin
                                 For i As Integer = 0 To lvFiles.Items.Count - 1
                                     TrashFile(Temp(i))
                                 Next
                             End If
                         Else
                             UpdateRTF(vbCrLf + "Joining Failed !!" & vbCrLf, _
                                 modMain.MessageType.Failure)
                             ShowProcessStat(modMain.MessageType.Failure)
                         End If
                     End With
                     statMain.Text = mTranslator.LangText(23)
                     If chkBeep.Checked Then Beep()
                 End If
 
             Case "Remove"
                 If lvFiles.Items.Count = 0 Then Exit Sub
                 'Dim DoomedItems As ListView.SelectedListViewItemCollection
                 'DoomedItems = lvFiles.SelectedItems
                 For Each Item As ListViewItem In lvFiles.SelectedItems
                     lvFiles.Items.Remove(Item)
                 Next
 
             Case "Sort"
                 Dim TempIn As String()
                 With lvFiles
                     ReDim TempIn(.Items.Count - 1)
                     For i As Integer = 0 To .Items.Count - 1
                         TempIn(i) = .Items(i).Text
                     Next
                     Array.Sort(TempIn)
                     .Items.Clear()
                     For i As Integer = 0 To UBound(TempIn)
                         .Items.Add(TempIn(i))
                     Next
                 End With
 
             Case "Clear"
                 lvFiles.Items.Clear()
 
             Case "Up"
                 'Move files up
                 If lvFiles.Items.Count = 0 Then Exit Sub
                 If lvFiles.SelectedItems.Count = 0 Then Exit Sub
                 MoveItemsUp(lvFiles)
 
             Case "Dn"
                 'Move files down
                 If lvFiles.Items.Count = 0 Then Exit Sub
                 If lvFiles.SelectedItems.Count = 0 Then Exit Sub
                 MoveItemsDn(lvFiles)
 
             Case "Info"
                 With lvFiles
                     If .Items.Count = 0 Then Exit Sub
                     Dim fi As New FileInfo(lvFiles.Items(0).Text)
                     If Not CreateHandler(fi.Extension) Then Exit Sub
                     mainTabs.SelectedTab = tabTrace
                     mHandler.ShowInfo(GetSelectedFilenames)
                 End With
         End Select
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="3040" endline="3160">
<![CDATA[
 
     Private Function ParseIdentifier(ByVal Info As ExpressionParseInfo) As Expression
         Dim value As Expression = Nothing
         Dim result As Boolean = True
 
         If tm.CurrentToken.IsLiteral Then
             value = ParseLiteralExpression(Info.Parent)
             If value Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         ElseIf tm.CurrentToken = KS.Dot Then
             value = ParseMemberAccessExpression(Info.Parent, Nothing)
             If value Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         ElseIf tm.CurrentToken = KS.Exclamation Then
             value = ParseDictionaryAccessExpression(Info.Parent, Nothing)
             If value Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         ElseIf tm.CurrentToken.Equals(Enums.BuiltInTypeTypeNames) Then
             value = ParseBuiltInTypeExpression(Info.Parent)
             If value Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         ElseIf tm.CurrentToken.IsIdentifier Then
             value = ParseSimpleNameExpression(Info.Parent)
             If value Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         ElseIf tm.CurrentToken = KS.LBrace Then
             value = ParseArrayInitializerExpression(Info.Parent)
             If value Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         ElseIf tm.CurrentToken = KS.LParenthesis Then
             value = ParseParenthesizedExpression(Info.Parent)
             If value Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         ElseIf tm.CurrentToken.Equals(KS.Add, KS.Minus) Then
             value = ParseUnaryPlusMinus(Info)
             If value Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         ElseIf tm.CurrentToken.IsKeyword Then
             Select Case tm.CurrentToken.Keyword
                 Case KS.Not
                     value = ParseNot(Info)
                 Case KS.DirectCast, KS.TryCast, KS.CType
                     value = ParseCTypeExpression(Info.Parent, tm.CurrentToken.Keyword)
                 Case KS.AddressOf
                     value = ParseAddressOfExpression(Info.Parent)
                 Case KS.[New]
                     value = ParseNewExpression(Info.Parent)
                 Case KS.CInt
                     value = ParseCIntExpression(Info.Parent)
                 Case KS.CBool
                     value = ParseCBoolExpression(Info.Parent)
                 Case KS.CByte
                     value = ParseCByteExpression(Info.Parent)
                 Case KS.CChar
                     value = ParseCCharExpression(Info.Parent)
                 Case KS.CDate
                     value = ParseCDateExpression(Info.Parent)
                 Case KS.CDbl
                     value = ParseCDblExpression(Info.Parent)
                 Case KS.CDec
                     value = ParseCDecExpression(Info.Parent)
                 Case KS.CLng
                     value = ParseCLngExpression(Info.Parent)
                 Case KS.CObj
                     value = ParseCObjExpression(Info.Parent)
                 Case KS.CSByte
                     value = ParseCSByteExpression(Info.Parent)
                 Case KS.CShort
                     value = ParseCShortExpression(Info.Parent)
                 Case KS.CSng
                     value = ParseCSngExpression(Info.Parent)
                 Case KS.CStr
                     value = ParseCStrExpression(Info.Parent)
                 Case KS.CUInt
                     value = ParseCUIntExpression(Info.Parent)
                 Case KS.CULng
                     value = ParseCULngExpression(Info.Parent)
                 Case KS.CUShort
                     value = ParseCUShortExpression(Info.Parent)
                 Case KS.True, KS.False
                     value = ParseBooleanLiteralExpression(Info.Parent)
                 Case KS.Nothing
                     tm.AcceptIfNotInternalError(KS.Nothing)
                     value = New NothingConstantExpression(Info.Parent)
                 Case KS.GetType
                     value = ParseGetTypeExpression(Info.Parent)
                 Case KS.TypeOf
                     value = ParseTypeOfExpression(Info.Parent)
                 Case KS.Me
                     value = ParseMeExpression(Info.Parent)
                 Case KS.MyBase
                     value = ParseMyBaseExpression(Info.Parent)
                 Case KS.MyClass
                     value = ParseMyClassExpression(Info.Parent)
                 Case KS.Global
                     Dim newGlobal As GlobalExpression
                     newGlobal = ParseGlobalExpression(Info.Parent)
                     value = ParseMemberAccessExpression(Info.Parent, newGlobal)
                 Case KS.If
                     value = ParseIfExpression(Info.Parent)
             End Select
         Else
             value = Nothing
         End If
 
         Do While result
             If tm.CurrentToken = KS.Dot Then
                 Dim newExp As MemberAccessExpression
                 newExp = ParseMemberAccessExpression(Info.Parent, value)
                 value = newExp
             ElseIf tm.CurrentToken = KS.Exclamation Then
                 Dim newExp As DictionaryAccessExpression
                 newExp = ParseDictionaryAccessExpression(Info.Parent, value)
                 value = newExp
             ElseIf tm.CurrentToken = KS.LParenthesis Then
                 If tm.PeekToken.IsIntegerLiteral AndAlso tm.PeekToken.IntegralLiteral = 0 AndAlso tm.PeekToken(2).Equals(KS.To) Then
                     Exit Do
                 End If
                 Dim newExp As InvocationOrIndexExpression
                 newExp = ParseInvocationOrIndexExpression(Info.Parent, value)
                 value = newExp
             Else
                 Exit Do
             End If
             If value Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Loop
         Do While result
             If tm.CurrentToken = KS.Dot Then
                 Dim newExp As MemberAccessExpression
                 newExp = ParseMemberAccessExpression(Info.Parent, value)
                 value = newExp
             ElseIf tm.CurrentToken = KS.Exclamation Then
                 Dim newExp As DictionaryAccessExpression
                 newExp = ParseDictionaryAccessExpression(Info.Parent, value)
                 value = newExp
             ElseIf tm.CurrentToken = KS.LParenthesis Then
                 If tm.PeekToken.IsIntegerLiteral AndAlso tm.PeekToken.IntegralLiteral = 0 AndAlso tm.PeekToken(2).Equals(KS.To) Then
                     Exit Do
                 End If
                 Dim newExp As InvocationOrIndexExpression
                 newExp = ParseInvocationOrIndexExpression(Info.Parent, value)
                 value = newExp
             Else
                 Exit Do
             End If
             If value Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
         Loop
 
         Return value
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Types\TypeImplementsClauses.vb" startline="235" endline="405">
<![CDATA[
 
     Private Function ResolveQualifiedNameInternal(ByVal Qualifier As TypeNameResolutionInfo, ByVal R As String, ByVal ShowError As Boolean, ByVal TypeArgumentCount As Integer) As Boolean
         '---------------------------------------------------------------------------------------------------------
         '*************************************** Qualified Name Resolution '**************************************
         '---------------------------------------------------------------------------------------------------------
         '* Given a qualified namespace or type name of the form N.R, where R is the rightmost identifier in the 
         '* qualified name, the following steps describe how to determine to which namespace or type the qualified 
         '* Name(refers)
         '**	Resolve N, which may be either a qualified or unqualified name.
         '**	If resolution of N fails, resolves to a type parameter, or does not resolve to a namespace or type, a
         '**  compile-time error occurs. If R matches the name of a namespace or type in N, then the qualified name 
         '** refers to that namespace or type.
         '**	If N contains one or more standard modules, and R matches the name of a type in exactly one standard 
         '** module, then the qualified name refers to that type. If R matches the name of types in more than one 
         '** standard module, a compile-time error occurs.
         '**	Otherwise, a compile-time error occurs. 
         ' * Note   An implication of this resolution process is that type members do not shadow namespaces or types 
         ' * when resolving namespace or type names.
         '---------------------------------------------------------------------------------------------------------
 
         Me.m_Qualifier = Qualifier
 
         If Qualifier.FoundOnlyOneObject Then
             Dim modules As TypeList = Nothing
             If Qualifier.IsGlobal Then
                 'Helper.NotImplemented()
                 If CheckOutermostNamespace(R, TypeArgumentCount) Then Return True
             ElseIf Qualifier.FoundIs(Of [Namespace])() OrElse Qualifier.FoundIs(Of ImportsClause)() Then
                 'Helper.NotImplemented()
                 '** If R matches the name of a namespace or type in N, 
                 '** then the qualified name refers to that namespace or type.
                 Dim strNS As String
 
                 If Qualifier.FoundIs(Of [Namespace])() Then
                     Dim ns As [Namespace]
                     ns = Qualifier.FoundAs(Of [Namespace])()
                     strNS = ns.FullName
                 ElseIf Qualifier.FoundIs(Of ImportsClause)() Then
                     Dim ic As ImportsClause
                     ic = Qualifier.FoundAs(Of ImportsClause)()
                     If ic.IsAliasClause Then
                         Dim ac As ImportsAliasClause = ic.AsAliasClause
                         If ac.NamespaceClause.IsNamespaceImport Then
                             Dim ns As [Namespace]
                             ns = ac.NamespaceClause.NamespaceImported
                             strNS = ns.FullName
                         ElseIf ac.NamespaceClause.IsTypeImport Then
                             strNS = ac.NamespaceClause.TypeImported.FullName
                         Else
                             Throw New InternalException(FromWhere)
                         End If
                     Else
                         Throw New InternalException(FromWhere)
                     End If
                 Else
                     Throw New InternalException(FromWhere)
                 End If
 
                 Dim nsp As [Namespace]
                 nsp = FromWhere.Compiler.TypeManager.Namespaces.FindNamespace(strNS, R)
                 If nsp IsNot Nothing Then
                     m_FoundObjects.Add(nsp)
                     Return True
                 End If
 
                 Dim types As TypeDictionary
                 types = FromWhere.Compiler.TypeManager.TypesByNamespace(strNS)
                 If types IsNot Nothing AndAlso types.Count > 0 Then
                     Dim genericName As String
                     genericName = vbnc.Helper.CreateGenericTypename(R, TypeArgumentCount)
 
                     'Dim typesByName As Generic.List(Of Mono.Cecil.TypeReference) = Nothing
                     'Dim tmp As Boolean
                     'tmp = FromWhere.Compiler.TypeManager.TypesByName.TryGetValue(genericName, typesByName)
 
                     For Each tp As Mono.Cecil.TypeReference In types.Values
                         'If TypeOf tp Is TypeDescriptor Then
                         If Helper.CompareName(tp.Name, genericName) Then
                             m_FoundObjects.Add(tp)
                         End If
                         'Else
                         'If typesByName IsNot Nothing AndAlso typesByName.Contains(tp) Then
                         '    m_FoundObjects.Add(tp)
                         'End If
                         'End If
                     Next
                     'Return True
                 End If
 
                 '**	If N contains one or more standard modules, and R matches the name of a type in 
                 '** exactly one standard module, then the qualified name refers to that type. If R 
                 '** matches the name of types in more than one standard module, a compile-time error occurs.
                 If m_FoundObjects.Count = 0 Then
                     Dim dic As TypeDictionary = FromWhere.Compiler.TypeManager.GetModulesByNamespace(strNS)
                     If dic IsNot Nothing Then
                         modules = dic.ToTypeList
                     Else
                         modules = Nothing
                     End If
                     'Return True
                 End If
 
                 'Throw New InternalException("(1) Could not resolve
 
                 'Return False
             ElseIf Qualifier.FoundIs(Of IType)() Then
                 '** If R matches the name of a namespace or type in N, 
                 '** then the qualified name refers to that namespace or type.
                 Dim tp As IType = Qualifier.FoundAs(Of IType)()
                 Dim types As Generic.List(Of IType) = tp.Members.GetSpecificMembers(Of IType)()
                 For Each t As IType In types
                     If Helper.CompareName(t.Name, R) Then
                         m_FoundObjects.Add(t)
                     End If
                 Next
 
                 '**	If N contains one or more standard modules, and R matches the name of a type in 
                 '** exactly one standard module, then the qualified name refers to that type. If R 
                 '** matches the name of types in more than one standard module, a compile-time error occurs.
                 If m_FoundObjects.Count = 0 Then
                     modules = Helper.CreateList(tp.Members.GetSpecificMembers(Of ModuleDeclaration)())
                 End If
             ElseIf Qualifier.FoundIs(Of Mono.Cecil.TypeReference)() Then
                 '** If R matches the name of a namespace or type in N, 
                 '** then the qualified name refers to that namespace or type.
                 Dim tp As Mono.Cecil.TypeReference = Qualifier.FoundAs(Of Mono.Cecil.TypeReference)()
                 Dim nestedtp As Mono.Cecil.TypeReference = CecilHelper.GetNestedType(tp, Helper.CreateGenericTypename(R, TypeArgumentCount))
 
                 If nestedtp IsNot Nothing Then m_FoundObjects.Add(nestedtp)
 
                 '**	If N contains one or more standard modules, and R matches the name of a type in 
                 '** exactly one standard module, then the qualified name refers to that type. If R 
                 '** matches the name of types in more than one standard module, a compile-time error occurs.
                 If m_FoundObjects.Count = 0 Then
                     Return Name.Compiler.Report.ShowMessage(Messages.VBNC30002, Name.Location, tp.FullName.Replace("/"c, "."c) & "." & R)
                 End If
             Else
                 '**	If resolution of N fails, resolves to a type parameter, or does not resolve to a namespace 
                 '** or type, a compile-time error occurs.  (..)
                 If ShowError = False Then Return False
                 'Helper.AddError("(2) Could not resolve
                 Return Name.Compiler.Report.ShowMessage(Messages.VBNC99997, Name.Location)
             End If
 
             '**	If N contains one or more standard modules, and R matches the name of a type in 
             '** exactly one standard module, then the qualified name refers to that type. If R 
             '** matches the name of types in more than one standard module, a compile-time error occurs.
 
             If modules IsNot Nothing AndAlso modules.Count > 0 AndAlso CheckModules(modules, R, TypeArgumentCount) Then Return True
 
             If m_FoundObjects.Count = 0 Then
                 If ShowError = False Then Return False
 
                 If Not IsImportsResolution Then FromWhere.Compiler.Report.ShowMessage(Messages.VBNC30456, FromWhere.Location, R, Qualifier.FoundObject.ToString)
                 Return False
             ElseIf m_FoundObjects.Count > 1 Then
                 If ShowError = False Then Return False
                 Helper.AddError(Name, "Found " & m_FoundObjects.Count.ToString & " members in type or namespace '" & Qualifier.FoundObject.ToString & "'")
                 Return False
             Else
                 Return True
             End If
         Else
             '**	If resolution of N fails, (...)
             If ShowError = False Then Return False
             Helper.AddError(Name, "Qualifying member '" & Qualifier.m_Qualifier.FoundObject.ToString & "' resolves to '" & Qualifier.FoundObjects.Count.ToString & " objects" & "(R = " & R & ")")
             Return False
         End If
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\Main.vb" startline="114" endline="121">
<![CDATA[
     End Property
 
     '*********************** Constructor ***********************
     Public Sub New()
         __StartSpecified = True
         __FinishSpecified = True
         RepeatNum = String.Empty
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\CMPT890\CS VB JS examples\Examples\VB.NET\examples\Chap0209.vb" startline="45" endline="55">
<![CDATA[
     Public Shared Sub Main(ByVal args As String())
         Console.WriteLine("Chapter 8 example 1
 
         Dim document As New com.lowagie.text.Document()
         Dim FileOutputStream As java.io.FileOutputStream
         FileOutputStream = New java.io.FileOutputStream("Chap0801.rtf")
         RtfWriter.getInstance(document, FileOutputStream)
         document.open()
         document.add(New Paragraph("Hello World"))
         document.close()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="1146" endline="1153">
<![CDATA[
 
     Public Shared Function GetGenericParameterAttributes(ByVal Type As TypeReference) As GenericParameterAttributes
         Dim gt As Mono.Cecil.GenericParameter
 
         gt = DirectCast(Type, Mono.Cecil.GenericParameter)
 
         Return gt.Attributes
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="235" endline="411">
<![CDATA[
 
     ''' <summary>
     ''' Emit code for
     ''' For i As Integer = 0 ...
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Private Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim conditionLabel As Label
         Dim startlabel As Label
         Dim loopCounter As LoopCounterData
         Dim loopMax As Mono.Cecil.Cil.VariableDefinition
         Dim loopStart As Mono.Cecil.Cil.VariableDefinition
         Dim loopStep As Mono.Cecil.Cil.VariableDefinition
         Dim loopLateBoundObject As Mono.Cecil.Cil.VariableDefinition = Nothing
         Dim loadInfo As EmitInfo
 
         conditionLabel = Emitter.DefineLabel(Info)
         startlabel = Emitter.DefineLabel(Info)
         EndLabel = Emitter.DefineLabel(Info)
         m_NextIteration = Emitter.DefineLabel(Info)
 
         loadInfo = Info.Clone(Me, True, False, m_LoopType)
 
         'Create the localbuilder
         If m_LoopControlVariable.IsVariableDeclaration Then
             result = m_LoopControlVariable.GenerateCode(Info) AndAlso result
             loopCounter = New LoopCounterData(m_LoopControlVariable.GetVariableDeclaration.LocalBuilder, LoopCounterTypes.Local)
         Else
             Dim varClass As VariableClassification
             varClass = m_LoopControlVariable.Expression.Classification.AsVariableClassification
             If varClass.LocalBuilder IsNot Nothing Then
                 loopCounter = New LoopCounterData(varClass.LocalBuilder, LoopCounterTypes.Local)
             ElseIf varClass.FieldInfo IsNot Nothing Then
                 loopCounter = New LoopCounterData(varClass.FieldInfo, LoopCounterTypes.Field, varClass.InstanceExpression)
             Else
                 Throw New InternalException()
             End If
         End If
 
         loopMax = Emitter.DeclareLocal(Info, m_LoopType, "maxvar$" & Me.ObjectID.ToString)
         loopStep = Emitter.DeclareLocal(Info, m_LoopType, "stepvar$" & Me.ObjectID.ToString)
         loopStart = Emitter.DeclareLocal(Info, m_LoopType, "startvar$" & Me.ObjectID.ToString)
         If m_IsLateBound Then
             loopLateBoundObject = Emitter.DeclareLocal(Info, Compiler.TypeCache.System_Object, "loopobj$" & Me.ObjectID.ToString)
         End If
 
         'Load the initial expression
         result = m_LoopStartExpression.GenerateCode(loadInfo) AndAlso result
         Emitter.EmitStoreVariable(Info, loopStart)
 
         'Store the initial expression in the counter
         EmitStoreCounterInstanceExpression(Info, loopCounter)
         Emitter.EmitLoadVariable(Info, loopStart)
         EmitStoreCounter(Info, loopCounter)
 
         'Load the max expression
         result = m_LoopEndExpression.GenerateCode(loadInfo) AndAlso result
         Emitter.EmitStoreVariable(Info, loopMax)
 
         'Load the step expression
         result = m_LoopStepExpression.GenerateCode(loadInfo) AndAlso result
         Emitter.EmitStoreVariable(Info, loopStep)
 
         'Jump to the comparison
         If m_IsLateBound Then
             EmitLoadCounter(Info, loopCounter)
             'Emitter.EmitLoadVariable(Info, loopCounter)
             Emitter.EmitLoadVariable(Info, loopStart)
             Emitter.EmitLoadVariable(Info, loopMax)
             Emitter.EmitLoadVariable(Info, loopStep)
             Emitter.EmitLoadVariableLocation(Info, loopLateBoundObject)
             EmitLoadAddressCounter(Info, loopCounter)
             'Emitter.EmitLoadVariableLocation(Info, loopCounter)
             Emitter.EmitCall(Info, Compiler.TypeCache.MS_VB_CS_ObjectFlowControl_ForLoopControl__ForLoopInitObj_Object_Object_Object_Object_Object_Object)
             Emitter.EmitBranchIfFalse(Info, EndLabel)
         Else
             Emitter.EmitBranch(Info, conditionLabel)
         End If
 
         'Emit the contained code.
         Emitter.MarkLabel(Info, startlabel)
         result = CodeBlock.GenerateCode(Info) AndAlso result
 
         'This is the start of the next iteration
         Emitter.MarkLabel(Info, m_NextIteration)
 
         If m_IsLateBound Then
             EmitLoadCounter(Info, loopCounter)
             'Emitter.EmitLoadVariable(Info, loopCounter)
             Emitter.EmitLoadVariable(Info, loopLateBoundObject)
             EmitLoadAddressCounter(Info, loopCounter)
             'Emitter.EmitLoadVariableLocation(Info, loopCounter)
             Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_ObjectFlowControl_ForLoopControl__ForNextCheckObj_Object_Object_Object)
             Emitter.EmitBranchIfTrue(Info, startlabel)
         ElseIf m_IsDecimal Then
             EmitStoreCounterInstanceExpression(Info, loopCounter)
             EmitLoadCounter(Info, loopCounter) 'Emitter.EmitLoadVariable(Info, loopCounter)
             Emitter.EmitLoadVariable(Info, loopStep)
             Emitter.EmitCall(Info, Info.Compiler.TypeCache.System_Decimal__Add_Decimal_Decimal)
             EmitStoreCounter(Info, loopCounter)
 
             'Do the comparison
             Emitter.MarkLabel(Info, conditionLabel)
 
             'Load the current value
             EmitLoadCounter(Info, loopCounter)
             'Emitter.EmitLoadVariable(Info, loopCounter)
 
             'Load the max value
             Emitter.EmitLoadVariable(Info, loopMax)
 
             'Load the step value
             Emitter.EmitLoadVariable(Info, loopStep)
 
             'Compare the values
             Emitter.EmitCall(Info, Info.Compiler.TypeCache.MS_VB_CS_ObjectFlowControl_ForLoopControl__ForNextCheckDec_Decimal_Decimal_Decimal)
             Emitter.EmitBranchIfTrue(Info, startlabel)
         Else
             EmitStoreCounterInstanceExpression(Info, loopCounter)
             EmitLoadCounter(Info, loopCounter) 'Emitter.EmitLoadVariable(Info, loopCounter)
             Emitter.EmitLoadVariable(Info, loopStep)
             Emitter.EmitAdd(Info, m_LoopType)
             EmitStoreCounter(Info, loopCounter) 'Emitter.EmitStoreVariable(Info, loopCounter)
 
             'Do the comparison
             Emitter.MarkLabel(Info, conditionLabel)
 
             'Load the current value
             EmitLoadCounter(Info, loopCounter) 'Emitter.EmitLoadVariable(Info, loopCounter)
 
             'Load the max value
             Emitter.EmitLoadVariable(Info, loopMax)
 
             'Compare the values
             If IsKnownStep() Then
                 If IsPositiveStep() Then
                     Emitter.EmitLE(Info, m_LoopType)
                     Emitter.EmitBranchIfTrue(Info, startlabel)
                 ElseIf IsNegativeStep() Then
                     Emitter.EmitGE(Info, m_LoopType)
                     Emitter.EmitBranchIfTrue(Info, startlabel)
                 Else
                     Helper.AddError(Me, "Infinite loop")
                 End If
             Else
                 Dim negativeLabel As Label
                 Dim endCheck As Label
 
                 negativeLabel = Emitter.DefineLabel(Info)
                 endCheck = Emitter.DefineLabel(Info)
 
                 Emitter.EmitLoadVariable(Info, loopStep)
                 Dim tmp As Object = Nothing
                 If TypeConverter.ConvertTo(Me, 0, m_LoopType, tmp, True) Then
                     Emitter.EmitLoadValue(Info.Clone(Me, True, False, m_LoopType), tmp)
                 Else
                     Throw New InternalException
                 End If
                 Emitter.EmitGE(Info, m_LoopType) 'stepvar >= 0?
                 Info.ILGen.Emit(Mono.Cecil.Cil.OpCodes.Brfalse_S, negativeLabel)
                 Emitter.EmitLE(Info, m_LoopType) 'Positive check
                 Emitter.EmitBranch(Info, endCheck)
                 Emitter.MarkLabel(Info, negativeLabel)
                 Emitter.EmitGE(Info, m_LoopType) 'Negative check
                 Emitter.MarkLabel(Info, endCheck)
                 Emitter.EmitBranchIfTrue(Info, startlabel)
             End If
         End If
 
         Emitter.MarkLabel(Info, EndLabel)
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\My Project\Settings.Designer.vb" startline="30" endline="36">
<![CDATA[
 
     <Global.System.Diagnostics.DebuggerNonUserCodeAttribute(), Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)> _
     Private Shared Sub AutoSaveSettings(ByVal sender As Global.System.Object, ByVal e As Global.System.EventArgs)
         If My.Application.SaveMySettingsOnExit Then
             My.Settings.Save()
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="157" endline="163">
<![CDATA[
     End Property
 
     Sub New(ByVal Parent As AddressOfExpression, ByVal MethodGroup As MethodGroupClassification)
         MyBase.new(Classifications.MethodPointer, Parent)
         Helper.Assert(MethodGroup IsNot Nothing)
         m_MethodGroup = MethodGroup
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="617" endline="631">
<![CDATA[
 
     Private Function IsOperatorCharacter(ByVal chr As Char) As Boolean
         'Operator 
         Return chr = "&"c OrElse _
                 chr = "*"c OrElse _
                 chr = "+"c OrElse _
                 chr = "-"c OrElse _
                 chr = "/"c OrElse _
                 chr = "\"c OrElse _
                 chr = "^"c OrElse _
                 chr = "<"c OrElse _
                 chr = "="c OrElse _
                 chr = ">"c
         chr = "
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="126" endline="140">
<![CDATA[
 
     Sub New(ByVal Parent As ParsedObject, ByVal Type As Object)
         Me.new(Parent)
         If TypeOf Type Is Mono.Cecil.TypeDefinition Then
             m_Type = DirectCast(Type, Mono.Cecil.TypeDefinition)
             'ElseIf TypeOf Type Is Type Then
             '    m_Type = DirectCast(Type, Type) ' New TypeDescriptor(DirectCast(Type, Type))
         ElseIf TypeOf Type Is TypeDeclaration Then
             m_Type = DirectCast(Type, TypeDeclaration).CecilType
         ElseIf TypeOf Type Is TypeParameter Then
             m_TypeParameter = DirectCast(Type, TypeParameter)
         Else
             Throw New InternalException(Me)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="177" endline="215">
<![CDATA[
 
     Shared Function BuiltInTypeToTypeCode(ByVal Type As BuiltInDataTypes) As TypeCode
         Select Case Type
             Case BuiltInDataTypes.Boolean
                 Return TypeCode.Boolean
             Case BuiltInDataTypes.Byte
                 Return TypeCode.Byte
             Case BuiltInDataTypes.Char
                 Return TypeCode.Char
             Case BuiltInDataTypes.Date
                 Return TypeCode.DateTime
             Case BuiltInDataTypes.Decimal
                 Return TypeCode.Decimal
             Case BuiltInDataTypes.Double
                 Return TypeCode.Double
             Case BuiltInDataTypes.Integer
                 Return TypeCode.Int32
             Case BuiltInDataTypes.Long
                 Return TypeCode.Int64
             Case BuiltInDataTypes.Object
                 Return TypeCode.Object
             Case BuiltInDataTypes.SByte
                 Return TypeCode.SByte
             Case BuiltInDataTypes.Short
                 Return TypeCode.Int16
             Case BuiltInDataTypes.Single
                 Return TypeCode.Single
             Case BuiltInDataTypes.String
                 Return TypeCode.String
             Case BuiltInDataTypes.UInteger
                 Return TypeCode.UInt32
             Case BuiltInDataTypes.ULong
                 Return TypeCode.UInt64
             Case BuiltInDataTypes.UShort
                 Return TypeCode.UInt16
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="263" endline="301">
<![CDATA[
 
     Private Shared Function getTypeIndex(ByVal special As BuiltInDataTypes) As Integer
         Select Case special
             Case BuiltInDataTypes.Boolean
                 Return 0
             Case BuiltInDataTypes.Byte
                 Return 1
             Case BuiltInDataTypes.Char
                 Return 2
             Case BuiltInDataTypes.Date
                 Return 3
             Case BuiltInDataTypes.Decimal
                 Return 4
             Case BuiltInDataTypes.Double
                 Return 5
             Case BuiltInDataTypes.Integer
                 Return 6
             Case BuiltInDataTypes.Long
                 Return 7
             Case BuiltInDataTypes.Object
                 Return 8
             Case BuiltInDataTypes.[SByte]
                 Return 9
             Case BuiltInDataTypes.Short
                 Return 10
             Case BuiltInDataTypes.Single
                 Return 11
             Case BuiltInDataTypes.String
                 Return 12
             Case BuiltInDataTypes.[UInteger]
                 Return 13
             Case BuiltInDataTypes.[ULong]
                 Return 14
             Case BuiltInDataTypes.[UShort]
                 Return 15
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="302" endline="340">
<![CDATA[
 
     Shared Function KeywordToTypeCode(ByVal Keyword As KS) As TypeCode
         Select Case Keyword
             Case KS.Boolean
                 Return TypeCode.Boolean
             Case KS.Byte
                 Return TypeCode.Byte
             Case KS.Char
                 Return TypeCode.Char
             Case KS.Date
                 Return TypeCode.DateTime
             Case KS.Decimal
                 Return TypeCode.Decimal
             Case KS.Double
                 Return TypeCode.Double
             Case KS.Integer
                 Return TypeCode.Int32
             Case KS.Long
                 Return TypeCode.Int64
             Case KS.Object
                 Return TypeCode.Object
             Case KS.Single
                 Return TypeCode.Single
             Case KS.Short
                 Return TypeCode.Int16
             Case KS.String
                 Return TypeCode.String
             Case KS.SByte
                 Return TypeCode.SByte
             Case KS.UShort
                 Return TypeCode.UInt16
             Case KS.UInteger
                 Return TypeCode.UInt32
             Case KS.ULong
                 Return TypeCode.UInt64
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="134" endline="176">
<![CDATA[
 
     Shared Function TypeCodeToBuiltInType(ByVal tp As TypeCode) As BuiltInDataTypes
         Select Case tp
             Case TypeCode.Boolean
                 Return BuiltInDataTypes.Boolean
             Case TypeCode.Byte
                 Return BuiltInDataTypes.Byte
             Case TypeCode.Char
                 Return BuiltInDataTypes.Char
             Case TypeCode.DateTime
                 Return BuiltInDataTypes.Date
             Case TypeCode.DBNull
                 Throw New InternalException("")
             Case TypeCode.Decimal
                 Return BuiltInDataTypes.Decimal
             Case TypeCode.Double
                 Return BuiltInDataTypes.Double
             Case TypeCode.Empty
                 Throw New InternalException("")
             Case TypeCode.Int16
                 Return BuiltInDataTypes.Short
             Case TypeCode.Int32
                 Return BuiltInDataTypes.Integer
             Case TypeCode.Int64
                 Return BuiltInDataTypes.Long
             Case TypeCode.Object
                 Return BuiltInDataTypes.Object
             Case TypeCode.SByte
                 Return BuiltInDataTypes.SByte
             Case TypeCode.Single
                 Return BuiltInDataTypes.Single
             Case TypeCode.String
                 Return BuiltInDataTypes.String
             Case TypeCode.UInt16
                 Return BuiltInDataTypes.UShort
             Case TypeCode.UInt32
                 Return BuiltInDataTypes.UInteger
             Case TypeCode.UInt64
                 Return BuiltInDataTypes.ULong
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\ExpressionList.vb" startline="420" endline="541">
<![CDATA[
 
     Public Overrides Function ResolveStatement(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         result = m_LoopControlVariable.ResolveCode(Info) AndAlso result
         result = m_LoopStartExpression.ResolveExpression(Info) AndAlso result
         result = m_LoopEndExpression.ResolveExpression(Info) AndAlso result
 
         If result = False Then Return result
 
         If m_LoopControlVariable.MustInfer = False AndAlso m_LoopControlVariable.Expression IsNot Nothing Then
             If m_LoopControlVariable.Expression.Classification.IsVariableClassification = False Then
                 Select Case m_LoopControlVariable.Expression.Classification.Classification
                     Case ExpressionClassification.Classifications.Type
                         If Me.IsOptionInferOn Then
                             m_LoopControlVariable.MustInfer = True
                         Else
                             Return Compiler.Report.ShowMessage(Messages.VBNC30108, Me.Location, m_LoopControlVariable.Identifier.Identifier)
                         End If
                     Case ExpressionClassification.Classifications.PropertyAccess, ExpressionClassification.Classifications.PropertyGroup, ExpressionClassification.Classifications.LateBoundAccess
                         Return Compiler.Report.ShowMessage(Messages.VBNC30039, Me.Location) AndAlso result
                     Case ExpressionClassification.Classifications.Value
                         Return Helper.ShowClassificationError(Compiler, Me.Location, m_LoopControlVariable.Expression.Classification, "Variable") AndAlso result
                     Case Else
                         Return Helper.ShowClassificationError(Compiler, Me.Location, m_LoopControlVariable.Expression.Classification, "Variable") AndAlso result
                 End Select
             End If
         End If
 
         If m_LoopStepExpression IsNot Nothing Then
             result = m_LoopStepExpression.ResolveExpression(Info) AndAlso result
             If Not m_LoopStepExpression.Classification.CanBeValueClassification Then
                 result = m_LoopStepExpression.ReportReclassifyToValueErrorMessage()
             Else
                 m_LoopStepExpression = m_LoopStepExpression.ReclassifyToValueExpression()
                 result = m_LoopStepExpression.ResolveExpression(Info) AndAlso result
             End If
         End If
 
         If Not m_LoopStartExpression.Classification.CanBeValueClassification Then
             result = m_LoopStartExpression.ReportReclassifyToValueErrorMessage()
         Else
             m_LoopStartExpression = m_LoopStartExpression.ReclassifyToValueExpression()
             result = m_LoopStartExpression.ResolveExpression(Info) AndAlso result
         End If
 
         If Not m_LoopEndExpression.Classification.CanBeValueClassification Then
             result = m_LoopEndExpression.ReportReclassifyToValueErrorMessage()
         Else
             m_LoopEndExpression = m_LoopEndExpression.ReclassifyToValueExpression()
             result = m_LoopEndExpression.ResolveExpression(Info) AndAlso result
         End If
 
         If result = False Then Return result
 
         If m_LoopControlVariable.MustInfer Then
             Dim start_type As TypeReference = m_LoopStartExpression.ExpressionType
             Dim end_type As TypeReference = m_LoopEndExpression.ExpressionType
             Dim step_type As TypeReference = If(m_LoopStepExpression IsNot Nothing, m_LoopStepExpression.ExpressionType, Nothing)
 
             m_LoopType = Compiler.TypeResolution.GetWidestType(start_type, end_type, step_type)
             If m_LoopType Is Nothing Then
                 Compiler.Report.ShowMessage(Messages.VBNC30983, Me.Location, m_LoopControlVariable.Identifier.Identifier)
                 Return False
             End If
 
             m_LoopControlVariable.CreateInferredVariable(m_LoopType)
         Else
             m_LoopType = m_LoopControlVariable.VariableType
         End If
 
         If m_LoopStepExpression Is Nothing Then
             If m_LoopControlVariable.MustInfer Then
                 m_LoopStepExpression = New ConstantExpression(Me, 1, m_LoopType)
                 result = m_LoopStepExpression.ResolveExpression(Info) AndAlso result
                 If Helper.IsEnum(Compiler, m_LoopType) Then
                     m_LoopStepExpression = New CTypeExpression(Me, m_LoopStepExpression, m_LoopType)
                     result = m_LoopStepExpression.ResolveExpression(Info) AndAlso result
                 End If
             Else
                 m_LoopStepExpression = New ConstantExpression(Me, 1, Compiler.TypeCache.System_Int32)
                 result = m_LoopStepExpression.ResolveExpression(Info) AndAlso result
             End If
         End If
 
         Select Case Helper.GetTypeCode(Compiler, m_LoopType)
             Case TypeCode.Boolean, TypeCode.Char, TypeCode.DBNull, TypeCode.Empty, TypeCode.String
                 Return Compiler.Report.ShowMessage(Messages.VBNC30337, Location, m_LoopType.Name)
             Case TypeCode.Decimal
                 m_IsLateBound = False
                 m_IsDecimal = True
             Case TypeCode.Byte, TypeCode.Double, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.SByte, TypeCode.Single, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 m_IsLateBound = False
             Case TypeCode.Object
                 m_IsLateBound = True
 
                 Compiler.Helper.AddCheck("The loop control variable of a For statement must be of a primitive numeric type (...), Object, or a type T that has the following operators
 
             Case Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC30337, Location, m_LoopType.Name)
         End Select
 
         'If m_NextExpressionList IsNot Nothing Then result = m_NextExpressionList.ResolveCode(info) AndAlso result
         m_LoopStepExpression = Helper.CreateTypeConversion(Me, m_LoopStepExpression, m_LoopType, result)
         m_LoopStartExpression = Helper.CreateTypeConversion(Me, m_LoopStartExpression, m_LoopType, result)
         m_LoopEndExpression = Helper.CreateTypeConversion(Me, m_LoopEndExpression, m_LoopType, result)
 
         If m_LoopControlVariable.IsVariableDeclaration Then
             CodeBlock.Variables.Add(m_LoopControlVariable.GetVariableDeclaration)
         End If
 
         result = CodeBlock.ResolveCode(Info) AndAlso result
 
         If result = False Then Return result
 
         Compiler.Helper.AddCheck("Check that loop variable has not been used in another for statement.")
         Compiler.Helper.AddCheck("The bound and step expressions must be implicitly convertible to the type of the loop control. ")
         Compiler.Helper.AddCheck("If a variable matches a For loop that is not the most nested loop at that point, a compile-time error results")
         Compiler.Helper.AddCheck("It is not valid to branch into a For loop from outside the loop.")
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="929" endline="1069">
<![CDATA[
 
     ''' <summary>
     ''' Tries to convert the value into the desired type. Returns true if successful, 
     ''' returns false otherwise. Can only convert if value is already an integral type 
     ''' (does only do range-checking, not type conversion)
     ''' </summary>
     ''' <param name="value"></param>
     ''' <param name="result"></param>
     ''' <param name="desiredType"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function CheckIntegralRange(ByVal value As Object, ByRef result As Object, ByVal desiredType As BuiltInDataTypes) As Boolean
         Helper.Assert(value IsNot Nothing)
         Helper.Assert(IsIntegralType(desiredType))
         Dim tpValue As TypeCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, value))
         Helper.Assert(IsIntegralType(tpValue))
         Select Case tpValue
             Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                 Dim tmpValue As ULong = CULng(value)
                 Select Case desiredType
                     Case BuiltInDataTypes.Byte
                         If tmpValue <= Byte.MaxValue Then
                             result = CByte(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case BuiltInDataTypes.UShort
                         If tmpValue <= UShort.MaxValue Then
                             result = CUShort(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case BuiltInDataTypes.UInteger
                         If tmpValue <= UInteger.MaxValue Then
                             result = CUInt(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case BuiltInDataTypes.ULong
                         result = tmpValue
                         Return True
                     Case BuiltInDataTypes.SByte
                         If tmpValue <= SByte.MaxValue Then
                             result = CSByte(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case BuiltInDataTypes.Short
                         If tmpValue <= Short.MaxValue Then
                             result = CShort(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case BuiltInDataTypes.Integer
                         If tmpValue <= Integer.MaxValue Then
                             result = CInt(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case BuiltInDataTypes.Long
                         If tmpValue <= Long.MaxValue Then
                             result = CLng(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case Else
                         Throw New InternalException("")
                 End Select
             Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                 Dim tmpValue As Long = CLng(value)
                 Select Case desiredType
                     Case BuiltInDataTypes.Byte
                         If tmpValue >= Byte.MinValue AndAlso tmpValue <= Byte.MaxValue Then
                             result = CByte(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case BuiltInDataTypes.UShort
                         If tmpValue >= UShort.MinValue AndAlso tmpValue <= UShort.MaxValue Then
                             result = CUShort(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case BuiltInDataTypes.UInteger
                         If tmpValue >= UInteger.MinValue AndAlso tmpValue <= UInteger.MaxValue Then
                             result = CUInt(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case BuiltInDataTypes.ULong
                         If tmpValue >= ULong.MinValue AndAlso tmpValue <= ULong.MaxValue Then
                             result = CULng(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case BuiltInDataTypes.SByte
                         If tmpValue >= SByte.MinValue AndAlso tmpValue <= SByte.MaxValue Then
                             result = CSByte(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case BuiltInDataTypes.Short
                         If tmpValue >= Short.MinValue AndAlso tmpValue <= Short.MaxValue Then
                             result = CShort(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case BuiltInDataTypes.Integer
                         If tmpValue >= Integer.MinValue AndAlso tmpValue <= Integer.MaxValue Then
                             result = CInt(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case BuiltInDataTypes.Long
                         If tmpValue >= Long.MinValue AndAlso tmpValue <= Long.MaxValue Then
                             result = CLng(tmpValue)
                             Return True
                         Else
                             Return False
                         End If
                     Case Else
                         Throw New InternalException("")
                 End Select
             Case Else
                 Throw New InternalException("")
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="4876" endline="4978">
<![CDATA[
 
     Public Shared Function VerifyConstraints(ByVal Context As ParsedObject, ByVal parameters As Mono.Collections.Generic.Collection(Of GenericParameter), ByVal arguments As Mono.Collections.Generic.Collection(Of TypeReference), ByVal ShowErrors As Boolean) As Boolean
         Dim result As Boolean = True
 
         For i As Integer = 0 To Math.Min(parameters.Count, arguments.Count) - 1
             Dim param As GenericParameter = parameters(i)
             Dim arg As TypeReference = arguments(i)
             Dim gt As GenericParameter = TryCast(arg, GenericParameter)
 
             If param.HasDefaultConstructorConstraint Then
                 If gt IsNot Nothing Then
                     If gt.HasDefaultConstructorConstraint = False AndAlso gt.HasNotNullableValueTypeConstraint = False Then
                         Dim tr As TypeReference = TryCast(param.Owner, TypeReference)
                         If ShowErrors Then
                             If Helper.CompareType(tr, Context.Compiler.TypeCache.System_Nullable1) Then
                                 result = Context.Compiler.Report.ShowMessage(Messages.VBNC33101, Context.Location, Helper.ToString(Context, arg))
                             Else
                                 result = Context.Compiler.Report.ShowMessage(Messages.VBNC32084, Context.Location, Helper.ToString(Context, arg), param.Name)
                             End If
                         End If
                         result = False
                         Continue For
                     End If
                 Else
                     Dim ctor As MethodReference = Helper.GetDefaultConstructor(arg)
                     If (ctor Is Nothing OrElse Helper.IsPublic(ctor) = False) AndAlso CecilHelper.IsValueType(arg) = False Then
                         If ShowErrors Then Context.Compiler.Report.ShowMessage(Messages.VBNC32083, Context.Location, Helper.ToString(Context, arg), param.Name)
                         result = False
                         Continue For
                     End If
                 End If
             End If
 
             If param.HasNotNullableValueTypeConstraint Then
                 If gt Is Nothing Then
                     If CecilHelper.IsValueType(arg) = False Then
                         If ShowErrors Then Context.Compiler.Report.ShowMessage(Messages.VBNC32105, Context.Location, Helper.ToString(Context, arg), param.Name)
                         result = False
                     End If
                 Else
                     If gt.HasNotNullableValueTypeConstraint = False Then
                         If ShowErrors Then Context.Compiler.Report.ShowMessage(Messages.VBNC32105, Context.Location, Helper.ToString(Context, arg), param.Name)
                         result = False
                     End If
                 End If
             End If
 
             If param.HasReferenceTypeConstraint Then
                 If gt IsNot Nothing Then
                     If gt.HasReferenceTypeConstraint = False Then
                         If ShowErrors Then Context.Compiler.Report.ShowMessage(Messages.VBNC32106, Context.Location, Helper.ToString(Context, arg), param.Name)
                         result = False
                     End If
                 Else
                     If CecilHelper.IsClass(arg) = False Then
                         If ShowErrors Then Context.Compiler.Report.ShowMessage(Messages.VBNC32106, Context.Location, Helper.ToString(Context, arg), param.Name)
                         result = False
                     End If
                 End If
             End If
 
             If param.HasConstraints Then
                 For c As Integer = 0 To param.Constraints.Count - 1
                     Dim constr As TypeReference = param.Constraints(i)
 
                     If param.HasNotNullableValueTypeConstraint AndAlso Helper.CompareType(constr, Context.Compiler.TypeCache.System_ValueType) Then Continue For
                     If Helper.CompareType(constr, arg) Then Continue For
 
                     If gt Is Nothing Then
                         If Helper.IsInterface(Context, constr) Then
                             If Helper.DoesTypeImplementInterface(Context, arg, constr) = False Then
                                 If ShowErrors Then Context.Compiler.Report.ShowMessage(Messages.VBNC32044, Context.Location, Helper.ToString(Context, arg), Helper.ToString(Context, constr))
                                 result = False
                             End If
                         Else
                             If Helper.IsSubclassOf(constr, arg) = False Then
                                 If ShowErrors Then Context.Compiler.Report.ShowMessage(Messages.VBNC32044, Context.Location, Helper.ToString(Context, arg), Helper.ToString(Context, constr))
                                 result = False
                             End If
                         End If
                     Else
                         Dim found As Boolean = False
 
                         For c2 As Integer = 0 To gt.Constraints.Count - 1
                             If Helper.CompareType(constr, gt.Constraints(c2)) Then
                                 found = True
                                 Exit For
                             End If
                             If Helper.DoesTypeImplementInterface(Context, gt.Constraints(c2), constr) Then
                                 found = True
                                 Exit For
                             End If
                         Next
                         If found = False Then
                             If ShowErrors Then Context.Compiler.Report.ShowMessage(Messages.VBNC32044, Context.Location, Helper.ToString(Context, arg), Helper.ToString(Context, constr))
                             result = False
                         End If
                     End If
                 Next
             End If
         Next
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Compiler.vb" startline="432" endline="593">
<![CDATA[
 
     ''' <summary>
     ''' Compile with the current options.
     ''' </summary>
     ''' <remarks></remarks>
     Function Compile() As Integer
         Dim result As Boolean = True
         BaseObject.ClearCache()
         Try
             'Show help if asked to
             If CommandLine.Help = True Then
                 If CommandLine.NoLogo = False Then
                     ShowLogo()
                 End If
                 ShowHelp()
                 Return 0
             End If
 
             'Show logo, unless asked not to
             If CommandLine.NoLogo = False Then ShowLogo()
 
             If Report.ShowSavedMessages Then
                 Return 1
             End If
 
             'Set the culture to en-us to enable correct parsing of numbers, dates, etc.
             Threading.Thread.CurrentThread.CurrentCulture = Globalization.CultureInfo.GetCultureInfo("en-us")
 
             'Exit if no source files were specified
             If m_CommandLine.Files.Count = 0 Then
                 Report.ShowMessage(Messages.VBNC2011, Span.CommandLineSpan)
                 Return 1
             End If
 
             'Set the library of the .net system dir
             m_CommandLine.LibPath.Add(GetSystemDir)
 
             'Load the referenced assemblies
             If Not CommandLine.References.Contains("mscorlib.dll") Then
                 CommandLine.References.Add("mscorlib.dll")
             End If
             If CommandLine.NoStdLib = False AndAlso Not CommandLine.References.Contains("System.dll") Then
                 CommandLine.References.Add("System.dll")
             End If
 
             If Not String.IsNullOrEmpty(CommandLine.VBRuntime) Then
                 CommandLine.References.Add(CommandLine.VBRuntime)
             End If
 
             m_Helper = New Helper(Me)
 
             'Calculate the output filename
             result = Compile_CalculateOutputFilename() AndAlso result
 
             'Load all the referenced assemblies and load all the types and namespaces into the type manager
             m_TypeCache = New CecilTypeCache(Me)
 
             result = GenerateMy() AndAlso result
 
             result = m_TypeManager.LoadReferenced AndAlso result
             If Report.Errors > 0 Then GoTo ShowErrors
 
             m_TypeResolver = New TypeResolution(Me)
 
             'Create the assembly and module builders
             result = Compile_CreateAssemblyAndModuleBuilders() AndAlso result
             VerifyConsistency(result, "CreateAssemblyAndModuleBuilders")
 
             'Parse the code into the type tree
             result = Compile_Parse() AndAlso result
             If Report.Errors > 0 Then GoTo ShowErrors
 
             'Create definitions
             result = theAss.CreateDefinitions AndAlso result
             If Report.Errors > 0 Then GoTo ShowErrors
 
             'Create implicit constructors
             result = theAss.CreateImplicitInstanceConstructors AndAlso result
             If Report.Errors > 0 Then GoTo ShowErrors
 
             'Create implicit constructors
             result = theAss.CreateDelegateMembers AndAlso result
             If Report.Errors > 0 Then GoTo ShowErrors
 
             'Create withevents members
             result = theAss.CreateWithEventsMembers AndAlso result
             If Report.Errors > 0 Then GoTo ShowErrors
 
             'Create regular events members
             result = theAss.CreateRegularEventMembers AndAlso result
             If Report.Errors > 0 Then GoTo ShowErrors
 
             m_TypeManager.LoadCompiledTypes()
 
             If String.IsNullOrEmpty(CommandLine.VBRuntime) Then
                 m_TypeCache.InitInternalVB()
             End If
 
             result = Compile_Resolve() AndAlso result
             If Report.Errors > 0 Then GoTo ShowErrors
 
             result = Me.Assembly.SetCecilName(AssemblyBuilderCecil.Name) AndAlso result
 
             result = AddResources() AndAlso result
             If result = False Then GoTo ShowErrors
 
             'Passed this step no errors should be found...
 
             result = theAss.DefineTypeHierarchy AndAlso result
             VerifyConsistency(result, "DefineTypeHierarchy")
 
             result = theAss.Emit AndAlso result
             VerifyConsistency(result, "Emit")
 
             'Set the main function / entry point
             result = SetMain() AndAlso result
             If result = False Then GoTo ShowErrors
 
             If result = False Then
                 Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Error creating the assembly!")
                 GoTo ShowErrors
             End If
 
             Dim writerParameters As New WriterParameters()
             writerParameters.WriteSymbols = EmittingDebugInfo
             AssemblyBuilderCecil.Write(m_OutFilename, writerParameters)
 
             Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, String.Format("Assembly '{0}' saved successfully to '{1}'.", AssemblyBuilderCecil.Name.FullName, m_OutFilename))
 
 ShowErrors
             VerifyConsistency(result, "ShowErrors")
 
             If Report.Errors > 0 Or Report.Warnings > 0 Then
                 Compiler.Report.WriteLine("There were " & Report.Errors.ToString & " errors and " & Report.Warnings.ToString & " warnings.")
             End If
             If Report.Errors = 0 Then
                 Compiler.Report.WriteLine("Compilation successful")
                 result = True
             Else
                 result = False
             End If
 
 EndOfCompilation
             result = Report.Errors = 0 AndAlso result
 
             If result Then
                 Return 0
             Else
                 Return 1
             End If
         Catch ex As TooManyErrorsException
             Report.ShowMessage(Messages.VBNC30041, Span.CommandLineSpan)
             Return 1
         Catch ex As Exception
             ShowExceptionInfo(ex)
             Return -1
         Finally
             BaseObject.ClearCache()
         End Try
         vbnc.Helper.Assert(False, "End of program reached!")
         Return 1
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="4299" endline="4305">
<![CDATA[
 
     Private Sub LinkLabel1_LinkClicked(ByVal sender As System.Object, ByVal e As System.Windows.Forms.LinkLabelLinkClickedEventArgs) Handles LinkLabel1.LinkClicked
         Dim LinkURL As String = "mailto
         LinkURL += "&Body=Please attach your language file from the folder C
         LinkURL += "&Attach=C
         System.Diagnostics.Process.Start(LinkURL)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Classifications\MethodGroupClassification.vb" startline="209" endline="349">
<![CDATA[
 
     ''' <summary>
     ''' Stores at the address of the variable.
     ''' </summary>
     ''' <param name="Info"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Friend Overrides Function GenerateCode(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         If m_Expression IsNot Nothing Then
             Return m_Expression.GenerateCode(Info)
         End If
 
         Helper.Assert(Info.IsRHS AndAlso Info.RHSExpression Is Nothing OrElse Info.IsLHS AndAlso Info.RHSExpression IsNot Nothing)
 
         If m_InstanceExpression IsNot Nothing Then
             Dim exp As Mono.Cecil.TypeReference = m_InstanceExpression.ExpressionType
             If CecilHelper.IsValueType(exp) AndAlso CecilHelper.IsByRef(exp) = False Then
                 exp = Compiler.TypeManager.MakeByRefType(Me.Parent, exp)
             End If
             result = m_InstanceExpression.GenerateCode(Info.Clone(Parent, True, False, exp)) AndAlso result
         End If
 
         If FieldInfo IsNot Nothing Then
             If Info.IsRHS Then
                 If CecilHelper.IsByRef(Info.DesiredType) Then
                     Emitter.EmitLoadVariableLocation(Info, FieldInfo)
                 Else
                     Emitter.EmitLoadVariable(Info, FieldInfo)
                 End If
             Else
                 Dim rInfo As EmitInfo = Info.Clone(Parent, True, False, FieldInfo.FieldType)
 
                 Helper.Assert(Info.RHSExpression IsNot Nothing)
                 Helper.Assert(Info.RHSExpression.Classification.IsValueClassification)
                 result = Info.RHSExpression.Classification.GenerateCode(rInfo) AndAlso result
 
                 Emitter.EmitConversion(Info.RHSExpression.ExpressionType, FieldInfo.FieldType, Info.Clone(Parent, Info.RHSExpression.ExpressionType))
                 Emitter.EmitStoreField(Info, FieldInfo)
             End If
         ElseIf LocalBuilder IsNot Nothing Then
             result = VariableExpression.Emit(Info, LocalBuilder) AndAlso result
         ElseIf ParameterInfo IsNot Nothing Then
             Dim isByRef As Boolean
             Dim isByRefStructure As Boolean
             Dim paramType As Mono.Cecil.TypeReference
             Dim paramElementType As Mono.Cecil.TypeReference = Nothing
 
             paramType = ParameterInfo.ParameterType
             isByRef = CecilHelper.IsByRef(paramType)
             If isByRef Then
                 paramElementType = CecilHelper.GetElementType(paramType)
                 isByRefStructure = CecilHelper.IsValueType(paramElementType)
             End If
 
             Helper.Assert(m_InstanceExpression Is Nothing)
 
             If Info.IsRHS Then
                 If isByRef Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
                 Else
                     Emitter.EmitLoadVariable(Info, ParameterInfo)
                 End If
             Else
                 Dim rInfo As EmitInfo
                 Dim rhs As Expression = Info.RHSExpression
                 Dim paramConsumed As Boolean
 
                 If isByRefStructure Then
                     Emitter.EmitLoadVariable(Info.Clone(Parent, paramType), ParameterInfo)
                     If TypeOf rhs Is GetRefExpression Then rhs = DirectCast(rhs, GetRefExpression).Expression
                     'paramConsumed = TypeOf rhs Is NewExpression
                     If paramConsumed Then
                         rInfo = Info.Clone(Parent, True, False, paramType)
                     Else
                         rInfo = Info.Clone(Parent, True, False, paramElementType)
                     End If
                 ElseIf isByRef Then
                     Emitter.EmitLoadVariableLocation(Info, ParameterInfo)
                     rInfo = Info.Clone(Parent, True, False, paramElementType)
                 Else
                     rInfo = Info.Clone(Parent, True, False, paramType)
                 End If
 
                 Helper.Assert(rhs IsNot Nothing, "RHSExpression Is Nothing!")
                 Helper.Assert(rhs.Classification.IsValueClassification)
                 result = rhs.Classification.GenerateCode(rInfo) AndAlso result
 
                 If Not paramConsumed Then
                     If isByRef = False Then
                         Emitter.EmitConversion(rhs.ExpressionType, paramType, Info)
                     End If
                     If isByRefStructure Then
                         Emitter.EmitStoreIndirect(Info, paramType)
                     Else
                         Emitter.EmitStoreVariable(Info, ParameterInfo)
                     End If
                 End If
             End If
         ElseIf Me.m_Variable IsNot Nothing Then
             If Info.IsRHS Then
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             Else
                 Dim rInfo As EmitInfo = Info.Clone(Parent, True, False, m_Variable.VariableType)
 
                 Helper.Assert(Info.RHSExpression IsNot Nothing)
                 Helper.Assert(Info.RHSExpression.Classification.IsValueClassification)
                 result = Info.RHSExpression.Classification.GenerateCode(rInfo) AndAlso result
 
                 Emitter.EmitConversion(Info.RHSExpression.ExpressionType, m_Variable.VariableType, Info)
 
                 If Helper.CompareType(m_Variable.VariableType, Compiler.TypeCache.System_Object) AndAlso Helper.CompareType(Info.RHSExpression.ExpressionType, Compiler.TypeCache.System_Object) Then
                     Emitter.EmitCall(Info, Compiler.TypeCache.System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValue_Object)
                 End If
 
                 Emitter.EmitStoreVariable(Info, LocalBuilder)
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Parent.Location)
             End If
         ElseIf m_ArrayVariable IsNot Nothing Then
             If Info.IsRHS Then
                 result = Me.GenerateCodeAsValue(Info) AndAlso result
             Else
                 result = Helper.EmitStoreArrayElement(Info, m_ArrayVariable, m_Arguments) AndAlso result
 
             End If
         ElseIf m_Method IsNot Nothing Then
             If Info.IsRHS Then
                 Emitter.EmitLoadVariable(Info, m_Method.DefaultReturnVariable)
             Else
                 Helper.Assert(Info.RHSExpression IsNot Nothing, "RHSExpression Is Nothing!")
                 Helper.Assert(Info.RHSExpression.Classification.IsValueClassification)
                 result = Info.RHSExpression.Classification.GenerateCode(Info.Clone(Parent, True, False, m_Method.DefaultReturnVariable.VariableType)) AndAlso result
                 Emitter.EmitStoreVariable(Info, m_Method.DefaultReturnVariable)
             End If
         Else
             Throw New InternalException(Me)
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CecilHelper.vb" startline="800" endline="839">
<![CDATA[
 
     Public Overloads Shared Function [GetType](ByVal Compiler As Compiler, ByVal value As Object) As Mono.Cecil.TypeReference
         If value Is Nothing Then Throw New InternalException("'Nothing' doesn't have a type")
         Select Case Type.GetTypeCode(value.GetType)
             Case TypeCode.Boolean
                 Return Compiler.TypeCache.System_Boolean
             Case TypeCode.Byte
                 Return Compiler.TypeCache.System_Byte
             Case TypeCode.Char
                 Return Compiler.TypeCache.System_Char
             Case TypeCode.DateTime
                 Return Compiler.TypeCache.System_DateTime
             Case TypeCode.DBNull
                 Return Compiler.TypeCache.System_DBNull
             Case TypeCode.Decimal
                 Return Compiler.TypeCache.System_Decimal
             Case TypeCode.Double
                 Return Compiler.TypeCache.System_Double
             Case TypeCode.Int16
                 Return Compiler.TypeCache.System_Int16
             Case TypeCode.Int32
                 Return Compiler.TypeCache.System_Int32
             Case TypeCode.Int64
                 Return Compiler.TypeCache.System_Int64
             Case TypeCode.SByte
                 Return Compiler.TypeCache.System_SByte
             Case TypeCode.Single
                 Return Compiler.TypeCache.System_Single
             Case TypeCode.String
                 Return Compiler.TypeCache.System_String
             Case TypeCode.UInt16
                 Return Compiler.TypeCache.System_UInt16
             Case TypeCode.UInt32
                 Return Compiler.TypeCache.System_UInt32
             Case TypeCode.UInt64
                 Return Compiler.TypeCache.System_UInt64
             Case Else
                 Throw New InternalException(String.Format("No constant value can be of the type '{0}'", value.GetType.FullName))
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\MainForm.cs" startline="574" endline="580">
<![CDATA[
 
 		private void LockStation()
 		{
 			lockingEnabled = false;
 			locked = true;
 			pluginManager.WorkstationLocked();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\MainForm.cs" startline="581" endline="587">
<![CDATA[
 
 		private void UnlockStation()
 		{
 			lockingEnabled = true;
 			locked = false;
 			pluginManager.WorkstationUnlocked();
 		}
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="154" endline="170">
<![CDATA[
     End Property
 
     Private Shared m_FakeGenerator As EmitLog
     ''' <summary>
     ''' The ILGenerator used to emit the code.
     ''' </summary>
     ''' <value></value>
     ''' <returns></returns>
     ''' <remarks></remarks>
     ReadOnly Property ILGen() As EmitLog
         Get
             If m_FakeGenerator Is Nothing OrElse m_FakeGenerator.Compiler IsNot Compiler Then
                 m_FakeGenerator = New EmitLog(Compiler)
             End If
             m_FakeGenerator.CilBody = CilBody
             Return m_FakeGenerator
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="249" endline="256">
<![CDATA[
 
     Shared Sub EmitAddOrAddOvf(ByVal Info As EmitInfo, ByVal OperandType As Mono.Cecil.TypeReference)
         If Info.IntegerOverflowChecks Then
             EmitAddOvf(Info, OperandType)
         Else
             EmitAdd(Info, OperandType)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="272" endline="279">
<![CDATA[
 
     Shared Sub EmitMultOrMultOvf(ByVal Info As EmitInfo, ByVal OperandType As Mono.Cecil.TypeReference)
         If Info.IntegerOverflowChecks Then
             EmitMultOvf(Info, OperandType)
         Else
             EmitMult(Info, OperandType)
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\LateBoundAccessToValueExpression.vb" startline="37" endline="43">
<![CDATA[
         Get
             If TypeOf m_Value.LiteralValue Is String Then
                 Return """" & m_Value.LiteralValue.ToString & """"
             Else
                 Return m_Value.LiteralValue.ToString()
             End If
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="184" endline="215">
<![CDATA[
 
     ReadOnly Property AsString() As String
         Get
             Select Case m_TokenType
                 Case TokenType.CharLiteral
                     Return """" & CharLiteral & """c"
                 Case TokenType.DateLiteral
                     Return "#" & DateLiteral.ToString() & "#"
                 Case TokenType.DecimalLiteral
                     Return DecimalLiteral.ToString
                 Case TokenType.EndOfCode
                     Return "END OF CODE"
                 Case TokenType.EndOfFile
                     Return "END OF FILE"
                 Case TokenType.EndOfLine
                     Return "END OF LINE"
                 Case TokenType.Identifier
                     Return Identifier
                 Case TokenType.Int16Literal, TokenType.Int32Literal, TokenType.Int64Literal, TokenType.UInt16Literal, TokenType.UInt32Literal, TokenType.UInt64Literal
                     Return IntegralLiteral.ToString
                 Case TokenType.Keyword
                     Return Keyword.ToString()
                 Case TokenType.SingleLiteral, TokenType.DoubleLiteral
                     Return Me.LiteralValue.ToString
                 Case TokenType.StringLiteral
                     Return """" & Me.StringLiteral & """"
                 Case TokenType.Symbol
                     Return Me.Symbol.ToString
                 Case Else
                     Return "EMPTY TOKEN"
             End Select
         End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="80" endline="100">
<![CDATA[
 
     Private Sub FrmMain_FormClosing(ByVal sender As Object, ByVal e As System.Windows.Forms.FormClosingEventArgs) Handles Me.FormClosing
 
         If GameMode() = True Then
             If ChkImg("QuickControl.exe") = False Then
                 Try
                     Process.Start(Application.StartupPath & "\QuickControl.exe")
                 Catch ex As System.ComponentModel.Win32Exception
                     MessageBox.Show("Gaming Mode will be turned off.", "Vista Services Optimizer", MessageBoxButtons.OK, MessageBoxIcon.Exclamation, MessageBoxDefaultButton.Button1, 0, False)
                     Try
                         FrmProgress.PicProgress.Image = New Bitmap(DataDir & "game_mode.png")
                     Catch exx As ArgumentException
                     End Try
                     FrmProgress.LblProgress.Text = "Turning off Gaming Mode, Please wait..."
                     FrmGameMode.BWGameMode.RunWorkerAsync()
                     FrmProgress.ShowDialog(Me)
                 End Try
             End If
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\Conversions\CStrExpression.vb" startline="66" endline="234">
<![CDATA[
 
     Protected Overrides Function GenerateCodeInternal(ByVal Info As EmitInfo) As Boolean
         Dim result As Boolean = True
 
         Dim expType As Mono.Cecil.TypeReference = Me.ExpressionType
         Dim expTypeCode As TypeCode = Helper.GetTypeCode(Compiler, expType)
 
         If m_ConversionType <> CTypeConversionType.Undetermined AndAlso m_ConversionType <> CTypeConversionType.Intrinsic Then
             result = Expression.Classification.GenerateCode(Info.Clone(Me, ExpressionType)) AndAlso result
         End If
 
         Select Case m_ConversionType
             Case CTypeConversionType.FromNullable
                 Dim nullable_dst_type As GenericInstanceType
                 Dim explicit_op As MethodReference
                 Dim git As GenericInstanceType
 
                 nullable_dst_type = New GenericInstanceType(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Nullable1))
                 nullable_dst_type.GenericArguments.Add(Helper.GetTypeOrTypeReference(Compiler, CecilHelper.GetNulledType(Expression.ExpressionType)))
                 git = New GenericInstanceType(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Nullable1))
                 git.GenericArguments.Add(Compiler.TypeCache.System_Nullable1.GenericParameters(0))
                 explicit_op = New MethodReference("op_Explicit", nullable_dst_type, ExpressionType, False, False, MethodCallingConvention.Default)
                 explicit_op.Parameters.Add(New ParameterDefinition(git))
                 Emitter.EmitCall(Info, explicit_op)
                 Return True
             Case CTypeConversionType.ToNullable
                 Dim nullable_dst_type As GenericInstanceType
                 Dim implicit_op As MethodReference
 
                 nullable_dst_type = New GenericInstanceType(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Nullable1))
                 nullable_dst_type.GenericArguments.Add(Helper.GetTypeOrTypeReference(Compiler, CecilHelper.GetNulledType(ExpressionType)))
                 implicit_op = New MethodReference("op_Implicit", nullable_dst_type, nullable_dst_type, False, False, MethodCallingConvention.Default)
                 implicit_op.Parameters.Add(New ParameterDefinition(Compiler.TypeCache.System_Nullable1.GenericParameters(0)))
                 Emitter.EmitCall(Info, implicit_op)
                 Return True
             Case CTypeConversionType.Castclass
                 Emitter.EmitCastClass(Info, ExpressionType)
                 Return True
             Case CTypeConversionType.Identity
                 'There is nothing to do here
                 Return True
             Case CTypeConversionType.Box
                 Emitter.EmitBox(Info, Expression.ExpressionType)
                 Return True
             Case CTypeConversionType.Box_CastClass
                 Emitter.EmitBox(Info, Expression.ExpressionType)
                 Emitter.EmitCastClass(Info, ExpressionType)
                 Return True
             Case CTypeConversionType.Unbox
                 Emitter.EmitUnbox(Info, ExpressionType)
                 Return True
             Case CTypeConversionType.Unbox_Ldobj
                 Emitter.EmitUnbox(Info, ExpressionType)
                 Emitter.EmitLdobj(Info, ExpressionType)
                 Return True
             Case CTypeConversionType.Unbox_Any
                 Emitter.EmitUnbox_Any(Info, ExpressionType)
                 Return True
             Case CTypeConversionType.MS_VB_CS_Conversions_ToGenericParameter
                 Dim gim As New GenericInstanceMethod(Compiler.TypeCache.MS_VB_CS_Conversions__ToGenericParameter_Object)
                 gim.GenericArguments.Add(ExpressionType)
                 Emitter.EmitCall(Info, gim)
                 Return True
             Case CTypeConversionType.UserDefinedOperator
                 Emitter.EmitCall(Info, ConversionMethod)
                 Return True
             Case CTypeConversionType.NullableToNullable
                 Dim SourceType As TypeReference = Expression.ExpressionType
                 Dim DestinationType As TypeReference = ExpressionType
                 Dim nullable_src_type As GenericInstanceType
                 Dim nullable_dst_type As GenericInstanceType
                 Dim get_value As MethodReference
                 Dim has_value As MethodReference
                 Dim ctor As MethodReference
                 Dim localsrc, localdst As Mono.Cecil.Cil.VariableDefinition
                 Dim falseLabel As Label = Emitter.DefineLabel(Info)
                 Dim endLabel As Label = Emitter.DefineLabel(Info)
                 Dim vose As ValueOnStackExpression
                 Dim type_conversion As Expression
 
                 nullable_src_type = New GenericInstanceType(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Nullable1))
                 nullable_src_type.GenericArguments.Add(Helper.GetTypeOrTypeReference(Compiler, CecilHelper.GetNulledType(SourceType)))
                 has_value = New MethodReference("get_HasValue", nullable_src_type, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Boolean), True, False, MethodCallingConvention.Default)
                 get_value = New MethodReference("GetValueOrDefault", nullable_src_type, Compiler.TypeCache.System_Nullable1.GenericParameters(0), True, False, MethodCallingConvention.Default)
 
                 nullable_dst_type = New GenericInstanceType(Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Nullable1))
                 nullable_dst_type.GenericArguments.Add(Helper.GetTypeOrTypeReference(Compiler, CecilHelper.GetNulledType(DestinationType)))
                 ctor = New MethodReference(".ctor", nullable_dst_type, Helper.GetTypeOrTypeReference(Compiler, Compiler.TypeCache.System_Void), True, False, MethodCallingConvention.Default)
                 ctor.Parameters.Add(New ParameterDefinition(Compiler.TypeCache.System_Nullable1.GenericParameters(0)))
 
                 'store in local
                 localsrc = Emitter.DeclareLocal(Info, SourceType)
                 Emitter.EmitStoreVariable(Info, localsrc)
 
                 'call Nullable`1.HasValue to check the condition
                 Emitter.EmitLoadVariableLocation(Info, localsrc)
                 Emitter.EmitCall(Info, has_value)
                 Emitter.EmitBranchIfFalse(Info, falseLabel)
 
                 localdst = Emitter.DeclareLocal(Info, DestinationType)
 
                 'true branch
                 Emitter.EmitLoadVariableLocation(Info, localdst)
                 Emitter.EmitLoadVariableLocation(Info, localsrc)
                 Emitter.EmitCall(Info, get_value)
 
                 'convert value
                 vose = New ValueOnStackExpression(Me, CecilHelper.GetNulledType(SourceType))
                 type_conversion = Helper.CreateTypeConversion(Me, vose, CecilHelper.GetNulledType(DestinationType), result)
                 result = type_conversion.GenerateCode(Info) AndAlso result
 
                 Emitter.EmitCall(Info, ctor)
                 Emitter.EmitLoadVariable(Info, localdst)
                 Emitter.EmitBranch(Info, endLabel)
 
                 'false branch
                 Emitter.MarkLabel(Info, falseLabel)
                 Emitter.EmitLoadVariableLocation(Info, localdst)
                 Emitter.EmitInitObj(Info, localdst.VariableType)
                 Emitter.EmitLoadVariable(Info, localdst)
 
                 'end
                 Emitter.MarkLabel(Info, endLabel)
                 Return True
         End Select
 
         Select Case expTypeCode
             Case TypeCode.Boolean
                 CBoolExpression.GenerateCode(Me, Info)
             Case TypeCode.Byte
                 CByteExpression.GenerateCode(Me, Info)
             Case TypeCode.Char
                 CCharExpression.GenerateCode(Me, Info)
             Case TypeCode.DateTime
                 CDateExpression.GenerateCode(Me, Info)
             Case TypeCode.Decimal
                 CDecExpression.GenerateCode(Me, Info)
             Case TypeCode.Double
                 CDblExpression.GenerateCode(Me, Info)
             Case TypeCode.Int16
                 CShortExpression.GenerateCode(Me, Info)
             Case TypeCode.Int32
                 CIntExpression.GenerateCode(Me, Info)
             Case TypeCode.Int64
                 CLngExpression.GenerateCode(Me, Info)
             Case TypeCode.SByte
                 CSByteExpression.GenerateCode(Me, Info)
             Case TypeCode.Single
                 CSngExpression.GenerateCode(Me, Info)
             Case TypeCode.String
                 CStrExpression.GenerateCode(Me, Info)
             Case TypeCode.UInt16
                 CUShortExpression.GenerateCode(Me, Info)
             Case TypeCode.UInt32
                 CUIntExpression.GenerateCode(Me, Info)
             Case TypeCode.UInt64
                 CULngExpression.GenerateCode(Me, Info)
             Case TypeCode.Object, TypeCode.DBNull
                 If Helper.CompareType(expType, Compiler.TypeCache.System_Object) Then
                     CObjExpression.GenerateCode(Me.Expression, Info)
                 Else
                     result = GenerateCTypeCode(Info, expType, Me.Expression.ExpressionType)
                 End If
             Case Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
         End Select
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\web sec\UsbWiSec-2.1-source\AboutBox.cs" startline="21" endline="172">
<![CDATA[
 
         #region Windows Form Designer generated code
 
         /// <summary>
         /// Required method for Designer support - do not modify
         /// the contents of this method with the code editor.
         /// </summary>
         private void InitializeComponent()
         {
             System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(AboutBox));
             this.tableLayoutPanel = new System.Windows.Forms.TableLayoutPanel();
             this.logoPictureBox = new System.Windows.Forms.PictureBox();
             this.labelProductName = new System.Windows.Forms.Label();
             this.labelVersion = new System.Windows.Forms.Label();
             this.labelCopyright = new System.Windows.Forms.Label();
             this.labelCompanyName = new System.Windows.Forms.Label();
             this.textBoxDescription = new System.Windows.Forms.TextBox();
             this.okButton = new System.Windows.Forms.Button();
             this.tableLayoutPanel.SuspendLayout();
             ((System.ComponentModel.ISupportInitialize)(this.logoPictureBox)).BeginInit();
             this.SuspendLayout();
             // 
             // tableLayoutPanel
             // 
             this.tableLayoutPanel.ColumnCount = 2;
             this.tableLayoutPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 33F));
             this.tableLayoutPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 67F));
             this.tableLayoutPanel.Controls.Add(this.logoPictureBox, 0, 0);
             this.tableLayoutPanel.Controls.Add(this.labelProductName, 1, 0);
             this.tableLayoutPanel.Controls.Add(this.labelVersion, 1, 1);
             this.tableLayoutPanel.Controls.Add(this.labelCopyright, 1, 2);
             this.tableLayoutPanel.Controls.Add(this.labelCompanyName, 1, 3);
             this.tableLayoutPanel.Controls.Add(this.textBoxDescription, 1, 4);
             this.tableLayoutPanel.Controls.Add(this.okButton, 1, 5);
             this.tableLayoutPanel.Dock = System.Windows.Forms.DockStyle.Fill;
             this.tableLayoutPanel.Location = new System.Drawing.Point(9, 9);
             this.tableLayoutPanel.Name = "tableLayoutPanel";
             this.tableLayoutPanel.RowCount = 6;
             this.tableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 10F));
             this.tableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 10F));
             this.tableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 10F));
             this.tableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 10F));
             this.tableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 36.98113F));
             this.tableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 23.77358F));
             this.tableLayoutPanel.Size = new System.Drawing.Size(417, 265);
             this.tableLayoutPanel.TabIndex = 0;
             // 
             // logoPictureBox
             // 
             this.logoPictureBox.BackColor = System.Drawing.Color.White;
             this.logoPictureBox.Dock = System.Windows.Forms.DockStyle.Fill;
             this.logoPictureBox.Image = ((System.Drawing.Image)(resources.GetObject("logoPictureBox.Image")));
             this.logoPictureBox.Location = new System.Drawing.Point(3, 3);
             this.logoPictureBox.Name = "logoPictureBox";
             this.tableLayoutPanel.SetRowSpan(this.logoPictureBox, 6);
             this.logoPictureBox.Size = new System.Drawing.Size(131, 259);
             this.logoPictureBox.TabIndex = 12;
             this.logoPictureBox.TabStop = false;
             // 
             // labelProductName
             // 
             this.labelProductName.Dock = System.Windows.Forms.DockStyle.Fill;
             this.labelProductName.Location = new System.Drawing.Point(143, 0);
             this.labelProductName.Margin = new System.Windows.Forms.Padding(6, 0, 3, 0);
             this.labelProductName.MaximumSize = new System.Drawing.Size(0, 17);
             this.labelProductName.Name = "labelProductName";
             this.labelProductName.Size = new System.Drawing.Size(271, 17);
             this.labelProductName.TabIndex = 19;
             this.labelProductName.Text = "Product Name";
             this.labelProductName.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
             // 
             // labelVersion
             // 
             this.labelVersion.Dock = System.Windows.Forms.DockStyle.Fill;
             this.labelVersion.Location = new System.Drawing.Point(143, 26);
             this.labelVersion.Margin = new System.Windows.Forms.Padding(6, 0, 3, 0);
             this.labelVersion.MaximumSize = new System.Drawing.Size(0, 17);
             this.labelVersion.Name = "labelVersion";
             this.labelVersion.Size = new System.Drawing.Size(271, 17);
             this.labelVersion.TabIndex = 0;
             this.labelVersion.Text = "Version";
             this.labelVersion.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
             // 
             // labelCopyright
             // 
             this.labelCopyright.Dock = System.Windows.Forms.DockStyle.Fill;
             this.labelCopyright.Location = new System.Drawing.Point(143, 52);
             this.labelCopyright.Margin = new System.Windows.Forms.Padding(6, 0, 3, 0);
             this.labelCopyright.MaximumSize = new System.Drawing.Size(0, 17);
             this.labelCopyright.Name = "labelCopyright";
             this.labelCopyright.Size = new System.Drawing.Size(271, 17);
             this.labelCopyright.TabIndex = 21;
             this.labelCopyright.Text = "Copyright";
             this.labelCopyright.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
             // 
             // labelCompanyName
             // 
             this.labelCompanyName.Dock = System.Windows.Forms.DockStyle.Fill;
             this.labelCompanyName.Location = new System.Drawing.Point(143, 78);
             this.labelCompanyName.Margin = new System.Windows.Forms.Padding(6, 0, 3, 0);
             this.labelCompanyName.MaximumSize = new System.Drawing.Size(0, 17);
             this.labelCompanyName.Name = "labelCompanyName";
             this.labelCompanyName.Size = new System.Drawing.Size(271, 17);
             this.labelCompanyName.TabIndex = 22;
             this.labelCompanyName.Text = "Company Name";
             this.labelCompanyName.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
             // 
             // textBoxDescription
             // 
             this.textBoxDescription.Dock = System.Windows.Forms.DockStyle.Fill;
             this.textBoxDescription.Location = new System.Drawing.Point(143, 107);
             this.textBoxDescription.Margin = new System.Windows.Forms.Padding(6, 3, 3, 3);
             this.textBoxDescription.Multiline = true;
             this.textBoxDescription.Name = "textBoxDescription";
             this.textBoxDescription.ReadOnly = true;
             this.textBoxDescription.ScrollBars = System.Windows.Forms.ScrollBars.Both;
             this.textBoxDescription.Size = new System.Drawing.Size(271, 91);
             this.textBoxDescription.TabIndex = 23;
             this.textBoxDescription.TabStop = false;
             this.textBoxDescription.Text = "Description";
             // 
             // okButton
             // 
             this.okButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
             this.okButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
             this.okButton.Location = new System.Drawing.Point(339, 239);
             this.okButton.Name = "okButton";
             this.okButton.Size = new System.Drawing.Size(75, 23);
             this.okButton.TabIndex = 24;
             this.okButton.Text = "&OK";
             // 
             // AboutBox
             // 
             this.AcceptButton = this.okButton;
             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.ClientSize = new System.Drawing.Size(435, 283);
             this.Controls.Add(this.tableLayoutPanel);
             this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
             this.MaximizeBox = false;
             this.MinimizeBox = false;
             this.Name = "AboutBox";
             this.Padding = new System.Windows.Forms.Padding(9);
             this.ShowIcon = false;
             this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
             this.Text = "AboutBox";
             this.tableLayoutPanel.ResumeLayout(false);
             this.tableLayoutPanel.PerformLayout();
             ((System.ComponentModel.ISupportInitialize)(this.logoPictureBox)).EndInit();
             this.ResumeLayout(false);
 
         }
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Classes\GMode.vb" startline="120" endline="225">
<![CDATA[
 
     Protected Friend Sub GamingOff()
 
         If File.Exists(GMFile) = False Then
             My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer", "GameMode", 0, Microsoft.Win32.RegistryValueKind.DWord)
             Exit Sub
         End If
 
         Dim Reader As New StreamReader(GMFile)
         Dim Info = Reader.ReadToEnd()
         Reader.Close()
 
         Dim GM_Info() As String = Info.Split(CChar("!"))
         UBound(GM_Info)
 
         TurnOff("Spooler", GM_Info(0).Trim)
         TurnOff("stisvc", GM_Info(1).Trim)
         TurnOff("TabletInputService", GM_Info(2).Trim)
 
         TurnOff("Themes", GM_Info(3).Trim)
         TurnOff("UxSms", GM_Info(4).Trim)
 
         TurnOff("Browser", GM_Info(5).Trim)
         TurnOff("fdPHost", GM_Info(6).Trim)
         TurnOff("FDResPub", GM_Info(7).Trim)
         TurnOff("LanmanServer", GM_Info(8).Trim)
         TurnOff("lmhosts", GM_Info(9).Trim)
 
         TurnOff("WSearch", GM_Info(10).Trim)
 
         TurnOff("Mcx2Svc", GM_Info(11).Trim)
         TurnOff("ehRecvr", GM_Info(12).Trim)
         TurnOff("ehSched", GM_Info(13).Trim)
         TurnOff("ehstart", GM_Info(14).Trim)
 
         TurnOff("wuauserv", GM_Info(15).Trim)
         TurnOff("TrustedInstaller", GM_Info(16).Trim)
         TurnOff("BITS", GM_Info(17).Trim)
 
         TurnOff("defragsvc", GM_Info(18).Trim)
 
         TurnOff("DPS", GM_Info(19).Trim)
         TurnOff("WdiServiceHost", GM_Info(20).Trim)
         TurnOff("WdiSystemHost", GM_Info(21).Trim)
 
         TurnOff("AeLookupSvc", GM_Info(22).Trim)
         TurnOff("ALG", GM_Info(23).Trim)
         TurnOff("AppMgmt", GM_Info(24).Trim)
         TurnOff("CertPropSvc", GM_Info(25).Trim)
         TurnOff("DFSR", GM_Info(26).Trim)
         TurnOff("TrkWks", GM_Info(27).Trim)
         TurnOff("MSDTC", GM_Info(28).Trim)
         TurnOff("FAX", GM_Info(29).Trim)
         TurnOff("hkmsvc", GM_Info(30).Trim)
         TurnOff("hidserv", GM_Info(31).Trim)
         TurnOff("IKEEXT", GM_Info(32).Trim)
         TurnOff("UI0Detect", GM_Info(33).Trim)
         TurnOff("SharedAccess", GM_Info(34).Trim)
         TurnOff("iphlpsvc", GM_Info(35).Trim)
         TurnOff("PolicyAgent", GM_Info(36).Trim)
         TurnOff("KtmRm", GM_Info(37).Trim)
         TurnOff("lltdsvc", GM_Info(38).Trim)
         TurnOff("MSiSCSI", GM_Info(39).Trim)
         TurnOff("NetTcpPortSharing", GM_Info(40).Trim)
         TurnOff("Netlogon", GM_Info(41).Trim)
         TurnOff("napagent", GM_Info(42).Trim)
         TurnOff("CscService", GM_Info(43).Trim)
         TurnOff("WPCSvc", GM_Info(44).Trim)
         TurnOff("PNRPsvc", GM_Info(45).Trim)
         TurnOff("p2psvc", GM_Info(46).Trim)
         TurnOff("p2pimsvc", GM_Info(47).Trim)
         TurnOff("IPBusEnum", GM_Info(48).Trim)
         TurnOff("PNRPAutoReg", GM_Info(49).Trim)
         TurnOff("WPDBusEnum", GM_Info(50).Trim)
         TurnOff("wercplsupport", GM_Info(51).Trim)
         TurnOff("ProtectedStorage", GM_Info(52).Trim)
         TurnOff("QWAVE", GM_Info(53).Trim)
         TurnOff("RemoteRegistry", GM_Info(54).Trim)
         TurnOff("RemoteAccess", GM_Info(55).Trim)
         TurnOff("LanmanServer", GM_Info(56).Trim)
         TurnOff("ShellHWDetection", GM_Info(57).Trim)
         TurnOff("SCardSvr", GM_Info(58).Trim)
         TurnOff("SCPolicySvc", GM_Info(59).Trim)
         TurnOff("SNMPTRAP", GM_Info(60).Trim)
         TurnOff("TermService", GM_Info(61).Trim)
         TurnOff("SessionEnv", GM_Info(62).Trim)
         TurnOff("UmRdpService", GM_Info(63).Trim)
         TurnOff("vds", GM_Info(64).Trim)
         TurnOff("VSS", GM_Info(65).Trim)
         TurnOff("WebClient", GM_Info(66).Trim)
         TurnOff("idsvc", GM_Info(67).Trim)
         TurnOff("WcsPlugInService", GM_Info(68).Trim)
         TurnOff("wcncsvc", GM_Info(69).Trim)
         TurnOff("WerSvc", GM_Info(70).Trim)
         TurnOff("WinRM", GM_Info(71).Trim)
         TurnOff("W32Time", GM_Info(72).Trim)
         TurnOff("WinHttpAutoProxySvc", GM_Info(73).Trim)
 
         SrvcCntrl.Close()
         File.SetAttributes(GMFile, FileAttributes.Normal)
         File.Delete(GMFile)
 
         System.Threading.Thread.Sleep(2000)
         My.Computer.Registry.SetValue("HKEY_CURRENT_USER\SOFTWARE\Smart PC Utilities\Services Optimizer", "GameMode", 0, Microsoft.Win32.RegistryValueKind.DWord)
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeCache.vb" startline="65" endline="210">
<![CDATA[
 
     Shared Function Generate(ByVal Lines As String()) As String
         Dim variables As New System.Text.StringBuilder
         Dim getters As New System.Text.StringBuilder
         Dim vbtypes As New System.Text.StringBuilder
         Dim vbmembers As New System.Text.StringBuilder
 
         'Turns out using public fields instead of private fields with property getters is about 10% faster during bootstrapping.
         'Quite possibly because there's quite more code to compile with the properties
         Dim publicfields As Boolean = True
 
         If publicfields Then
             getters.AppendLine("    Protected Overrides Sub InitInternal ()")
         End If
 
         vbtypes.AppendLine("    Public Overrides Sub InitInternalVB()")
         vbmembers.AppendLine("    Public Overrides Sub InitInternalVBMembers()")
 
         For Each line As String In Lines
             If line.StartsWith("'") Then Continue For
             If line.Trim = "" Then Continue For
 
             Dim splitted() As String = line.Split(New Char() {" "c}, StringSplitOptions.RemoveEmptyEntries)
             Dim name, type, find, parameters As String
             Dim param As Integer = Integer.MaxValue
             Dim noparaminname As Boolean = False
             Dim isVB As Boolean = False
             Dim isVBMember As Boolean = False
 
             parameters = Nothing
 
             Select Case splitted(0)
                 Case "vbtype"
                     name = splitted(1)
                     name = name.Replace("Microsoft.VisualBasic.CompilerServices.", "MS_VB_CS_")
                     name = name.Replace("Microsoft.VisualBasic.", "MS_VB_")
                     name = name.Replace("""", "").Replace(".", "_").Replace("`", "").Replace("+", "_")
                     type = "Mono.Cecil.TypeDefinition"
                     find = "GetVBType"
                     parameters = splitted(1)
                     isVB = True
                 Case "type"
                     name = splitted(2).Replace("""", "").Replace(".", "_").Replace("`", "").Replace("+", "_")
                     type = "Mono.Cecil.TypeDefinition"
                     find = "[GetType]"
                     parameters = splitted(1) & ", " & splitted(2)
 
                     If splitted(2).IndexOf("+"c) > 0 Then
                         Dim declaringtype As String = splitted(2).Substring(0, splitted(2).LastIndexOf("+"c)).Replace(".", "_").Replace("""", "")
                         Dim nestedtype As String = """" & splitted(2).Substring(splitted(2).LastIndexOf("+"c) + 1)
                         parameters = declaringtype & ", " & nestedtype
                     End If
 
                 Case "array"
                     name = splitted(1).Replace("""", "").Replace(".", "_").Replace("`", "") & "_Array"
                     type = "Mono.Cecil.TypeReference"
                     find = "GetArrayType"
                     parameters = splitted(1)
                 Case "byref"
                     name = splitted(1).Replace("""", "").Replace(".", "_").Replace("`", "") & "_ByRef"
                     type = "Mono.Cecil.TypeReference"
                     find = "GetByRefType"
                     parameters = splitted(1)
                 Case "method", "method2"
                     name = splitted(1) & "__" & splitted(2).Replace("""", "").Replace(".", "_").Replace("`", "")
                     type = "Mono.Cecil.MethodDefinition"
                     If splitted(0) <> "method" Then noparaminname = True
                     param = 3
                     find = "GetMethod"
                     parameters = splitted(1) & ", " & splitted(2)
                     isVBMember = splitted(1).StartsWith("MS_")
                 Case "property"
                     name = splitted(1) & "__" & splitted(2).Replace("""", "").Replace(".", "_").Replace("`", "")
                     type = "Mono.Cecil.PropertyDefinition"
                     param = 3
                     find = "GetProperty"
                     parameters = splitted(1) & ", " & splitted(2)
                     isVBMember = splitted(1).StartsWith("MS_")
                 Case "field"
                     name = splitted(1) & "__" & splitted(2).Replace("""", "").Replace(".", "_").Replace("`", "")
                     type = "Mono.Cecil.FieldDefinition"
                     find = "GetField"
                     parameters = splitted(1) & ", " & splitted(2)
                     isVBMember = splitted(1).StartsWith("MS_")
                 Case "ctor"
                     name = splitted(1) & "__ctor"
                     type = "Mono.Cecil.MethodDefinition"
                     param = 2
                     find = "GetConstructor"
                     parameters = splitted(1)
                     isVBMember = splitted(1).StartsWith("MS_")
                 Case Else
                     Helper.Stop()
                     Throw New NotImplementedException(splitted(0))
             End Select
 
             For i As Integer = param To splitted.GetUpperBound(0)
                 If noparaminname = False Then
                     Dim lastUScore As Integer
                     Dim p As String = splitted(i)
                     p = splitted(i)
                     p = p.Replace("_ByRef", "")
                     lastUScore = p.LastIndexOf("_"c) + 1
                     name &= "_" & p.Substring(lastUScore)
                 End If
                 If parameters IsNot Nothing Then parameters &= ", "
                 parameters &= splitted(i)
             Next
 
             If publicfields Then
                 variables.AppendLine(String.Format("    Public {0} As {1}", name, type))
             Else
                 variables.AppendLine(String.Format("    Private m_{0} As {1}", name, type))
             End If
 
             Dim text As String
             If publicfields Then
                 text = String.Format("        {0} = {1}({2})", name, find, parameters)
                 If isVB Then
                     vbtypes.AppendLine(text)
                 ElseIf isVBMember Then
                     vbmembers.AppendLine(text)
                 Else
                     getters.AppendLine(text)
                 End If
             Else
                 getters.AppendLine(String.Format("    Public ReadOnly Property {0} As {1}", name, type))
                 getters.AppendLine(String.Format("        Get"))
                 getters.AppendLine(String.Format("            If m_{0} Is Nothing Then", name))
                 getters.AppendLine(String.Format("                m_{0} = {1}({2})", name, find, parameters))
                 getters.AppendLine(String.Format("            End If"))
                 getters.AppendLine(String.Format("            Return m_{0}", name))
                 getters.AppendLine(String.Format("        End Get"))
                 getters.AppendLine(String.Format("    End Property"))
             End If
         Next
 
         If publicfields Then
             getters.AppendLine("    End Sub")
         End If
 
         vbtypes.AppendLine("    End Sub")
         vbmembers.AppendLine("    End Sub")
 
         Return variables.ToString & Environment.NewLine & getters.ToString & Environment.NewLine & vbtypes.ToString & Environment.NewLine & vbmembers.ToString
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmManual.vb" startline="177" endline="281">
<![CDATA[
 
     Private Sub ItmSearchEngine_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles ItmSearchEngine.Click
 
         On Error Resume Next
         Dim I, Indx As Integer
 
         If TabMain.SelectedIndex = 0 Then
 
             For I = 0 To LstPerformance.SelectedItems.Count - 1
                 Indx = LstPerformance.SelectedItems(I).Index
             Next
 
             If Indx = 0 Then
                 Process.Start(Search_Engine & """""Themes service""""")
             ElseIf Indx = 1 Then
                 Process.Start(Search_Engine & """""Desktop Window Manager Session Manager service""""")
             ElseIf Indx = 2 = True Then
                 Process.Start(Search_Engine & """""Windows Media Center Service Launcher""""")
             ElseIf Indx = 3 Then
                 Process.Start(Search_Engine & """""Windows Media Player Network Sharing Service""""")
             ElseIf Indx = 4 Then
                 Process.Start(Search_Engine & """""Windows Search service""""")
             ElseIf Indx = 5 Then
                 Process.Start(Search_Engine & """""Program Compatibility Assistant Service""""")
             ElseIf Indx = 6 Then
                 Process.Start(Search_Engine & """""Diagnostic Policy Service""""")
             ElseIf Indx = 7 Then
                 Process.Start(Search_Engine & """""Print Spooler service""""")
             ElseIf Indx = 8 Then
                 Process.Start(Search_Engine & """""Windows Image Acquisition (WIA) service""""")
             ElseIf Indx = 9 Then
                 Process.Start(Search_Engine & """""Tablet PC Input Service""""")
             ElseIf Indx = 10 Then
                 Process.Start(Search_Engine & """""System Event Notification Service""""")
             ElseIf Indx = 11 Then
                 Process.Start(Search_Engine & """""Secondary Logon service""""")
             ElseIf Indx = 12 Then
                 Process.Start(Search_Engine & """""Windows Error Reporting Service""""")
             ElseIf Indx = 13 Then
                 Process.Start(Search_Engine & """""Disk Defragmenter service""""")
             End If
 
         ElseIf TabMain.SelectedIndex = 1 Then
 
             For I = 0 To LstSecurity.SelectedItems.Count - 1
                 Indx = LstSecurity.SelectedItems(I).Index
             Next
 
             If Indx = 0 Then
                 Process.Start(Search_Engine & """""Security Center service""""")
             ElseIf Indx = 1 Then
                 Process.Start(Search_Engine & """""Windows Update service""""")
             ElseIf Indx = 2 Then
                 Process.Start(Search_Engine & """""Windows Defender service""""")
             ElseIf Indx = 3 Then
                 Process.Start(Search_Engine & """""Windows Firewall service""""")
             ElseIf Indx = 4 Then
                 Process.Start(Search_Engine & """""Windows Backup service""""")
             ElseIf Indx = 5 Then
                 Process.Start(Search_Engine & """""Remote Registry service""""")
             ElseIf Indx = 6 Then
                 Process.Start(Search_Engine & """""IPsec Policy Agent service""""")
             End If
 
         ElseIf TabMain.SelectedIndex = 2 Then
 
             For I = 0 To LstNetwork.SelectedItems.Count - 1
                 Indx = LstNetwork.SelectedItems(I).Index
             Next
 
             If Indx = 0 Then
                 Process.Start(Search_Engine & """""DHCP Client service""""")
             ElseIf Indx = 1 Then
                 Process.Start(Search_Engine & """""DNS Client service""""")
             ElseIf Indx = 2 Then
                 Process.Start(Search_Engine & """""DFS Replication service""""")
             ElseIf Indx = 3 Then
                 Process.Start(Search_Engine & """""Workstation service""""")
             ElseIf Indx = 4 Then
                 Process.Start(Search_Engine & """""Computer Browser service""""")
             ElseIf Indx = 5 Then
                 Process.Start(Search_Engine & """""Function Discovery Resource Publication service""""")
             ElseIf Indx = 6 Then
                 Process.Start(Search_Engine & """""Server service""""")
             ElseIf Indx = 7 Then
                 Process.Start(Search_Engine & """""TCP/IP NetBIOS Helper service""""")
             ElseIf Indx = 8 Then
                 Process.Start(Search_Engine & """""Terminal Services""""")
             ElseIf Indx = 9 Then
                 Process.Start(Search_Engine & """""UPnP Device Host service""""")
             ElseIf Indx = 10 Then
                 Process.Start(Search_Engine & """""Offline Files service""""")
             ElseIf Indx = 11 Then
                 Process.Start(Search_Engine & """""IP Helper service""""")
             ElseIf Indx = 12 Then
                 Process.Start(Search_Engine & """""WebClient service""""")
             ElseIf Indx = 13 Then
                 Process.Start(Search_Engine & """""Windows Time service""""")
             ElseIf Indx = 14 Then
                 Process.Start(Search_Engine & """""WLAN AutoConfig service""""")
             End If
 
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmManual.vb" startline="282" endline="386">
<![CDATA[
 
     Private Sub ItmBlkVpr_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles ItmBlkVpr.Click
 
         On Error Resume Next
         Dim I, Indx As Integer
 
         If TabMain.SelectedIndex = 0 Then
 
             For I = 0 To LstPerformance.SelectedItems.Count - 1
                 Indx = LstPerformance.SelectedItems(I).Index
             Next
 
             If Indx = 0 Then
                 Process.Start(BlackViper & "Themes.htm")
             ElseIf Indx = 1 Then
                 Process.Start(BlackViper & "Desktop_Window_Manager_Session_Manager.htm")
             ElseIf Indx = 2 = True Then
                 Process.Start(BlackViper & "Windows_Media_Center_Service_Launcher.htm")
             ElseIf Indx = 3 Then
                 Process.Start(BlackViper & "Windows_Media_Player_Network_Sharing_Service.htm")
             ElseIf Indx = 4 Then
                 Process.Start(BlackViper & "Windows_Search.htm")
             ElseIf Indx = 5 Then
                 Process.Start(BlackViper & "Program_Compatibility_Assistant_Service.htm")
             ElseIf Indx = 6 Then
                 Process.Start(BlackViper & "Diagnostic_Policy_Service.htm")
             ElseIf Indx = 7 Then
                 Process.Start(BlackViper & "Print_Spooler.htm")
             ElseIf Indx = 8 Then
                 Process.Start(BlackViper & "Windows_Image_Acquisition_(WIA).htm")
             ElseIf Indx = 9 Then
                 Process.Start(BlackViper & "Tablet_PC_Input_Service.htm")
             ElseIf Indx = 10 Then
                 Process.Start(BlackViper & "System_Event_Notification_Service.htm")
             ElseIf Indx = 11 Then
                 Process.Start(BlackViper & "Secondary_Logon.htm")
             ElseIf Indx = 12 Then
                 Process.Start(BlackViper & "Windows_Error_Reporting_Service.htm")
             ElseIf Indx = 13 Then
                 Process.Start(BlackViper & "Disk_Defragmenter.htm")
             End If
 
         ElseIf TabMain.SelectedIndex = 1 Then
 
             For I = 0 To LstSecurity.SelectedItems.Count - 1
                 Indx = LstSecurity.SelectedItems(I).Index
             Next
 
             If Indx = 0 Then
                 Process.Start(BlackViper & "Security_Center.htm")
             ElseIf Indx = 1 Then
                 Process.Start(BlackViper & "Windows_Update.htm")
             ElseIf Indx = 2 Then
                 Process.Start(BlackViper & "Windows_Defender.htm")
             ElseIf Indx = 3 Then
                 Process.Start(BlackViper & "Windows_Firewall.htm")
             ElseIf Indx = 4 Then
                 Process.Start(BlackViper & "Windows_Backup.htm")
             ElseIf Indx = 5 Then
                 Process.Start(BlackViper & "Remote_Registry.htm")
             ElseIf Indx = 6 Then
                 Process.Start(BlackViper & "IPsec_Policy_Agent.htm")
             End If
 
         ElseIf TabMain.SelectedIndex = 2 Then
 
             For I = 0 To LstNetwork.SelectedItems.Count - 1
                 Indx = LstNetwork.SelectedItems(I).Index
             Next
 
             If Indx = 0 Then
                 Process.Start(BlackViper & "DHCP_Client.htm")
             ElseIf Indx = 1 Then
                 Process.Start(BlackViper & "DNS_Client.htm")
             ElseIf Indx = 2 Then
                 Process.Start(BlackViper & "DFS_Replication.htm")
             ElseIf Indx = 3 Then
                 Process.Start(BlackViper & "Workstation.htm")
             ElseIf Indx = 4 Then
                 Process.Start(BlackViper & "Computer_Browser.htm")
             ElseIf Indx = 5 Then
                 Process.Start(BlackViper & "Function_Discovery_Resource_Publication.htm")
             ElseIf Indx = 6 Then
                 Process.Start(BlackViper & "Server.htm")
             ElseIf Indx = 7 Then
                 Process.Start(BlackViper & "TCP_IP_NetBIOS_Helper.htm")
             ElseIf Indx = 8 Then
                 Process.Start(BlackViper & "Terminal_Services.htm")
             ElseIf Indx = 9 Then
                 Process.Start(BlackViper & "UPnP_Device_Host.htm")
             ElseIf Indx = 10 Then
                 Process.Start(BlackViper & "Offline_Files.htm")
             ElseIf Indx = 11 Then
                 Process.Start(BlackViper & "IP_Helper.htm")
             ElseIf Indx = 12 Then
                 Process.Start(BlackViper & "WebClient.htm")
             ElseIf Indx = 13 Then
                 Process.Start(BlackViper & "Windows_Time.htm")
             ElseIf Indx = 14 Then
                 Process.Start(BlackViper & "WLAN_AutoConfig.htm")
             End If
 
         End If
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="1338" endline="1556">
<![CDATA[
 
     Private Function GetNextToken() As Token
         Dim Result As Token = Nothing
         Do
             Select Case CurrentChar()
                 Case nl27, nl201C, nl201D 'String Literal
                     Result = GetString()
                 Case COMMENTCHAR1, COMMENTCHAR2, COMMENTCHAR3 'VB Comment
                     EatComment()
                 Case nlD, nlA, nl2028, nl2029 'New line
 
                     'Keep the current line of the end of line token to the current line so we get better
                     'location info for errors and warnings
                     Result = Token.CreateEndOfLineToken(GetCurrentLocation)
                     EatNewLine()
 
                 Case nl0 'End of file
                     Result = Token.CreateEndOfFileToken(GetCurrentLocation)
                 Case "
                     NextChar()
                     Result = NewToken(KS.Colon)
                 Case ","c ',
                     NextChar()
                     Result = NewToken(KS.Comma)
                 Case "."c
                     If PeekChar() >= "0"c AndAlso PeekChar() <= "9"c Then
                         Result = GetNumber()
                     Else
                         NextChar()
                         Result = NewToken(KS.Dot)
                     End If
                 Case "0"c To "9"c
                     Result = GetNumber()
                 Case "("c
                     NextChar()
                     Result = NewToken(KS.LParenthesis)
                 Case ")"c
                     NextChar()
                     Result = NewToken(KS.RParenthesis)
                 Case "["c
                     Result = GetEscapedIdentifier()
                 Case "{"c
                     NextChar()
                     Result = NewToken(KS.LBrace)
                 Case "}"c
                     NextChar()
                     Result = NewToken(KS.RBrace)
                 Case ">"c
                     NextChar()
                     EatWhiteSpace()
                     'If CurrentChar() = "<"c Then
                     '    NextChar()
                     '    Result = NewToken(KS.NotEqual)
                     'Else
                     If CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.GE)
                     ElseIf CurrentChar() = ">"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftRightAssign)
                         Else
                             Result = NewToken(KS.ShiftRight)
                         End If
                     Else
                         Result = NewToken(KS.GT)
                     End If
                 Case "<"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = ">"c) Then
                         NextChar()
                         Result = NewToken(KS.NotEqual)
                     ElseIf CurrentChar() = "="c Then
                         NextChar()
                         Result = NewToken(KS.LE)
                     ElseIf CurrentChar() = "<"c Then
                         NextChar()
                         EatWhiteSpace()
                         If CurrentChar() = "="c Then
                             NextChar()
                             Result = NewToken(KS.ShiftLeftAssign)
                         Else
                             Result = NewToken(KS.ShiftLeft)
                         End If
                     Else
                         Result = NewToken(KS.LT)
                     End If
                 Case "="c
                     NextChar()
                     Result = NewToken(KS.Equals)
                 Case "!"c
                     NextChar()
                     Result = NewToken(KS.Exclamation)
                 Case "?"c
                     NextChar()
                     Result = NewToken(KS.Interrogation)
                 Case "&"c
                     Select Case PeekChar()
 #If EXTENDED Then
                         Case "b"c, "B"c, "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #Else
                         Case "h"c, "H"c, "o"c, "O"c, "d"c, "D"c
 #End If
                             Result = GetNumber()
                         Case Else 'Not a number, but operator
                             NextChar()
                             EatWhiteSpace()
                             If CurrentChar() = "="c Then
                                 Result = NewToken(KS.ConcatAssign)
                                 NextChar()
                             Else
                                 Result = NewToken(KS.Concat)
                             End If
                     End Select
                 Case "*"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MultAssign)
                     Else
                         Result = NewToken(KS.Mult)
                     End If
                 Case "+"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.AddAssign)
                     Else
                         Result = NewToken(KS.Add)
                     End If
                 Case "-"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.MinusAssign)
                     Else
                         Result = NewToken(KS.Minus)
                     End If
                 Case "^"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.PowerAssign)
                     Else
                         Result = NewToken(KS.Power)
                     End If
                 Case "\"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.IntDivAssign)
                     Else
                         Result = NewToken(KS.IntDivision)
                     End If
                 Case "#"c
                     'Type characters are already scanned when they appear after a literal. 
                     'If scanning gets here, it is not a type character.
                     If m_TokensSeenOnLine = 0 Then
                         Result = NewToken(KS.Numeral)
                         NextChar()
                     Else
                         Result = GetDate()
                     End If
                 Case "/"c
                     NextChar()
                     EatWhiteSpace()
                     If (CurrentChar() = "="c) Then
                         NextChar()
                         Result = NewToken(KS.RealDivAssign)
                     Else
                         Result = NewToken(KS.RealDivision)
                     End If
                 Case " "c 'Space
                     NextChar()
                     If (CurrentChar() = "_"c) Then '
                         Dim i As Integer = 1
                         Do While IsWhiteSpace(PeekChars(i))
                             i += 1
                         Loop
                         Do While IsWhiteSpace(PeekChars(i))
                             i += 1
                         Loop
                         If IsNewLine(PeekChars(i)) Then
                             NextChar()
                             EatWhiteSpace()
                             EatNewLine()
                         End If
                     End If
                 Case nlTab ' Tab character
                     NextChar()
                 Case Else
                     If IsWhiteSpace() Then
                         NextChar()
                     ElseIf CanStartIdentifier() Then
                         Result = GetIdentifier()
                         If Result.IsKeyword AndAlso Result.Equals(KS.[REM]) Then
                             EatLine(False)
                             Result = Nothing
                         End If
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30037, GetCurrentLocation())
                         EatLine(False)
                     End If
             End Select
         Loop While Token.IsSomething(Result) = False
 
         If Result.IsEndOfLine = False Then
             m_TokensSeenOnLine += 1
         Else
             m_TokensSeenOnLine = 0
         End If
 
         Return Result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="959" endline="1194">
<![CDATA[
 
     Function InferTypeArguments() As Boolean
         Dim GenericParameters As Mono.Collections.Generic.Collection(Of GenericParameter)
         Dim methodDef As MethodDefinition = TryCast(m_Member, MethodDefinition)
         Dim methodRef As MethodReference
 
         If methodDef Is Nothing Then
             methodRef = TryCast(m_Member, MethodReference)
             If methodRef IsNot Nothing Then
                 methodDef = CecilHelper.FindDefinition(methodRef)
             End If
         End If
 
         If methodDef IsNot Nothing Then
             If Not methodDef.HasGenericParameters Then Return True
             GenericParameters = methodDef.GenericParameters
         Else
             Return True
         End If
 
         If DefinedParameters.Count <> Arguments.Count Then
             'If m_Parent.ShowErrors Then Compiler.Report.ShowMessage(Messages.VBNC30057, Me.Parent.Location, Helper.ToString(Compiler, Member))
             Return True
         End If
 
         '* Generate a dependency graph *
         ' Given a set of arguments A1, A2, ?, AN, a set of matching parameters P1, P2, ?, PN and a set of method type parameters 
         ' T1, T2, ?, TN, the dependencies between the arguments and method type parameters are first collected as follows
 
         Dim A_deps() As Generic.List(Of GenericParameter) = Nothing
         Dim A_dep As Generic.List(Of GenericParameter)
 
         For i As Integer = 0 To Arguments.Count - 1
             Dim An As Argument = Arguments(i)
             Dim Pn As ParameterDefinition = m_DefinedParameters(i)
             Dim git As GenericInstanceType
             Dim gp As GenericParameter
 
             '?	If AN is the Nothing literal, no dependencies are generated.
             If TypeOf An.Expression Is NothingConstantExpression Then Continue For
 
             git = TryCast(Pn.ParameterType, GenericInstanceType)
             gp = TryCast(Pn.ParameterType, GenericParameter)
 
             '?	If AN is a lambda method and the type of PN is a constructed delegate type 
             '   or System.Linq.Expressions.Expression(Of T), where T is a constructed delegate type,
             '   ?	If the type of a lambda method parameter will be inferred from the type of the corresponding parameter PN, and the type of the parameter depends on a method type parameter TN, then AN has a dependency on TN.
             '   ?	If the type of a lambda method parameter is specified and the type of the corresponding parameter PN depends on a method type parameter TN, then TN has a dependency on AN.
             '   ?	If the return type of PN depends on a method type parameter TN, then TN has a dependency on AN.
             '* Lambda methods haven't been implemented yet *
 
             '?	If AN is a method pointer and the type of PN is a constructed delegate type,
             '   ?	If the return type of PN depends on a method type parameter TN, then TN has a dependency on AN.
             If An.Expression.Classification.IsMethodPointerClassification AndAlso Helper.IsDelegate(Compiler, Pn.ParameterType) AndAlso git IsNot Nothing Then
                 Dim invokeMethod As MethodReference = Helper.GetInvokeMethod(Compiler, Pn.ParameterType)
                 A_dep = Nothing
                 CollectGenericParameters(TryCast(invokeMethod.ReturnType, GenericInstanceType), GenericParameters, A_dep)
                 If A_dep IsNot Nothing Then
                     If A_deps Is Nothing Then ReDim A_deps(Arguments.Count - 1)
                     A_deps(i) = A_dep
                 End If
                 Continue For
             End If
 
             '?	If PN is a constructed type and the type of PN depends on a method type parameter TN, then TN has a dependency on AN.
             If git IsNot Nothing Then
                 A_dep = Nothing
                 CollectGenericParameters(git, GenericParameters, A_dep)
                 If A_dep IsNot Nothing Then
                     If A_deps Is Nothing Then ReDim A_deps(Arguments.Count - 1)
                     A_deps(i) = A_dep
                 End If
                 Continue For
             ElseIf gp IsNot Nothing AndAlso GenericParameters.Contains(gp) Then
                 If A_deps Is Nothing Then ReDim A_deps(Arguments.Count - 1)
                 A_dep = New Generic.List(Of GenericParameter)
                 A_dep.Add(gp)
                 A_deps(i) = A_dep
                 Continue For
             End If
 
             '?	Otherwise, no dependency is generated.
         Next
 
         ' After collecting dependencies, any arguments that have no dependencies are eliminated.
         '* eliminated arguments are represented by null entries in the A_deps array
 
         ' If any method type parameters have no outgoing dependencies (i.e. the method type parameter does not depend on an argument), then type inference fails. 
         If A_deps Is Nothing Then
             If m_Parent.ShowErrors Then Compiler.Report.ShowMessage(Messages.VBNC32050, Me.Parent.Location, GenericParameters(0).Name, Helper.ToString(Compiler, m_Member))
             Return False '* No dependencies at all
         End If
         For i As Integer = 0 To GenericParameters.Count - 1
             Dim found As Boolean = False
             For a As Integer = 0 To A_deps.Length - 1
                 If A_deps(a) Is Nothing Then Continue For
                 If A_deps(a).Contains(GenericParameters(i)) Then
                     found = True
                     Exit For
                 End If
             Next
             If Not found Then
                 If m_Parent.ShowErrors Then Compiler.Report.ShowMessage(Messages.VBNC32050, Me.Parent.Location, GenericParameters(i).Name, Helper.ToString(Compiler, m_Member))
                 Return False '* GenericParameter(i) does not have a dependency
             End If
         Next
 
         Dim hints As TypeHints()
         ReDim hints(GenericParameters.Count - 1)
 
         ' Otherwise, the remaining arguments and method type parameters are grouped into strongly connected components.
         ' A strongly connected component is a set of arguments and method type parameters,
         ' where any element in the component is reachable via dependencies on other elements.
         ' The strongly connected components are then topologically sorted and processed in topological order
         '* Since we don't have lambda methods yet, we only have a tree of dependencies (method type parameters on arguments)
         '* We'll always have one element in each the stronly connected component, so just look over each argument and each method type parameter
 
         '?	If the strongly typed component contains only one element,
         '   ?	If the element has already been marked complete, skip it.
         '   ?	If the element is an argument, then add type hints from the argument to the method type parameters 
         '       that depend on it and mark the element as complete. If the argument is a lambda method with parameters 
         '       that still need inferred types, then infer Object for the types of those parameters.
         For i As Integer = 0 To A_deps.Length - 1
             Dim Ta As TypeReference
             Dim Tp As TypeReference
             If A_deps(i) Is Nothing Then Continue For
 
             Ta = Arguments(i).Expression.ExpressionType
             Tp = DefinedParameters(i).ParameterType
             For a As Integer = 0 To A_deps(i).Count - 1
                 Dim Tg As GenericParameter = A_deps(i)(a)
                 Dim aI As Integer = GenericParameters.IndexOf(Tg)
                 Dim hint As TypeHints = hints(aI)
 
                 If hints(aI) Is Nothing Then
                     hint = New TypeHints(Me)
                     hints(aI) = hint
                 End If
 
                 If hint.GenerateHint(GenericParameters, Ta, DefinedParameters(i)) = False Then
                     If m_Parent.ShowErrors Then Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Parent.Location)
                     Return False
                 End If
 
             Next
             '       If the argument is a lambda method with parameters 
             '       that still need inferred types, then infer Object for the types of those parameters.
             '* no lambda method support yet *
         Next
 
         '   ?	If the element is a method type parameter, then infer the method type parameter to be the dominant
         '       type among the argument type hints and mark the element as complete. If a type hint has an array element 
         '       restriction on it, then only conversions that are valid between arrays of the given type are considered 
         '       (i.e. covariant and intrinsic array conversions). If a type hint has a generic argument restriction on it, 
         '       then only identity conversions are considered. If no dominant type can be chosen, inference fails. 
         '       If any lambda method argument types depend on this method type parameter, the type is propagated to the lambda method.
         Dim m_InferredTypeArguments As New Mono.Collections.Generic.Collection(Of TypeReference)(GenericParameters.Count)
         For i As Integer = 0 To GenericParameters.Count - 1
             Dim hint As TypeHints = hints(i)
             Dim types As Generic.List(Of TypeReference)
             Dim dominantType As TypeReference
             Dim generic_argument_restriction As Boolean
             Dim array_element_restriction As Boolean
             types = New Generic.List(Of TypeReference)(hint.Hints.Count)
 
             For h As Integer = 0 To hint.Hints.Count - 1
                 Dim hi As TypeHint = hint.Hints(h)
                 If hi.GenericArgumentRestriction Then
                     generic_argument_restriction = True
                 ElseIf hi.ArrayElementRestriction Then
                     array_element_restriction = True
                 End If
 
                 Dim found As Boolean
                 For t As Integer = 0 To types.Count - 1
                     If Helper.CompareType(types(t), hi.Hint) Then
                         found = True
                         Exit For
                     End If
                 Next
                 If Not found Then types.Add(hi.Hint)
             Next
 
             If types.Count = 0 Then
                 If m_Parent.ShowErrors Then Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Parent.Location)
                 Return False
             End If
 
             If generic_argument_restriction Then
                 'all types must be identical
                 dominantType = types(0)
                 For t As Integer = 1 To types.Count - 1
                     If Helper.CompareType(types(t), dominantType) = False Then
                         If m_Parent.ShowErrors Then Compiler.Report.ShowMessage(Messages.VBNC36657, Me.Parent.Location, Helper.ToString(Compiler, m_Member))
                         Return False
                     End If
                 Next
             ElseIf array_element_restriction Then
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Parent.Location, "Type argument inference with array element restriction")
             Else
                 dominantType = Helper.GetDominantType(Compiler, types)
             End If
 
             If dominantType Is Nothing Then
                 If m_Parent.ShowErrors Then Compiler.Report.ShowMessage(Messages.VBNC36651, Me.Parent.Location, Helper.ToString(Compiler, m_Member))
                 Return False
             End If
             m_InferredTypeArguments.Add(dominantType)
         Next
 
         '?	If the strongly typed component contains more than one element, then the component contains a cycle.
         '   ?	For each method type parameter that is an element in the component, if the method type parameter depends
         '       on an argument that is not marked complete, convert that dependency into an assertion that will be 
         '       checked at the end of the inference process.
         '   ?	Restart the inference process at the point at which the strongly typed components were determined.
         '* This can't happen until lambda methods have been implemented, since only lambda methods can have a dependency 
         '* from method type parameters to arguments, so until then this is just a tree of arguments to method type parameters, 
         '* not a cyclic graph *
 
         'If type inference succeeds for all of the method type parameters, then any dependencies that were changed 
         'into assertions are checked. An assertion succeeds if the type of the argument is implicitly convertible 
         'to the inferred type of the method type parameter. If an assertion fails, then type argument inference fails.
         '* no assertions are added until lambda support has been implemented, so nothing to do here for now *
 
         '* type inference succeeded, inflate our method *
         Dim inflated_method As MethodReference = CecilHelper.GetCorrectMember(methodDef, m_InferredTypeArguments)
         Dim gim As New GenericInstanceMethod(inflated_method)
         gim.GenericArguments.AddRange(m_InferredTypeArguments)
         m_Member = gim
         m_DefinedParameters = Nothing
         m_DefinedParametersTypes = Nothing
         m_TypesInInvokedOrder = Nothing
 
         'The success of type inference does not, in and of itself, guarantee that the method is applicable.
         Return True
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="97" endline="118">
<![CDATA[
 
     Sub New(ByVal Compiler As Compiler)
         MyBase.New(Compiler)
     Friend BuiltInTypes As New Generic.List(Of Mono.Cecil.TypeReference)(New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_Boolean, Compiler.TypeCache.System_Byte, Compiler.TypeCache.System_Char, Compiler.TypeCache.System_DateTime, Compiler.TypeCache.System_Double, Compiler.TypeCache.System_Int32, Compiler.TypeCache.System_int64, Compiler.TypeCache.System_Object, Compiler.TypeCache.System_int16, Compiler.TypeCache.System_Single, Compiler.TypeCache.System_String, Compiler.TypeCache.System_SByte, Compiler.TypeCache.System_UInt16, Compiler.TypeCache.System_UInt32, Compiler.TypeCache.System_Uint64})
     Friend NumericTypes As New Generic.List(Of Mono.Cecil.TypeReference)(New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_Byte, Compiler.TypeCache.System_SByte, Compiler.TypeCache.System_Decimal, Compiler.TypeCache.System_Double, Compiler.TypeCache.System_Single, Compiler.TypeCache.System_int16, Compiler.TypeCache.System_UInt16, Compiler.TypeCache.System_Int32, Compiler.TypeCache.System_UInt32, Compiler.TypeCache.System_int64, Compiler.TypeCache.System_Uint64})
     Friend IntegralTypes As New Generic.List(Of Mono.Cecil.TypeReference)(New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_Byte, Compiler.TypeCache.System_SByte, Compiler.TypeCache.System_int16, Compiler.TypeCache.System_Uint16, Compiler.TypeCache.System_Int32, Compiler.TypeCache.System_UInt32, Compiler.TypeCache.System_int64, Compiler.TypeCache.System_Uint64})
 
     Private valCanBeContainBy(15)() As Mono.Cecil.TypeReference
 
     Public Shared Conversion As TypeConversionInfo(,)
 
     Private Shared m_ImplicitlyConvertedIntrinsicTypes As New Generic.Dictionary(Of Mono.Cecil.TypeReference, TypeCode())
 
     Shared Function GetIntrinsicTypesImplicitlyConvertibleFrom(ByVal Compiler As Compiler, ByVal Type As Mono.Cecil.TypeReference) As TypeCode()
         Dim result As TypeCode() = Nothing
 
         If m_ImplicitlyConvertedIntrinsicTypes.TryGetValue(Type, result) Then
             Return result
         End If
 
         If Helper.CompareType(Type, Compiler.TypeCache.System_Char_Array) Then
             result = New TypeCode() {TypeCode.String}
         End If
 
         If result IsNot Nothing Then
             m_ImplicitlyConvertedIntrinsicTypes.Add(Type, result)
         End If
 
         Return result
     End Function
 
     Shared Sub New()
         Dim highest As Integer
 
         Dim tmp As Array = System.Enum.GetValues(GetType(TypeCode))
         highest = CInt(tmp.GetValue(tmp.GetUpperBound(0)))
 
         ReDim Conversion(highest, highest)
         For i As Integer = 0 To highest
             For j As Integer = 0 To highest
                 Conversion(i, j) = New TypeConversionInfo
                 If j = TypeCode.Object OrElse j = i Then
                     Conversion(i, j).Conversion = ConversionType.Implicit
                 ElseIf i = TypeCode.Char OrElse j = TypeCode.Char Then
                     Conversion(i, j).Conversion = ConversionType.None
                 ElseIf i = TypeCode.DateTime OrElse j = TypeCode.DateTime Then
                     Conversion(i, j).Conversion = ConversionType.None
                 ElseIf i = TypeCode.DBNull OrElse j = TypeCode.DBNull Then
                     Conversion(i, j).Conversion = ConversionType.None
                 Else
                     Conversion(i, j).Conversion = ConversionType.Explicit
                 End If
             Next
         Next
 
         setImplicit(TypeCode.SByte, New TypeCode() {TypeCode.Int16, TypeCode.Int32, TypeCode.Int64, TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.Byte, New TypeCode() {TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.Int16, New TypeCode() {TypeCode.Int32, TypeCode.Int64, TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.UInt16, New TypeCode() {TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.Int32, New TypeCode() {TypeCode.Int64, TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.UInt32, New TypeCode() {TypeCode.Int64, TypeCode.UInt64, TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.Int64, New TypeCode() {TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.UInt64, New TypeCode() {TypeCode.Decimal, TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.Decimal, New TypeCode() {TypeCode.Single, TypeCode.Double})
         setImplicit(TypeCode.Single, New TypeCode() {TypeCode.Double})
         setImplicit(TypeCode.Double, New TypeCode() {})
         setImplicit(TypeCode.Char, New TypeCode() {TypeCode.String})
         setImplicit(TypeCode.DBNull, New TypeCode() {TypeCode.String})
 
         Conversion(TypeCode.DateTime, TypeCode.String).Conversion = ConversionType.Explicit
         Conversion(TypeCode.Byte, TypeCode.Byte).BinaryAddResult = TypeCode.Byte
         Conversion(TypeCode.Boolean, TypeCode.Boolean).BinaryAddResult = TypeCode.SByte
     End Sub
 
     Sub New(ByVal Compiler As Compiler)
         MyBase.New(Compiler)
 
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.Boolean)) = Nothing
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.Byte)) = New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_Byte, Compiler.TypeCache.System_Int16, Compiler.TypeCache.System_UInt16, Compiler.TypeCache.System_Int32, Compiler.TypeCache.System_UInt32, Compiler.TypeCache.System_Int64, Compiler.TypeCache.System_UInt64, Compiler.TypeCache.System_Decimal, Compiler.TypeCache.System_Double, Compiler.TypeCache.System_Single}
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.Char)) = Nothing
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.Date)) = Nothing
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.Decimal)) = New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_Decimal, Compiler.TypeCache.System_Double, Compiler.TypeCache.System_Single}
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.Double)) = New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_Double}
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.Integer)) = New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_Int32, Compiler.TypeCache.System_Int64, Compiler.TypeCache.System_Decimal, Compiler.TypeCache.System_Double, Compiler.TypeCache.System_Single}
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.Long)) = New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_Int64, Compiler.TypeCache.System_Decimal, Compiler.TypeCache.System_Double, Compiler.TypeCache.System_Single}
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.Object)) = Nothing
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.[SByte])) = New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_SByte, Compiler.TypeCache.System_Int16, Compiler.TypeCache.System_Int32, Compiler.TypeCache.System_Int64, Compiler.TypeCache.System_Decimal, Compiler.TypeCache.System_Double, Compiler.TypeCache.System_Single}
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.Short)) = New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_Int16, Compiler.TypeCache.System_Int32, Compiler.TypeCache.System_Int64, Compiler.TypeCache.System_Decimal, Compiler.TypeCache.System_Double, Compiler.TypeCache.System_Single}
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.Single)) = New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_Double, Compiler.TypeCache.System_Single}
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.String)) = Nothing
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.[UInteger])) = New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_UInt32, Compiler.TypeCache.System_Int64, Compiler.TypeCache.System_UInt64, Compiler.TypeCache.System_Decimal, Compiler.TypeCache.System_Double, Compiler.TypeCache.System_Single}
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.[ULong])) = New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_UInt64, Compiler.TypeCache.System_Decimal, Compiler.TypeCache.System_Double, Compiler.TypeCache.System_Single}
         valCanBeContainBy(getTypeIndex(BuiltInDataTypes.[UShort])) = New Mono.Cecil.TypeReference() {Compiler.TypeCache.System_UInt16, Compiler.TypeCache.System_Int32, Compiler.TypeCache.System_UInt32, Compiler.TypeCache.System_Int64, Compiler.TypeCache.System_UInt64, Compiler.TypeCache.System_Decimal, Compiler.TypeCache.System_Double, Compiler.TypeCache.System_Single}
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="4174" endline="4292">
<![CDATA[
 
     Private Sub ChangeLanguage()
 
         With mTranslator
             'MPcontrols
             MPcontrols.cFFwd.ToolTipText = .LangText(31)
             MPcontrols.cFRev.ToolTipText = .LangText(32)
             MPcontrols.cEnd.ToolTipText = .LangText(39)
             MPcontrols.cBegin.ToolTipText = .LangText(40)
             MPcontrols.cSelEnd.ToolTipText = .LangText(42)
             MPcontrols.cSelStrt.ToolTipText = .LangText(43)
             MPcontrols.cMute.ToolTipText = .LangText(47)
             MPcontrols.cPlay.ToolTipText = .LangText(55)
             MPcontrols.cStop.ToolTipText = .LangText(86)
 
             'This form
             Label9.Text = .LangText(0)
             MenuItem6.Text = .LangText(1)
             mnuCheckUpdate.Text = .LangText(2)
             MenuItem9.Text = .LangText(3)
             MenuItem10.Text = .LangText(4)
             MenuItem1.Text = .LangText(5)
             MenuItem5.Text = .LangText(6)
             mnuHelp.Text = .LangText(6)
             mnuOpen.Text = .LangText(7)
             MenuItem11.Text = .LangText(8)
             MenuItem7.Text = .LangText(9)
             mnuSaveMask.Text = .LangText(10)
             cSplit.Text = .LangText(11)
             MenuItem3.Text = .LangText(12)
             MenuItem2.Text = .LangText(13)
             tabSettings.Text = .LangText(15)
             chkAuto.Text = .LangText(16)
             cSplitBrw.Text = .LangText(17)
             cClear.ToolTipText = .LangText(19)
             tcClearTrace.ToolTipText = .LangText(20)
             chkKeepMRU.Text = .LangText(115)
             chkDel.Text = .LangText(22)
             mnuExit.Text = .LangText(25)
             cTransleditor.Text = .LangText(26)
             chkFrameAccurate.Text = .LangText(27)
             colEnd.Text = .LangText(28)
             Label7.Text = .LangText(29)
             chkForceJoin.Text = .LangText(33)
             mnuFullscreen.Text = .LangText(34)
             GroupBox3.Text = .LangText(35)
             tabJoin.Text = .LangText(36)
             cJoin.ToolTipText = .LangText(37)
             GroupBox4.Text = .LangText(41)
             cDn.ToolTipText = .LangText(45)
             cUp.ToolTipText = .LangText(46)
             Label6.Text = .LangText(48)
             Label1.Text = .LangText(50)
             cOpenMask.ToolTipText = .LangText(51)
             rtfTrace.Text = .LangText(53)
             radPieces.Text = .LangText(54)
             mnuPlaySel.Text = .LangText(56)
             cPlayAll.ToolTipText = .LangText(57)
             radTime.Text = .LangText(58)
             mnuTestSeg.Text = .LangText(59)
             mnuLoop.Text = .LangText(60)
             cPlaySelected.ToolTipText = .LangText(61)
             mnuPlayUns.Text = .LangText(62)
             tabPlayer.Text = .LangText(63)
             cPlayNotSelected.ToolTipText = .LangText(64)
             cRemove.ToolTipText = .LangText(66)
             cLoop.ToolTipText = .LangText(67)
             mnuSave.Text = .LangText(68)
             mnuSaveX.Text = .LangText(69)
             tcSaveTrace.ToolTipText = .LangText(70)
             cSaveMask.ToolTipText = .LangText(71)
             cOpen.ToolTipText = .LangText(73)
             GroupBox1.Text = .LangText(74)
             Label11.Text = .LangText(75)
             mnuInfo.Text = .LangText(76)
             CheckBox1.Text = .LangText(77)
             cInfo.ToolTipText = .LangText(78)
             chkDialogView.Text = .LangText(79)
             radSize.Text = .LangText(80)
             cSort.ToolTipText = .LangText(81)
             tabSplit.Text = .LangText(82)
             colStart.Text = .LangText(83)
             statMain.Text = .LangText(84)
             lMsgStat.Text = .LangText(85)
             lpanFineText.Text = .LangText(88)
             tabTrace.Text = .LangText(89)
             chkOnTop.Text = .LangText(90)
             chkUpdate.Text = .LangText(95)
             mnuImpSkip.Text = .LangText(106)
             mnuImpComskip.Text = .LangText(105)
             GroupBox2.Text = .LangText(108)
             mnuSaveSepFiles.Text = .LangText(109)
             mnuDonate.Text = .LangText(116)
             mnuView.Text = .LangText(123)
             mnuCompact.Text = .LangText(124)
             chkBeep.Text = .LangText(126)
             mnuUnload.Text = .LangText(128)
 
             'Tools tab
             tabTools.Text = .LangText(104)
             chkEnabled.Text = .LangText(97)
             Label10.Text = .LangText(98)
             cDetect.Text = .LangText(101)
             cToolFind.Text = .LangText(17)
             GroupBox5.Text = .LangText(99)
             GroupBox6.Text = .LangText(100)
             mnuDShow.Text = .LangText(114)
             cDShow.Text = .LangText(114)
             linkToolURL.Text = .LangText(103)
 
             'Tooltips on this form
             ToolTips.SetToolTip(Me.cStrtFrRev, .LangText(91))
             ToolTips.SetToolTip(Me.cStrtFrFwd, .LangText(92))
             ToolTips.SetToolTip(Me.cEndFrRev, .LangText(93))
             ToolTips.SetToolTip(Me.cEndFrFwd, .LangText(94))
 
         End With
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmAuto.vb" startline="15" endline="274">
<![CDATA[
 
     Private components As System.ComponentModel.IContainer
 
     <System.Diagnostics.DebuggerStepThrough()> _
     Private Sub InitializeComponent()
         Dim resources As System.ComponentModel.ComponentResourceManager = New System.ComponentModel.ComponentResourceManager(GetType(FrmAuto))
         Me.PnlMain = New System.Windows.Forms.Panel
         Me.BoxTasks = New ComponentFactory.Krypton.Toolkit.KryptonGroup
         Me.HdrTasks = New ComponentFactory.Krypton.Toolkit.KryptonHeader
         Me.LnkManTuneUp = New ComponentFactory.Krypton.Toolkit.KryptonLinkLabel
         Me.RdoMaxOpt = New System.Windows.Forms.RadioButton
         Me.RdoMinOpt = New System.Windows.Forms.RadioButton
         Me.LnkProfile = New ComponentFactory.Krypton.Toolkit.KryptonLinkLabel
         Me.LnkExport = New ComponentFactory.Krypton.Toolkit.KryptonLinkLabel
         Me.LblInfo = New System.Windows.Forms.Label
         Me.BtnClose = New System.Windows.Forms.Button
         Me.BtnOptimize = New System.Windows.Forms.Button
         Me.BWAutoTuneUp = New System.ComponentModel.BackgroundWorker
         Me.HdrMain = New ComponentFactory.Krypton.Toolkit.KryptonHeader
         Me.LnkRescueCntr = New ComponentFactory.Krypton.Toolkit.KryptonLinkLabel
         Me.PnlMain.SuspendLayout()
         CType(Me.BoxTasks, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.BoxTasks.Panel, System.ComponentModel.ISupportInitialize).BeginInit()
         Me.BoxTasks.Panel.SuspendLayout()
         Me.BoxTasks.SuspendLayout()
         Me.SuspendLayout()
         '
         'PnlMain
         '
         Me.PnlMain.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
                     Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.PnlMain.BackColor = System.Drawing.Color.White
         Me.PnlMain.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.PnlMain.Controls.Add(Me.BoxTasks)
         Me.PnlMain.Controls.Add(Me.LblInfo)
         Me.PnlMain.Location = New System.Drawing.Point(-2, 49)
         Me.PnlMain.Name = "PnlMain"
         Me.PnlMain.Size = New System.Drawing.Size(663, 500)
         Me.PnlMain.TabIndex = 1
         '
         'BoxTasks
         '
         Me.BoxTasks.Anchor = CType(((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.BoxTasks.GroupBackStyle = ComponentFactory.Krypton.Toolkit.PaletteBackStyle.TabOneNote
         Me.BoxTasks.Location = New System.Drawing.Point(39, 130)
         Me.BoxTasks.Name = "BoxTasks"
         Me.BoxTasks.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Silver
         '
         'BoxTasks.Panel
         '
         Me.BoxTasks.Panel.Controls.Add(Me.LnkRescueCntr)
         Me.BoxTasks.Panel.Controls.Add(Me.HdrTasks)
         Me.BoxTasks.Panel.Controls.Add(Me.LnkManTuneUp)
         Me.BoxTasks.Panel.Controls.Add(Me.RdoMaxOpt)
         Me.BoxTasks.Panel.Controls.Add(Me.RdoMinOpt)
         Me.BoxTasks.Panel.Controls.Add(Me.LnkProfile)
         Me.BoxTasks.Panel.Controls.Add(Me.LnkExport)
         Me.BoxTasks.Size = New System.Drawing.Size(580, 250)
         Me.BoxTasks.StateNormal.Border.Rounding = 3
         Me.BoxTasks.TabIndex = 1
         '
         'HdrTasks
         '
         Me.HdrTasks.Dock = System.Windows.Forms.DockStyle.Top
         Me.HdrTasks.HeaderStyle = ComponentFactory.Krypton.Toolkit.HeaderStyle.DockInactive
         Me.HdrTasks.Location = New System.Drawing.Point(0, 0)
         Me.HdrTasks.Name = "HdrTasks"
         Me.HdrTasks.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Silver
         Me.HdrTasks.Size = New System.Drawing.Size(576, 26)
         Me.HdrTasks.StateNormal.Back.ColorStyle = ComponentFactory.Krypton.Toolkit.PaletteColorStyle.HalfCut
         Me.HdrTasks.StateNormal.Border.DrawBorders = ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom
         Me.HdrTasks.StateNormal.Border.Rounding = 3
         Me.HdrTasks.StateNormal.Content.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.HdrTasks.StateNormal.Content.ShortText.Font = New System.Drawing.Font("Segoe UI", 11.25!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.HdrTasks.TabIndex = 0
         Me.HdrTasks.TabStop = False
         Me.HdrTasks.Values.Description = ""
         Me.HdrTasks.Values.Heading = "Automatic TuneUp Tasks"
         Me.HdrTasks.Values.Image = Nothing
         '
         'LnkManTuneUp
         '
         Me.LnkManTuneUp.LinkBehavior = ComponentFactory.Krypton.Toolkit.KryptonLinkBehavior.HoverUnderline
         Me.LnkManTuneUp.Location = New System.Drawing.Point(22, 142)
         Me.LnkManTuneUp.Name = "LnkManTuneUp"
         Me.LnkManTuneUp.OverrideNotVisited.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkManTuneUp.OverrideNotVisited.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkManTuneUp.OverridePressed.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkManTuneUp.OverridePressed.ShortText.Color1 = System.Drawing.Color.RoyalBlue
         Me.LnkManTuneUp.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Blue
         Me.LnkManTuneUp.Size = New System.Drawing.Size(218, 20)
         Me.LnkManTuneUp.StateNormal.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkManTuneUp.StateNormal.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkManTuneUp.TabIndex = 4
         Me.LnkManTuneUp.Values.Text = "Optimize Windows services manually"
         '
         'RdoMaxOpt
         '
         Me.RdoMaxOpt.AutoSize = True
         Me.RdoMaxOpt.BackColor = System.Drawing.Color.Transparent
         Me.RdoMaxOpt.Location = New System.Drawing.Point(29, 73)
         Me.RdoMaxOpt.Name = "RdoMaxOpt"
         Me.RdoMaxOpt.Size = New System.Drawing.Size(397, 19)
         Me.RdoMaxOpt.TabIndex = 2
         Me.RdoMaxOpt.TabStop = True
         Me.RdoMaxOpt.Text = "Optimize all Windows services for &maximum performance and security"
         Me.RdoMaxOpt.UseVisualStyleBackColor = True
         '
         'RdoMinOpt
         '
         Me.RdoMinOpt.AutoSize = True
         Me.RdoMinOpt.BackColor = System.Drawing.Color.Transparent
         Me.RdoMinOpt.Checked = True
         Me.RdoMinOpt.Location = New System.Drawing.Point(29, 50)
         Me.RdoMinOpt.Name = "RdoMinOpt"
         Me.RdoMinOpt.Size = New System.Drawing.Size(328, 19)
         Me.RdoMinOpt.TabIndex = 1
         Me.RdoMinOpt.TabStop = True
         Me.RdoMinOpt.Text = "Optimize Windows services based on my &user profile only"
         Me.RdoMinOpt.UseVisualStyleBackColor = True
         '
         'LnkProfile
         '
         Me.LnkProfile.LinkBehavior = ComponentFactory.Krypton.Toolkit.KryptonLinkBehavior.HoverUnderline
         Me.LnkProfile.Location = New System.Drawing.Point(22, 112)
         Me.LnkProfile.Name = "LnkProfile"
         Me.LnkProfile.OverrideNotVisited.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkProfile.OverrideNotVisited.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkProfile.OverridePressed.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkProfile.OverridePressed.ShortText.Color1 = System.Drawing.Color.RoyalBlue
         Me.LnkProfile.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Blue
         Me.LnkProfile.Size = New System.Drawing.Size(181, 20)
         Me.LnkProfile.StateNormal.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkProfile.StateNormal.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkProfile.TabIndex = 3
         Me.LnkProfile.Values.Text = "Change current user profile"
         '
         'LnkExport
         '
         Me.LnkExport.Enabled = False
         Me.LnkExport.LinkBehavior = ComponentFactory.Krypton.Toolkit.KryptonLinkBehavior.HoverUnderline
         Me.LnkExport.Location = New System.Drawing.Point(22, 172)
         Me.LnkExport.Name = "LnkExport"
         Me.LnkExport.OverrideNotVisited.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkExport.OverrideNotVisited.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkExport.OverridePressed.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkExport.OverridePressed.ShortText.Color1 = System.Drawing.Color.RoyalBlue
         Me.LnkExport.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Blue
         Me.LnkExport.Size = New System.Drawing.Size(190, 20)
         Me.LnkExport.StateDisabled.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkExport.StateDisabled.ShortText.Color1 = System.Drawing.Color.DimGray
         Me.LnkExport.StateNormal.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkExport.StateNormal.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkExport.TabIndex = 5
         Me.LnkExport.Values.Text = "Export Windows services status"
         '
         'LblInfo
         '
         Me.LblInfo.Anchor = CType(((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.LblInfo.Location = New System.Drawing.Point(16, 23)
         Me.LblInfo.Name = "LblInfo"
         Me.LblInfo.Size = New System.Drawing.Size(620, 90)
         Me.LblInfo.TabIndex = 0
         Me.LblInfo.Text = resources.GetString("LblInfo.Text")
         '
         'BtnClose
         '
         Me.BtnClose.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.BtnClose.Location = New System.Drawing.Point(562, 560)
         Me.BtnClose.Name = "BtnClose"
         Me.BtnClose.Size = New System.Drawing.Size(85, 25)
         Me.BtnClose.TabIndex = 3
         Me.BtnClose.Text = "&Close"
         Me.BtnClose.UseVisualStyleBackColor = True
         '
         'BtnOptimize
         '
         Me.BtnOptimize.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.BtnOptimize.Location = New System.Drawing.Point(471, 560)
         Me.BtnOptimize.Name = "BtnOptimize"
         Me.BtnOptimize.Size = New System.Drawing.Size(85, 25)
         Me.BtnOptimize.TabIndex = 2
         Me.BtnOptimize.Text = "&Optimize"
         Me.BtnOptimize.UseVisualStyleBackColor = True
         '
         'BWAutoTuneUp
         '
         Me.BWAutoTuneUp.WorkerReportsProgress = True
         Me.BWAutoTuneUp.WorkerSupportsCancellation = True
         '
         'HdrMain
         '
         Me.HdrMain.Dock = System.Windows.Forms.DockStyle.Top
         Me.HdrMain.Location = New System.Drawing.Point(0, 0)
         Me.HdrMain.Name = "HdrMain"
         Me.HdrMain.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2007Silver
         Me.HdrMain.Size = New System.Drawing.Size(659, 53)
         Me.HdrMain.StateNormal.Back.Color1 = System.Drawing.Color.White
         Me.HdrMain.StateNormal.Back.Color2 = System.Drawing.Color.Gainsboro
         Me.HdrMain.StateNormal.Back.ColorStyle = ComponentFactory.Krypton.Toolkit.PaletteColorStyle.HalfCut
         Me.HdrMain.StateNormal.Border.DrawBorders = ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom
         Me.HdrMain.StateNormal.Content.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.HdrMain.StateNormal.Content.ShortText.Font = New System.Drawing.Font("Calibri", 27.75!, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.HdrMain.TabIndex = 0
         Me.HdrMain.TabStop = False
         Me.HdrMain.Values.Description = ""
         Me.HdrMain.Values.Heading = " Automatic TuneUp"
         Me.HdrMain.Values.Image = Nothing
         '
         'LnkRescueCntr
         '
         Me.LnkRescueCntr.LinkBehavior = ComponentFactory.Krypton.Toolkit.KryptonLinkBehavior.HoverUnderline
         Me.LnkRescueCntr.Location = New System.Drawing.Point(22, 202)
         Me.LnkRescueCntr.Name = "LnkRescueCntr"
         Me.LnkRescueCntr.OverrideNotVisited.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkRescueCntr.OverrideNotVisited.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkRescueCntr.OverridePressed.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkRescueCntr.OverridePressed.ShortText.Color1 = System.Drawing.Color.RoyalBlue
         Me.LnkRescueCntr.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Blue
         Me.LnkRescueCntr.Size = New System.Drawing.Size(276, 20)
         Me.LnkRescueCntr.StateNormal.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkRescueCntr.StateNormal.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkRescueCntr.TabIndex = 6
         Me.LnkRescueCntr.Values.Text = "Restore default Windows services configurations"
         '
         'FrmAuto
         '
         Me.AcceptButton = Me.BtnOptimize
         Me.AutoScaleMode = System.Windows.Forms.AutoScaleMode.None
         Me.ClientSize = New System.Drawing.Size(659, 596)
         Me.ControlBox = False
         Me.Controls.Add(Me.HdrMain)
         Me.Controls.Add(Me.BtnClose)
         Me.Controls.Add(Me.BtnOptimize)
         Me.Controls.Add(Me.PnlMain)
         Me.DoubleBuffered = True
         Me.Font = New System.Drawing.Font("Segoe UI", 9.0!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.ForeColor = System.Drawing.Color.Black
         Me.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None
         Me.MaximizeBox = False
         Me.MinimizeBox = False
         Me.Name = "FrmAuto"
         Me.ShowIcon = False
         Me.ShowInTaskbar = False
         Me.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide
         Me.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen
         Me.Text = "Automatic TuneUp"
         Me.PnlMain.ResumeLayout(False)
         CType(Me.BoxTasks.Panel, System.ComponentModel.ISupportInitialize).EndInit()
         Me.BoxTasks.Panel.ResumeLayout(False)
         Me.BoxTasks.Panel.PerformLayout()
         CType(Me.BoxTasks, System.ComponentModel.ISupportInitialize).EndInit()
         Me.BoxTasks.ResumeLayout(False)
         Me.ResumeLayout(False)
         Me.PerformLayout()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Scanner.vb" startline="937" endline="1138">
<![CDATA[
 
     Private Function GetNumber() As Token
         Dim Base As IntegerBase
         Dim bReal As Boolean
         Dim bE As Boolean
         Static Builder As New Text.StringBuilder
         Builder.Length = 0
 
         'First find the type of the number
         Select Case CurrentChar()
             Case "."c, "0"c To "9"c 'Decimal
                 Base = IntegerBase.Decimal
             Case "&"c
                 Select Case NextChar()
 #If EXTENDED Then
                     Case "b"c, "B"c 'Binary
                         Base = IntegerBase.Binary
 #End If
                     Case "d"c, "D"c 'Decimal
                         Base = IntegerBase.Decimal
                     Case "h"c, "H"c 'Hex
                         Base = IntegerBase.Hex
                     Case "o"c, "O"c 'Octal
                         Base = IntegerBase.Octal
                     Case Else
                         Throw New InternalException(GetCurrentLocation.ToString(Compiler)) 'Should never get here, this function should only be called with the correct specifiers.
                 End Select
                 NextChar()
             Case Else
                 Throw New InternalException("Invalid character
         End Select
 
         Dim ch As Char = CurrentChar()
         ' Then start the parsing
         Select Case Base
             Case IntegerBase.Decimal
                 While Me.IsNumericCharacter(ch)
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
                 While Me.IsNumericCharacter(ch)
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
                 If ch = "."c Then
                     If Me.IsNumericCharacter(Me.PeekChar) Then
                         Builder.Append(ch)
                         bReal = True
                         ch = NextChar()
                         While Me.IsNumericCharacter(ch)
                             Builder.Append(ch)
                             ch = NextChar()
                         End While
                         While Me.IsNumericCharacter(ch)
                             Builder.Append(ch)
                             ch = NextChar()
                         End While
                     End If
                 End If
                 If ch = "E"c OrElse ch = "e"c Then
                     bE = True
                     bReal = True
                     Builder.Append(ch)
                     ch = NextChar()
                     If ch = "+"c OrElse ch = "-"c Then
                         Builder.Append(ch)
                         ch = NextChar()
                     End If
                     While Me.IsNumericCharacter(ch)
                         Builder.Append(ch)
                         ch = NextChar()
                     End While
                     While Me.IsNumericCharacter(ch)
                         Builder.Append(ch)
                         ch = NextChar()
                     End While
                 End If
 #If EXTENDED Then
             Case IntegerBase.Binary
                 While ((ch >= "0"c) AndAlso (ch <= "1"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
 #End If
             Case IntegerBase.Hex
                 While (((ch >= "0"c) AndAlso (ch <= "9"c)) OrElse _
                   ((ch >= "a"c) AndAlso (ch <= "f"c)) OrElse _
                   ((ch >= "A"c) AndAlso (ch <= "F"c)))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
                 While (((ch >= "0"c) AndAlso (ch <= "9"c)) OrElse _
                   ((ch >= "a"c) AndAlso (ch <= "f"c)) OrElse _
                   ((ch >= "A"c) AndAlso (ch <= "F"c)))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case IntegerBase.Octal
                 While ((ch >= "0"c) AndAlso (ch <= "7"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
                 While ((ch >= "0"c) AndAlso (ch <= "7"c))
                     Builder.Append(ch)
                     ch = NextChar()
                 End While
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
 
         'Find the type character, if any
         Dim strType As String = ""
         Dim typeOfNumber As BuiltInDataTypes
         Dim typeCharacter As LiteralTypeCharacters_Characters = LiteralTypeCharacters_Characters.None
 
         Dim test As String
         test = CurrentChar()
         If test = "U" OrElse test = "u" Then test &= PeekChar()
         typeCharacter = LiteralTypeCharacters.GetTypeCharacter(test)
         If typeCharacter <> LiteralTypeCharacters_Characters.None Then
             NextChar()
             If test.Length = 2 Then NextChar()
             typeOfNumber = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
         End If
 
         If typeCharacter <> LiteralTypeCharacters_Characters.None AndAlso LiteralTypeCharacters.IsIntegral(typeCharacter) = False AndAlso Base <> IntegerBase.Decimal Then
             Compiler.Report.ShowMessage(Messages.VBNC90002, Me.GetCurrentLocation(), KS.Decimal.ToString)
         End If
 
         ' Found the string of the number
         Dim strResult As String = Builder.ToString
         Dim IntegerValue As ULong
 
         Select Case Base
             Case IntegerBase.Decimal
                 Try
                     Dim tp As BuiltInDataTypes
                     If typeCharacter = LiteralTypeCharacters_Characters.None Then
                         If bReal Then
                             tp = BuiltInDataTypes.Double
                         Else
                             tp = BuiltInDataTypes.Integer
                         End If
                     Else
                         tp = LiteralTypeCharacters.GetBuiltInType(typeCharacter)
                     End If
                     Select Case tp
                         Case BuiltInDataTypes.Decimal
                             GetNumber = Token.CreateDecimalToken(GetCurrentLocation, Decimal.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Double
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, Double.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Single
                             GetNumber = Token.CreateSingleToken(GetCurrentLocation, Single.Parse(strResult, Helper.USCulture))
                         Case BuiltInDataTypes.Integer, BuiltInDataTypes.Long, BuiltInDataTypes.Short, BuiltInDataTypes.UInteger, BuiltInDataTypes.ULong, BuiltInDataTypes.UShort
                             If bReal Then
                                 Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                                 IntegerValue = 0
                             Else
                                 'Try to parse the result
                                 IntegerValue = ULong.Parse(strResult, Helper.USCulture)
                             End If
                             'Check if value is out of range for data type.
                             Dim bOutOfRange As Boolean
                             'TODO
                             Select Case tp
                                 Case BuiltInDataTypes.Integer
                                     If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Long
                                     If IntegerValue > Long.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.Short
                                     If IntegerValue > Short.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UInteger
                                     If IntegerValue > UInteger.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.ULong 'Not necessary
                                     '    If IntegerValue > Integer.MaxValue Then bOutOfRange = True
                                 Case BuiltInDataTypes.UShort
                                     If IntegerValue > UShort.MaxValue Then bOutOfRange = True
                                 Case Else
                                     Throw New InternalException("")
                             End Select
                             If bOutOfRange AndAlso typeCharacter <> LiteralTypeCharacters_Characters.None Then
                                 Compiler.Report.ShowMessage(Messages.VBNC30439, GetCurrentLocation(), typeCharacter.ToString)
                             End If
                             GetNumber = GetIntegralToken(ULong.Parse(strResult, Helper.USCulture), Base, typeCharacter)
                         Case Else
                             Compiler.Report.ShowMessage(Messages.VBNC90002, GetCurrentLocation(), typeCharacter.ToString)
                             GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                     End Select
                 Catch ex As System.OverflowException
                     Compiler.Report.ShowMessage(Messages.VBNC30036, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90005, GetCurrentLocation())
                     GetNumber = Token.CreateDoubleToken(GetCurrentLocation, 0)
                 End Try
 #If EXTENDED Then
             Case IntegerBase.Binary
                 Try
                     IntegerValue = Helper.BinToInt(strResult)
                     IntegerValue = ConvertNonDecimalBits(IntegerValue, typeCharacter)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, "binary")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
 #End If
             Case IntegerBase.Hex
                 Try
                     'Console.WriteLine("Hex
                     IntegerValue = Helper.HexToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, Me.GetCurrentLocation, "hexadecimal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case IntegerBase.Octal
                 Try
                     IntegerValue = Helper.OctToInt(strResult)
                 Catch ex As Exception
                     Compiler.Report.ShowMessage(Messages.VBNC90006, GetCurrentLocation(), "octal")
                 End Try
                 GetNumber = GetIntegralToken(IntegerValue, Base, typeCharacter)
             Case Else
                 Throw New InternalException(GetCurrentLocation.ToString(Compiler))
         End Select
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\CMPT890\CS VB JS examples\Examples\VB.NET\examples\MainModule.vb" startline="99" endline="134">
<![CDATA[
 
     Private Shared Sub init()
         exeExts = New ArrayList
         exeExts.Add(".exe")
         exeExts.Add(".bat")
         exeExts.Add(".cmd")
         exeExts.Add(".com")
         exeExts.Add(".lnk")
         exeExts.Add(".config")
         exeExts.Add(".manifest")
         exeExts.Add(".dll")
         exeExts.Add(".pdb")
 
         Dim dirApp As String = Path.GetFullPath(Environment.CurrentDirectory)
         Dim dirInputs As String = Path.Combine(dirApp, MainModule.InputFilesDirectory)
 
         If Not Directory.Exists(dirInputs) Then
             ' If input directory doesn't exist in a current directory,
             ' it may be executed from a project.
             Try
                 Dim dirSrc As String = Path.Combine(Path.GetDirectoryName(Path.GetDirectoryName(dirApp)), MainModule.InputFilesDirectory)
                 If Not Directory.Exists(dirSrc) Then
                     Throw New Exception(dirSrc + " doesn't exist.")
                 End If
                 Directory.CreateDirectory(dirInputs)
                 copyFiles(Directory.GetFiles(dirSrc, "*.*"), dirInputs)
             Catch ex As Exception
                 Directory.Delete(dirInputs, True)
                 Throw ex
             End Try
         End If
 
         deleteNonExecutables(dirApp)
 
         copyFiles(Directory.GetFiles(dirInputs, "*.*"), dirApp)
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="190" endline="333">
<![CDATA[
 
     Private Function ResolveInternal() As Boolean
         Log("There are " & CandidatesLeft & " candidates left.")
 
         m_IsLateBound = False
 
         If ShowErrors AndAlso CandidatesLeft = 0 Then
             Helper.AddError(Me.m_Parent, "No candidates
         End If
 
         RemoveInaccessible()
         Log("After removing inaccessible candidates, there are " & CandidatesLeft & " candidates left.")
         If ShowErrors AndAlso CandidatesLeft = 0 Then
             If m_InitialCandidates.Length = 1 Then
                 Return Compiler.Report.ShowMessage(Messages.VBNC30390, Parent.Location, m_InitialCandidates(0).Member.DeclaringType.Name, m_InitialCandidates(0).Member.Name, Helper.GetMethodAccessibilityString(Helper.GetMethodAttributes(m_InitialCandidates(0).Member)))
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC30517, Parent.Location, m_InitialCandidates(0).Member.Name)
             End If
         End If
 
         'ExpandParamArrays()
         'Log("After expanding paramarrays, there are " & CandidatesLeft & " candidates left.")
         'If ShowErrors AndAlso CandidatesLeft = 0 Then
         '    Throw New InternalException("Expanding paramarrays resulted in fewer candidates
         'End If
 
         InferTypeArguments()
         Log("After inferring type arguments, there are " & CandidatesLeft & " candidates left.")
         If CandidatesLeft = 0 Then
             'Type infer code shows the error message if it's supposed to show errors
             Return False
         End If
 
         'Remove inapplicable candidates
         RemoveInapplicable_ParameterCount()
         Log("After removing inapplicable pc candidates, there are " & CandidatesLeft & " candidates left.")
         If CandidatesLeft = 0 Then
             If ShowErrors Then
                 If m_InitialCandidates.Length = 1 Then
                     If m_InitialCandidates(0).InputParameters.Count < m_InitialCandidates(0).Arguments.Count Then
                         Compiler.Report.ShowMessage(Messages.VBNC30057, m_Parent.Location, Helper.ToString(Compiler, m_InitialCandidates(0).Member))
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30455, m_Parent.Location, m_InitialCandidates(0).InputParameters(m_InitialCandidates(0).Arguments.Count).Name, Helper.ToString(Compiler, m_InitialCandidates(0).Member))
                     End If
                 Else
                     Compiler.Report.ShowMessage(Messages.VBNC30516, m_Parent.Location, m_Name)
                 End If
             End If
             Return False
         End If
 
         RemoveInapplicable(Nothing)
         Log("After removing inapplicable candidates, there are " & CandidatesLeft & " candidates left.")
         If CandidatesLeft = 1 Then
             Return True
         ElseIf CandidatesLeft = 0 Then
             If ShowErrors Then
                 Dim lines As New Generic.List(Of String)
                 RemoveInapplicable(lines)
                 If lines.Count > 0 Then
                     'If there are no lines, an error has been shown already
                     Compiler.Report.ShowMessage(Messages.VBNC30518, m_Parent.Location, Helper.GetMemberName(m_InitialCandidates(0).Member), Environment.NewLine & "    " & String.Join(Environment.NewLine & "    ", lines.ToArray()))
                 End If
             End If
             Return False
         End If
 
         RemoveNarrowingExceptObject(Nothing)
         Log("After removing narrowing (except object) candidates, there are " & CandidatesLeft & " candidates left.")
         If CandidatesLeft = 1 Then
             Return True
         ElseIf CandidatesLeft = 0 Then
             If Parent.Location.File(Compiler).IsOptionStrictOn = False AndAlso m_CanBeLateBound Then
                 m_IsLateBound = True
                 Return True
             End If
             If ShowErrors Then
                 Dim lines As New Generic.List(Of String)
                 RemoveNarrowingExceptObject(lines)
                 Compiler.Report.ShowMessage(Messages.VBNC30519, m_Parent.Location, m_InitialCandidates(0).Member.Name, Environment.NewLine & "    " & String.Join(Environment.NewLine & "    ", lines.ToArray()))
             End If
             Return False
         End If
 
         If CandidatesLeft <= 1 Then Return CandidatesLeft = 1
 
         RemoveNarrowing()
         Log("After removing narrowing candidates, there are " & CandidatesLeft & " candidates left.")
         If CandidatesLeft = 1 Then
             Return True
         ElseIf CandidatesLeft = 0 Then
             If Parent.Location.File(Compiler).IsOptionStrictOn = False AndAlso m_CanBeLateBound Then
                 m_IsLateBound = True
                 Return True
             End If
         End If
 
         If ShowErrors AndAlso CandidatesLeft = 0 Then
             Helper.AddError(Me.m_Parent, "No non-narrowing
         End If
 
         SelectMostApplicable()
         Log("After selecting the most applicable candidates, there are " & CandidatesLeft & " candidates left.")
         If ShowErrors AndAlso CandidatesLeft = 0 Then
             Helper.AddError(Me.m_Parent, "No most applicable
         End If
 
         If CandidatesLeft = 1 Then
             Return True
         End If
 
         SelectUsingTieBreak()
         Log("After tie break, there are " & CandidatesLeft & " candidates left.")
         If ShowErrors AndAlso CandidatesLeft = 0 Then
             Helper.AddError(Me.m_Parent, "Tie break failed")
         End If
 
         SelectLessGeneric()
         Log("After selecting the less generic candidates, there are " & CandidatesLeft & " candidates left.")
         If CandidatesLeft = 1 Then
             Return True
         End If
 
         RemoveInvalid()
 
         If ShowErrors AndAlso CandidatesLeft <> 1 Then
             If CandidatesLeft > 1 Then
                 Helper.AddError(Me.m_Parent, String.Format("After selecting the less generic method for method '{0}', there are still {1} candidates left", Me.m_InitialCandidates(0).Member.Name, CandidatesLeft))
                 Helper.AddError(Me.m_Parent, String.Format("Tried to select using invocation list
                 Dim reported As Integer = 0
                 For i As Integer = 0 To m_Candidates.Count - 1
                     If m_Candidates(i) Is Nothing OrElse m_Candidates(i).RemovedBy IsNot Nothing Then Continue For
 
                     reported += 1
                     Dim mi As Mono.Cecil.MemberReference = m_InitialCandidates(i).Member
                     Helper.AddError(Me.m_Parent, String.Format("Candidate #{0}
                 Next
             Else
                 Helper.AddError(Me.m_Parent, String.Format("After selecting the less generic method for method '{0}', nothing was found", Me.m_InitialCandidates(0).Member.Name))
             End If
         End If
 
         Return CandidatesLeft = 1
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Statements\UsingDeclaration.vb" startline="651" endline="914">
<![CDATA[
 
     Sub SetFileVersion()
         Dim product As String = String.Empty
         Dim productversion As String = String.Empty
         Dim company As String = String.Empty
         Dim copyright As String = String.Empty
         Dim trademark As String = String.Empty
 
         Dim att As Mono.Collections.Generic.Collection(Of CustomAttribute)
         Dim custom_attributes As Mono.Collections.Generic.Collection(Of CustomAttribute) = Me.Compiler.AssemblyBuilderCecil.CustomAttributes
 
         att = CecilHelper.GetCustomAttributes(custom_attributes, Compiler.TypeCache.System_Reflection_AssemblyProductAttribute)
         If att IsNot Nothing AndAlso att.Count > 0 Then product = CecilHelper.GetAttributeCtorString(att(0), 0)
         att = CecilHelper.GetCustomAttributes(custom_attributes, Compiler.TypeCache.System_Reflection_AssemblyVersionAttribute)
         If att IsNot Nothing AndAlso att.Count > 0 Then productversion = CecilHelper.GetAttributeCtorString(att(0), 0)
         att = CecilHelper.GetCustomAttributes(custom_attributes, Compiler.TypeCache.System_Reflection_AssemblyCompanyAttribute)
         If att IsNot Nothing AndAlso att.Count > 0 Then company = CecilHelper.GetAttributeCtorString(att(0), 0)
         att = CecilHelper.GetCustomAttributes(custom_attributes, Compiler.TypeCache.System_Reflection_AssemblyCopyrightAttribute)
         If att IsNot Nothing AndAlso att.Count > 0 Then copyright = CecilHelper.GetAttributeCtorString(att(0), 0)
         att = CecilHelper.GetCustomAttributes(custom_attributes, Compiler.TypeCache.System_Reflection_AssemblyTrademarkAttribute)
         If att IsNot Nothing AndAlso att.Count > 0 Then trademark = CecilHelper.GetAttributeCtorString(att(0), 0)
 
         'Dim rdt As New Mono.Cecil.PE.ResourceDirectoryTable()
         'Dim r1 As New Mono.Cecil.PE.ResourceDirectoryEntry(16)
         'Dim r2 As New Mono.Cecil.PE.ResourceDirectoryEntry(1)
         'Dim r3 As New Mono.Cecil.PE.ResourceDirectoryEntry(0)
         'Dim data As New Mono.Cecil.PE.ResourceDataEntry()
 
         'Dim rsrc As Mono.Cecil.PE.Section = Nothing
         'If Compiler.AssemblyBuilderCecil.MainModule.Image Is Nothing Then
         '    Compiler.AssemblyBuilderCecil.MainModule.Image = New Mono.Cecil.PE.Image()
         '    Compiler.AssemblyBuilderCecil.MainModule.Image.Sections = New Mono.Cecil.PE.Section() {}
         'End If
         'rsrc = Compiler.AssemblyBuilderCecil.MainModule.Image.GetSection(".rsrc")
         'If rsrc Is Nothing Then
         '    rsrc = New Mono.Cecil.PE.Section()
         '    rsrc.Name = ".rsrc"
         '    Dim sections(Me.Compiler.AssemblyBuilderCecil.MainModule.Image.Sections.Length) As Mono.Cecil.PE.Section
         '    For i As Integer = 0 To sections.Length - 2
         '        sections(i) = Compiler.AssemblyBuilderCecil.MainModule.Image.Sections(i)
         '    Next
         '    sections(sections.Length - 1) = rsrc
         '    Me.Compiler.AssemblyBuilderCecil.MainModule.Image.Sections = sections
         'End If
         'Me.Compiler.AssemblyBuilderCecil.MainModule.Image.ResourceDirectoryRoot = New Mono.Cecil.PE.ResourceDirectoryTable()
 
         'Me.Compiler.AssemblyBuilderCecil.MainModule.Image.ResourceDirectoryRoot.Entries.Add(r1)
         'rdt = New Mono.Cecil.Binary.ResourceDirectoryTable()
         'rdt.Entries.Add(r2)
         'r1.Child = rdt
 
         'rdt = New Mono.Cecil.Binary.ResourceDirectoryTable()
         'rdt.Entries.Add(r3)
         'r2.Child = rdt
 
         'r3.Child = data
         'data.Size = 0
         'data.ResourceData = New Byte() {}
 
         Dim win32versionresources As Byte()
         Using ms As New IO.MemoryStream()
             Using w As New IO.BinaryWriter(ms, System.Text.Encoding.Unicode)
                 Dim file_flags_mask As Integer = 63
                 Dim file_flags As Integer = 0
                 Dim file_os As Integer = 4 '/* VOS_WIN32 */
                 Dim file_type As Integer = 2
                 Dim file_subtype As Integer = 0
                 Dim file_date As Long = 0
                 Dim file_lang As Integer = 0
                 Dim file_codepage As Integer = 1200
                 Dim properties As New Generic.Dictionary(Of String, String)
 
                 Dim file_version As Long
                 Dim product_version As Long
 
                 Dim WellKnownProperties As String() = New String() {"Assembly Version", "FileDescription", "FileVersion", "InternalName", "OriginalFilename", "ProductVersion"}
 
                 For i As Integer = 0 To WellKnownProperties.Length - 1
                     properties.Add(WellKnownProperties(i), WellKnownProperties(i) & " ")
                 Next
 
                 If product <> String.Empty Then properties("ProductName") = product
                 If productversion <> String.Empty Then
                     properties("ProductVersion") = productversion
                     properties("FileVersion") = productversion
                 End If
                 If company <> String.Empty Then properties("Company") = company
                 If copyright <> String.Empty Then properties("LegalCopyright") = copyright
                 If trademark <> String.Empty Then properties("LegalTrademark") = trademark
 
                 'VS_VERSIONINFO
                 w.Write(CShort(0))
                 w.Write(CShort(&H34))
                 w.Write(CShort(0))
                 w.Write("VS_VERSION_INFO".ToCharArray())
                 w.Write(CShort(0))
                 emit_padding(w)
 
                 '// VS_FIXEDFILEINFO
                 w.Write(&HFEEF04BDUI)
                 w.Write(CInt(1 << 16))
                 w.Write(CInt(file_version >> 32)) 'TODO
                 w.Write(CInt(((file_version And &HFFFFFFFF)))) 'TODO
 
                 w.Write(CInt(product_version >> 32))
                 w.Write(CInt(product_version And &HFFFFFFFF))
                 w.Write(CInt(file_flags_mask))
                 w.Write(CInt(file_flags))
                 w.Write(CInt(file_os))
                 w.Write(CInt(file_type))
                 w.Write(CInt(file_subtype))
                 w.Write(CInt((file_date >> 32)))
                 w.Write(CInt((file_date And &HFFFFFFFF)))
 
                 emit_padding(w)
 
                 '// VarFileInfo
                 Dim var_file_info_pos As Long = ms.Position
                 w.Write(CShort(0))
                 w.Write(CShort(0))
                 w.Write(CShort(1))
                 w.Write("VarFileInfo".ToCharArray())
                 w.Write(CShort(0))
 
                 If ((ms.Position Mod 4) <> 0) Then
                     w.Write(CShort(0))
                 End If
 
                 '// Var
                 Dim var_pos As Long = ms.Position
                 w.Write(CShort(0))
                 w.Write(CShort(4))
                 w.Write(CShort(0))
                 w.Write("Translation".ToCharArray())
                 w.Write(CShort(0))
 
                 If ((ms.Position Mod 4) <> 0) Then
                     w.Write(CShort(0))
                 End If
 
                 w.Write(CShort(file_lang))
                 w.Write(CShort(file_codepage))
 
                 patch_length(w, var_pos)
 
                 patch_length(w, var_file_info_pos)
 
                 '// StringFileInfo
                 Dim string_file_info_pos As Long = ms.Position
                 w.Write(CShort(0))
                 w.Write(CShort(0))
                 w.Write(CShort(1))
                 w.Write("StringFileInfo".ToCharArray())
 
                 emit_padding(w)
 
                 '// StringTable
                 Dim string_table_pos As Long = ms.Position
                 w.Write(CShort(0))
                 w.Write(CShort(0))
                 w.Write(CShort(1))
                 w.Write(String.Format("{0
 
                 emit_padding(w)
 
                 '// Strings
                 For Each key As String In properties.Keys
                     Dim value As String = properties(key)
 
                     Dim string_pos As Long = ms.Position
                     w.Write(CShort(0))
                     w.Write(CShort((value.ToCharArray().Length + 1)))
                     w.Write(CShort(1))
                     w.Write(key.ToCharArray())
                     w.Write(CShort(0))
 
                     emit_padding(w)
 
                     w.Write(value.ToCharArray())
                     w.Write(CShort(0))
 
                     emit_padding(w)
 
                     patch_length(w, string_pos)
                 Next
 
                 patch_length(w, string_table_pos)
 
                 patch_length(w, string_file_info_pos)
 
                 patch_length(w, 0)
                 win32versionresources = ms.ToArray()
             End Using
         End Using
 
 
         Using ms As New IO.MemoryStream()
             Using w As New IO.BinaryWriter(ms, System.Text.Encoding.Unicode)
                 ' IMAGE_RESOURCE_DIRECTORY
                 w.Write(0UI) 'characteristics
                 w.Write(0UI) 'timedatestamp
                 w.Write(0US) 'majorversion
                 w.Write(0US) 'minorversion
                 w.Write(0US) 'NumberOfNamedEntries
                 w.Write(1US) 'NumberOfIdEntries
 
                 '16 bytes
 
                 ' IMAGE_RESOURCE_DIRECTORY_ENTRY
                 w.Write(16UI) 'name
                 w.Write(&H20UI + &H80000000UI) 'dataoffset
                 w.Write(0UI) 'codepage
                 w.Write(0UI) 'reserved
 
                 ' 16 bytes, total 32 bytes
 
                 ' IMAGE_RESOURCE_DIRECTORY
                 w.Write(0UI) 'characteristics
                 w.Write(0UI) 'timedatestamp
                 w.Write(0US) 'majorversion
                 w.Write(0US) 'minorversion
                 w.Write(0US) 'NumberOfNamedEntries
                 w.Write(1US) 'NumberOfIdEntries
 
                 ' 16 bytes, total 48 bytes
 
                 ' IMAGE_RESOURCE_DIRECTORY_ENTRY
                 w.Write(1UI) 'name
                 w.Write(&H40UI + &H80000000UI) 'dataoffset
                 w.Write(0UI) 'codepage
                 w.Write(0UI) 'reserved
 
                 ' 16 bytes, total 64 bytes
 
                 ' IMAGE_RESOURCE_DIRECTORY
                 w.Write(0UI) 'characteristics
                 w.Write(0UI) 'timedatestamp
                 w.Write(0US) 'majorversion
                 w.Write(0US) 'minorversion
                 w.Write(0US) 'NumberOfNamedEntries
                 w.Write(1US) 'NumberOfIdEntries
 
                 ' 16 bytes, total 80 bytes
 
                 ' IMAGE_RESOURCE_DIRECTORY_ENTRY
                 w.Write(0UI) 'name
                 w.Write(&H60UI) 'dataoffset
                 w.Write(0UI) 'codepage
                 w.Write(0UI) 'reserved
 
                 ' 16 bytes, total 96 bytes
 
                 ' IMAGE_RESOURCE_DATA_ENTRY
                 w.Write(&H70UI) 'offsettodata
                 w.Write(CUInt(win32versionresources.Length)) 'size
                 w.Write(0UI) 'codepage
                 w.Write(0UI) 'reserved
 
                 w.Write(win32versionresources)
 
                 Compiler.ModuleBuilderCecil.Win32Resources = ms.ToArray()
             End Using
         End Using
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\SimpleNameExpression.vb" startline="180" endline="559">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim Name As String = m_Identifier.Identifier
 
         '---------------------------------------------------------------------------------------------------------
         'A simple name expression consists of a single identifier followed by an optional type argument list. 
         'The name is resolved and classified as follows
         '---------------------------------------------------------------------------------------------------------
         '* Starting with the immediately enclosing block and continuing with each enclosing outer block (if any),
         '  if the identifier matches the name of a local variable, static variable, constant local, method type 
         '  parameter, or parameter, then the identifier refers to the matching entity. The expression is 
         '  classified as a variable if it is a local variable, static variable, or parameter. The expression 
         '  is classified as a type if it is a method type parameter. The expression is classified as a value 
         '  if it is a constant local with the following exception. If the local variable matched is the 
         '  implicit function or Get accessor return local variable, and the expression is part of an 
         '  invocation expression, invocation statement, or an AddressOf expression, then no match occurs and 
         '  resolution continues.
         '---------------------------------------------------------------------------------------------------------
         '* For each nested type containing the expression, starting from the innermost and going to the 
         '  outermost, if a lookup of the identifier in the type produces a match with an accessible member
         '** If the matching type member is a type parameter, then the result is classified as a type and 
         '   is the matching type parameter.
         '** Otherwise, if the type is the immediately enclosing type and the lookup identifies a non-shared 
         '   type member, then the result is the same as a member access of the form Me.E, where E is 
         '   the identifier.
         '** Otherwise, the result is exactly the same as a member access of the form T.E, where T is the 
         '   type containing the matching member and E is the identifier. In this case, it is an error for the 
         '   identifier to refer to a non-shared member.
         '---------------------------------------------------------------------------------------------------------
         '* For each nested namespace, starting from the innermost and going to the outermost namespace, 
         '  do the following
         '** If the namespace contains an accessible namespace member with the given name, then the identifier
         '   refers to that member and, depending on the member, is classified as a namespace or a type.
         '** Otherwise, if the namespace contains one or more accessible standard modules, and a member name 
         '   lookup of the identifier produces an accessible match in exactly one standard module, then the 
         '   result is exactly the same as a member access of the form M.E, where M is the standard module 
         '   containing the matching member and E is the identifier. If the identifier matches accessible type 
         '   members in more than one standard module, a compile-time error occurs.
         '---------------------------------------------------------------------------------------------------------
         '* If the source file has one or more import aliases, and the identifier matches the name of one of them,
         '   then the identifier refers to that namespace or type.
         '---------------------------------------------------------------------------------------------------------
         '* If the source file containing the name reference has one or more imports
         '** If the identifier matches the name of an accessible type or type member in exactly one import, 
         '   then the identifier refers to that type or type member. If the identifier matches the name of 
         '   an accessible type or type member in more than one import, a compile-time error occurs.
         '** If the identifier matches the name of a namespace in exactly one import, then the identifier 
         '   refers to that namespace. If the identifier matches the name of a namespace in more than one import, 
         '   a compile-time error occurs.
         '** Otherwise, if the imports contain one or more accessible standard modules, and a member name 
         '   lookup of the identifier produces an accessible match in exactly one standard module, then 
         '   the result is exactly the same as a member access of the form M.E, where M is the standard 
         '   module containing the matching member and E is the identifier. If the identifier matches 
         '   accessible type members in more than one standard module, a compile-time error occurs.
         '---------------------------------------------------------------------------------------------------------
         '* If the compilation environment defines one or more import aliases, and the identifier matches 
         '  the name of one of them, then the identifier refers to that namespace or type.
         '---------------------------------------------------------------------------------------------------------
         '* If the compilation environment defines one or more imports
         '** If the identifier matches the name of an accessible type or type member in exactly one import, 
         '   then the identifier refers to that type or type member. If the identifier matches the name 
         '   of an accessible type or type member in more than one import, a compile-time error occurs.
         '** If the identifier matches the name of a namespace in exactly one import, then the identifier 
         '   refers to that namespace. If the identifier matches the name of a namespace in more than 
         '   one import, a compile-time error occurs.
         '** Otherwise, if the imports contain one or more accessible standard modules, and a member name 
         '   lookup of the identifier produces an accessible match in exactly one standard module, then the result 
         '   is exactly the same as a member access of the form M.E, where M is the standard module containing 
         '   the matching member and E is the identifier. If the identifier matches accessible type members in 
         '   more than one standard module, a compile-time error occurs.
         '---------------------------------------------------------------------------------------------------------
         '* Otherwise, the name given by the identifier is undefined and a compile-time error occurs.
         '---------------------------------------------------------------------------------------------------------
         'If a simple name with a type argument list resolves to anything other than a type or method, 
         'a compile time error occurs. If a type argument list is supplied, only types with the same arity as 
         'the type argument list are considered but type members, including methods with different arities, 
         'are still considered. This is because type inference can be used to fill in missing type arguments. 
         'As a result, names with type arguments may bind differently to types and methods
         '---------------------------------------------------------------------------------------------------------
 
         If m_TypeArgumentList IsNot Nothing Then If m_TypeArgumentList.ResolveCode(Info) = False Then Return False
 
         '* Starting with the immediately enclosing block and continuing with each enclosing outer block (if any),
         '  if the identifier matches the name of a local variable, static variable, constant local, method type 
         '  parameter, or parameter, then the identifier refers to the matching entity. 
         '  - The expression is classified as a variable if it is a local variable, static variable, or parameter.
         '  - The expression is classified as a type if it is a method type parameter. 
         '  - The expression is classified as a value if it is a constant local.
         '  * With the following exception
         '  If the local variable matched is the implicit function or Get accessor return local variable, 
         '  and the expression is part of an  invocation expression, invocation statement, 
         '  or an AddressOf expression, then no match occurs and resolution continues.
         Dim block As CodeBlock = Me.FindFirstParent(Of CodeBlock)()
         While block IsNot Nothing
             Dim var As IAttributableNamedDeclaration
             var = block.FindVariable(Name)
             If TypeOf var Is ConstantDeclaration Then
                 'The expression is classified as a value if it is a constant local (...)
                 Classification = New ValueClassification(Me, DirectCast(var, ConstantDeclaration))
                 Return True
             ElseIf TypeOf var Is VariableDeclaration Then
                 'The expression is classified as a variable if it is a local variable, static variable (...)
                 Dim varDecl As VariableDeclaration
                 varDecl = DirectCast(var, VariableDeclaration)
                 If varDecl.Modifiers.Is(ModifierMasks.Static) AndAlso varDecl.DeclaringMethod.IsShared = False Then
                     Classification = New VariableClassification(Me, varDecl, CreateMeExpression)
                 ElseIf varDecl.Modifiers.Is(ModifierMasks.Const) Then
                     Classification = New ValueClassification(Me, varDecl)
                 Else
                     Classification = New VariableClassification(Me, varDecl)
                 End If
                 Return True
             ElseIf var IsNot Nothing Then
                 Throw New InternalException(Me)
             End If
             block = block.FindFirstParent(Of CodeBlock)()
         End While
         While block IsNot Nothing
             Dim var As IAttributableNamedDeclaration
             var = block.FindVariable(Name)
             If TypeOf var Is ConstantDeclaration Then
                 'The expression is classified as a value if it is a constant local (...)
                 Classification = New ValueClassification(Me, DirectCast(var, ConstantDeclaration))
                 Return True
             ElseIf TypeOf var Is VariableDeclaration Then
                 'The expression is classified as a variable if it is a local variable, static variable (...)
                 Dim varDecl As VariableDeclaration
                 varDecl = DirectCast(var, VariableDeclaration)
                 If varDecl.Modifiers.Is(ModifierMasks.Static) AndAlso varDecl.DeclaringMethod.IsShared = False Then
                     Classification = New VariableClassification(Me, varDecl, CreateMeExpression)
                 ElseIf varDecl.Modifiers.Is(ModifierMasks.Const) Then
                     Classification = New ValueClassification(Me, varDecl)
                 Else
                     Classification = New VariableClassification(Me, varDecl)
                 End If
                 Return True
             ElseIf var IsNot Nothing Then
                 Throw New InternalException(Me)
             End If
             block = block.FindFirstParent(Of CodeBlock)()
         End While
 
         Dim method As IMethod
         method = Me.FindFirstParent(Of IMethod)()
         If method IsNot Nothing Then
             If method.Signature.TypeParameters IsNot Nothing Then
                 Dim typeparam As TypeParameter = method.Signature.TypeParameters.Parameters.Item(Name)
                 If typeparam IsNot Nothing Then
                     'The expression is classified as a type if it is a method type parameter. 
                     Classification = New TypeClassification(Me, typeparam)
                     Return True
                 End If
             End If
         End If
 
         If method IsNot Nothing Then
             If method.Signature.Parameters IsNot Nothing Then
                 Dim param As Parameter = method.Signature.Parameters.Item(Name)
                 If param IsNot Nothing Then
                     'The expression is classified as a variable if it is a (...) parameter
                     Classification = New VariableClassification(Me, param)
                     Return True
                 End If
             End If
         End If
 
         '  If the local variable matched is the implicit function or Get accessor return local variable, 
         '  and the expression is part of an  invocation expression, invocation statement, 
         '  or an AddressOf expression, then no match occurs and resolution continues.
         If method IsNot Nothing Then
             If method.HasReturnValue AndAlso Info.SkipFunctionReturnVariable = False Then
                 Dim pgd As PropertyGetDeclaration = TryCast(method, PropertyGetDeclaration)
                 If pgd IsNot Nothing AndAlso Helper.CompareName(pgd.PropertySignature.Name, Name) Then
                     'The expression is classified as a variable if it is a local variable, static variable (...)
                     Classification = New VariableClassification(Me, method)
                     Return True
                 ElseIf Helper.CompareName(method.Name, Name) Then
                     'The expression is classified as a variable if it is a local variable, static variable (...)
                     Classification = New VariableClassification(Me, method)
                     Return True
                 End If
             End If
         End If
 
         '* For each nested type containing the expression, starting from the innermost and going to the 
         '  outermost, if a lookup of the identifier in the type produces a match with an accessible member
         '** If the matching type member is a type parameter, then the result is classified as a type and 
         '   is the matching type parameter.
         '** Otherwise, if the type is the immediately enclosing type and the lookup identifies a non-shared 
         '   type member, then the result is the same as a member access of the form Me.E, where E is 
         '   the identifier.
         '** Otherwise, the result is exactly the same as a member access of the form T.E, where T is the 
         '   type containing the matching member and E is the identifier. In this case, it is an error for the 
         '   identifier to refer to a non-shared member.
         Dim firstcontainer As IType = Me.FindFirstParent(Of IType)()
         Dim container As IType = firstcontainer
         While container IsNot Nothing
             Dim constructable As IConstructable = TryCast(container, IConstructable)
             If constructable IsNot Nothing AndAlso constructable.TypeParameters IsNot Nothing Then
                 Dim typeparam As TypeParameter = constructable.TypeParameters.Parameters.Item(Name)
                 If typeparam IsNot Nothing Then
                     'If the matching type member is a type parameter, then the result is classified 
                     'as a type and is the matching type parameter.
                     Classification = New TypeClassification(Me, typeparam)
                     Return True
                 End If
             End If
 
             Dim cache As MemberCacheEntry
             Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
             cache = Compiler.TypeManager.GetCache(container.CecilType).LookupFlattened(Name)
             If cache Is Nothing Then
                 members = New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
             Else
                 members = cache.Members
                 members = Helper.FilterExternalInaccessible(Compiler, members)
             End If
 
 #If EXTENDEDDEBUG Then
             Compiler.Report.WriteLine("Found " & membersArray.Length & " members, after filtering by name it's " & members.Count & " members")
 #End If
 
             Helper.ApplyTypeArguments(Me, members, m_TypeArgumentList)
 
             If members.Count > 0 Then
                 'Otherwise, if the type is the immediately enclosing type and the lookup identifies a non-shared 
                 'type member, then the result is the same as a member access of the form Me.E, where E is 
                 'the identifier.
 
                 'Otherwise, the result is exactly the same as a member access of the form T.E, where T is the 
                 'type containing the matching member and E is the identifier. In this case, it is an error for the 
                 'identifier to refer to a non-shared member.
 
                 'NOTE
                 '(it can resolve to a method group with several methods, some shared, some not. 
                 'So we create a classification with an instance expression, if the member is 
                 'shared, the instance expression should not be used.
                 Dim instanceCount As Integer
 
                 For i As Integer = 0 To members.Count - 1
                     Dim member As Mono.Cecil.MemberReference = members(i)
                     If CecilHelper.GetMemberType(member) = MemberTypes.TypeInfo OrElse CecilHelper.GetMemberType(member) = MemberTypes.NestedType Then
                         '
                     ElseIf Helper.IsShared(member) Then
                         '
                     Else
                         instanceCount += 1
                     End If
                 Next
 
                 If container Is firstcontainer AndAlso instanceCount > 0 Then
                     'Otherwise, if the type is the immediately enclosing type and the lookup identifies a non-shared 
                     'type member, then the result is the same as a member access of the form Me.E, where E is 
                     'the identifier.
                     If instanceCount = members.Count AndAlso IsSharedContext() Then
                         Dim show30369 As Boolean = True
 
                         If instanceCount = 1 Then
                             Dim fd As FieldReference
                             Dim pd As PropertyReference
 
                             'this is allowed
                             fd = TryCast(members(0), FieldReference)
                             If fd IsNot Nothing Then
                                 show30369 = Helper.CompareName(fd.Name, fd.FieldType.Name) = False
                             Else
                                 pd = TryCast(members(0), PropertyReference)
                                 If pd IsNot Nothing Then
                                     show30369 = Helper.CompareName(pd.Name, pd.PropertyType.Name) = False
                                 End If
                             End If
                             If show30369 Then Return Report.ShowMessage(Messages.VBNC30369, Me.Location)
                         End If
                     End If
                     Classification = GetMeClassification(members, firstcontainer)
                     Return True
                 Else
                     'Otherwise, the result is exactly the same as a member access of the form T.E, where T is the 
                     'type containing the matching member and E is the identifier. In this case, it is an error for the                    
                     'identifier to refer to a non-shared member.
                     Classification = GetTypeClassification(members, firstcontainer)
                     Return True
                 End If
             End If
             container = DirectCast(container, BaseObject).FindFirstParent(Of IType)()
         End While
         While container IsNot Nothing
             Dim constructable As IConstructable = TryCast(container, IConstructable)
             If constructable IsNot Nothing AndAlso constructable.TypeParameters IsNot Nothing Then
                 Dim typeparam As TypeParameter = constructable.TypeParameters.Parameters.Item(Name)
                 If typeparam IsNot Nothing Then
                     'If the matching type member is a type parameter, then the result is classified 
                     'as a type and is the matching type parameter.
                     Classification = New TypeClassification(Me, typeparam)
                     Return True
                 End If
             End If
 
             Dim cache As MemberCacheEntry
             Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
             cache = Compiler.TypeManager.GetCache(container.CecilType).LookupFlattened(Name)
             If cache Is Nothing Then
                 members = New Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
             Else
                 members = cache.Members
                 members = Helper.FilterExternalInaccessible(Compiler, members)
             End If
 
 #If EXTENDEDDEBUG Then
             Compiler.Report.WriteLine("Found " & membersArray.Length & " members, after filtering by name it's " & members.Count & " members")
 #End If
 
             Helper.ApplyTypeArguments(Me, members, m_TypeArgumentList)
 
             If members.Count > 0 Then
                 'Otherwise, if the type is the immediately enclosing type and the lookup identifies a non-shared 
                 'type member, then the result is the same as a member access of the form Me.E, where E is 
                 'the identifier.
 
                 'Otherwise, the result is exactly the same as a member access of the form T.E, where T is the 
                 'type containing the matching member and E is the identifier. In this case, it is an error for the 
                 'identifier to refer to a non-shared member.
 
                 'NOTE
                 '(it can resolve to a method group with several methods, some shared, some not. 
                 'So we create a classification with an instance expression, if the member is 
                 'shared, the instance expression should not be used.
                 Dim instanceCount As Integer
 
                 For i As Integer = 0 To members.Count - 1
                     Dim member As Mono.Cecil.MemberReference = members(i)
                     If CecilHelper.GetMemberType(member) = MemberTypes.TypeInfo OrElse CecilHelper.GetMemberType(member) = MemberTypes.NestedType Then
                         '
                     ElseIf Helper.IsShared(member) Then
                         '
                     Else
                         instanceCount += 1
                     End If
                 Next
 
                 If container Is firstcontainer AndAlso instanceCount > 0 Then
                     'Otherwise, if the type is the immediately enclosing type and the lookup identifies a non-shared 
                     'type member, then the result is the same as a member access of the form Me.E, where E is 
                     'the identifier.
                     If instanceCount = members.Count AndAlso IsSharedContext() Then
                         Dim show30369 As Boolean = True
 
                         If instanceCount = 1 Then
                             Dim fd As FieldReference
                             Dim pd As PropertyReference
 
                             'this is allowed
                             fd = TryCast(members(0), FieldReference)
                             If fd IsNot Nothing Then
                                 show30369 = Helper.CompareName(fd.Name, fd.FieldType.Name) = False
                             Else
                                 pd = TryCast(members(0), PropertyReference)
                                 If pd IsNot Nothing Then
                                     show30369 = Helper.CompareName(pd.Name, pd.PropertyType.Name) = False
                                 End If
                             End If
                             If show30369 Then Return Report.ShowMessage(Messages.VBNC30369, Me.Location)
                         End If
                     End If
                     Classification = GetMeClassification(members, firstcontainer)
                     Return True
                 Else
                     'Otherwise, the result is exactly the same as a member access of the form T.E, where T is the 
                     'type containing the matching member and E is the identifier. In this case, it is an error for the                    
                     'identifier to refer to a non-shared member.
                     Classification = GetTypeClassification(members, firstcontainer)
                     Return True
                 End If
             End If
             container = DirectCast(container, BaseObject).FindFirstParent(Of IType)()
         End While
 
         '* For each nested namespace, starting from the innermost and going to the outermost namespace, 
         '  do the following
         '** If the namespace contains an accessible namespace member with the given name, then the identifier
         '   refers to that member and, depending on the member, is classified as a namespace or a type.
         '** Otherwise, if the namespace contains one or more accessible standard modules, and a member name 
         '   lookup of the identifier produces an accessible match in exactly one standard module, then the 
         '   result is exactly the same as a member access of the form M.E, where M is the standard module 
         '   containing the matching member and E is the identifier. If the identifier matches accessible type 
         '   members in more than one standard module, a compile-time error occurs.
         Dim currentNS As String = Nothing
         If firstcontainer IsNot Nothing Then currentNS = firstcontainer.Namespace
         While currentNS IsNot Nothing
             Dim foundType As Mono.Cecil.TypeReference
             foundType = Compiler.TypeManager.GetTypesByNamespace(currentNS).Item(Name)
             If foundType IsNot Nothing Then
                 Classification = New TypeClassification(Me, foundType)
                 Return True
             End If
             If currentNS <> "" Then
                 Dim foundNS As [Namespace]
                 foundNS = Compiler.TypeManager.Namespaces(currentNS & "." & Name)
                 If foundNS IsNot Nothing Then
                     Classification = New NamespaceClassification(Me, foundNS)
                     Return True
                 End If
             End If
 
             'Otherwise, if the namespace contains one or more accessible standard modules, and a member name 
             'lookup of the identifier produces an accessible match in exactly one standard module, then the 
             'result is exactly the same as a member access of the form M.E, where M is the standard module 
             'containing the matching member and E is the identifier. If the identifier matches accessible type 
             'members in more than one standard module, a compile-time error occurs.
             Dim modulemembers As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
             modulemembers = Helper.GetMembersOfTypes(Compiler, Compiler.TypeManager.GetModulesByNamespace(currentNS), Name)
             If modulemembers Is Nothing Then
                 'do nothing
             ElseIf modulemembers.Count >= 1 Then
                 'Check that they're all from the same module
                 For i As Integer = 1 To modulemembers.Count - 1
                     If Helper.CompareType(modulemembers(0).DeclaringType, modulemembers(i).DeclaringType) = False Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC30562, Me.Location, Name, modulemembers(0).DeclaringType.Name, modulemembers(i).DeclaringType.Name)
                     End If
                 Next
                 Return SetClassificationOfModuleMembers(modulemembers)
             End If
 
             currentNS = Helper.GetNamespaceParent(currentNS)
         End While
         While currentNS IsNot Nothing
             Dim foundType As Mono.Cecil.TypeReference
             foundType = Compiler.TypeManager.GetTypesByNamespace(currentNS).Item(Name)
             If foundType IsNot Nothing Then
                 Classification = New TypeClassification(Me, foundType)
                 Return True
             End If
             If currentNS <> "" Then
                 Dim foundNS As [Namespace]
                 foundNS = Compiler.TypeManager.Namespaces(currentNS & "." & Name)
                 If foundNS IsNot Nothing Then
                     Classification = New NamespaceClassification(Me, foundNS)
                     Return True
                 End If
             End If
 
             'Otherwise, if the namespace contains one or more accessible standard modules, and a member name 
             'lookup of the identifier produces an accessible match in exactly one standard module, then the 
             'result is exactly the same as a member access of the form M.E, where M is the standard module 
             'containing the matching member and E is the identifier. If the identifier matches accessible type 
             'members in more than one standard module, a compile-time error occurs.
             Dim modulemembers As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
             modulemembers = Helper.GetMembersOfTypes(Compiler, Compiler.TypeManager.GetModulesByNamespace(currentNS), Name)
             If modulemembers Is Nothing Then
                 'do nothing
             ElseIf modulemembers.Count >= 1 Then
                 'Check that they're all from the same module
                 For i As Integer = 1 To modulemembers.Count - 1
                     If Helper.CompareType(modulemembers(0).DeclaringType, modulemembers(i).DeclaringType) = False Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC30562, Me.Location, Name, modulemembers(0).DeclaringType.Name, modulemembers(i).DeclaringType.Name)
                     End If
                 Next
                 Return SetClassificationOfModuleMembers(modulemembers)
             End If
 
             currentNS = Helper.GetNamespaceParent(currentNS)
         End While
         If CheckOutermostNamespace(Name) Then Return True
 
         '* If the source file has one or more import aliases, and the identifier matches the name of one of them,
         '   then the identifier refers to that namespace or type.
         If ResolveAliasImports(Me.Location.File(Compiler).Imports, Name) Then Return True
 
         '* If the source file containing the name reference has one or more imports
         '** If the identifier matches the name of an accessible type or type member in exactly one import, 
         '   then the identifier refers to that type or type member. If the identifier matches the name of 
         '   an accessible type or type member in more than one import, a compile-time error occurs.
         '** If the identifier matches the name of a namespace in exactly one import, then the identifier 
         '   refers to that namespace. If the identifier matches the name of a namespace in more than one import, 
         '   a compile-time error occurs.
         '** Otherwise, if the imports contain one or more accessible standard modules, and a member name 
         '   lookup of the identifier produces an accessible match in exactly one standard module, then 
         '   the result is exactly the same as a member access of the form M.E, where M is the standard 
         '   module containing the matching member and E is the identifier. If the identifier matches 
         '   accessible type members in more than one standard module, a compile-time error occurs.
         If ResolveImports(Me.Location.File(Compiler).Imports, Name) Then Return True
 
         '* If the compilation environment defines one or more import aliases, and the identifier matches 
         '  the name of one of them, then the identifier refers to that namespace or type.
         If ResolveAliasImports(Me.Compiler.CommandLine.Imports.Clauses, Name) Then Return True
 
         '* If the compilation environment defines one or more imports
         '** If the identifier matches the name of an accessible type or type member in exactly one import, 
         '   then the identifier refers to that type or type member. If the identifier matches the name 
         '   of an accessible type or type member in more than one import, a compile-time error occurs.
         '** If the identifier matches the name of a namespace in exactly one import, then the identifier 
         '   refers to that namespace. If the identifier matches the name of a namespace in more than 
         '   one import, a compile-time error occurs.
         '** Otherwise, if the imports contain one or more accessible standard modules, and a member name 
         '   lookup of the identifier produces an accessible match in exactly one standard module, then the result 
         '   is exactly the same as a member access of the form M.E, where M is the standard module containing 
         '   the matching member and E is the identifier. If the identifier matches accessible type members in 
         '   more than one standard module, a compile-time error occurs.
         If ResolveImports(Me.Compiler.CommandLine.Imports.Clauses, Name) Then Return True
 
         If Location.File(Compiler).IsOptionExplicitOn = False AndAlso Info.CanBeImplicitSimpleName Then
             Dim parent_method As MethodBaseDeclaration
             parent_method = Me.FindFirstParent(Of MethodBaseDeclaration)()
 
             If method IsNot Nothing Then
                 Dim varD As LocalVariableDeclaration
                 Dim varType As Mono.Cecil.TypeReference
                 If m_Identifier.HasTypeCharacter Then
                     varType = TypeCharacters.TypeCharacterToType(Compiler, m_Identifier.TypeCharacter)
                 Else
                     varType = Compiler.TypeCache.System_Object
                 End If
                 varD = New LocalVariableDeclaration(parent_method.Code, Nothing, m_Identifier, False, Nothing, Nothing, Nothing)
                 varD.Init(Nothing, m_Identifier.Identifier, varType)
                 parent_method.Code.AddVariable(varD)
                 Me.Classification = New VariableClassification(Me, varD)
                 Return True
             End If
         End If
 
         'Check if Local Type Inference is enabled        
         If InferEnabled Then
             InferPossible = True
             Return False
         End If
 
         '* Otherwise, the name given by the identifier is undefined and a compile-time error occurs.
         Compiler.Report.ShowMessage(Messages.VBNC30451, Me.Location, Name)
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\ArrayInitializerExpression.vb" startline="136" endline="270">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
         Dim operandType As TypeCode
         Dim rightOperandType As TypeCode
         Dim leftOperandType As TypeCode
 
         result = ResolveExpressions(Info) AndAlso result
 
         If result = False Then Return False
 
         If Helper.CompareType(m_LeftExpression.ExpressionType, m_RightExpression.ExpressionType) = False Then
             If Helper.CompareType(m_LeftExpression.ExpressionType, Compiler.TypeCache.Nothing) Then
                 m_LeftExpression = New CTypeExpression(Me, m_LeftExpression, m_RightExpression.ExpressionType)
                 result = m_LeftExpression.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
             ElseIf Helper.CompareType(m_RightExpression.ExpressionType, Compiler.TypeCache.Nothing) Then
                 m_RightExpression = New CTypeExpression(Me, m_RightExpression, m_LeftExpression.ExpressionType)
                 result = m_RightExpression.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
             End If
         End If
 
         operandType = Me.OperandTypeCode
         rightOperandType = Me.RightOperandTypeCode
         leftOperandType = Me.LeftOperandTypeCode
 
         If operandType = TypeCode.Empty Then
             'Try operator overloading
             Dim showErrors As Boolean = Me.RightTypeCode = TypeCode.DBNull OrElse Me.LeftTypeCode = TypeCode.DBNull
 
             result = DoOperatorOverloading(showErrors) AndAlso result
 
             If result = False AndAlso showErrors = False Then
                 If (Me.Keyword = KS.ShiftLeft OrElse Me.Keyword = KS.ShiftRight) AndAlso Helper.CompareType(Me.LeftType, Compiler.TypeCache.System_Char) = False AndAlso Helper.CompareType(Me.LeftType, Compiler.TypeCache.System_DateTime) = False Then
                     If Helper.CompareType(Me.RightType, Compiler.TypeCache.System_Char) Then
                         Compiler.Report.ShowMessage(Messages.VBNC32006, Location, Helper.ToString(Compiler, Compiler.TypeCache.System_Int32))
                     ElseIf Helper.CompareType(Me.RightType, Compiler.TypeCache.System_DateTime) Then
                         Compiler.Report.ShowMessage(Messages.VBNC30311, Location, Helper.ToString(Compiler, Me.RightType), Helper.ToString(Compiler, Compiler.TypeCache.System_Int32))
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30452, Location, Enums.strSpecial(Me.Keyword), Helper.ToString(Compiler, Compiler.TypeCache.System_Int32), Helper.ToString(Compiler, Me.RightType))
                     End If
                 Else
                     If Me.Keyword = KS.AndAlso AndAlso (Me.LeftTypeCode = TypeCode.DBNull OrElse Me.RightTypeCode = TypeCode.DBNull) Then
                         Compiler.Report.ShowMessage(Messages.VBNC30452, Location, "And", Helper.ToString(Compiler, Me.LeftType), Helper.ToString(Compiler, Me.RightType))
                     ElseIf Me.Keyword = KS.OrElse AndAlso (Me.LeftTypeCode = TypeCode.DBNull OrElse Me.RightTypeCode = TypeCode.DBNull) Then
                         Compiler.Report.ShowMessage(Messages.VBNC30452, Location, "Or", Helper.ToString(Compiler, Me.LeftType), Helper.ToString(Compiler, Me.RightType))
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30452, Location, Enums.strSpecial(Me.Keyword), Helper.ToString(Compiler, Me.LeftType), Helper.ToString(Compiler, Me.RightType))
                     End If
                 End If
             End If
         Else
             'If X and Y are both intrinsic types, look up the result type in our operator tables and use that.
             'If X is an intrinsic type, then
             '- Collect all of the intrinsic types that Y converts to.
             '- Choose the most encompassed type, T, from the list. If there is no single most encompassed type, then we don't consider an intrinsic operator.
             '- Lookup up the intrinsic operator for X and T, and call it O. If there is no intrinsic operator defined for those two types, then we don't consider an intrinsic operator.
             '- The set of operators to be considered is all the user-defined operators in Y, plus O, if it exists.
             'If Y is an intrinsic type, then perform the same steps as for X (obviously, both can't be intrinsic types at this point).
             'Do overload resolution on the set of operators to be considered.
             Dim isLeftIntrinsic As Boolean = Me.LeftTypeCode <> TypeCode.Object OrElse Helper.CompareType(Compiler.TypeCache.System_Object, Me.LeftType)
             Dim isRightIntrinsic As Boolean = Me.RightTypeCode <> TypeCode.Object OrElse Helper.CompareType(Compiler.TypeCache.System_Object, Me.RightType)
             Dim doOpOverloading As Boolean = False
             Dim isStrict As Boolean?
 
             If isLeftIntrinsic AndAlso isRightIntrinsic OrElse IsOverloadable = False Then
                 Dim destinationType As Mono.Cecil.TypeReference
                 m_ExpressionType = Compiler.TypeResolution.TypeCodeToType(TypeConverter.GetBinaryResultType(Keyword, LeftTypeCode, RightTypeCode))
 
                 If Keyword <> KS.Is AndAlso Keyword <> KS.IsNot Then
                     If Location.File(Compiler).IsOptionStrictOn Then
                         If Helper.CompareType(m_LeftExpression.ExpressionType, Compiler.TypeCache.System_Object) Then
                             If Keyword = KS.Equals OrElse Keyword = KS.NotEqual Then
                                 result = Compiler.Report.ShowMessage(Messages.VBNC32013, Me.Location, Enums.strSpecial(Keyword))
                             Else
                                 result = Compiler.Report.ShowMessage(Messages.VBNC30038, Me.Location, Enums.strSpecial(Keyword))
                             End If
                         End If
                         If Helper.CompareType(m_RightExpression.ExpressionType, Compiler.TypeCache.System_Object) Then
                             If Keyword = KS.Equals OrElse Keyword = KS.NotEqual Then
                                 result = Compiler.Report.ShowMessage(Messages.VBNC32013, Me.Location, Enums.strSpecial(Keyword))
                             Else
                                 result = Compiler.Report.ShowMessage(Messages.VBNC30038, Me.Location, Enums.strSpecial(Keyword))
                             End If
                         End If
                     End If
                 End If
 
                 If LeftTypeCode = TypeCode.String AndAlso RightTypeCode = TypeCode.String AndAlso (Keyword = KS.Concat OrElse Keyword = KS.Add) Then
                     isStrict = False
                 End If
 
                 If LeftTypeCode <> leftOperandType Then
                     destinationType = Compiler.TypeResolution.TypeCodeToType(leftOperandType)
                     result = Helper.IsConvertible(Me, m_LeftExpression, m_LeftExpression.ExpressionType, destinationType, True, m_LeftExpression, True, isStrict)
                 End If
 
                 If RightTypeCode <> rightOperandType Then
                     destinationType = Compiler.TypeResolution.TypeCodeToType(rightOperandType)
                     result = Helper.IsConvertible(Me, m_RightExpression, m_RightExpression.ExpressionType, destinationType, True, m_RightExpression, True, isStrict)
                 End If
                 Classification = New ValueClassification(Me)
 
             ElseIf isRightIntrinsic = False AndAlso isLeftIntrinsic = True Then
                 Dim convertsTo As TypeCode() = TypeResolution.GetIntrinsicTypesImplicitlyConvertibleFrom(Compiler, RightType)
                 convertsTo = Helper.GetMostEncompassedTypes(Compiler, convertsTo)
 
                 If convertsTo IsNot Nothing AndAlso convertsTo.Length = 1 Then
                     m_RightExpression = Helper.CreateTypeConversion(Me, m_RightExpression, Compiler.TypeResolution.TypeCodeToType(convertsTo(0)), result)
                     m_ExpressionType = Compiler.TypeResolution.TypeCodeToType(TypeConverter.GetBinaryResultType(Keyword, LeftTypeCode, RightTypeCode))
                     Classification = New ValueClassification(Me)
                 Else
                     doOpOverloading = True
                 End If
             ElseIf isRightIntrinsic = True AndAlso isLeftIntrinsic = False Then
                 Dim convertsTo As TypeCode() = TypeResolution.GetIntrinsicTypesImplicitlyConvertibleFrom(Compiler, LeftType)
                 convertsTo = Helper.GetMostEncompassedTypes(Compiler, convertsTo)
 
                 If convertsTo IsNot Nothing AndAlso convertsTo.Length = 1 Then
                     m_LeftExpression = Helper.CreateTypeConversion(Me, m_LeftExpression, Compiler.TypeResolution.TypeCodeToType(convertsTo(0)), result)
                     m_ExpressionType = Compiler.TypeResolution.TypeCodeToType(TypeConverter.GetBinaryResultType(Keyword, LeftTypeCode, RightTypeCode))
                     Classification = New ValueClassification(Me)
                 Else
                     doOpOverloading = True
                 End If
             Else
                 doOpOverloading = True
             End If
 
             If doOpOverloading Then
                 result = DoOperatorOverloading(True) AndAlso result
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\StdToolMgr.vb" startline="26" endline="237">
<![CDATA[
 
     'Required by the Windows Form Designer
     Private components As System.ComponentModel.IContainer
 
     'NOTE
     'It can be modified using the Windows Form Designer.  
     'Do not modify it using the code editor.
     Friend WithEvents lplayPos As System.Windows.Forms.Label
     Friend WithEvents tbButtons As System.Windows.Forms.ToolBar
     Friend WithEvents cPlay As System.Windows.Forms.ToolBarButton
     Friend WithEvents cStop As System.Windows.Forms.ToolBarButton
     Friend WithEvents cEnd As System.Windows.Forms.ToolBarButton
     Friend WithEvents cBegin As System.Windows.Forms.ToolBarButton
     Friend WithEvents cSelStrt As System.Windows.Forms.ToolBarButton
     Friend WithEvents cSelEnd As System.Windows.Forms.ToolBarButton
     Friend WithEvents cFFwd As System.Windows.Forms.ToolBarButton
     Friend WithEvents cFRev As System.Windows.Forms.ToolBarButton
     Friend WithEvents sep1 As System.Windows.Forms.ToolBarButton
     Friend WithEvents sep2 As System.Windows.Forms.ToolBarButton
     Friend WithEvents cMute As System.Windows.Forms.ToolBarButton
     Friend WithEvents sep3 As System.Windows.Forms.ToolBarButton
     Friend WithEvents iList As System.Windows.Forms.ImageList
     Friend WithEvents VolBar As System.Windows.Forms.TrackBar
     Friend WithEvents Timer As System.Windows.Forms.Timer
     Friend WithEvents lPos As System.Windows.Forms.Label
     <System.Diagnostics.DebuggerStepThrough()> Private Sub InitializeComponent()
         Me.components = New System.ComponentModel.Container
         Dim resources As System.ComponentModel.ComponentResourceManager = New System.ComponentModel.ComponentResourceManager(GetType(ucMPcontrols))
         Me.lplayPos = New System.Windows.Forms.Label
         Me.tbButtons = New System.Windows.Forms.ToolBar
         Me.cStop = New System.Windows.Forms.ToolBarButton
         Me.cPlay = New System.Windows.Forms.ToolBarButton
         Me.sep1 = New System.Windows.Forms.ToolBarButton
         Me.cBegin = New System.Windows.Forms.ToolBarButton
         Me.cFRev = New System.Windows.Forms.ToolBarButton
         Me.cFFwd = New System.Windows.Forms.ToolBarButton
         Me.cEnd = New System.Windows.Forms.ToolBarButton
         Me.sep2 = New System.Windows.Forms.ToolBarButton
         Me.cSelStrt = New System.Windows.Forms.ToolBarButton
         Me.cSelEnd = New System.Windows.Forms.ToolBarButton
         Me.sep3 = New System.Windows.Forms.ToolBarButton
         Me.cMute = New System.Windows.Forms.ToolBarButton
         Me.iList = New System.Windows.Forms.ImageList(Me.components)
         Me.VolBar = New System.Windows.Forms.TrackBar
         Me.Timer = New System.Windows.Forms.Timer(Me.components)
         Me.lPos = New System.Windows.Forms.Label
         CType(Me.VolBar, System.ComponentModel.ISupportInitialize).BeginInit()
         Me.SuspendLayout()
         '
         'lplayPos
         '
         Me.lplayPos.BackColor = System.Drawing.Color.Beige
         Me.lplayPos.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.lplayPos.Dock = System.Windows.Forms.DockStyle.Top
         Me.lplayPos.Enabled = False
         Me.lplayPos.Location = New System.Drawing.Point(3, 3)
         Me.lplayPos.Name = "lplayPos"
         Me.lplayPos.Size = New System.Drawing.Size(362, 16)
         Me.lplayPos.TabIndex = 0
         '
         'tbButtons
         '
         Me.tbButtons.Appearance = System.Windows.Forms.ToolBarAppearance.Flat
         Me.tbButtons.Buttons.AddRange(New System.Windows.Forms.ToolBarButton() {Me.cStop, Me.cPlay, Me.sep1, Me.cBegin, Me.cFRev, Me.cFFwd, Me.cEnd, Me.sep2, Me.cSelStrt, Me.cSelEnd, Me.sep3, Me.cMute})
         Me.tbButtons.Dock = System.Windows.Forms.DockStyle.Bottom
         Me.tbButtons.DropDownArrows = True
         Me.tbButtons.ImageList = Me.iList
         Me.tbButtons.Location = New System.Drawing.Point(3, 28)
         Me.tbButtons.Name = "tbButtons"
         Me.tbButtons.ShowToolTips = True
         Me.tbButtons.Size = New System.Drawing.Size(362, 28)
         Me.tbButtons.TabIndex = 1
         '
         'cStop
         '
         Me.cStop.ImageIndex = 9
         Me.cStop.Name = "cStop"
         Me.cStop.Tag = "cStop"
         Me.cStop.ToolTipText = "Stop"
         '
         'cPlay
         '
         Me.cPlay.ImageIndex = 1
         Me.cPlay.Name = "cPlay"
         Me.cPlay.Tag = "cPlay"
         Me.cPlay.ToolTipText = "Play / Pause [Space]"
         '
         'sep1
         '
         Me.sep1.Name = "sep1"
         Me.sep1.Style = System.Windows.Forms.ToolBarButtonStyle.Separator
         '
         'cBegin
         '
         Me.cBegin.ImageIndex = 5
         Me.cBegin.Name = "cBegin"
         Me.cBegin.Tag = "cBegin"
         Me.cBegin.ToolTipText = "Jump to start [Ctrl+S]"
         '
         'cFRev
         '
         Me.cFRev.ImageIndex = 3
         Me.cFRev.Name = "cFRev"
         Me.cFRev.Style = System.Windows.Forms.ToolBarButtonStyle.ToggleButton
         Me.cFRev.Tag = "cFRev"
         Me.cFRev.ToolTipText = "Fast Reverse [Ctrl+Dn Arrow]"
         '
         'cFFwd
         '
         Me.cFFwd.ImageIndex = 2
         Me.cFFwd.Name = "cFFwd"
         Me.cFFwd.Style = System.Windows.Forms.ToolBarButtonStyle.ToggleButton
         Me.cFFwd.Tag = "cFFwd"
         Me.cFFwd.ToolTipText = "Fast Forward [Ctrl+Up Arrow]"
         '
         'cEnd
         '
         Me.cEnd.ImageIndex = 4
         Me.cEnd.Name = "cEnd"
         Me.cEnd.Tag = "cEnd"
         Me.cEnd.ToolTipText = "Jump to End [Ctrl+End]"
         '
         'sep2
         '
         Me.sep2.Name = "sep2"
         Me.sep2.Style = System.Windows.Forms.ToolBarButtonStyle.Separator
         '
         'cSelStrt
         '
         Me.cSelStrt.ImageIndex = 7
         Me.cSelStrt.Name = "cSelStrt"
         Me.cSelStrt.Tag = "cSelStrt"
         Me.cSelStrt.ToolTipText = "Mark Selection Start [Home]"
         '
         'cSelEnd
         '
         Me.cSelEnd.ImageIndex = 8
         Me.cSelEnd.Name = "cSelEnd"
         Me.cSelEnd.Tag = "cSelEnd"
         Me.cSelEnd.ToolTipText = "Mark Selection End [End]"
         '
         'sep3
         '
         Me.sep3.Name = "sep3"
         Me.sep3.Style = System.Windows.Forms.ToolBarButtonStyle.Separator
         '
         'cMute
         '
         Me.cMute.ImageIndex = 0
         Me.cMute.Name = "cMute"
         Me.cMute.Style = System.Windows.Forms.ToolBarButtonStyle.ToggleButton
         Me.cMute.Tag = "cMute"
         Me.cMute.ToolTipText = "Mute"
         '
         'iList
         '
         Me.iList.ImageStream = CType(resources.GetObject("iList.ImageStream"), System.Windows.Forms.ImageListStreamer)
         Me.iList.TransparentColor = System.Drawing.Color.Transparent
         Me.iList.Images.SetKeyName(0, "")
         Me.iList.Images.SetKeyName(1, "")
         Me.iList.Images.SetKeyName(2, "")
         Me.iList.Images.SetKeyName(3, "")
         Me.iList.Images.SetKeyName(4, "")
         Me.iList.Images.SetKeyName(5, "")
         Me.iList.Images.SetKeyName(6, "")
         Me.iList.Images.SetKeyName(7, "")
         Me.iList.Images.SetKeyName(8, "")
         Me.iList.Images.SetKeyName(9, "")
         Me.iList.Images.SetKeyName(10, "")
         '
         'VolBar
         '
         Me.VolBar.Location = New System.Drawing.Point(233, 31)
         Me.VolBar.Maximum = 100
         Me.VolBar.Name = "VolBar"
         Me.VolBar.Size = New System.Drawing.Size(80, 45)
         Me.VolBar.SmallChange = 5
         Me.VolBar.TabIndex = 2
         Me.VolBar.TabStop = False
         Me.VolBar.TickFrequency = 5
         Me.VolBar.TickStyle = System.Windows.Forms.TickStyle.None
         '
         'Timer
         '
         '
         'lPos
         '
         Me.lPos.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.lPos.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.lPos.Font = New System.Drawing.Font("Microsoft Sans Serif", 7.0!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.lPos.ForeColor = System.Drawing.SystemColors.ControlDarkDark
         Me.lPos.Location = New System.Drawing.Point(313, 32)
         Me.lPos.Name = "lPos"
         Me.lPos.Size = New System.Drawing.Size(52, 16)
         Me.lPos.TabIndex = 3
         Me.lPos.Text = "0
         Me.lPos.TextAlign = System.Drawing.ContentAlignment.MiddleRight
         '
         'ucMPcontrols
         '
         Me.Controls.Add(Me.lPos)
         Me.Controls.Add(Me.lplayPos)
         Me.Controls.Add(Me.VolBar)
         Me.Controls.Add(Me.tbButtons)
         Me.Name = "ucMPcontrols"
         Me.Padding = New System.Windows.Forms.Padding(3, 3, 3, 0)
         Me.Size = New System.Drawing.Size(368, 56)
         CType(Me.VolBar, System.ComponentModel.ISupportInitialize).EndInit()
         Me.ResumeLayout(False)
         Me.PerformLayout()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeDictionary.vb" startline="633" endline="928">
<![CDATA[
 
     ''' <summary>
     ''' Tries to convert the value into the desired type. Returns true if successful, 
     ''' returns false otherwise. 
     ''' </summary>
     ''' <param name="value"></param>
     ''' <param name="result"></param>
     ''' <param name="desiredType"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Public Function CheckNumericRange(ByVal value As Object, ByRef result As Object, ByVal desiredType As Mono.Cecil.TypeReference) As Boolean
         Dim builtInType As BuiltInDataTypes = TypeResolution.TypeCodeToBuiltInType(Helper.GetTypeCode(Compiler, desiredType))
 
         If value Is Nothing Then 'Nothing can be converted into anything.
             result = Nothing
             Return True
         End If
 
         If IsNumericType(desiredType) = False Then Return False
 
         If IsIntegralType(builtInType) AndAlso IsIntegralType(Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, value))) Then
             Return CheckIntegralRange(value, result, builtInType)
         Else
             Dim tpValue As TypeCode = Helper.GetTypeCode(Compiler, CecilHelper.GetType(Compiler, value))
             Dim desiredCode As TypeCode = Helper.GetTypeCode(Compiler, desiredType)
 
             If Helper.CompareType(CecilHelper.GetType(Compiler, value), desiredType) Then
                 result = value
                 Return True
             End If
 
             If tpValue = TypeCode.DBNull Then
                 Select Case desiredCode
                     Case TypeCode.Boolean
                         result = CBool(Nothing)
                     Case TypeCode.Byte
                         result = CByte(Nothing)
                     Case TypeCode.Char
                         result = CChar(Nothing)
                     Case TypeCode.DateTime
                         result = CDate(Nothing)
                     Case TypeCode.Decimal
                         result = CDec(Nothing)
                     Case TypeCode.Double
                         result = CDbl(Nothing)
                     Case TypeCode.Int16
                         result = CShort(Nothing)
                     Case TypeCode.Int32
                         result = CInt(Nothing)
                     Case TypeCode.Int64
                         result = CLng(Nothing)
                     Case TypeCode.SByte
                         result = CSByte(Nothing)
                     Case TypeCode.Single
                         result = CSng(Nothing)
                     Case TypeCode.String
                         result = Nothing
                     Case TypeCode.UInt16
                         result = CUShort(Nothing)
                     Case TypeCode.UInt32
                         result = CUInt(Nothing)
                     Case TypeCode.UInt64
                         result = CULng(Nothing)
                     Case Else
                         Helper.Stop()
                         Throw New InternalException("")
                 End Select
                 Return True
             End If
 
             If IsNumericType(CecilHelper.GetType(Compiler, value)) = False Then Return False
 
             Select Case desiredCode
                 Case TypeCode.Double
                     Select Case tpValue
                         Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Single, TypeCode.Double, TypeCode.Decimal
                             result = CDbl(value)
                             Return True
                     End Select
                 Case TypeCode.Decimal
                     Select Case tpValue
                         Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Decimal
                             result = CDec(value)
                             Return True
                         Case TypeCode.Single, TypeCode.Double
                             Dim tmp As Double = CDbl(value)
                             If tmp <= Decimal.MaxValue AndAlso tmp >= Decimal.MinValue Then
                                 result = CDec(tmp) 'This should be CDec(value), but vbc.exe seems to do it like this.
                                 Return True
                             Else
                                 Return False
                             End If
                     End Select
                 Case TypeCode.Single
                     Select Case tpValue
                         Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.UInt32, TypeCode.Int64, TypeCode.UInt64, TypeCode.Single, TypeCode.Decimal
                             result = CSng(value)
                             Return True
                         Case TypeCode.Double
                             If CDbl(value) >= Single.MinValue AndAlso CDbl(value) <= Single.MaxValue Then
                                 result = CSng(value)
                                 Return True
                             Else
                                 Return False
                             End If
                     End Select
                 Case TypeCode.Byte
                     Select Case tpValue
                         Case TypeCode.Single, TypeCode.Double
                             Dim tmp As Double = CDbl(value)
                             If tmp <= Byte.MaxValue AndAlso tmp >= Byte.MinValue Then
                                 result = CByte(value)
                                 Return True
                             Else
                                 Return False
                             End If
                         Case TypeCode.Decimal
                             Dim tmp As Decimal = CDec(value)
                             If tmp <= Byte.MaxValue AndAlso tmp >= Byte.MinValue Then
                                 result = CByte(value)
                                 Return True
                             Else
                                 Return False
                             End If
                     End Select
                 Case TypeCode.SByte
                     Select Case tpValue
                         Case TypeCode.Single, TypeCode.Double
                             Dim tmp As Double = CDbl(value)
                             If tmp <= SByte.MaxValue AndAlso tmp >= SByte.MinValue Then
                                 result = CSByte(value)
                                 Return True
                             Else
                                 Return False
                             End If
                         Case TypeCode.Decimal
                             Dim tmp As Decimal = CDec(value)
                             If tmp <= SByte.MaxValue AndAlso tmp >= SByte.MinValue Then
                                 result = CSByte(value)
                                 Return True
                             Else
                                 Return False
                             End If
                     End Select
                 Case TypeCode.Int16
                     Select Case tpValue
                         Case TypeCode.Single, TypeCode.Double
                             Dim tmp As Double = CDbl(value)
                             If tmp <= Int16.MaxValue AndAlso tmp >= Int16.MinValue Then
                                 result = CShort(value)
                                 Return True
                             Else
                                 Return False
                             End If
                         Case TypeCode.Decimal
                             Dim tmp As Decimal = CDec(value)
                             If tmp <= Int16.MaxValue AndAlso tmp >= Int16.MinValue Then
                                 result = CShort(value)
                                 Return True
                             Else
                                 Return False
                             End If
                     End Select
                 Case TypeCode.UInt16
                     Select Case tpValue
                         Case TypeCode.Single, TypeCode.Double
                             Dim tmp As Double = CDbl(value)
                             If tmp <= UInt16.MaxValue AndAlso tmp >= UInt16.MinValue Then
                                 result = CUShort(value)
                                 Return True
                             Else
                                 Return False
                             End If
                         Case TypeCode.Decimal
                             Dim tmp As Decimal = CDec(value)
                             If tmp <= UInt16.MaxValue AndAlso tmp >= UInt16.MinValue Then
                                 result = CUShort(value)
                                 Return True
                             Else
                                 Return False
                             End If
                     End Select
                 Case TypeCode.Int32
                     Select Case tpValue
                         Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.Boolean
                             result = CInt(value)
                             Return True
                         Case TypeCode.Single, TypeCode.Double
                             Dim tmp As Double = CDbl(value)
                             If tmp <= Int32.MaxValue AndAlso tmp >= Int32.MinValue Then
                                 result = CInt(value)
                                 Return True
                             Else
                                 Return False
                             End If
                         Case TypeCode.Decimal
                             Dim tmp As Decimal = CDec(value)
                             If tmp <= Int32.MaxValue AndAlso tmp >= Int32.MinValue Then
                                 result = CInt(value)
                                 Return True
                             Else
                                 Return False
                             End If
                     End Select
                 Case TypeCode.UInt32
                     Select Case tpValue
                         Case TypeCode.Single, TypeCode.Double
                             Dim tmp As Double = CDbl(value)
                             If tmp <= UInt32.MaxValue AndAlso tmp >= UInt32.MinValue Then
                                 result = CUInt(value)
                                 Return True
                             Else
                                 Return False
                             End If
                         Case TypeCode.Decimal
                             Dim tmp As Decimal = CDec(value)
                             If tmp <= UInt32.MaxValue AndAlso tmp >= UInt32.MinValue Then
                                 result = CUInt(value)
                                 Return True
                             Else
                                 Return False
                             End If
                     End Select
                 Case TypeCode.Int64
                     Select Case tpValue
                         Case TypeCode.Byte, TypeCode.SByte, TypeCode.Int16, TypeCode.UInt16, TypeCode.Int32, TypeCode.Boolean
                             result = CInt(value)
                             Return True
                         Case TypeCode.Single, TypeCode.Double
                             Dim tmp As Double = CDbl(value)
                             If tmp <= Int64.MaxValue AndAlso tmp >= Int64.MinValue Then
                                 result = CLng(value)
                                 Return True
                             Else
                                 Return False
                             End If
                         Case TypeCode.Decimal
                             Dim tmp As Decimal = CDec(value)
                             If tmp <= Int64.MaxValue AndAlso tmp >= Int64.MinValue Then
                                 result = CLng(value)
                                 Return True
                             Else
                                 Return False
                             End If
                     End Select
                 Case TypeCode.UInt64
                     Select Case tpValue
                         Case TypeCode.Single, TypeCode.Double
                             Dim tmp As Double = CDbl(value)
                             If tmp <= UInt64.MaxValue AndAlso tmp >= UInt64.MinValue Then
                                 result = CULng(value)
                                 Return True
                             Else
                                 Return False
                             End If
                         Case TypeCode.Decimal
                             Dim tmp As Decimal = CDec(value)
                             If tmp <= UInt64.MaxValue AndAlso tmp >= UInt64.MinValue Then
                                 result = CULng(value)
                                 Return True
                             Else
                                 Return False
                             End If
                     End Select
             End Select
 
             Select Case tpValue
                 Case TypeCode.Byte, TypeCode.UInt16, TypeCode.UInt32, TypeCode.UInt64
                     Dim tmpValue As ULong = CULng(value)
                     Helper.Stop()
                 Case TypeCode.SByte, TypeCode.Int16, TypeCode.Int32, TypeCode.Int64
                     Dim tmpValue As Long = CLng(value)
                     'Dim t As Type
                     Helper.Stop()
                 Case TypeCode.Char
                     Helper.Stop()
                 Case TypeCode.Boolean
                     Helper.Stop()
                 Case TypeCode.DateTime
                     Helper.Stop()
                 Case TypeCode.Decimal
                     Helper.Stop()
                 Case TypeCode.Double
                     Helper.Stop()
                 Case TypeCode.Single
                     Helper.Stop()
                 Case TypeCode.String
                     Helper.Stop()
                 Case Else
                     Helper.Stop()
             End Select
             Helper.Stop()
         End If
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\MethodResolver.vb" startline="1347" endline="1669">
<![CDATA[
 
     ''' <summary>
     ''' if error_lines is empty upon exit, an error has been shown
     ''' </summary>
     ''' <param name="error_lines"></param>
     ''' <returns></returns>
     ''' <remarks></remarks>
     Function IsApplicable(ByVal error_lines As Generic.List(Of String)) As Boolean
         Dim matchedParameters As Argument()
         Dim exactArguments As Generic.List(Of Argument)
 
         Dim isLastParamArray As Boolean
         Dim paramArrayExpression As ArrayCreationExpression = Nothing
         Dim inputParametersCount As Integer = InputParameters.Count
         Dim paramArrayParameter As ParameterDefinition = Nothing
 
         If inputParametersCount > 0 AndAlso Helper.IsParamArrayParameter(Compiler, InputParameters(inputParametersCount - 1)) Then
             isLastParamArray = True
             paramArrayParameter = InputParameters(inputParametersCount - 1)
         End If
 
         '(if there are more arguments than parameters and the last parameter is not a 
         'paramarray parameter the method should not be applicable)
         'This has already been checked
 
         ReDim matchedParameters(inputParametersCount - 1)
         exactArguments = New Generic.List(Of Argument)(inputParametersCount)
         For i As Integer = 0 To inputParametersCount - 1
             exactArguments.Add(Nothing)
         Next
 
         ReDim m_TypesInInvokedOrder(Math.Max(Arguments.Count - 1, inputParametersCount - 1))
 
         If isLastParamArray Then
             Dim paramArrayArg As New PositionalArgument(Parent)
 
             paramArrayExpression = New ArrayCreationExpression(paramArrayArg)
             paramArrayExpression.Init(ParamArrayParameter.ParameterType, New Expression() {})
 
             paramArrayArg.Init(ParamArrayParameter.Sequence, paramArrayExpression)
             exactArguments(inputParametersCount - 1) = paramArrayArg
 
             m_TypesInInvokedOrder(inputParametersCount - 1) = paramArrayParameter.ParameterType
             ParametersFromExpandedParamArray += 1
         End If
 
         Dim firstNamedArgument As Integer = Arguments.Count + 1
         For i As Integer = 0 To Arguments.Count - 1
             'First, match each positional argument in order to the list of method parameters. 
             'If there are more positional arguments than parameters and the last parameter 
             'is not a paramarray, the method is not applicable. Otherwise, the paramarray parameter 
             'is expanded with parameters of the paramarray element type to match the number
             'of positional arguments. If a positional argument is omitted, the method is not applicable.
             If Arguments(i).IsNamedArgument Then
                 firstNamedArgument = i
                 Exit For '(No more positional arguments)
             End If
 
             If inputParametersCount - 1 < i Then
                 '(more positional arguments than parameters)
                 Helper.Assert(isLastParamArray) 'We've already checked the case where we're not a paramarray candidate
 
                 'Add the additional expressions to the param array creation expression.
                 'Helper.Assert(paramArrayExpression.ArrayElementInitalizer.Initializers.Count = 1)
                 'A paramarray element has to be specified.
                 If Arguments(i).Expression Is Nothing Then
                     If error_lines IsNot Nothing Then
                         error_lines.Clear()
                         Compiler.Report.ShowMessage(Messages.VBNC30588, m_Parent.Parent.Location)
                     End If
                     Return False
                 End If
                 paramArrayExpression.ArrayElementInitalizer.AddInitializer(Arguments(i).Expression)
 
                 Helper.Assert(m_TypesInInvokedOrder(i) Is Nothing)
                 m_TypesInInvokedOrder(i) = CecilHelper.GetElementType(InputParameters(inputParametersCount - 1).ParameterType)
                 ParametersFromExpandedParamArray += 1
                 IsParamArray = True
             Else
                 matchedParameters(i) = Arguments(i)
 
                 'Helper.Assert(m_TypesInInvokedOrder(i) Is Nothing)
                 m_TypesInInvokedOrder(i) = InputParameters(i).ParameterType
 
                 'Get the default value of the parameter if the specified argument has no expression.
                 Dim arg As Argument = Nothing
                 If Arguments(i).Expression IsNot Nothing Then
                     arg = Arguments(i)
                 End If
 
                 If isLastParamArray = False Then exactArguments(i) = arg
                 If isLastParamArray AndAlso inputParametersCount - 1 = i Then
                     'Helper.Assert(paramArrayExpression.ArrayElementInitalizer.Initializers.Count = 0)
                     paramArrayExpression.ArrayElementInitalizer.AddInitializer(arg.Expression)
                     'Helper.Assert(m_TypesInInvokedOrder(i) Is Nothing)
                     m_TypesInInvokedOrder(i) = CecilHelper.GetElementType(InputParameters(inputParametersCount - 1).ParameterType)
                     ParametersFromExpandedParamArray += 1
                 Else
                     If isLastParamArray Then exactArguments(i) = arg
                 End If
             End If
             '??? If a positional argument is omitted, the method is not applicable.
         Next
 
         For i As Integer = firstNamedArgument To Arguments.Count - 1
             Helper.Assert(Arguments(i).IsNamedArgument)
 
             'Next, match each named argument to a parameter with the given name. 
             'If one of the named arguments fails to match, matches a paramarray parameter, 
             'or matches an argument already matched with another positional or named argument,
             'the method is not applicable.
 
             Dim namedArgument As NamedArgument = DirectCast(Arguments(i), NamedArgument)
 
             Dim matched As Boolean = False
             For j As Integer = 0 To inputParametersCount - 1
                 'Next, match each named argument to a parameter with the given name. 
                 Dim inputParam As Mono.Cecil.ParameterReference = InputParameters(j)
                 If Helper.CompareName(inputParam.Name, namedArgument.Name) Then
                     If matchedParameters(j) IsNot Nothing Then
                         'If one of the named arguments (...) matches an argument already matched with 
                         'another positional or named argument, the method is not applicable
                         'LogResolutionMessage(Parent.Compiler, "N/A
                         If error_lines IsNot Nothing Then
                             If matchedParameters(j).Expression Is Nothing Then
                                 error_lines.Clear()
                                 Compiler.Report.ShowMessage(Messages.VBNC32021, m_Parent.Parent.Location, inputParam.Name, Helper.ToString(Compiler, Member))
                             Else
                                 error_lines.Add(String.Format("'{0}'
                             End If
                         End If
                         Return False
                     ElseIf Helper.IsParamArrayParameter(Parent.Compiler, inputParam) Then
                         'If one of the named arguments (...) matches a paramarray parameter, 
                         '(...) the method is not applicable.
                         If error_lines IsNot Nothing Then
                             error_lines.Clear()
                             Compiler.Report.ShowMessage(Messages.VBNC30587, m_Parent.Parent.Location)
                         End If
                         Return False
                     Else
                         matchedParameters(j) = Arguments(i)
                         exactArguments(j) = Arguments(i)
 
                         Helper.Assert(m_TypesInInvokedOrder(j) Is Nothing)
                         m_TypesInInvokedOrder(j) = inputParam.ParameterType
                         matched = True
                         Exit For
                     End If
                 End If
             Next
             'If one of the named arguments fails to match (...) the method is not applicable
             If matched = False Then
                 'LogResolutionMessage(Parent.Compiler, "N/A
                 Return False
             End If
         Next
 
         'Next, if parameters that have not been matched are not optional, 
         'the method is not applicable. If optional parameters remain, the default value 
         'specified in the optional parameter declaration is matched to the parameter. 
         'If an Object parameter does not specify a default value, then the expression 
         'System.Reflection.Missing.Value is used. If an optional Integer parameter 
         'has the Microsoft.VisualBasic.CompilerServices.OptionCompareAttribute attribute, 
         'then the literal 1 is supplied for text comparisons and the literal 0 otherwise.
 
         For i As Integer = 0 To inputParametersCount - 1
             If matchedParameters(i) Is Nothing Then
                 'if parameters that have not been matched are not optional, the method is not applicable
                 If isLastParamArray = False AndAlso Helper.IsParamArrayParameter(Compiler, InputParameters(i)) Then
                     Return False
                 End If
                 If InputParameters(i).IsOptional = False AndAlso InputParameters(i) Is ParamArrayParameter = False Then
                     'LogResolutionMessage(Parent.Compiler, "N/A
                     If error_lines IsNot Nothing Then
                         error_lines.Clear()
                         Compiler.Report.ShowMessage(Messages.VBNC30455, m_Parent.Parent.Location, InputParameters(i).Name, Helper.ToString(Compiler, Member))
                     End If
                     Return False
                 End If
 
                 If InputParameters(i) Is paramArrayParameter AndAlso isLastParamArray Then
                     Continue For
                 End If
 
                 Dim exp As Expression
                 Dim arg As New PositionalArgument(Parent)
                 exp = Helper.GetOptionalValueExpression(arg, InputParameters(i))
                 arg.Init(InputParameters(i).Sequence, exp)
                 If isLastParamArray = False Then
                     Helper.Assert(m_TypesInInvokedOrder(i) Is Nothing)
                     m_TypesInInvokedOrder(i) = InputParameters(i).ParameterType
                     exactArguments(i) = arg
                 End If
                 If Helper.IsParamArrayParameter(Parent.Compiler, InputParameters(i)) = False Then
                     'he arraycreation has already been created and added to the exactArguments(1).
                     If isLastParamArray Then exactArguments(i) = arg
                 End If
             End If
         Next
 
         'Finally, if type arguments have been specified, they are matched against
         'the type parameter list. If the two lists do not have the same number of elements, 
         'the method is not applicable, unless the type argument list is empty. If the 
         'type argument list is empty, type inferencing is used to try and infer 
         'the type argument list. If type inferencing fails, the method is not applicable.
         'Otherwise, the type arguments are filled in the place of the 
         'type parameters in the signature.
         Dim genericTypeArgumentCount As Integer
         Dim genericTypeArguments As Mono.Collections.Generic.Collection(Of TypeReference)
         Dim method As Mono.Cecil.MethodReference = TryCast(Member, Mono.Cecil.MethodReference)
         If method IsNot Nothing AndAlso CecilHelper.IsGenericMethod(method) Then
             genericTypeArguments = CecilHelper.GetGenericArguments(method)
             genericTypeArgumentCount = genericTypeArguments.Count
         End If
 
         If genericTypeArgumentCount > 0 AndAlso (TypeArguments Is Nothing OrElse TypeArguments.List.Count = 0) Then
             'If the Then type argument list is empty, type inferencing is used to try and infer 
             'the type argument list.
             'Helper.NotImplementedYet("Type argument inference")
         ElseIf TypeArguments IsNot Nothing AndAlso TypeArguments.List.Count > 0 Then
             'If the two lists do not have the same number of elements, the method is not applicable
             If TypeArguments.List.Count <> genericTypeArgumentCount Then
                 'LogResolutionMessage(Parent.Compiler, "N/A
                 Return False
             End If
 
             'Return m_Parent.Compiler.Report.ShowMessage(Messages.VBNC99997, m_Parent.Parent.Location)
             'Helper.NotImplemented("Type argument matching")
         End If
 
         m_ExactArguments = exactArguments
 
         'We need to check for delegate creation expressions, and resolve those against the parameter's type
         For i As Integer = 0 To m_ExactArguments.Count - 1
             Dim aoe As AddressOfExpression
             Dim aoeExact As AddressOfExpression
             If m_ExactArguments(i) Is Nothing Then Continue For
             aoe = TryCast(m_ExactArguments(i).Expression, AddressOfExpression)
             If aoe Is Nothing Then Continue For
             aoeExact = aoe.Clone()
             If Not aoeExact.ResolveExpression(ResolveInfo.Default(Compiler)) Then
                 'Not applicable
                 If error_lines IsNot Nothing Then
                     error_lines.Clear()
                     Helper.AddError(Me.Parent)
                 End If
                 Return False
             End If
             If Not aoeExact.ResolveAddressOfExpression(InputParameters(i).ParameterType, False) Then
                 'Not applicable
                 If error_lines IsNot Nothing Then
                     error_lines.Clear()
                     Helper.AddError(Me.Parent)
                 End If
                 Return False
             End If
             m_ExactArguments(i) = New PositionalArgument(m_ExactArguments(i).Parent, i, aoeExact)
         Next
 
         Dim convertible As Boolean = True
         For i As Integer = 0 To m_ExactArguments.Count - 1
             If m_ExactArguments(i) Is Nothing Then
                 'Argument not supplied for an optional parameter, create it
                 Dim exp As Expression
                 Dim pArg As New PositionalArgument(Parent)
                 exp = Helper.GetOptionalValueExpression(pArg, InputParameters(i))
                 pArg.Init(InputParameters(i).Sequence, exp)
                 m_ExactArguments(i) = pArg
                 'The optional parameter's default value can always be converted to the parameter's type, so no need to check anything here.
                 Continue For
             End If
             If Helper.IsConvertible(m_ExactArguments(i), m_ExactArguments(i).Expression, m_ExactArguments(i).Expression.ExpressionType, m_DefinedParametersTypes(i), False, Nothing, False, Nothing) = False Then
                 convertible = False
                 If error_lines Is Nothing Then Exit For
                 error_lines.Add(String.Format("'{0}'
             End If
         Next
         If Not convertible Then Return False
 
         If isLastParamArray AndAlso paramArrayExpression.ArrayElementInitalizer.Initializers.Count = 1 Then
             Dim exp As Expression = paramArrayExpression.ArrayElementInitalizer.Initializers(0).InitializerExpression
             'If a single argument expression matches a paramarray parameter and the type of the argument expression 
             'is convertible to both the type of the paramarray parameter and the paramarray element type, 
             'the method is applicable in both its expanded and unexpanded forms, with two exceptions. 
 
             If Helper.IsConvertible(exp, exp, exp.ExpressionType, CecilHelper.GetElementType(paramArrayParameter.ParameterType), False, Nothing, False, Nothing) Then
                 IsParamArray = True
                 If Helper.IsConvertible(exp, exp, exp.ExpressionType, paramArrayParameter.ParameterType, False, Nothing, False, Nothing) Then
                     ApplicableExpandedAndUnexpanded = True
 
                     'If the conversion from the type of the argument expression to the paramarray type is narrowing, 
                     'then the method is only applicable in its expanded form. 
                     If Helper.IsConvertible(exp, exp, exp.ExpressionType, paramArrayParameter.ParameterType, False, Nothing, False, True) = False Then
                         ApplicableExpandedAndUnexpanded = False
                     End If
 
                     'If the argument expression is the literal Nothing,  then the method is only applicable in its unexpanded form. 
                     If TypeOf exp Is NothingConstantExpression Then
                         ApplicableExpandedAndUnexpanded = False
                         IsParamArray = False
                     End If
                 End If
             End If
 
             If IsParamArray = False AndAlso m_ExactArguments(m_ExactArguments.Count - 1).Expression Is paramArrayExpression Then
                 'Unwrap the paramarray argument we created.
                 UnexpandParamArrayArgument()
             End If
         End If
 
         'if m_IsParamArray is true
         'if also m_ApplicableExpandedAndUnexpanded is true
         'if m_IsParamArray is false
 
         Helper.AssertNotNothing(m_TypesInInvokedOrder)
 
         If ResolveUnresolvedExpressions() = False Then
             Return False
         End If
 
         Return True 'Method is applicable!!
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Members\AliasClause.vb" startline="225" endline="514">
<![CDATA[
 
     Public Overrides Function ResolveCode(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         Dim argList As ArgumentList
 
         If m_IsResolved Then Return result
 
         If m_AttributeArguments IsNot Nothing Then
             Helper.Assert(m_Arguments Is Nothing)
             Helper.Assert(m_Fields Is Nothing)
             Helper.Assert(m_FieldValues Is Nothing)
             Helper.Assert(m_Properties Is Nothing)
             Helper.Assert(m_PropertyValues Is Nothing)
 
             result = m_AttributeArguments.ResolveCode(Info) AndAlso result
 
             If m_AttributeArguments.PositionalArgumentList IsNot Nothing Then
                 argList = New ArgumentList(Me, m_AttributeArguments.PositionalArgumentList.AsExpressions)
             Else
                 argList = New ArgumentList(Me)
             End If
 
             If m_AttributeArguments.VariablePropertyInitializerList IsNot Nothing Then
                 Dim cache As MemberCache
 
                 cache = Info.Compiler.TypeManager.GetCache(m_ResolvedType)
 
                 For Each item As VariablePropertyInitializer In m_AttributeArguments.VariablePropertyInitializerList
                     Dim name As String
                     Dim member As Mono.Cecil.MemberReference
                     Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
                     Dim constant As Object = Nothing
 
                     name = item.Identifier
                     members = cache.LookupFlattenedMembers(name)
                     members = Helper.FilterExternalInaccessible(Info.Compiler, members)
                     If members.Count <> 1 Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                     End If
                     member = members(0)
 
                     If Not item.AttributeArgumentExpression.Expression.GetConstant(constant, True) Then Return False
 
                     If TypeOf member Is Mono.Cecil.FieldReference Then
                         Dim field As Mono.Cecil.FieldReference
                         field = DirectCast(member, Mono.Cecil.FieldReference)
 
                         If m_Fields Is Nothing Then m_Fields = New Generic.List(Of Mono.Cecil.FieldReference)
                         If m_FieldValues Is Nothing Then m_FieldValues = New Generic.List(Of Object)
                         m_Fields.Add(field)
                         m_FieldValues.Add(constant)
                     ElseIf TypeOf member Is Mono.Cecil.PropertyReference Then
                         Dim prop As Mono.Cecil.PropertyReference
                         prop = DirectCast(member, Mono.Cecil.PropertyReference)
                         If m_Properties Is Nothing Then m_Properties = New Generic.List(Of Mono.Cecil.PropertyReference)
                         If m_PropertyValues Is Nothing Then m_PropertyValues = New Generic.List(Of Object)
                         m_Properties.Add(prop)
                         m_PropertyValues.Add(constant)
                         'm_PropertyValues.add(item.
                     Else
                         Helper.AddError(Me, "Invalid member type for attribute value.")
                     End If
                 Next
             End If
 
         ElseIf m_Arguments IsNot Nothing Then
             argList = New ArgumentList(Me)
             For i As Integer = 0 To m_Arguments.Length - 1
                 argList.Arguments.Add(New PositionalArgument(argList, argList.Count, New ConstantExpression(argList, m_Arguments(i), CecilHelper.GetType(Compiler, m_Arguments(i)))))
             Next
         Else
             argList = New ArgumentList(Me)
         End If
 
         If m_Arguments Is Nothing Then m_Arguments = New Object() {}
         If m_Fields Is Nothing Then m_Fields = New Generic.List(Of Mono.Cecil.FieldReference)
         If m_FieldValues Is Nothing Then m_FieldValues = New Generic.List(Of Object)
         If m_Properties Is Nothing Then m_Properties = New Generic.List(Of Mono.Cecil.PropertyReference)
         If m_PropertyValues Is Nothing Then m_PropertyValues = New Generic.List(Of Object)
 
         Dim ctors As Mono.Collections.Generic.Collection(Of MethodReference)
         Dim parameters As Mono.Collections.Generic.Collection(Of ParameterDefinition)
         ctors = CecilHelper.GetConstructors(m_ResolvedType)
 
         Dim groupClassification As New MethodGroupClassification(Me, Nothing, Nothing, Nothing, ctors)
         result = groupClassification.ResolveGroup(argList) AndAlso result
         If result = False Then
             groupClassification.ResolveGroup(argList, True)
             Return result
         End If
         m_ResolvedTypeConstructor = groupClassification.ResolvedConstructor
         result = m_ResolvedTypeConstructor IsNot Nothing AndAlso result
         result = argList.FillWithOptionalParameters(m_ResolvedTypeConstructor) AndAlso result
 
         parameters = Helper.GetParameters(Me, m_ResolvedTypeConstructor)
 
         ReDim m_Arguments(argList.Count - 1)
         For i As Integer = 0 To m_Arguments.Length - 1
             Dim constant As Object = Nothing
             If argList(i).Expression.GetConstant(constant, True) = False Then Return False
             m_Arguments(i) = constant
             If TypeOf m_Arguments(i) Is DBNull Then
                 m_Arguments(i) = Nothing
             End If
         Next
 
         m_IsResolved = result
 
         If result Then
             For i As Integer = 0 To m_Arguments.Length - 1
                 Dim value As Object = Nothing
                 If TypeOf m_Arguments(i) Is TypeReference Then Continue For
                 result = TypeConverter.ConvertTo(Me, m_Arguments(i), parameters(i).ParameterType, value, True)
                 If result Then m_Arguments(i) = value
             Next
             For i As Integer = 0 To m_FieldValues.Count - 1
                 Dim value As Object = Nothing
                 'TypeConverter.ConvertTo will report any errors
                 result = TypeConverter.ConvertTo(Me, m_FieldValues(i), m_Fields(i).FieldType, value, True)
                 If result Then m_FieldValues(i) = value
             Next
             For i As Integer = 0 To m_PropertyValues.Count - 1
                 Dim value As Object = Nothing
                 'TypeConverter.ConvertTo will report any errors
                 result = TypeConverter.ConvertTo(Me, m_PropertyValues(i), m_Properties(i).PropertyType, value, True)
                 If result Then m_PropertyValues(i) = value
             Next
         End If
 
         m_CecilBuilder = GetAttributeBuilderCecil()
 
         If m_IsAssembly Then
             Me.Compiler.AssemblyBuilderCecil.CustomAttributes.Add(CecilBuilder)
         ElseIf m_IsModule Then
             Me.Compiler.ModuleBuilderCecil.CustomAttributes.Add(CecilBuilder)
         Else
             Dim memberparent As IAttributableDeclaration = Me.FindFirstParent(Of IAttributableDeclaration)()
             If memberparent IsNot Nothing Then
                 Dim tp As TypeDeclaration = TryCast(memberparent, TypeDeclaration)
                 Dim mthd As IMethod = TryCast(memberparent, IMethod)
                 Dim ctro As IConstructorMember = TryCast(memberparent, IConstructorMember)
                 Dim fld As IFieldMember = TryCast(memberparent, IFieldMember)
                 Dim prop As PropertyDeclaration = TryCast(memberparent, PropertyDeclaration)
                 Dim param As Parameter = TryCast(memberparent, Parameter)
                 Dim evt As EventDeclaration = TryCast(memberparent, EventDeclaration)
 
                 If ctro IsNot Nothing Then mthd = Nothing
                 Helper.Assert(tp IsNot Nothing Xor mthd IsNot Nothing Xor ctro IsNot Nothing Xor fld IsNot Nothing Xor prop IsNot Nothing Xor param IsNot Nothing OrElse evt IsNot Nothing)
 
                 If tp IsNot Nothing Then
                     If Helper.CompareType(CecilBuilder.Constructor.DeclaringType, Compiler.TypeCache.System_SerializableAttribute) Then
                         tp.Serializable = True
                     ElseIf Helper.CompareType(CecilBuilder.Constructor.DeclaringType, Compiler.TypeCache.System_Runtime_InteropServices_StructLayoutAttribute) Then
                         Dim layout As System.Runtime.InteropServices.LayoutKind
                         layout = CType(CecilBuilder.ConstructorArguments(0).Value, System.Runtime.InteropServices.LayoutKind)
                         Select Case layout
                             Case Runtime.InteropServices.LayoutKind.Auto
                                 tp.CecilType.IsAutoLayout = True
                             Case Runtime.InteropServices.LayoutKind.Explicit
                                 tp.CecilType.IsExplicitLayout = True
                             Case Runtime.InteropServices.LayoutKind.Sequential
                                 tp.CecilType.IsSequentialLayout = True
                             Case Else
                                 Compiler.Report.ShowMessage(Messages.VBNC30127, Me.Location, CecilBuilder.Constructor.DeclaringType.FullName, "Invalid argument.")
                                 Return False
                         End Select
                     Else
                         tp.CecilType.CustomAttributes.Add(CecilBuilder)
                     End If
                 ElseIf mthd IsNot Nothing Then
                     If Helper.CompareType(CecilBuilder.Constructor.DeclaringType, Compiler.TypeCache.System_Runtime_InteropServices_DllImportAttribute) Then
                         Dim values As Mono.Collections.Generic.Collection(Of Mono.Cecil.CustomAttributeNamedArgument) = CecilBuilder.Fields
                         Dim modRef As Mono.Cecil.ModuleReference = Nothing
                         Dim modRefName As String = DirectCast(CecilBuilder.ConstructorArguments(0).Value, String)
                         Dim entry As String = Nothing
                         Dim charSetField As Nullable(Of Mono.Cecil.CustomAttributeNamedArgument) = Nothing
                         Dim entryPointField As Nullable(Of Mono.Cecil.CustomAttributeNamedArgument) = Nothing
                         Dim callingConventionField As Nullable(Of Mono.Cecil.CustomAttributeNamedArgument) = Nothing
                         Dim setLastErrorField As Nullable(Of Mono.Cecil.CustomAttributeNamedArgument) = Nothing
 
                         For i As Integer = 0 To values.Count - 1
                             If Helper.CompareNameOrdinal(values(i).Name, "CharSet") Then
                                 charSetField = values(i)
                             ElseIf Helper.CompareNameOrdinal(values(i).Name, "EntryPoint") Then
                                 entryPointField = values(i)
                                 entry = DirectCast(entryPointField.Value.Argument.Value, String)
                             ElseIf Helper.CompareNameOrdinal(values(i).Name, "CallingConvention") Then
                                 callingConventionField = values(i)
                             ElseIf Helper.CompareNameOrdinal(values(i).Name, "SetLastError") Then
                                 setLastErrorField = values(i)
                             End If
                         Next
 
                         If entry = String.Empty Then entry = mthd.Name
                         For i As Integer = 0 To Compiler.AssemblyBuilderCecil.MainModule.ModuleReferences.Count - 1
                             If Helper.CompareNameOrdinal(Compiler.AssemblyBuilderCecil.MainModule.ModuleReferences(i).Name, modRefName) Then
                                 modRef = Compiler.AssemblyBuilderCecil.MainModule.ModuleReferences(i)
                                 Exit For
                             End If
                         Next
                         If modRef Is Nothing Then
                             modRef = New Mono.Cecil.ModuleReference(modRefName)
                             Compiler.AssemblyBuilderCecil.MainModule.ModuleReferences.Add(modRef)
                         End If
                         mthd.CecilBuilder.PInvokeInfo = New Mono.Cecil.PInvokeInfo(0, entry, modRef)
 
                         Dim charset As System.Runtime.InteropServices.CharSet
                         If charSetField.HasValue Then
                             charset = DirectCast(charSetField.Value.Argument.Value, System.Runtime.InteropServices.CharSet)
                         Else
                             charset = Runtime.InteropServices.CharSet.Auto
                         End If
                         Select Case charset
                             Case Runtime.InteropServices.CharSet.Ansi
                                 mthd.CecilBuilder.PInvokeInfo.IsCharSetAnsi = True
                             Case Runtime.InteropServices.CharSet.Auto
                                 mthd.CecilBuilder.PInvokeInfo.IsCharSetAuto = True
                             Case Runtime.InteropServices.CharSet.None
                                 mthd.CecilBuilder.PInvokeInfo.IsCharSetNotSpec = True
                             Case Runtime.InteropServices.CharSet.Unicode
                                 mthd.CecilBuilder.PInvokeInfo.IsCharSetUnicode = True
                             Case Else
                                 result = Compiler.Report.ShowMessage(Messages.VBNC99999, Me.Location, "Invalid charset
                         End Select
 
                         Dim callingconv As System.Runtime.InteropServices.CallingConvention
                         If callingConventionField.HasValue Then
                             callingconv = DirectCast(callingConventionField.Value.Argument.Value, System.Runtime.InteropServices.CallingConvention)
                         Else
                             callingconv = Runtime.InteropServices.CallingConvention.Winapi
                         End If
                         Select Case callingconv
                             Case Runtime.InteropServices.CallingConvention.Cdecl
                                 mthd.CecilBuilder.PInvokeInfo.IsCallConvCdecl = True
                             Case Runtime.InteropServices.CallingConvention.FastCall
                                 mthd.CecilBuilder.PInvokeInfo.IsCallConvFastcall = True
                             Case Runtime.InteropServices.CallingConvention.StdCall
                                 mthd.CecilBuilder.PInvokeInfo.IsCallConvStdCall = True
                             Case Runtime.InteropServices.CallingConvention.ThisCall
                                 mthd.CecilBuilder.PInvokeInfo.IsCallConvThiscall = True
                             Case Runtime.InteropServices.CallingConvention.Winapi
                                 mthd.CecilBuilder.PInvokeInfo.IsCallConvWinapi = True
                             Case Else
                                 result = Compiler.Report.ShowMessage(Messages.VBNC99999, Me.Location, "Invalid calling convention
                         End Select
 
                         Dim setlasterror As Boolean = True
                         If setLastErrorField.HasValue Then
                             setlasterror = DirectCast(setLastErrorField.Value.Argument.Value, Boolean)
                         End If
                         mthd.CecilBuilder.PInvokeInfo.SupportsLastError = setlasterror
                         mthd.CecilBuilder.PInvokeInfo.IsNoMangle = True
                     Else
                         mthd.CecilBuilder.CustomAttributes.Add(CecilBuilder)
                     End If
                 ElseIf ctro IsNot Nothing Then
                     ctro.CecilBuilder.CustomAttributes.Add(CecilBuilder)
                 ElseIf fld IsNot Nothing Then
                     If Helper.CompareType(CecilBuilder.Constructor.DeclaringType, Compiler.TypeCache.System_Runtime_InteropServices_MarshalAsAttribute) Then
                         fld.FieldBuilder.MarshalInfo = New MarshalInfo(CType(CecilBuilder.ConstructorArguments(0).Value, Mono.Cecil.NativeType))
                         fld.FieldBuilder.Attributes = fld.FieldBuilder.Attributes Or Mono.Cecil.FieldAttributes.HasFieldMarshal
                     ElseIf Helper.CompareType(CecilBuilder.Constructor.DeclaringType, Compiler.TypeCache.System_Runtime_InteropServices_FieldOffsetAttribute) Then
                         fld.FieldBuilder.Offset = CType(CecilBuilder.ConstructorArguments(0).Value, Integer)
                     Else
                         fld.FieldBuilder.CustomAttributes.Add(CecilBuilder)
                     End If
                 ElseIf prop IsNot Nothing Then
                     prop.CecilBuilder.CustomAttributes.Add(CecilBuilder)
                 ElseIf param IsNot Nothing Then
                     If Helper.CompareType(CecilBuilder.Constructor.DeclaringType, Compiler.TypeCache.System_Runtime_InteropServices_OutAttribute) Then
                         param.CecilBuilder.IsOut = True
                     ElseIf Helper.CompareType(CecilBuilder.Constructor.DeclaringType, Compiler.TypeCache.System_Runtime_InteropServices_MarshalAsAttribute) Then
                         param.CecilBuilder.MarshalInfo = New MarshalInfo(CType(CecilBuilder.ConstructorArguments(0).Value, Mono.Cecil.NativeType))
                         param.CecilBuilder.Attributes = param.CecilBuilder.Attributes Or Mono.Cecil.ParameterAttributes.HasFieldMarshal
                     Else
                         param.CecilBuilder.CustomAttributes.Add(CecilBuilder)
                     End If
                 ElseIf evt IsNot Nothing Then
                     evt.CecilBuilder.CustomAttributes.Add(CecilBuilder)
                 Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                 End If
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
             End If
         End If
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Parser\ParsedObject.vb" startline="2682" endline="2976">
<![CDATA[
 
     Private Function ParseCodeBlock(ByVal Parent As ParsedObject, ByVal IsOneLiner As Boolean) As CodeBlock
         Dim result As New CodeBlock(Parent)
         Dim breakloop As Boolean
 
         Do
             If IsOneLiner = False AndAlso LabelDeclarationStatement.CanBeMe(tm) Then
                 Dim newLabel As LabelDeclarationStatement
                 newLabel = ParseLabelDeclarationStatement(result)
                 If newLabel Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 result.AddStatement(newLabel)
                 result.AddLabel(newLabel)
             ElseIf MidAssignStatement.IsMe(tm) Then
                 Dim newMidAssign As MidAssignStatement
                 newMidAssign = ParseMidAssignmentStatement(result, IsOneLiner)
                 If newMidAssign Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 result.AddStatement(newMidAssign)
             ElseIf tm.CurrentToken.IsIdentifier OrElse _
               tm.CurrentToken.Equals(KS.Dot, KS.Me, KS.MyClass, KS.MyBase) OrElse _
               tm.CurrentToken.Equals(Enums.BuiltInTypeTypeNames) OrElse _
               tm.CurrentToken.Equals(KS.Global) OrElse _
               tm.CurrentToken.Equals(KS.DirectCast, KS.TryCast, KS.CType) OrElse _
               tm.CurrentToken.Equals(KS.GetType) Then
                 'Must appear after the label check.
                 'Must appear before the symbol check.
                 'Must appear before the keywords check
                 Dim lside, rside As Expression
 
                 lside = ParseExpression(New ExpressionParseInfo(result, True, False))
                 If lside Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                 If tm.CurrentToken.IsSymbol Then
                     Select Case tm.CurrentToken.Symbol
                         Case KS.Equals
                             tm.NextToken()
                             tm.AcceptNewLine()
                             Dim newStmt As New AssignmentStatement(result)
                             rside = ParseExpression(New ExpressionParseInfo(newStmt, False, False))
                             If rside Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                             newStmt.Init(lside, rside)
                             result.AddStatement(newStmt)
                         Case KS.AddAssign
                             tm.NextToken()
                             tm.AcceptNewLine()
                             Dim newStmt As New AddAssignStatement(result)
                             rside = ParseExpression(New ExpressionParseInfo(newStmt, False, False))
                             If rside Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                             newStmt.Init(lside, rside)
                             result.AddStatement(newStmt)
                         Case KS.ConcatAssign
                             tm.NextToken()
                             tm.AcceptNewLine()
                             Dim newStmt As New ConcatAssignStatement(result)
                             rside = ParseExpression(New ExpressionParseInfo(newStmt, False, False))
                             If rside Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                             newStmt.Init(lside, rside)
                             result.AddStatement(newStmt)
                         Case KS.RealDivAssign
                             tm.NextToken()
                             tm.AcceptNewLine()
                             Dim newStmt As New DivisionAssignStatement(result)
                             rside = ParseExpression(New ExpressionParseInfo(newStmt, False, False))
                             If rside Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                             newStmt.Init(lside, rside)
                             result.AddStatement(newStmt)
                         Case KS.IntDivAssign
                             tm.NextToken()
                             tm.AcceptNewLine()
                             Dim newStmt As New IntDivisionAssignStatement(result)
                             rside = ParseExpression(New ExpressionParseInfo(newStmt, False, False))
                             If rside Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                             newStmt.Init(lside, rside)
                             result.AddStatement(newStmt)
                         Case KS.MultAssign
                             tm.NextToken()
                             tm.AcceptNewLine()
                             Dim newStmt As New MultiplicationAssignStatement(result)
                             rside = ParseExpression(New ExpressionParseInfo(newStmt, False, False))
                             If rside Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                             newStmt.Init(lside, rside)
                             result.AddStatement(newStmt)
                         Case KS.PowerAssign
                             tm.NextToken()
                             tm.AcceptNewLine()
                             Dim newStmt As New PowerAssignStatement(result)
                             rside = ParseExpression(New ExpressionParseInfo(newStmt, False, False))
                             If rside Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                             newStmt.Init(lside, rside)
                             result.AddStatement(newStmt)
                         Case KS.ShiftRightAssign
                             tm.NextToken()
                             tm.AcceptNewLine()
                             Dim newStmt As New RShiftAssignStatement(result)
                             rside = ParseExpression(New ExpressionParseInfo(newStmt, False, False))
                             If rside Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                             newStmt.Init(lside, rside)
                             result.AddStatement(newStmt)
                         Case KS.ShiftLeftAssign
                             tm.NextToken()
                             tm.AcceptNewLine()
                             Dim newStmt As New LShiftAssignStatement(result)
                             rside = ParseExpression(New ExpressionParseInfo(newStmt, False, False))
                             If rside Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                             newStmt.Init(lside, rside)
                             result.AddStatement(newStmt)
                         Case KS.MinusAssign
                             tm.NextToken()
                             tm.AcceptNewLine()
                             Dim newStmt As New SubtractionAssignStatement(result)
                             rside = ParseExpression(New ExpressionParseInfo(newStmt, False, False))
                             If rside Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                             newStmt.Init(lside, rside)
                             result.AddStatement(newStmt)
                         Case Else
                             Dim newStmt As New CallStatement(result)
                             newStmt.Init(lside)
                             result.AddStatement(newStmt)
                     End Select
                 Else
                     Dim newStmt As New CallStatement(result)
                     newStmt.Init(lside)
                     result.AddStatement(newStmt)
                 End If
             ElseIf tm.CurrentToken.IsKeyword Then
                 Select Case tm.CurrentToken.Keyword
                     Case KS.Dim, KS.Static, KS.Const
                         Dim newVariables As Generic.List(Of LocalVariableDeclaration)
                         newVariables = ParseLocalDeclarationStatement(result)
                         If newVariables Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddVariables(newVariables)
                     Case KS.SyncLock
                         Dim newLock As SyncLockStatement
                         newLock = ParseSyncLockStatement(result, IsOneLiner)
                         If newLock Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newLock)
                     Case KS.Try
                         Dim newTry As TryStatement
                         newTry = ParseTryStatement(result, IsOneLiner)
                         If newTry Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newTry)
                     Case KS.Throw
                         Dim newThrow As ThrowStatement
                         newThrow = ParseThrowStatement(result)
                         If newThrow Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newThrow)
                     Case KS.With
                         Dim newWith As WithStatement
                         newWith = ParseWithStatement(result, IsOneLiner)
                         If newWith Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newWith)
                     Case KS.Select
                         Dim newSelect As SelectStatement
                         newSelect = ParseSelectStatement(result, IsOneLiner)
                         If newSelect Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newSelect)
                     Case KS.If
                         Dim newIf As IfStatement
                         newIf = ParseIfStatement(result, IsOneLiner)
                         If newIf Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newIf)
                     Case KS.Do
                         Dim newDo As DoStatement
                         newDo = ParseDoStatement(result, IsOneLiner)
                         If newDo Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newDo)
                     Case KS.Stop
                         Dim newStop As StopStatement
                         newStop = ParseStopStatement(result)
                         If newStop Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newStop)
                     Case KS.End
                         Dim newEnd As EndStatement
                         If tm.PeekToken.IsEndOfStatement() Then
                             newEnd = ParseEndStatement(result)
                             If newEnd Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                             result.AddStatement(newEnd)
                         Else
                             breakloop = True
                         End If
                     Case KS.While
                         Dim newWhile As WhileStatement
                         newWhile = ParseWhileStatement(result, IsOneLiner)
                         If newWhile Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newWhile)
                     Case KS.Exit
                         Dim newExit As ExitStatement
                         newExit = ParseExitStatement(result)
                         If newExit Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newExit)
                     Case KS.Return
                         Dim newReturn As ReturnStatement
                         newReturn = ParseReturnStatement(result)
                         If newReturn Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newReturn)
                     Case KS.For
                         If tm.PeekToken.Equals(KS.Each) Then
                             Dim newFor As ForEachStatement
                             newFor = ParseForEachStatement(result, IsOneLiner)
                             If newFor Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                             result.AddStatement(newFor)
                         Else
                             Dim newFor As ForStatement
                             newFor = ParseForStatement(result, IsOneLiner)
                             If newFor Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                             result.AddStatement(newFor)
                         End If
                     Case KS.Continue
                         Dim newContinue As ContinueStatement
                         newContinue = ParseContinueStatement(result, IsOneLiner)
                         If newContinue Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newContinue)
                     Case KS.GoTo
                         Dim newGoto As GotoStatement
                         newGoto = ParseGotoStatement(result)
                         If newGoto Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newGoto)
                     Case KS.On
                         Dim newOnError As OnErrorStatement
                         newOnError = ParseOnErrorStatement(result)
                         If newOnError Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newOnError)
                     Case KS.Error
                         Dim newError As ErrorStatement
                         newError = ParseErrorStatement(result)
                         If newError Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newError)
                     Case KS.AddHandler, KS.RemoveHandler
                         Dim newAddHandler As AddOrRemoveHandlerStatement
                         newAddHandler = ParseAddOrRemoveHandlerStatement(result)
                         If newAddHandler Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newAddHandler)
                     Case KS.RaiseEvent
                         Dim newRaiseEvent As RaiseEventStatement
                         newRaiseEvent = ParseRaiseEventStatement(result)
                         If newRaiseEvent Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newRaiseEvent)
                     Case KS.Call
                         Dim newCall As CallStatement
                         newCall = ParseCallStatement(result)
                         If newCall Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newCall)
                     Case KS.Erase
                         Dim newErase As EraseStatement
                         newErase = ParseEraseStatement(result)
                         If newErase Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newErase)
                     Case KS.ReDim
                         Dim newReDim As ReDimStatement
                         newReDim = ParseReDimStatement(result)
                         If newReDim Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newReDim)
                     Case KS.Resume
                         Dim newResume As ResumeStatement
                         newResume = ParseResumeStatement(result)
                         If newResume Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newResume)
                     Case KS.Using
                         Dim newUsing As UsingStatement
                         newUsing = ParseUsingStatement(result, IsOneLiner)
                         If newUsing Is Nothing Then Helper.ErrorRecoveryNotImplemented(tm.CurrentLocation)
                         result.AddStatement(newUsing)
                     Case Else
                         breakloop = True
                 End Select
             ElseIf tm.CurrentToken.Equals(KS.Colon) Then
                 'tm.NextToken()
             Else
                 breakloop = True
             End If
 
             If breakloop = False Then
                 If IsOneLiner Then
                     If tm.Accept(KS.Colon) = False Then
                         breakloop = True
                     End If
                 Else
                     If tm.AcceptEndOfStatement(False, Compiler.Report.Errors = 0) = False Then
                         Return result
                     End If
                 End If
             End If
 
             If result.FirstStatement Is Nothing AndAlso breakloop = False Then
                 If result.Statements.Count = 1 Then
                     result.FirstStatement = result.Statements(0)
                     'ElseIf result.Variables.Count >= 1 Then
                     'result.FirstStatement = result.Variables(0)
                 ElseIf result.Statements.Count > 1 Then 'OrElse result.Variables.Count > 1 Then
                     Throw New InternalException(result)
                 Else
                     'Do nothing. No statements were parsed.
                 End If
             End If
         Loop Until breakloop = True
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\TypeDeclarations\ClassDeclaration.vb" startline="266" endline="543">
<![CDATA[
 
     Public Function CreateMyGroupMembers() As Boolean
         Dim result As Boolean = True
 
         If Me.CustomAttributes Is Nothing Then Return result
 
         Dim attrib As Attribute
         Dim attribs As Generic.List(Of Attribute)
 
         attribs = Me.CustomAttributes.FindAttributes(Compiler.TypeCache.MS_VB_MyGroupCollectionAttribute)
 
         If attribs Is Nothing Then Return result
         If attribs.Count <> 1 Then Return result
 
         attrib = attribs(0)
 
         Dim groupData As New MyGroupData
         Dim typeToCollect As String
         Dim createInstanceMethodName As String
         Dim disposeInstanceMethodName As String
         Dim defaultInstanceAlias As String
 
         If Not attrib.ResolveCode(ResolveInfo.Default(Compiler)) Then
             'The attribute is not instantiated correctly, this will cause an error on the attribute
             'no need to show more errors here.
             Return result
         End If
 
         'Check the number of arguments and their types
         'There should be 4 string arguments, if not there's something wrong with
         'the MyGroupCollectionAttribute (won't reach here if the code is wrong
         'because we resolve the attribute first)
         'It's also safe to index the arguments, since attributes can't have named constructor parameters.
         Dim args As Object() = attrib.Arguments
         If args Is Nothing OrElse args.Length <> 4 Then
             Throw New InternalException("Weird MyGroupCollectionAttribute, should have 4 arguments.")
         Else
             For Each arg As Object In args
                 If arg Is Nothing Then Continue For
                 If TypeOf arg Is String Then Continue For
                 Throw New InternalException("Weird MyGroupCollectionAttribute, non-string argument?")
             Next
         End If
         typeToCollect = DirectCast(args(0), String)
         createInstanceMethodName = DirectCast(args(1), String)
         disposeInstanceMethodName = DirectCast(args(2), String)
         defaultInstanceAlias = DirectCast(args(3), String)
 
         If typeToCollect = String.Empty Then Return result
         If createInstanceMethodName = String.Empty Then Return result
         If disposeInstanceMethodName = String.Empty Then Return result
 
         Dim collectType As Mono.Cecil.TypeReference
         Dim foundTypes As Generic.List(Of Mono.Cecil.TypeReference)
         foundTypes = Compiler.TypeManager.GetType(typeToCollect, False)
         If foundTypes.Count <> 1 Then
             Return result
         End If
         collectType = foundTypes(0)
         groupData.TypeToCollect = collectType
 
         For Each mi As MethodDeclaration In Members.GetSpecificMembers(Of MethodDeclaration)()
             If mi.IsShared AndAlso Helper.CompareName(createInstanceMethodName, mi.Name) Then
                 If mi.Signature.Parameters.Count <> 1 Then Continue For
                 If mi.Signature.TypeParameters Is Nothing OrElse mi.Signature.TypeParameters.Parameters.Count <> 1 Then Continue For
                 If mi.Signature.ReturnType Is Nothing Then Continue For
 
                 Dim T As TypeParameter = mi.Signature.TypeParameters.Parameters(0)
                 If T.TypeParameterConstraints Is Nothing Then Continue For
 
                 Dim constraints As ConstraintList = T.TypeParameterConstraints.Constraints
                 If constraints.Count <> 2 Then Continue For
 
                 If Not (constraints(0).Special = KS.[New] OrElse constraints(1).Special = KS.[New]) Then Continue For
 
                 Dim tn As TypeName
                 tn = constraints(0).TypeName
                 If tn Is Nothing Then tn = constraints(1).TypeName
                 If tn Is Nothing Then Continue For
                 If Not Helper.CompareType(tn.ResolvedType, groupData.TypeToCollect) Then Continue For
 
                 If Helper.CompareType(mi.Signature.Parameters(0).ParameterType, T.CecilBuilder) = False Then Continue For
                 If Helper.CompareType(mi.Signature.ReturnType, T.CecilBuilder) = False Then Continue For
 
 
                 If groupData.CreateInstanceMethod IsNot Nothing Then Continue For
                 groupData.CreateInstanceMethod = mi.CecilBuilder
             ElseIf mi.IsShared = False AndAlso Helper.CompareName(disposeInstanceMethodName, mi.Name) Then
                 If mi.Signature.Parameters.Count <> 1 Then Continue For
                 If mi.Signature.TypeParameters Is Nothing OrElse mi.Signature.TypeParameters.Parameters.Count <> 1 Then Continue For
                 If mi.Signature.ReturnType IsNot Nothing AndAlso Helper.CompareType(mi.Signature.ReturnType, Compiler.TypeCache.System_Void) = False Then Continue For
 
                 Dim T As TypeParameter = mi.Signature.TypeParameters.Parameters(0)
                 'SPECBUG
                 'https
                 If T.TypeParameterConstraints Is Nothing OrElse T.TypeParameterConstraints.Constraints Is Nothing OrElse T.TypeParameterConstraints.Constraints.Count <> 1 Then Continue For
                 If Not Helper.CompareType(T.TypeParameterConstraints.Constraints(0).TypeName.ResolvedType, groupData.TypeToCollect) Then Continue For
 
                 If Helper.CompareType(mi.Signature.Parameters(0).ParameterType, Compiler.TypeManager.MakeByRefType(Me, T.CecilBuilder)) = False Then Continue For
 
                 If groupData.DisposeInstanceMethod IsNot Nothing Then Continue For
                 groupData.DisposeInstanceMethod = mi.CecilBuilder
             End If
             If groupData.DisposeInstanceMethod IsNot Nothing AndAlso groupData.CreateInstanceMethod IsNot Nothing Then Exit For
         Next
 
         If groupData.CreateInstanceMethod Is Nothing Then Return result
         If groupData.DisposeInstanceMethod Is Nothing Then Return result
 
         If Compiler.Assembly.GroupedClasses Is Nothing Then Compiler.Assembly.GroupedClasses = New Generic.List(Of MyGroupData)
         Compiler.Assembly.GroupedClasses.Add(groupData)
 
         'Parse the alias
         If defaultInstanceAlias <> String.Empty Then
             Dim scanner As New Scanner(Compiler, defaultInstanceAlias)
             Dim parser As New Parser(Compiler, scanner)
             Dim alias_exp As Expression
             'TODO
             alias_exp = parser.ParseExpression(Me)
 
             If alias_exp IsNot Nothing Then
                 Dim alias_result As Boolean
                 alias_result = alias_exp.ResolveExpression(New ResolveInfo(Compiler))
                 If alias_result Then
                     groupData.DefaultInstanceAlias = alias_exp
                 End If
             End If
         End If
 
 
         'Find all non-generic types that inherit from the type to collect
         Dim typesCollected As New Generic.List(Of TypeDeclaration)
         Dim namesUsed As New Generic.Dictionary(Of String, Object)(Helper.StringComparer)
         Dim namesClashed As New Generic.Dictionary(Of String, Object)(Helper.StringComparer)
         For Each type As TypeDeclaration In Compiler.theAss.Types
             Dim classType As ClassDeclaration = TryCast(type, ClassDeclaration)
 
             If classType Is Nothing Then Continue For
             If classType.TypeParameters IsNot Nothing AndAlso classType.TypeParameters.Parameters.Count > 0 Then Continue For
 
             If Helper.IsSubclassOf(collectType, type.CecilType) Then
                 typesCollected.Add(type)
                 If namesUsed.ContainsKey(type.Name) Then
                     namesClashed.Add(type.Name, Nothing)
                 Else
                     namesUsed.Add(type.Name, Nothing)
                 End If
             End If
         Next
 
         For Each type As TypeDeclaration In typesCollected
             Dim propertyName As String
             Dim fieldName As String
 
             If namesClashed.ContainsKey(type.Name) Then
                 propertyName = type.FullName.Replace(".", "_")
             Else
                 propertyName = type.Name
             End If
             fieldName = "m_" & propertyName
 
             Dim field As New TypeVariableDeclaration(Me)
             Dim prop As New PropertyDeclaration(Me)
             Dim modifiers As New Modifiers(ModifierMasks.Public)
 
             field.Init(modifiers, fieldName, type.CecilType)
             prop.Init(modifiers, propertyName, type.CecilType)
 
             type.MyGroupField = field
 
             Dim setter As MethodDeclaration
             Dim getter As MethodDeclaration
 
             getter = prop.GetDeclaration
             setter = prop.SetDeclaration
 
             getter.Code = New CodeBlock(getter)
             setter.Code = New CodeBlock(setter)
 
             Dim get_1 As New AssignmentStatement(getter.Code)
             Dim get_1_left As New SimpleNameExpression(get_1)
             Dim get_1_right As New InvocationOrIndexExpression(get_1)
             Dim get_1_right_instance_exp As New SimpleNameExpression(get_1_right)
             Dim get_1_right_instance_exp_typeargs As New TypeArgumentList(get_1_right_instance_exp)
             Dim get_1_right_instance_exp_typeargs_1 As New TypeName(get_1_right_instance_exp_typeargs)
             Dim get_1_right_arg1 As New SimpleNameExpression(get_1_right)
             Dim get_1_right_arglist As New ArgumentList(get_1_right, get_1_right_arg1)
             Dim get_1_right_field_token As Identifier = New Identifier(get_1_right, fieldName, attrib.Location, TypeCharacters.Characters.None)
             Dim get_1_right_method_token As Identifier = New Identifier(get_1_right, createInstanceMethodName, attrib.Location, TypeCharacters.Characters.None)
 
             get_1_left.Init(get_1_right_field_token, Nothing)
 
             get_1_right_instance_exp_typeargs_1.Init(type.CecilType)
             get_1_right_instance_exp_typeargs.Add(get_1_right_instance_exp_typeargs_1)
             get_1_right_instance_exp.Init(get_1_right_method_token, get_1_right_instance_exp_typeargs)
             get_1_right_arg1.Init(get_1_right_field_token, Nothing)
             get_1_right.Init(get_1_right_instance_exp, get_1_right_arglist)
             get_1.Init(get_1_left, get_1_right)
 
             Dim get_2 As New ReturnStatement(getter.Code)
             Dim get_2_exp As New SimpleNameExpression(get_2)
             get_2_exp.Init(get_1_right_field_token, Nothing)
             get_2.Init(get_2_exp)
 
             getter.Code.AddStatement(get_1)
             getter.Code.AddStatement(get_2)
 
             Dim set_if1 As New IfStatement(setter.Code)
             Dim value_token As Identifier = New Identifier(set_if1, "Value", attrib.Location, TypeCharacters.Characters.None)
             Dim field_token As Identifier = New Identifier(set_if1, fieldName, attrib.Location, TypeCharacters.Characters.None)
             Dim set_if1_condition_left As New SimpleNameExpression(set_if1)
             Dim set_if1_condition_right As New SimpleNameExpression(set_if1)
             Dim set_if1_condition As New Is_IsNotExpression(set_if1, set_if1_condition_left, set_if1_condition_right, KS.IsNot)
             Dim set_if1_code As New CodeBlock(set_if1)
             Dim set_if2 As New IfStatement(set_if1)
             Dim set_if2_condition_right As New NothingConstantExpression(set_if2)
             Dim set_if2_condition As New Is_IsNotExpression(set_if2, set_if1_condition_left, set_if2_condition_right, KS.IsNot)
             Dim set_if2_code As New CodeBlock(set_if2)
             Dim set_throw As New ThrowStatement(set_if2_code)
             Dim set_throw_creation As New DelegateOrObjectCreationExpression(set_throw)
             Dim set_throw_arg1 As New ConstantExpression(set_throw_creation, "Property can only be set to Nothing", Compiler.TypeCache.System_String)
             Dim set_throw_args As New ArgumentList(set_throw_creation, set_throw_arg1)
             Dim set_dispose As New CallStatement(set_if1)
             Dim set_dispose_invocation As New InvocationOrIndexExpression(set_dispose)
             Dim set_dispose_invocation_instance_exp As New SimpleNameExpression(set_dispose_invocation)
             Dim set_dispose_invocation_instance_exp_typeargs As New TypeArgumentList(set_dispose_invocation_instance_exp)
             Dim set_dispose_invocation_instance_exp_typeargs_1 As New TypeName(set_dispose_invocation_instance_exp_typeargs)
             Dim set_dispose_invocation_arg1 As New SimpleNameExpression(set_dispose_invocation)
             Dim set_dispose_invocation_arglist As New ArgumentList(set_dispose_invocation, set_dispose_invocation_arg1)
             Dim set_dispose_invocation_field_token As Identifier = New Identifier(set_dispose_invocation, fieldName, attrib.Location, TypeCharacters.Characters.None)
             Dim set_dispose_invocation_method_token As Identifier = New Identifier(set_dispose_invocation, disposeInstanceMethodName, attrib.Location, TypeCharacters.Characters.None)
 
             set_throw_creation.Init(Compiler.TypeCache.System_ArgumentException, set_throw_args)
             set_throw.Init(set_throw_creation)
 
             set_if2_code.AddStatement(set_throw)
 
             set_dispose_invocation_instance_exp_typeargs_1.Init(type.CecilType)
             set_dispose_invocation_instance_exp_typeargs.Add(set_dispose_invocation_instance_exp_typeargs_1)
             set_dispose_invocation_instance_exp.Init(set_dispose_invocation_method_token, set_dispose_invocation_instance_exp_typeargs)
             set_dispose_invocation_arg1.Init(set_dispose_invocation_field_token, Nothing)
             set_dispose_invocation.Init(set_dispose_invocation_instance_exp, set_dispose_invocation_arglist)
             set_dispose.Init(set_dispose_invocation)
 
             set_if1_code.AddStatement(set_if2)
             set_if1_code.AddStatement(set_dispose)
 
             set_if1_condition_left.Init(value_token, Nothing)
             set_if1_condition_right.Init(field_token, Nothing)
 
             set_if1.Init(set_if1_condition, Nothing, set_if1_code, False, Nothing)
             set_if2.Init(set_if2_condition, Nothing, set_if2_code, False, Nothing)
 
             setter.Code.AddStatement(set_if1)
 
             Members.Add(field)
             Members.Add(prop)
 
             result = field.CreateDefinition AndAlso result
             result = prop.CreateDefinition AndAlso result
 
             result = setter.ResolveTypeReferences AndAlso result
             result = getter.ResolveTypeReferences AndAlso result
 
             'Me.TypeDescriptor.ClearCache()
 
             If Compiler.TypeManager.ContainsCache(Me.CecilType) Then
                 Dim cache As MemberCache = Compiler.TypeManager.GetCache(Me.CecilType)
                 'cache.Cache.Add(New MemberCacheEntry(field.FieldDescriptor))
                 'cache.Cache.Add(New MemberCacheEntry(prop.MemberDescriptor))
                 'cache.FlattenedCache.Add(New MemberCacheEntry(field.FieldDescriptor))
                 'cache.FlattenedCache.Add(New MemberCacheEntry(prop.MemberDescriptor))
                 cache.ClearAll()
             End If
         Next
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\ConditionalCompilation\ConditionalConstants.vb" startline="523" endline="824">
<![CDATA[
 
     ''' <summary>
     ''' Convert the value on the stack to ToType.
     ''' </summary>
     ''' <param name="ToType"></param>
     ''' <remarks></remarks>
     Shared Sub EmitConversion(ByVal FromType As Mono.Cecil.TypeReference, ByVal ToType As Mono.Cecil.TypeReference, ByVal Info As EmitInfo)
         Dim ToTypeOriginal, FromTypeOriginal As Mono.Cecil.TypeReference
 
         If Helper.CompareType(FromType, Info.Compiler.TypeCache.Nothing) Then Return
 
         ToTypeOriginal = ToType
         ToType = Helper.GetTypeOrTypeBuilder(Info.Compiler, ToType)
 
         'Dim FromType As Type = Info.Stack.Peek
         Dim FromTP, ToTP As TypeCode
         Dim converted As Boolean = False
 
         FromTypeOriginal = FromType
         FromType = Helper.GetTypeOrTypeBuilder(Info.Compiler, FromType)
 
         FromTP = Helper.GetTypeCode(Info.Compiler, FromType)
         ToTP = Helper.GetTypeCode(Info.Compiler, ToType)
 
 #If DEBUGIMPLICITCONVERSION Then
                     		If FromTP <> ToTP OrElse FromTP = TypeCode.Object OrElse ToTP = TypeCode.Object Then
                     			Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, String.Format("Converting from '{0}' to '{1}'.", FromTP.ToString, ToTP.ToString))
                     		End If
 #End If
 
         If ToTP = TypeCode.Object AndAlso FromTP <> TypeCode.Object AndAlso Helper.CompareType(ToType, Info.Compiler.TypeCache.System_Object) = False Then
             EmitValueTypeToObjectConversion(Info, FromType, ToType)
             Return
         End If
 
         Dim Switch As TypeCombinations = Helper.GetCombination(FromTP, ToTP)
 
         Select Case Switch
             Case TypeCombinations.Boolean_Boolean, _
              TypeCombinations.Byte_Byte, _
               TypeCombinations.Char_Char, _
                TypeCombinations.DateTime_DateTime, _
                 TypeCombinations.Decimal_Decimal, _
                  TypeCombinations.Double_Double, _
                   TypeCombinations.Empty_Empty, _
                    TypeCombinations.Int16_Int16, _
                     TypeCombinations.Int32_Int32, _
                      TypeCombinations.Int64_Int64, _
                        TypeCombinations.SByte_SByte, _
                         TypeCombinations.Single_Single, _
                          TypeCombinations.String_String, _
                           TypeCombinations.UInt16_UInt16, _
                            TypeCombinations.UInt32_UInt32, _
                             TypeCombinations.UInt64_UInt64
                 Return 'Nothing to convert, both types are equal
             Case TypeCombinations.Object_Object
                 Dim tmpTo, tmpFrom As Mono.Cecil.TypeReference
                 If Info.IsExplicitConversion = False Then
                     'If TypeOf FromType Is TypeDescriptor Then
                     '    tmpFrom = DirectCast(FromType, TypeDescriptor).TypeInReflection
                     'Else
                     '    tmpFrom = FromType
                     'End If
                     tmpFrom = FromTypeOriginal
                     'If TypeOf ToTypeIn Is TypeDescriptor Then
                     '    tmpTo = DirectCast(ToType, TypeDescriptor).TypeInReflection
                     'Else
                     tmpTo = ToTypeOriginal
                     '               End If
                     If Helper.CompareType(tmpTo, tmpFrom) Then
                         converted = True
                     ElseIf Helper.IsAssignable(Info.Context, tmpFrom, tmpTo) Then
                         converted = True
                     Else
                         converted = True
                         Info.Compiler.Report.WriteLine(Report.ReportLevels.Debug, "The compiler supposes a conversion from " & tmpFrom.Name & " to " & tmpTo.Name & " is valid.")
                     End If
                 Else
                     Info.ILGen.Emit(OpCodes.Castclass, ToType)
                     'Emitter.EmitCastClass(Info, FromType, ToType)
                     converted = True
                 End If
                 ' ToSByte conversions
             Case TypeCombinations.Byte_SByte
                 If Info.IsExplicitConversion Then
                     If Info.IntegerOverflowChecks Then
                         Info.ILGen.Emit(OpCodes.Conv_Ovf_I1_Un) 
                     Else
                         Info.ILGen.Emit(OpCodes.Conv_I1)
                     End If
                 Else
                     Helper.Stop()
                 End If
             Case TypeCombinations.Int16_SByte
             Case TypeCombinations.UInt16_SByte
             Case TypeCombinations.Int32_SByte
                 If Info.IsExplicitConversion Then
                     If Info.IntegerOverflowChecks Then
                         Info.ILGen.Emit(OpCodes.Conv_Ovf_I1) 
                     Else
                         Info.ILGen.Emit(OpCodes.Conv_I1) 
                     End If
                 Else
                     Helper.Stop()
                 End If
             Case TypeCombinations.UInt32_SByte
             Case TypeCombinations.Int64_SByte
             Case TypeCombinations.UInt64_SByte
             Case TypeCombinations.Single_SByte
             Case TypeCombinations.Double_SByte
             Case TypeCombinations.Decimal_SByte
 
                 'ToByte conversions
             Case TypeCombinations.SByte_Byte, _
               TypeCombinations.Int16_Byte, _
               TypeCombinations.Int32_Byte, _
               TypeCombinations.Int64_Byte
                 If Info.IsExplicitConversion Then
                     If Info.IntegerOverflowChecks Then
                         Info.ILGen.Emit(OpCodes.Conv_Ovf_U1) 
                     Else
                         Info.ILGen.Emit(OpCodes.Conv_U1) 
                     End If
                 Else
                     Helper.Stop()
                 End If
             Case TypeCombinations.UInt16_Byte
             Case TypeCombinations.UInt32_Byte
             Case TypeCombinations.UInt64_Byte
             Case TypeCombinations.Single_Byte
             Case TypeCombinations.Double_Byte
             Case TypeCombinations.Decimal_Byte
 
                 'ToUInt64 conversions
             Case TypeCombinations.Byte_UInt16
                 Info.ILGen.Emit(OpCodes.Conv_U2)
                 converted = True
 
                 'ToInt16 conversions
             Case TypeCombinations.Byte_Int16, _
              TypeCombinations.SByte_Int16
                 Info.ILGen.Emit(OpCodes.Conv_I2)
                 converted = True
 
 
                 'ToUInt32 conversions
             Case TypeCombinations.Byte_UInt32, _
                TypeCombinations.UInt16_UInt32
                 Info.ILGen.Emit(OpCodes.Conv_U4)
                 converted = True
 
                 'ToInt32 conversions
             Case TypeCombinations.SByte_Int32, _
                  TypeCombinations.Byte_Int32, _
                  TypeCombinations.UInt16_Int32, _
                  TypeCombinations.Int16_Int32
                 Info.ILGen.Emit(OpCodes.Conv_I4)
                 converted = True
             Case TypeCombinations.Object_Int32
                 'Narrowing conversion
                 If Info.IsExplicitConversion = False Then
                     Helper.AddError(Info.Context)
                 Else
                     Emitter.EmitUnbox(Info, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Int32))
                     Emitter.EmitLdobj(Info, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Int32))
                     converted = True
                 End If
 
                 'ToInt64 conversions
             Case TypeCombinations.Byte_Int64, _
               TypeCombinations.SByte_Int64, _
                TypeCombinations.UInt16_Int64, _
                 TypeCombinations.Int16_Int64, _
                  TypeCombinations.UInt32_Int64, _
                   TypeCombinations.Int32_Int64
                 Info.ILGen.Emit(OpCodes.Conv_I8)
                 converted = True
 
                 'ToUInt64 conversions
             Case TypeCombinations.Byte_UInt64, _
                   TypeCombinations.UInt16_UInt64, _
                    TypeCombinations.UInt32_UInt64
                 Info.ILGen.Emit(OpCodes.Conv_U8)
                 converted = True
 
                 'ToSingle conversions
             Case TypeCombinations.SByte_Single, _
                   TypeCombinations.Byte_Single, _
                    TypeCombinations.UInt16_Single, _
                     TypeCombinations.Int16_Single, _
                      TypeCombinations.UInt32_Single, _
                       TypeCombinations.Int32_Single, _
                        TypeCombinations.UInt64_Single, _
                         TypeCombinations.Int64_Single
                 Info.ILGen.Emit(OpCodes.Conv_R4)
                 converted = True
             Case TypeCombinations.Decimal_Single
                 Info.ILGen.Emit(OpCodes.Call, Helper.GetMethodOrMethodReference(Info.Compiler, Info.Compiler.TypeCache.System_Convert__ToSingle_Decimal))
                 converted = True
 
                 'ToDouble conversions
             Case TypeCombinations.Decimal_Double
                 Info.ILGen.Emit(OpCodes.Call, Helper.GetMethodOrMethodReference(Info.Compiler, Info.Compiler.TypeCache.System_Convert__ToDouble_Decimal))
                 converted = True
             Case TypeCombinations.SByte_Double, _
                   TypeCombinations.Byte_Double, _
                    TypeCombinations.UInt16_Double, _
                     TypeCombinations.Int16_Double, _
                      TypeCombinations.UInt32_Double, _
                       TypeCombinations.Int32_Double, _
                        TypeCombinations.UInt64_Double, _
                         TypeCombinations.Int64_Double, _
                          TypeCombinations.Single_Double
                 Info.ILGen.Emit(OpCodes.Conv_R8)
                 converted = True
 
                 'ToDecimal conversions
             Case TypeCombinations.Byte_Decimal, _
              TypeCombinations.SByte_Decimal, _
              TypeCombinations.Int16_Decimal
                 Info.ILGen.Emit(OpCodes.Conv_I4)
                 Info.ILGen.Emit(OpCodes.Newobj, Helper.GetMethodOrMethodReference(Info.Compiler, Info.Compiler.TypeCache.System_Decimal__ctor_Int32))
                 converted = True
             Case TypeCombinations.UInt16_Decimal, _
                TypeCombinations.UInt32_Decimal
                 Info.ILGen.Emit(OpCodes.Conv_I8)
                 Info.ILGen.Emit(OpCodes.Newobj, Helper.GetMethodOrMethodReference(Info.Compiler, Info.Compiler.TypeCache.System_Decimal__ctor_Int64))
                 converted = True
             Case TypeCombinations.Int32_Decimal
                 Info.ILGen.Emit(OpCodes.Newobj, Helper.GetMethodOrMethodReference(Info.Compiler, Info.Compiler.TypeCache.System_Decimal__ctor_Int32))
                 converted = True
             Case TypeCombinations.UInt64_Decimal
                 Info.ILGen.Emit(OpCodes.Newobj, Helper.GetMethodOrMethodReference(Info.Compiler, Info.Compiler.TypeCache.System_Decimal__ctor_UInt64))
                 converted = True
             Case TypeCombinations.Int64_Decimal
                 Info.ILGen.Emit(OpCodes.Newobj, Helper.GetMethodOrMethodReference(Info.Compiler, Info.Compiler.TypeCache.System_Decimal__ctor_Int64))
                 converted = True
 
                 'ToObject conversions
             Case TypeCombinations.SByte_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_SByte))
                 converted = True
             Case TypeCombinations.Byte_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Byte))
                 converted = True
             Case TypeCombinations.Int16_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Int16))
                 converted = True
             Case TypeCombinations.UInt16_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_UInt16))
                 converted = True
             Case TypeCombinations.Int32_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Int32))
                 converted = True
             Case TypeCombinations.UInt32_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_UInt32))
                 converted = True
             Case TypeCombinations.Int64_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Int64))
                 converted = True
             Case TypeCombinations.UInt64_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_UInt64))
                 converted = True
             Case TypeCombinations.Single_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Single))
                 converted = True
             Case TypeCombinations.Double_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Double))
                 converted = True
             Case TypeCombinations.String_Object
                 converted = True
             Case TypeCombinations.Decimal_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Decimal))
                 converted = True
             Case TypeCombinations.DateTime_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_DateTime))
                 converted = True
             Case TypeCombinations.Boolean_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Boolean))
                 converted = True
             Case TypeCombinations.Char_Object
                 Info.ILGen.Emit(OpCodes.Box, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_Char))
                 converted = True
             Case TypeCombinations.DBNull_Object
                 converted = True 'Nothing to object
             Case TypeCombinations.Object_String
                 Emitter.EmitCastClass(Info, Helper.GetTypeOrTypeReference(Info.Compiler, Info.Compiler.TypeCache.System_String))
                 converted = True
             Case TypeCombinations.Int32_Boolean
                 'Nothing to do here
                 converted = True
             Case Else
                 Info.Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Missed option
                 Info.Compiler.Report.WriteLine(Report.ReportLevels.Debug, Info.Method.Location.ToString(Info.Compiler))
                 Helper.Stop()
         End Select
 
         If Not converted Then
             Info.Compiler.Report.WriteLine(vbnc.Report.ReportLevels.Debug, "Skipped option
             Helper.Stop()
         End If
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\Expressions\LateBoundAccessToValueExpression.vb" startline="132" endline="714">
<![CDATA[
 
     Protected Overrides Function ResolveExpressionInternal(ByVal Info As ResolveInfo) As Boolean
         Dim result As Boolean = True
 
         '---------------------------------------------------------------------------------------------------------
         'A member access expression is used to access a member of an entity. A member access of the form E.I, 
         'where E is an expression, a built-in type, the keyword Global, or omitted and I is an identifier with an 
         'optional type argument list, is evaluated and classified as follows
         '---------------------------------------------------------------------------------------------------------
         '* If E is omitted, then the expression from the immediately containing With statement is substituted for 
         '  E and the member access is performed. If there is no containing With statement, a compile-time 
         '  error occurs.
         '---------------------------------------------------------------------------------------------------------
         '* If E is a type parameter, then a compile-time error results.
         '---------------------------------------------------------------------------------------------------------
         '* If E is the keyword Global, and I is the name of an accessible type in the global namespace, 
         '  then the result is that type.
         '---------------------------------------------------------------------------------------------------------
         '* If E is classified as a namespace and I is the name of an accessible member of that namespace, 
         '  then the result is that member. The result is classified as a namespace or a type depending on the member.
         '---------------------------------------------------------------------------------------------------------
         '* If E is a built-in type or an expression classified as a type, and I is the name of an accessible 
         '  member of E, then E.I is evaluated and classified as follows
         '** If I is the keyword New, then a compile-time error occurs.
         '** If I identifies a type, then the result is that type.
         '** If I identifies one or more methods, then the result is a method group with the associated 
         '   type argument list and no associated instance expression.
         '** If I identifies one or more properties, then the result is a property group with no associated 
         '   instance expression.
         '** If I identifies a shared variable, and if the variable is read-only, and the reference occurs 
         '   outside the shared constructor of the type in which the variable is declared, then the result is the 
         '   value of the shared variable I in E. Otherwise, the result is the shared variable I in E.
         '** If I identifies a shared event, the result is an event access with no associated instance expression.
         '** If I identifies a constant, then the result is the value of that constant.
         '** If I identifies an enumeration member, then the result is the value of that enumeration member.
         '** Otherwise, E.I is an invalid member reference, and a compile-time error occurs.
         '---------------------------------------------------------------------------------------------------------
         '* If E is classified as a variable or value, the type of which is T, and I is the name of an accessible 
         '  member of E, then E.I is evaluated and classified as follows
         '** If I is the keyword New and E is an instance expression (Me, MyBase, or MyClass), then the result is 
         '   a method group representing the instance constructors of the type of E with an associated 
         '   instance expression of E and no type argument list. Otherwise, a compile-time error occurs.
         '** If I identifies one or more methods, then the result is a method group with the associated type 
         '   argument list and an associated instance expression of E.
         '** If I identifies one or more properties, then the result is a property group with an 
         '   associated instance expression of E.
         '** If I identifies a shared variable or an instance variable, and if the variable is read-only, 
         '   and the reference occurs outside a constructor of the class in which the variable is declared 
         '   appropriate for the kind of variable (shared or instance), then the result is the value of the 
         '   variable I in the object referenced by E. If T is a reference type, then the result is the variable 
         '   I in the object referenced by E. Otherwise, if T is a value type and the expression E is classified 
         '   as a variable, the result is a variable; otherwise the result is a value.
         '** If I identifies an event, the result is an event access with an associated instance expression of E.
         '** If I identifies a constant, then the result is the value of that constant.
         '** If I identifies an enumeration member, then the result is the value of that enumeration member.
         '** If T is Object, then the result is a late-bound member lookup classified as a late-bound access 
         '   with an associated instance expression of E.
         '** Otherwise, E.I is an invalid member reference, and a compile-time error occurs.
         '---------------------------------------------------------------------------------------------------------
         'If the member access expression includes a type argument list, then only types or methods 
         'with the same arity as the type argument list are considered.
         'When a member access expression begins with the keyword Global, the keyword represents the outermost 
         'unnamed namespace, which is useful in situations where a declaration shadows an enclosing namespace. The 
         'Global keyword allows "escaping" out to the outermost namespace in that situation. 
         '---------------------------------------------------------------------------------------------------------
 
         Dim Name As String = m_Second.Name
         Dim typeArguments As TypeArgumentList = Nothing
 
         Dim iokwta As IdentifierOrKeywordWithTypeArguments = TryCast(m_Second, IdentifierOrKeywordWithTypeArguments)
         If iokwta IsNot Nothing Then
             typeArguments = iokwta.TypeArguments
         End If
 
         Helper.Assert(Name IsNot Nothing AndAlso Name <> "")
 
         If m_First IsNot Nothing Then
             result = m_First.ResolveExpression(New ResolveInfo(Info.Compiler, False, Info.CanFail, Info.CanBeImplicitSimpleName)) AndAlso result
         Else
             '* If E is omitted, then the expression from the immediately containing With statement is substituted for
             '  E and the member access is performed. If there is no containing With statement, a compile-time 
             '  error occurs.
             m_WithStatement = Me.FindFirstParentOfCodeBlock(Of WithStatement)()
             If m_WithStatement Is Nothing Then
                 Helper.AddError(Me)
                 Return False
             Else
                 m_First = m_WithStatement.WithVariableExpression
                 ' Helper.Assert(m_First.IsResolved)
             End If
         End If
 
         If result = False Then Return result
 
         '* If E is a type parameter, then a compile-time error results.
         If m_First.Classification.IsTypeClassification AndAlso m_First.Classification.AsTypeClassification.IsTypeParameter Then
             result = Compiler.Report.ShowMessage(Messages.VBNC32098, Me.Location) AndAlso result
             If result = False Then Return result
         End If
 
         '* If E is the keyword Global, and I is the name of an accessible type in the global namespace, 
         '  then the result is that type.
         If TypeOf m_First Is GlobalExpression Then
             Dim foundType As Mono.Cecil.TypeReference
             foundType = Compiler.TypeManager.GetTypesByNamespace("").Item(Name)
             If foundType IsNot Nothing Then
                 Classification = New TypeClassification(Me, foundType)
                 Return True
             ElseIf Compiler.TypeManager.Namespaces.ContainsKey(Name) Then
                 Classification = New NamespaceClassification(Me, Compiler.TypeManager.Namespaces(Name))
                 Return True
             Else
                 Return Compiler.Report.ShowMessage(Messages.VBNC30456, Location, Name, "<Default>") AndAlso result
             End If
         End If
 
         '* If E is classified as a namespace and I is the name of an accessible member of that namespace, 
         '  then the result is that member. The result is classified as a namespace or a type depending on the member.
         If m_First.Classification.IsNamespaceClassification Then
             Dim nstypes As Generic.List(Of Mono.Cecil.TypeReference) = Nothing
             Dim ns As [Namespace] = m_First.Classification.AsNamespaceClassification.Namespace
             Dim nsname As String = ns.Name
             Dim foundns As [Namespace]
             Dim foundType As Mono.Cecil.TypeReference
 
             foundns = Compiler.TypeManager.Namespaces.Item(ns, Name)
             foundType = Compiler.TypeManager.TypesByNamespace(nsname).Item(Name)
 
             If foundns IsNot Nothing AndAlso foundType Is Nothing Then
                 Classification = New NamespaceClassification(Me, foundns)
                 Return True
             ElseIf foundns Is Nothing AndAlso foundType IsNot Nothing Then
                 Classification = New TypeClassification(Me, foundType)
                 Return True
             ElseIf foundns IsNot Nothing AndAlso nstypes IsNot Nothing Then
                 Helper.AddError(Me, "Found a namespace and a type with the same name.")
             End If
 
             'TODO
             Dim modules As TypeDictionary = Compiler.TypeManager.GetModulesByNamespace(ns.ToString)
             Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference) = Helper.GetMembersOfTypes(Compiler, modules, Name)
             If members IsNot Nothing AndAlso members.Count > 0 Then
                 Dim first As Object = members(0)
                 If Helper.IsMethodDeclaration(first) Then
                     Classification = New MethodGroupClassification(Me, Nothing, typeArguments, Nothing, members)
                     Return True
                 ElseIf Helper.IsTypeDeclaration(first) Then
                     If members.Count = 1 Then
                         Classification = New TypeClassification(Me, first)
                         Return True
                     Else
                         Helper.AddError(Me)
                     End If
                 ElseIf Helper.IsFieldDeclaration(first) Then
                     If members.Count = 1 Then
                         Classification = New VariableClassification(Me, DirectCast(first, Mono.Cecil.FieldReference), Nothing)
                         Return True
                     Else
                         Helper.AddError(Me)
                     End If
                 ElseIf Helper.IsPropertyDeclaration(first) Then
                     Classification = New PropertyGroupClassification(Me, Nothing, members)
                     Return True
                 Else
                     Helper.Stop()
                 End If
             End If
         End If
 
         '* If E is a built-in type or an expression classified as a type, and I is the name of an accessible 
         '  member of E, then E.I is evaluated and classified as follows
         '** If I is the keyword New, then a compile-time error occurs.
         '** If I identifies a type, then the result is that type.
         '** If I identifies one or more methods, then the result is a method group with the associated 
         '   type argument list and no associated instance expression.
         '** If I identifies one or more properties, then the result is a property group with no associated 
         '   instance expression.
         '** If I identifies a shared variable, and if the variable is read-only, and the reference occurs 
         '   outside the shared constructor of the type in which the variable is declared, then the result is the 
         '   value of the shared variable I in E. Otherwise, the result is the shared variable I in E.
         '** If I identifies a shared event, the result is an event access with no associated instance expression.
         '** If I identifies a constant, then the result is the value of that constant.
         '** If I identifies an enumeration member, then the result is the value of that enumeration member.
         '** Otherwise, E.I is an invalid member reference, and a compile-time error occurs.
         If m_First.Classification.IsTypeClassification Then
             'If m_Second.IsKeyword AndAlso m_Second.Keyword = KS.New Then
             '    '** If I is the keyword New, then a compile-time error occurs.
             '    Helper.AddError(Me)
             'End If
             Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference) = Nothing
             Dim entry As MemberCacheEntry
             'members = Helper.FilterByName(Helper.GetMembers(Compiler, m_First.Classification.AsTypeClassification.Type), Name)
             'members = Helper.FilterByName(Compiler.TypeManager.GetCache(m_First.Classification.AsTypeClassification.Type).FlattenedCache.GetAllMembers.ToArray, Name)
             entry = Compiler.TypeManager.GetCache(m_First.Classification.AsTypeClassification.Type).LookupFlattened(Name)
 
             If entry Is Nothing Then
                 Compiler.Report.ShowMessage(Messages.VBNC30456, Me.Location, Name, m_First.Classification.AsTypeClassification.Type.FullName)
                 Return False
             End If
 
             If entry IsNot Nothing Then
                 members = entry.Members
                 If typeArguments IsNot Nothing Then
                     members = Helper.FilterByTypeArguments(members, typeArguments)
                     'For i As Integer = 0 To members.Count - 1
                     '    Dim mR As Mono.Cecil.MethodReference = TryCast(members(i), Mono.Cecil.MethodReference)
                     '    If mR Is Nothing Then
                     '        Helper.StopIfDebugging()
                     '        Continue For
                     '    End If
                     '    members(i) = CecilHelper.GetCorrectMember(mR, withTypeArgs.TypeArguments.ArgumentCollection)
                     'Next
                 End If
                 members = Helper.FilterExternalInaccessible(Me.Compiler, members)
             End If
 
             Helper.StopIfDebugging(members Is Nothing OrElse members.Count = 0)
 
             If members IsNot Nothing AndAlso members.Count > 0 Then
                 Dim first As Object = members(0)
                 '** If I identifies one or more methods, then the result is a method group with the associated 
                 '   type argument list and no associated instance expression.
                 If Helper.IsMethodDeclaration(first) Then
                     Classification = New MethodGroupClassification(Me, Nothing, typeArguments, Nothing, members)
                     Return True
                 End If
                 '** If I identifies one or more properties, then the result is a property group with no associated 
                 '   instance expression.
                 If Helper.IsPropertyDeclaration(first) Then
                     Dim instanceExpression As Expression = Nothing
                     If m_First.Classification.AsTypeClassification.CanBeExpression Then
                         'Ignore failures here, not sure if failures can actually happen for valid code
                         m_First.Classification.AsTypeClassification.CreateAliasExpression(m_First, instanceExpression)
                     End If
                     Classification = New PropertyGroupClassification(Me, instanceExpression, members)
                     Return True
                 End If
 
                 If members.Count > 1 Then Helper.Stop()
 
                 '** If I identifies a type, then the result is that type.
                 If Helper.IsTypeDeclaration(first) Then
                     Classification = New TypeClassification(Me, first)
                     Return True
                 End If
 
                 '** If I identifies a shared variable, and if the variable is read-only, and the reference occurs 
                 '   outside the shared constructor of the type in which the variable is declared, then the result is the 
                 '   value of the shared variable I in E. Otherwise, the result is the shared variable I in E.
                 If Helper.IsFieldDeclaration(first) Then
                     Dim fld As Mono.Cecil.FieldReference = TryCast(first, Mono.Cecil.FieldReference)
                     If fld Is Nothing Then
                         Dim var As TypeVariableDeclaration = TryCast(first, TypeVariableDeclaration)
                         Helper.Assert(var IsNot Nothing)
                         fld = var.FieldBuilder
                     End If
                     Dim constructor As ConstructorDeclaration = Me.FindFirstParent(Of ConstructorDeclaration)()
                     Dim instanceExpression As Expression = Nothing
 
                     If Not CecilHelper.IsStatic(fld) AndAlso m_First.Classification.IsTypeClassification AndAlso m_First.Classification.AsTypeClassification.CanBeExpression Then
                         result = m_First.Classification.AsTypeClassification.CreateAliasExpression(m_First, instanceExpression) AndAlso result
                     End If
 
                     If Helper.IsShared(fld) AndAlso CBool(CecilHelper.FindDefinition(fld).Attributes And Mono.Cecil.FieldAttributes.InitOnly) AndAlso (constructor Is Nothing OrElse constructor.Modifiers.Is(ModifierMasks.Shared) = False) Then
                         Classification = New ValueClassification(Me, fld, Nothing)
                         Return True
                     Else
                         If instanceExpression Is Nothing AndAlso CecilHelper.IsStatic(fld) = False Then
                             Return Report.ShowMessage(Messages.VBNC30469, Me.Location)
                         End If
                         Classification = New VariableClassification(Me, fld, instanceExpression)
                         Return True
                     End If
                 End If
 
                 '** If I identifies a shared event, the result is an event access with no associated instance expression.
                 If Helper.IsEventDeclaration(first) Then
                     Dim red As EventDeclaration = TryCast(first, EventDeclaration)
                     Dim red2 As Mono.Cecil.EventDefinition = CecilHelper.FindDefinition(TryCast(first, Mono.Cecil.EventReference))
                     If red IsNot Nothing AndAlso red.Modifiers.Is(ModifierMasks.Shared) Then
                         Classification = New EventAccessClassification(Me, red.EventDescriptor, Nothing)
                         Return True
                     ElseIf red2 IsNot Nothing AndAlso red2.AddMethod.IsStatic Then
                         Classification = New EventAccessClassification(Me, red2, Nothing)
                         Return True
                     End If
                 End If
 
                 '** If I identifies a constant, then the result is the value of that constant.
                 Dim c As ConstantDeclaration = TryCast(first, ConstantDeclaration)
                 If c IsNot Nothing Then
                     Classification = New ValueClassification(Me, c)
                     Return True
                 End If
 
                 '** If I identifies an enumeration member, then the result is the value of that enumeration member.
                 Dim enummember As EnumMemberDeclaration = TryCast(first, EnumMemberDeclaration)
                 If enummember IsNot Nothing Then
                     Classification = New ValueClassification(Me, enummember)
                     Return True
                 End If
 
                 '** Otherwise, E.I is an invalid member reference, and a compile-time error occurs.
                 'Now we need to check for default instances
                 If m_First.Classification.AsTypeClassification.CanBeExpression Then
                     Dim aliasExpression As Expression = Nothing
                     m_First.Classification.AsTypeClassification.CreateAliasExpression(m_First, aliasExpression)
                     m_First = aliasExpression
                 Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC30469, Me.Location)
                 End If
             Else
                 Helper.AddError(Me, "Could not resolve name '" & Name & "'" & "," & Me.Location.ToString(Compiler))
             End If
         End If
 
 
         '* If E is classified as a variable or value, the type of which is T, and I is the name of an accessible 
         '  member of E, then E.I is evaluated and classified as follows
         '** If I is the keyword New and E is an instance expression (Me, MyBase, or MyClass), then the result is 
         '   a method group representing the instance constructors of the type of E with an associated 
         '   instance expression of E and no type argument list. Otherwise, a compile-time error occurs.
         '** If I identifies one or more methods, then the result is a method group with the associated type 
         '   argument list and an associated instance expression of E.
         '** If I identifies one or more properties, then the result is a property group with an 
         '   associated instance expression of E.
         '** If I identifies a shared variable or an instance variable, and if the variable is read-only, 
         '   and the reference occurs outside a constructor of the class in which the variable is declared 
         '   appropriate for the kind of variable (shared or instance), then the result is the value of the 
         '   variable I in the object referenced by E. If T is a reference type, then the result is the variable 
         '   I in the object referenced by E. Otherwise, if T is a value type and the expression E is classified 
         '   as a variable, the result is a variable; otherwise the result is a value.
         '** If I identifies an event, the result is an event access with an associated instance expression of E.
         '** If I identifies a constant, then the result is the value of that constant.
         '** If I identifies an enumeration member, then the result is the value of that enumeration member.
         '** If T is Object, then the result is a late-bound member lookup classified as a late-bound access 
         '   with an associated instance expression of E.
         '** Otherwise, E.I is an invalid member reference, and a compile-time error occurs.
         If m_First.Classification.IsValueClassification OrElse m_First.Classification.IsVariableClassification OrElse m_First.Classification.CanBeValueClassification Then
             Dim T As Mono.Cecil.TypeReference 'Descriptor
 
             If m_First.Classification.IsValueClassification Then
                 T = m_First.Classification.AsValueClassification.Type
             ElseIf m_First.Classification.IsVariableClassification Then
                 T = m_First.Classification.AsVariableClassification.Type
             ElseIf m_First.Classification.CanBeValueClassification Then
                 m_First = m_First.ReclassifyToValueExpression
                 result = m_First.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
                 If result = False Then
                     If Info.IsEventResolution Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC30506, Location)
                     Else
                         Helper.AddError(Compiler, Location, "Huh?")
                     End If
                 End If
                 Helper.Assert(m_First.Classification IsNot Nothing)
                 Helper.Assert(m_First.Classification.AsValueClassification IsNot Nothing)
                 T = m_First.Classification.AsValueClassification.Type
             Else
                 Throw New InternalException(Me)
             End If
 
             If CecilHelper.IsByRef(T) Then
                 m_First = m_First.DereferenceByRef()
                 T = m_First.ExpressionType
             End If
 
             '** If I is the keyword New and E is an instance expression (Me, MyBase, or MyClass), then the result is 
             '   a method group representing the instance constructors of the type of E with an associated 
             '   instance expression of E and no type argument list. Otherwise, a compile-time error occurs.
             If m_Second.IsKeyword AndAlso m_Second.Keyword = KS.New Then
                 If TypeOf m_First Is InstanceExpression Then
                     Classification = New MethodGroupClassification(Me, m_First, typeArguments, Nothing, Helper.GetInstanceConstructors(T))
                     Return True
                 Else
                     Helper.AddError(Me)
                 End If
             End If
 
             Dim members As Mono.Collections.Generic.Collection(Of Mono.Cecil.MemberReference)
             Dim member As MemberCacheEntry
 
             member = Compiler.TypeManager.GetCache(T).LookupFlattened(Name, Me.FindFirstParent_IType.CecilType)
             If member Is Nothing Then
                 If Me.File.IsOptionStrictOn = False AndAlso Helper.CompareType(T, Compiler.TypeCache.System_Object) Then
                     Classification = New LateBoundAccessClassification(Me, m_First, Nothing, Name)
                     Return True
                 End If
 
                 member = Compiler.TypeManager.GetCache(T).LookupFlattened(Name, MemberVisibility.All)
                 If member Is Nothing OrElse member.Members.Count = 0 Then
                     If Helper.CompareType(T, Compiler.TypeCache.System_Object) Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC30574, Me.Location) AndAlso result
                     Else
                         Return Compiler.Report.ShowMessage(Messages.VBNC30456, Me.Location, Name, T.FullName) AndAlso result
                     End If
                 ElseIf member.Members.Count = 1 Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC30390, Me.Location, Name, T.FullName, Helper.GetVisibilityString(member.Members(0))) AndAlso result
                 Else
                     Return Compiler.Report.ShowMessage(Messages.VBNC30517, Me.Location, Name) AndAlso result
                 End If
             End If
 
             members = member.Members
             Dim withTypeArgs As IdentifierOrKeywordWithTypeArguments
             withTypeArgs = TryCast(m_Second, IdentifierOrKeywordWithTypeArguments)
             If withTypeArgs IsNot Nothing Then
                 members = Helper.FilterByTypeArguments(members, withTypeArgs.TypeArguments)
             End If
             members = Helper.FilterExternalInaccessible(Me.Compiler, members)
 
             If members.Count = 0 Then
                 result = Compiler.Report.ShowMessage(Messages.VBNC30456, Me.Location, Name, T.FullName) AndAlso result
                 If result = False Then Return result
             End If
 
             If members.Count > 0 Then
                 Dim first As Object = members(0)
                 '** If I identifies one or more methods, then the result is a method group with the associated type 
                 '   argument list and an associated instance expression of E.
                 If Helper.IsMethodDeclaration(first) Then
                     m_First = m_First.GetObjectReference
                     Classification = New MethodGroupClassification(Me, m_First, typeArguments, Nothing, members)
                     Return True
                 End If
                 '** If I identifies one or more properties, then the result is a property group with an 
                 '   associated instance expression of E.
                 If Helper.IsPropertyDeclaration(first) Then
                     m_First = m_First.GetObjectReference
                     Classification = New PropertyGroupClassification(Me, m_First, members)
                     Return True
                 End If
 
                 If members.Count > 1 Then Throw New InternalException(Me)
 
                 '** If I identifies a shared variable or an instance variable, and if the variable is read-only, 
                 '   and the reference occurs outside a constructor of the class in which the variable is declared 
                 '   appropriate for the kind of variable (shared or instance), then the result is the value of the 
                 '   variable I in the object referenced by E. 
                 '   If T is a reference type, then the result is the variable I in the object referenced by E. 
                 '   Otherwise, if T is a value type and the expression E is classified as a variable, the result is 
                 '   a variable; otherwise the result is a value.
                 Dim var As VariableDeclaration = TryCast(first, VariableDeclaration)
                 Dim fld As Mono.Cecil.FieldReference = TryCast(first, Mono.Cecil.FieldReference)
 
                 If var IsNot Nothing Then
                     Dim constructor As ConstructorDeclaration = Me.FindFirstParent(Of ConstructorDeclaration)()
 
                     If var.Modifiers.Is(ModifierMasks.ReadOnly) AndAlso (constructor Is Nothing OrElse constructor.Modifiers.Is(ModifierMasks.Shared) <> var.Modifiers.Is(ModifierMasks.Shared)) Then
                         Classification = New ValueClassification(Me, var)
                         Return True
                     ElseIf CecilHelper.IsClass(T) Then
                         Classification = New VariableClassification(Me, var)
                         Return True
                     ElseIf CecilHelper.IsValueType(T) Then
                         If m_First.Classification.IsVariableClassification Then
                             Classification = New VariableClassification(Me, var)
                             Return True
                         ElseIf m_First.Classification.IsValueClassification Then
                             Classification = New ValueClassification(Me, var)
                             Return True
                         Else
                             Throw New InternalException(Me)
                         End If
                     Else
                         Throw New InternalException(Me)
                     End If
                 ElseIf fld IsNot Nothing Then
                     Dim fD As Mono.Cecil.FieldDefinition = CecilHelper.FindDefinition(fld)
                     If Helper.IsAccessible(Me, fD.Attributes, fld.DeclaringType, Me.FindFirstParent_IType.CecilType) = False Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC30390, Location, fld.DeclaringType.FullName, fld.Name, Helper.ToString(fD.Attributes))
                     End If
 
                     Dim constructor As ConstructorDeclaration = Me.FindFirstParent(Of ConstructorDeclaration)()
                     If fD.IsInitOnly AndAlso (constructor Is Nothing OrElse constructor.Modifiers.Is(ModifierMasks.Shared) <> fD.IsStatic) Then
                         If fD.IsStatic Then
                             Classification = New ValueClassification(Me, fld, Nothing)
                         Else
                             Classification = New ValueClassification(Me, fld, m_First)
                         End If
                         Return True
                     ElseIf CecilHelper.IsClass(T) Then
                         If fD.IsStatic Then
                             Classification = New VariableClassification(Me, fld, Nothing)
                         Else
                             Classification = New VariableClassification(Me, fld, m_First)
                         End If
                         Return True
                     ElseIf CecilHelper.IsValueType(T) Then
                         If m_First.Classification.IsVariableClassification Then
                             If Not TypeOf m_First Is InstanceExpression Then
                                 m_First = m_First.GetObjectReference
                             End If
                             If fD.IsStatic Then
                                 Classification = New VariableClassification(Me, fld, Nothing)
                             Else
                                 Classification = New VariableClassification(Me, fld, m_First)
                             End If
                             Return True
                         ElseIf m_First.Classification.IsValueClassification Then
                             If fD.IsStatic Then
                                 Classification = New ValueClassification(Me, fld, Nothing)
                             Else
                                 Classification = New ValueClassification(Me, fld, m_First)
                             End If
                             Return True
                         ElseIf m_First.Classification.CanBeValueClassification Then
                             m_First = m_First.ReclassifyToValueExpression
                             result = m_First.ResolveExpression(ResolveInfo.Default(Info.Compiler)) AndAlso result
 
                             If fD.IsStatic Then
                                 Classification = New ValueClassification(Me, fld, Nothing)
                             Else
                                 Classification = New ValueClassification(Me, fld, m_First)
                             End If
                             Return True
                         Else
                             Throw New InternalException(Me)
                         End If
                     Else
                         Throw New InternalException(Me)
                     End If
                 End If
 
                 '** If I identifies an event, the result is an event access with an associated instance expression of E.
                 If Helper.IsEventDeclaration(first) Then
                     Dim red As EventDeclaration = TryCast(first, EventDeclaration)
                     If red Is Nothing AndAlso TypeOf first Is Mono.Cecil.EventReference Then
                         red = DirectCast(CecilHelper.FindDefinition(DirectCast(first, Mono.Cecil.EventReference)).Annotations(Compiler), EventDeclaration)
                     End If
                     If red IsNot Nothing Then
                         Classification = New EventAccessClassification(Me, red.EventDescriptor, m_First)
                         Return True
                     End If
                     Dim eInfo As Mono.Cecil.EventReference = TryCast(first, Mono.Cecil.EventReference)
                     If eInfo IsNot Nothing Then
                         Classification = New EventAccessClassification(Me, eInfo, m_First)
                         Return True
                     End If
                 End If
 
                 '** If I identifies a constant, then the result is the value of that constant.
                 Dim constant As ConstantDeclaration = TryCast(first, ConstantDeclaration)
                 If constant IsNot Nothing Then
                     Classification = New ValueClassification(Me, constant)
                     Return True
                 End If
 
                 '** If I identifies an enumeration member, then the result is the value of that enumeration member.
                 If Helper.IsEnumFieldDeclaration(Compiler, first) Then
                     Dim em As EnumMemberDeclaration = TryCast(first, EnumMemberDeclaration)
                     Dim emfld As Mono.Cecil.FieldReference = TryCast(first, Mono.Cecil.FieldReference)
                     If em IsNot Nothing Then
                         Classification = New ValueClassification(Me, em)
                         Return True
                     ElseIf emfld IsNot Nothing Then
                         Classification = New ValueClassification(Me, emfld, Nothing)
                         Return True
                     End If
                 End If
 
                 '** If T is Object, then the result is a late-bound member lookup classified as a late-bound access 
                 '   with an associated instance expression of E.
                 If T IsNot Nothing Then
                     'Dim td As TypeDescriptor = TryCast(T, TypeDescriptor)
                     Dim compresult As Boolean = Helper.CompareType(T, Compiler.TypeCache.System_Object)
                     If compresult Then
                         Return Compiler.Report.ShowMessage(Messages.VBNC99997, Me.Location)
                     End If
                 End If
                 '** Otherwise, E.I is an invalid member reference, and a compile-time error occurs.
                 Compiler.Report.ShowMessage(Messages.VBNC30456, Me.Location, Name, T.FullName)
                 result = False
             Else
                 Compiler.Report.ShowMessage(Messages.VBNC30456, Me.Location, Name, T.FullName)
                 result = False
             End If
         End If
 
         Compiler.Report.ShowMessage(Messages.VBNC30456, Location, Name, m_First.AsString)
 
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\CodeFiles.vb" startline="929" endline="1152">
<![CDATA[
 
     Private Function SetOption(ByVal strName As String, ByVal strValue As String) As Boolean
         Dim result As Boolean = True
         Select Case LCase(strName)
             ' - OUTPUT FILE -
             Case "out"
                 m_strOut = strValue
             Case "target", "t"
                 Select Case LCase(strValue)
                     Case "exe"
                         m_strTarget = Targets.Console
                     Case "winexe"
                         m_strTarget = Targets.Winexe
                     Case "library"
                         m_strTarget = Targets.Library
                     Case "module"
                         m_strTarget = Targets.Module
                     Case Else
                         Compiler.Report.SaveMessage(Messages.VBNC2019, Span.CommandLineSpan, "target", strValue)
                         result = False
                 End Select
                 ' - INPUT FILES -
             Case "addmodule"
                 m_lstModules.AddRange(Split(strValue, ","))
             Case "recurse"
                 'Add the files
                 Dim strPath As String = System.IO.Path.GetDirectoryName(strValue)
                 Dim strRelativePath As String = strPath
                 Dim strFileName As String
                 If strPath <> "" Then
                     strFileName = strValue.Substring(strPath.Length + 1)
                 Else
                     strPath = IO.Directory.GetCurrentDirectory()
                     strFileName = strValue
                 End If
                 result = AddFilesInDir(strPath, strRelativePath, strFileName) AndAlso result
             Case "reference", "r"
                 m_lstReferences.AddRange(Split(strValue, ","))
                 ' - RESOURCES -
             Case "linkresource", "linkres"
                 result = m_lstLinkResources.Add(strValue) AndAlso result
             Case "resource", "res"
                 result = m_lstResources.Add(strValue) AndAlso result
             Case "win32icon"
                 m_strWin32Icon = strValue
             Case "win32resource"
                 m_strWin32Resource = strValue
                 ' - CODE GENERATION -
             Case "optimize+", "optimize"
                 m_bOptimize = True
             Case "optimize-"
                 m_bOptimize = False
             Case "removeintchecks+", "removeintchecks"
                 m_bRemoveIntChecks = True
             Case "removeintchecks-"
                 m_bRemoveIntChecks = False
             Case "debug+"
                 m_eDebugInfo = DebugTypes.Full
             Case "debug-"
                 m_eDebugInfo = DebugTypes.None
             Case "debug"
                 Select Case LCase(strValue)
                     Case "full"
                         m_eDebugInfo = DebugTypes.Full
                     Case "pdbonly"
                         m_eDebugInfo = DebugTypes.PDB
                     Case ""
                         m_eDebugInfo = DebugTypes.Full
                     Case Else
                         'TODO
                         Compiler.Report.SaveMessage(Messages.VBNC2019, Span.CommandLineSpan, strName, strValue)
                         result = False
                 End Select
                 ' - ERRORS AND WARNINGS -
             Case "nowarn"
                 m_bNoWarn = True
             Case "warnaserror+", "warnaserror"
                 m_bWarnAsError = True
             Case "warnaserror-"
                 m_bWarnAsError = False
                 ' - LANGUAGE -
             Case "define", "d"
                 'FIXME
                 Dim strDefines() As String = Split(strValue, ",")
                 For Each str As String In strDefines
                     If str.Contains("=") = False Then str = str & "=True"
                     Dim strSplit() As String = Split(str, "=")
                     If strSplit.GetUpperBound(0) <> 1 Then
                         Compiler.Report.ShowMessage(Messages.VBNC90017, Span.CommandLineSpan, str)
                         result = False
                     Else
                         m_lstDefine.Add(New Define(Compiler, strSplit(0), strSplit(1)))
                     End If
                 Next
             Case "imports"
                 Dim imps As String()
                 imps = strValue.Split(","c)
                 For Each str As String In imps
                     If str <> "" Then
                         result = vbnc.Parser.ParseImportsStatement(m_lstImports, str) AndAlso result
                     End If
                 Next
             Case "optionexplicit+", "optionexplicit"
                 m_eOptionExplicit = OptionExplicitTypes.On
             Case "optionexplicit-"
                 m_eOptionExplicit = OptionExplicitTypes.Off
             Case "optionstrict+", "optionstrict"
                 m_eOptionStrict = OptionStrictTypes.On
             Case "optionstrict-"
                 m_eOptionStrict = OptionStrictTypes.Off
             Case "optioninfer+", "optioninfer"
                 m_eOptionInfer = OptionInferTypes.On
             Case "optioninfer-"
                 m_eOptionInfer = OptionInferTypes.Off
             Case "rootnamespace"
                 m_strRootNamespace = strValue
             Case "optioncompare"
                 Select Case LCase(strValue)
                     Case "text"
                         m_eOptionCompare = OptionCompareTypes.Text
                     Case "binary"
                         m_eOptionCompare = OptionCompareTypes.Binary
                     Case Else
                         result = False
                         'TODO
                         Compiler.Report.SaveMessage(Messages.VBNC2019, Span.CommandLineSpan, strName, strValue)
                 End Select
                 ' - MISCELLANEOUS -
             Case "help", "?"
                 m_bHelp = True
             Case "nologo"
                 m_bNoLogo = True
             Case "quiet"
                 m_bQuiet = True
             Case "verbose", "verbose+"
                 m_bVerbose = True
             Case "verbose-"
                 m_bVerbose = False
             Case "noconfig"
                 m_bNoConfig = True
             Case "nostdlib"
                 m_bNoStdLib = True
             Case "trace"
                 m_bTrace = True
                 ' - ADVANCED -
             Case "baseaddress"
                 m_strBaseAddress = strValue
             Case "bugreport"
                 m_strBugReport = strValue
             Case "codepage"
                 If strValue = "" Then
                     Compiler.Report.ShowMessage(Messages.VBNC2006, Span.CommandLineSpan, "codepage", "<number>")
                     result = False
                 Else
                     Try
                         m_Encoding = System.Text.Encoding.GetEncoding(Integer.Parse(strValue, Globalization.NumberStyles.AllowLeadingWhite Or Globalization.NumberStyles.AllowLeadingSign, System.Globalization.CultureInfo.InvariantCulture))
                     Catch
                         Compiler.Report.ShowMessage(Messages.VBNC2016, Span.CommandLineSpan, strValue)
                         result = False
                     End Try
                 End If
             Case "delaysign+"
                 m_bDelaySign = True
             Case "delaysign-"
                 m_bDelaySign = False
             Case "keycontainer"
                 m_strKeyContainer = strValue
             Case "keyfile"
                 Dim paths() As String
                 paths = Me.GetFullPaths(strValue)
                 If paths IsNot Nothing AndAlso paths.Length = 1 Then
                     m_strKeyFile = paths(0)
                 Else
                     Helper.AddError(Compiler, """")
                 End If
             Case "libpath"
                 m_lstLibPath.AddRange(Split(strValue, ","))
             Case "main"
                 m_strMain = strValue
             Case "netcf"
                 m_bNetCF = True
                 result = False
                 Compiler.Report.ShowMessage(Messages.VBNC90016, Span.CommandLineSpan, ".NET Compact Framework")
             Case "sdkpath"
                 m_strSDKPath = strValue
             Case "utf8output+", "utf8output"
                 m_bUTF8Output = True
             Case "utf8output-"
                 m_bUTF8Output = False
             Case "novbruntimeref"
                 m_VBRuntime = Nothing
             Case "vbruntime-"
                 m_VBRuntime = Nothing
             Case "vbruntime+"
                 m_VBRuntime = "Microsoft.VisualBasic.dll"
             Case "vbruntime"
                 m_VBRuntime = strValue
             Case "errorreport"
                 result = Compiler.Report.SaveMessage(Messages.VBNC99998, Span.CommandLineSpan, "/errorreport isn't implemented yet.") AndAlso result
             Case "vbversion"
                 Select Case strValue
                     Case "7"
                         m_VBVersion = VBVersions.V7
                     Case "7.1"
                         m_VBVersion = VBVersions.V7_1
                     Case "8"
                         m_VBVersion = VBVersions.V8
                     Case Else
                         Helper.AddWarning("Unknown vb version
                 End Select
             Case "doc-"
                 m_strDoc = Nothing
             Case "doc+"
                 m_strDoc = String.Empty
                 Compiler.Report.SaveMessage(Messages.VBNC99998, Span.CommandLineSpan, "Support for /doc+ has not been implemented. No documentation file will be generated.")
             Case "doc"
                 m_strDoc = strValue
                 Compiler.Report.SaveMessage(Messages.VBNC99998, Span.CommandLineSpan, "Support for /doc
             Case Else
                 'result = False 'OK since this is only a warning.
                 result = Compiler.Report.SaveMessage(Messages.VBNC2009, Span.CommandLineSpan, strName) AndAlso result
         End Select
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="1" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\MRUbuffer.vb" startline="61" endline="69">
<![CDATA[
         End Property
         
         '''<summary>
         '''  Looks up a localized string similar to &lt;Settings/&gt;.
         '''</summary>
         Friend ReadOnly Property FactorySettings() As String
             Get
                 Return ResourceManager.GetString("FactorySettings", resourceCulture)
             End Get
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\MRUbuffer.vb" startline="70" endline="87">
<![CDATA[
         End Property
         
         '''<summary>
         '''  Looks up a localized string similar to &lt;Tools&gt;
         '''    &lt;Tool&gt;
         '''        &lt;DisplayName&gt;Real Media Movies&lt;/DisplayName&gt;
         '''        &lt;Path Name=&quot;Path&quot; Reqd=&quot;yes&quot;&gt;C
         '''        &lt;URL&gt;http
         '''        &lt;Desc&gt;You can edit RealMedia movies if you have RealProducer Basic (free download) on your computer 
         '''        
         '''Prerequisites 
         '''        &lt;Filter&gt;RealMedia Splitter&lt;/Filter&gt;
         '''        &lt;Extensi [rest of string was truncated]&quot;;.
         '''</summary>
         Friend ReadOnly Property ToolsMetadata() As String
             Get
                 Return ResourceManager.GetString("ToolsMetadata", resourceCulture)
             End Get
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="2" nfragments="2" Csharpe_files="0" vb_files="2" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\Helper.vb" startline="2821" endline="3727">
<![CDATA[
 
     Shared Function IsConvertible(ByVal Parent As ParsedObject, ByVal FromExpression As Expression, ByVal FromType As TypeReference, ByVal DestinationType As TypeReference, ByVal CreateConversionExpression As Boolean, ByRef convExpr As Expression, ByVal ShowError As Boolean, ByVal isStrict As Boolean?, Optional ByVal considerConstantExpressions As Boolean = True) As Boolean
         Dim Compiler As Compiler = Parent.Compiler
         Dim TypeCache As CecilTypeCache = Compiler.TypeCache
         Dim toArray As ArrayType
         Dim fromArray As ArrayType
         Dim fromTD As TypeDefinition
         Dim toTD As TypeDefinition
         Dim fromElement As TypeReference
         Dim toElement As TypeReference
         Dim isFromReference As Boolean
         Dim fromTG As GenericParameter
         Dim toTG As GenericParameter
         Dim fromTC As TypeCode
         Dim toTC As TypeCode
         Dim isFromNullable As Boolean
         Dim isToNullable As Boolean
         Dim isFromEnum As Boolean
         Dim isToEnum As Boolean
         Dim byrefTo As ByReferenceType = TryCast(DestinationType, ByReferenceType)
         Dim byrefFrom As ByReferenceType = TryCast(FromType, ByReferenceType)
 
         Dim constant As Object = Nothing
 
         If Not isStrict.HasValue Then
             isStrict = Parent.Location.File(Compiler).IsOptionStrictOn
         End If
 
         convExpr = FromExpression
 
         If byrefTo IsNot Nothing AndAlso byrefFrom Is Nothing Then
             If IsConvertible(Parent, FromExpression, FromType, byrefTo.ElementType, CreateConversionExpression, convExpr, ShowError, isStrict) Then
                 'If CreateConversionExpression Then
                 '    convExpr = New GetRefExpression(Parent, convExpr)
                 '    If convExpr.ResolveExpression(ResolveInfo.Default(Parent.Compiler)) = False Then Return False
                 'End If
                 Return True
             End If
             Return False
         ElseIf byrefFrom IsNot Nothing AndAlso byrefTo Is Nothing Then
             If IsConvertible(Parent, FromExpression, byrefFrom.ElementType, DestinationType, False, convExpr, ShowError, isStrict) Then
                 If CreateConversionExpression Then
                     convExpr = New DeRefExpression(Parent, convExpr)
                     If convExpr.ResolveExpression(ResolveInfo.Default(Parent.Compiler)) = False Then Return False
                     If Not IsConvertible(Parent, convExpr, byrefFrom.ElementType, DestinationType, True, convExpr, ShowError, isStrict) Then Return False
                 End If
                 Return True
             End If
             Return False
         End If
 
         'Identity/Default conversions
         '?	From a type to itself.
         If Helper.CompareType(FromType, DestinationType) Then
             'no conversion required
             Return True
         End If
         '?	From an anonymous delegate type generated for a lambda method reclassification to any delegate type with an identical signature.
         'TODO
         '?	From the literal Nothing to a type.
         If Helper.CompareType(FromType, Compiler.TypeCache.Nothing) Then
             'not sure if a conversion is required here
             If CreateConversionExpression Then
                 convExpr = New CTypeExpression(Parent, convExpr, DestinationType)
                 If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
             End If
             Return True
         End If
 
         toTD = CecilHelper.FindDefinition(DestinationType)
         fromTD = CecilHelper.FindDefinition(FromType)
         toArray = TryCast(DestinationType, ArrayType)
         fromArray = TryCast(FromType, ArrayType)
         isFromReference = fromTD IsNot Nothing AndAlso ((fromTD.IsInterface OrElse fromTD.IsClass) AndAlso (fromTD.IsValueType = False OrElse fromArray IsNot Nothing))
         isFromNullable = Helper.IsNullableType(Compiler, FromType)
         isToNullable = Helper.IsNullableType(Compiler, DestinationType)
         isFromEnum = Helper.IsEnum(Compiler, FromType)
         isToEnum = Helper.IsEnum(Compiler, DestinationType)
         fromTC = Helper.GetTypeCode(Compiler, FromType)
         toTC = Helper.GetTypeCode(Compiler, DestinationType)
 
         'Numeric conversions
         'Widening conversions
         '?	From Byte to UShort, Short, UInteger, Integer, ULong, Long, Decimal, Single, or Double.
         '?	From SByte to Short, Integer, Long, Decimal, Single, or Double.
         '?	From UShort to UInteger, Integer, ULong, Long, Decimal, Single, or Double.
         '?	From Short to Integer, Long, Decimal, Single or Double.
         '?	From UInteger to ULong, Long, Decimal, Single, or Double.
         '?	From Integer to Long, Decimal, Single or Double.
         '?	From ULong to Decimal, Single, or Double.
         '?	From Long to Decimal, Single or Double.
         '?	From Decimal to Single or Double.
         '?	From Single to Double.
         If isFromNullable = False AndAlso isToNullable = False AndAlso isFromEnum = False AndAlso isToEnum = False Then
             Select Case fromTC
                 Case TypeCode.Byte, TypeCode.SByte, TypeCode.UInt16, TypeCode.Int16, TypeCode.UInt32, TypeCode.Int32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Decimal, TypeCode.Single
                     If (toTC <> TypeCode.Object OrElse Helper.CompareType(DestinationType, TypeCache.System_Object)) AndAlso Compiler.TypeResolution.IsImplicitlyConvertible(Compiler, fromTC, toTC) Then
                         If CreateConversionExpression Then
                             convExpr = New CTypeExpression(Parent, FromExpression, DestinationType)
                             If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                         End If
                         Return True
                     End If
             End Select
         End If
         '?	From the literal 0 to an enumerated type. (widening)
         If considerConstantExpressions AndAlso Helper.IsEnum(Compiler, DestinationType) AndAlso Helper.IsLiteral0Expression(Compiler, FromExpression) Then
             If CreateConversionExpression Then
                 convExpr = New CTypeExpression(Parent, FromExpression, DestinationType)
                 If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
             End If
             Return True
         End If
         '?	From an enumerated type to its underlying numeric type, or to a numeric type that its underlying numeric type has a widening conversion to.
         If Helper.IsEnum(Compiler, FromType) AndAlso toTC <> TypeCode.Object AndAlso Helper.IsEnum(Compiler, DestinationType) = False Then
             Dim enumType As TypeReference = Helper.GetEnumType(Compiler, FromType)
             If Compiler.TypeResolution.IsImplicitlyConvertible(Compiler, Helper.GetTypeCode(Compiler, enumType), toTC) Then
                 convExpr = New CTypeExpression(Parent, FromExpression, DestinationType, CTypeConversionType.Intrinsic)
                 If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                 Return True
             End If
         End If
         '?	From a constant expression of type ULong, Long, UInteger, Integer, UShort, Short, Byte, or SByte to a narrower type, provided the value of the constant expression is within the range of the destination type.
         'SPECBUG
         If considerConstantExpressions AndAlso (fromTC = TypeCode.UInt64 OrElse fromTC = TypeCode.Int64 OrElse fromTC = TypeCode.UInt32 OrElse fromTC = TypeCode.Int32 OrElse fromTC = TypeCode.UInt16 OrElse fromTC = TypeCode.Int16 OrElse fromTC = TypeCode.Byte OrElse fromTC = TypeCode.SByte OrElse fromTC = TypeCode.Single OrElse fromTC = TypeCode.Double OrElse fromTC = TypeCode.Decimal) Then
             If FromExpression.GetConstant(constant, False) Then
                 If Helper.CompareType(DestinationType, TypeCache.System_DBNull) = False AndAlso Compiler.TypeResolution.CheckNumericRange(constant, constant, DestinationType) Then
                     'No conversion should be required here
                     convExpr = New CTypeExpression(Parent, FromExpression, DestinationType)
                     If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                     Return True
                 End If
             End If
         End If
 
         '?	From a numeric type to an enumerated type.
         If Helper.IsEnum(Compiler, DestinationType) AndAlso Compiler.TypeResolution.IsNumericType(FromType) Then
             If isStrict Then
                 If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30512, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                 Return False
             End If
             If CreateConversionExpression Then
                 convExpr = New CTypeExpression(Parent, FromExpression, DestinationType)
                 If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
             End If
             Return True
         End If
         '?	From an enumerated type to a numeric type its underlying numeric type has a narrowing conversion to.
         If Helper.IsEnum(Compiler, FromType) AndAlso Compiler.TypeResolution.IsNumericType(DestinationType) Then
             'if DestinationType is a numeric type the enum's type has a widening conversion to, we'll hit a widening conversion case above
             If isStrict Then
                 If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30512, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                 Return False
             End If
             If CreateConversionExpression Then
                 convExpr = New CTypeExpression(Parent, FromExpression, DestinationType)
                 If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
             End If
             Return True
         End If
         '?	From an enumerated type to another enumerated type. 
         If Helper.IsEnum(Compiler, DestinationType) Then
             If Helper.IsEnum(Compiler, FromType) Then
                 If isStrict Then
                     If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30512, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                     Return False
                 End If
                 If CreateConversionExpression Then
                     convExpr = New CTypeExpression(Parent, FromExpression, Helper.GetEnumType(Compiler, DestinationType), CTypeConversionType.Intrinsic)
                     If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                 End If
                 Return True
             ElseIf Helper.CompareType(FromType, TypeCache.System_Enum) Then
                 If isStrict Then
                     If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30512, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                     Return False
                 End If
                 If CreateConversionExpression Then
                     convExpr = New CTypeExpression(Parent, FromExpression, DestinationType, CTypeConversionType.Unbox_Ldobj)
                     If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                 End If
                 Return True
             End If
         End If
 
         'Reference conversions
         '?	From a reference type to a base type.
         If isFromReference AndAlso Helper.IsSubclassOf(DestinationType, FromType) Then
             'no conversion required
             Return True
         End If
 
         If isFromReference AndAlso Helper.CompareType(DestinationType, TypeCache.System_Object) Then
             'no conversion required.
             'this case is required for at least arrays (since arrays don't explicitly inherit from object)
             Return True
         End If
 
         '?	From a reference type to an interface type, provided that the type implements the interface or a variant compatible interface.
         If isFromReference AndAlso toTD IsNot Nothing AndAlso toTD.IsInterface Then
             If Helper.DoesTypeImplementInterface(Parent, FromType, DestinationType) Then
                 'no conversion required
                 Return True
             End If
         End If
         If CecilHelper.IsArray(FromType) AndAlso toTD IsNot Nothing AndAlso toTD.IsInterface Then
             If Helper.DoesTypeImplementInterface(Parent, FromType, DestinationType) Then
                 'no conversion required
                 Return True
             End If
         End If
 
         '?	From an interface type to Object.
         If isFromReference AndAlso toTD IsNot Nothing AndAlso fromTD.IsInterface AndAlso Helper.Compare(Parent.Compiler.TypeCache.System_Object, DestinationType) Then
             'No conversion required
             Return True
         End If
         '?	From an interface type to a variant compatible interface type.
         '?	From a delegate type to a variant compatible delegate type.
 
         'https
         'This is from C#'s ECMA-334
         '?	From a one-dimensional array-type S[] to System.Collections.Generic.IList<T> and base interfaces of this interface, provided there is an implicit reference conversion from S to T.
         If fromArray IsNot Nothing AndAlso fromArray.Rank = 1 AndAlso toTD IsNot Nothing AndAlso toTD.IsInterface AndAlso toTD.GenericParameters.Count = 1 Then
             Dim isIList As Boolean = Helper.CompareType(toTD, TypeCache.System_Collections_Generic_IList1)
             isIList = isIList OrElse Helper.CompareType(toTD, TypeCache.System_Collections_Generic_IEnumerable1)
             isIList = isIList OrElse Helper.CompareType(toTD, TypeCache.System_Collections_Generic_ICollection1)
             If isIList Then
                 Dim git As GenericInstanceType = TryCast(DestinationType, GenericInstanceType)
                 If git IsNot Nothing AndAlso git.GenericArguments.Count = 1 AndAlso IsConvertible(Parent, FromExpression, fromArray.GetElementType(), git.GenericArguments(0), False, Nothing, False, True) Then
                     'No conversion expression is required I think
                     Return True
                 End If
             End If
         End If
 
         'Narrowing conversions for reference conversions are done at the end of the widening conversions
 
         'Anonymous Delegate conversions
         '?	From an anonymous delegate type generated for a lambda method reclassification to any wider delegate type. (widening)
         '?	From an anonymous delegate type generated for a lambda method reclassification to any narrower delegate type. (narrowing)
         'TODO
 
         'Array conversions
         If toArray IsNot Nothing AndAlso fromArray IsNot Nothing Then
             toElement = toArray.ElementType
             fromElement = fromArray.ElementType
 
             '?	From an array type S with an element type SE to an array type T with an element type TE, provided all of the following are true
             '   ?	S and T differ only in element type.
             If toArray.Rank <> fromArray.Rank Then
                 If ShowError Then
                     Compiler.Report.ShowMessage(Messages.VBNC30414, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                 End If
                 Return False
             End If
             If toArray.Dimensions.Count <> fromArray.Dimensions.Count Then
                 If ShowError Then
                     Compiler.Report.ShowMessage(Messages.VBNC30414, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                 End If
                 Return False
             End If
             '   ?	Both SE and TE are reference types or are type parameters known to be a reference type.
             '   ?	A widening reference, array, or type parameter conversion exists from SE to TE.
             If CecilHelper.IsReferenceTypeOrGenericReferenceTypeParameter(toElement) AndAlso CecilHelper.IsReferenceTypeOrGenericReferenceTypeParameter(fromElement) Then
                 If IsConvertible(Parent, FromExpression, fromElement, toElement, False, Nothing, False, True) Then
                     If CreateConversionExpression Then
                         convExpr = New CTypeExpression(Parent, FromExpression, DestinationType, CTypeConversionType.Castclass)
                         If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                     End If
                     Return True
                 End If
             End If
 
             '?	From an array type S with an enumerated element type SE to an array type T with an element type TE, provided all of the following are true
             If Helper.IsEnum(Parent.Compiler, fromElement) Then
                 '   ?	S and T differ only in element type.
                 'This has been checked above
 
                 '   ?	TE is the underlying type of SE.
                 Dim enumT As TypeReference = Helper.GetEnumType(Parent.Compiler, fromElement)
                 If Helper.CompareType(enumT, toElement) Then
                     'Not sure if a conversion is required here
                     Return True
                 End If
             End If
 
             'Narrowing conversions
             '?	From an array type S with an element type SE, to an array type T with an element type TE, provided that all of the following are true
             '   ?	S and T differ only in element type.
             '   ?	Both SE and TE are reference types or are type parameters not known to be value types.
             '   ?	A narrowing reference, array, or type parameter conversion exists from SE to TE.
             If CecilHelper.IsValueType(toElement) = False AndAlso CecilHelper.IsValueType(fromElement) = False Then
                 If IsConvertible(Parent, FromExpression, fromElement, toElement, False, Nothing, False, False) Then
                     If isStrict Then
                         If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30512, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                         Return False
                     End If
                     If CreateConversionExpression Then
                         convExpr = New CTypeExpression(Parent, FromExpression, DestinationType, CTypeConversionType.Castclass)
                         If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                     End If
                     Return True
                 End If
             End If
 
             '?	From an array type S with an element type SE to an array type T with an enumerated element type TE, provided all of the following are true
             If Helper.IsEnum(Parent.Compiler, toElement) Then
                 '   ?	S and T differ only in element type.
                 'This has been checked above
 
                 '   ?	SE is the underlying type of TE.
                 Dim enumT As TypeReference = Helper.GetEnumType(Parent.Compiler, toElement)
                 If Helper.CompareType(enumT, fromElement) Then
                     If isStrict Then
                         If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30512, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                         Return False
                     End If
                     If CreateConversionExpression Then
                         'Not sure if this is the right conversion
                         convExpr = New CTypeExpression(Parent, FromExpression, DestinationType, CTypeConversionType.Castclass)
                         If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                     End If
                     Return True
                 End If
             End If
 
             If ShowError Then
                 If Helper.IsEnum(Compiler, fromElement) = False AndAlso CecilHelper.IsValueType(fromElement) AndAlso CecilHelper.IsValueType(toElement) = False Then
                     Compiler.Report.ShowMessage(Messages.VBNC30333, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType), Helper.ToString(Compiler, fromElement), Helper.ToString(Compiler, toElement))
                 Else
                     Compiler.Report.ShowMessage(Messages.VBNC30332, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType), Helper.ToString(Compiler, fromElement), Helper.ToString(Compiler, toElement))
                 End If
             End If
             Return False
         End If
 
         'Value Type conversions
         If fromTD IsNot Nothing AndAlso fromTD.IsValueType Then
             '?	From a value type to a base type.
             If Helper.CompareType(DestinationType, Parent.Compiler.TypeCache.System_Object) OrElse Helper.CompareType(DestinationType, Parent.Compiler.TypeCache.System_ValueType) Then
                 If CreateConversionExpression Then
                     convExpr = New BoxExpression(Parent, convExpr, DestinationType)
                     If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                 End If
                 Return True
             End If
 
             If Helper.IsEnum(Compiler, FromType) AndAlso Helper.CompareType(DestinationType, TypeCache.System_Enum) Then
                 If CreateConversionExpression Then
                     convExpr = New CTypeExpression(Parent, convExpr, DestinationType, CTypeConversionType.Box)
                     If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                 End If
                 Return True
             End If
 
             '?	From a value type to an interface type that the type implements.
             If fromTD.HasInterfaces Then
                 Dim interfaces As Mono.Collections.Generic.Collection(Of TypeReference)
                 interfaces = CecilHelper.GetInterfaces(FromType, True)
                 For i As Integer = 0 To interfaces.Count - 1
                     If Helper.CompareType(DestinationType, interfaces(i)) Then
                         If CreateConversionExpression Then
                             convExpr = New BoxExpression(Parent, convExpr, DestinationType)
                             If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                         End If
                         Return True
                     End If
 
                     If Helper.DoesTypeImplementInterface(Parent, interfaces(i), DestinationType) Then
                         If CreateConversionExpression Then
                             convExpr = New BoxExpression(Parent, convExpr, DestinationType)
                             If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                         End If
                         Return True
                     End If
                 Next
             End If
         End If
 
         'Narrowing conversions
         '?	From Boolean to Byte, SByte, UShort, Short, UInteger, Integer, ULong, Long, Decimal, Single, or Double.
         '?	From Byte, SByte, UShort, Short, UInteger, Integer, ULong, Long, Decimal, Single, or Double to Boolean.
         '?	From Byte to SByte.
         '?	From SByte to Byte, UShort, UInteger, or ULong.
         '?	From UShort to Byte, SByte, or Short.
         '?	From Short to Byte, SByte, UShort, UInteger, or ULong.
         '?	From UInteger to Byte, SByte, UShort, Short, or Integer.
         '?	From Integer to Byte, SByte, UShort, Short, UInteger, or ULong.
         '?	From ULong to Byte, SByte, UShort, Short, UInteger, Integer, or Long.
         '?	From Long to Byte, SByte, UShort, Short, UInteger, Integer, or ULong.
         '?	From Decimal to Byte, SByte, UShort, Short, UInteger, Integer, ULong, or Long.
         '?	From Single to Byte, SByte, UShort, Short, UInteger, Integer, ULong, Long, or Decimal.
         '?	From Double to Byte, SByte, UShort, Short, UInteger, Integer, ULong, Long, Decimal, or Single.
         If isFromNullable = False AndAlso isToNullable = False Then
             Select Case fromTC
                 Case TypeCode.Byte, TypeCode.SByte, TypeCode.UInt16, TypeCode.Int16, TypeCode.UInt32, TypeCode.Int32, TypeCode.UInt64, TypeCode.Int64, TypeCode.Decimal, TypeCode.Single
                     If toTC <> TypeCode.Object AndAlso Compiler.TypeResolution.IsExplicitlyConvertible(Compiler, fromTC, toTC) Then
                         If isStrict Then
                             If ShowError Then
                                 If Helper.CompareType(TypeCache.System_Char, DestinationType) Then
                                     If Helper.CompareType(TypeCache.System_Decimal, FromType) OrElse Helper.CompareType(TypeCache.System_Double, FromType) OrElse Helper.CompareType(TypeCache.System_Single, FromType) OrElse Helper.CompareType(TypeCache.System_DBNull, FromType) OrElse Helper.CompareType(TypeCache.System_DateTime, FromType) Then
                                         Compiler.Report.ShowMessage(Messages.VBNC30311, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                                     Else
                                         Compiler.Report.ShowMessage(Messages.VBNC32007, Parent.Location, Helper.ToString(Compiler, FromType))
                                     End If
                                 ElseIf Helper.CompareType(TypeCache.System_DateTime, DestinationType) Then
                                     Compiler.Report.ShowMessage(Messages.VBNC30311, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                                 ElseIf Helper.CompareType(TypeCache.System_DBNull, DestinationType) Then
                                     Compiler.Report.ShowMessage(Messages.VBNC30311, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                                 Else
                                     Compiler.Report.ShowMessage(Messages.VBNC30512, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                                 End If
                             End If
                             Return False
                         End If
                         If CreateConversionExpression Then
                             convExpr = New CTypeExpression(Parent, FromExpression, DestinationType, CTypeConversionType.Intrinsic)
                             If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                         End If
                         Return True
                     End If
                 Case TypeCode.Boolean, TypeCode.Double
                     If toTC <> TypeCode.Object AndAlso Compiler.TypeResolution.IsExplicitlyConvertible(Compiler, fromTC, toTC) Then
                         If isStrict Then
                             If ShowError Then
                                 If Helper.CompareType(TypeCache.System_Char, DestinationType) Then
                                     Compiler.Report.ShowMessage(Messages.VBNC30311, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                                 ElseIf Helper.CompareType(TypeCache.System_DateTime, DestinationType) Then
                                     If Helper.CompareType(TypeCache.System_Double, FromType) Then
                                         Compiler.Report.ShowMessage(Messages.VBNC30533, Parent.Location)
                                     Else
                                         Compiler.Report.ShowMessage(Messages.VBNC30311, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                                     End If
                                 ElseIf Helper.CompareType(TypeCache.System_DBNull, DestinationType) Then
                                     Compiler.Report.ShowMessage(Messages.VBNC30311, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                                 Else
                                     Compiler.Report.ShowMessage(Messages.VBNC30512, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                                 End If
                             End If
                             Return False
                         End If
                         If CreateConversionExpression Then
                             convExpr = New CTypeExpression(Parent, FromExpression, DestinationType)
                             If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                         End If
                         Return True
                     End If
             End Select
         End If
 
         'Reference conversions
         If toTD IsNot Nothing AndAlso toTD.IsValueType Then
             '?	From a reference type to a more derived value type.
             If Helper.CompareType(FromType, Parent.Compiler.TypeCache.System_Object) OrElse Helper.CompareType(FromType, Parent.Compiler.TypeCache.System_ValueType) Then
                 If isStrict Then
                     If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30512, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                     Return False
                 End If
                 If CreateConversionExpression Then
                     If Helper.IsIntrinsicType(Compiler, DestinationType) Then
                         convExpr = New CTypeExpression(Parent, convExpr, DestinationType)
                     Else
                         convExpr = New CTypeExpression(Parent, convExpr, DestinationType, CTypeConversionType.Unbox_Ldobj)
                     End If
                     If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                 End If
                 Return True
             End If
             '?	From an interface type to a value type, provided the value type implements the interface type
             If fromTD.IsInterface AndAlso Helper.DoesTypeImplementInterface(Parent, DestinationType, FromType) Then
                 If isStrict Then
                     If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30512, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                     Return False
                 End If
                 If CreateConversionExpression Then
                     convExpr = New CTypeExpression(Parent, convExpr, DestinationType, CTypeConversionType.Unbox_Ldobj)
                     If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                 End If
                 Return True
             End If
         End If
 
         'Nullable Value Type conversions
         If fromTD IsNot Nothing AndAlso fromTD.IsValueType Then
             Dim nulledTo As TypeReference = Nothing
             Dim nulledFrom As TypeReference = Nothing
 
             If isFromNullable Then nulledFrom = CecilHelper.GetNulledType(FromType)
             If isToNullable Then nulledTo = CecilHelper.GetNulledType(DestinationType)
 
             '?	From a type T to the type T?.
             If isFromNullable = False AndAlso isToNullable AndAlso Helper.CompareType(nulledTo, FromType) Then
                 If CreateConversionExpression Then
                     convExpr = New CTypeExpression(Parent, convExpr, DestinationType, CTypeConversionType.ToNullable)
                     If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                 End If
                 Return True
             End If
 
             '?	From a type T? to a type S?, where there is a widening conversion from the type T to the type S.
             If isFromNullable AndAlso isToNullable AndAlso IsConvertible(Parent, FromExpression, nulledFrom, nulledTo, False, Nothing, False, True) Then
                 If CreateConversionExpression Then
                     convExpr = New CTypeExpression(Parent, convExpr, DestinationType, CTypeConversionType.NullableToNullable)
                     If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                 End If
                 Return True
             End If
 
             '?	From a type T to a type S?, where there is a widening conversion from the type T to the type S.
             If isFromNullable = False AndAlso isToNullable AndAlso IsConvertible(Parent, FromExpression, FromType, nulledTo, False, Nothing, False, True) Then
                 If CreateConversionExpression Then
                     convExpr = New CTypeExpression(Parent, convExpr, nulledTo, CTypeConversionType.Intrinsic)
                     If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                     convExpr = New CTypeExpression(Parent, convExpr, DestinationType, CTypeConversionType.ToNullable)
                     If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                 End If
                 Return True
             End If
 
             '?	From a type T? to an interface type that the type T implements.
             If isFromNullable AndAlso toTD.IsInterface AndAlso Helper.DoesTypeImplementInterface(Parent, nulledFrom, DestinationType) Then
                 If CreateConversionExpression Then
                     convExpr = New BoxExpression(Parent, convExpr, FromType)
                     If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                     convExpr = New CTypeExpression(Parent, convExpr, DestinationType, CTypeConversionType.Castclass)
                     If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                 End If
                 Return True
             End If
 
             'narrowing conversions
             '?	From a type T? to a type T.
             If isFromNullable AndAlso isToNullable = False AndAlso Helper.CompareType(nulledFrom, DestinationType) Then
                 If isStrict Then
                     If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30512, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                     Return False
                 End If
                 If CreateConversionExpression Then
                     convExpr = New CTypeExpression(Parent, convExpr, DestinationType, CTypeConversionType.FromNullable)
                     If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                 End If
                 Return True
             End If
             '?	From a type T? to a type S?, where there is a narrowing conversion from the type T to the type S.
             If isFromNullable AndAlso isToNullable AndAlso IsConvertible(Parent, FromExpression, nulledFrom, nulledTo, False, Nothing, False, False) Then
                 If isStrict Then
                     If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30512, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                     Return False
                 End If
                 If CreateConversionExpression Then
                     'denullify
                     convExpr = New CTypeExpression(Parent, convExpr, nulledFrom, CTypeConversionType.FromNullable)
                     If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                     'convert
                     If Not IsConvertible(Parent, convExpr, nulledFrom, nulledTo, True, convExpr, True, isStrict) Then Return False
                     'renullify
                     convExpr = New CTypeExpression(Parent, convExpr, DestinationType, CTypeConversionType.ToNullable)
                     If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                 End If
                 Return True
             End If
             '?	From a type T to a type S?, where there is a narrowing conversion from the type T to the type S.
             If isFromNullable = False AndAlso isToNullable AndAlso IsConvertible(Parent, FromExpression, FromType, nulledTo, False, Nothing, False, False) Then
                 If isStrict Then
                     If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30512, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                     Return False
                 End If
                 If CreateConversionExpression Then
                     'convert
                     If Not IsConvertible(Parent, convExpr, FromType, nulledTo, True, convExpr, True, isStrict) Then Return False
                     'renullify
                     convExpr = New CTypeExpression(Parent, convExpr, DestinationType, CTypeConversionType.ToNullable)
                     If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                 End If
                 Return True
             End If
             '?	From a type S? to a type T, where there is a conversion from the type S to the type T.
             If isFromNullable AndAlso isToNullable = False AndAlso IsConvertible(Parent, FromExpression, nulledFrom, DestinationType, False, Nothing, False, False) Then
                 If isStrict Then
                     If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30512, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                     Return False
                 End If
                 If CreateConversionExpression Then
                     'denullify
                     convExpr = New CTypeExpression(Parent, convExpr, nulledFrom, CTypeConversionType.FromNullable)
                     If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                     'convert
                     If Not IsConvertible(Parent, convExpr, nulledFrom, DestinationType, True, convExpr, True, Nothing) Then Return False
                 End If
                 Return True
             End If
         End If
 
         'String conversions
         If Helper.CompareType(DestinationType, Compiler.TypeCache.System_String) Then
             '?	From Char to String.
             '?	From Char() to String.
             If Helper.CompareType(FromType, Compiler.TypeCache.System_Char) OrElse Helper.CompareType(FromType, Compiler.TypeCache.System_Char_Array) Then
                 If CreateConversionExpression Then
                     convExpr = New CStrExpression(Parent, FromExpression)
                     If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                 End If
                 Return True
             End If
             If fromTC <> TypeCode.DBNull AndAlso (fromTC <> TypeCode.Object OrElse Helper.CompareType(TypeCache.System_Object, FromType)) Then
                 If isStrict Then
                     If ShowError Then
                         If Helper.CompareType(TypeCache.System_DBNull, FromType) Then
                             Compiler.Report.ShowMessage(Messages.VBNC30311, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                         Else
                             Compiler.Report.ShowMessage(Messages.VBNC30512, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                         End If
                     End If
                     Return False
                 End If
                 If CreateConversionExpression Then
                     convExpr = New CTypeExpression(Parent, FromExpression, DestinationType)
                     If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                 End If
                 Return True
             End If
         ElseIf Helper.CompareType(FromType, TypeCache.System_String) Then
             '?	From String to Char.
             If Helper.CompareType(DestinationType, Compiler.TypeCache.System_Char) Then
                 If isStrict Then
                     If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30512, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                     Return False
                 End If
                 If CreateConversionExpression Then
                     convExpr = New CCharExpression(Parent, FromExpression)
                     If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                 End If
                 Return True
             End If
             '?	From String to Char().
             If Helper.CompareType(DestinationType, Compiler.TypeCache.System_Char_Array) Then
                 If isStrict Then
                     If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30512, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                     Return False
                 End If
                 If CreateConversionExpression Then
                     convExpr = New CTypeExpression(Parent, FromExpression, Compiler.TypeCache.System_Char_Array)
                     If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                 End If
                 Return True
             End If
             '?	From String to Boolean and from Boolean to String.
             '?	Conversions between String and Byte, SByte, UShort, Short, UInteger, Integer, ULong, Long, Decimal, Single, or Double.
             '?	From String to Date and from Date to String.
             'from boolean is handled in the numeric conversion code
             If toTC <> TypeCode.Object Then
                 If isStrict Then
                     If ShowError Then
                         If Helper.CompareType(TypeCache.System_DBNull, DestinationType) Then
                             Compiler.Report.ShowMessage(Messages.VBNC30311, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                         Else
                             Compiler.Report.ShowMessage(Messages.VBNC30512, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                         End If
                     End If
                     Return False
                 End If
                 If CreateConversionExpression Then
                     convExpr = New CTypeExpression(Parent, FromExpression, DestinationType)
                     If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                 End If
                 Return True
             End If
         End If
 
         'Type Parameter conversions
         fromTG = TryCast(FromType, GenericParameter)
         If fromTG IsNot Nothing Then
             '?	From a type parameter to Object.
             If Helper.CompareType(DestinationType, Parent.Compiler.TypeCache.System_Object) Then
                 If CreateConversionExpression Then
                     convExpr = New BoxExpression(Parent, convExpr, DestinationType)
                     If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                 End If
                 Return True
             End If
 
             If fromTG.HasConstraints Then
                 For i As Integer = 0 To fromTG.Constraints.Count - 1
                     Dim constraint As TypeReference = fromTG.Constraints(i)
 
                     '?	From a type parameter to an interface type constraint or any interface variant compatible with an interface type constraint.
                     ' Same implementation as "From a type parameter to a class constraint, or a base type of the class constraint." below
 
                     '?	From a type parameter to an interface implemented by a class constraint.
                     If toTD IsNot Nothing AndAlso toTD.IsInterface Then
                         If Helper.DoesTypeImplementInterface(Parent, constraint, DestinationType) Then
                             If CreateConversionExpression Then
                                 convExpr = New CTypeExpression(Parent, convExpr, DestinationType, CTypeConversionType.Box)
                                 If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                                 convExpr = New CTypeExpression(Parent, convExpr, DestinationType, CTypeConversionType.Castclass)
                                 If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                             End If
                             Return True
                         End If
                     End If
 
                     '?	From a type parameter to an interface variant compatible with an interface implemented by a class constraint.
                     'TODO
 
                     '?	From a type parameter to a class constraint, or a base type of the class constraint.
                     If Helper.CompareType(constraint, DestinationType) Then
                         If CreateConversionExpression Then
                             convExpr = New CTypeExpression(Parent, convExpr, DestinationType, CTypeConversionType.Box)
                             If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                             convExpr = New CTypeExpression(Parent, convExpr, DestinationType, CTypeConversionType.Castclass)
                             If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                         End If
                         Return True
                     End If
                     If Helper.IsSubclassOf(DestinationType, fromTG.Constraints(i)) Then
                         If CreateConversionExpression Then
                             convExpr = New CTypeExpression(Parent, convExpr, DestinationType, CTypeConversionType.Box)
                             If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                             convExpr = New CTypeExpression(Parent, convExpr, DestinationType, CTypeConversionType.Castclass)
                             If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                         End If
                         Return True
                     End If
 
                     '?	From a type parameter T to a type parameter constraint TX, or anything TX has a widening conversion to.
                     'TODO
 
                 Next
             End If
 
             'narrowing conversions
             '?	From Object to a type parameter (handled below)
             '?	From a type parameter to an interface type, provided the type parameter is not constrained to that interface or constrained to a class that implements that interface.
             If toTD IsNot Nothing AndAlso toTD.IsInterface Then
                 If isStrict Then
                     If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30512, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                     Return False
                 End If
                 If CreateConversionExpression Then
                     convExpr = New CTypeExpression(Parent, FromExpression, DestinationType, CTypeConversionType.Castclass)
                     If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                 End If
                 Return True
             End If
             '?	From an interface type to a type parameter (handled below)
             If fromTG.HasConstraints Then
                 For i As Integer = 0 To fromTG.Constraints.Count - 1
                     Dim constraint As TypeReference = fromTG.Constraints(i)
 
                     '?	From a type parameter to a derived type of a class constraint.
                     If CecilHelper.IsClass(constraint) Then 'A bit more is needed here
                         If isStrict Then
                             If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30311, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                             Return False
                         End If
                         If CreateConversionExpression Then
                             convExpr = New CTypeExpression(Parent, FromExpression, DestinationType, CTypeConversionType.Box_CastClass)
                             If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                         End If
                         Return True
                     End If
 
                     '?	From a type parameter T to anything a type parameter constraint TX has a narrowing conversion to.
                     If IsConvertible(Parent, convExpr, constraint, DestinationType, False, Nothing, False, Nothing) Then
                         If isStrict Then
                             If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30512, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                             Return False
                         End If
                         If CreateConversionExpression Then
                             convExpr = New CTypeExpression(Parent, convExpr, constraint, CTypeConversionType.Box_CastClass)
                             If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                             If Not IsConvertible(Parent, convExpr, constraint, DestinationType, True, convExpr, True, Nothing) Then Return True
                         End If
                         Return True
                     End If
                 Next
             End If
 
             If ShowError Then
                 Compiler.Report.ShowMessage(Messages.VBNC30311, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
             End If
             Return False
         End If
 
         toTG = TryCast(DestinationType, GenericParameter)
         If toTG IsNot Nothing Then
             '?	From Object to a type parameter.
             '?	From an interface type to a type parameter.
             If Helper.CompareType(FromType, TypeCache.System_Object) OrElse (fromTD IsNot Nothing AndAlso fromTD.IsInterface) Then
                 If isStrict Then
                     If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30512, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                     Return False
                 End If
                 If CreateConversionExpression Then
                     convExpr = New CTypeExpression(Parent, FromExpression, DestinationType, CTypeConversionType.MS_VB_CS_Conversions_ToGenericParameter)
                     If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                 End If
                 Return True
             End If
         End If
 
         'Reference (narrowing) conversions
         If fromTD IsNot Nothing AndAlso toTD IsNot Nothing Then
             If ((fromTD.IsInterface OrElse fromTD.IsClass) AndAlso fromTD.IsValueType = False) AndAlso (toTD.IsInterface OrElse toTD.IsClass) AndAlso toTD.IsValueType = False Then
                 '?	From a reference type to a more derived type.
                 If Helper.IsSubclassOf(FromType, DestinationType) Then
                     If isStrict Then
                         If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30512, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                         Return False
                     End If
                     convExpr = New CTypeExpression(Parent, FromExpression, DestinationType, CTypeConversionType.Castclass)
                     If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                     Return True
                 End If
                 '?	From a class type to an interface type, provided the class type does not implement the interface type or an interface type variant compatible with it.
                 '?	From an interface type to a class type. 
                 '?	From an interface type to another interface type, provided there is no inheritance relationship between the two types and provided they are not variant compatible.
                 'Put those 3 conditions in one bug chunk here
                 If fromTD.IsInterface OrElse toTD.IsInterface Then
                     If isStrict Then
                         If ShowError Then Compiler.Report.ShowMessage(Messages.VBNC30512, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                         Return False
                     End If
                     If CreateConversionExpression Then
                         convExpr = New CTypeExpression(Parent, FromExpression, DestinationType, CTypeConversionType.Castclass)
                         If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
                     End If
                     Return True
                 End If
             End If
         End If
 
         'Check user defined operators
         If fromTD IsNot Nothing AndAlso toTD IsNot Nothing AndAlso _
             ((fromTC = TypeCode.Object AndAlso Helper.CompareType(TypeCache.System_Object, DestinationType) = False) OrElse _
                 (toTC = TypeCode.Object AndAlso Helper.CompareType(TypeCache.System_Object, DestinationType) = False)) Then
             'user-defined operators can only exist if either the from or to type aren't intrinsic types
 
             Dim ops As Generic.List(Of MethodReference)
             Dim isNarrowing As Boolean
             ops = Helper.GetWideningConversionOperators(Compiler, FromType, DestinationType)
 
             If ops Is Nothing OrElse ops.Count = 0 Then
                 ops = Helper.GetNarrowingConversionOperators(Compiler, FromType, DestinationType)
                 isNarrowing = True
             End If
 
             If ops Is Nothing OrElse ops.Count = 0 Then
                 If ShowError Then
                     If isFromNullable AndAlso isToNullable AndAlso Compiler.TypeResolver.IsExplicitlyConvertible(Compiler, Helper.GetTypeCode(Compiler, CecilHelper.GetNulledType(FromType)), Helper.GetTypeCode(Compiler, CecilHelper.GetNulledType(DestinationType))) Then
                         Compiler.Report.ShowMessage(Messages.VBNC30512, FromExpression.Location, Helper.ToString(FromExpression, FromType), Helper.ToString(FromExpression, DestinationType))
                     Else
                         Compiler.Report.ShowMessage(Messages.VBNC30311, FromExpression.Location, Helper.ToString(FromExpression, FromType), Helper.ToString(FromExpression, DestinationType))
                     End If
                 End If
                 Return False
             End If
 
             If ops.Count > 1 Then
                 If ShowError Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC30311, FromExpression.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                 End If
                 Return False
             End If
 
             If isNarrowing AndAlso isStrict.Value Then
                 If ShowError Then
                     Return Compiler.Report.ShowMessage(Messages.VBNC30512, FromExpression.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                 End If
                 Return False
             End If
 
             If CreateConversionExpression Then
                 convExpr = New CTypeExpression(Parent, FromExpression, DestinationType, CTypeConversionType.UserDefinedOperator)
                 DirectCast(convExpr, CTypeExpression).ConversionMethod = ops(0)
                 If Not convExpr.ResolveExpression(ResolveInfo.Default(Compiler)) Then Return False
             End If
             Return True
         End If
 
 
         If ShowError Then
             If Helper.CompareType(TypeCache.System_DBNull, DestinationType) Then
                 Compiler.Report.ShowMessage(Messages.VBNC30311, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
             ElseIf Helper.CompareType(TypeCache.System_Char, FromType) Then
                 If Helper.CompareType(TypeCache.System_DateTime, DestinationType) OrElse Helper.CompareType(TypeCache.System_Double, DestinationType) OrElse Helper.CompareType(TypeCache.System_Single, DestinationType) OrElse Helper.CompareType(TypeCache.System_Decimal, DestinationType) OrElse Helper.Compare(TypeCache.System_Boolean, DestinationType) Then
                     Compiler.Report.ShowMessage(Messages.VBNC30311, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                 Else
                     Compiler.Report.ShowMessage(Messages.VBNC32006, Parent.Location, Helper.ToString(Compiler, DestinationType))
                 End If
             ElseIf Helper.CompareType(TypeCache.System_Char, DestinationType) Then
                 If Helper.CompareType(TypeCache.System_Decimal, FromType) OrElse Helper.CompareType(TypeCache.System_Double, FromType) OrElse Helper.CompareType(TypeCache.System_Single, FromType) OrElse Helper.CompareType(TypeCache.System_DBNull, FromType) OrElse Helper.CompareType(TypeCache.System_DateTime, FromType) OrElse Helper.CompareType(TypeCache.System_Boolean, FromType) Then
                     Compiler.Report.ShowMessage(Messages.VBNC30311, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
                 Else
                     Compiler.Report.ShowMessage(Messages.VBNC32007, Parent.Location, Helper.ToString(Compiler, FromType))
                 End If
             ElseIf Helper.CompareType(TypeCache.System_DateTime, FromType) AndAlso Helper.CompareType(TypeCache.System_Double, DestinationType) Then
                 Compiler.Report.ShowMessage(Messages.VBNC30532, Parent.Location)
             ElseIf Helper.CompareType(TypeCache.System_DateTime, DestinationType) AndAlso Helper.CompareType(TypeCache.System_Double, FromType) Then
                 Compiler.Report.ShowMessage(Messages.VBNC30533, Parent.Location)
             Else
                 Compiler.Report.ShowMessage(Messages.VBNC30311, Parent.Location, Helper.ToString(Compiler, FromType), Helper.ToString(Compiler, DestinationType))
             End If
         End If
         Return False
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeCache.vb" startline="876" endline="986">
<![CDATA[
 
     Public Overrides Sub InitInternalVBMembers()
         MS_VB_Information__IsNumeric = GetMethod(MS_VB_Information, "IsNumeric", System_Object)
         MS_VB_Information__SystemTypeName = GetMethod(MS_VB_Information, "SystemTypeName", System_String)
         MS_VB_Information__TypeName = GetMethod(MS_VB_Information, "TypeName", System_Object)
         MS_VB_Information__VbTypeName = GetMethod(MS_VB_Information, "VbTypeName", System_String)
         MS_VB_Interaction__CallByName = GetMethod(MS_VB_Interaction, "CallByName", System_Object, System_String, MS_VB_CallType, System_Object_Array)
         MS_VB_CS_Versioned__IsNumeric = GetMethod(MS_VB_CS_Versioned, "IsNumeric", System_Object)
         MS_VB_CS_Versioned__SystemTypeName = GetMethod(MS_VB_CS_Versioned, "SystemTypeName", System_String)
         MS_VB_CS_Versioned__TypeName = GetMethod(MS_VB_CS_Versioned, "TypeName", System_Object)
         MS_VB_CS_Versioned__VbTypeName = GetMethod(MS_VB_CS_Versioned, "VbTypeName", System_String)
         MS_VB_CS_Versioned__CallByName = GetMethod(MS_VB_CS_Versioned, "CallByName", System_Object, System_String, MS_VB_CallType, System_Object_Array)
         MS_VB_CS_StaticLocalInitFlag__State = GetField(MS_VB_CS_StaticLocalInitFlag, "State")
         MS_VB_CS_StaticLocalInitFlag__ctor = GetConstructor(MS_VB_CS_StaticLocalInitFlag)
         MS_VB_CS_IncompleteInitialization__ctor = GetConstructor(MS_VB_CS_IncompleteInitialization)
         MS_VB_CS_NewLateBinding__LateGet_Object_Type_String_Array_Array_Array_Array = GetMethod(MS_VB_CS_NewLateBinding, "LateGet", System_Object, System_Type, System_String, System_Object_Array, System_String_Array, System_Type_Array, System_Boolean_Array)
         MS_VB_CS_NewLateBinding__LateSet_Object_Type_String_Array_Array_Array = GetMethod(MS_VB_CS_NewLateBinding, "LateSet", System_Object, System_Type, System_String, System_Object_Array, System_String_Array, System_Type_Array)
         MS_VB_CS_NewLateBinding__LateIndexGet_Object_Array_Array = GetMethod(MS_VB_CS_NewLateBinding, "LateIndexGet", System_Object, System_Object_Array, System_String_Array)
         MS_VB_CS_NewLateBinding__LateIndexSet_Object_Array_Array = GetMethod(MS_VB_CS_NewLateBinding, "LateIndexSet", System_Object, System_Object_Array, System_String_Array)
         MS_VB_CS_NewLateBinding__LateCall_Object_Type_String_Array_Array_Array_Array_Boolean = GetMethod(MS_VB_CS_NewLateBinding, "LateCall", System_Object, System_Type, System_String, System_Object_Array, System_String_Array, System_Type_Array, System_Boolean_Array, System_Boolean)
         MS_VB_CS_ProjectData__EndApp = GetMethod(MS_VB_CS_ProjectData, "EndApp")
         MS_VB_CS_ProjectData__CreateProjectError_Int32 = GetMethod(MS_VB_CS_ProjectData, "CreateProjectError", System_Int32)
         MS_VB_CS_ProjectData__ClearProjectError = GetMethod(MS_VB_CS_ProjectData, "ClearProjectError")
         MS_VB_CS_ProjectData__SetProjectError_Exception = GetMethod(MS_VB_CS_ProjectData, "SetProjectError", System_Exception)
         MS_VB_CS_ProjectData__SetProjectError_Exception_Int32 = GetMethod(MS_VB_CS_ProjectData, "SetProjectError", System_Exception, System_Int32)
         MS_VB_CS_Conversions__ToBoolean_Object = GetMethod(MS_VB_CS_Conversions, "ToBoolean", System_Object)
         MS_VB_CS_Conversions__ToChar_Object = GetMethod(MS_VB_CS_Conversions, "ToChar", System_Object)
         MS_VB_CS_Conversions__ToDate_Object = GetMethod(MS_VB_CS_Conversions, "ToDate", System_Object)
         MS_VB_CS_Conversions__ToByte_Object = GetMethod(MS_VB_CS_Conversions, "ToByte", System_Object)
         MS_VB_CS_Conversions__ToSByte_Object = GetMethod(MS_VB_CS_Conversions, "ToSByte", System_Object)
         MS_VB_CS_Conversions__ToShort_Object = GetMethod(MS_VB_CS_Conversions, "ToShort", System_Object)
         MS_VB_CS_Conversions__ToUShort_Object = GetMethod(MS_VB_CS_Conversions, "ToUShort", System_Object)
         MS_VB_CS_Conversions__ToInteger_Object = GetMethod(MS_VB_CS_Conversions, "ToInteger", System_Object)
         MS_VB_CS_Conversions__ToUInteger_Object = GetMethod(MS_VB_CS_Conversions, "ToUInteger", System_Object)
         MS_VB_CS_Conversions__ToLong_Object = GetMethod(MS_VB_CS_Conversions, "ToLong", System_Object)
         MS_VB_CS_Conversions__ToULong_Object = GetMethod(MS_VB_CS_Conversions, "ToULong", System_Object)
         MS_VB_CS_Conversions__ToSingle_Object = GetMethod(MS_VB_CS_Conversions, "ToSingle", System_Object)
         MS_VB_CS_Conversions__ToDouble_Object = GetMethod(MS_VB_CS_Conversions, "ToDouble", System_Object)
         MS_VB_CS_Conversions__ToDecimal_Object = GetMethod(MS_VB_CS_Conversions, "ToDecimal", System_Object)
         MS_VB_CS_Conversions__ToBoolean_String = GetMethod(MS_VB_CS_Conversions, "ToBoolean", System_String)
         MS_VB_CS_Conversions__ToChar_String = GetMethod(MS_VB_CS_Conversions, "ToChar", System_String)
         MS_VB_CS_Conversions__ToDate_String = GetMethod(MS_VB_CS_Conversions, "ToDate", System_String)
         MS_VB_CS_Conversions__ToByte_String = GetMethod(MS_VB_CS_Conversions, "ToByte", System_String)
         MS_VB_CS_Conversions__ToSByte_String = GetMethod(MS_VB_CS_Conversions, "ToSByte", System_String)
         MS_VB_CS_Conversions__ToShort_String = GetMethod(MS_VB_CS_Conversions, "ToShort", System_String)
         MS_VB_CS_Conversions__ToUShort_String = GetMethod(MS_VB_CS_Conversions, "ToUShort", System_String)
         MS_VB_CS_Conversions__ToInteger_String = GetMethod(MS_VB_CS_Conversions, "ToInteger", System_String)
         MS_VB_CS_Conversions__ToUInteger_String = GetMethod(MS_VB_CS_Conversions, "ToUInteger", System_String)
         MS_VB_CS_Conversions__ToLong_String = GetMethod(MS_VB_CS_Conversions, "ToLong", System_String)
         MS_VB_CS_Conversions__ToULong_String = GetMethod(MS_VB_CS_Conversions, "ToULong", System_String)
         MS_VB_CS_Conversions__ToSingle_String = GetMethod(MS_VB_CS_Conversions, "ToSingle", System_String)
         MS_VB_CS_Conversions__ToDouble_String = GetMethod(MS_VB_CS_Conversions, "ToDouble", System_String)
         MS_VB_CS_Conversions__ToDecimal_String = GetMethod(MS_VB_CS_Conversions, "ToDecimal", System_String)
         MS_VB_CS_Conversions__ToDecimal_Boolean = GetMethod(MS_VB_CS_Conversions, "ToDecimal", System_Boolean)
         MS_VB_CS_Conversions__ToString_Decimal = GetMethod(MS_VB_CS_Conversions, "ToString", System_Decimal)
         MS_VB_CS_Conversions__ToString_Boolean = GetMethod(MS_VB_CS_Conversions, "ToString", System_Boolean)
         MS_VB_CS_Conversions__ToString_Char = GetMethod(MS_VB_CS_Conversions, "ToString", System_Char)
         MS_VB_CS_Conversions__ToString_DateTime = GetMethod(MS_VB_CS_Conversions, "ToString", System_DateTime)
         MS_VB_CS_Conversions__ToString_Byte = GetMethod(MS_VB_CS_Conversions, "ToString", System_Byte)
         MS_VB_CS_Conversions__ToString_Int32 = GetMethod(MS_VB_CS_Conversions, "ToString", System_Int32)
         MS_VB_CS_Conversions__ToString_UInt32 = GetMethod(MS_VB_CS_Conversions, "ToString", System_UInt32)
         MS_VB_CS_Conversions__ToString_Int64 = GetMethod(MS_VB_CS_Conversions, "ToString", System_Int64)
         MS_VB_CS_Conversions__ToString_UInt64 = GetMethod(MS_VB_CS_Conversions, "ToString", System_UInt64)
         MS_VB_CS_Conversions__ToString_Single = GetMethod(MS_VB_CS_Conversions, "ToString", System_Single)
         MS_VB_CS_Conversions__ToString_Double = GetMethod(MS_VB_CS_Conversions, "ToString", System_Double)
         MS_VB_CS_Conversions__ToString_Object = GetMethod(MS_VB_CS_Conversions, "ToString", System_Object)
         MS_VB_CS_Conversions__ToGenericParameter_Object = GetMethod(MS_VB_CS_Conversions, "ToGenericParameter", System_Object)
         MS_VB_CS_Conversions__ChangeType_Object_Type = GetMethod(MS_VB_CS_Conversions, "ChangeType", System_Object, System_Type)
         MS_VB_CS_Conversions__ToCharArrayRankOne_String = GetMethod(MS_VB_CS_Conversions, "ToCharArrayRankOne", System_String)
         MS_VB_CS_LikeOperator__LikeString_String_String_CompareMethod = GetMethod(MS_VB_CS_LikeOperator, "LikeString", System_String, System_String, MS_VB_CompareMethod)
         MS_VB_CS_LikeOperator__LikeObject_Object_Object_CompareMethod = GetMethod(MS_VB_CS_LikeOperator, "LikeObject", System_Object, System_Object, MS_VB_CompareMethod)
         MS_VB_CS_StringType__MidStmtStr_String_Int32_Int32_String = GetMethod(MS_VB_CS_StringType, "MidStmtStr", System_String_ByRef, System_Int32, System_Int32, System_String)
         MS_VB_CS_ObjectFlowControl__CheckForSyncLockOnValueType_Object = GetMethod(MS_VB_CS_ObjectFlowControl, "CheckForSyncLockOnValueType", System_Object)
         MS_VB_CS_ObjectFlowControl_ForLoopControl__ForLoopInitObj_Object_Object_Object_Object_Object_Object = GetMethod(MS_VB_CS_ObjectFlowControl_ForLoopControl, "ForLoopInitObj", System_Object, System_Object, System_Object, System_Object, System_Object_ByRef, System_Object_ByRef)
         MS_VB_CS_ObjectFlowControl_ForLoopControl__ForNextCheckDec_Decimal_Decimal_Decimal = GetMethod(MS_VB_CS_ObjectFlowControl_ForLoopControl, "ForNextCheckDec", System_Decimal, System_Decimal, System_Decimal)
         MS_VB_CS_ObjectFlowControl_ForLoopControl__ForNextCheckObj_Object_Object_Object = GetMethod(MS_VB_CS_ObjectFlowControl_ForLoopControl, "ForNextCheckObj", System_Object, System_Object, System_Object_ByRef)
         MS_VB_CS_ObjectFlowControl_ForLoopControl__ForNextCheckR4_Single_Single_Single = GetMethod(MS_VB_CS_ObjectFlowControl_ForLoopControl, "ForNextCheckR4", System_Single, System_Single, System_Single)
         MS_VB_CS_ObjectFlowControl_ForLoopControl__ForNextCheckR8_Double_Double_Double = GetMethod(MS_VB_CS_ObjectFlowControl_ForLoopControl, "ForNextCheckR8", System_Double, System_Double, System_Double)
         MS_VB_CS_Utils__CopyArray_Array_Array = GetMethod(MS_VB_CS_Utils, "CopyArray", System_Array, System_Array)
         MS_VB_CS_Operators__ConditionalCompareObjectEqual_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "ConditionalCompareObjectEqual", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__ConditionalCompareObjectNotEqual_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "ConditionalCompareObjectNotEqual", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__ConditionalCompareObjectGreater_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "ConditionalCompareObjectGreater", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__ConditionalCompareObjectGreaterEqual_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "ConditionalCompareObjectGreaterEqual", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__ConditionalCompareObjectLess_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "ConditionalCompareObjectLess", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__ConditionalCompareObjectLessEqual_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "ConditionalCompareObjectLessEqual", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__CompareString_String_String_Boolean = GetMethod(MS_VB_CS_Operators, "CompareString", System_String, System_String, System_Boolean)
         MS_VB_CS_Operators__ConcatenateObject_Object_Object = GetMethod(MS_VB_CS_Operators, "ConcatenateObject", System_Object, System_Object)
         MS_VB_CS_Operators__AddObject_Object_Object = GetMethod(MS_VB_CS_Operators, "AddObject", System_Object, System_Object)
         MS_VB_CS_Operators__AndObject_Object_Object = GetMethod(MS_VB_CS_Operators, "AndObject", System_Object, System_Object)
         MS_VB_CS_Operators__DivideObject_Object_Object = GetMethod(MS_VB_CS_Operators, "DivideObject", System_Object, System_Object)
         MS_VB_CS_Operators__ExponentObject_Object_Object = GetMethod(MS_VB_CS_Operators, "ExponentObject", System_Object, System_Object)
         MS_VB_CS_Operators__IntDivideObject_Object_Object = GetMethod(MS_VB_CS_Operators, "IntDivideObject", System_Object, System_Object)
         MS_VB_CS_Operators__LeftShiftObject_Object_Object = GetMethod(MS_VB_CS_Operators, "LeftShiftObject", System_Object, System_Object)
         MS_VB_CS_Operators__ModObject_Object_Object = GetMethod(MS_VB_CS_Operators, "ModObject", System_Object, System_Object)
         MS_VB_CS_Operators__MultiplyObject_Object_Object = GetMethod(MS_VB_CS_Operators, "MultiplyObject", System_Object, System_Object)
         MS_VB_CS_Operators__NegateObject_Object = GetMethod(MS_VB_CS_Operators, "NegateObject", System_Object)
         MS_VB_CS_Operators__NotObject_Object = GetMethod(MS_VB_CS_Operators, "NotObject", System_Object)
         MS_VB_CS_Operators__OrObject_Object_Object = GetMethod(MS_VB_CS_Operators, "OrObject", System_Object, System_Object)
         MS_VB_CS_Operators__PlusObject_Object = GetMethod(MS_VB_CS_Operators, "PlusObject", System_Object)
         MS_VB_CS_Operators__RightShiftObject_Object_Object = GetMethod(MS_VB_CS_Operators, "RightShiftObject", System_Object, System_Object)
         MS_VB_CS_Operators__SubtractObject_Object_Object = GetMethod(MS_VB_CS_Operators, "SubtractObject", System_Object, System_Object)
         MS_VB_CS_Operators__XorObject_Object_Object = GetMethod(MS_VB_CS_Operators, "XorObject", System_Object, System_Object)
         MS_VB_CS_Operators__LikeObject_Object_Object_CompareMethod = GetMethod(MS_VB_CS_Operators, "LikeObject", System_Object, System_Object, MS_VB_CompareMethod)
         MS_VB_CS_Operators__LikeString_String_String_CompareMethod = GetMethod(MS_VB_CS_Operators, "LikeString", System_String, System_String, MS_VB_CompareMethod)
         MS_VB_CS_Operators__CompareObjectEqual_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "CompareObjectEqual", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__CompareObjectNotEqual_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "CompareObjectNotEqual", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__CompareObjectGreater_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "CompareObjectGreater", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__CompareObjectGreaterEqual_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "CompareObjectGreaterEqual", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__CompareObjectLess_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "CompareObjectLess", System_Object, System_Object, System_Boolean)
         MS_VB_CS_Operators__CompareObjectLessEqual_Object_Object_Boolean = GetMethod(MS_VB_CS_Operators, "CompareObjectLessEqual", System_Object, System_Object, System_Boolean)
     End Sub
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="3" nfragments="4" Csharpe_files="0" vb_files="4" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MyGenerator.vb" startline="356" endline="435">
<![CDATA[
 
     Function GenerateMyWebServices() As Boolean
         Dim result As Boolean = True
         Dim _MyWebServicesDefine As Define
         Dim _MyWebServices As Boolean
 
         _MyWebServicesDefine = Compiler.CommandLine.Define("_MYWEBSERVICES")
         If _MyWebServicesDefine Is Nothing Then
             Select Case m_MyType
                 Case MyTypes.Console, MyTypes.WindowsFormsWithCustomSubMain, MyTypes.Windows, MyTypes.WindowsForms, MyTypes.WebControl
                     _MyWebServices = True
                 Case Else
                     _MyWebServices = False
             End Select
         Else
             _MyWebServices = CBool(_MyWebServicesDefine.Value)
         End If
 
         If Not _MyWebServices Then Return True
 
         Dim code As String = VB.vbNewLine & _
        "        <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "        <Global.Microsoft.VisualBasic.MyGroupCollection(""System.Web.Services.Protocols.SoapHttpClientProtocol"", ""Create__Instance__"", ""Dispose__Instance__"", """")> _" & VB.vbNewLine & _
        "        Friend NotInheritable Class MyWebServices" & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Public Sub New()" & VB.vbNewLine & _
        "            End Sub" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Private Shared Function Create__Instance__(Of T As New)(ByVal instance As T) As T" & VB.vbNewLine & _
        "                If (instance Is Nothing) Then" & VB.vbNewLine & _
        "                    Return Global.System.Activator.CreateInstance(Of T)" & VB.vbNewLine & _
        "                End If" & VB.vbNewLine & _
        "                Return instance" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Private Sub Dispose__Instance__(Of T)(ByRef instance As T)" & VB.vbNewLine & _
        "                instance = CType(Nothing, T)" & VB.vbNewLine & _
        "            End Sub" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function Equals(ByVal o As Object) As Boolean" & VB.vbNewLine & _
        "                Return MyBase.Equals(Global.System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(o))" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function GetHashCode() As Integer" & VB.vbNewLine & _
        "             Return MyBase.GetHashCode" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Friend Overloads Function [GetType]() As Type" & VB.vbNewLine & _
        "                Return GetType(MyWebServices)" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function ToString() As String" & VB.vbNewLine & _
        "                Return MyBase.ToString" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "        End Class" & VB.vbNewLine & _
        ""
         ProjectCode.Append(code)
 
         ProjectCode.AppendLine("        Private Shared ReadOnly m_MyWebServicesObjectProvider As ThreadSafeObjectProvider(Of MyWebServices) = New ThreadSafeObjectProvider(Of MyWebServices)")
         ProjectCode.AppendLine("        <Global.System.ComponentModel.Design.HelpKeyword(""My.WebServices"")> _")
         ProjectCode.AppendLine("        Friend Shared ReadOnly Property WebServices As MyWebServices")
         ProjectCode.AppendLine("            <Global.System.Diagnostics.DebuggerHidden()> _")
         ProjectCode.AppendLine("            Get")
         ProjectCode.AppendLine("                Return m_MyWebServicesObjectProvider.GetInstance")
         ProjectCode.AppendLine("            End Get")
         ProjectCode.AppendLine("        End Property")
 
         Return result
     End Function
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\TypeConverter.vb" startline="42" endline="332">
<![CDATA[
     Public Shared LikeDefinedTypes As String = "S"
     Public Shared LikeResultType As String = "" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXBBBBBBBBBBBBBB-B" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "XBXDDDDDDDDDDDDDD-D" & _
             "-------------------" & _
             "XBXDDDDDDDDDDDDDD-D"
     Public Shared LikeOperandType As String = "" & _
                 "XXXXXXXXXXXXXXXXX-X" & _
                 "XBXBBBBBBBBBBBBBB-B" & _
                 "XXXXXXXXXXXXXXXXX-X" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "XBXSSSSSSSSSSSSSS-S" & _
                 "-------------------" & _
                 "XBXSSSSSSSSSSSSSS-S"
 
     Public Shared ConcatResultType As String = LikeOperandType
     Public Shared ConcatDefinedTypes As String = "S"
     Public Shared ConcatOperandType As String = LikeOperandType
 
     Public Shared ModResultType As String = "" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXBXBBBBBBBBBBBX-B" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXHXFHHJJLLPNOPX-O" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXFXFHHJJLLPNOPX-O" & _
             "XBXHXHGHIJKLMNOPX-O" & _
             "XBXHXHHHJJLLPNOPX-O" & _
             "XBXJXJIJIJKLMNOPX-O" & _
             "XBXJXJJJJJLLPNOPX-O" & _
             "XBXLXLKLKLKLMNOPX-O" & _
             "XBXLXLLLLLLLPNOPX-O" & _
             "XBXPXPMPMPMPMNOPX-O" & _
             "XBXNXNNNNNNNNNONX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXPXPPPPPPPPNOPX-O" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "-------------------" & _
             "XBXOXOOOOOOOOOOOX-O"
     Public Shared ModDefinedTypes As String = "FGHIJKLMNOP"
 
     Public Shared IntDivResultTypes As String = "" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXBXBBBBBBBBBBBX-B" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXHXFHHJJLLLLLLX-L" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXFXFHHJJLLLLLLX-L" & _
             "XBXHXHGHIJKLMLLLX-L" & _
             "XBXHXHHHJJLLLLLLX-L" & _
             "XBXJXJIJIJKLMLLLX-L" & _
             "XBXJXJJJJJLLLLLLX-L" & _
             "XBXLXLKLKLKLMLLLX-L" & _
             "XBXLXLLLLLLLLLLLX-L" & _
             "XBXLXLMLMLMLMLLLX-L" & _
             "XBXLXLLLLLLLLLLLX-L" & _
             "XBXLXLLLLLLLLLLLX-L" & _
             "XBXLXLLLLLLLLLLLX-L" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "-------------------" & _
             "XBXLXLLLLLLLLLLLX-L"
     Public Shared IntDivDefinedTypes As String = "FGHIJKLM"
 
     Public Shared RealDivResultTypes As String = "" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXBXBBBBBBBBBBBX-B" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXOXOOOOOOOONOPX-O" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXOXOOOOOOOONOPX-O" & _
             "XBXOXOOOOOOOONOPX-O" & _
             "XBXOXOOOOOOOONOPX-O" & _
             "XBXOXOOOOOOOONOPX-O" & _
             "XBXOXOOOOOOOONOPX-O" & _
             "XBXOXOOOOOOOONOPX-O" & _
             "XBXOXOOOOOOOONOPX-O" & _
             "XBXOXOOOOOOOONOPX-O" & _
             "XBXNXNNNNNNNNNONX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXPXPPPPPPPPNOPX-O" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "-------------------" & _
             "XBXOXOOOOOOOOOOOX-O"
     Public Shared RealDivDefinedTypes As String = "NOP"
 
     Public Shared AddResultType As String = "" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXBBBBBBBBBBBBBB-B" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXHXFHHJJLLPNOPX-O" & _
             "XBXXSXXXXXXXXXXXX-S" & _
             "XBXFXFHHJJLLPNOPX-O" & _
             "XBXHXHGHIJKLMNOPX-O" & _
             "XBXHXHHHJJLLPNOPX-O" & _
             "XBXJXJIJIJKLMNOPX-O" & _
             "XBXJXJJJJJLLPNOPX-O" & _
             "XBXLXLKLKLKLMNOPX-O" & _
             "XBXLXLLLLLLLPNOPX-O" & _
             "XBXPXPMPMPMPMNOPX-O" & _
             "XBXNXNNNNNNNNNONX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXPXPPPPPPPPNOPX-O" & _
             "XBXXXXXXXXXXXXXXS-S" & _
             "-------------------" & _
             "XBXOSOOOOOOOOOOOS-S"
     Public Shared AddDefinedTypes As String = "FGHIJKLMNOPS"
 
     Public Shared SubResultType As String = "" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXBXBBBBBBBBBBBX-B" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXHXFHHJJLLPNOPX-O" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXFXFHHJJLLPNOPX-O" & _
             "XBXHXHGHIJKLMNOPX-O" & _
             "XBXHXHHHJJLLPNOPX-O" & _
             "XBXJXJIJIJKLMNOPX-O" & _
             "XBXJXJJJJJLLPNOPX-O" & _
             "XBXLXLKLKLKLMNOPX-O" & _
             "XBXLXLLLLLLLPNOPX-O" & _
             "XBXPXPMPMPMPMNOPX-O" & _
             "XBXNXNNNNNNNNNONX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXPXPPPPPPPPNOPX-O" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "-------------------" & _
             "XBXOXOOOOOOOOOOOX-O"
     Public Shared SubDefinedTypes As String = "FGHIJKLMNOP"
 
     Public Shared MultResultType As String = SubResultType
     Public Shared MultDefinedTypes As String = "FGHIJKLMNOP"
 
     Public Shared ShortcircuitResultType As String = "" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXBXBBBBBBBBBBBX-B" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXDXDDDDDDDDDDDX-D" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXDXDDDDDDDDDDDX-D" & _
             "XBXDXDDDDDDDDDDDX-D" & _
             "XBXDXDDDDDDDDDDDX-D" & _
             "XBXDXDDDDDDDDDDDX-D" & _
             "XBXDXDDDDDDDDDDDX-D" & _
             "XBXDXDDDDDDDDDDDX-D" & _
             "XBXDXDDDDDDDDDDDX-D" & _
             "XBXDXDDDDDDDDDDDX-D" & _
             "XBXDXDDDDDDDDDDDX-D" & _
             "XBXDXDDDDDDDDDDDX-D" & _
             "XBXDXDDDDDDDDDDDX-D" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "-------------------" & _
             "XBXDXDDDDDDDDDDDX-D"
     Public Shared ShortcircuitDefinedTypes As String = "D"
 
     Public Shared LogicalOperatorResultType As String = "" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXBXBBBBBBBBBBBX-B" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXDXFHHJJLLLLLLX-D" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXFXFHHJJLLLLLLX-L" & _
             "XBXHXHGHIJKLMLLLX-L" & _
             "XBXHXHHHJJLLLLLLX-L" & _
             "XBXJXJIJIJKLMLLLX-L" & _
             "XBXJXJJJJJLLLLLLX-L" & _
             "XBXLXLKLKLKLMLLLX-L" & _
             "XBXLXLLLLLLLLLLLX-L" & _
             "XBXLXLMLMLMLMLLLX-L" & _
             "XBXLXLLLLLLLLLLLX-L" & _
             "XBXLXLLLLLLLLLLLX-L" & _
             "XBXLXLLLLLLLLLLLX-L" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "-------------------" & _
             "XBXDXLLLLLLLLLLLX-L"
     Public Shared LogicalDefinedTypes As String = "DFGHIJKLM"
 
     Public Shared RelationalOperandTypes As String = _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXBBBBBBBBBBBBBB-B" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXDXFHHJJLLPNOPX-D" & _
             "XBXXEXXXXXXXXXXXX-S" & _
             "XBXFXFHHJJPLPNOPX-O" & _
             "XBXHXHGHIJKLMNOPX-O" & _
             "XBXHXHHHJJPLPNOPX-O" & _
             "XBXJXJIJIJKLMNOPX-O" & _
             "XBXJXJJJJJPLPNOPX-O" & _
             "XBXLXPKPKPKLMNOPX-O" & _
             "XBXLXLLLLLLLPNOPX-O" & _
             "XBXPXPMPMPMPMNOPX-O" & _
             "XBXNXNNNNNNNNNONX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXPXPPPPPPPPNOPX-O" & _
             "XBXXXXXXXXXXXXXXQ-Q" & _
             "-------------------" & _
             "XBXDSOOOOOOOOOOOQ-S"
     Public Shared RelationalDefinedTypes As String = "DEFGHIJKLMNOPQS"
 
 
     Public Shared ExponentResultTypes As String = _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXBXBBBBBBBBBBBX-B" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XBXOXOOOOOOOOOOOX-O" & _
             "XXXXXXXXXXXXXXXXX-X" & _
             "-------------------" & _
             "XBXOXOOOOOOOOOOOX-O"
     Public Shared ExponentDefinedTypes As String = "O"
 
     Public Shared NotOperatorResultType As String = "XBXDXFGHIJKLMLLLX-L"
 
     Public Shared UnaryPlusResultType As String = "XBXHXFGHIJKLMNOPX-O"
 
     Public Shared UnaryMinusResultType As String = "XBXHXFHHJJLLPNOPX-O"
 
     Public Shared ShiftDefinedTypes As String = "FGHIJKLM"
     Public Shared ShiftResultType As String = _
              "XXXXXXXXXXXXXXXXX-X" & _
              "XBXBXBBBBBBBBBBBX-B" & _
              "XXXXXXXXXXXXXXXXX-X" & _
              "XBXHXFGHIJKLMLLLX-L" & _
              "XBXXXXXXXXXXXXXXX-X" & _
              "XBXHXFGHIJKLMLLLX-L" & _
              "XBXHXFGHIJKLMLLLX-L" & _
              "XBXHXFGHIJKLMLLLX-L" & _
              "XBXHXFGHIJKLMLLLX-L" & _
              "XBXHXFGHIJKLMLLLX-L" & _
              "XBXHXFGHIJKLMLLLX-L" & _
              "XBXHXFGHIJKLMLLLX-L" & _
              "XBXHXFGHIJKLMLLLX-L" & _
              "XBXHXFGHIJKLMLLLX-L" & _
              "XBXHXFGHIJKLMLLLX-L" & _
              "XBXHXFGHIJKLMLLLX-L" & _
              "XBXXXXXXXXXXXXXXX-X" & _
              "-------------------" & _
              "XBXHXFGHIJKLMLLLX-L"
 
 
     ''' <summary>
     ''' X=?
     ''' I=Implicit ok
     ''' 0=Explicit ok
     ''' 1=30311
     ''' 2=32007
     ''' 3=30533
     ''' 4=32006
     ''' 5=30532
     ''' 6=30533
     ''' A=30311, only explicit
     ''' </summary>
     ''' <remarks></remarks>
     Public Shared ConversionResultType As String = _
]]>
</clone_fragment>
<clone_fragment file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="59" endline="82">
<![CDATA[
     Public Shared Sub Main(ByVal args As String())
         Console.WriteLine("Chapter 1 example 3
 
         ' step 1
         Dim document As New Document(PageSize.A4.rotate())
 
         ' step 2
         ' we create a writer that listens to the document
         ' and directs a PDF-stream to a file
 
         PdfWriter.getInstance(document, New FileOutputStream("Chap0103.pdf"))
 
         ' step 3
         document.open()
 
         ' step 4
         Dim i As Integer
         For i = 0 To 20
             document.add(New Phrase("Hello World, Hello Sun, Hello Moon, Hello Stars, Hello Sea, Hello Land, Hello People. "))
         Next
 
         ' step 5
         document.close()
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\mono\mono-mono-basic-6bb2ca6\vbnc\vbnc\source\General\MyGenerator.vb" startline="258" endline="355">
<![CDATA[
 
     Function GenerateMyForms() As Boolean
         Dim result As Boolean = True
         Dim _MyFormsDefine As Define
         Dim _MyForms As Boolean
 
         _MyFormsDefine = Compiler.CommandLine.Define("_MYFORMS")
         If _MyFormsDefine Is Nothing Then
             Select Case m_MyType
                 Case MyTypes.WindowsFormsWithCustomSubMain, MyTypes.WindowsForms
                     _MyForms = True
                 Case Else
                     _MyForms = False
             End Select
         Else
             _MyForms = CBool(_MyFormsDefine.Value)
         End If
 
         If Not _MyForms Then Return True
 
         Compiler.CommandLine.References.Add("System.Windows.Forms.dll")
 
         Dim code As String = VB.vbNewLine & _
        "        <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "        <Global.Microsoft.VisualBasic.MyGroupCollection(""System.Windows.Forms.Form"", ""Create__Instance__"", ""Dispose__Instance__"", ""My.MyProject.Forms"")> _" & VB.vbNewLine & _
        "        Friend NotInheritable Class MyForms" & VB.vbNewLine & _
        "            <Global.System.ThreadStatic> _" & VB.vbNewLine & _
        "            Private Shared m_FormBeingCreated As Global.System.Collections.Hashtable" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Public Sub New()" & VB.vbNewLine & _
        "            End Sub" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Private Shared Function Create__Instance__(Of T As {Global.System.Windows.Forms.Form, New})(ByVal Instance As T) As T" & VB.vbNewLine & _
        "                If Instance IsNot Nothing AndAlso Instance.IsDisposed = False" & VB.vbNewLine & _
        "                    Return Instance" & VB.vbNewLine & _
        "                End If" & VB.vbNewLine & _
        "                " & VB.vbNewLine & _
        "                Dim TType As Type = GetType(T)" & VB.vbNewLine & _
        "                If m_FormBeingCreated Is Nothing Then" & VB.vbNewLine & _
        "                    m_FormBeingCreated = New Global.System.Collections.Hashtable()" & VB.vbNewLine & _
        "                ElseIf m_FormBeingCreated.ContainsKey(TType) Then" & VB.vbNewLine & _
        "                    Throw New InvalidOperationException(""There is a reference to a default instance from the constructor of a form, which leads to infinite recursion. Please refer to the form itself using 'Me' from within the constructor."")" & VB.vbNewLine & _
        "                End If" & VB.vbNewLine & _
        "                " & VB.vbNewLine & _
        "                m_FormBeingCreated.Add(TType, Nothing)" & VB.vbNewLine & _
        "                Try" & VB.vbNewLine & _
        "                    Return Global.System.Activator.CreateInstance(Of T)()" & VB.vbNewLine & _
        "                Catch ex As Global.System.Reflection.TargetInvocationException" & VB.vbNewLine & _
        "                    Throw New Global.System.InvalidOperationException(""See inner exception"", ex.InnerException)" & VB.vbNewLine & _
        "                Finally" & VB.vbNewLine & _
        "                    m_FormBeingCreated.Remove(TType)" & VB.vbNewLine & _
        "                End Try" & VB.vbNewLine & _
        "                Return Nothing" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.Diagnostics.DebuggerHidden> _" & VB.vbNewLine & _
        "            Private Sub Dispose__Instance__(Of T As Global.System.Windows.Forms.Form)(ByRef instance As T)" & VB.vbNewLine & _
        "                instance.Dispose()" & VB.vbNewLine & _
        "                instance = CType(Nothing, T)" & VB.vbNewLine & _
        "            End Sub" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function Equals(ByVal o As Object) As Boolean" & VB.vbNewLine & _
        "                Return MyBase.Equals(Global.System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(o))" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function GetHashCode() As Integer" & VB.vbNewLine & _
        "             Return MyBase.GetHashCode" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Friend Overloads Function [GetType]() As Type" & VB.vbNewLine & _
        "                Return GetType(MyForms)" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "            " & VB.vbNewLine & _
        "            <Global.System.ComponentModel.EditorBrowsable(Global.System.ComponentModel.EditorBrowsableState.Never)> _" & VB.vbNewLine & _
        "            Public Overrides Function ToString() As String" & VB.vbNewLine & _
        "                Return MyBase.ToString" & VB.vbNewLine & _
        "            End Function" & VB.vbNewLine & _
        "        End Class" & VB.vbNewLine & _
        ""
         ProjectCode.Append(code)
 
         ProjectCode.AppendLine("        Private Shared m_MyFormsObjectProvider As ThreadSafeObjectProvider(Of MyForms) = New ThreadSafeObjectProvider(Of MyForms)")
         ProjectCode.AppendLine("        <Global.System.ComponentModel.Design.HelpKeyword(""My.Forms"")> _")
         ProjectCode.AppendLine("        Friend Shared ReadOnly Property Forms As MyForms")
         ProjectCode.AppendLine("            <Global.System.Diagnostics.DebuggerHidden()> _")
         ProjectCode.AppendLine("            Get")
         ProjectCode.AppendLine("                Return m_MyFormsObjectProvider.GetInstance")
         ProjectCode.AppendLine("            End Get")
         ProjectCode.AppendLine("        End Property")
 
         Return result
     End Function
]]>
</clone_fragment>
</clone_group>
<clone_group groupid="4" nfragments="8" Csharpe_files="0" vb_files="8" Jsharpe_files="0" CPP_files="0" Fsharpe_files="0">
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmProfiles.vb" startline="15" endline="350">
<![CDATA[
 
     Private components As System.ComponentModel.IContainer
 
     <System.Diagnostics.DebuggerStepThrough()> _
     Private Sub InitializeComponent()
         Me.components = New System.ComponentModel.Container
         Dim resources As System.ComponentModel.ComponentResourceManager = New System.ComponentModel.ComponentResourceManager(GetType(FrmProfiles))
         Me.PnlMain = New System.Windows.Forms.Panel
         Me.BoxProfiles = New ComponentFactory.Krypton.Toolkit.KryptonGroup
         Me.PnlProfiles = New System.Windows.Forms.Panel
         Me.LstProfiles = New System.Windows.Forms.ListView
         Me.ColProfiles = New System.Windows.Forms.ColumnHeader
         Me.ColDate = New System.Windows.Forms.ColumnHeader
         Me.ColDescription = New System.Windows.Forms.ColumnHeader
         Me.ConTxtMnu = New System.Windows.Forms.ContextMenuStrip(Me.components)
         Me.ItmPreview = New System.Windows.Forms.ToolStripMenuItem
         Me.ItmApply = New System.Windows.Forms.ToolStripMenuItem
         Me.Sprtr1 = New System.Windows.Forms.ToolStripSeparator
         Me.ItmValidate = New System.Windows.Forms.ToolStripMenuItem
         Me.ItmEdit = New System.Windows.Forms.ToolStripMenuItem
         Me.ItmDelete = New System.Windows.Forms.ToolStripMenuItem
         Me.Sprtr2 = New System.Windows.Forms.ToolStripSeparator
         Me.ItmImport = New System.Windows.Forms.ToolStripMenuItem
         Me.ItmCreate = New System.Windows.Forms.ToolStripMenuItem
         Me.HdrTasks = New ComponentFactory.Krypton.Toolkit.KryptonHeader
         Me.BtnCreate = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnImport = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnDelete = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnEdit = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnValidate = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnApply = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnPreview = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.LblInfo = New System.Windows.Forms.Label
         Me.BtnClose = New System.Windows.Forms.Button
         Me.BWProfiles = New System.ComponentModel.BackgroundWorker
         Me.HdrMain = New ComponentFactory.Krypton.Toolkit.KryptonHeader
         Me.FileDlg = New System.Windows.Forms.OpenFileDialog
         Me.PnlMain.SuspendLayout()
         CType(Me.BoxProfiles, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.BoxProfiles.Panel, System.ComponentModel.ISupportInitialize).BeginInit()
         Me.BoxProfiles.Panel.SuspendLayout()
         Me.BoxProfiles.SuspendLayout()
         Me.PnlProfiles.SuspendLayout()
         Me.ConTxtMnu.SuspendLayout()
         Me.SuspendLayout()
         '
         'PnlMain
         '
         Me.PnlMain.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
                     Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.PnlMain.BackColor = System.Drawing.Color.White
         Me.PnlMain.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.PnlMain.Controls.Add(Me.BoxProfiles)
         Me.PnlMain.Controls.Add(Me.LblInfo)
         Me.PnlMain.Location = New System.Drawing.Point(-2, 49)
         Me.PnlMain.Name = "PnlMain"
         Me.PnlMain.Size = New System.Drawing.Size(663, 500)
         Me.PnlMain.TabIndex = 1
         '
         'BoxProfiles
         '
         Me.BoxProfiles.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
                     Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.BoxProfiles.GroupBackStyle = ComponentFactory.Krypton.Toolkit.PaletteBackStyle.TabOneNote
         Me.BoxProfiles.Location = New System.Drawing.Point(14, 125)
         Me.BoxProfiles.Name = "BoxProfiles"
         Me.BoxProfiles.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Silver
         '
         'BoxProfiles.Panel
         '
         Me.BoxProfiles.Panel.Controls.Add(Me.PnlProfiles)
         Me.BoxProfiles.Panel.Controls.Add(Me.HdrTasks)
         Me.BoxProfiles.Size = New System.Drawing.Size(630, 340)
         Me.BoxProfiles.StateNormal.Border.DrawBorders = CType((((ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Top Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Left) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Right), ComponentFactory.Krypton.Toolkit.PaletteDrawBorders)
         Me.BoxProfiles.StateNormal.Border.Rounding = 3
         Me.BoxProfiles.TabIndex = 1
         '
         'PnlProfiles
         '
         Me.PnlProfiles.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
                     Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.PnlProfiles.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle
         Me.PnlProfiles.Controls.Add(Me.LstProfiles)
         Me.PnlProfiles.Location = New System.Drawing.Point(16, 50)
         Me.PnlProfiles.Name = "PnlProfiles"
         Me.PnlProfiles.Size = New System.Drawing.Size(595, 270)
         Me.PnlProfiles.TabIndex = 1
         '
         'LstProfiles
         '
         Me.LstProfiles.BackColor = System.Drawing.Color.White
         Me.LstProfiles.BorderStyle = System.Windows.Forms.BorderStyle.None
         Me.LstProfiles.Columns.AddRange(New System.Windows.Forms.ColumnHeader() {Me.ColProfiles, Me.ColDate, Me.ColDescription})
         Me.LstProfiles.ContextMenuStrip = Me.ConTxtMnu
         Me.LstProfiles.Dock = System.Windows.Forms.DockStyle.Fill
         Me.LstProfiles.ForeColor = System.Drawing.Color.Black
         Me.LstProfiles.FullRowSelect = True
         Me.LstProfiles.GridLines = True
         Me.LstProfiles.Location = New System.Drawing.Point(0, 0)
         Me.LstProfiles.MultiSelect = False
         Me.LstProfiles.Name = "LstProfiles"
         Me.LstProfiles.Size = New System.Drawing.Size(593, 268)
         Me.LstProfiles.Sorting = System.Windows.Forms.SortOrder.Ascending
         Me.LstProfiles.TabIndex = 1
         Me.LstProfiles.UseCompatibleStateImageBehavior = False
         Me.LstProfiles.View = System.Windows.Forms.View.Details
         '
         'ColProfiles
         '
         Me.ColProfiles.Text = "Services profile"
         Me.ColProfiles.Width = 125
         '
         'ColDate
         '
         Me.ColDate.Text = "Date created"
         Me.ColDate.Width = 125
         '
         'ColDescription
         '
         Me.ColDescription.Text = "Description"
         Me.ColDescription.Width = 330
         '
         'ConTxtMnu
         '
         Me.ConTxtMnu.Font = New System.Drawing.Font("Segoe UI", 9.0!)
         Me.ConTxtMnu.Items.AddRange(New System.Windows.Forms.ToolStripItem() {Me.ItmPreview, Me.ItmApply, Me.Sprtr1, Me.ItmValidate, Me.ItmEdit, Me.ItmDelete, Me.Sprtr2, Me.ItmImport, Me.ItmCreate})
         Me.ConTxtMnu.Name = "ConTxtMnu"
         Me.ConTxtMnu.ShowItemToolTips = False
         Me.ConTxtMnu.Size = New System.Drawing.Size(136, 170)
         '
         'ItmPreview
         '
         Me.ItmPreview.Name = "ItmPreview"
         Me.ItmPreview.Size = New System.Drawing.Size(135, 22)
         Me.ItmPreview.Text = "Preview"
         '
         'ItmApply
         '
         Me.ItmApply.Name = "ItmApply"
         Me.ItmApply.Size = New System.Drawing.Size(135, 22)
         Me.ItmApply.Text = "Apply"
         '
         'Sprtr1
         '
         Me.Sprtr1.Name = "Sprtr1"
         Me.Sprtr1.Size = New System.Drawing.Size(132, 6)
         '
         'ItmValidate
         '
         Me.ItmValidate.Name = "ItmValidate"
         Me.ItmValidate.Size = New System.Drawing.Size(135, 22)
         Me.ItmValidate.Text = "Validate"
         '
         'ItmEdit
         '
         Me.ItmEdit.Name = "ItmEdit"
         Me.ItmEdit.Size = New System.Drawing.Size(135, 22)
         Me.ItmEdit.Text = "Edit"
         '
         'ItmDelete
         '
         Me.ItmDelete.Name = "ItmDelete"
         Me.ItmDelete.Size = New System.Drawing.Size(135, 22)
         Me.ItmDelete.Text = "Delete"
         '
         'Sprtr2
         '
         Me.Sprtr2.Name = "Sprtr2"
         Me.Sprtr2.Size = New System.Drawing.Size(132, 6)
         '
         'ItmImport
         '
         Me.ItmImport.Name = "ItmImport"
         Me.ItmImport.Size = New System.Drawing.Size(135, 22)
         Me.ItmImport.Text = "Import"
         '
         'ItmCreate
         '
         Me.ItmCreate.Name = "ItmCreate"
         Me.ItmCreate.Size = New System.Drawing.Size(135, 22)
         Me.ItmCreate.Text = "New profile"
         '
         'HdrTasks
         '
         Me.HdrTasks.AllowButtonSpecToolTips = True
         Me.HdrTasks.ButtonSpecs.AddRange(New ComponentFactory.Krypton.Toolkit.ButtonSpecAny() {Me.BtnCreate, Me.BtnImport, Me.BtnDelete, Me.BtnEdit, Me.BtnValidate, Me.BtnApply, Me.BtnPreview})
         Me.HdrTasks.Dock = System.Windows.Forms.DockStyle.Top
         Me.HdrTasks.HeaderStyle = ComponentFactory.Krypton.Toolkit.HeaderStyle.Secondary
         Me.HdrTasks.Location = New System.Drawing.Point(0, 0)
         Me.HdrTasks.Name = "HdrTasks"
         Me.HdrTasks.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Silver
         Me.HdrTasks.Size = New System.Drawing.Size(626, 28)
         Me.HdrTasks.StateNormal.Border.DrawBorders = ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom
         Me.HdrTasks.TabIndex = 0
         Me.HdrTasks.TabStop = False
         Me.HdrTasks.Values.Description = ""
         Me.HdrTasks.Values.Heading = ""
         Me.HdrTasks.Values.Image = Nothing
         '
         'BtnCreate
         '
         Me.BtnCreate.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnCreate.Text = " New profile"
         Me.BtnCreate.ToolTipBody = "Create a new services profile."
         Me.BtnCreate.UniqueName = ""
         '
         'BtnImport
         '
         Me.BtnImport.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnImport.Text = " Import"
         Me.BtnImport.ToolTipBody = "Import an existing services profile."
         Me.BtnImport.UniqueName = ""
         '
         'BtnDelete
         '
         Me.BtnDelete.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnDelete.Text = " Delete"
         Me.BtnDelete.ToolTipBody = "Delete the selected services profile."
         Me.BtnDelete.UniqueName = ""
         '
         'BtnEdit
         '
         Me.BtnEdit.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnEdit.Text = " Edit"
         Me.BtnEdit.ToolTipBody = "Edit the selected services profile."
         Me.BtnEdit.UniqueName = ""
         '
         'BtnValidate
         '
         Me.BtnValidate.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnValidate.Text = " Validate"
         Me.BtnValidate.ToolTipBody = "Validate the selected services profile."
         Me.BtnValidate.UniqueName = ""
         '
         'BtnApply
         '
         Me.BtnApply.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnApply.Text = " Apply"
         Me.BtnApply.ToolTipBody = "Apply the selected services profile."
         Me.BtnApply.UniqueName = ""
         '
         'BtnPreview
         '
         Me.BtnPreview.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnPreview.Text = " Preview"
         Me.BtnPreview.ToolTipBody = "Preview the selected services profile."
         Me.BtnPreview.UniqueName = ""
         '
         'LblInfo
         '
         Me.LblInfo.Anchor = CType(((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.LblInfo.Location = New System.Drawing.Point(16, 23)
         Me.LblInfo.Name = "LblInfo"
         Me.LblInfo.Size = New System.Drawing.Size(620, 85)
         Me.LblInfo.TabIndex = 0
         Me.LblInfo.Text = resources.GetString("LblInfo.Text")
         '
         'BtnClose
         '
         Me.BtnClose.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.BtnClose.Location = New System.Drawing.Point(562, 560)
         Me.BtnClose.Name = "BtnClose"
         Me.BtnClose.Size = New System.Drawing.Size(85, 25)
         Me.BtnClose.TabIndex = 2
         Me.BtnClose.Text = "&Close"
         Me.BtnClose.UseVisualStyleBackColor = True
         '
         'BWProfiles
         '
         Me.BWProfiles.WorkerReportsProgress = True
         Me.BWProfiles.WorkerSupportsCancellation = True
         '
         'HdrMain
         '
         Me.HdrMain.Dock = System.Windows.Forms.DockStyle.Top
         Me.HdrMain.Location = New System.Drawing.Point(0, 0)
         Me.HdrMain.Name = "HdrMain"
         Me.HdrMain.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2007Silver
         Me.HdrMain.Size = New System.Drawing.Size(659, 53)
         Me.HdrMain.StateNormal.Back.Color1 = System.Drawing.Color.White
         Me.HdrMain.StateNormal.Back.Color2 = System.Drawing.Color.Gainsboro
         Me.HdrMain.StateNormal.Back.ColorStyle = ComponentFactory.Krypton.Toolkit.PaletteColorStyle.HalfCut
         Me.HdrMain.StateNormal.Border.DrawBorders = ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom
         Me.HdrMain.StateNormal.Content.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.HdrMain.StateNormal.Content.ShortText.Font = New System.Drawing.Font("Calibri", 27.75!, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.HdrMain.TabIndex = 0
         Me.HdrMain.TabStop = False
         Me.HdrMain.Values.Description = ""
         Me.HdrMain.Values.Heading = " Services Profiles"
         Me.HdrMain.Values.Image = Nothing
         '
         'FileDlg
         '
         Me.FileDlg.DefaultExt = "wsp"
         Me.FileDlg.Filter = "Services Profiles|*.wsp"
         Me.FileDlg.Title = "Import services profile"
         '
         'FrmProfiles
         '
         Me.AutoScaleMode = System.Windows.Forms.AutoScaleMode.None
         Me.ClientSize = New System.Drawing.Size(659, 596)
         Me.ControlBox = False
         Me.Controls.Add(Me.HdrMain)
         Me.Controls.Add(Me.BtnClose)
         Me.Controls.Add(Me.PnlMain)
         Me.DoubleBuffered = True
         Me.Font = New System.Drawing.Font("Segoe UI", 9.0!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.ForeColor = System.Drawing.Color.Black
         Me.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None
         Me.KeyPreview = True
         Me.MaximizeBox = False
         Me.MinimizeBox = False
         Me.Name = "FrmProfiles"
         Me.ShowIcon = False
         Me.ShowInTaskbar = False
         Me.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide
         Me.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen
         Me.Text = "Services Profiles"
         Me.PnlMain.ResumeLayout(False)
         CType(Me.BoxProfiles.Panel, System.ComponentModel.ISupportInitialize).EndInit()
         Me.BoxProfiles.Panel.ResumeLayout(False)
         Me.BoxProfiles.Panel.PerformLayout()
         CType(Me.BoxProfiles, System.ComponentModel.ISupportInitialize).EndInit()
         Me.BoxProfiles.ResumeLayout(False)
         Me.PnlProfiles.ResumeLayout(False)
         Me.ConTxtMnu.ResumeLayout(False)
         Me.ResumeLayout(False)
         Me.PerformLayout()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Classes\SrvcProfile.vb" startline="15" endline="358">
<![CDATA[
 
     Private components As System.ComponentModel.IContainer
 
     <System.Diagnostics.DebuggerStepThrough()> _
     Private Sub InitializeComponent()
         Dim resources As System.ComponentModel.ComponentResourceManager = New System.ComponentModel.ComponentResourceManager(GetType(FrmAbout))
         Me.TabMain = New System.Windows.Forms.TabControl
         Me.TabGeneral = New System.Windows.Forms.TabPage
         Me.BoxSupport = New System.Windows.Forms.GroupBox
         Me.LnkSupport = New ComponentFactory.Krypton.Toolkit.KryptonLinkLabel
         Me.LblSupport = New System.Windows.Forms.Label
         Me.BoxGeneral = New System.Windows.Forms.GroupBox
         Me.LnkEmail = New ComponentFactory.Krypton.Toolkit.KryptonLinkLabel
         Me.LblEmail = New System.Windows.Forms.Label
         Me.LnkInternet = New ComponentFactory.Krypton.Toolkit.KryptonLinkLabel
         Me.LblInternet = New System.Windows.Forms.Label
         Me.LblVersion = New System.Windows.Forms.Label
         Me.TabComponents = New System.Windows.Forms.TabPage
         Me.BoxComponents = New System.Windows.Forms.GroupBox
         Me.LblComponents = New System.Windows.Forms.Label
         Me.LstComponents = New System.Windows.Forms.ListBox
         Me.TabLicense = New System.Windows.Forms.TabPage
         Me.TxtLicense = New System.Windows.Forms.TextBox
         Me.TabCredits = New System.Windows.Forms.TabPage
         Me.TxtCredits = New System.Windows.Forms.TextBox
         Me.PnlMain = New System.Windows.Forms.Panel
         Me.BtnOK = New System.Windows.Forms.Button
         Me.BtnUpdate = New System.Windows.Forms.Button
         Me.HdrMain = New ComponentFactory.Krypton.Toolkit.KryptonHeader
         Me.TabMain.SuspendLayout()
         Me.TabGeneral.SuspendLayout()
         Me.BoxSupport.SuspendLayout()
         Me.BoxGeneral.SuspendLayout()
         Me.TabComponents.SuspendLayout()
         Me.BoxComponents.SuspendLayout()
         Me.TabLicense.SuspendLayout()
         Me.TabCredits.SuspendLayout()
         Me.PnlMain.SuspendLayout()
         Me.SuspendLayout()
         '
         'TabMain
         '
         Me.TabMain.Controls.Add(Me.TabGeneral)
         Me.TabMain.Controls.Add(Me.TabComponents)
         Me.TabMain.Controls.Add(Me.TabLicense)
         Me.TabMain.Controls.Add(Me.TabCredits)
         Me.TabMain.Location = New System.Drawing.Point(13, 15)
         Me.TabMain.Name = "TabMain"
         Me.TabMain.SelectedIndex = 0
         Me.TabMain.Size = New System.Drawing.Size(400, 266)
         Me.TabMain.TabIndex = 1
         '
         'TabGeneral
         '
         Me.TabGeneral.BackColor = System.Drawing.Color.White
         Me.TabGeneral.Controls.Add(Me.BoxSupport)
         Me.TabGeneral.Controls.Add(Me.BoxGeneral)
         Me.TabGeneral.Location = New System.Drawing.Point(4, 24)
         Me.TabGeneral.Name = "TabGeneral"
         Me.TabGeneral.Padding = New System.Windows.Forms.Padding(3)
         Me.TabGeneral.Size = New System.Drawing.Size(392, 238)
         Me.TabGeneral.TabIndex = 0
         Me.TabGeneral.Text = "General"
         Me.TabGeneral.UseVisualStyleBackColor = True
         '
         'BoxSupport
         '
         Me.BoxSupport.Controls.Add(Me.LnkSupport)
         Me.BoxSupport.Controls.Add(Me.LblSupport)
         Me.BoxSupport.Location = New System.Drawing.Point(11, 126)
         Me.BoxSupport.Name = "BoxSupport"
         Me.BoxSupport.Size = New System.Drawing.Size(370, 100)
         Me.BoxSupport.TabIndex = 2
         Me.BoxSupport.TabStop = False
         Me.BoxSupport.Text = "Support Vista Services Optimizer"
         '
         'LnkSupport
         '
         Me.LnkSupport.LinkBehavior = ComponentFactory.Krypton.Toolkit.KryptonLinkBehavior.HoverUnderline
         Me.LnkSupport.Location = New System.Drawing.Point(13, 68)
         Me.LnkSupport.Name = "LnkSupport"
         Me.LnkSupport.OverrideNotVisited.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkSupport.OverridePressed.ShortText.Color1 = System.Drawing.Color.RoyalBlue
         Me.LnkSupport.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Blue
         Me.LnkSupport.Size = New System.Drawing.Size(218, 20)
         Me.LnkSupport.StateNormal.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkSupport.TabIndex = 1
         Me.LnkSupport.Values.Text = "Contribute to Vista Services Optimizer"
         '
         'LblSupport
         '
         Me.LblSupport.Location = New System.Drawing.Point(13, 28)
         Me.LblSupport.Name = "LblSupport"
         Me.LblSupport.Size = New System.Drawing.Size(340, 30)
         Me.LblSupport.TabIndex = 0
         Me.LblSupport.Text = "Vista Services Optimizer is an open source optimization utility. Please support Vista Services Optimizer to make it better."
         '
         'BoxGeneral
         '
         Me.BoxGeneral.Controls.Add(Me.LnkEmail)
         Me.BoxGeneral.Controls.Add(Me.LblEmail)
         Me.BoxGeneral.Controls.Add(Me.LnkInternet)
         Me.BoxGeneral.Controls.Add(Me.LblInternet)
         Me.BoxGeneral.Controls.Add(Me.LblVersion)
         Me.BoxGeneral.Location = New System.Drawing.Point(11, 15)
         Me.BoxGeneral.Name = "BoxGeneral"
         Me.BoxGeneral.Size = New System.Drawing.Size(370, 105)
         Me.BoxGeneral.TabIndex = 1
         Me.BoxGeneral.TabStop = False
         Me.BoxGeneral.Text = "General Information"
         '
         'LnkEmail
         '
         Me.LnkEmail.LinkBehavior = ComponentFactory.Krypton.Toolkit.KryptonLinkBehavior.HoverUnderline
         Me.LnkEmail.Location = New System.Drawing.Point(58, 72)
         Me.LnkEmail.Name = "LnkEmail"
         Me.LnkEmail.OverrideNotVisited.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkEmail.OverridePressed.ShortText.Color1 = System.Drawing.Color.RoyalBlue
         Me.LnkEmail.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Blue
         Me.LnkEmail.Size = New System.Drawing.Size(160, 20)
         Me.LnkEmail.StateNormal.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkEmail.TabIndex = 2
         Me.LnkEmail.Values.Text = "bug.report_spu@ymail.com"
         '
         'LblEmail
         '
         Me.LblEmail.AutoSize = True
         Me.LblEmail.Location = New System.Drawing.Point(13, 74)
         Me.LblEmail.Name = "LblEmail"
         Me.LblEmail.Size = New System.Drawing.Size(44, 15)
         Me.LblEmail.TabIndex = 0
         Me.LblEmail.Text = "E-mail
         '
         'LnkInternet
         '
         Me.LnkInternet.LinkBehavior = ComponentFactory.Krypton.Toolkit.KryptonLinkBehavior.HoverUnderline
         Me.LnkInternet.Location = New System.Drawing.Point(70, 49)
         Me.LnkInternet.Name = "LnkInternet"
         Me.LnkInternet.OverrideNotVisited.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkInternet.OverridePressed.ShortText.Color1 = System.Drawing.Color.RoyalBlue
         Me.LnkInternet.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Blue
         Me.LnkInternet.Size = New System.Drawing.Size(184, 20)
         Me.LnkInternet.StateNormal.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkInternet.TabIndex = 1
         Me.LnkInternet.Values.Text = "http
         '
         'LblInternet
         '
         Me.LblInternet.AutoSize = True
         Me.LblInternet.Location = New System.Drawing.Point(13, 51)
         Me.LblInternet.Name = "LblInternet"
         Me.LblInternet.Size = New System.Drawing.Size(56, 15)
         Me.LblInternet.TabIndex = 0
         Me.LblInternet.Text = "Web Site
         '
         'LblVersion
         '
         Me.LblVersion.AutoSize = True
         Me.LblVersion.Location = New System.Drawing.Point(13, 28)
         Me.LblVersion.Name = "LblVersion"
         Me.LblVersion.Size = New System.Drawing.Size(94, 15)
         Me.LblVersion.TabIndex = 0
         Me.LblVersion.Text = "Product Version
         '
         'TabComponents
         '
         Me.TabComponents.BackColor = System.Drawing.Color.White
         Me.TabComponents.Controls.Add(Me.BoxComponents)
         Me.TabComponents.Controls.Add(Me.LstComponents)
         Me.TabComponents.Location = New System.Drawing.Point(4, 24)
         Me.TabComponents.Name = "TabComponents"
         Me.TabComponents.Padding = New System.Windows.Forms.Padding(3)
         Me.TabComponents.Size = New System.Drawing.Size(392, 238)
         Me.TabComponents.TabIndex = 1
         Me.TabComponents.Text = "Components"
         Me.TabComponents.UseVisualStyleBackColor = True
         '
         'BoxComponents
         '
         Me.BoxComponents.Controls.Add(Me.LblComponents)
         Me.BoxComponents.Location = New System.Drawing.Point(11, 130)
         Me.BoxComponents.Name = "BoxComponents"
         Me.BoxComponents.Size = New System.Drawing.Size(370, 100)
         Me.BoxComponents.TabIndex = 0
         Me.BoxComponents.TabStop = False
         Me.BoxComponents.Text = "Component Information"
         '
         'LblComponents
         '
         Me.LblComponents.Location = New System.Drawing.Point(13, 26)
         Me.LblComponents.Name = "LblComponents"
         Me.LblComponents.Size = New System.Drawing.Size(345, 65)
         Me.LblComponents.TabIndex = 0
         '
         'LstComponents
         '
         Me.LstComponents.BackColor = System.Drawing.Color.White
         Me.LstComponents.Font = New System.Drawing.Font("Calibri", 9.75!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.LstComponents.ForeColor = System.Drawing.Color.Black
         Me.LstComponents.FormattingEnabled = True
         Me.LstComponents.ItemHeight = 15
         Me.LstComponents.Location = New System.Drawing.Point(11, 15)
         Me.LstComponents.Name = "LstComponents"
         Me.LstComponents.Size = New System.Drawing.Size(370, 109)
         Me.LstComponents.TabIndex = 1
         '
         'TabLicense
         '
         Me.TabLicense.BackColor = System.Drawing.Color.White
         Me.TabLicense.Controls.Add(Me.TxtLicense)
         Me.TabLicense.Location = New System.Drawing.Point(4, 24)
         Me.TabLicense.Name = "TabLicense"
         Me.TabLicense.Size = New System.Drawing.Size(392, 238)
         Me.TabLicense.TabIndex = 2
         Me.TabLicense.Text = "License"
         Me.TabLicense.UseVisualStyleBackColor = True
         '
         'TxtLicense
         '
         Me.TxtLicense.BackColor = System.Drawing.Color.Honeydew
         Me.TxtLicense.Cursor = System.Windows.Forms.Cursors.Arrow
         Me.TxtLicense.Location = New System.Drawing.Point(11, 15)
         Me.TxtLicense.Multiline = True
         Me.TxtLicense.Name = "TxtLicense"
         Me.TxtLicense.ReadOnly = True
         Me.TxtLicense.ScrollBars = System.Windows.Forms.ScrollBars.Vertical
         Me.TxtLicense.ShortcutsEnabled = False
         Me.TxtLicense.Size = New System.Drawing.Size(370, 210)
         Me.TxtLicense.TabIndex = 0
         Me.TxtLicense.TabStop = False
         Me.TxtLicense.Text = resources.GetString("TxtLicense.Text")
         '
         'TabCredits
         '
         Me.TabCredits.BackColor = System.Drawing.Color.White
         Me.TabCredits.Controls.Add(Me.TxtCredits)
         Me.TabCredits.Location = New System.Drawing.Point(4, 24)
         Me.TabCredits.Name = "TabCredits"
         Me.TabCredits.Padding = New System.Windows.Forms.Padding(3)
         Me.TabCredits.Size = New System.Drawing.Size(392, 238)
         Me.TabCredits.TabIndex = 3
         Me.TabCredits.Text = "Credits"
         Me.TabCredits.UseVisualStyleBackColor = True
         '
         'TxtCredits
         '
         Me.TxtCredits.BackColor = System.Drawing.Color.Honeydew
         Me.TxtCredits.Cursor = System.Windows.Forms.Cursors.Arrow
         Me.TxtCredits.Location = New System.Drawing.Point(11, 15)
         Me.TxtCredits.Multiline = True
         Me.TxtCredits.Name = "TxtCredits"
         Me.TxtCredits.ReadOnly = True
         Me.TxtCredits.ScrollBars = System.Windows.Forms.ScrollBars.Vertical
         Me.TxtCredits.ShortcutsEnabled = False
         Me.TxtCredits.Size = New System.Drawing.Size(370, 210)
         Me.TxtCredits.TabIndex = 0
         Me.TxtCredits.TabStop = False
         Me.TxtCredits.Text = resources.GetString("TxtCredits.Text")
         '
         'PnlMain
         '
         Me.PnlMain.BackColor = System.Drawing.Color.White
         Me.PnlMain.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.PnlMain.Controls.Add(Me.TabMain)
         Me.PnlMain.Location = New System.Drawing.Point(-3, 48)
         Me.PnlMain.Name = "PnlMain"
         Me.PnlMain.Size = New System.Drawing.Size(430, 302)
         Me.PnlMain.TabIndex = 1
         '
         'BtnOK
         '
         Me.BtnOK.DialogResult = System.Windows.Forms.DialogResult.OK
         Me.BtnOK.Location = New System.Drawing.Point(236, 357)
         Me.BtnOK.Name = "BtnOK"
         Me.BtnOK.Size = New System.Drawing.Size(85, 25)
         Me.BtnOK.TabIndex = 2
         Me.BtnOK.Text = "&OK"
         Me.BtnOK.UseVisualStyleBackColor = True
         '
         'BtnUpdate
         '
         Me.BtnUpdate.Location = New System.Drawing.Point(327, 357)
         Me.BtnUpdate.Name = "BtnUpdate"
         Me.BtnUpdate.Size = New System.Drawing.Size(85, 25)
         Me.BtnUpdate.TabIndex = 3
         Me.BtnUpdate.Text = "&Update"
         Me.BtnUpdate.UseVisualStyleBackColor = True
         '
         'HdrMain
         '
         Me.HdrMain.Dock = System.Windows.Forms.DockStyle.Top
         Me.HdrMain.Location = New System.Drawing.Point(0, 0)
         Me.HdrMain.Name = "HdrMain"
         Me.HdrMain.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Black
         Me.HdrMain.Size = New System.Drawing.Size(424, 47)
         Me.HdrMain.StateNormal.Back.ColorStyle = ComponentFactory.Krypton.Toolkit.PaletteColorStyle.HalfCut
         Me.HdrMain.StateNormal.Border.DrawBorders = ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom
         Me.HdrMain.StateNormal.Content.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.HdrMain.StateNormal.Content.ShortText.Font = New System.Drawing.Font("Calibri", 24.0!, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.HdrMain.TabIndex = 0
         Me.HdrMain.TabStop = False
         Me.HdrMain.Values.Description = ""
         Me.HdrMain.Values.Heading = " Vista Services Optimizer"
         Me.HdrMain.Values.Image = Nothing
         '
         'FrmAbout
         '
         Me.AcceptButton = Me.BtnOK
         Me.AutoScaleMode = System.Windows.Forms.AutoScaleMode.None
         Me.CancelButton = Me.BtnOK
         Me.ClientSize = New System.Drawing.Size(424, 394)
         Me.Controls.Add(Me.HdrMain)
         Me.Controls.Add(Me.BtnUpdate)
         Me.Controls.Add(Me.BtnOK)
         Me.Controls.Add(Me.PnlMain)
         Me.Font = New System.Drawing.Font("Segoe UI", 9.0!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.ForeColor = System.Drawing.Color.Black
         Me.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle
         Me.HelpButton = True
         Me.MaximizeBox = False
         Me.MinimizeBox = False
         Me.Name = "FrmAbout"
         Me.ShowIcon = False
         Me.ShowInTaskbar = False
         Me.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide
         Me.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent
         Me.Text = "About"
         Me.TabMain.ResumeLayout(False)
         Me.TabGeneral.ResumeLayout(False)
         Me.BoxSupport.ResumeLayout(False)
         Me.BoxSupport.PerformLayout()
         Me.BoxGeneral.ResumeLayout(False)
         Me.BoxGeneral.PerformLayout()
         Me.TabComponents.ResumeLayout(False)
         Me.BoxComponents.ResumeLayout(False)
         Me.TabLicense.ResumeLayout(False)
         Me.TabLicense.PerformLayout()
         Me.TabCredits.ResumeLayout(False)
         Me.TabCredits.PerformLayout()
         Me.PnlMain.ResumeLayout(False)
         Me.ResumeLayout(False)
         Me.PerformLayout()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmSrvcMngr.vb" startline="15" endline="388">
<![CDATA[
 
     Private components As System.ComponentModel.IContainer
 
     <System.Diagnostics.DebuggerStepThrough()> _
     Private Sub InitializeComponent()
         Me.components = New System.ComponentModel.Container
         Me.PnlMain = New System.Windows.Forms.Panel
         Me.SplitPnl = New System.Windows.Forms.SplitContainer
         Me.LstServices = New System.Windows.Forms.ListView
         Me.ColDisplayName = New System.Windows.Forms.ColumnHeader
         Me.ColName = New System.Windows.Forms.ColumnHeader
         Me.ColStatus = New System.Windows.Forms.ColumnHeader
         Me.ColStartup = New System.Windows.Forms.ColumnHeader
         Me.ColCompany = New System.Windows.Forms.ColumnHeader
         Me.ConTxtMnu = New System.Windows.Forms.ContextMenuStrip(Me.components)
         Me.ItmStart = New System.Windows.Forms.ToolStripMenuItem
         Me.ItmStop = New System.Windows.Forms.ToolStripMenuItem
         Me.ItmDelete = New System.Windows.Forms.ToolStripMenuItem
         Me.Sprtr1 = New System.Windows.Forms.ToolStripSeparator
         Me.ItmSearch = New System.Windows.Forms.ToolStripMenuItem
         Me.ItmExport = New System.Windows.Forms.ToolStripMenuItem
         Me.ItmRefresh = New System.Windows.Forms.ToolStripMenuItem
         Me.Sprtr2 = New System.Windows.Forms.ToolStripSeparator
         Me.ItmSnapshot = New System.Windows.Forms.ToolStripMenuItem
         Me.TxtInfo = New System.Windows.Forms.TextBox
         Me.HdrInfo = New ComponentFactory.Krypton.Toolkit.KryptonHeader
         Me.HdrMain = New ComponentFactory.Krypton.Toolkit.KryptonHeader
         Me.BtnSnapshot = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnRefresh = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnExport = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnSearch = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnDelete = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnStartup = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.MnuStartup = New System.Windows.Forms.ContextMenuStrip(Me.components)
         Me.ItmAutomatic = New System.Windows.Forms.ToolStripMenuItem
         Me.ItmManual = New System.Windows.Forms.ToolStripMenuItem
         Me.ItmDisabled = New System.Windows.Forms.ToolStripMenuItem
         Me.BtnStop = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnStart = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnClose = New System.Windows.Forms.Button
         Me.PnlMain.SuspendLayout()
         Me.SplitPnl.Panel1.SuspendLayout()
         Me.SplitPnl.Panel2.SuspendLayout()
         Me.SplitPnl.SuspendLayout()
         Me.ConTxtMnu.SuspendLayout()
         Me.MnuStartup.SuspendLayout()
         Me.SuspendLayout()
         '
         'PnlMain
         '
         Me.PnlMain.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
                     Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.PnlMain.BackColor = System.Drawing.Color.White
         Me.PnlMain.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.PnlMain.Controls.Add(Me.SplitPnl)
         Me.PnlMain.Location = New System.Drawing.Point(-2, 29)
         Me.PnlMain.Name = "PnlMain"
         Me.PnlMain.Size = New System.Drawing.Size(663, 520)
         Me.PnlMain.TabIndex = 1
         '
         'SplitPnl
         '
         Me.SplitPnl.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
                     Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.SplitPnl.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle
         Me.SplitPnl.Location = New System.Drawing.Point(14, 18)
         Me.SplitPnl.Name = "SplitPnl"
         Me.SplitPnl.Orientation = System.Windows.Forms.Orientation.Horizontal
         '
         'SplitPnl.Panel1
         '
         Me.SplitPnl.Panel1.Controls.Add(Me.LstServices)
         Me.SplitPnl.Panel1MinSize = 250
         '
         'SplitPnl.Panel2
         '
         Me.SplitPnl.Panel2.Controls.Add(Me.TxtInfo)
         Me.SplitPnl.Panel2.Controls.Add(Me.HdrInfo)
         Me.SplitPnl.Size = New System.Drawing.Size(630, 480)
         Me.SplitPnl.SplitterDistance = 350
         Me.SplitPnl.TabIndex = 1
         Me.SplitPnl.TabStop = False
         '
         'LstServices
         '
         Me.LstServices.Alignment = System.Windows.Forms.ListViewAlignment.Left
         Me.LstServices.BackColor = System.Drawing.Color.White
         Me.LstServices.BorderStyle = System.Windows.Forms.BorderStyle.None
         Me.LstServices.Columns.AddRange(New System.Windows.Forms.ColumnHeader() {Me.ColDisplayName, Me.ColName, Me.ColStatus, Me.ColStartup, Me.ColCompany})
         Me.LstServices.ContextMenuStrip = Me.ConTxtMnu
         Me.LstServices.Dock = System.Windows.Forms.DockStyle.Fill
         Me.LstServices.ForeColor = System.Drawing.Color.Black
         Me.LstServices.FullRowSelect = True
         Me.LstServices.GridLines = True
         Me.LstServices.HideSelection = False
         Me.LstServices.LabelWrap = False
         Me.LstServices.Location = New System.Drawing.Point(0, 0)
         Me.LstServices.MultiSelect = False
         Me.LstServices.Name = "LstServices"
         Me.LstServices.ShowGroups = False
         Me.LstServices.Size = New System.Drawing.Size(628, 348)
         Me.LstServices.Sorting = System.Windows.Forms.SortOrder.Ascending
         Me.LstServices.TabIndex = 1
         Me.LstServices.UseCompatibleStateImageBehavior = False
         Me.LstServices.View = System.Windows.Forms.View.Details
         '
         'ColDisplayName
         '
         Me.ColDisplayName.Text = "Display name"
         Me.ColDisplayName.Width = 220
         '
         'ColName
         '
         Me.ColName.Text = "Name"
         Me.ColName.Width = 110
         '
         'ColStatus
         '
         Me.ColStatus.Text = "Status"
         Me.ColStatus.Width = 80
         '
         'ColStartup
         '
         Me.ColStartup.Text = "Startup"
         Me.ColStartup.Width = 85
         '
         'ColCompany
         '
         Me.ColCompany.Text = "Company"
         Me.ColCompany.Width = 105
         '
         'ConTxtMnu
         '
         Me.ConTxtMnu.Font = New System.Drawing.Font("Segoe UI", 9.0!)
         Me.ConTxtMnu.Items.AddRange(New System.Windows.Forms.ToolStripItem() {Me.ItmStart, Me.ItmStop, Me.ItmDelete, Me.Sprtr1, Me.ItmSearch, Me.ItmExport, Me.ItmRefresh, Me.Sprtr2, Me.ItmSnapshot})
         Me.ConTxtMnu.Name = "ConTxtMnu"
         Me.ConTxtMnu.ShowItemToolTips = False
         Me.ConTxtMnu.Size = New System.Drawing.Size(160, 170)
         '
         'ItmStart
         '
         Me.ItmStart.Name = "ItmStart"
         Me.ItmStart.Size = New System.Drawing.Size(159, 22)
         Me.ItmStart.Text = "Start"
         '
         'ItmStop
         '
         Me.ItmStop.Name = "ItmStop"
         Me.ItmStop.Size = New System.Drawing.Size(159, 22)
         Me.ItmStop.Text = "Stop"
         '
         'ItmDelete
         '
         Me.ItmDelete.Name = "ItmDelete"
         Me.ItmDelete.Size = New System.Drawing.Size(159, 22)
         Me.ItmDelete.Text = "Delete"
         '
         'Sprtr1
         '
         Me.Sprtr1.Name = "Sprtr1"
         Me.Sprtr1.Size = New System.Drawing.Size(156, 6)
         '
         'ItmSearch
         '
         Me.ItmSearch.Name = "ItmSearch"
         Me.ItmSearch.Size = New System.Drawing.Size(159, 22)
         Me.ItmSearch.Text = "Search"
         '
         'ItmExport
         '
         Me.ItmExport.Name = "ItmExport"
         Me.ItmExport.Size = New System.Drawing.Size(159, 22)
         Me.ItmExport.Text = "Export"
         '
         'ItmRefresh
         '
         Me.ItmRefresh.Name = "ItmRefresh"
         Me.ItmRefresh.Size = New System.Drawing.Size(159, 22)
         Me.ItmRefresh.Text = "Refresh"
         '
         'Sprtr2
         '
         Me.Sprtr2.Name = "Sprtr2"
         Me.Sprtr2.Size = New System.Drawing.Size(156, 6)
         '
         'ItmSnapshot
         '
         Me.ItmSnapshot.Name = "ItmSnapshot"
         Me.ItmSnapshot.Size = New System.Drawing.Size(159, 22)
         Me.ItmSnapshot.Text = "Create snapshot"
         '
         'TxtInfo
         '
         Me.TxtInfo.BackColor = System.Drawing.Color.White
         Me.TxtInfo.BorderStyle = System.Windows.Forms.BorderStyle.None
         Me.TxtInfo.Cursor = System.Windows.Forms.Cursors.Arrow
         Me.TxtInfo.Dock = System.Windows.Forms.DockStyle.Fill
         Me.TxtInfo.ForeColor = System.Drawing.Color.Black
         Me.TxtInfo.Location = New System.Drawing.Point(0, 22)
         Me.TxtInfo.Multiline = True
         Me.TxtInfo.Name = "TxtInfo"
         Me.TxtInfo.ReadOnly = True
         Me.TxtInfo.ScrollBars = System.Windows.Forms.ScrollBars.Vertical
         Me.TxtInfo.Size = New System.Drawing.Size(628, 102)
         Me.TxtInfo.TabIndex = 0
         Me.TxtInfo.TabStop = False
         '
         'HdrInfo
         '
         Me.HdrInfo.Dock = System.Windows.Forms.DockStyle.Top
         Me.HdrInfo.HeaderStyle = ComponentFactory.Krypton.Toolkit.HeaderStyle.Secondary
         Me.HdrInfo.Location = New System.Drawing.Point(0, 0)
         Me.HdrInfo.Name = "HdrInfo"
         Me.HdrInfo.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Silver
         Me.HdrInfo.Size = New System.Drawing.Size(628, 22)
         Me.HdrInfo.StateNormal.Back.ColorStyle = ComponentFactory.Krypton.Toolkit.PaletteColorStyle.HalfCut
         Me.HdrInfo.StateNormal.Border.DrawBorders = ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom
         Me.HdrInfo.StateNormal.Content.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.HdrInfo.StateNormal.Content.ShortText.Font = New System.Drawing.Font("Segoe UI", 9.75!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.HdrInfo.TabIndex = 0
         Me.HdrInfo.TabStop = False
         Me.HdrInfo.Values.Description = ""
         Me.HdrInfo.Values.Heading = "Windows service information"
         Me.HdrInfo.Values.Image = Nothing
         '
         'HdrMain
         '
         Me.HdrMain.AllowButtonSpecToolTips = True
         Me.HdrMain.ButtonSpecs.AddRange(New ComponentFactory.Krypton.Toolkit.ButtonSpecAny() {Me.BtnSnapshot, Me.BtnRefresh, Me.BtnExport, Me.BtnSearch, Me.BtnDelete, Me.BtnStartup, Me.BtnStop, Me.BtnStart})
         Me.HdrMain.Dock = System.Windows.Forms.DockStyle.Top
         Me.HdrMain.HeaderStyle = ComponentFactory.Krypton.Toolkit.HeaderStyle.Secondary
         Me.HdrMain.Location = New System.Drawing.Point(0, 0)
         Me.HdrMain.Name = "HdrMain"
         Me.HdrMain.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Silver
         Me.HdrMain.Size = New System.Drawing.Size(659, 28)
         Me.HdrMain.StateNormal.Back.ColorStyle = ComponentFactory.Krypton.Toolkit.PaletteColorStyle.Switch50
         Me.HdrMain.StateNormal.Border.DrawBorders = ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom
         Me.HdrMain.TabIndex = 0
         Me.HdrMain.TabStop = False
         Me.HdrMain.Values.Description = ""
         Me.HdrMain.Values.Heading = ""
         Me.HdrMain.Values.Image = Nothing
         '
         'BtnSnapshot
         '
         Me.BtnSnapshot.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnSnapshot.Text = " Create snapshot"
         Me.BtnSnapshot.ToolTipBody = "Create services snapshot."
         Me.BtnSnapshot.UniqueName = ""
         '
         'BtnRefresh
         '
         Me.BtnRefresh.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnRefresh.Text = " Refresh"
         Me.BtnRefresh.ToolTipBody = "Refresh Windows services status."
         Me.BtnRefresh.UniqueName = ""
         '
         'BtnExport
         '
         Me.BtnExport.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnExport.Text = " Export"
         Me.BtnExport.ToolTipBody = "Export installed Windows services."
         Me.BtnExport.UniqueName = ""
         '
         'BtnSearch
         '
         Me.BtnSearch.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnSearch.Text = " Search"
         Me.BtnSearch.ToolTipBody = "Search the selected Windows service information."
         Me.BtnSearch.UniqueName = ""
         '
         'BtnDelete
         '
         Me.BtnDelete.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnDelete.Text = " Delete"
         Me.BtnDelete.ToolTipBody = "Delete the selected Windows service."
         Me.BtnDelete.UniqueName = ""
         '
         'BtnStartup
         '
         Me.BtnStartup.ContextMenuStrip = Me.MnuStartup
         Me.BtnStartup.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnStartup.Text = " Startup"
         Me.BtnStartup.ToolTipBody = "Specify the selected Windows service startup."
         Me.BtnStartup.UniqueName = ""
         '
         'MnuStartup
         '
         Me.MnuStartup.Font = New System.Drawing.Font("Segoe UI", 9.0!)
         Me.MnuStartup.Items.AddRange(New System.Windows.Forms.ToolStripItem() {Me.ItmAutomatic, Me.ItmManual, Me.ItmDisabled})
         Me.MnuStartup.Name = "MnuStartup"
         Me.MnuStartup.ShowItemToolTips = False
         Me.MnuStartup.Size = New System.Drawing.Size(131, 70)
         '
         'ItmAutomatic
         '
         Me.ItmAutomatic.AutoToolTip = True
         Me.ItmAutomatic.Name = "ItmAutomatic"
         Me.ItmAutomatic.Size = New System.Drawing.Size(130, 22)
         Me.ItmAutomatic.Text = "Automatic"
         Me.ItmAutomatic.ToolTipText = "Set the selected Windows service to Automatic startup."
         '
         'ItmManual
         '
         Me.ItmManual.Name = "ItmManual"
         Me.ItmManual.Size = New System.Drawing.Size(130, 22)
         Me.ItmManual.Text = "Manual"
         Me.ItmManual.ToolTipText = "Set the selected Windows service to Manual startup."
         '
         'ItmDisabled
         '
         Me.ItmDisabled.Name = "ItmDisabled"
         Me.ItmDisabled.Size = New System.Drawing.Size(130, 22)
         Me.ItmDisabled.Text = "Disabled"
         Me.ItmDisabled.ToolTipText = "Set the selected Windows service to Disabled startup."
         '
         'BtnStop
         '
         Me.BtnStop.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnStop.Text = " Stop"
         Me.BtnStop.ToolTipBody = "Stop the selected Windows service."
         Me.BtnStop.UniqueName = ""
         '
         'BtnStart
         '
         Me.BtnStart.Edge = ComponentFactory.Krypton.Toolkit.PaletteRelativeEdgeAlign.Near
         Me.BtnStart.Text = " Start"
         Me.BtnStart.ToolTipBody = "Start the selected Windows service."
         Me.BtnStart.UniqueName = ""
         '
         'BtnClose
         '
         Me.BtnClose.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.BtnClose.Location = New System.Drawing.Point(562, 560)
         Me.BtnClose.Name = "BtnClose"
         Me.BtnClose.Size = New System.Drawing.Size(85, 25)
         Me.BtnClose.TabIndex = 2
         Me.BtnClose.Text = "&Close"
         Me.BtnClose.UseVisualStyleBackColor = True
         '
         'FrmSrvcMngr
         '
         Me.AutoScaleMode = System.Windows.Forms.AutoScaleMode.None
         Me.ClientSize = New System.Drawing.Size(659, 596)
         Me.ControlBox = False
         Me.Controls.Add(Me.BtnClose)
         Me.Controls.Add(Me.HdrMain)
         Me.Controls.Add(Me.PnlMain)
         Me.DoubleBuffered = True
         Me.Font = New System.Drawing.Font("Segoe UI", 9.0!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.ForeColor = System.Drawing.Color.Black
         Me.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None
         Me.KeyPreview = True
         Me.MaximizeBox = False
         Me.MinimizeBox = False
         Me.Name = "FrmSrvcMngr"
         Me.ShowIcon = False
         Me.ShowInTaskbar = False
         Me.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide
         Me.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen
         Me.Text = "Services Manager"
         Me.PnlMain.ResumeLayout(False)
         Me.SplitPnl.Panel1.ResumeLayout(False)
         Me.SplitPnl.Panel2.ResumeLayout(False)
         Me.SplitPnl.Panel2.PerformLayout()
         Me.SplitPnl.ResumeLayout(False)
         Me.ConTxtMnu.ResumeLayout(False)
         Me.MnuStartup.ResumeLayout(False)
         Me.ResumeLayout(False)
         Me.PerformLayout()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmGameMode.vb" startline="15" endline="544">
<![CDATA[
 
     Private components As System.ComponentModel.IContainer
 
     <System.Diagnostics.DebuggerStepThrough()> _
     Private Sub InitializeComponent()
         Me.components = New System.ComponentModel.Container
         Dim resources As System.ComponentModel.ComponentResourceManager = New System.ComponentModel.ComponentResourceManager(GetType(FrmGameMode))
         Me.BtnSwitch = New System.Windows.Forms.Button
         Me.PnlMain = New System.Windows.Forms.Panel
         Me.BoxProfile = New ComponentFactory.Krypton.Toolkit.KryptonGroup
         Me.PnlProfile = New System.Windows.Forms.Panel
         Me.ChkDefrag = New System.Windows.Forms.CheckBox
         Me.ChkDiagnostics = New System.Windows.Forms.CheckBox
         Me.ChkAero = New System.Windows.Forms.CheckBox
         Me.ChkWinUpdate = New System.Windows.Forms.CheckBox
         Me.ChkScanner = New System.Windows.Forms.CheckBox
         Me.LblFunctions = New System.Windows.Forms.Label
         Me.LblHardware = New System.Windows.Forms.Label
         Me.ChkTabletPC = New System.Windows.Forms.CheckBox
         Me.ChkOther = New System.Windows.Forms.CheckBox
         Me.ChkThemes = New System.Windows.Forms.CheckBox
         Me.ChkNetShare = New System.Windows.Forms.CheckBox
         Me.ChkWinSearch = New System.Windows.Forms.CheckBox
         Me.LblVisEffects = New System.Windows.Forms.Label
         Me.ChkPrinter = New System.Windows.Forms.CheckBox
         Me.ChkMediaCntr = New System.Windows.Forms.CheckBox
         Me.HdrProfile = New ComponentFactory.Krypton.Toolkit.KryptonHeader
         Me.LnkVisEffects = New ComponentFactory.Krypton.Toolkit.KryptonLinkLabel
         Me.LblInfo = New System.Windows.Forms.Label
         Me.LnkTaskMngr = New ComponentFactory.Krypton.Toolkit.KryptonLinkLabel
         Me.LnkGameCntrl = New ComponentFactory.Krypton.Toolkit.KryptonLinkLabel
         Me.LnkDirectX = New ComponentFactory.Krypton.Toolkit.KryptonLinkLabel
         Me.LnkPerfMon = New ComponentFactory.Krypton.Toolkit.KryptonLinkLabel
         Me.LnkPowerOpt = New ComponentFactory.Krypton.Toolkit.KryptonLinkLabel
         Me.LnkMemory = New ComponentFactory.Krypton.Toolkit.KryptonLinkLabel
         Me.LnkDisplaySet = New ComponentFactory.Krypton.Toolkit.KryptonLinkLabel
         Me.HdrMain = New ComponentFactory.Krypton.Toolkit.KryptonHeader
         Me.BtnClose = New System.Windows.Forms.Button
         Me.BWGameMode = New System.ComponentModel.BackgroundWorker
         Me.ToolTip = New System.Windows.Forms.ToolTip(Me.components)
         Me.PnlMain.SuspendLayout()
         CType(Me.BoxProfile, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.BoxProfile.Panel, System.ComponentModel.ISupportInitialize).BeginInit()
         Me.BoxProfile.Panel.SuspendLayout()
         Me.BoxProfile.SuspendLayout()
         Me.PnlProfile.SuspendLayout()
         Me.SuspendLayout()
         '
         'BtnSwitch
         '
         Me.BtnSwitch.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.BtnSwitch.ImageAlign = System.Drawing.ContentAlignment.MiddleLeft
         Me.BtnSwitch.Location = New System.Drawing.Point(465, 165)
         Me.BtnSwitch.Name = "BtnSwitch"
         Me.BtnSwitch.Padding = New System.Windows.Forms.Padding(5, 0, 0, 0)
         Me.BtnSwitch.Size = New System.Drawing.Size(180, 30)
         Me.BtnSwitch.TabIndex = 2
         Me.BtnSwitch.Text = " Turn &on Gaming Mode"
         Me.BtnSwitch.UseVisualStyleBackColor = True
         '
         'PnlMain
         '
         Me.PnlMain.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
                     Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.PnlMain.BackColor = System.Drawing.Color.White
         Me.PnlMain.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.PnlMain.Controls.Add(Me.BoxProfile)
         Me.PnlMain.Controls.Add(Me.BtnSwitch)
         Me.PnlMain.Controls.Add(Me.LnkVisEffects)
         Me.PnlMain.Controls.Add(Me.LblInfo)
         Me.PnlMain.Controls.Add(Me.LnkTaskMngr)
         Me.PnlMain.Controls.Add(Me.LnkGameCntrl)
         Me.PnlMain.Controls.Add(Me.LnkDirectX)
         Me.PnlMain.Controls.Add(Me.LnkPerfMon)
         Me.PnlMain.Controls.Add(Me.LnkPowerOpt)
         Me.PnlMain.Controls.Add(Me.LnkMemory)
         Me.PnlMain.Controls.Add(Me.LnkDisplaySet)
         Me.PnlMain.Location = New System.Drawing.Point(-2, 49)
         Me.PnlMain.Name = "PnlMain"
         Me.PnlMain.Size = New System.Drawing.Size(663, 500)
         Me.PnlMain.TabIndex = 1
         '
         'BoxProfile
         '
         Me.BoxProfile.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
                     Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.BoxProfile.Location = New System.Drawing.Point(20, 130)
         Me.BoxProfile.Name = "BoxProfile"
         Me.BoxProfile.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Silver
         '
         'BoxProfile.Panel
         '
         Me.BoxProfile.Panel.Controls.Add(Me.PnlProfile)
         Me.BoxProfile.Panel.Controls.Add(Me.HdrProfile)
         Me.BoxProfile.Size = New System.Drawing.Size(430, 325)
         Me.BoxProfile.StateNormal.Border.Rounding = 3
         Me.BoxProfile.TabIndex = 1
         '
         'PnlProfile
         '
         Me.PnlProfile.AutoScroll = True
         Me.PnlProfile.BackColor = System.Drawing.Color.White
         Me.PnlProfile.Controls.Add(Me.ChkDefrag)
         Me.PnlProfile.Controls.Add(Me.ChkDiagnostics)
         Me.PnlProfile.Controls.Add(Me.ChkAero)
         Me.PnlProfile.Controls.Add(Me.ChkWinUpdate)
         Me.PnlProfile.Controls.Add(Me.ChkScanner)
         Me.PnlProfile.Controls.Add(Me.LblFunctions)
         Me.PnlProfile.Controls.Add(Me.LblHardware)
         Me.PnlProfile.Controls.Add(Me.ChkTabletPC)
         Me.PnlProfile.Controls.Add(Me.ChkOther)
         Me.PnlProfile.Controls.Add(Me.ChkThemes)
         Me.PnlProfile.Controls.Add(Me.ChkNetShare)
         Me.PnlProfile.Controls.Add(Me.ChkWinSearch)
         Me.PnlProfile.Controls.Add(Me.LblVisEffects)
         Me.PnlProfile.Controls.Add(Me.ChkPrinter)
         Me.PnlProfile.Controls.Add(Me.ChkMediaCntr)
         Me.PnlProfile.Dock = System.Windows.Forms.DockStyle.Fill
         Me.PnlProfile.Location = New System.Drawing.Point(0, 26)
         Me.PnlProfile.Name = "PnlProfile"
         Me.PnlProfile.Size = New System.Drawing.Size(426, 295)
         Me.PnlProfile.TabIndex = 1
         '
         'ChkDefrag
         '
         Me.ChkDefrag.AutoSize = True
         Me.ChkDefrag.Location = New System.Drawing.Point(28, 343)
         Me.ChkDefrag.Name = "ChkDefrag"
         Me.ChkDefrag.Size = New System.Drawing.Size(244, 19)
         Me.ChkDefrag.TabIndex = 10
         Me.ChkDefrag.Text = "Suspend scheduled disk &defragmentation"
         Me.ToolTip.SetToolTip(Me.ChkDefrag, "Scheduled disk defragmentation of your hard disk will" & Global.Microsoft.VisualBasic.ChrW(13) & Global.Microsoft.VisualBasic.ChrW(10) & "be temporary suspended to save computer power.")
         Me.ChkDefrag.UseVisualStyleBackColor = True
         '
         'ChkDiagnostics
         '
         Me.ChkDiagnostics.AutoSize = True
         Me.ChkDiagnostics.Location = New System.Drawing.Point(28, 366)
         Me.ChkDiagnostics.Name = "ChkDiagnostics"
         Me.ChkDiagnostics.Size = New System.Drawing.Size(224, 19)
         Me.ChkDiagnostics.TabIndex = 11
         Me.ChkDiagnostics.Text = "Turn off &Windows Diagnostics service"
         Me.ToolTip.SetToolTip(Me.ChkDiagnostics, "Windows Diagnostics and problem detection tools will be turned off.")
         Me.ChkDiagnostics.UseVisualStyleBackColor = True
         '
         'ChkAero
         '
         Me.ChkAero.AutoSize = True
         Me.ChkAero.Location = New System.Drawing.Point(25, 181)
         Me.ChkAero.Name = "ChkAero"
         Me.ChkAero.Size = New System.Drawing.Size(292, 19)
         Me.ChkAero.TabIndex = 5
         Me.ChkAero.Text = "Turn off transparent windows with &3D glass effects"
         Me.ToolTip.SetToolTip(Me.ChkAero, "Complex transparent, 3D effects and taskbar's thumbnails will be turned off.")
         Me.ChkAero.UseVisualStyleBackColor = True
         '
         'ChkWinUpdate
         '
         Me.ChkWinUpdate.AutoSize = True
         Me.ChkWinUpdate.Location = New System.Drawing.Point(28, 320)
         Me.ChkWinUpdate.Name = "ChkWinUpdate"
         Me.ChkWinUpdate.Size = New System.Drawing.Size(223, 19)
         Me.ChkWinUpdate.TabIndex = 9
         Me.ChkWinUpdate.Text = "Suspend &Automatic Windows Update"
         Me.ToolTip.SetToolTip(Me.ChkWinUpdate, "Automatic Windows Update which runs in the background" & Global.Microsoft.VisualBasic.ChrW(13) & Global.Microsoft.VisualBasic.ChrW(10) & "will be temporary suspended to save computer power.")
         Me.ChkWinUpdate.UseVisualStyleBackColor = True
         '
         'ChkScanner
         '
         Me.ChkScanner.AutoSize = True
         Me.ChkScanner.Location = New System.Drawing.Point(25, 70)
         Me.ChkScanner.Name = "ChkScanner"
         Me.ChkScanner.Size = New System.Drawing.Size(270, 19)
         Me.ChkScanner.TabIndex = 2
         Me.ChkScanner.Text = "Limit support for digital cameras and &scanners"
         Me.ToolTip.SetToolTip(Me.ChkScanner, "You will not be able to import or scan images from your digital camera.")
         Me.ChkScanner.UseVisualStyleBackColor = True
         '
         'LblFunctions
         '
         Me.LblFunctions.AutoSize = True
         Me.LblFunctions.Font = New System.Drawing.Font("Segoe UI", 9.75!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.LblFunctions.ForeColor = System.Drawing.Color.Navy
         Me.LblFunctions.Location = New System.Drawing.Point(14, 221)
         Me.LblFunctions.Name = "LblFunctions"
         Me.LblFunctions.Size = New System.Drawing.Size(129, 17)
         Me.LblFunctions.TabIndex = 0
         Me.LblFunctions.Text = "Windows Functions
         '
         'LblHardware
         '
         Me.LblHardware.AutoSize = True
         Me.LblHardware.Font = New System.Drawing.Font("Segoe UI", 9.75!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.LblHardware.ForeColor = System.Drawing.Color.Navy
         Me.LblHardware.Location = New System.Drawing.Point(14, 17)
         Me.LblHardware.Name = "LblHardware"
         Me.LblHardware.Size = New System.Drawing.Size(68, 17)
         Me.LblHardware.TabIndex = 0
         Me.LblHardware.Text = "Hardware
         '
         'ChkTabletPC
         '
         Me.ChkTabletPC.AutoSize = True
         Me.ChkTabletPC.Location = New System.Drawing.Point(25, 93)
         Me.ChkTabletPC.Name = "ChkTabletPC"
         Me.ChkTabletPC.Size = New System.Drawing.Size(211, 19)
         Me.ChkTabletPC.TabIndex = 3
         Me.ChkTabletPC.Text = "Limit support for &Tablet PC devices"
         Me.ToolTip.SetToolTip(Me.ChkTabletPC, "You will not be able to use Tablet PC devices" & Global.Microsoft.VisualBasic.ChrW(13) & Global.Microsoft.VisualBasic.ChrW(10) & "like the pen and other input devices.")
         Me.ChkTabletPC.UseVisualStyleBackColor = True
         '
         'ChkOther
         '
         Me.ChkOther.AutoSize = True
         Me.ChkOther.Location = New System.Drawing.Point(28, 389)
         Me.ChkOther.Name = "ChkOther"
         Me.ChkOther.Size = New System.Drawing.Size(253, 19)
         Me.ChkOther.TabIndex = 12
         Me.ChkOther.Text = "Turn off other unneeded Windows &features"
         Me.ToolTip.SetToolTip(Me.ChkOther, "This will turn off many of Windows features that" & Global.Microsoft.VisualBasic.ChrW(13) & Global.Microsoft.VisualBasic.ChrW(10) & "known to be unneeded for normal use.")
         Me.ChkOther.UseVisualStyleBackColor = True
         '
         'ChkThemes
         '
         Me.ChkThemes.AutoSize = True
         Me.ChkThemes.Location = New System.Drawing.Point(25, 158)
         Me.ChkThemes.Name = "ChkThemes"
         Me.ChkThemes.Size = New System.Drawing.Size(201, 19)
         Me.ChkThemes.TabIndex = 4
         Me.ChkThemes.Text = "Switch to classic Windows t&heme"
         Me.ToolTip.SetToolTip(Me.ChkThemes, "Use classic Windows style for the appearance of windows, menus and buttons.")
         Me.ChkThemes.UseVisualStyleBackColor = True
         '
         'ChkNetShare
         '
         Me.ChkNetShare.AutoSize = True
         Me.ChkNetShare.Location = New System.Drawing.Point(28, 251)
         Me.ChkNetShare.Name = "ChkNetShare"
         Me.ChkNetShare.Size = New System.Drawing.Size(304, 19)
         Me.ChkNetShare.TabIndex = 6
         Me.ChkNetShare.Text = "Turn off accessing and sharing files over the &network"
         Me.ToolTip.SetToolTip(Me.ChkNetShare, "You will not be able to share files and devices over your network" & Global.Microsoft.VisualBasic.ChrW(13) & Global.Microsoft.VisualBasic.ChrW(10) & "and you will not be able to access shared resources.")
         Me.ChkNetShare.UseVisualStyleBackColor = True
         '
         'ChkWinSearch
         '
         Me.ChkWinSearch.AutoSize = True
         Me.ChkWinSearch.Location = New System.Drawing.Point(28, 274)
         Me.ChkWinSearch.Name = "ChkWinSearch"
         Me.ChkWinSearch.Size = New System.Drawing.Size(285, 19)
         Me.ChkWinSearch.TabIndex = 7
         Me.ChkWinSearch.Text = "Turn off Windows searching and &indexing service"
         Me.ToolTip.SetToolTip(Me.ChkWinSearch, "Indexing of your files and e-mails will be turned off to save computer power.")
         Me.ChkWinSearch.UseVisualStyleBackColor = True
         '
         'LblVisEffects
         '
         Me.LblVisEffects.AutoSize = True
         Me.LblVisEffects.Font = New System.Drawing.Font("Segoe UI", 9.75!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.LblVisEffects.ForeColor = System.Drawing.Color.Navy
         Me.LblVisEffects.Location = New System.Drawing.Point(14, 133)
         Me.LblVisEffects.Name = "LblVisEffects"
         Me.LblVisEffects.Size = New System.Drawing.Size(87, 17)
         Me.LblVisEffects.TabIndex = 0
         Me.LblVisEffects.Text = "Visual Effects
         '
         'ChkPrinter
         '
         Me.ChkPrinter.AutoSize = True
         Me.ChkPrinter.Location = New System.Drawing.Point(25, 47)
         Me.ChkPrinter.Name = "ChkPrinter"
         Me.ChkPrinter.Size = New System.Drawing.Size(270, 19)
         Me.ChkPrinter.TabIndex = 1
         Me.ChkPrinter.Text = "Limit support for printers and network &printers"
         Me.ToolTip.SetToolTip(Me.ChkPrinter, "You will not be able to use your printer or a network printer.")
         Me.ChkPrinter.UseVisualStyleBackColor = True
         '
         'ChkMediaCntr
         '
         Me.ChkMediaCntr.AutoSize = True
         Me.ChkMediaCntr.Location = New System.Drawing.Point(28, 297)
         Me.ChkMediaCntr.Name = "ChkMediaCntr"
         Me.ChkMediaCntr.Size = New System.Drawing.Size(239, 19)
         Me.ChkMediaCntr.TabIndex = 8
         Me.ChkMediaCntr.Text = "Turn off Windows &Media Center services"
         Me.ToolTip.SetToolTip(Me.ChkMediaCntr, "Windows Media Center functions like recording of TV programs" & Global.Microsoft.VisualBasic.ChrW(13) & Global.Microsoft.VisualBasic.ChrW(10) & "and TV and FM broadcast reception will be turned off.")
         Me.ChkMediaCntr.UseVisualStyleBackColor = True
         '
         'HdrProfile
         '
         Me.HdrProfile.Dock = System.Windows.Forms.DockStyle.Top
         Me.HdrProfile.HeaderStyle = ComponentFactory.Krypton.Toolkit.HeaderStyle.DockInactive
         Me.HdrProfile.Location = New System.Drawing.Point(0, 0)
         Me.HdrProfile.Name = "HdrProfile"
         Me.HdrProfile.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Silver
         Me.HdrProfile.Size = New System.Drawing.Size(426, 26)
         Me.HdrProfile.StateNormal.Back.ColorStyle = ComponentFactory.Krypton.Toolkit.PaletteColorStyle.HalfCut
         Me.HdrProfile.StateNormal.Border.DrawBorders = ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom
         Me.HdrProfile.StateNormal.Border.Rounding = 3
         Me.HdrProfile.StateNormal.Content.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.HdrProfile.StateNormal.Content.ShortText.Font = New System.Drawing.Font("Segoe UI", 11.25!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.HdrProfile.TabIndex = 0
         Me.HdrProfile.TabStop = False
         Me.HdrProfile.Values.Description = ""
         Me.HdrProfile.Values.Heading = "Gaming Mode Profile"
         Me.HdrProfile.Values.Image = Nothing
         '
         'LnkVisEffects
         '
         Me.LnkVisEffects.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.LnkVisEffects.LinkBehavior = ComponentFactory.Krypton.Toolkit.KryptonLinkBehavior.HoverUnderline
         Me.LnkVisEffects.Location = New System.Drawing.Point(481, 214)
         Me.LnkVisEffects.Name = "LnkVisEffects"
         Me.LnkVisEffects.OverrideNotVisited.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkVisEffects.OverrideNotVisited.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkVisEffects.OverridePressed.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkVisEffects.OverridePressed.ShortText.Color1 = System.Drawing.Color.RoyalBlue
         Me.LnkVisEffects.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Blue
         Me.LnkVisEffects.Size = New System.Drawing.Size(137, 20)
         Me.LnkVisEffects.StateNormal.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkVisEffects.StateNormal.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkVisEffects.TabIndex = 3
         Me.LnkVisEffects.Values.Text = "Windows Visual effects"
         '
         'LblInfo
         '
         Me.LblInfo.Anchor = CType(((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.LblInfo.Location = New System.Drawing.Point(16, 23)
         Me.LblInfo.Name = "LblInfo"
         Me.LblInfo.Size = New System.Drawing.Size(630, 90)
         Me.LblInfo.TabIndex = 0
         Me.LblInfo.Text = resources.GetString("LblInfo.Text")
         '
         'LnkTaskMngr
         '
         Me.LnkTaskMngr.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.LnkTaskMngr.LinkBehavior = ComponentFactory.Krypton.Toolkit.KryptonLinkBehavior.HoverUnderline
         Me.LnkTaskMngr.Location = New System.Drawing.Point(481, 243)
         Me.LnkTaskMngr.Name = "LnkTaskMngr"
         Me.LnkTaskMngr.OverrideNotVisited.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkTaskMngr.OverrideNotVisited.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkTaskMngr.OverridePressed.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkTaskMngr.OverridePressed.ShortText.Color1 = System.Drawing.Color.RoyalBlue
         Me.LnkTaskMngr.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Blue
         Me.LnkTaskMngr.Size = New System.Drawing.Size(142, 20)
         Me.LnkTaskMngr.StateNormal.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkTaskMngr.StateNormal.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkTaskMngr.TabIndex = 4
         Me.LnkTaskMngr.Values.Text = "Windows Task Manager"
         '
         'LnkGameCntrl
         '
         Me.LnkGameCntrl.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.LnkGameCntrl.LinkBehavior = ComponentFactory.Krypton.Toolkit.KryptonLinkBehavior.HoverUnderline
         Me.LnkGameCntrl.Location = New System.Drawing.Point(481, 272)
         Me.LnkGameCntrl.Name = "LnkGameCntrl"
         Me.LnkGameCntrl.OverrideNotVisited.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkGameCntrl.OverrideNotVisited.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkGameCntrl.OverridePressed.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkGameCntrl.OverridePressed.ShortText.Color1 = System.Drawing.Color.RoyalBlue
         Me.LnkGameCntrl.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Blue
         Me.LnkGameCntrl.Size = New System.Drawing.Size(107, 20)
         Me.LnkGameCntrl.StateNormal.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkGameCntrl.StateNormal.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkGameCntrl.TabIndex = 5
         Me.LnkGameCntrl.Values.Text = "Game Controllers"
         '
         'LnkDirectX
         '
         Me.LnkDirectX.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.LnkDirectX.LinkBehavior = ComponentFactory.Krypton.Toolkit.KryptonLinkBehavior.HoverUnderline
         Me.LnkDirectX.Location = New System.Drawing.Point(481, 359)
         Me.LnkDirectX.Name = "LnkDirectX"
         Me.LnkDirectX.OverrideNotVisited.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkDirectX.OverrideNotVisited.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkDirectX.OverridePressed.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkDirectX.OverridePressed.ShortText.Color1 = System.Drawing.Color.RoyalBlue
         Me.LnkDirectX.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Blue
         Me.LnkDirectX.Size = New System.Drawing.Size(140, 20)
         Me.LnkDirectX.StateNormal.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkDirectX.StateNormal.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkDirectX.TabIndex = 8
         Me.LnkDirectX.Values.Text = "DirectX Diagnostic Tool"
         '
         'LnkPerfMon
         '
         Me.LnkPerfMon.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.LnkPerfMon.LinkBehavior = ComponentFactory.Krypton.Toolkit.KryptonLinkBehavior.HoverUnderline
         Me.LnkPerfMon.Location = New System.Drawing.Point(481, 417)
         Me.LnkPerfMon.Name = "LnkPerfMon"
         Me.LnkPerfMon.OverrideNotVisited.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkPerfMon.OverrideNotVisited.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkPerfMon.OverridePressed.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkPerfMon.OverridePressed.ShortText.Color1 = System.Drawing.Color.RoyalBlue
         Me.LnkPerfMon.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Blue
         Me.LnkPerfMon.Size = New System.Drawing.Size(129, 20)
         Me.LnkPerfMon.StateNormal.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkPerfMon.StateNormal.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkPerfMon.TabIndex = 10
         Me.LnkPerfMon.Values.Text = "Performance Monitor"
         '
         'LnkPowerOpt
         '
         Me.LnkPowerOpt.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.LnkPowerOpt.LinkBehavior = ComponentFactory.Krypton.Toolkit.KryptonLinkBehavior.HoverUnderline
         Me.LnkPowerOpt.Location = New System.Drawing.Point(481, 301)
         Me.LnkPowerOpt.Name = "LnkPowerOpt"
         Me.LnkPowerOpt.OverrideNotVisited.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkPowerOpt.OverrideNotVisited.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkPowerOpt.OverridePressed.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkPowerOpt.OverridePressed.ShortText.Color1 = System.Drawing.Color.RoyalBlue
         Me.LnkPowerOpt.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Blue
         Me.LnkPowerOpt.Size = New System.Drawing.Size(147, 20)
         Me.LnkPowerOpt.StateNormal.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkPowerOpt.StateNormal.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkPowerOpt.TabIndex = 6
         Me.LnkPowerOpt.Values.Text = "Windows Power Options"
         '
         'LnkMemory
         '
         Me.LnkMemory.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.LnkMemory.LinkBehavior = ComponentFactory.Krypton.Toolkit.KryptonLinkBehavior.HoverUnderline
         Me.LnkMemory.Location = New System.Drawing.Point(481, 388)
         Me.LnkMemory.Name = "LnkMemory"
         Me.LnkMemory.OverrideNotVisited.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkMemory.OverrideNotVisited.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkMemory.OverridePressed.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkMemory.OverridePressed.ShortText.Color1 = System.Drawing.Color.RoyalBlue
         Me.LnkMemory.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Blue
         Me.LnkMemory.Size = New System.Drawing.Size(152, 20)
         Me.LnkMemory.StateNormal.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkMemory.StateNormal.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkMemory.TabIndex = 9
         Me.LnkMemory.Values.Text = "Memory Diagnostics Tool"
         '
         'LnkDisplaySet
         '
         Me.LnkDisplaySet.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.LnkDisplaySet.LinkBehavior = ComponentFactory.Krypton.Toolkit.KryptonLinkBehavior.HoverUnderline
         Me.LnkDisplaySet.Location = New System.Drawing.Point(481, 330)
         Me.LnkDisplaySet.Name = "LnkDisplaySet"
         Me.LnkDisplaySet.OverrideNotVisited.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkDisplaySet.OverrideNotVisited.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkDisplaySet.OverridePressed.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkDisplaySet.OverridePressed.ShortText.Color1 = System.Drawing.Color.RoyalBlue
         Me.LnkDisplaySet.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Blue
         Me.LnkDisplaySet.Size = New System.Drawing.Size(99, 20)
         Me.LnkDisplaySet.StateNormal.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.LnkDisplaySet.StateNormal.ShortText.Color1 = System.Drawing.Color.MediumBlue
         Me.LnkDisplaySet.TabIndex = 7
         Me.LnkDisplaySet.Values.Text = "Display Settings"
         '
         'HdrMain
         '
         Me.HdrMain.Dock = System.Windows.Forms.DockStyle.Top
         Me.HdrMain.Location = New System.Drawing.Point(0, 0)
         Me.HdrMain.Name = "HdrMain"
         Me.HdrMain.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2007Silver
         Me.HdrMain.Size = New System.Drawing.Size(659, 53)
         Me.HdrMain.StateNormal.Back.Color1 = System.Drawing.Color.White
         Me.HdrMain.StateNormal.Back.Color2 = System.Drawing.Color.Gainsboro
         Me.HdrMain.StateNormal.Back.ColorStyle = ComponentFactory.Krypton.Toolkit.PaletteColorStyle.HalfCut
         Me.HdrMain.StateNormal.Border.DrawBorders = ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom
         Me.HdrMain.StateNormal.Content.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.HdrMain.StateNormal.Content.ShortText.Font = New System.Drawing.Font("Calibri", 27.75!, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.HdrMain.TabIndex = 0
         Me.HdrMain.TabStop = False
         Me.HdrMain.Values.Description = ""
         Me.HdrMain.Values.Heading = " Gaming Mode"
         Me.HdrMain.Values.Image = Nothing
         '
         'BtnClose
         '
         Me.BtnClose.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.BtnClose.Location = New System.Drawing.Point(562, 560)
         Me.BtnClose.Name = "BtnClose"
         Me.BtnClose.Size = New System.Drawing.Size(85, 25)
         Me.BtnClose.TabIndex = 2
         Me.BtnClose.Text = "&Close"
         Me.BtnClose.UseVisualStyleBackColor = True
         '
         'BWGameMode
         '
         Me.BWGameMode.WorkerReportsProgress = True
         Me.BWGameMode.WorkerSupportsCancellation = True
         '
         'ToolTip
         '
         Me.ToolTip.AutomaticDelay = 250
         Me.ToolTip.AutoPopDelay = 50000
         Me.ToolTip.InitialDelay = 100
         Me.ToolTip.ReshowDelay = 50
         '
         'FrmGameMode
         '
         Me.AcceptButton = Me.BtnSwitch
         Me.AutoScaleMode = System.Windows.Forms.AutoScaleMode.None
         Me.ClientSize = New System.Drawing.Size(659, 596)
         Me.ControlBox = False
         Me.Controls.Add(Me.BtnClose)
         Me.Controls.Add(Me.HdrMain)
         Me.Controls.Add(Me.PnlMain)
         Me.DoubleBuffered = True
         Me.Font = New System.Drawing.Font("Segoe UI", 9.0!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.ForeColor = System.Drawing.Color.Black
         Me.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None
         Me.MaximizeBox = False
         Me.MinimizeBox = False
         Me.Name = "FrmGameMode"
         Me.ShowIcon = False
         Me.ShowInTaskbar = False
         Me.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide
         Me.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen
         Me.Text = "Gaming Mode"
         Me.PnlMain.ResumeLayout(False)
         Me.PnlMain.PerformLayout()
         CType(Me.BoxProfile.Panel, System.ComponentModel.ISupportInitialize).EndInit()
         Me.BoxProfile.Panel.ResumeLayout(False)
         Me.BoxProfile.Panel.PerformLayout()
         CType(Me.BoxProfile, System.ComponentModel.ISupportInitialize).EndInit()
         Me.BoxProfile.ResumeLayout(False)
         Me.PnlProfile.ResumeLayout(False)
         Me.PnlProfile.PerformLayout()
         Me.ResumeLayout(False)
         Me.PerformLayout()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmManual.vb" startline="15" endline="866">
<![CDATA[
 
     Private components As System.ComponentModel.IContainer
 
     <System.Diagnostics.DebuggerStepThrough()> _
     Private Sub InitializeComponent()
         Me.components = New System.ComponentModel.Container
         Dim ListViewItem1 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I want Windows visual styles and themes
         Dim ListViewItem2 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I want transparent windows with 3D and glass effects
         Dim ListViewItem3 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I use Windows Media Center to play movies and other multimedia
         Dim ListViewItem4 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I share Media Player libraries with other networked players
         Dim ListViewItem5 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I want system to index and cache files for fast searching
         Dim ListViewItem6 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("Some of my programs are not compatible with Windows
         Dim ListViewItem7 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I use System Diagnostic and Problem Detection tools
         Dim ListViewItem8 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I have a printer or use a network printer
         Dim ListViewItem9 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I have a scanner or a digital camera
         Dim ListViewItem10 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I use the pen of the Tablet PC
         Dim ListViewItem11 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I want system to track logon, network and other system events
         Dim ListViewItem12 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I need to start processes under alternate credentials
         Dim ListViewItem13 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I want to send programs error reports to Microsoft
         Dim ListViewItem14 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I use Windows disk defragmenting tool
         Dim ListViewItem15 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I use Windows Security Center
         Dim ListViewItem16 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I want Windows Update to check for new updates automatically
         Dim ListViewItem17 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I use Windows Defender, I do not use another Anti-Spyware
         Dim ListViewItem18 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I use Windows Firewall, I do not use another Firewall
         Dim ListViewItem19 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I use Windows Backup to backup and restore files
         Dim ListViewItem20 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("Allow remote users to modify registry settings on my computer
         Dim ListViewItem21 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I use encrypted network connections (VPN / IPsec)
         Dim ListViewItem22 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("DHCP Service
         Dim ListViewItem23 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("DNS Client Service
         Dim ListViewItem24 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("DFS Replication Service
         Dim ListViewItem25 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("WorkStation Service
         Dim ListViewItem26 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("Computer Browser Service
         Dim ListViewItem27 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("Function Discovery Resource Publication Service
         Dim ListViewItem28 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("Server Service
         Dim ListViewItem29 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("TCP/IP NetBIOS Helper Service
         Dim ListViewItem30 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("Allow remote users to connect interactively to my computer
         Dim ListViewItem31 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("Allow the discovery of UPnP devices on my home network
         Dim ListViewItem32 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I want to cache offline files on my local computer
         Dim ListViewItem33 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("My Network uses the IPv6 protocol
         Dim ListViewItem34 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("Allow programs to create, access and modify Internet-based files
         Dim ListViewItem35 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("Synchronize computer date and time to the network
         Dim ListViewItem36 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I use a wireless network to access the Internet
         Me.PnlMain = New System.Windows.Forms.Panel
         Me.BoxInfo = New System.Windows.Forms.GroupBox
         Me.PnlStatus = New System.Windows.Forms.Panel
         Me.PicStatus = New System.Windows.Forms.PictureBox
         Me.TxtInfo = New System.Windows.Forms.TextBox
         Me.TabMain = New System.Windows.Forms.TabControl
         Me.TabPerformance = New System.Windows.Forms.TabPage
         Me.LstPerformance = New System.Windows.Forms.ListView
         Me.CboDefrag = New System.Windows.Forms.ComboBox
         Me.CboErrReport = New System.Windows.Forms.ComboBox
         Me.CboSecondLogon = New System.Windows.Forms.ComboBox
         Me.CboSystemEvent = New System.Windows.Forms.ComboBox
         Me.CboTabletPC = New System.Windows.Forms.ComboBox
         Me.CboScanner = New System.Windows.Forms.ComboBox
         Me.CboPrinter = New System.Windows.Forms.ComboBox
         Me.CboDiagnostics = New System.Windows.Forms.ComboBox
         Me.CboCompatibility = New System.Windows.Forms.ComboBox
         Me.CboWinSearch = New System.Windows.Forms.ComboBox
         Me.CboMediaShare = New System.Windows.Forms.ComboBox
         Me.CboMediaCntr = New System.Windows.Forms.ComboBox
         Me.CboWinAero = New System.Windows.Forms.ComboBox
         Me.CboThemes = New System.Windows.Forms.ComboBox
         Me.TabSecurity = New System.Windows.Forms.TabPage
         Me.LstSecurity = New System.Windows.Forms.ListView
         Me.CboIPSec = New System.Windows.Forms.ComboBox
         Me.CboRmtReg = New System.Windows.Forms.ComboBox
         Me.CboWinBackup = New System.Windows.Forms.ComboBox
         Me.CboWinFirewall = New System.Windows.Forms.ComboBox
         Me.CboWinDefender = New System.Windows.Forms.ComboBox
         Me.CboWinUpdate = New System.Windows.Forms.ComboBox
         Me.CboSecCntr = New System.Windows.Forms.ComboBox
         Me.TabNetwork = New System.Windows.Forms.TabPage
         Me.LstNetwork = New System.Windows.Forms.ListView
         Me.CboWirelessNet = New System.Windows.Forms.ComboBox
         Me.CboWinTime = New System.Windows.Forms.ComboBox
         Me.CboWebClient = New System.Windows.Forms.ComboBox
         Me.CboIPv6 = New System.Windows.Forms.ComboBox
         Me.CboOfflineFiles = New System.Windows.Forms.ComboBox
         Me.CboUPnP = New System.Windows.Forms.ComboBox
         Me.CboTerminal = New System.Windows.Forms.ComboBox
         Me.CboNetBIOSHelper = New System.Windows.Forms.ComboBox
         Me.CboServer = New System.Windows.Forms.ComboBox
         Me.CboFunctionDiscovery = New System.Windows.Forms.ComboBox
         Me.CboComputerBrowser = New System.Windows.Forms.ComboBox
         Me.CboWorkstation = New System.Windows.Forms.ComboBox
         Me.CboDFS = New System.Windows.Forms.ComboBox
         Me.CboDNS = New System.Windows.Forms.ComboBox
         Me.CboDHCP = New System.Windows.Forms.ComboBox
         Me.BtnOptimize = New System.Windows.Forms.Button
         Me.BtnClose = New System.Windows.Forms.Button
         Me.BWManTuneUp = New System.ComponentModel.BackgroundWorker
         Me.HdrMain = New ComponentFactory.Krypton.Toolkit.KryptonHeader
         Me.BtnLock = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnRefresh = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnSearch = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.ConTxtMnu = New System.Windows.Forms.ContextMenuStrip(Me.components)
         Me.ItmSearchEngine = New System.Windows.Forms.ToolStripMenuItem
         Me.ItmBlkVpr = New System.Windows.Forms.ToolStripMenuItem
         Me.BtnCProfile = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.PnlMain.SuspendLayout()
         Me.BoxInfo.SuspendLayout()
         Me.PnlStatus.SuspendLayout()
         CType(Me.PicStatus, System.ComponentModel.ISupportInitialize).BeginInit()
         Me.TabMain.SuspendLayout()
         Me.TabPerformance.SuspendLayout()
         Me.TabSecurity.SuspendLayout()
         Me.TabNetwork.SuspendLayout()
         Me.ConTxtMnu.SuspendLayout()
         Me.SuspendLayout()
         '
         'PnlMain
         '
         Me.PnlMain.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
                     Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.PnlMain.BackColor = System.Drawing.Color.White
         Me.PnlMain.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.PnlMain.Controls.Add(Me.BoxInfo)
         Me.PnlMain.Controls.Add(Me.TabMain)
         Me.PnlMain.Location = New System.Drawing.Point(-2, 49)
         Me.PnlMain.Name = "PnlMain"
         Me.PnlMain.Size = New System.Drawing.Size(663, 500)
         Me.PnlMain.TabIndex = 1
         '
         'BoxInfo
         '
         Me.BoxInfo.Anchor = CType(((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.BoxInfo.Controls.Add(Me.PnlStatus)
         Me.BoxInfo.Controls.Add(Me.TxtInfo)
         Me.BoxInfo.Location = New System.Drawing.Point(14, 406)
         Me.BoxInfo.Name = "BoxInfo"
         Me.BoxInfo.Size = New System.Drawing.Size(630, 80)
         Me.BoxInfo.TabIndex = 0
         Me.BoxInfo.TabStop = False
         '
         'PnlStatus
         '
         Me.PnlStatus.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Stretch
         Me.PnlStatus.Controls.Add(Me.PicStatus)
         Me.PnlStatus.Location = New System.Drawing.Point(11, 18)
         Me.PnlStatus.Name = "PnlStatus"
         Me.PnlStatus.Size = New System.Drawing.Size(50, 50)
         Me.PnlStatus.TabIndex = 0
         '
         'PicStatus
         '
         Me.PicStatus.BackColor = System.Drawing.Color.Transparent
         Me.PicStatus.ErrorImage = Nothing
         Me.PicStatus.InitialImage = Nothing
         Me.PicStatus.Location = New System.Drawing.Point(32, 32)
         Me.PicStatus.Name = "PicStatus"
         Me.PicStatus.Size = New System.Drawing.Size(18, 18)
         Me.PicStatus.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage
         Me.PicStatus.TabIndex = 0
         Me.PicStatus.TabStop = False
         '
         'TxtInfo
         '
         Me.TxtInfo.Anchor = CType(((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.TxtInfo.BackColor = System.Drawing.Color.White
         Me.TxtInfo.BorderStyle = System.Windows.Forms.BorderStyle.None
         Me.TxtInfo.Cursor = System.Windows.Forms.Cursors.Arrow
         Me.TxtInfo.ForeColor = System.Drawing.Color.Black
         Me.TxtInfo.Location = New System.Drawing.Point(67, 18)
         Me.TxtInfo.Multiline = True
         Me.TxtInfo.Name = "TxtInfo"
         Me.TxtInfo.ReadOnly = True
         Me.TxtInfo.ScrollBars = System.Windows.Forms.ScrollBars.Vertical
         Me.TxtInfo.Size = New System.Drawing.Size(555, 50)
         Me.TxtInfo.TabIndex = 0
         Me.TxtInfo.TabStop = False
         '
         'TabMain
         '
         Me.TabMain.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
                     Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.TabMain.Controls.Add(Me.TabPerformance)
         Me.TabMain.Controls.Add(Me.TabSecurity)
         Me.TabMain.Controls.Add(Me.TabNetwork)
         Me.TabMain.Location = New System.Drawing.Point(14, 15)
         Me.TabMain.Name = "TabMain"
         Me.TabMain.SelectedIndex = 0
         Me.TabMain.Size = New System.Drawing.Size(630, 385)
         Me.TabMain.TabIndex = 1
         '
         'TabPerformance
         '
         Me.TabPerformance.AutoScroll = True
         Me.TabPerformance.BackColor = System.Drawing.Color.White
         Me.TabPerformance.Controls.Add(Me.LstPerformance)
         Me.TabPerformance.Controls.Add(Me.CboDefrag)
         Me.TabPerformance.Controls.Add(Me.CboErrReport)
         Me.TabPerformance.Controls.Add(Me.CboSecondLogon)
         Me.TabPerformance.Controls.Add(Me.CboSystemEvent)
         Me.TabPerformance.Controls.Add(Me.CboTabletPC)
         Me.TabPerformance.Controls.Add(Me.CboScanner)
         Me.TabPerformance.Controls.Add(Me.CboPrinter)
         Me.TabPerformance.Controls.Add(Me.CboDiagnostics)
         Me.TabPerformance.Controls.Add(Me.CboCompatibility)
         Me.TabPerformance.Controls.Add(Me.CboWinSearch)
         Me.TabPerformance.Controls.Add(Me.CboMediaShare)
         Me.TabPerformance.Controls.Add(Me.CboMediaCntr)
         Me.TabPerformance.Controls.Add(Me.CboWinAero)
         Me.TabPerformance.Controls.Add(Me.CboThemes)
         Me.TabPerformance.Location = New System.Drawing.Point(4, 24)
         Me.TabPerformance.Name = "TabPerformance"
         Me.TabPerformance.Padding = New System.Windows.Forms.Padding(3)
         Me.TabPerformance.Size = New System.Drawing.Size(622, 357)
         Me.TabPerformance.TabIndex = 0
         Me.TabPerformance.Text = "Performance"
         Me.TabPerformance.UseVisualStyleBackColor = True
         '
         'LstPerformance
         '
         Me.LstPerformance.Alignment = System.Windows.Forms.ListViewAlignment.Left
         Me.LstPerformance.BackColor = System.Drawing.Color.White
         Me.LstPerformance.BorderStyle = System.Windows.Forms.BorderStyle.None
         Me.LstPerformance.ForeColor = System.Drawing.Color.Black
         Me.LstPerformance.HideSelection = False
         Me.LstPerformance.Items.AddRange(New System.Windows.Forms.ListViewItem() {ListViewItem1, ListViewItem2, ListViewItem3, ListViewItem4, ListViewItem5, ListViewItem6, ListViewItem7, ListViewItem8, ListViewItem9, ListViewItem10, ListViewItem11, ListViewItem12, ListViewItem13, ListViewItem14})
         Me.LstPerformance.LabelWrap = False
         Me.LstPerformance.Location = New System.Drawing.Point(15, 20)
         Me.LstPerformance.MultiSelect = False
         Me.LstPerformance.Name = "LstPerformance"
         Me.LstPerformance.Scrollable = False
         Me.LstPerformance.ShowGroups = False
         Me.LstPerformance.Size = New System.Drawing.Size(400, 430)
         Me.LstPerformance.TabIndex = 1
         Me.LstPerformance.TileSize = New System.Drawing.Size(380, 30)
         Me.LstPerformance.UseCompatibleStateImageBehavior = False
         Me.LstPerformance.View = System.Windows.Forms.View.Tile
         '
         'CboDefrag
         '
         Me.CboDefrag.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboDefrag.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboDefrag.FormattingEnabled = True
         Me.CboDefrag.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboDefrag.Location = New System.Drawing.Point(440, 414)
         Me.CboDefrag.Name = "CboDefrag"
         Me.CboDefrag.Size = New System.Drawing.Size(155, 23)
         Me.CboDefrag.TabIndex = 15
         '
         'CboErrReport
         '
         Me.CboErrReport.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboErrReport.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboErrReport.FormattingEnabled = True
         Me.CboErrReport.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboErrReport.Location = New System.Drawing.Point(440, 382)
         Me.CboErrReport.Name = "CboErrReport"
         Me.CboErrReport.Size = New System.Drawing.Size(155, 23)
         Me.CboErrReport.TabIndex = 14
         '
         'CboSecondLogon
         '
         Me.CboSecondLogon.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboSecondLogon.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboSecondLogon.FormattingEnabled = True
         Me.CboSecondLogon.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboSecondLogon.Location = New System.Drawing.Point(440, 352)
         Me.CboSecondLogon.Name = "CboSecondLogon"
         Me.CboSecondLogon.Size = New System.Drawing.Size(155, 23)
         Me.CboSecondLogon.TabIndex = 13
         '
         'CboSystemEvent
         '
         Me.CboSystemEvent.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboSystemEvent.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboSystemEvent.FormattingEnabled = True
         Me.CboSystemEvent.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboSystemEvent.Location = New System.Drawing.Point(440, 322)
         Me.CboSystemEvent.Name = "CboSystemEvent"
         Me.CboSystemEvent.Size = New System.Drawing.Size(155, 23)
         Me.CboSystemEvent.TabIndex = 12
         '
         'CboTabletPC
         '
         Me.CboTabletPC.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboTabletPC.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboTabletPC.FormattingEnabled = True
         Me.CboTabletPC.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboTabletPC.Location = New System.Drawing.Point(440, 292)
         Me.CboTabletPC.Name = "CboTabletPC"
         Me.CboTabletPC.Size = New System.Drawing.Size(155, 23)
         Me.CboTabletPC.TabIndex = 11
         '
         'CboScanner
         '
         Me.CboScanner.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboScanner.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboScanner.FormattingEnabled = True
         Me.CboScanner.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboScanner.Location = New System.Drawing.Point(440, 262)
         Me.CboScanner.Name = "CboScanner"
         Me.CboScanner.Size = New System.Drawing.Size(155, 23)
         Me.CboScanner.TabIndex = 10
         '
         'CboPrinter
         '
         Me.CboPrinter.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboPrinter.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboPrinter.FormattingEnabled = True
         Me.CboPrinter.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboPrinter.Location = New System.Drawing.Point(440, 232)
         Me.CboPrinter.Name = "CboPrinter"
         Me.CboPrinter.Size = New System.Drawing.Size(155, 23)
         Me.CboPrinter.TabIndex = 9
         '
         'CboDiagnostics
         '
         Me.CboDiagnostics.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboDiagnostics.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboDiagnostics.FormattingEnabled = True
         Me.CboDiagnostics.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboDiagnostics.Location = New System.Drawing.Point(440, 202)
         Me.CboDiagnostics.Name = "CboDiagnostics"
         Me.CboDiagnostics.Size = New System.Drawing.Size(155, 23)
         Me.CboDiagnostics.TabIndex = 8
         '
         'CboCompatibility
         '
         Me.CboCompatibility.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboCompatibility.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboCompatibility.FormattingEnabled = True
         Me.CboCompatibility.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboCompatibility.Location = New System.Drawing.Point(440, 172)
         Me.CboCompatibility.Name = "CboCompatibility"
         Me.CboCompatibility.Size = New System.Drawing.Size(155, 23)
         Me.CboCompatibility.TabIndex = 7
         '
         'CboWinSearch
         '
         Me.CboWinSearch.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboWinSearch.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboWinSearch.FormattingEnabled = True
         Me.CboWinSearch.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboWinSearch.Location = New System.Drawing.Point(440, 142)
         Me.CboWinSearch.Name = "CboWinSearch"
         Me.CboWinSearch.Size = New System.Drawing.Size(155, 23)
         Me.CboWinSearch.TabIndex = 6
         '
         'CboMediaShare
         '
         Me.CboMediaShare.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboMediaShare.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboMediaShare.FormattingEnabled = True
         Me.CboMediaShare.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboMediaShare.Location = New System.Drawing.Point(440, 112)
         Me.CboMediaShare.Name = "CboMediaShare"
         Me.CboMediaShare.Size = New System.Drawing.Size(155, 23)
         Me.CboMediaShare.TabIndex = 5
         '
         'CboMediaCntr
         '
         Me.CboMediaCntr.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboMediaCntr.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboMediaCntr.FormattingEnabled = True
         Me.CboMediaCntr.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboMediaCntr.Location = New System.Drawing.Point(440, 82)
         Me.CboMediaCntr.Name = "CboMediaCntr"
         Me.CboMediaCntr.Size = New System.Drawing.Size(155, 23)
         Me.CboMediaCntr.TabIndex = 4
         '
         'CboWinAero
         '
         Me.CboWinAero.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboWinAero.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboWinAero.FormattingEnabled = True
         Me.CboWinAero.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboWinAero.Location = New System.Drawing.Point(440, 52)
         Me.CboWinAero.Name = "CboWinAero"
         Me.CboWinAero.Size = New System.Drawing.Size(155, 23)
         Me.CboWinAero.TabIndex = 3
         '
         'CboThemes
         '
         Me.CboThemes.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboThemes.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboThemes.FormattingEnabled = True
         Me.CboThemes.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboThemes.Location = New System.Drawing.Point(440, 22)
         Me.CboThemes.Name = "CboThemes"
         Me.CboThemes.Size = New System.Drawing.Size(155, 23)
         Me.CboThemes.TabIndex = 2
         '
         'TabSecurity
         '
         Me.TabSecurity.BackColor = System.Drawing.Color.White
         Me.TabSecurity.Controls.Add(Me.LstSecurity)
         Me.TabSecurity.Controls.Add(Me.CboIPSec)
         Me.TabSecurity.Controls.Add(Me.CboRmtReg)
         Me.TabSecurity.Controls.Add(Me.CboWinBackup)
         Me.TabSecurity.Controls.Add(Me.CboWinFirewall)
         Me.TabSecurity.Controls.Add(Me.CboWinDefender)
         Me.TabSecurity.Controls.Add(Me.CboWinUpdate)
         Me.TabSecurity.Controls.Add(Me.CboSecCntr)
         Me.TabSecurity.Location = New System.Drawing.Point(4, 24)
         Me.TabSecurity.Name = "TabSecurity"
         Me.TabSecurity.Padding = New System.Windows.Forms.Padding(3)
         Me.TabSecurity.Size = New System.Drawing.Size(622, 357)
         Me.TabSecurity.TabIndex = 1
         Me.TabSecurity.Text = "Security"
         Me.TabSecurity.UseVisualStyleBackColor = True
         '
         'LstSecurity
         '
         Me.LstSecurity.Alignment = System.Windows.Forms.ListViewAlignment.Left
         Me.LstSecurity.BackColor = System.Drawing.Color.White
         Me.LstSecurity.BorderStyle = System.Windows.Forms.BorderStyle.None
         Me.LstSecurity.ForeColor = System.Drawing.Color.Black
         Me.LstSecurity.HideSelection = False
         Me.LstSecurity.Items.AddRange(New System.Windows.Forms.ListViewItem() {ListViewItem15, ListViewItem16, ListViewItem17, ListViewItem18, ListViewItem19, ListViewItem20, ListViewItem21})
         Me.LstSecurity.LabelWrap = False
         Me.LstSecurity.Location = New System.Drawing.Point(15, 20)
         Me.LstSecurity.MultiSelect = False
         Me.LstSecurity.Name = "LstSecurity"
         Me.LstSecurity.Scrollable = False
         Me.LstSecurity.ShowGroups = False
         Me.LstSecurity.Size = New System.Drawing.Size(400, 220)
         Me.LstSecurity.TabIndex = 1
         Me.LstSecurity.TileSize = New System.Drawing.Size(380, 30)
         Me.LstSecurity.UseCompatibleStateImageBehavior = False
         Me.LstSecurity.View = System.Windows.Forms.View.Tile
         '
         'CboIPSec
         '
         Me.CboIPSec.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboIPSec.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboIPSec.FormattingEnabled = True
         Me.CboIPSec.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboIPSec.Location = New System.Drawing.Point(440, 202)
         Me.CboIPSec.Name = "CboIPSec"
         Me.CboIPSec.Size = New System.Drawing.Size(155, 23)
         Me.CboIPSec.TabIndex = 8
         '
         'CboRmtReg
         '
         Me.CboRmtReg.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboRmtReg.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboRmtReg.FormattingEnabled = True
         Me.CboRmtReg.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboRmtReg.Location = New System.Drawing.Point(440, 172)
         Me.CboRmtReg.Name = "CboRmtReg"
         Me.CboRmtReg.Size = New System.Drawing.Size(155, 23)
         Me.CboRmtReg.TabIndex = 7
         '
         'CboWinBackup
         '
         Me.CboWinBackup.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboWinBackup.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboWinBackup.FormattingEnabled = True
         Me.CboWinBackup.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboWinBackup.Location = New System.Drawing.Point(440, 142)
         Me.CboWinBackup.Name = "CboWinBackup"
         Me.CboWinBackup.Size = New System.Drawing.Size(155, 23)
         Me.CboWinBackup.TabIndex = 6
         '
         'CboWinFirewall
         '
         Me.CboWinFirewall.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboWinFirewall.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboWinFirewall.Enabled = False
         Me.CboWinFirewall.FormattingEnabled = True
         Me.CboWinFirewall.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboWinFirewall.Location = New System.Drawing.Point(440, 112)
         Me.CboWinFirewall.Name = "CboWinFirewall"
         Me.CboWinFirewall.Size = New System.Drawing.Size(155, 23)
         Me.CboWinFirewall.TabIndex = 5
         '
         'CboWinDefender
         '
         Me.CboWinDefender.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboWinDefender.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboWinDefender.Enabled = False
         Me.CboWinDefender.FormattingEnabled = True
         Me.CboWinDefender.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboWinDefender.Location = New System.Drawing.Point(440, 82)
         Me.CboWinDefender.Name = "CboWinDefender"
         Me.CboWinDefender.Size = New System.Drawing.Size(155, 23)
         Me.CboWinDefender.TabIndex = 4
         '
         'CboWinUpdate
         '
         Me.CboWinUpdate.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboWinUpdate.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboWinUpdate.Enabled = False
         Me.CboWinUpdate.FormattingEnabled = True
         Me.CboWinUpdate.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboWinUpdate.Location = New System.Drawing.Point(440, 52)
         Me.CboWinUpdate.Name = "CboWinUpdate"
         Me.CboWinUpdate.Size = New System.Drawing.Size(155, 23)
         Me.CboWinUpdate.TabIndex = 3
         '
         'CboSecCntr
         '
         Me.CboSecCntr.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboSecCntr.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboSecCntr.Enabled = False
         Me.CboSecCntr.FormattingEnabled = True
         Me.CboSecCntr.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboSecCntr.Location = New System.Drawing.Point(440, 22)
         Me.CboSecCntr.Name = "CboSecCntr"
         Me.CboSecCntr.Size = New System.Drawing.Size(155, 23)
         Me.CboSecCntr.TabIndex = 2
         '
         'TabNetwork
         '
         Me.TabNetwork.AutoScroll = True
         Me.TabNetwork.BackColor = System.Drawing.Color.White
         Me.TabNetwork.Controls.Add(Me.LstNetwork)
         Me.TabNetwork.Controls.Add(Me.CboWirelessNet)
         Me.TabNetwork.Controls.Add(Me.CboWinTime)
         Me.TabNetwork.Controls.Add(Me.CboWebClient)
         Me.TabNetwork.Controls.Add(Me.CboIPv6)
         Me.TabNetwork.Controls.Add(Me.CboOfflineFiles)
         Me.TabNetwork.Controls.Add(Me.CboUPnP)
         Me.TabNetwork.Controls.Add(Me.CboTerminal)
         Me.TabNetwork.Controls.Add(Me.CboNetBIOSHelper)
         Me.TabNetwork.Controls.Add(Me.CboServer)
         Me.TabNetwork.Controls.Add(Me.CboFunctionDiscovery)
         Me.TabNetwork.Controls.Add(Me.CboComputerBrowser)
         Me.TabNetwork.Controls.Add(Me.CboWorkstation)
         Me.TabNetwork.Controls.Add(Me.CboDFS)
         Me.TabNetwork.Controls.Add(Me.CboDNS)
         Me.TabNetwork.Controls.Add(Me.CboDHCP)
         Me.TabNetwork.Location = New System.Drawing.Point(4, 24)
         Me.TabNetwork.Name = "TabNetwork"
         Me.TabNetwork.Size = New System.Drawing.Size(622, 357)
         Me.TabNetwork.TabIndex = 2
         Me.TabNetwork.Text = "Network"
         Me.TabNetwork.UseVisualStyleBackColor = True
         '
         'LstNetwork
         '
         Me.LstNetwork.Alignment = System.Windows.Forms.ListViewAlignment.Left
         Me.LstNetwork.BackColor = System.Drawing.Color.White
         Me.LstNetwork.BorderStyle = System.Windows.Forms.BorderStyle.None
         Me.LstNetwork.ForeColor = System.Drawing.Color.Black
         Me.LstNetwork.HideSelection = False
         Me.LstNetwork.Items.AddRange(New System.Windows.Forms.ListViewItem() {ListViewItem22, ListViewItem23, ListViewItem24, ListViewItem25, ListViewItem26, ListViewItem27, ListViewItem28, ListViewItem29, ListViewItem30, ListViewItem31, ListViewItem32, ListViewItem33, ListViewItem34, ListViewItem35, ListViewItem36})
         Me.LstNetwork.LabelWrap = False
         Me.LstNetwork.Location = New System.Drawing.Point(15, 20)
         Me.LstNetwork.MultiSelect = False
         Me.LstNetwork.Name = "LstNetwork"
         Me.LstNetwork.Scrollable = False
         Me.LstNetwork.ShowGroups = False
         Me.LstNetwork.Size = New System.Drawing.Size(400, 460)
         Me.LstNetwork.TabIndex = 1
         Me.LstNetwork.TileSize = New System.Drawing.Size(380, 30)
         Me.LstNetwork.UseCompatibleStateImageBehavior = False
         Me.LstNetwork.View = System.Windows.Forms.View.Tile
         '
         'CboWirelessNet
         '
         Me.CboWirelessNet.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboWirelessNet.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboWirelessNet.FormattingEnabled = True
         Me.CboWirelessNet.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboWirelessNet.Location = New System.Drawing.Point(440, 445)
         Me.CboWirelessNet.Name = "CboWirelessNet"
         Me.CboWirelessNet.Size = New System.Drawing.Size(155, 23)
         Me.CboWirelessNet.TabIndex = 16
         '
         'CboWinTime
         '
         Me.CboWinTime.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboWinTime.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboWinTime.FormattingEnabled = True
         Me.CboWinTime.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboWinTime.Location = New System.Drawing.Point(440, 412)
         Me.CboWinTime.Name = "CboWinTime"
         Me.CboWinTime.Size = New System.Drawing.Size(155, 23)
         Me.CboWinTime.TabIndex = 15
         '
         'CboWebClient
         '
         Me.CboWebClient.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboWebClient.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboWebClient.FormattingEnabled = True
         Me.CboWebClient.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboWebClient.Location = New System.Drawing.Point(440, 382)
         Me.CboWebClient.Name = "CboWebClient"
         Me.CboWebClient.Size = New System.Drawing.Size(155, 23)
         Me.CboWebClient.TabIndex = 14
         '
         'CboIPv6
         '
         Me.CboIPv6.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboIPv6.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboIPv6.FormattingEnabled = True
         Me.CboIPv6.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboIPv6.Location = New System.Drawing.Point(440, 352)
         Me.CboIPv6.Name = "CboIPv6"
         Me.CboIPv6.Size = New System.Drawing.Size(155, 23)
         Me.CboIPv6.TabIndex = 13
         '
         'CboOfflineFiles
         '
         Me.CboOfflineFiles.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboOfflineFiles.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboOfflineFiles.FormattingEnabled = True
         Me.CboOfflineFiles.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboOfflineFiles.Location = New System.Drawing.Point(440, 322)
         Me.CboOfflineFiles.Name = "CboOfflineFiles"
         Me.CboOfflineFiles.Size = New System.Drawing.Size(155, 23)
         Me.CboOfflineFiles.TabIndex = 12
         '
         'CboUPnP
         '
         Me.CboUPnP.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboUPnP.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboUPnP.FormattingEnabled = True
         Me.CboUPnP.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboUPnP.Location = New System.Drawing.Point(440, 292)
         Me.CboUPnP.Name = "CboUPnP"
         Me.CboUPnP.Size = New System.Drawing.Size(155, 23)
         Me.CboUPnP.TabIndex = 11
         '
         'CboTerminal
         '
         Me.CboTerminal.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboTerminal.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboTerminal.FormattingEnabled = True
         Me.CboTerminal.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboTerminal.Location = New System.Drawing.Point(440, 262)
         Me.CboTerminal.Name = "CboTerminal"
         Me.CboTerminal.Size = New System.Drawing.Size(155, 23)
         Me.CboTerminal.TabIndex = 10
         '
         'CboNetBIOSHelper
         '
         Me.CboNetBIOSHelper.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboNetBIOSHelper.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboNetBIOSHelper.FormattingEnabled = True
         Me.CboNetBIOSHelper.Items.AddRange(New Object() {"Automatic Startup", "Manual Startup", "Disabled Startup"})
         Me.CboNetBIOSHelper.Location = New System.Drawing.Point(440, 232)
         Me.CboNetBIOSHelper.Name = "CboNetBIOSHelper"
         Me.CboNetBIOSHelper.Size = New System.Drawing.Size(155, 23)
         Me.CboNetBIOSHelper.TabIndex = 9
         '
         'CboServer
         '
         Me.CboServer.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboServer.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboServer.FormattingEnabled = True
         Me.CboServer.Items.AddRange(New Object() {"Automatic Startup", "Manual Startup", "Disabled Startup"})
         Me.CboServer.Location = New System.Drawing.Point(440, 202)
         Me.CboServer.Name = "CboServer"
         Me.CboServer.Size = New System.Drawing.Size(155, 23)
         Me.CboServer.TabIndex = 8
         '
         'CboFunctionDiscovery
         '
         Me.CboFunctionDiscovery.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboFunctionDiscovery.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboFunctionDiscovery.FormattingEnabled = True
         Me.CboFunctionDiscovery.Items.AddRange(New Object() {"Automatic Startup", "Manual Startup", "Disabled Startup"})
         Me.CboFunctionDiscovery.Location = New System.Drawing.Point(440, 172)
         Me.CboFunctionDiscovery.Name = "CboFunctionDiscovery"
         Me.CboFunctionDiscovery.Size = New System.Drawing.Size(155, 23)
         Me.CboFunctionDiscovery.TabIndex = 7
         '
         'CboComputerBrowser
         '
         Me.CboComputerBrowser.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboComputerBrowser.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboComputerBrowser.FormattingEnabled = True
         Me.CboComputerBrowser.Items.AddRange(New Object() {"Automatic Startup", "Manual Startup", "Disabled Startup"})
         Me.CboComputerBrowser.Location = New System.Drawing.Point(440, 142)
         Me.CboComputerBrowser.Name = "CboComputerBrowser"
         Me.CboComputerBrowser.Size = New System.Drawing.Size(155, 23)
         Me.CboComputerBrowser.TabIndex = 6
         '
         'CboWorkstation
         '
         Me.CboWorkstation.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboWorkstation.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboWorkstation.Enabled = False
         Me.CboWorkstation.FormattingEnabled = True
         Me.CboWorkstation.Items.AddRange(New Object() {"Automatic Startup", "Manual Startup", "Disabled Startup"})
         Me.CboWorkstation.Location = New System.Drawing.Point(440, 112)
         Me.CboWorkstation.Name = "CboWorkstation"
         Me.CboWorkstation.Size = New System.Drawing.Size(155, 23)
         Me.CboWorkstation.TabIndex = 5
         '
         'CboDFS
         '
         Me.CboDFS.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboDFS.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboDFS.Enabled = False
         Me.CboDFS.FormattingEnabled = True
         Me.CboDFS.Items.AddRange(New Object() {"Automatic Startup", "Manual Startup", "Disabled Startup"})
         Me.CboDFS.Location = New System.Drawing.Point(440, 82)
         Me.CboDFS.Name = "CboDFS"
         Me.CboDFS.Size = New System.Drawing.Size(155, 23)
         Me.CboDFS.TabIndex = 4
         '
         'CboDNS
         '
         Me.CboDNS.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboDNS.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboDNS.Enabled = False
         Me.CboDNS.FormattingEnabled = True
         Me.CboDNS.Items.AddRange(New Object() {"Automatic Startup", "Manual Startup", "Disabled Startup"})
         Me.CboDNS.Location = New System.Drawing.Point(440, 52)
         Me.CboDNS.Name = "CboDNS"
         Me.CboDNS.Size = New System.Drawing.Size(155, 23)
         Me.CboDNS.TabIndex = 3
         '
         'CboDHCP
         '
         Me.CboDHCP.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboDHCP.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboDHCP.Enabled = False
         Me.CboDHCP.FormattingEnabled = True
         Me.CboDHCP.Items.AddRange(New Object() {"Automatic Startup", "Manual Startup", "Disabled Startup"})
         Me.CboDHCP.Location = New System.Drawing.Point(440, 22)
         Me.CboDHCP.Name = "CboDHCP"
         Me.CboDHCP.Size = New System.Drawing.Size(155, 23)
         Me.CboDHCP.TabIndex = 2
         '
         'BtnOptimize
         '
         Me.BtnOptimize.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.BtnOptimize.Location = New System.Drawing.Point(471, 560)
         Me.BtnOptimize.Name = "BtnOptimize"
         Me.BtnOptimize.Size = New System.Drawing.Size(85, 25)
         Me.BtnOptimize.TabIndex = 2
         Me.BtnOptimize.Text = "&Optimize"
         Me.BtnOptimize.UseVisualStyleBackColor = True
         '
         'BtnClose
         '
         Me.BtnClose.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.BtnClose.Location = New System.Drawing.Point(562, 560)
         Me.BtnClose.Name = "BtnClose"
         Me.BtnClose.Size = New System.Drawing.Size(85, 25)
         Me.BtnClose.TabIndex = 3
         Me.BtnClose.Text = "&Close"
         Me.BtnClose.UseVisualStyleBackColor = True
         '
         'BWManTuneUp
         '
         Me.BWManTuneUp.WorkerReportsProgress = True
         Me.BWManTuneUp.WorkerSupportsCancellation = True
         '
         'HdrMain
         '
         Me.HdrMain.AllowButtonSpecToolTips = True
         Me.HdrMain.ButtonSpecs.AddRange(New ComponentFactory.Krypton.Toolkit.ButtonSpecAny() {Me.BtnLock, Me.BtnRefresh, Me.BtnSearch, Me.BtnCProfile})
         Me.HdrMain.Dock = System.Windows.Forms.DockStyle.Top
         Me.HdrMain.Location = New System.Drawing.Point(0, 0)
         Me.HdrMain.Name = "HdrMain"
         Me.HdrMain.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2007Silver
         Me.HdrMain.Size = New System.Drawing.Size(659, 53)
         Me.HdrMain.StateNormal.Back.Color1 = System.Drawing.Color.White
         Me.HdrMain.StateNormal.Back.Color2 = System.Drawing.Color.Gainsboro
         Me.HdrMain.StateNormal.Back.ColorStyle = ComponentFactory.Krypton.Toolkit.PaletteColorStyle.HalfCut
         Me.HdrMain.StateNormal.Border.DrawBorders = ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom
         Me.HdrMain.StateNormal.Content.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.HdrMain.StateNormal.Content.ShortText.Font = New System.Drawing.Font("Calibri", 27.75!, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.HdrMain.TabIndex = 0
         Me.HdrMain.TabStop = False
         Me.HdrMain.Values.Description = ""
         Me.HdrMain.Values.Heading = " Manual TuneUp"
         Me.HdrMain.Values.Image = Nothing
         '
         'BtnLock
         '
         Me.BtnLock.Checked = ComponentFactory.Krypton.Toolkit.ButtonCheckState.Checked
         Me.BtnLock.Tag = "0"
         Me.BtnLock.ToolTipBody = "Unlock the modification of critical services."
         Me.BtnLock.UniqueName = ""
         '
         'BtnRefresh
         '
         Me.BtnRefresh.ToolTipBody = "Refresh Windows services status."
         Me.BtnRefresh.UniqueName = ""
         '
         'BtnSearch
         '
         Me.BtnSearch.ContextMenuStrip = Me.ConTxtMnu
         Me.BtnSearch.ToolTipBody = "Search the selected service information."
         Me.BtnSearch.UniqueName = ""
         '
         'ConTxtMnu
         '
         Me.ConTxtMnu.Font = New System.Drawing.Font("Segoe UI", 9.0!)
         Me.ConTxtMnu.Items.AddRange(New System.Windows.Forms.ToolStripItem() {Me.ItmSearchEngine, Me.ItmBlkVpr})
         Me.ConTxtMnu.Name = "ConTxtMnu"
         Me.ConTxtMnu.ShowItemToolTips = False
         Me.ConTxtMnu.Size = New System.Drawing.Size(156, 48)
         '
         'ItmSearchEngine
         '
         Me.ItmSearchEngine.Name = "ItmSearchEngine"
         Me.ItmSearchEngine.Size = New System.Drawing.Size(155, 22)
         Me.ItmSearchEngine.Text = ""
         '
         'ItmBlkVpr
         '
         Me.ItmBlkVpr.Name = "ItmBlkVpr"
         Me.ItmBlkVpr.Size = New System.Drawing.Size(155, 22)
         Me.ItmBlkVpr.Text = "Blackviper.com"
         '
         'BtnCProfile
         '
         Me.BtnCProfile.ToolTipBody = "Create services profile."
         Me.BtnCProfile.UniqueName = ""
         '
         'FrmManual
         '
         Me.AcceptButton = Me.BtnOptimize
         Me.AutoScaleMode = System.Windows.Forms.AutoScaleMode.None
         Me.ClientSize = New System.Drawing.Size(659, 596)
         Me.ControlBox = False
         Me.Controls.Add(Me.HdrMain)
         Me.Controls.Add(Me.BtnClose)
         Me.Controls.Add(Me.BtnOptimize)
         Me.Controls.Add(Me.PnlMain)
         Me.DoubleBuffered = True
         Me.Font = New System.Drawing.Font("Segoe UI", 9.0!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.ForeColor = System.Drawing.Color.Black
         Me.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None
         Me.MaximizeBox = False
         Me.MinimizeBox = False
         Me.Name = "FrmManual"
         Me.ShowIcon = False
         Me.ShowInTaskbar = False
         Me.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide
         Me.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen
         Me.Text = "Manual TuneUp"
         Me.PnlMain.ResumeLayout(False)
         Me.BoxInfo.ResumeLayout(False)
         Me.BoxInfo.PerformLayout()
         Me.PnlStatus.ResumeLayout(False)
         CType(Me.PicStatus, System.ComponentModel.ISupportInitialize).EndInit()
         Me.TabMain.ResumeLayout(False)
         Me.TabPerformance.ResumeLayout(False)
         Me.TabSecurity.ResumeLayout(False)
         Me.TabNetwork.ResumeLayout(False)
         Me.ConTxtMnu.ResumeLayout(False)
         Me.ResumeLayout(False)
         Me.PerformLayout()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmMain.vb" startline="15" endline="922">
<![CDATA[
 
     Private components As System.ComponentModel.IContainer
 
     <System.Diagnostics.DebuggerStepThrough()> _
     Private Sub InitializeComponent()
         Me.components = New System.ComponentModel.Container
         Dim resources As System.ComponentModel.ComponentResourceManager = New System.ComponentModel.ComponentResourceManager(GetType(FrmMain))
         Me.HdrMain = New ComponentFactory.Krypton.Toolkit.KryptonHeader
         Me.BtnHelp = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.PnlSide = New System.Windows.Forms.Panel
         Me.LnkProfiles = New Glass.GlassButton
         Me.LnkHome = New Glass.GlassButton
         Me.LnkManualTuneUp = New Glass.GlassButton
         Me.LnkRescueCntr = New Glass.GlassButton
         Me.LnkAutoTuneUp = New Glass.GlassButton
         Me.LnkDiagnostics = New Glass.GlassButton
         Me.LnkGameMode = New Glass.GlassButton
         Me.LnkSrvcMngr = New Glass.GlassButton
         Me.MDICntrl = New SmartPCUtilities.Components.MdiClientController
         Me.KMngr = New ComponentFactory.Krypton.Toolkit.KryptonManager(Me.components)
         Me.BWCPUUsg = New System.ComponentModel.BackgroundWorker
         Me.TmrUsg = New System.Windows.Forms.Timer(Me.components)
         Me.PnlHome = New System.Windows.Forms.Panel
         Me.BoxSysStatus = New ComponentFactory.Krypton.Toolkit.KryptonGroup
         Me.TrkDrvUsg = New Tracker.Tracker
         Me.TrkCPUUsg = New Tracker.Tracker
         Me.LblDrvUsg = New System.Windows.Forms.Label
         Me.LblCPUUsg = New System.Windows.Forms.Label
         Me.LblMemUsg = New System.Windows.Forms.Label
         Me.TrkMemUsg = New Tracker.Tracker
         Me.HdrSysStatus = New ComponentFactory.Krypton.Toolkit.KryptonHeader
         Me.BoxTips = New ComponentFactory.Krypton.Toolkit.KryptonGroup
         Me.HdrTips = New ComponentFactory.Krypton.Toolkit.KryptonHeader
         Me.PicTips = New System.Windows.Forms.PictureBox
         Me.LblTips = New ComponentFactory.Krypton.Toolkit.KryptonWrapLabel
         Me.BoxSettings = New ComponentFactory.Krypton.Toolkit.KryptonGroup
         Me.LblAutoUpdate_Status = New System.Windows.Forms.Label
         Me.LblSnapshots_Status = New System.Windows.Forms.Label
         Me.LblAutoUpdate = New System.Windows.Forms.Label
         Me.LblSnapshots = New System.Windows.Forms.Label
         Me.LblGameMode = New System.Windows.Forms.Label
         Me.LblDiagnostics = New System.Windows.Forms.Label
         Me.LblGameMode_Status = New System.Windows.Forms.Label
         Me.LblDiagnostics_Status = New System.Windows.Forms.Label
         Me.BtnAutoUpdate = New ComponentFactory.Krypton.Toolkit.KryptonButton
         Me.BtnSnapshots = New ComponentFactory.Krypton.Toolkit.KryptonButton
         Me.BtnGameMode = New ComponentFactory.Krypton.Toolkit.KryptonButton
         Me.BtnDiagnostics = New ComponentFactory.Krypton.Toolkit.KryptonButton
         Me.HdrSettings = New ComponentFactory.Krypton.Toolkit.KryptonHeader
         Me.PnlHdr = New System.Windows.Forms.Panel
         Me.BtnFunctions = New ComponentFactory.Krypton.Toolkit.KryptonDropButton
         Me.ConTxtMnu = New ComponentFactory.Krypton.Toolkit.KryptonContextMenu
         Me.ItmCollection = New ComponentFactory.Krypton.Toolkit.KryptonContextMenuItems
         Me.ItmOptions = New ComponentFactory.Krypton.Toolkit.KryptonContextMenuItem
         Me.ItmSnapshots = New ComponentFactory.Krypton.Toolkit.KryptonContextMenuItem
         Me.ItmUserProfile = New ComponentFactory.Krypton.Toolkit.KryptonContextMenuItem
         Me.ItmWebUpdate = New ComponentFactory.Krypton.Toolkit.KryptonContextMenuItem
         Me.ItmSupport = New ComponentFactory.Krypton.Toolkit.KryptonContextMenuItem
         Me.ItmContribute = New ComponentFactory.Krypton.Toolkit.KryptonContextMenuItem
         Me.ItmAbout = New ComponentFactory.Krypton.Toolkit.KryptonContextMenuItem
         Me.LblCPUInfo = New System.Windows.Forms.Label
         Me.LblMemInfo = New System.Windows.Forms.Label
         Me.LblWinInfo = New System.Windows.Forms.Label
         Me.TmrTips = New System.Windows.Forms.Timer(Me.components)
         Me.BWProfiles = New System.ComponentModel.BackgroundWorker
         Me.BWDiagnostics = New System.ComponentModel.BackgroundWorker
         Me.PnlSide.SuspendLayout()
         Me.PnlHome.SuspendLayout()
         CType(Me.BoxSysStatus, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.BoxSysStatus.Panel, System.ComponentModel.ISupportInitialize).BeginInit()
         Me.BoxSysStatus.Panel.SuspendLayout()
         Me.BoxSysStatus.SuspendLayout()
         CType(Me.BoxTips, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.BoxTips.Panel, System.ComponentModel.ISupportInitialize).BeginInit()
         Me.BoxTips.Panel.SuspendLayout()
         Me.BoxTips.SuspendLayout()
         CType(Me.PicTips, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.BoxSettings, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.BoxSettings.Panel, System.ComponentModel.ISupportInitialize).BeginInit()
         Me.BoxSettings.Panel.SuspendLayout()
         Me.BoxSettings.SuspendLayout()
         Me.PnlHdr.SuspendLayout()
         Me.SuspendLayout()
         '
         'HdrMain
         '
         Me.HdrMain.ButtonSpecs.AddRange(New ComponentFactory.Krypton.Toolkit.ButtonSpecAny() {Me.BtnHelp})
         Me.HdrMain.Dock = System.Windows.Forms.DockStyle.Top
         Me.HdrMain.Location = New System.Drawing.Point(0, 0)
         Me.HdrMain.Name = "HdrMain"
         Me.HdrMain.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.SparkleBlue
         Me.HdrMain.Size = New System.Drawing.Size(934, 55)
         Me.HdrMain.StateNormal.Border.DrawBorders = ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom
         Me.HdrMain.StateNormal.Content.Padding = New System.Windows.Forms.Padding(10, -1, -1, -1)
         Me.HdrMain.StateNormal.Content.ShortText.Font = New System.Drawing.Font("Calibri", 27.75!, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.HdrMain.TabIndex = 0
         Me.HdrMain.TabStop = False
         Me.HdrMain.Values.Description = ""
         Me.HdrMain.Values.Heading = " Vista Services Optimizer"
         Me.HdrMain.Values.Image = Nothing
         '
         'BtnHelp
         '
         Me.BtnHelp.Text = " Help"
         Me.BtnHelp.UniqueName = ""
         '
         'PnlSide
         '
         Me.PnlSide.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Stretch
         Me.PnlSide.Controls.Add(Me.LnkProfiles)
         Me.PnlSide.Controls.Add(Me.LnkHome)
         Me.PnlSide.Controls.Add(Me.LnkManualTuneUp)
         Me.PnlSide.Controls.Add(Me.LnkRescueCntr)
         Me.PnlSide.Controls.Add(Me.LnkAutoTuneUp)
         Me.PnlSide.Controls.Add(Me.LnkDiagnostics)
         Me.PnlSide.Controls.Add(Me.LnkGameMode)
         Me.PnlSide.Controls.Add(Me.LnkSrvcMngr)
         Me.PnlSide.Dock = System.Windows.Forms.DockStyle.Left
         Me.PnlSide.Location = New System.Drawing.Point(0, 55)
         Me.PnlSide.Name = "PnlSide"
         Me.PnlSide.Size = New System.Drawing.Size(275, 599)
         Me.PnlSide.TabIndex = 1
         '
         'LnkProfiles
         '
         Me.LnkProfiles.FadeOnFocus = True
         Me.LnkProfiles.Font = New System.Drawing.Font("Segoe UI", 11.25!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.LnkProfiles.GlowColor = System.Drawing.Color.LightSteelBlue
         Me.LnkProfiles.ImageAlign = System.Drawing.ContentAlignment.MiddleLeft
         Me.LnkProfiles.Location = New System.Drawing.Point(15, 372)
         Me.LnkProfiles.Name = "LnkProfiles"
         Me.LnkProfiles.OuterBorderColor = System.Drawing.Color.FromArgb(CType(CType(64, Byte), Integer), CType(CType(64, Byte), Integer), CType(CType(64, Byte), Integer))
         Me.LnkProfiles.ShineColor = System.Drawing.Color.LightBlue
         Me.LnkProfiles.Size = New System.Drawing.Size(245, 60)
         Me.LnkProfiles.TabIndex = 6
         Me.LnkProfiles.Text = "    Services &Profiles"
         '
         'LnkHome
         '
         Me.LnkHome.FadeOnFocus = True
         Me.LnkHome.Font = New System.Drawing.Font("Segoe UI", 11.25!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.LnkHome.GlowColor = System.Drawing.Color.LightSteelBlue
         Me.LnkHome.ImageAlign = System.Drawing.ContentAlignment.MiddleLeft
         Me.LnkHome.Location = New System.Drawing.Point(15, 22)
         Me.LnkHome.Name = "LnkHome"
         Me.LnkHome.OuterBorderColor = System.Drawing.Color.FromArgb(CType(CType(64, Byte), Integer), CType(CType(64, Byte), Integer), CType(CType(64, Byte), Integer))
         Me.LnkHome.ShineColor = System.Drawing.Color.LightBlue
         Me.LnkHome.Size = New System.Drawing.Size(245, 60)
         Me.LnkHome.TabIndex = 1
         Me.LnkHome.Text = "     Home &Window"
         '
         'LnkManualTuneUp
         '
         Me.LnkManualTuneUp.FadeOnFocus = True
         Me.LnkManualTuneUp.Font = New System.Drawing.Font("Segoe UI", 11.25!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.LnkManualTuneUp.GlowColor = System.Drawing.Color.LightSteelBlue
         Me.LnkManualTuneUp.ImageAlign = System.Drawing.ContentAlignment.MiddleLeft
         Me.LnkManualTuneUp.Location = New System.Drawing.Point(15, 232)
         Me.LnkManualTuneUp.Name = "LnkManualTuneUp"
         Me.LnkManualTuneUp.OuterBorderColor = System.Drawing.Color.FromArgb(CType(CType(64, Byte), Integer), CType(CType(64, Byte), Integer), CType(CType(64, Byte), Integer))
         Me.LnkManualTuneUp.ShineColor = System.Drawing.Color.LightBlue
         Me.LnkManualTuneUp.Size = New System.Drawing.Size(245, 60)
         Me.LnkManualTuneUp.TabIndex = 4
         Me.LnkManualTuneUp.Text = "    &Manual TuneUp"
         '
         'LnkRescueCntr
         '
         Me.LnkRescueCntr.FadeOnFocus = True
         Me.LnkRescueCntr.Font = New System.Drawing.Font("Segoe UI", 11.25!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.LnkRescueCntr.GlowColor = System.Drawing.Color.LightSteelBlue
         Me.LnkRescueCntr.ImageAlign = System.Drawing.ContentAlignment.MiddleLeft
         Me.LnkRescueCntr.Location = New System.Drawing.Point(15, 516)
         Me.LnkRescueCntr.Name = "LnkRescueCntr"
         Me.LnkRescueCntr.OuterBorderColor = System.Drawing.Color.FromArgb(CType(CType(64, Byte), Integer), CType(CType(64, Byte), Integer), CType(CType(64, Byte), Integer))
         Me.LnkRescueCntr.ShineColor = System.Drawing.Color.LightBlue
         Me.LnkRescueCntr.Size = New System.Drawing.Size(245, 60)
         Me.LnkRescueCntr.TabIndex = 8
         Me.LnkRescueCntr.Text = "&Rescue Center"
         '
         'LnkAutoTuneUp
         '
         Me.LnkAutoTuneUp.FadeOnFocus = True
         Me.LnkAutoTuneUp.Font = New System.Drawing.Font("Segoe UI", 11.25!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.LnkAutoTuneUp.GlowColor = System.Drawing.Color.LightSteelBlue
         Me.LnkAutoTuneUp.ImageAlign = System.Drawing.ContentAlignment.MiddleLeft
         Me.LnkAutoTuneUp.Location = New System.Drawing.Point(15, 162)
         Me.LnkAutoTuneUp.Name = "LnkAutoTuneUp"
         Me.LnkAutoTuneUp.OuterBorderColor = System.Drawing.Color.FromArgb(CType(CType(64, Byte), Integer), CType(CType(64, Byte), Integer), CType(CType(64, Byte), Integer))
         Me.LnkAutoTuneUp.ShineColor = System.Drawing.Color.LightBlue
         Me.LnkAutoTuneUp.Size = New System.Drawing.Size(245, 60)
         Me.LnkAutoTuneUp.TabIndex = 3
         Me.LnkAutoTuneUp.Text = "       &Automatic TuneUp"
         '
         'LnkDiagnostics
         '
         Me.LnkDiagnostics.FadeOnFocus = True
         Me.LnkDiagnostics.Font = New System.Drawing.Font("Segoe UI", 11.25!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.LnkDiagnostics.GlowColor = System.Drawing.Color.LightSteelBlue
         Me.LnkDiagnostics.ImageAlign = System.Drawing.ContentAlignment.MiddleLeft
         Me.LnkDiagnostics.Location = New System.Drawing.Point(15, 92)
         Me.LnkDiagnostics.Name = "LnkDiagnostics"
         Me.LnkDiagnostics.OuterBorderColor = System.Drawing.Color.FromArgb(CType(CType(64, Byte), Integer), CType(CType(64, Byte), Integer), CType(CType(64, Byte), Integer))
         Me.LnkDiagnostics.ShineColor = System.Drawing.Color.LightBlue
         Me.LnkDiagnostics.Size = New System.Drawing.Size(245, 60)
         Me.LnkDiagnostics.TabIndex = 2
         Me.LnkDiagnostics.Text = "         Services &Diagnostics"
         '
         'LnkGameMode
         '
         Me.LnkGameMode.FadeOnFocus = True
         Me.LnkGameMode.Font = New System.Drawing.Font("Segoe UI", 11.25!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.LnkGameMode.GlowColor = System.Drawing.Color.LightSteelBlue
         Me.LnkGameMode.ImageAlign = System.Drawing.ContentAlignment.MiddleLeft
         Me.LnkGameMode.Location = New System.Drawing.Point(15, 302)
         Me.LnkGameMode.Name = "LnkGameMode"
         Me.LnkGameMode.OuterBorderColor = System.Drawing.Color.FromArgb(CType(CType(64, Byte), Integer), CType(CType(64, Byte), Integer), CType(CType(64, Byte), Integer))
         Me.LnkGameMode.ShineColor = System.Drawing.Color.LightBlue
         Me.LnkGameMode.Size = New System.Drawing.Size(245, 60)
         Me.LnkGameMode.TabIndex = 5
         Me.LnkGameMode.Text = "    &Gaming Mode"
         '
         'LnkSrvcMngr
         '
         Me.LnkSrvcMngr.FadeOnFocus = True
         Me.LnkSrvcMngr.Font = New System.Drawing.Font("Segoe UI", 11.25!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.LnkSrvcMngr.GlowColor = System.Drawing.Color.LightSteelBlue
         Me.LnkSrvcMngr.ImageAlign = System.Drawing.ContentAlignment.MiddleLeft
         Me.LnkSrvcMngr.Location = New System.Drawing.Point(15, 444)
         Me.LnkSrvcMngr.Name = "LnkSrvcMngr"
         Me.LnkSrvcMngr.OuterBorderColor = System.Drawing.Color.FromArgb(CType(CType(64, Byte), Integer), CType(CType(64, Byte), Integer), CType(CType(64, Byte), Integer))
         Me.LnkSrvcMngr.ShineColor = System.Drawing.Color.LightBlue
         Me.LnkSrvcMngr.Size = New System.Drawing.Size(245, 60)
         Me.LnkSrvcMngr.TabIndex = 7
         Me.LnkSrvcMngr.Text = "    &Services Manager"
         '
         'MDICntrl
         '
         Me.MDICntrl.AutoScroll = False
         Me.MDICntrl.BackColor = System.Drawing.Color.White
         Me.MDICntrl.BorderStyle = System.Windows.Forms.BorderStyle.None
         Me.MDICntrl.ImageAlign = System.Drawing.ContentAlignment.MiddleCenter
         Me.MDICntrl.ParentForm = Me
         '
         'KMngr
         '
         Me.KMngr.GlobalPaletteMode = ComponentFactory.Krypton.Toolkit.PaletteModeManager.Office2010Silver
         '
         'BWCPUUsg
         '
         Me.BWCPUUsg.WorkerReportsProgress = True
         Me.BWCPUUsg.WorkerSupportsCancellation = True
         '
         'TmrUsg
         '
         Me.TmrUsg.Enabled = True
         Me.TmrUsg.Interval = 2000
         '
         'PnlHome
         '
         Me.PnlHome.BackColor = System.Drawing.Color.White
         Me.PnlHome.Controls.Add(Me.BoxSysStatus)
         Me.PnlHome.Controls.Add(Me.BoxTips)
         Me.PnlHome.Controls.Add(Me.BoxSettings)
         Me.PnlHome.Controls.Add(Me.PnlHdr)
         Me.PnlHome.Dock = System.Windows.Forms.DockStyle.Fill
         Me.PnlHome.Location = New System.Drawing.Point(275, 55)
         Me.PnlHome.Name = "PnlHome"
         Me.PnlHome.Size = New System.Drawing.Size(659, 599)
         Me.PnlHome.TabIndex = 2
         '
         'BoxSysStatus
         '
         Me.BoxSysStatus.GroupBackStyle = ComponentFactory.Krypton.Toolkit.PaletteBackStyle.TabDock
         Me.BoxSysStatus.Location = New System.Drawing.Point(12, 110)
         Me.BoxSysStatus.Name = "BoxSysStatus"
         Me.BoxSysStatus.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Silver
         '
         'BoxSysStatus.Panel
         '
         Me.BoxSysStatus.Panel.Controls.Add(Me.TrkDrvUsg)
         Me.BoxSysStatus.Panel.Controls.Add(Me.TrkCPUUsg)
         Me.BoxSysStatus.Panel.Controls.Add(Me.LblDrvUsg)
         Me.BoxSysStatus.Panel.Controls.Add(Me.LblCPUUsg)
         Me.BoxSysStatus.Panel.Controls.Add(Me.LblMemUsg)
         Me.BoxSysStatus.Panel.Controls.Add(Me.TrkMemUsg)
         Me.BoxSysStatus.Panel.Controls.Add(Me.HdrSysStatus)
         Me.BoxSysStatus.Size = New System.Drawing.Size(635, 185)
         Me.BoxSysStatus.StateNormal.Border.DrawBorders = CType((((ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Top Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Left) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Right), ComponentFactory.Krypton.Toolkit.PaletteDrawBorders)
         Me.BoxSysStatus.StateNormal.Border.Rounding = 3
         Me.BoxSysStatus.TabIndex = 0
         '
         'TrkDrvUsg
         '
         Me.TrkDrvUsg.Anchor = System.Windows.Forms.AnchorStyles.None
         Me.TrkDrvUsg.BackColor = System.Drawing.Color.Black
         Me.TrkDrvUsg.Location = New System.Drawing.Point(31, 37)
         Me.TrkDrvUsg.Name = "TrkDrvUsg"
         Me.TrkDrvUsg.RefreshingTime = Tracker.Tracker.eRefresh.Slow
         Me.TrkDrvUsg.Size = New System.Drawing.Size(175, 105)
         Me.TrkDrvUsg.TabIndex = 0
         Me.TrkDrvUsg.TabStop = False
         '
         'TrkCPUUsg
         '
         Me.TrkCPUUsg.Anchor = System.Windows.Forms.AnchorStyles.None
         Me.TrkCPUUsg.BackColor = System.Drawing.Color.Black
         Me.TrkCPUUsg.Location = New System.Drawing.Point(425, 37)
         Me.TrkCPUUsg.Name = "TrkCPUUsg"
         Me.TrkCPUUsg.RefreshingTime = Tracker.Tracker.eRefresh.Slow
         Me.TrkCPUUsg.Size = New System.Drawing.Size(175, 105)
         Me.TrkCPUUsg.TabIndex = 0
         Me.TrkCPUUsg.TabStop = False
         '
         'LblDrvUsg
         '
         Me.LblDrvUsg.Anchor = System.Windows.Forms.AnchorStyles.None
         Me.LblDrvUsg.BackColor = System.Drawing.Color.Transparent
         Me.LblDrvUsg.Location = New System.Drawing.Point(28, 150)
         Me.LblDrvUsg.Name = "LblDrvUsg"
         Me.LblDrvUsg.Size = New System.Drawing.Size(175, 20)
         Me.LblDrvUsg.TabIndex = 0
         Me.LblDrvUsg.Text = "System drive usage
         '
         'LblCPUUsg
         '
         Me.LblCPUUsg.Anchor = System.Windows.Forms.AnchorStyles.None
         Me.LblCPUUsg.BackColor = System.Drawing.Color.Transparent
         Me.LblCPUUsg.Location = New System.Drawing.Point(422, 150)
         Me.LblCPUUsg.Name = "LblCPUUsg"
         Me.LblCPUUsg.Size = New System.Drawing.Size(175, 20)
         Me.LblCPUUsg.TabIndex = 0
         Me.LblCPUUsg.Text = "CPU usage
         '
         'LblMemUsg
         '
         Me.LblMemUsg.Anchor = System.Windows.Forms.AnchorStyles.None
         Me.LblMemUsg.BackColor = System.Drawing.Color.Transparent
         Me.LblMemUsg.Location = New System.Drawing.Point(225, 150)
         Me.LblMemUsg.Name = "LblMemUsg"
         Me.LblMemUsg.Size = New System.Drawing.Size(175, 20)
         Me.LblMemUsg.TabIndex = 0
         Me.LblMemUsg.Text = "Memory usage
         '
         'TrkMemUsg
         '
         Me.TrkMemUsg.Anchor = System.Windows.Forms.AnchorStyles.None
         Me.TrkMemUsg.BackColor = System.Drawing.Color.Black
         Me.TrkMemUsg.Location = New System.Drawing.Point(228, 37)
         Me.TrkMemUsg.Name = "TrkMemUsg"
         Me.TrkMemUsg.RefreshingTime = Tracker.Tracker.eRefresh.Slow
         Me.TrkMemUsg.Size = New System.Drawing.Size(175, 105)
         Me.TrkMemUsg.TabIndex = 0
         Me.TrkMemUsg.TabStop = False
         '
         'HdrSysStatus
         '
         Me.HdrSysStatus.Dock = System.Windows.Forms.DockStyle.Top
         Me.HdrSysStatus.Location = New System.Drawing.Point(0, 0)
         Me.HdrSysStatus.Name = "HdrSysStatus"
         Me.HdrSysStatus.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Silver
         Me.HdrSysStatus.Size = New System.Drawing.Size(631, 25)
         Me.HdrSysStatus.StateNormal.Back.ColorStyle = ComponentFactory.Krypton.Toolkit.PaletteColorStyle.HalfCut
         Me.HdrSysStatus.StateNormal.Border.DrawBorders = ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom
         Me.HdrSysStatus.StateNormal.Border.Rounding = 3
         Me.HdrSysStatus.StateNormal.Content.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.HdrSysStatus.StateNormal.Content.ShortText.Font = New System.Drawing.Font("Segoe UI", 11.25!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.HdrSysStatus.TabIndex = 0
         Me.HdrSysStatus.TabStop = False
         Me.HdrSysStatus.Values.Description = ""
         Me.HdrSysStatus.Values.Heading = "System Status"
         Me.HdrSysStatus.Values.Image = Nothing
         '
         'BoxTips
         '
         Me.BoxTips.GroupBackStyle = ComponentFactory.Krypton.Toolkit.PaletteBackStyle.TabDock
         Me.BoxTips.Location = New System.Drawing.Point(12, 482)
         Me.BoxTips.Name = "BoxTips"
         Me.BoxTips.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Silver
         '
         'BoxTips.Panel
         '
         Me.BoxTips.Panel.Controls.Add(Me.HdrTips)
         Me.BoxTips.Panel.Controls.Add(Me.PicTips)
         Me.BoxTips.Panel.Controls.Add(Me.LblTips)
         Me.BoxTips.Size = New System.Drawing.Size(635, 105)
         Me.BoxTips.StateNormal.Border.DrawBorders = CType((((ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Top Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Left) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Right), ComponentFactory.Krypton.Toolkit.PaletteDrawBorders)
         Me.BoxTips.StateNormal.Border.Rounding = 3
         Me.BoxTips.TabIndex = 0
         '
         'HdrTips
         '
         Me.HdrTips.Dock = System.Windows.Forms.DockStyle.Top
         Me.HdrTips.Location = New System.Drawing.Point(0, 0)
         Me.HdrTips.Name = "HdrTips"
         Me.HdrTips.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Silver
         Me.HdrTips.Size = New System.Drawing.Size(631, 25)
         Me.HdrTips.StateNormal.Back.ColorStyle = ComponentFactory.Krypton.Toolkit.PaletteColorStyle.HalfCut
         Me.HdrTips.StateNormal.Border.DrawBorders = ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom
         Me.HdrTips.StateNormal.Border.Rounding = 3
         Me.HdrTips.StateNormal.Content.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.HdrTips.StateNormal.Content.ShortText.Font = New System.Drawing.Font("Segoe UI", 11.25!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.HdrTips.TabIndex = 0
         Me.HdrTips.TabStop = False
         Me.HdrTips.Values.Description = ""
         Me.HdrTips.Values.Heading = "Tips"
         Me.HdrTips.Values.Image = Nothing
         '
         'PicTips
         '
         Me.PicTips.BackColor = System.Drawing.Color.Transparent
         Me.PicTips.ErrorImage = Nothing
         Me.PicTips.InitialImage = Nothing
         Me.PicTips.Location = New System.Drawing.Point(18, 38)
         Me.PicTips.Name = "PicTips"
         Me.PicTips.Size = New System.Drawing.Size(50, 50)
         Me.PicTips.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage
         Me.PicTips.TabIndex = 0
         Me.PicTips.TabStop = False
         '
         'LblTips
         '
         Me.LblTips.Anchor = CType(((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.LblTips.AutoSize = False
         Me.LblTips.Font = New System.Drawing.Font("Segoe UI", 9.0!)
         Me.LblTips.ForeColor = System.Drawing.Color.FromArgb(CType(CType(59, Byte), Integer), CType(CType(59, Byte), Integer), CType(CType(59, Byte), Integer))
         Me.LblTips.Location = New System.Drawing.Point(80, 45)
         Me.LblTips.Name = "LblTips"
         Me.LblTips.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Silver
         Me.LblTips.Size = New System.Drawing.Size(540, 40)
         Me.LblTips.UseMnemonic = False
         '
         'BoxSettings
         '
         Me.BoxSettings.GroupBackStyle = ComponentFactory.Krypton.Toolkit.PaletteBackStyle.TabDock
         Me.BoxSettings.Location = New System.Drawing.Point(12, 301)
         Me.BoxSettings.Name = "BoxSettings"
         Me.BoxSettings.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Silver
         '
         'BoxSettings.Panel
         '
         Me.BoxSettings.Panel.Controls.Add(Me.LblAutoUpdate_Status)
         Me.BoxSettings.Panel.Controls.Add(Me.LblSnapshots_Status)
         Me.BoxSettings.Panel.Controls.Add(Me.LblAutoUpdate)
         Me.BoxSettings.Panel.Controls.Add(Me.LblSnapshots)
         Me.BoxSettings.Panel.Controls.Add(Me.LblGameMode)
         Me.BoxSettings.Panel.Controls.Add(Me.LblDiagnostics)
         Me.BoxSettings.Panel.Controls.Add(Me.LblGameMode_Status)
         Me.BoxSettings.Panel.Controls.Add(Me.LblDiagnostics_Status)
         Me.BoxSettings.Panel.Controls.Add(Me.BtnAutoUpdate)
         Me.BoxSettings.Panel.Controls.Add(Me.BtnSnapshots)
         Me.BoxSettings.Panel.Controls.Add(Me.BtnGameMode)
         Me.BoxSettings.Panel.Controls.Add(Me.BtnDiagnostics)
         Me.BoxSettings.Panel.Controls.Add(Me.HdrSettings)
         Me.BoxSettings.Size = New System.Drawing.Size(635, 175)
         Me.BoxSettings.StateNormal.Border.DrawBorders = CType((((ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Top Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Left) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Right), ComponentFactory.Krypton.Toolkit.PaletteDrawBorders)
         Me.BoxSettings.StateNormal.Border.Rounding = 3
         Me.BoxSettings.TabIndex = 0
         '
         'LblAutoUpdate_Status
         '
         Me.LblAutoUpdate_Status.Anchor = System.Windows.Forms.AnchorStyles.None
         Me.LblAutoUpdate_Status.AutoSize = True
         Me.LblAutoUpdate_Status.BackColor = System.Drawing.Color.Transparent
         Me.LblAutoUpdate_Status.Cursor = System.Windows.Forms.Cursors.Hand
         Me.LblAutoUpdate_Status.ForeColor = System.Drawing.Color.RoyalBlue
         Me.LblAutoUpdate_Status.Location = New System.Drawing.Point(494, 143)
         Me.LblAutoUpdate_Status.Name = "LblAutoUpdate_Status"
         Me.LblAutoUpdate_Status.Size = New System.Drawing.Size(0, 15)
         Me.LblAutoUpdate_Status.TabIndex = 0
         '
         'LblSnapshots_Status
         '
         Me.LblSnapshots_Status.Anchor = System.Windows.Forms.AnchorStyles.None
         Me.LblSnapshots_Status.AutoSize = True
         Me.LblSnapshots_Status.BackColor = System.Drawing.Color.Transparent
         Me.LblSnapshots_Status.Cursor = System.Windows.Forms.Cursors.Hand
         Me.LblSnapshots_Status.ForeColor = System.Drawing.Color.RoyalBlue
         Me.LblSnapshots_Status.Location = New System.Drawing.Point(329, 143)
         Me.LblSnapshots_Status.Name = "LblSnapshots_Status"
         Me.LblSnapshots_Status.Size = New System.Drawing.Size(0, 15)
         Me.LblSnapshots_Status.TabIndex = 0
         '
         'LblAutoUpdate
         '
         Me.LblAutoUpdate.Anchor = System.Windows.Forms.AnchorStyles.None
         Me.LblAutoUpdate.AutoSize = True
         Me.LblAutoUpdate.BackColor = System.Drawing.Color.Transparent
         Me.LblAutoUpdate.Location = New System.Drawing.Point(494, 123)
         Me.LblAutoUpdate.Name = "LblAutoUpdate"
         Me.LblAutoUpdate.Size = New System.Drawing.Size(115, 15)
         Me.LblAutoUpdate.TabIndex = 0
         Me.LblAutoUpdate.Text = "Automatic Update is"
         '
         'LblSnapshots
         '
         Me.LblSnapshots.Anchor = System.Windows.Forms.AnchorStyles.None
         Me.LblSnapshots.AutoSize = True
         Me.LblSnapshots.BackColor = System.Drawing.Color.Transparent
         Me.LblSnapshots.Location = New System.Drawing.Point(329, 123)
         Me.LblSnapshots.Name = "LblSnapshots"
         Me.LblSnapshots.Size = New System.Drawing.Size(131, 15)
         Me.LblSnapshots.TabIndex = 0
         Me.LblSnapshots.Text = "Automatic Snapshots is"
         '
         'LblGameMode
         '
         Me.LblGameMode.Anchor = System.Windows.Forms.AnchorStyles.None
         Me.LblGameMode.AutoSize = True
         Me.LblGameMode.BackColor = System.Drawing.Color.Transparent
         Me.LblGameMode.Location = New System.Drawing.Point(191, 123)
         Me.LblGameMode.Name = "LblGameMode"
         Me.LblGameMode.Size = New System.Drawing.Size(94, 15)
         Me.LblGameMode.TabIndex = 0
         Me.LblGameMode.Text = "Gaming Mode is"
         '
         'LblDiagnostics
         '
         Me.LblDiagnostics.Anchor = System.Windows.Forms.AnchorStyles.None
         Me.LblDiagnostics.AutoSize = True
         Me.LblDiagnostics.BackColor = System.Drawing.Color.Transparent
         Me.LblDiagnostics.Location = New System.Drawing.Point(28, 123)
         Me.LblDiagnostics.Name = "LblDiagnostics"
         Me.LblDiagnostics.Size = New System.Drawing.Size(113, 15)
         Me.LblDiagnostics.TabIndex = 0
         Me.LblDiagnostics.Text = "Services Diagnostics"
         '
         'LblGameMode_Status
         '
         Me.LblGameMode_Status.Anchor = System.Windows.Forms.AnchorStyles.None
         Me.LblGameMode_Status.AutoSize = True
         Me.LblGameMode_Status.BackColor = System.Drawing.Color.Transparent
         Me.LblGameMode_Status.Cursor = System.Windows.Forms.Cursors.Hand
         Me.LblGameMode_Status.ForeColor = System.Drawing.Color.RoyalBlue
         Me.LblGameMode_Status.Location = New System.Drawing.Point(191, 143)
         Me.LblGameMode_Status.Name = "LblGameMode_Status"
         Me.LblGameMode_Status.Size = New System.Drawing.Size(0, 15)
         Me.LblGameMode_Status.TabIndex = 0
         '
         'LblDiagnostics_Status
         '
         Me.LblDiagnostics_Status.Anchor = System.Windows.Forms.AnchorStyles.None
         Me.LblDiagnostics_Status.AutoSize = True
         Me.LblDiagnostics_Status.BackColor = System.Drawing.Color.Transparent
         Me.LblDiagnostics_Status.Cursor = System.Windows.Forms.Cursors.Hand
         Me.LblDiagnostics_Status.ForeColor = System.Drawing.Color.RoyalBlue
         Me.LblDiagnostics_Status.Location = New System.Drawing.Point(28, 143)
         Me.LblDiagnostics_Status.Name = "LblDiagnostics_Status"
         Me.LblDiagnostics_Status.Size = New System.Drawing.Size(0, 15)
         Me.LblDiagnostics_Status.TabIndex = 0
         '
         'BtnAutoUpdate
         '
         Me.BtnAutoUpdate.Anchor = System.Windows.Forms.AnchorStyles.None
         Me.BtnAutoUpdate.Location = New System.Drawing.Point(514, 38)
         Me.BtnAutoUpdate.Name = "BtnAutoUpdate"
         Me.BtnAutoUpdate.OverrideDefault.Back.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnAutoUpdate.OverrideDefault.Border.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnAutoUpdate.OverrideDefault.Border.DrawBorders = CType((((ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Top Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Left) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Right), ComponentFactory.Krypton.Toolkit.PaletteDrawBorders)
         Me.BtnAutoUpdate.OverrideDefault.Content.DrawFocus = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnAutoUpdate.OverrideFocus.Back.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnAutoUpdate.OverrideFocus.Border.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnAutoUpdate.OverrideFocus.Border.DrawBorders = CType((((ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Top Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Left) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Right), ComponentFactory.Krypton.Toolkit.PaletteDrawBorders)
         Me.BtnAutoUpdate.OverrideFocus.Content.DrawFocus = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnAutoUpdate.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Silver
         Me.BtnAutoUpdate.Size = New System.Drawing.Size(70, 70)
         Me.BtnAutoUpdate.StateNormal.Back.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnAutoUpdate.StateNormal.Border.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnAutoUpdate.StateNormal.Border.DrawBorders = CType((((ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Top Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Left) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Right), ComponentFactory.Krypton.Toolkit.PaletteDrawBorders)
         Me.BtnAutoUpdate.StateNormal.Content.DrawFocus = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnAutoUpdate.StatePressed.Back.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnAutoUpdate.StatePressed.Border.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnAutoUpdate.StatePressed.Border.DrawBorders = CType((((ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Top Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Left) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Right), ComponentFactory.Krypton.Toolkit.PaletteDrawBorders)
         Me.BtnAutoUpdate.StatePressed.Content.DrawFocus = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnAutoUpdate.StateTracking.Back.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnAutoUpdate.StateTracking.Border.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnAutoUpdate.StateTracking.Border.DrawBorders = CType((((ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Top Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Left) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Right), ComponentFactory.Krypton.Toolkit.PaletteDrawBorders)
         Me.BtnAutoUpdate.StateTracking.Content.DrawFocus = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnAutoUpdate.StateTracking.Content.Image.Effect = ComponentFactory.Krypton.Toolkit.PaletteImageEffect.Light
         Me.BtnAutoUpdate.TabIndex = 0
         Me.BtnAutoUpdate.TabStop = False
         Me.BtnAutoUpdate.Values.Text = ""
         '
         'BtnSnapshots
         '
         Me.BtnSnapshots.Anchor = System.Windows.Forms.AnchorStyles.None
         Me.BtnSnapshots.Location = New System.Drawing.Point(358, 38)
         Me.BtnSnapshots.Name = "BtnSnapshots"
         Me.BtnSnapshots.OverrideDefault.Back.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnSnapshots.OverrideDefault.Border.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnSnapshots.OverrideDefault.Border.DrawBorders = CType((((ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Top Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Left) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Right), ComponentFactory.Krypton.Toolkit.PaletteDrawBorders)
         Me.BtnSnapshots.OverrideDefault.Content.DrawFocus = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnSnapshots.OverrideFocus.Back.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnSnapshots.OverrideFocus.Border.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnSnapshots.OverrideFocus.Border.DrawBorders = CType((((ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Top Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Left) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Right), ComponentFactory.Krypton.Toolkit.PaletteDrawBorders)
         Me.BtnSnapshots.OverrideFocus.Content.DrawFocus = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnSnapshots.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Silver
         Me.BtnSnapshots.Size = New System.Drawing.Size(70, 70)
         Me.BtnSnapshots.StateNormal.Back.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnSnapshots.StateNormal.Border.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnSnapshots.StateNormal.Border.DrawBorders = CType((((ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Top Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Left) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Right), ComponentFactory.Krypton.Toolkit.PaletteDrawBorders)
         Me.BtnSnapshots.StateNormal.Content.DrawFocus = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnSnapshots.StatePressed.Back.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnSnapshots.StatePressed.Border.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnSnapshots.StatePressed.Border.DrawBorders = CType((((ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Top Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Left) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Right), ComponentFactory.Krypton.Toolkit.PaletteDrawBorders)
         Me.BtnSnapshots.StatePressed.Content.DrawFocus = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnSnapshots.StateTracking.Back.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnSnapshots.StateTracking.Border.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnSnapshots.StateTracking.Border.DrawBorders = CType((((ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Top Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Left) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Right), ComponentFactory.Krypton.Toolkit.PaletteDrawBorders)
         Me.BtnSnapshots.StateTracking.Content.DrawFocus = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnSnapshots.StateTracking.Content.Image.Effect = ComponentFactory.Krypton.Toolkit.PaletteImageEffect.Light
         Me.BtnSnapshots.TabIndex = 0
         Me.BtnSnapshots.TabStop = False
         Me.BtnSnapshots.Values.Text = ""
         '
         'BtnGameMode
         '
         Me.BtnGameMode.Anchor = System.Windows.Forms.AnchorStyles.None
         Me.BtnGameMode.Location = New System.Drawing.Point(202, 38)
         Me.BtnGameMode.Name = "BtnGameMode"
         Me.BtnGameMode.OverrideDefault.Back.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnGameMode.OverrideDefault.Border.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnGameMode.OverrideDefault.Border.DrawBorders = CType((((ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Top Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Left) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Right), ComponentFactory.Krypton.Toolkit.PaletteDrawBorders)
         Me.BtnGameMode.OverrideDefault.Content.DrawFocus = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnGameMode.OverrideFocus.Back.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnGameMode.OverrideFocus.Border.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnGameMode.OverrideFocus.Border.DrawBorders = CType((((ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Top Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Left) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Right), ComponentFactory.Krypton.Toolkit.PaletteDrawBorders)
         Me.BtnGameMode.OverrideFocus.Content.DrawFocus = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnGameMode.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Silver
         Me.BtnGameMode.Size = New System.Drawing.Size(70, 70)
         Me.BtnGameMode.StateNormal.Back.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnGameMode.StateNormal.Border.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnGameMode.StateNormal.Border.DrawBorders = CType((((ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Top Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Left) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Right), ComponentFactory.Krypton.Toolkit.PaletteDrawBorders)
         Me.BtnGameMode.StateNormal.Content.DrawFocus = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnGameMode.StatePressed.Back.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnGameMode.StatePressed.Border.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnGameMode.StatePressed.Border.DrawBorders = CType((((ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Top Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Left) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Right), ComponentFactory.Krypton.Toolkit.PaletteDrawBorders)
         Me.BtnGameMode.StatePressed.Content.DrawFocus = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnGameMode.StateTracking.Back.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnGameMode.StateTracking.Border.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnGameMode.StateTracking.Border.DrawBorders = CType((((ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Top Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Left) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Right), ComponentFactory.Krypton.Toolkit.PaletteDrawBorders)
         Me.BtnGameMode.StateTracking.Content.DrawFocus = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnGameMode.StateTracking.Content.Image.Effect = ComponentFactory.Krypton.Toolkit.PaletteImageEffect.Light
         Me.BtnGameMode.TabIndex = 0
         Me.BtnGameMode.TabStop = False
         Me.BtnGameMode.Values.Text = ""
         '
         'BtnDiagnostics
         '
         Me.BtnDiagnostics.Anchor = System.Windows.Forms.AnchorStyles.None
         Me.BtnDiagnostics.Location = New System.Drawing.Point(46, 38)
         Me.BtnDiagnostics.Name = "BtnDiagnostics"
         Me.BtnDiagnostics.OverrideDefault.Back.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnDiagnostics.OverrideDefault.Border.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnDiagnostics.OverrideDefault.Border.DrawBorders = CType((((ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Top Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Left) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Right), ComponentFactory.Krypton.Toolkit.PaletteDrawBorders)
         Me.BtnDiagnostics.OverrideDefault.Content.DrawFocus = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnDiagnostics.OverrideFocus.Back.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnDiagnostics.OverrideFocus.Border.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnDiagnostics.OverrideFocus.Border.DrawBorders = CType((((ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Top Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Left) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Right), ComponentFactory.Krypton.Toolkit.PaletteDrawBorders)
         Me.BtnDiagnostics.OverrideFocus.Content.DrawFocus = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnDiagnostics.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Silver
         Me.BtnDiagnostics.Size = New System.Drawing.Size(70, 70)
         Me.BtnDiagnostics.StateNormal.Back.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnDiagnostics.StateNormal.Border.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnDiagnostics.StateNormal.Border.DrawBorders = CType((((ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Top Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Left) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Right), ComponentFactory.Krypton.Toolkit.PaletteDrawBorders)
         Me.BtnDiagnostics.StateNormal.Content.DrawFocus = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnDiagnostics.StatePressed.Back.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnDiagnostics.StatePressed.Border.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnDiagnostics.StatePressed.Border.DrawBorders = CType((((ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Top Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Left) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Right), ComponentFactory.Krypton.Toolkit.PaletteDrawBorders)
         Me.BtnDiagnostics.StatePressed.Content.DrawFocus = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnDiagnostics.StateTracking.Back.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnDiagnostics.StateTracking.Border.Draw = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnDiagnostics.StateTracking.Border.DrawBorders = CType((((ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Top Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Left) _
                     Or ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Right), ComponentFactory.Krypton.Toolkit.PaletteDrawBorders)
         Me.BtnDiagnostics.StateTracking.Content.DrawFocus = ComponentFactory.Krypton.Toolkit.InheritBool.[False]
         Me.BtnDiagnostics.StateTracking.Content.Image.Effect = ComponentFactory.Krypton.Toolkit.PaletteImageEffect.Light
         Me.BtnDiagnostics.TabIndex = 0
         Me.BtnDiagnostics.TabStop = False
         Me.BtnDiagnostics.Values.Text = ""
         '
         'HdrSettings
         '
         Me.HdrSettings.Dock = System.Windows.Forms.DockStyle.Top
         Me.HdrSettings.Location = New System.Drawing.Point(0, 0)
         Me.HdrSettings.Name = "HdrSettings"
         Me.HdrSettings.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2010Silver
         Me.HdrSettings.Size = New System.Drawing.Size(631, 25)
         Me.HdrSettings.StateNormal.Back.ColorStyle = ComponentFactory.Krypton.Toolkit.PaletteColorStyle.HalfCut
         Me.HdrSettings.StateNormal.Border.DrawBorders = ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom
         Me.HdrSettings.StateNormal.Border.Rounding = 3
         Me.HdrSettings.StateNormal.Content.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.HdrSettings.StateNormal.Content.ShortText.Font = New System.Drawing.Font("Segoe UI", 11.25!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.HdrSettings.TabIndex = 0
         Me.HdrSettings.TabStop = False
         Me.HdrSettings.Values.Description = ""
         Me.HdrSettings.Values.Heading = "Settings"
         Me.HdrSettings.Values.Image = Nothing
         '
         'PnlHdr
         '
         Me.PnlHdr.BackColor = System.Drawing.Color.Black
         Me.PnlHdr.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Stretch
         Me.PnlHdr.Controls.Add(Me.BtnFunctions)
         Me.PnlHdr.Controls.Add(Me.LblCPUInfo)
         Me.PnlHdr.Controls.Add(Me.LblMemInfo)
         Me.PnlHdr.Controls.Add(Me.LblWinInfo)
         Me.PnlHdr.Dock = System.Windows.Forms.DockStyle.Top
         Me.PnlHdr.Location = New System.Drawing.Point(0, 0)
         Me.PnlHdr.Name = "PnlHdr"
         Me.PnlHdr.Size = New System.Drawing.Size(659, 100)
         Me.PnlHdr.TabIndex = 1
         '
         'BtnFunctions
         '
         Me.BtnFunctions.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.BtnFunctions.KryptonContextMenu = Me.ConTxtMnu
         Me.BtnFunctions.Location = New System.Drawing.Point(507, 36)
         Me.BtnFunctions.Name = "BtnFunctions"
         Me.BtnFunctions.OverrideDefault.Back.ColorStyle = ComponentFactory.Krypton.Toolkit.PaletteColorStyle.GlassTrackingFull
         Me.BtnFunctions.OverrideDefault.Content.ShortText.Font = New System.Drawing.Font("Arial", 9.75!, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.BtnFunctions.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.SparkleBlue
         Me.BtnFunctions.Size = New System.Drawing.Size(140, 28)
         Me.BtnFunctions.Splitter = False
         Me.BtnFunctions.StateNormal.Back.ColorStyle = ComponentFactory.Krypton.Toolkit.PaletteColorStyle.GlassTrackingFull
         Me.BtnFunctions.StateNormal.Content.ShortText.Font = New System.Drawing.Font("Arial", 9.75!, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.BtnFunctions.StatePressed.Back.ColorStyle = ComponentFactory.Krypton.Toolkit.PaletteColorStyle.GlassTrackingFull
         Me.BtnFunctions.StatePressed.Content.ShortText.Font = New System.Drawing.Font("Arial", 9.75!, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.BtnFunctions.StateTracking.Back.ColorStyle = ComponentFactory.Krypton.Toolkit.PaletteColorStyle.GlassTrackingFull
         Me.BtnFunctions.StateTracking.Content.ShortText.Font = New System.Drawing.Font("Arial", 9.75!, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.BtnFunctions.TabIndex = 1
         Me.BtnFunctions.Values.Text = "More Functions"
         '
         'ConTxtMnu
         '
         Me.ConTxtMnu.Items.AddRange(New ComponentFactory.Krypton.Toolkit.KryptonContextMenuItemBase() {Me.ItmCollection})
         Me.ConTxtMnu.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.SparkleBlue
         '
         'ItmCollection
         '
         Me.ItmCollection.Items.AddRange(New ComponentFactory.Krypton.Toolkit.KryptonContextMenuItemBase() {Me.ItmOptions, Me.ItmSnapshots, Me.ItmUserProfile, Me.ItmWebUpdate, Me.ItmSupport, Me.ItmContribute, Me.ItmAbout})
         '
         'ItmOptions
         '
         Me.ItmOptions.Text = "Options"
         '
         'ItmSnapshots
         '
         Me.ItmSnapshots.Text = "Create snapshot"
         '
         'ItmUserProfile
         '
         Me.ItmUserProfile.Text = "User Profile"
         '
         'ItmWebUpdate
         '
         Me.ItmWebUpdate.Text = "Check for updates"
         '
         'ItmSupport
         '
         Me.ItmSupport.Text = "Support"
         '
         'ItmContribute
         '
         Me.ItmContribute.Text = "Contribute"
         '
         'ItmAbout
         '
         Me.ItmAbout.Text = "About"
         '
         'LblCPUInfo
         '
         Me.LblCPUInfo.AutoSize = True
         Me.LblCPUInfo.BackColor = System.Drawing.Color.Transparent
         Me.LblCPUInfo.Cursor = System.Windows.Forms.Cursors.Hand
         Me.LblCPUInfo.Font = New System.Drawing.Font("Segoe UI", 9.75!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.LblCPUInfo.ForeColor = System.Drawing.Color.White
         Me.LblCPUInfo.Location = New System.Drawing.Point(18, 42)
         Me.LblCPUInfo.Name = "LblCPUInfo"
         Me.LblCPUInfo.Size = New System.Drawing.Size(0, 17)
         Me.LblCPUInfo.TabIndex = 0
         '
         'LblMemInfo
         '
         Me.LblMemInfo.AutoSize = True
         Me.LblMemInfo.BackColor = System.Drawing.Color.Transparent
         Me.LblMemInfo.Cursor = System.Windows.Forms.Cursors.Hand
         Me.LblMemInfo.Font = New System.Drawing.Font("Segoe UI", 9.75!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.LblMemInfo.ForeColor = System.Drawing.Color.White
         Me.LblMemInfo.Location = New System.Drawing.Point(18, 70)
         Me.LblMemInfo.Name = "LblMemInfo"
         Me.LblMemInfo.Size = New System.Drawing.Size(0, 17)
         Me.LblMemInfo.TabIndex = 0
         '
         'LblWinInfo
         '
         Me.LblWinInfo.AutoSize = True
         Me.LblWinInfo.BackColor = System.Drawing.Color.Transparent
         Me.LblWinInfo.Cursor = System.Windows.Forms.Cursors.Hand
         Me.LblWinInfo.Font = New System.Drawing.Font("Segoe UI", 9.75!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.LblWinInfo.ForeColor = System.Drawing.Color.White
         Me.LblWinInfo.Location = New System.Drawing.Point(18, 14)
         Me.LblWinInfo.Name = "LblWinInfo"
         Me.LblWinInfo.Size = New System.Drawing.Size(0, 17)
         Me.LblWinInfo.TabIndex = 0
         '
         'TmrTips
         '
         Me.TmrTips.Enabled = True
         Me.TmrTips.Interval = 7000
         '
         'BWProfiles
         '
         Me.BWProfiles.WorkerReportsProgress = True
         Me.BWProfiles.WorkerSupportsCancellation = True
         '
         'BWDiagnostics
         '
         Me.BWDiagnostics.WorkerReportsProgress = True
         Me.BWDiagnostics.WorkerSupportsCancellation = True
         '
         'FrmMain
         '
         Me.AutoScaleMode = System.Windows.Forms.AutoScaleMode.None
         Me.BackColor = System.Drawing.Color.Black
         Me.ClientSize = New System.Drawing.Size(934, 654)
         Me.Controls.Add(Me.PnlHome)
         Me.Controls.Add(Me.PnlSide)
         Me.Controls.Add(Me.HdrMain)
         Me.DoubleBuffered = True
         Me.Font = New System.Drawing.Font("Segoe UI", 9.0!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.ForeColor = System.Drawing.Color.Black
         Me.Icon = CType(resources.GetObject("$this.Icon"), System.Drawing.Icon)
         Me.IsMdiContainer = True
         Me.Margin = New System.Windows.Forms.Padding(4)
         Me.MinimumSize = New System.Drawing.Size(950, 690)
         Me.Name = "FrmMain"
         Me.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide
         Me.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen
         Me.Text = "Vista Services Optimizer"
         Me.PnlSide.ResumeLayout(False)
         Me.PnlHome.ResumeLayout(False)
         CType(Me.BoxSysStatus.Panel, System.ComponentModel.ISupportInitialize).EndInit()
         Me.BoxSysStatus.Panel.ResumeLayout(False)
         Me.BoxSysStatus.Panel.PerformLayout()
         CType(Me.BoxSysStatus, System.ComponentModel.ISupportInitialize).EndInit()
         Me.BoxSysStatus.ResumeLayout(False)
         CType(Me.BoxTips.Panel, System.ComponentModel.ISupportInitialize).EndInit()
         Me.BoxTips.Panel.ResumeLayout(False)
         Me.BoxTips.Panel.PerformLayout()
         CType(Me.BoxTips, System.ComponentModel.ISupportInitialize).EndInit()
         Me.BoxTips.ResumeLayout(False)
         CType(Me.PicTips, System.ComponentModel.ISupportInitialize).EndInit()
         CType(Me.BoxSettings.Panel, System.ComponentModel.ISupportInitialize).EndInit()
         Me.BoxSettings.Panel.ResumeLayout(False)
         Me.BoxSettings.Panel.PerformLayout()
         CType(Me.BoxSettings, System.ComponentModel.ISupportInitialize).EndInit()
         Me.BoxSettings.ResumeLayout(False)
         Me.PnlHdr.ResumeLayout(False)
         Me.PnlHdr.PerformLayout()
         Me.ResumeLayout(False)
         Me.PerformLayout()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\c vb\C# VB 2\src\ServicesOptimizer\Forms\FrmManual.vb" startline="15" endline="866">
<![CDATA[
 
     Private components As System.ComponentModel.IContainer
 
     <System.Diagnostics.DebuggerStepThrough()> _
     Private Sub InitializeComponent()
         Me.components = New System.ComponentModel.Container
         Dim ListViewItem1 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I want Windows visual styles and themes
         Dim ListViewItem2 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I want transparent windows with 3D and glass effects
         Dim ListViewItem3 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I use Windows Media Center to play movies and other multimedia
         Dim ListViewItem4 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I share Media Player libraries with other networked players
         Dim ListViewItem5 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I want system to index and cache files for fast searching
         Dim ListViewItem6 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("Some of my programs are not compatible with Windows
         Dim ListViewItem7 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I use System Diagnostic and Problem Detection tools
         Dim ListViewItem8 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I have a printer or use a network printer
         Dim ListViewItem9 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I have a scanner or a digital camera
         Dim ListViewItem10 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I use the pen of the Tablet PC
         Dim ListViewItem11 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I want system to track logon, network and other system events
         Dim ListViewItem12 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I need to start processes under alternate credentials
         Dim ListViewItem13 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I want to send programs error reports to Microsoft
         Dim ListViewItem14 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I use Windows disk defragmenting tool
         Dim ListViewItem15 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I use Windows Security Center
         Dim ListViewItem16 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I want Windows Update to check for new updates automatically
         Dim ListViewItem17 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I use Windows Defender, I do not use another Anti-Spyware
         Dim ListViewItem18 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I use Windows Firewall, I do not use another Firewall
         Dim ListViewItem19 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I use Windows Backup to backup and restore files
         Dim ListViewItem20 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("Allow remote users to modify registry settings on my computer
         Dim ListViewItem21 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I use encrypted network connections (VPN / IPsec)
         Dim ListViewItem22 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("DHCP Service
         Dim ListViewItem23 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("DNS Client Service
         Dim ListViewItem24 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("DFS Replication Service
         Dim ListViewItem25 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("WorkStation Service
         Dim ListViewItem26 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("Computer Browser Service
         Dim ListViewItem27 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("Function Discovery Resource Publication Service
         Dim ListViewItem28 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("Server Service
         Dim ListViewItem29 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("TCP/IP NetBIOS Helper Service
         Dim ListViewItem30 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("Allow remote users to connect interactively to my computer
         Dim ListViewItem31 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("Allow the discovery of UPnP devices on my home network
         Dim ListViewItem32 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I want to cache offline files on my local computer
         Dim ListViewItem33 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("My Network uses the IPv6 protocol
         Dim ListViewItem34 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("Allow programs to create, access and modify Internet-based files
         Dim ListViewItem35 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("Synchronize computer date and time to the network
         Dim ListViewItem36 As System.Windows.Forms.ListViewItem = New System.Windows.Forms.ListViewItem("I use a wireless network to access the Internet
         Me.PnlMain = New System.Windows.Forms.Panel
         Me.BoxInfo = New System.Windows.Forms.GroupBox
         Me.PnlStatus = New System.Windows.Forms.Panel
         Me.PicStatus = New System.Windows.Forms.PictureBox
         Me.TxtInfo = New System.Windows.Forms.TextBox
         Me.TabMain = New System.Windows.Forms.TabControl
         Me.TabPerformance = New System.Windows.Forms.TabPage
         Me.LstPerformance = New System.Windows.Forms.ListView
         Me.CboDefrag = New System.Windows.Forms.ComboBox
         Me.CboErrReport = New System.Windows.Forms.ComboBox
         Me.CboSecondLogon = New System.Windows.Forms.ComboBox
         Me.CboSystemEvent = New System.Windows.Forms.ComboBox
         Me.CboTabletPC = New System.Windows.Forms.ComboBox
         Me.CboScanner = New System.Windows.Forms.ComboBox
         Me.CboPrinter = New System.Windows.Forms.ComboBox
         Me.CboDiagnostics = New System.Windows.Forms.ComboBox
         Me.CboCompatibility = New System.Windows.Forms.ComboBox
         Me.CboWinSearch = New System.Windows.Forms.ComboBox
         Me.CboMediaShare = New System.Windows.Forms.ComboBox
         Me.CboMediaCntr = New System.Windows.Forms.ComboBox
         Me.CboWinAero = New System.Windows.Forms.ComboBox
         Me.CboThemes = New System.Windows.Forms.ComboBox
         Me.TabSecurity = New System.Windows.Forms.TabPage
         Me.LstSecurity = New System.Windows.Forms.ListView
         Me.CboIPSec = New System.Windows.Forms.ComboBox
         Me.CboRmtReg = New System.Windows.Forms.ComboBox
         Me.CboWinBackup = New System.Windows.Forms.ComboBox
         Me.CboWinFirewall = New System.Windows.Forms.ComboBox
         Me.CboWinDefender = New System.Windows.Forms.ComboBox
         Me.CboWinUpdate = New System.Windows.Forms.ComboBox
         Me.CboSecCntr = New System.Windows.Forms.ComboBox
         Me.TabNetwork = New System.Windows.Forms.TabPage
         Me.LstNetwork = New System.Windows.Forms.ListView
         Me.CboWirelessNet = New System.Windows.Forms.ComboBox
         Me.CboWinTime = New System.Windows.Forms.ComboBox
         Me.CboWebClient = New System.Windows.Forms.ComboBox
         Me.CboIPv6 = New System.Windows.Forms.ComboBox
         Me.CboOfflineFiles = New System.Windows.Forms.ComboBox
         Me.CboUPnP = New System.Windows.Forms.ComboBox
         Me.CboTerminal = New System.Windows.Forms.ComboBox
         Me.CboNetBIOSHelper = New System.Windows.Forms.ComboBox
         Me.CboServer = New System.Windows.Forms.ComboBox
         Me.CboFunctionDiscovery = New System.Windows.Forms.ComboBox
         Me.CboComputerBrowser = New System.Windows.Forms.ComboBox
         Me.CboWorkstation = New System.Windows.Forms.ComboBox
         Me.CboDFS = New System.Windows.Forms.ComboBox
         Me.CboDNS = New System.Windows.Forms.ComboBox
         Me.CboDHCP = New System.Windows.Forms.ComboBox
         Me.BtnOptimize = New System.Windows.Forms.Button
         Me.BtnClose = New System.Windows.Forms.Button
         Me.BWManTuneUp = New System.ComponentModel.BackgroundWorker
         Me.HdrMain = New ComponentFactory.Krypton.Toolkit.KryptonHeader
         Me.BtnLock = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnRefresh = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.BtnSearch = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.ConTxtMnu = New System.Windows.Forms.ContextMenuStrip(Me.components)
         Me.ItmSearchEngine = New System.Windows.Forms.ToolStripMenuItem
         Me.ItmBlkVpr = New System.Windows.Forms.ToolStripMenuItem
         Me.BtnCProfile = New ComponentFactory.Krypton.Toolkit.ButtonSpecAny
         Me.PnlMain.SuspendLayout()
         Me.BoxInfo.SuspendLayout()
         Me.PnlStatus.SuspendLayout()
         CType(Me.PicStatus, System.ComponentModel.ISupportInitialize).BeginInit()
         Me.TabMain.SuspendLayout()
         Me.TabPerformance.SuspendLayout()
         Me.TabSecurity.SuspendLayout()
         Me.TabNetwork.SuspendLayout()
         Me.ConTxtMnu.SuspendLayout()
         Me.SuspendLayout()
         '
         'PnlMain
         '
         Me.PnlMain.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
                     Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.PnlMain.BackColor = System.Drawing.Color.White
         Me.PnlMain.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.PnlMain.Controls.Add(Me.BoxInfo)
         Me.PnlMain.Controls.Add(Me.TabMain)
         Me.PnlMain.Location = New System.Drawing.Point(-2, 49)
         Me.PnlMain.Name = "PnlMain"
         Me.PnlMain.Size = New System.Drawing.Size(663, 500)
         Me.PnlMain.TabIndex = 1
         '
         'BoxInfo
         '
         Me.BoxInfo.Anchor = CType(((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.BoxInfo.Controls.Add(Me.PnlStatus)
         Me.BoxInfo.Controls.Add(Me.TxtInfo)
         Me.BoxInfo.Location = New System.Drawing.Point(14, 406)
         Me.BoxInfo.Name = "BoxInfo"
         Me.BoxInfo.Size = New System.Drawing.Size(630, 80)
         Me.BoxInfo.TabIndex = 0
         Me.BoxInfo.TabStop = False
         '
         'PnlStatus
         '
         Me.PnlStatus.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Stretch
         Me.PnlStatus.Controls.Add(Me.PicStatus)
         Me.PnlStatus.Location = New System.Drawing.Point(11, 18)
         Me.PnlStatus.Name = "PnlStatus"
         Me.PnlStatus.Size = New System.Drawing.Size(50, 50)
         Me.PnlStatus.TabIndex = 0
         '
         'PicStatus
         '
         Me.PicStatus.BackColor = System.Drawing.Color.Transparent
         Me.PicStatus.ErrorImage = Nothing
         Me.PicStatus.InitialImage = Nothing
         Me.PicStatus.Location = New System.Drawing.Point(32, 32)
         Me.PicStatus.Name = "PicStatus"
         Me.PicStatus.Size = New System.Drawing.Size(18, 18)
         Me.PicStatus.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage
         Me.PicStatus.TabIndex = 0
         Me.PicStatus.TabStop = False
         '
         'TxtInfo
         '
         Me.TxtInfo.Anchor = CType(((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.TxtInfo.BackColor = System.Drawing.Color.White
         Me.TxtInfo.BorderStyle = System.Windows.Forms.BorderStyle.None
         Me.TxtInfo.Cursor = System.Windows.Forms.Cursors.Arrow
         Me.TxtInfo.ForeColor = System.Drawing.Color.Black
         Me.TxtInfo.Location = New System.Drawing.Point(67, 18)
         Me.TxtInfo.Multiline = True
         Me.TxtInfo.Name = "TxtInfo"
         Me.TxtInfo.ReadOnly = True
         Me.TxtInfo.ScrollBars = System.Windows.Forms.ScrollBars.Vertical
         Me.TxtInfo.Size = New System.Drawing.Size(555, 50)
         Me.TxtInfo.TabIndex = 0
         Me.TxtInfo.TabStop = False
         '
         'TabMain
         '
         Me.TabMain.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
                     Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.TabMain.Controls.Add(Me.TabPerformance)
         Me.TabMain.Controls.Add(Me.TabSecurity)
         Me.TabMain.Controls.Add(Me.TabNetwork)
         Me.TabMain.Location = New System.Drawing.Point(14, 15)
         Me.TabMain.Name = "TabMain"
         Me.TabMain.SelectedIndex = 0
         Me.TabMain.Size = New System.Drawing.Size(630, 385)
         Me.TabMain.TabIndex = 1
         '
         'TabPerformance
         '
         Me.TabPerformance.AutoScroll = True
         Me.TabPerformance.BackColor = System.Drawing.Color.White
         Me.TabPerformance.Controls.Add(Me.LstPerformance)
         Me.TabPerformance.Controls.Add(Me.CboDefrag)
         Me.TabPerformance.Controls.Add(Me.CboErrReport)
         Me.TabPerformance.Controls.Add(Me.CboSecondLogon)
         Me.TabPerformance.Controls.Add(Me.CboSystemEvent)
         Me.TabPerformance.Controls.Add(Me.CboTabletPC)
         Me.TabPerformance.Controls.Add(Me.CboScanner)
         Me.TabPerformance.Controls.Add(Me.CboPrinter)
         Me.TabPerformance.Controls.Add(Me.CboDiagnostics)
         Me.TabPerformance.Controls.Add(Me.CboCompatibility)
         Me.TabPerformance.Controls.Add(Me.CboWinSearch)
         Me.TabPerformance.Controls.Add(Me.CboMediaShare)
         Me.TabPerformance.Controls.Add(Me.CboMediaCntr)
         Me.TabPerformance.Controls.Add(Me.CboWinAero)
         Me.TabPerformance.Controls.Add(Me.CboThemes)
         Me.TabPerformance.Location = New System.Drawing.Point(4, 24)
         Me.TabPerformance.Name = "TabPerformance"
         Me.TabPerformance.Padding = New System.Windows.Forms.Padding(3)
         Me.TabPerformance.Size = New System.Drawing.Size(622, 357)
         Me.TabPerformance.TabIndex = 0
         Me.TabPerformance.Text = "Performance"
         Me.TabPerformance.UseVisualStyleBackColor = True
         '
         'LstPerformance
         '
         Me.LstPerformance.Alignment = System.Windows.Forms.ListViewAlignment.Left
         Me.LstPerformance.BackColor = System.Drawing.Color.White
         Me.LstPerformance.BorderStyle = System.Windows.Forms.BorderStyle.None
         Me.LstPerformance.ForeColor = System.Drawing.Color.Black
         Me.LstPerformance.HideSelection = False
         Me.LstPerformance.Items.AddRange(New System.Windows.Forms.ListViewItem() {ListViewItem1, ListViewItem2, ListViewItem3, ListViewItem4, ListViewItem5, ListViewItem6, ListViewItem7, ListViewItem8, ListViewItem9, ListViewItem10, ListViewItem11, ListViewItem12, ListViewItem13, ListViewItem14})
         Me.LstPerformance.LabelWrap = False
         Me.LstPerformance.Location = New System.Drawing.Point(15, 20)
         Me.LstPerformance.MultiSelect = False
         Me.LstPerformance.Name = "LstPerformance"
         Me.LstPerformance.Scrollable = False
         Me.LstPerformance.ShowGroups = False
         Me.LstPerformance.Size = New System.Drawing.Size(400, 430)
         Me.LstPerformance.TabIndex = 1
         Me.LstPerformance.TileSize = New System.Drawing.Size(380, 30)
         Me.LstPerformance.UseCompatibleStateImageBehavior = False
         Me.LstPerformance.View = System.Windows.Forms.View.Tile
         '
         'CboDefrag
         '
         Me.CboDefrag.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboDefrag.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboDefrag.FormattingEnabled = True
         Me.CboDefrag.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboDefrag.Location = New System.Drawing.Point(440, 414)
         Me.CboDefrag.Name = "CboDefrag"
         Me.CboDefrag.Size = New System.Drawing.Size(155, 23)
         Me.CboDefrag.TabIndex = 15
         '
         'CboErrReport
         '
         Me.CboErrReport.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboErrReport.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboErrReport.FormattingEnabled = True
         Me.CboErrReport.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboErrReport.Location = New System.Drawing.Point(440, 382)
         Me.CboErrReport.Name = "CboErrReport"
         Me.CboErrReport.Size = New System.Drawing.Size(155, 23)
         Me.CboErrReport.TabIndex = 14
         '
         'CboSecondLogon
         '
         Me.CboSecondLogon.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboSecondLogon.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboSecondLogon.FormattingEnabled = True
         Me.CboSecondLogon.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboSecondLogon.Location = New System.Drawing.Point(440, 352)
         Me.CboSecondLogon.Name = "CboSecondLogon"
         Me.CboSecondLogon.Size = New System.Drawing.Size(155, 23)
         Me.CboSecondLogon.TabIndex = 13
         '
         'CboSystemEvent
         '
         Me.CboSystemEvent.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboSystemEvent.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboSystemEvent.FormattingEnabled = True
         Me.CboSystemEvent.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboSystemEvent.Location = New System.Drawing.Point(440, 322)
         Me.CboSystemEvent.Name = "CboSystemEvent"
         Me.CboSystemEvent.Size = New System.Drawing.Size(155, 23)
         Me.CboSystemEvent.TabIndex = 12
         '
         'CboTabletPC
         '
         Me.CboTabletPC.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboTabletPC.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboTabletPC.FormattingEnabled = True
         Me.CboTabletPC.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboTabletPC.Location = New System.Drawing.Point(440, 292)
         Me.CboTabletPC.Name = "CboTabletPC"
         Me.CboTabletPC.Size = New System.Drawing.Size(155, 23)
         Me.CboTabletPC.TabIndex = 11
         '
         'CboScanner
         '
         Me.CboScanner.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboScanner.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboScanner.FormattingEnabled = True
         Me.CboScanner.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboScanner.Location = New System.Drawing.Point(440, 262)
         Me.CboScanner.Name = "CboScanner"
         Me.CboScanner.Size = New System.Drawing.Size(155, 23)
         Me.CboScanner.TabIndex = 10
         '
         'CboPrinter
         '
         Me.CboPrinter.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboPrinter.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboPrinter.FormattingEnabled = True
         Me.CboPrinter.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboPrinter.Location = New System.Drawing.Point(440, 232)
         Me.CboPrinter.Name = "CboPrinter"
         Me.CboPrinter.Size = New System.Drawing.Size(155, 23)
         Me.CboPrinter.TabIndex = 9
         '
         'CboDiagnostics
         '
         Me.CboDiagnostics.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboDiagnostics.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboDiagnostics.FormattingEnabled = True
         Me.CboDiagnostics.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboDiagnostics.Location = New System.Drawing.Point(440, 202)
         Me.CboDiagnostics.Name = "CboDiagnostics"
         Me.CboDiagnostics.Size = New System.Drawing.Size(155, 23)
         Me.CboDiagnostics.TabIndex = 8
         '
         'CboCompatibility
         '
         Me.CboCompatibility.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboCompatibility.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboCompatibility.FormattingEnabled = True
         Me.CboCompatibility.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboCompatibility.Location = New System.Drawing.Point(440, 172)
         Me.CboCompatibility.Name = "CboCompatibility"
         Me.CboCompatibility.Size = New System.Drawing.Size(155, 23)
         Me.CboCompatibility.TabIndex = 7
         '
         'CboWinSearch
         '
         Me.CboWinSearch.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboWinSearch.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboWinSearch.FormattingEnabled = True
         Me.CboWinSearch.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboWinSearch.Location = New System.Drawing.Point(440, 142)
         Me.CboWinSearch.Name = "CboWinSearch"
         Me.CboWinSearch.Size = New System.Drawing.Size(155, 23)
         Me.CboWinSearch.TabIndex = 6
         '
         'CboMediaShare
         '
         Me.CboMediaShare.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboMediaShare.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboMediaShare.FormattingEnabled = True
         Me.CboMediaShare.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboMediaShare.Location = New System.Drawing.Point(440, 112)
         Me.CboMediaShare.Name = "CboMediaShare"
         Me.CboMediaShare.Size = New System.Drawing.Size(155, 23)
         Me.CboMediaShare.TabIndex = 5
         '
         'CboMediaCntr
         '
         Me.CboMediaCntr.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboMediaCntr.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboMediaCntr.FormattingEnabled = True
         Me.CboMediaCntr.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboMediaCntr.Location = New System.Drawing.Point(440, 82)
         Me.CboMediaCntr.Name = "CboMediaCntr"
         Me.CboMediaCntr.Size = New System.Drawing.Size(155, 23)
         Me.CboMediaCntr.TabIndex = 4
         '
         'CboWinAero
         '
         Me.CboWinAero.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboWinAero.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboWinAero.FormattingEnabled = True
         Me.CboWinAero.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboWinAero.Location = New System.Drawing.Point(440, 52)
         Me.CboWinAero.Name = "CboWinAero"
         Me.CboWinAero.Size = New System.Drawing.Size(155, 23)
         Me.CboWinAero.TabIndex = 3
         '
         'CboThemes
         '
         Me.CboThemes.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboThemes.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboThemes.FormattingEnabled = True
         Me.CboThemes.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboThemes.Location = New System.Drawing.Point(440, 22)
         Me.CboThemes.Name = "CboThemes"
         Me.CboThemes.Size = New System.Drawing.Size(155, 23)
         Me.CboThemes.TabIndex = 2
         '
         'TabSecurity
         '
         Me.TabSecurity.BackColor = System.Drawing.Color.White
         Me.TabSecurity.Controls.Add(Me.LstSecurity)
         Me.TabSecurity.Controls.Add(Me.CboIPSec)
         Me.TabSecurity.Controls.Add(Me.CboRmtReg)
         Me.TabSecurity.Controls.Add(Me.CboWinBackup)
         Me.TabSecurity.Controls.Add(Me.CboWinFirewall)
         Me.TabSecurity.Controls.Add(Me.CboWinDefender)
         Me.TabSecurity.Controls.Add(Me.CboWinUpdate)
         Me.TabSecurity.Controls.Add(Me.CboSecCntr)
         Me.TabSecurity.Location = New System.Drawing.Point(4, 24)
         Me.TabSecurity.Name = "TabSecurity"
         Me.TabSecurity.Padding = New System.Windows.Forms.Padding(3)
         Me.TabSecurity.Size = New System.Drawing.Size(622, 357)
         Me.TabSecurity.TabIndex = 1
         Me.TabSecurity.Text = "Security"
         Me.TabSecurity.UseVisualStyleBackColor = True
         '
         'LstSecurity
         '
         Me.LstSecurity.Alignment = System.Windows.Forms.ListViewAlignment.Left
         Me.LstSecurity.BackColor = System.Drawing.Color.White
         Me.LstSecurity.BorderStyle = System.Windows.Forms.BorderStyle.None
         Me.LstSecurity.ForeColor = System.Drawing.Color.Black
         Me.LstSecurity.HideSelection = False
         Me.LstSecurity.Items.AddRange(New System.Windows.Forms.ListViewItem() {ListViewItem15, ListViewItem16, ListViewItem17, ListViewItem18, ListViewItem19, ListViewItem20, ListViewItem21})
         Me.LstSecurity.LabelWrap = False
         Me.LstSecurity.Location = New System.Drawing.Point(15, 20)
         Me.LstSecurity.MultiSelect = False
         Me.LstSecurity.Name = "LstSecurity"
         Me.LstSecurity.Scrollable = False
         Me.LstSecurity.ShowGroups = False
         Me.LstSecurity.Size = New System.Drawing.Size(400, 220)
         Me.LstSecurity.TabIndex = 1
         Me.LstSecurity.TileSize = New System.Drawing.Size(380, 30)
         Me.LstSecurity.UseCompatibleStateImageBehavior = False
         Me.LstSecurity.View = System.Windows.Forms.View.Tile
         '
         'CboIPSec
         '
         Me.CboIPSec.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboIPSec.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboIPSec.FormattingEnabled = True
         Me.CboIPSec.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboIPSec.Location = New System.Drawing.Point(440, 202)
         Me.CboIPSec.Name = "CboIPSec"
         Me.CboIPSec.Size = New System.Drawing.Size(155, 23)
         Me.CboIPSec.TabIndex = 8
         '
         'CboRmtReg
         '
         Me.CboRmtReg.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboRmtReg.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboRmtReg.FormattingEnabled = True
         Me.CboRmtReg.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboRmtReg.Location = New System.Drawing.Point(440, 172)
         Me.CboRmtReg.Name = "CboRmtReg"
         Me.CboRmtReg.Size = New System.Drawing.Size(155, 23)
         Me.CboRmtReg.TabIndex = 7
         '
         'CboWinBackup
         '
         Me.CboWinBackup.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboWinBackup.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboWinBackup.FormattingEnabled = True
         Me.CboWinBackup.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboWinBackup.Location = New System.Drawing.Point(440, 142)
         Me.CboWinBackup.Name = "CboWinBackup"
         Me.CboWinBackup.Size = New System.Drawing.Size(155, 23)
         Me.CboWinBackup.TabIndex = 6
         '
         'CboWinFirewall
         '
         Me.CboWinFirewall.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboWinFirewall.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboWinFirewall.Enabled = False
         Me.CboWinFirewall.FormattingEnabled = True
         Me.CboWinFirewall.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboWinFirewall.Location = New System.Drawing.Point(440, 112)
         Me.CboWinFirewall.Name = "CboWinFirewall"
         Me.CboWinFirewall.Size = New System.Drawing.Size(155, 23)
         Me.CboWinFirewall.TabIndex = 5
         '
         'CboWinDefender
         '
         Me.CboWinDefender.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboWinDefender.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboWinDefender.Enabled = False
         Me.CboWinDefender.FormattingEnabled = True
         Me.CboWinDefender.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboWinDefender.Location = New System.Drawing.Point(440, 82)
         Me.CboWinDefender.Name = "CboWinDefender"
         Me.CboWinDefender.Size = New System.Drawing.Size(155, 23)
         Me.CboWinDefender.TabIndex = 4
         '
         'CboWinUpdate
         '
         Me.CboWinUpdate.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboWinUpdate.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboWinUpdate.Enabled = False
         Me.CboWinUpdate.FormattingEnabled = True
         Me.CboWinUpdate.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboWinUpdate.Location = New System.Drawing.Point(440, 52)
         Me.CboWinUpdate.Name = "CboWinUpdate"
         Me.CboWinUpdate.Size = New System.Drawing.Size(155, 23)
         Me.CboWinUpdate.TabIndex = 3
         '
         'CboSecCntr
         '
         Me.CboSecCntr.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboSecCntr.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboSecCntr.Enabled = False
         Me.CboSecCntr.FormattingEnabled = True
         Me.CboSecCntr.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboSecCntr.Location = New System.Drawing.Point(440, 22)
         Me.CboSecCntr.Name = "CboSecCntr"
         Me.CboSecCntr.Size = New System.Drawing.Size(155, 23)
         Me.CboSecCntr.TabIndex = 2
         '
         'TabNetwork
         '
         Me.TabNetwork.AutoScroll = True
         Me.TabNetwork.BackColor = System.Drawing.Color.White
         Me.TabNetwork.Controls.Add(Me.LstNetwork)
         Me.TabNetwork.Controls.Add(Me.CboWirelessNet)
         Me.TabNetwork.Controls.Add(Me.CboWinTime)
         Me.TabNetwork.Controls.Add(Me.CboWebClient)
         Me.TabNetwork.Controls.Add(Me.CboIPv6)
         Me.TabNetwork.Controls.Add(Me.CboOfflineFiles)
         Me.TabNetwork.Controls.Add(Me.CboUPnP)
         Me.TabNetwork.Controls.Add(Me.CboTerminal)
         Me.TabNetwork.Controls.Add(Me.CboNetBIOSHelper)
         Me.TabNetwork.Controls.Add(Me.CboServer)
         Me.TabNetwork.Controls.Add(Me.CboFunctionDiscovery)
         Me.TabNetwork.Controls.Add(Me.CboComputerBrowser)
         Me.TabNetwork.Controls.Add(Me.CboWorkstation)
         Me.TabNetwork.Controls.Add(Me.CboDFS)
         Me.TabNetwork.Controls.Add(Me.CboDNS)
         Me.TabNetwork.Controls.Add(Me.CboDHCP)
         Me.TabNetwork.Location = New System.Drawing.Point(4, 24)
         Me.TabNetwork.Name = "TabNetwork"
         Me.TabNetwork.Size = New System.Drawing.Size(622, 357)
         Me.TabNetwork.TabIndex = 2
         Me.TabNetwork.Text = "Network"
         Me.TabNetwork.UseVisualStyleBackColor = True
         '
         'LstNetwork
         '
         Me.LstNetwork.Alignment = System.Windows.Forms.ListViewAlignment.Left
         Me.LstNetwork.BackColor = System.Drawing.Color.White
         Me.LstNetwork.BorderStyle = System.Windows.Forms.BorderStyle.None
         Me.LstNetwork.ForeColor = System.Drawing.Color.Black
         Me.LstNetwork.HideSelection = False
         Me.LstNetwork.Items.AddRange(New System.Windows.Forms.ListViewItem() {ListViewItem22, ListViewItem23, ListViewItem24, ListViewItem25, ListViewItem26, ListViewItem27, ListViewItem28, ListViewItem29, ListViewItem30, ListViewItem31, ListViewItem32, ListViewItem33, ListViewItem34, ListViewItem35, ListViewItem36})
         Me.LstNetwork.LabelWrap = False
         Me.LstNetwork.Location = New System.Drawing.Point(15, 20)
         Me.LstNetwork.MultiSelect = False
         Me.LstNetwork.Name = "LstNetwork"
         Me.LstNetwork.Scrollable = False
         Me.LstNetwork.ShowGroups = False
         Me.LstNetwork.Size = New System.Drawing.Size(400, 460)
         Me.LstNetwork.TabIndex = 1
         Me.LstNetwork.TileSize = New System.Drawing.Size(380, 30)
         Me.LstNetwork.UseCompatibleStateImageBehavior = False
         Me.LstNetwork.View = System.Windows.Forms.View.Tile
         '
         'CboWirelessNet
         '
         Me.CboWirelessNet.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboWirelessNet.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboWirelessNet.FormattingEnabled = True
         Me.CboWirelessNet.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboWirelessNet.Location = New System.Drawing.Point(440, 445)
         Me.CboWirelessNet.Name = "CboWirelessNet"
         Me.CboWirelessNet.Size = New System.Drawing.Size(155, 23)
         Me.CboWirelessNet.TabIndex = 16
         '
         'CboWinTime
         '
         Me.CboWinTime.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboWinTime.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboWinTime.FormattingEnabled = True
         Me.CboWinTime.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboWinTime.Location = New System.Drawing.Point(440, 412)
         Me.CboWinTime.Name = "CboWinTime"
         Me.CboWinTime.Size = New System.Drawing.Size(155, 23)
         Me.CboWinTime.TabIndex = 15
         '
         'CboWebClient
         '
         Me.CboWebClient.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboWebClient.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboWebClient.FormattingEnabled = True
         Me.CboWebClient.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboWebClient.Location = New System.Drawing.Point(440, 382)
         Me.CboWebClient.Name = "CboWebClient"
         Me.CboWebClient.Size = New System.Drawing.Size(155, 23)
         Me.CboWebClient.TabIndex = 14
         '
         'CboIPv6
         '
         Me.CboIPv6.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboIPv6.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboIPv6.FormattingEnabled = True
         Me.CboIPv6.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboIPv6.Location = New System.Drawing.Point(440, 352)
         Me.CboIPv6.Name = "CboIPv6"
         Me.CboIPv6.Size = New System.Drawing.Size(155, 23)
         Me.CboIPv6.TabIndex = 13
         '
         'CboOfflineFiles
         '
         Me.CboOfflineFiles.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboOfflineFiles.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboOfflineFiles.FormattingEnabled = True
         Me.CboOfflineFiles.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboOfflineFiles.Location = New System.Drawing.Point(440, 322)
         Me.CboOfflineFiles.Name = "CboOfflineFiles"
         Me.CboOfflineFiles.Size = New System.Drawing.Size(155, 23)
         Me.CboOfflineFiles.TabIndex = 12
         '
         'CboUPnP
         '
         Me.CboUPnP.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboUPnP.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboUPnP.FormattingEnabled = True
         Me.CboUPnP.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboUPnP.Location = New System.Drawing.Point(440, 292)
         Me.CboUPnP.Name = "CboUPnP"
         Me.CboUPnP.Size = New System.Drawing.Size(155, 23)
         Me.CboUPnP.TabIndex = 11
         '
         'CboTerminal
         '
         Me.CboTerminal.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboTerminal.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboTerminal.FormattingEnabled = True
         Me.CboTerminal.Items.AddRange(New Object() {"Yes - Automatic Startup", "Maybe - Manual Startup", "No - Disabled Startup"})
         Me.CboTerminal.Location = New System.Drawing.Point(440, 262)
         Me.CboTerminal.Name = "CboTerminal"
         Me.CboTerminal.Size = New System.Drawing.Size(155, 23)
         Me.CboTerminal.TabIndex = 10
         '
         'CboNetBIOSHelper
         '
         Me.CboNetBIOSHelper.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboNetBIOSHelper.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboNetBIOSHelper.FormattingEnabled = True
         Me.CboNetBIOSHelper.Items.AddRange(New Object() {"Automatic Startup", "Manual Startup", "Disabled Startup"})
         Me.CboNetBIOSHelper.Location = New System.Drawing.Point(440, 232)
         Me.CboNetBIOSHelper.Name = "CboNetBIOSHelper"
         Me.CboNetBIOSHelper.Size = New System.Drawing.Size(155, 23)
         Me.CboNetBIOSHelper.TabIndex = 9
         '
         'CboServer
         '
         Me.CboServer.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboServer.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboServer.FormattingEnabled = True
         Me.CboServer.Items.AddRange(New Object() {"Automatic Startup", "Manual Startup", "Disabled Startup"})
         Me.CboServer.Location = New System.Drawing.Point(440, 202)
         Me.CboServer.Name = "CboServer"
         Me.CboServer.Size = New System.Drawing.Size(155, 23)
         Me.CboServer.TabIndex = 8
         '
         'CboFunctionDiscovery
         '
         Me.CboFunctionDiscovery.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboFunctionDiscovery.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboFunctionDiscovery.FormattingEnabled = True
         Me.CboFunctionDiscovery.Items.AddRange(New Object() {"Automatic Startup", "Manual Startup", "Disabled Startup"})
         Me.CboFunctionDiscovery.Location = New System.Drawing.Point(440, 172)
         Me.CboFunctionDiscovery.Name = "CboFunctionDiscovery"
         Me.CboFunctionDiscovery.Size = New System.Drawing.Size(155, 23)
         Me.CboFunctionDiscovery.TabIndex = 7
         '
         'CboComputerBrowser
         '
         Me.CboComputerBrowser.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboComputerBrowser.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboComputerBrowser.FormattingEnabled = True
         Me.CboComputerBrowser.Items.AddRange(New Object() {"Automatic Startup", "Manual Startup", "Disabled Startup"})
         Me.CboComputerBrowser.Location = New System.Drawing.Point(440, 142)
         Me.CboComputerBrowser.Name = "CboComputerBrowser"
         Me.CboComputerBrowser.Size = New System.Drawing.Size(155, 23)
         Me.CboComputerBrowser.TabIndex = 6
         '
         'CboWorkstation
         '
         Me.CboWorkstation.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboWorkstation.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboWorkstation.Enabled = False
         Me.CboWorkstation.FormattingEnabled = True
         Me.CboWorkstation.Items.AddRange(New Object() {"Automatic Startup", "Manual Startup", "Disabled Startup"})
         Me.CboWorkstation.Location = New System.Drawing.Point(440, 112)
         Me.CboWorkstation.Name = "CboWorkstation"
         Me.CboWorkstation.Size = New System.Drawing.Size(155, 23)
         Me.CboWorkstation.TabIndex = 5
         '
         'CboDFS
         '
         Me.CboDFS.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboDFS.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboDFS.Enabled = False
         Me.CboDFS.FormattingEnabled = True
         Me.CboDFS.Items.AddRange(New Object() {"Automatic Startup", "Manual Startup", "Disabled Startup"})
         Me.CboDFS.Location = New System.Drawing.Point(440, 82)
         Me.CboDFS.Name = "CboDFS"
         Me.CboDFS.Size = New System.Drawing.Size(155, 23)
         Me.CboDFS.TabIndex = 4
         '
         'CboDNS
         '
         Me.CboDNS.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboDNS.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboDNS.Enabled = False
         Me.CboDNS.FormattingEnabled = True
         Me.CboDNS.Items.AddRange(New Object() {"Automatic Startup", "Manual Startup", "Disabled Startup"})
         Me.CboDNS.Location = New System.Drawing.Point(440, 52)
         Me.CboDNS.Name = "CboDNS"
         Me.CboDNS.Size = New System.Drawing.Size(155, 23)
         Me.CboDNS.TabIndex = 3
         '
         'CboDHCP
         '
         Me.CboDHCP.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CboDHCP.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.CboDHCP.Enabled = False
         Me.CboDHCP.FormattingEnabled = True
         Me.CboDHCP.Items.AddRange(New Object() {"Automatic Startup", "Manual Startup", "Disabled Startup"})
         Me.CboDHCP.Location = New System.Drawing.Point(440, 22)
         Me.CboDHCP.Name = "CboDHCP"
         Me.CboDHCP.Size = New System.Drawing.Size(155, 23)
         Me.CboDHCP.TabIndex = 2
         '
         'BtnOptimize
         '
         Me.BtnOptimize.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.BtnOptimize.Location = New System.Drawing.Point(471, 560)
         Me.BtnOptimize.Name = "BtnOptimize"
         Me.BtnOptimize.Size = New System.Drawing.Size(85, 25)
         Me.BtnOptimize.TabIndex = 2
         Me.BtnOptimize.Text = "&Optimize"
         Me.BtnOptimize.UseVisualStyleBackColor = True
         '
         'BtnClose
         '
         Me.BtnClose.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.BtnClose.Location = New System.Drawing.Point(562, 560)
         Me.BtnClose.Name = "BtnClose"
         Me.BtnClose.Size = New System.Drawing.Size(85, 25)
         Me.BtnClose.TabIndex = 3
         Me.BtnClose.Text = "&Close"
         Me.BtnClose.UseVisualStyleBackColor = True
         '
         'BWManTuneUp
         '
         Me.BWManTuneUp.WorkerReportsProgress = True
         Me.BWManTuneUp.WorkerSupportsCancellation = True
         '
         'HdrMain
         '
         Me.HdrMain.AllowButtonSpecToolTips = True
         Me.HdrMain.ButtonSpecs.AddRange(New ComponentFactory.Krypton.Toolkit.ButtonSpecAny() {Me.BtnLock, Me.BtnRefresh, Me.BtnSearch, Me.BtnCProfile})
         Me.HdrMain.Dock = System.Windows.Forms.DockStyle.Top
         Me.HdrMain.Location = New System.Drawing.Point(0, 0)
         Me.HdrMain.Name = "HdrMain"
         Me.HdrMain.PaletteMode = ComponentFactory.Krypton.Toolkit.PaletteMode.Office2007Silver
         Me.HdrMain.Size = New System.Drawing.Size(659, 53)
         Me.HdrMain.StateNormal.Back.Color1 = System.Drawing.Color.White
         Me.HdrMain.StateNormal.Back.Color2 = System.Drawing.Color.Gainsboro
         Me.HdrMain.StateNormal.Back.ColorStyle = ComponentFactory.Krypton.Toolkit.PaletteColorStyle.HalfCut
         Me.HdrMain.StateNormal.Border.DrawBorders = ComponentFactory.Krypton.Toolkit.PaletteDrawBorders.Bottom
         Me.HdrMain.StateNormal.Content.Padding = New System.Windows.Forms.Padding(5, -1, -1, -1)
         Me.HdrMain.StateNormal.Content.ShortText.Font = New System.Drawing.Font("Calibri", 27.75!, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.HdrMain.TabIndex = 0
         Me.HdrMain.TabStop = False
         Me.HdrMain.Values.Description = ""
         Me.HdrMain.Values.Heading = " Manual TuneUp"
         Me.HdrMain.Values.Image = Nothing
         '
         'BtnLock
         '
         Me.BtnLock.Checked = ComponentFactory.Krypton.Toolkit.ButtonCheckState.Checked
         Me.BtnLock.Tag = "0"
         Me.BtnLock.ToolTipBody = "Unlock the modification of critical services."
         Me.BtnLock.UniqueName = ""
         '
         'BtnRefresh
         '
         Me.BtnRefresh.ToolTipBody = "Refresh Windows services status."
         Me.BtnRefresh.UniqueName = ""
         '
         'BtnSearch
         '
         Me.BtnSearch.ContextMenuStrip = Me.ConTxtMnu
         Me.BtnSearch.ToolTipBody = "Search the selected service information."
         Me.BtnSearch.UniqueName = ""
         '
         'ConTxtMnu
         '
         Me.ConTxtMnu.Font = New System.Drawing.Font("Segoe UI", 9.0!)
         Me.ConTxtMnu.Items.AddRange(New System.Windows.Forms.ToolStripItem() {Me.ItmSearchEngine, Me.ItmBlkVpr})
         Me.ConTxtMnu.Name = "ConTxtMnu"
         Me.ConTxtMnu.ShowItemToolTips = False
         Me.ConTxtMnu.Size = New System.Drawing.Size(156, 48)
         '
         'ItmSearchEngine
         '
         Me.ItmSearchEngine.Name = "ItmSearchEngine"
         Me.ItmSearchEngine.Size = New System.Drawing.Size(155, 22)
         Me.ItmSearchEngine.Text = ""
         '
         'ItmBlkVpr
         '
         Me.ItmBlkVpr.Name = "ItmBlkVpr"
         Me.ItmBlkVpr.Size = New System.Drawing.Size(155, 22)
         Me.ItmBlkVpr.Text = "Blackviper.com"
         '
         'BtnCProfile
         '
         Me.BtnCProfile.ToolTipBody = "Create services profile."
         Me.BtnCProfile.UniqueName = ""
         '
         'FrmManual
         '
         Me.AcceptButton = Me.BtnOptimize
         Me.AutoScaleMode = System.Windows.Forms.AutoScaleMode.None
         Me.ClientSize = New System.Drawing.Size(659, 596)
         Me.ControlBox = False
         Me.Controls.Add(Me.HdrMain)
         Me.Controls.Add(Me.BtnClose)
         Me.Controls.Add(Me.BtnOptimize)
         Me.Controls.Add(Me.PnlMain)
         Me.DoubleBuffered = True
         Me.Font = New System.Drawing.Font("Segoe UI", 9.0!, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.ForeColor = System.Drawing.Color.Black
         Me.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None
         Me.MaximizeBox = False
         Me.MinimizeBox = False
         Me.Name = "FrmManual"
         Me.ShowIcon = False
         Me.ShowInTaskbar = False
         Me.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide
         Me.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen
         Me.Text = "Manual TuneUp"
         Me.PnlMain.ResumeLayout(False)
         Me.BoxInfo.ResumeLayout(False)
         Me.BoxInfo.PerformLayout()
         Me.PnlStatus.ResumeLayout(False)
         CType(Me.PicStatus, System.ComponentModel.ISupportInitialize).EndInit()
         Me.TabMain.ResumeLayout(False)
         Me.TabPerformance.ResumeLayout(False)
         Me.TabSecurity.ResumeLayout(False)
         Me.TabNetwork.ResumeLayout(False)
         Me.ConTxtMnu.ResumeLayout(False)
         Me.ResumeLayout(False)
         Me.PerformLayout()
 
     End Sub
]]>
</clone_fragment>
<clone_fragment file="C:\Users\faa634\Desktop\movica\Editor\frmList.vb" startline="31" endline="1771">
<![CDATA[
 
     'Required by the Windows Form Designer
     Private components As System.ComponentModel.IContainer
 
     'NOTE
     'It can be modified using the Windows Form Designer.  
     'Do not modify it using the code editor.
     Friend WithEvents MainMenu1 As System.Windows.Forms.MainMenu
     Friend WithEvents MenuItem1 As System.Windows.Forms.MenuItem
     Friend WithEvents mnuOpen As System.Windows.Forms.MenuItem
     Friend WithEvents mnuExit As System.Windows.Forms.MenuItem
     Friend WithEvents mnuSave As System.Windows.Forms.MenuItem
     Friend WithEvents dlgOpenFile As System.Windows.Forms.OpenFileDialog
     Friend WithEvents dlgSaveFile As System.Windows.Forms.SaveFileDialog
     Friend WithEvents mainTabs As System.Windows.Forms.TabControl
     Friend WithEvents tabPlayer As System.Windows.Forms.TabPage
     Friend WithEvents tabTrace As System.Windows.Forms.TabPage
     Friend WithEvents mPlayer As AxWMPLib.AxWindowsMediaPlayer
     Friend WithEvents rtfTrace As System.Windows.Forms.RichTextBox
     Friend WithEvents panSegments As System.Windows.Forms.Panel
     Friend WithEvents lvPositions As System.Windows.Forms.ListView
     Friend WithEvents colStart As System.Windows.Forms.ColumnHeader
     Friend WithEvents colEnd As System.Windows.Forms.ColumnHeader
     Friend WithEvents MenuItem2 As System.Windows.Forms.MenuItem
     Friend WithEvents MenuItem3 As System.Windows.Forms.MenuItem
     Friend WithEvents tabJoin As System.Windows.Forms.TabPage
     Friend WithEvents cSort As System.Windows.Forms.ToolBarButton
     Friend WithEvents cJoin As System.Windows.Forms.ToolBarButton
     Friend WithEvents cClear As System.Windows.Forms.ToolBarButton
     Friend WithEvents cRemove As System.Windows.Forms.ToolBarButton
     Friend WithEvents chkAuto As System.Windows.Forms.CheckBox
     Friend WithEvents cOpen As System.Windows.Forms.ToolBarButton
     Friend WithEvents lvFiles As System.Windows.Forms.ListView
     Friend WithEvents ColumnHeader1 As System.Windows.Forms.ColumnHeader
     Friend WithEvents ImageList1 As System.Windows.Forms.ImageList
     Friend WithEvents MenuItem4 As System.Windows.Forms.MenuItem
     Friend WithEvents MenuItem5 As System.Windows.Forms.MenuItem
     Friend WithEvents mnuSaveX As System.Windows.Forms.MenuItem
     Friend WithEvents MenuItem6 As System.Windows.Forms.MenuItem
     Friend WithEvents mnuHelp As System.Windows.Forms.MenuItem
     Friend WithEvents Splitter1 As System.Windows.Forms.Splitter
     Friend WithEvents MenuItem7 As System.Windows.Forms.MenuItem
     Friend WithEvents mnuPlaySel As System.Windows.Forms.MenuItem
     Friend WithEvents Timer As System.Windows.Forms.Timer
     Friend WithEvents mnuPlayUns As System.Windows.Forms.MenuItem
     Friend WithEvents MenuItem8 As System.Windows.Forms.MenuItem
     Friend WithEvents mnuTestSeg As System.Windows.Forms.MenuItem
     Friend WithEvents SegMenu As System.Windows.Forms.ContextMenu
     Friend WithEvents MenuItem9 As System.Windows.Forms.MenuItem
     Friend WithEvents MenuItem10 As System.Windows.Forms.MenuItem
     Friend WithEvents MenuItem11 As System.Windows.Forms.MenuItem
     Friend WithEvents Helper As System.Windows.Forms.HelpProvider
     Friend WithEvents MPcontrols As Editor.ucMPcontrols
     Friend WithEvents chkDel As System.Windows.Forms.CheckBox
     Friend WithEvents mnuCheckUpdate As System.Windows.Forms.MenuItem
     Friend WithEvents tabSplit As System.Windows.Forms.TabPage
     Friend WithEvents GroupBox1 As System.Windows.Forms.GroupBox
     Friend WithEvents radTime As System.Windows.Forms.RadioButton
     Friend WithEvents radPieces As System.Windows.Forms.RadioButton
     Friend WithEvents radSize As System.Windows.Forms.RadioButton
     Friend WithEvents cSplit As System.Windows.Forms.Button
     Friend WithEvents Label1 As System.Windows.Forms.Label
     Friend WithEvents Label2 As System.Windows.Forms.Label
     Friend WithEvents Label3 As System.Windows.Forms.Label
     Friend WithEvents Label4 As System.Windows.Forms.Label
     Friend WithEvents numSec As System.Windows.Forms.NumericUpDown
     Friend WithEvents numMin As System.Windows.Forms.NumericUpDown
     Friend WithEvents numHr As System.Windows.Forms.NumericUpDown
     Friend WithEvents numPcs As System.Windows.Forms.NumericUpDown
     Friend WithEvents Label5 As System.Windows.Forms.Label
     Friend WithEvents cbSize As System.Windows.Forms.ComboBox
     Friend WithEvents tFile2Split As System.Windows.Forms.TextBox
     Friend WithEvents Label6 As System.Windows.Forms.Label
     Friend WithEvents tSplitName As System.Windows.Forms.TextBox
     Friend WithEvents cSplitBrw As System.Windows.Forms.Button
     Friend WithEvents Label7 As System.Windows.Forms.Label
     Friend WithEvents cUp As System.Windows.Forms.ToolBarButton
     Friend WithEvents cDn As System.Windows.Forms.ToolBarButton
     Friend WithEvents PanelFine As System.Windows.Forms.Panel
     Friend WithEvents cStrtFrRev As System.Windows.Forms.Button
     Friend WithEvents cStrtFrFwd As System.Windows.Forms.Button
     Friend WithEvents cEndFrFwd As System.Windows.Forms.Button
     Friend WithEvents cEndFrRev As System.Windows.Forms.Button
     Friend WithEvents Label9 As System.Windows.Forms.Label
     Friend WithEvents mnuInfo As System.Windows.Forms.MenuItem
     Friend WithEvents ToolTips As System.Windows.Forms.ToolTip
     Friend WithEvents FineResolution As Editor.ucSlider
     Friend WithEvents lSize As System.Windows.Forms.Label
     Friend WithEvents cInfo As System.Windows.Forms.ToolBarButton
     Friend WithEvents tbJoin As System.Windows.Forms.ToolBar
     Friend WithEvents CheckBox1 As System.Windows.Forms.CheckBox
     Friend WithEvents tbTrace As System.Windows.Forms.ToolBar
     Friend WithEvents tcClearTrace As System.Windows.Forms.ToolBarButton
     Friend WithEvents tcSaveTrace As System.Windows.Forms.ToolBarButton
     Friend WithEvents panStatus As System.Windows.Forms.Panel
     Friend WithEvents picStat As System.Windows.Forms.PictureBox
     Friend WithEvents lMsgStat As System.Windows.Forms.Label
     Friend WithEvents MenuItem13 As System.Windows.Forms.MenuItem
     Friend WithEvents mnuSaveMask As System.Windows.Forms.MenuItem
     Friend WithEvents MenuItem14 As System.Windows.Forms.MenuItem
     Friend WithEvents Label11 As System.Windows.Forms.Label
     Friend WithEvents tbPositions As System.Windows.Forms.ToolBar
     Friend WithEvents cSaveMask As System.Windows.Forms.ToolBarButton
     Friend WithEvents cPlaySelected As System.Windows.Forms.ToolBarButton
     Friend WithEvents cPlayAll As System.Windows.Forms.ToolBarButton
     Friend WithEvents cOpenMask As System.Windows.Forms.ToolBarButton
     Friend WithEvents cPlayNotSelected As System.Windows.Forms.ToolBarButton
     Friend WithEvents mnuLoop As System.Windows.Forms.MenuItem
     Friend WithEvents cLoop As System.Windows.Forms.ToolBarButton
     Friend WithEvents tabSettings As System.Windows.Forms.TabPage
     Friend WithEvents chkFrameAccurate As System.Windows.Forms.CheckBox
     Friend WithEvents chkForceJoin As System.Windows.Forms.CheckBox
     Friend WithEvents lpanFineText As System.Windows.Forms.Label
     Friend WithEvents GroupBox2 As System.Windows.Forms.GroupBox
     Friend WithEvents GroupBox3 As System.Windows.Forms.GroupBox
     Friend WithEvents chkKeepMRU As System.Windows.Forms.CheckBox
     Friend WithEvents chkDialogView As System.Windows.Forms.CheckBox
     Friend WithEvents GroupBox4 As System.Windows.Forms.GroupBox
     Friend WithEvents Label8 As System.Windows.Forms.Label
     Friend WithEvents cbLang As System.Windows.Forms.ComboBox
     Friend WithEvents cTransleditor As System.Windows.Forms.Button
     Friend WithEvents LinkLabel1 As System.Windows.Forms.LinkLabel
     Friend WithEvents chkOnTop As System.Windows.Forms.CheckBox
     Friend WithEvents mnuImpSkip As System.Windows.Forms.MenuItem
     Friend WithEvents chkUpdate As System.Windows.Forms.CheckBox
     Friend WithEvents MenuItem12 As System.Windows.Forms.MenuItem
     Friend WithEvents mnuImpComskip As System.Windows.Forms.MenuItem
     Friend WithEvents MenuItem15 As System.Windows.Forms.MenuItem
     Friend WithEvents mnuSaveSepFiles As System.Windows.Forms.MenuItem
     Friend WithEvents tabTools As System.Windows.Forms.TabPage
     Friend WithEvents GroupBox5 As System.Windows.Forms.GroupBox
     Friend WithEvents GroupBox6 As System.Windows.Forms.GroupBox
     Friend WithEvents Label12 As System.Windows.Forms.Label
     Friend WithEvents cToolFind As System.Windows.Forms.Button
     Friend WithEvents tStdToolPath As System.Windows.Forms.TextBox
     Friend WithEvents linkToolURL As System.Windows.Forms.LinkLabel
     Friend WithEvents lblToolDesc As System.Windows.Forms.Label
     Friend WithEvents lbStdTools As System.Windows.Forms.ListBox
     Friend WithEvents cDetect As System.Windows.Forms.Button
     Friend WithEvents chkEnabled As System.Windows.Forms.CheckBox
     Friend WithEvents Label10 As System.Windows.Forms.Label
     Friend WithEvents MenuItem17 As System.Windows.Forms.MenuItem
     Friend WithEvents mnuDonate As System.Windows.Forms.MenuItem
     Friend WithEvents Panel1 As System.Windows.Forms.Panel
     Friend WithEvents statBar As System.Windows.Forms.StatusBar
     Friend WithEvents statMain As System.Windows.Forms.StatusBarPanel
     Friend WithEvents statDur As System.Windows.Forms.StatusBarPanel
     Friend WithEvents picStatus As System.Windows.Forms.PictureBox
     Friend WithEvents mnuDShow As System.Windows.Forms.MenuItem
     Friend WithEvents cDShow As System.Windows.Forms.Button
     Friend WithEvents statSel As System.Windows.Forms.StatusBarPanel
     Friend WithEvents panAudio As System.Windows.Forms.Panel
     Friend WithEvents picAudioDetail As System.Windows.Forms.PictureBox
     Friend WithEvents picAudioSumm As System.Windows.Forms.PictureBox
     Friend WithEvents mnuView As System.Windows.Forms.MenuItem
     Friend WithEvents mnuCompact As System.Windows.Forms.MenuItem
     Friend WithEvents mnuFullscreen As System.Windows.Forms.MenuItem
     Friend WithEvents chkBeep As System.Windows.Forms.CheckBox
     Friend WithEvents mnuUnload As System.Windows.Forms.MenuItem
     Friend WithEvents MenuItem16 As System.Windows.Forms.MenuItem
     <System.Diagnostics.DebuggerStepThrough()> Private Sub InitializeComponent()
         Me.components = New System.ComponentModel.Container
         Dim resources As System.ComponentModel.ComponentResourceManager = New System.ComponentModel.ComponentResourceManager(GetType(frmMain))
         Me.MainMenu1 = New System.Windows.Forms.MainMenu(Me.components)
         Me.MenuItem1 = New System.Windows.Forms.MenuItem
         Me.mnuOpen = New System.Windows.Forms.MenuItem
         Me.mnuSave = New System.Windows.Forms.MenuItem
         Me.mnuSaveX = New System.Windows.Forms.MenuItem
         Me.mnuSaveSepFiles = New System.Windows.Forms.MenuItem
         Me.MenuItem4 = New System.Windows.Forms.MenuItem
         Me.mnuSaveMask = New System.Windows.Forms.MenuItem
         Me.MenuItem17 = New System.Windows.Forms.MenuItem
         Me.MenuItem14 = New System.Windows.Forms.MenuItem
         Me.mnuUnload = New System.Windows.Forms.MenuItem
         Me.mnuExit = New System.Windows.Forms.MenuItem
         Me.MenuItem2 = New System.Windows.Forms.MenuItem
         Me.mnuInfo = New System.Windows.Forms.MenuItem
         Me.mnuDShow = New System.Windows.Forms.MenuItem
         Me.MenuItem3 = New System.Windows.Forms.MenuItem
         Me.MenuItem12 = New System.Windows.Forms.MenuItem
         Me.mnuImpSkip = New System.Windows.Forms.MenuItem
         Me.mnuImpComskip = New System.Windows.Forms.MenuItem
         Me.MenuItem15 = New System.Windows.Forms.MenuItem
         Me.MenuItem16 = New System.Windows.Forms.MenuItem
         Me.MenuItem7 = New System.Windows.Forms.MenuItem
         Me.mnuPlaySel = New System.Windows.Forms.MenuItem
         Me.mnuPlayUns = New System.Windows.Forms.MenuItem
         Me.MenuItem8 = New System.Windows.Forms.MenuItem
         Me.mnuTestSeg = New System.Windows.Forms.MenuItem
         Me.MenuItem13 = New System.Windows.Forms.MenuItem
         Me.mnuLoop = New System.Windows.Forms.MenuItem
         Me.mnuView = New System.Windows.Forms.MenuItem
         Me.mnuCompact = New System.Windows.Forms.MenuItem
         Me.mnuFullscreen = New System.Windows.Forms.MenuItem
         Me.MenuItem5 = New System.Windows.Forms.MenuItem
         Me.mnuHelp = New System.Windows.Forms.MenuItem
         Me.mnuCheckUpdate = New System.Windows.Forms.MenuItem
         Me.mnuDonate = New System.Windows.Forms.MenuItem
         Me.MenuItem6 = New System.Windows.Forms.MenuItem
         Me.dlgOpenFile = New System.Windows.Forms.OpenFileDialog
         Me.dlgSaveFile = New System.Windows.Forms.SaveFileDialog
         Me.mainTabs = New System.Windows.Forms.TabControl
         Me.tabPlayer = New System.Windows.Forms.TabPage
         Me.panAudio = New System.Windows.Forms.Panel
         Me.picAudioDetail = New System.Windows.Forms.PictureBox
         Me.picAudioSumm = New System.Windows.Forms.PictureBox
         Me.mPlayer = New AxWMPLib.AxWindowsMediaPlayer
         Me.tabJoin = New System.Windows.Forms.TabPage
         Me.chkDel = New System.Windows.Forms.CheckBox
         Me.chkAuto = New System.Windows.Forms.CheckBox
         Me.lvFiles = New System.Windows.Forms.ListView
         Me.ColumnHeader1 = New System.Windows.Forms.ColumnHeader
         Me.tbJoin = New System.Windows.Forms.ToolBar
         Me.cSort = New System.Windows.Forms.ToolBarButton
         Me.cRemove = New System.Windows.Forms.ToolBarButton
         Me.cClear = New System.Windows.Forms.ToolBarButton
         Me.cJoin = New System.Windows.Forms.ToolBarButton
         Me.cOpen = New System.Windows.Forms.ToolBarButton
         Me.cUp = New System.Windows.Forms.ToolBarButton
         Me.cDn = New System.Windows.Forms.ToolBarButton
         Me.cInfo = New System.Windows.Forms.ToolBarButton
         Me.ImageList1 = New System.Windows.Forms.ImageList(Me.components)
         Me.tabSplit = New System.Windows.Forms.TabPage
         Me.lSize = New System.Windows.Forms.Label
         Me.Label6 = New System.Windows.Forms.Label
         Me.cSplitBrw = New System.Windows.Forms.Button
         Me.tSplitName = New System.Windows.Forms.TextBox
         Me.cSplit = New System.Windows.Forms.Button
         Me.GroupBox1 = New System.Windows.Forms.GroupBox
         Me.cbSize = New System.Windows.Forms.ComboBox
         Me.numSec = New System.Windows.Forms.NumericUpDown
         Me.Label2 = New System.Windows.Forms.Label
         Me.radTime = New System.Windows.Forms.RadioButton
         Me.radPieces = New System.Windows.Forms.RadioButton
         Me.radSize = New System.Windows.Forms.RadioButton
         Me.Label3 = New System.Windows.Forms.Label
         Me.Label4 = New System.Windows.Forms.Label
         Me.numMin = New System.Windows.Forms.NumericUpDown
         Me.numHr = New System.Windows.Forms.NumericUpDown
         Me.numPcs = New System.Windows.Forms.NumericUpDown
         Me.Label5 = New System.Windows.Forms.Label
         Me.tFile2Split = New System.Windows.Forms.TextBox
         Me.Label1 = New System.Windows.Forms.Label
         Me.Label7 = New System.Windows.Forms.Label
         Me.tabTrace = New System.Windows.Forms.TabPage
         Me.panStatus = New System.Windows.Forms.Panel
         Me.lMsgStat = New System.Windows.Forms.Label
         Me.picStat = New System.Windows.Forms.PictureBox
         Me.CheckBox1 = New System.Windows.Forms.CheckBox
         Me.rtfTrace = New System.Windows.Forms.RichTextBox
         Me.tbTrace = New System.Windows.Forms.ToolBar
         Me.tcClearTrace = New System.Windows.Forms.ToolBarButton
         Me.tcSaveTrace = New System.Windows.Forms.ToolBarButton
         Me.tabSettings = New System.Windows.Forms.TabPage
         Me.GroupBox3 = New System.Windows.Forms.GroupBox
         Me.chkForceJoin = New System.Windows.Forms.CheckBox
         Me.chkKeepMRU = New System.Windows.Forms.CheckBox
         Me.chkDialogView = New System.Windows.Forms.CheckBox
         Me.chkBeep = New System.Windows.Forms.CheckBox
         Me.chkOnTop = New System.Windows.Forms.CheckBox
         Me.chkUpdate = New System.Windows.Forms.CheckBox
         Me.GroupBox2 = New System.Windows.Forms.GroupBox
         Me.chkFrameAccurate = New System.Windows.Forms.CheckBox
         Me.GroupBox4 = New System.Windows.Forms.GroupBox
         Me.LinkLabel1 = New System.Windows.Forms.LinkLabel
         Me.cTransleditor = New System.Windows.Forms.Button
         Me.Label8 = New System.Windows.Forms.Label
         Me.cbLang = New System.Windows.Forms.ComboBox
         Me.tabTools = New System.Windows.Forms.TabPage
         Me.GroupBox6 = New System.Windows.Forms.GroupBox
         Me.Label12 = New System.Windows.Forms.Label
         Me.GroupBox5 = New System.Windows.Forms.GroupBox
         Me.cDShow = New System.Windows.Forms.Button
         Me.tStdToolPath = New System.Windows.Forms.TextBox
         Me.Label10 = New System.Windows.Forms.Label
         Me.chkEnabled = New System.Windows.Forms.CheckBox
         Me.cDetect = New System.Windows.Forms.Button
         Me.cToolFind = New System.Windows.Forms.Button
         Me.linkToolURL = New System.Windows.Forms.LinkLabel
         Me.lblToolDesc = New System.Windows.Forms.Label
         Me.lbStdTools = New System.Windows.Forms.ListBox
         Me.panSegments = New System.Windows.Forms.Panel
         Me.lvPositions = New System.Windows.Forms.ListView
         Me.colStart = New System.Windows.Forms.ColumnHeader
         Me.colEnd = New System.Windows.Forms.ColumnHeader
         Me.SegMenu = New System.Windows.Forms.ContextMenu
         Me.MenuItem10 = New System.Windows.Forms.MenuItem
         Me.MenuItem9 = New System.Windows.Forms.MenuItem
         Me.MenuItem11 = New System.Windows.Forms.MenuItem
         Me.tbPositions = New System.Windows.Forms.ToolBar
         Me.cPlayAll = New System.Windows.Forms.ToolBarButton
         Me.cPlayNotSelected = New System.Windows.Forms.ToolBarButton
         Me.cPlaySelected = New System.Windows.Forms.ToolBarButton
         Me.cSaveMask = New System.Windows.Forms.ToolBarButton
         Me.cOpenMask = New System.Windows.Forms.ToolBarButton
         Me.cLoop = New System.Windows.Forms.ToolBarButton
         Me.Label11 = New System.Windows.Forms.Label
         Me.Splitter1 = New System.Windows.Forms.Splitter
         Me.Timer = New System.Windows.Forms.Timer(Me.components)
         Me.Helper = New System.Windows.Forms.HelpProvider
         Me.Panel1 = New System.Windows.Forms.Panel
         Me.statBar = New System.Windows.Forms.StatusBar
         Me.statMain = New System.Windows.Forms.StatusBarPanel
         Me.statSel = New System.Windows.Forms.StatusBarPanel
         Me.statDur = New System.Windows.Forms.StatusBarPanel
         Me.picStatus = New System.Windows.Forms.PictureBox
         Me.PanelFine = New System.Windows.Forms.Panel
         Me.Label9 = New System.Windows.Forms.Label
         Me.cEndFrRev = New System.Windows.Forms.Button
         Me.cEndFrFwd = New System.Windows.Forms.Button
         Me.cStrtFrFwd = New System.Windows.Forms.Button
         Me.cStrtFrRev = New System.Windows.Forms.Button
         Me.lpanFineText = New System.Windows.Forms.Label
         Me.ToolTips = New System.Windows.Forms.ToolTip(Me.components)
         Me.MPcontrols = New Editor.ucMPcontrols
         Me.FineResolution = New Editor.ucSlider
         Me.mainTabs.SuspendLayout()
         Me.tabPlayer.SuspendLayout()
         Me.panAudio.SuspendLayout()
         CType(Me.picAudioDetail, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.picAudioSumm, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.mPlayer, System.ComponentModel.ISupportInitialize).BeginInit()
         Me.tabJoin.SuspendLayout()
         Me.tabSplit.SuspendLayout()
         Me.GroupBox1.SuspendLayout()
         CType(Me.numSec, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.numMin, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.numHr, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.numPcs, System.ComponentModel.ISupportInitialize).BeginInit()
         Me.tabTrace.SuspendLayout()
         Me.panStatus.SuspendLayout()
         CType(Me.picStat, System.ComponentModel.ISupportInitialize).BeginInit()
         Me.tabSettings.SuspendLayout()
         Me.GroupBox3.SuspendLayout()
         Me.GroupBox2.SuspendLayout()
         Me.GroupBox4.SuspendLayout()
         Me.tabTools.SuspendLayout()
         Me.GroupBox6.SuspendLayout()
         Me.GroupBox5.SuspendLayout()
         Me.panSegments.SuspendLayout()
         Me.Panel1.SuspendLayout()
         CType(Me.statMain, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.statSel, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.statDur, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.picStatus, System.ComponentModel.ISupportInitialize).BeginInit()
         Me.PanelFine.SuspendLayout()
         Me.SuspendLayout()
         '
         'MainMenu1
         '
         Me.MainMenu1.MenuItems.AddRange(New System.Windows.Forms.MenuItem() {Me.MenuItem1, Me.MenuItem2, Me.MenuItem7, Me.mnuView, Me.MenuItem5})
         '
         'MenuItem1
         '
         Me.MenuItem1.Index = 0
         Me.MenuItem1.MenuItems.AddRange(New System.Windows.Forms.MenuItem() {Me.mnuOpen, Me.mnuSave, Me.mnuSaveX, Me.mnuSaveSepFiles, Me.MenuItem4, Me.mnuSaveMask, Me.MenuItem17, Me.MenuItem14, Me.mnuUnload, Me.mnuExit})
         Me.MenuItem1.Text = "&File"
         '
         'mnuOpen
         '
         Me.mnuOpen.Index = 0
         Me.mnuOpen.Shortcut = System.Windows.Forms.Shortcut.CtrlO
         Me.mnuOpen.Text = "&Open Movie File"
         '
         'mnuSave
         '
         Me.mnuSave.Index = 1
         Me.mnuSave.Shortcut = System.Windows.Forms.Shortcut.F7
         Me.mnuSave.Text = "Sa&ve Selected Parts"
         '
         'mnuSaveX
         '
         Me.mnuSaveX.Index = 2
         Me.mnuSaveX.Shortcut = System.Windows.Forms.Shortcut.ShiftF7
         Me.mnuSaveX.Text = "Save &Without Selected Parts"
         '
         'mnuSaveSepFiles
         '
         Me.mnuSaveSepFiles.Index = 3
         Me.mnuSaveSepFiles.Shortcut = System.Windows.Forms.Shortcut.F6
         Me.mnuSaveSepFiles.Text = "Save Selections as Se&parate files"
         '
         'MenuItem4
         '
         Me.MenuItem4.Index = 4
         Me.MenuItem4.Text = "-"
         '
         'mnuSaveMask
         '
         Me.mnuSaveMask.Index = 5
         Me.mnuSaveMask.Shortcut = System.Windows.Forms.Shortcut.CtrlM
         Me.mnuSaveMask.Text = "&Save Selections as MoviClips"
         '
         'MenuItem17
         '
         Me.MenuItem17.Index = 6
         Me.MenuItem17.Text = "-"
         '
         'MenuItem14
         '
         Me.MenuItem14.Index = 7
         Me.MenuItem14.Text = "-"
         '
         'mnuUnload
         '
         Me.mnuUnload.Index = 8
         Me.mnuUnload.Shortcut = System.Windows.Forms.Shortcut.CtrlW
         Me.mnuUnload.Text = "&Unload Movie"
         '
         'mnuExit
         '
         Me.mnuExit.Index = 9
         Me.mnuExit.Shortcut = System.Windows.Forms.Shortcut.CtrlX
         Me.mnuExit.Text = "E&xit"
         '
         'MenuItem2
         '
         Me.MenuItem2.Index = 1
         Me.MenuItem2.MenuItems.AddRange(New System.Windows.Forms.MenuItem() {Me.mnuInfo, Me.mnuDShow, Me.MenuItem3, Me.MenuItem12, Me.mnuImpSkip, Me.mnuImpComskip, Me.MenuItem15, Me.MenuItem16})
         Me.MenuItem2.Text = "&Tools"
         '
         'mnuInfo
         '
         Me.mnuInfo.Enabled = False
         Me.mnuInfo.Index = 0
         Me.mnuInfo.Shortcut = System.Windows.Forms.Shortcut.CtrlI
         Me.mnuInfo.Text = "Show &Information on Movie"
         '
         'mnuDShow
         '
         Me.mnuDShow.Index = 1
         Me.mnuDShow.Text = "Show directShow filters"
         '
         'MenuItem3
         '
         Me.MenuItem3.Index = 2
         Me.MenuItem3.Shortcut = System.Windows.Forms.Shortcut.CtrlZ
         Me.MenuItem3.Text = "&Test"
         Me.MenuItem3.Visible = False
         '
         'MenuItem12
         '
         Me.MenuItem12.Index = 3
         Me.MenuItem12.Text = "-"
         '
         'mnuImpSkip
         '
         Me.mnuImpSkip.Enabled = False
         Me.mnuImpSkip.Index = 4
         Me.mnuImpSkip.Text = "Import SmartSkip file"
         '
         'mnuImpComskip
         '
         Me.mnuImpComskip.Enabled = False
         Me.mnuImpComskip.Index = 5
         Me.mnuImpComskip.Text = "Import Comskip file"
         '
         'MenuItem15
         '
         Me.MenuItem15.Index = 6
         Me.MenuItem15.Text = "-"
         '
         'MenuItem16
         '
         Me.MenuItem16.Enabled = False
         Me.MenuItem16.Index = 7
         Me.MenuItem16.Text = "Run Comskip"
         Me.MenuItem16.Visible = False
         '
         'MenuItem7
         '
         Me.MenuItem7.Index = 2
         Me.MenuItem7.MenuItems.AddRange(New System.Windows.Forms.MenuItem() {Me.mnuPlaySel, Me.mnuPlayUns, Me.MenuItem8, Me.mnuTestSeg, Me.MenuItem13, Me.mnuLoop})
         Me.MenuItem7.Text = "&Play"
         '
         'mnuPlaySel
         '
         Me.mnuPlaySel.Index = 0
         Me.mnuPlaySel.Shortcut = System.Windows.Forms.Shortcut.CtrlP
         Me.mnuPlaySel.Text = "Play All &Selected Parts"
         '
         'mnuPlayUns
         '
         Me.mnuPlayUns.Index = 1
         Me.mnuPlayUns.Shortcut = System.Windows.Forms.Shortcut.CtrlShiftP
         Me.mnuPlayUns.Text = "Play Parts &Not Selected"
         '
         'MenuItem8
         '
         Me.MenuItem8.Index = 2
         Me.MenuItem8.Text = "-"
         '
         'mnuTestSeg
         '
         Me.mnuTestSeg.Index = 3
         Me.mnuTestSeg.Shortcut = System.Windows.Forms.Shortcut.CtrlT
         Me.mnuTestSeg.Text = "Play Highligh&ted Part(s)"
         '
         'MenuItem13
         '
         Me.MenuItem13.Index = 4
         Me.MenuItem13.Text = "-"
         '
         'mnuLoop
         '
         Me.mnuLoop.Index = 5
         Me.mnuLoop.Shortcut = System.Windows.Forms.Shortcut.CtrlL
         Me.mnuLoop.Text = "Play in Loop"
         '
         'mnuView
         '
         Me.mnuView.Index = 3
         Me.mnuView.MenuItems.AddRange(New System.Windows.Forms.MenuItem() {Me.mnuCompact, Me.mnuFullscreen})
         Me.mnuView.Text = "&View"
         '
         'mnuCompact
         '
         Me.mnuCompact.Index = 0
         Me.mnuCompact.Text = "Compact Mode"
         '
         'mnuFullscreen
         '
         Me.mnuFullscreen.Index = 1
         Me.mnuFullscreen.Text = "Full Screen"
         '
         'MenuItem5
         '
         Me.MenuItem5.Index = 4
         Me.MenuItem5.MenuItems.AddRange(New System.Windows.Forms.MenuItem() {Me.mnuHelp, Me.mnuCheckUpdate, Me.mnuDonate, Me.MenuItem6})
         Me.MenuItem5.Text = "&Help"
         '
         'mnuHelp
         '
         Me.mnuHelp.Index = 0
         Me.mnuHelp.Shortcut = System.Windows.Forms.Shortcut.F1
         Me.mnuHelp.Text = "&Help"
         '
         'mnuCheckUpdate
         '
         Me.mnuCheckUpdate.Index = 1
         Me.mnuCheckUpdate.Text = "&Check for updates"
         '
         'mnuDonate
         '
         Me.mnuDonate.Index = 2
         Me.mnuDonate.Text = "Donate"
         '
         'MenuItem6
         '
         Me.MenuItem6.Index = 3
         Me.MenuItem6.Text = "&About Movica"
         '
         'dlgOpenFile
         '
         Me.dlgOpenFile.Title = "Select video file"
         '
         'dlgSaveFile
         '
         Me.dlgSaveFile.Title = "Select Output file"
         '
         'mainTabs
         '
         Me.mainTabs.Controls.Add(Me.tabPlayer)
         Me.mainTabs.Controls.Add(Me.tabJoin)
         Me.mainTabs.Controls.Add(Me.tabSplit)
         Me.mainTabs.Controls.Add(Me.tabTrace)
         Me.mainTabs.Controls.Add(Me.tabSettings)
         Me.mainTabs.Controls.Add(Me.tabTools)
         Me.mainTabs.Dock = System.Windows.Forms.DockStyle.Fill
         Me.mainTabs.Location = New System.Drawing.Point(0, 0)
         Me.mainTabs.Name = "mainTabs"
         Me.mainTabs.SelectedIndex = 0
         Me.mainTabs.Size = New System.Drawing.Size(594, 413)
         Me.mainTabs.TabIndex = 5
         '
         'tabPlayer
         '
         Me.tabPlayer.BackColor = System.Drawing.Color.Black
         Me.tabPlayer.BackgroundImage = CType(resources.GetObject("tabPlayer.BackgroundImage"), System.Drawing.Image)
         Me.tabPlayer.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Center
         Me.tabPlayer.Controls.Add(Me.panAudio)
         Me.tabPlayer.Controls.Add(Me.mPlayer)
         Me.tabPlayer.Controls.Add(Me.MPcontrols)
         Me.tabPlayer.Location = New System.Drawing.Point(4, 22)
         Me.tabPlayer.Name = "tabPlayer"
         Me.tabPlayer.Size = New System.Drawing.Size(586, 387)
         Me.tabPlayer.TabIndex = 0
         Me.tabPlayer.Text = "Player"
         '
         'panAudio
         '
         Me.panAudio.BackColor = System.Drawing.Color.Black
         Me.panAudio.Controls.Add(Me.picAudioDetail)
         Me.panAudio.Controls.Add(Me.picAudioSumm)
         Me.panAudio.Dock = System.Windows.Forms.DockStyle.Fill
         Me.panAudio.Location = New System.Drawing.Point(0, 0)
         Me.panAudio.Name = "panAudio"
         Me.panAudio.Size = New System.Drawing.Size(586, 331)
         Me.panAudio.TabIndex = 4
         Me.panAudio.Visible = False
         '
         'picAudioDetail
         '
         Me.picAudioDetail.BackColor = System.Drawing.Color.White
         Me.picAudioDetail.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Center
         Me.picAudioDetail.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.picAudioDetail.Dock = System.Windows.Forms.DockStyle.Fill
         Me.picAudioDetail.Location = New System.Drawing.Point(0, 0)
         Me.picAudioDetail.Margin = New System.Windows.Forms.Padding(0)
         Me.picAudioDetail.Name = "picAudioDetail"
         Me.picAudioDetail.Size = New System.Drawing.Size(586, 245)
         Me.picAudioDetail.TabIndex = 5
         Me.picAudioDetail.TabStop = False
         Me.ToolTips.SetToolTip(Me.picAudioDetail, "The next release will show detailed waveform views of the audio here")
         '
         'picAudioSumm
         '
         Me.picAudioSumm.BackColor = System.Drawing.Color.White
         Me.picAudioSumm.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Stretch
         Me.picAudioSumm.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.picAudioSumm.Dock = System.Windows.Forms.DockStyle.Bottom
         Me.picAudioSumm.Location = New System.Drawing.Point(0, 245)
         Me.picAudioSumm.Name = "picAudioSumm"
         Me.picAudioSumm.Size = New System.Drawing.Size(586, 86)
         Me.picAudioSumm.TabIndex = 4
         Me.picAudioSumm.TabStop = False
         '
         'mPlayer
         '
         Me.mPlayer.Dock = System.Windows.Forms.DockStyle.Fill
         Me.mPlayer.Enabled = True
         Me.mPlayer.Location = New System.Drawing.Point(0, 0)
         Me.mPlayer.Name = "mPlayer"
         Me.mPlayer.OcxState = CType(resources.GetObject("mPlayer.OcxState"), System.Windows.Forms.AxHost.State)
         Me.mPlayer.Size = New System.Drawing.Size(586, 331)
         Me.mPlayer.TabIndex = 1
         Me.mPlayer.TabStop = False
         Me.mPlayer.Visible = False
         '
         'tabJoin
         '
         Me.tabJoin.Controls.Add(Me.chkDel)
         Me.tabJoin.Controls.Add(Me.chkAuto)
         Me.tabJoin.Controls.Add(Me.lvFiles)
         Me.tabJoin.Controls.Add(Me.tbJoin)
         Me.tabJoin.Location = New System.Drawing.Point(4, 22)
         Me.tabJoin.Name = "tabJoin"
         Me.tabJoin.Size = New System.Drawing.Size(586, 387)
         Me.tabJoin.TabIndex = 2
         Me.tabJoin.Text = "Join"
         Me.tabJoin.UseVisualStyleBackColor = True
         '
         'chkDel
         '
         Me.chkDel.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.chkDel.BackColor = System.Drawing.SystemColors.Control
         Me.chkDel.Location = New System.Drawing.Point(248, 3)
         Me.chkDel.Name = "chkDel"
         Me.chkDel.Size = New System.Drawing.Size(184, 25)
         Me.chkDel.TabIndex = 2
         Me.chkDel.Text = "Delete after joining"
         Me.chkDel.UseVisualStyleBackColor = False
         '
         'chkAuto
         '
         Me.chkAuto.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.chkAuto.BackColor = System.Drawing.SystemColors.Control
         Me.chkAuto.Checked = True
         Me.chkAuto.CheckState = System.Windows.Forms.CheckState.Checked
         Me.chkAuto.Location = New System.Drawing.Point(440, 3)
         Me.chkAuto.Name = "chkAuto"
         Me.chkAuto.Size = New System.Drawing.Size(136, 25)
         Me.chkAuto.TabIndex = 2
         Me.chkAuto.Text = "Auto detect parts"
         Me.chkAuto.UseVisualStyleBackColor = False
         '
         'lvFiles
         '
         Me.lvFiles.Columns.AddRange(New System.Windows.Forms.ColumnHeader() {Me.ColumnHeader1})
         Me.lvFiles.Dock = System.Windows.Forms.DockStyle.Fill
         Me.lvFiles.FullRowSelect = True
         Me.lvFiles.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.None
         Me.lvFiles.Location = New System.Drawing.Point(0, 28)
         Me.lvFiles.Name = "lvFiles"
         Me.lvFiles.Size = New System.Drawing.Size(586, 359)
         Me.lvFiles.TabIndex = 1
         Me.lvFiles.UseCompatibleStateImageBehavior = False
         Me.lvFiles.View = System.Windows.Forms.View.Details
         '
         'ColumnHeader1
         '
         Me.ColumnHeader1.Width = 495
         '
         'tbJoin
         '
         Me.tbJoin.Buttons.AddRange(New System.Windows.Forms.ToolBarButton() {Me.cSort, Me.cRemove, Me.cClear, Me.cJoin, Me.cOpen, Me.cUp, Me.cDn, Me.cInfo})
         Me.tbJoin.DropDownArrows = True
         Me.tbJoin.ImageList = Me.ImageList1
         Me.tbJoin.Location = New System.Drawing.Point(0, 0)
         Me.tbJoin.Name = "tbJoin"
         Me.tbJoin.ShowToolTips = True
         Me.tbJoin.Size = New System.Drawing.Size(586, 28)
         Me.tbJoin.TabIndex = 0
         '
         'cSort
         '
         Me.cSort.ImageIndex = 1
         Me.cSort.Name = "cSort"
         Me.cSort.Tag = "Sort"
         Me.cSort.ToolTipText = "Sort the list"
         '
         'cRemove
         '
         Me.cRemove.ImageIndex = 5
         Me.cRemove.Name = "cRemove"
         Me.cRemove.Tag = "Remove"
         Me.cRemove.ToolTipText = "Remove the items from the list"
         '
         'cClear
         '
         Me.cClear.ImageIndex = 0
         Me.cClear.Name = "cClear"
         Me.cClear.Tag = "Clear"
         Me.cClear.ToolTipText = "Clear list"
         '
         'cJoin
         '
         Me.cJoin.ImageIndex = 3
         Me.cJoin.Name = "cJoin"
         Me.cJoin.Tag = "Join"
         Me.cJoin.ToolTipText = "Join files in the list"
         '
         'cOpen
         '
         Me.cOpen.ImageIndex = 4
         Me.cOpen.Name = "cOpen"
         Me.cOpen.Tag = "Open"
         Me.cOpen.ToolTipText = "Select file to join"
         '
         'cUp
         '
         Me.cUp.ImageIndex = 6
         Me.cUp.Name = "cUp"
         Me.cUp.Tag = "Up"
         Me.cUp.ToolTipText = "Move highlighted files up"
         '
         'cDn
         '
         Me.cDn.ImageIndex = 7
         Me.cDn.Name = "cDn"
         Me.cDn.Tag = "Dn"
         Me.cDn.ToolTipText = "Move highlighted files down"
         '
         'cInfo
         '
         Me.cInfo.ImageIndex = 10
         Me.cInfo.Name = "cInfo"
         Me.cInfo.Tag = "Info"
         Me.cInfo.ToolTipText = "Show information on files"
         '
         'ImageList1
         '
         Me.ImageList1.ImageStream = CType(resources.GetObject("ImageList1.ImageStream"), System.Windows.Forms.ImageListStreamer)
         Me.ImageList1.TransparentColor = System.Drawing.Color.White
         Me.ImageList1.Images.SetKeyName(0, "")
         Me.ImageList1.Images.SetKeyName(1, "")
         Me.ImageList1.Images.SetKeyName(2, "")
         Me.ImageList1.Images.SetKeyName(3, "")
         Me.ImageList1.Images.SetKeyName(4, "")
         Me.ImageList1.Images.SetKeyName(5, "")
         Me.ImageList1.Images.SetKeyName(6, "")
         Me.ImageList1.Images.SetKeyName(7, "")
         Me.ImageList1.Images.SetKeyName(8, "")
         Me.ImageList1.Images.SetKeyName(9, "")
         Me.ImageList1.Images.SetKeyName(10, "")
         Me.ImageList1.Images.SetKeyName(11, "")
         Me.ImageList1.Images.SetKeyName(12, "")
         Me.ImageList1.Images.SetKeyName(13, "")
         Me.ImageList1.Images.SetKeyName(14, "")
         Me.ImageList1.Images.SetKeyName(15, "")
         Me.ImageList1.Images.SetKeyName(16, "")
         Me.ImageList1.Images.SetKeyName(17, "")
         '
         'tabSplit
         '
         Me.tabSplit.Controls.Add(Me.lSize)
         Me.tabSplit.Controls.Add(Me.Label6)
         Me.tabSplit.Controls.Add(Me.cSplitBrw)
         Me.tabSplit.Controls.Add(Me.tSplitName)
         Me.tabSplit.Controls.Add(Me.cSplit)
         Me.tabSplit.Controls.Add(Me.GroupBox1)
         Me.tabSplit.Controls.Add(Me.tFile2Split)
         Me.tabSplit.Controls.Add(Me.Label1)
         Me.tabSplit.Controls.Add(Me.Label7)
         Me.tabSplit.Location = New System.Drawing.Point(4, 22)
         Me.tabSplit.Name = "tabSplit"
         Me.tabSplit.Size = New System.Drawing.Size(586, 387)
         Me.tabSplit.TabIndex = 3
         Me.tabSplit.Text = "Split"
         Me.tabSplit.UseVisualStyleBackColor = True
         '
         'lSize
         '
         Me.lSize.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.lSize.Font = New System.Drawing.Font("Microsoft Sans Serif", 11.25!, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.lSize.Location = New System.Drawing.Point(24, 235)
         Me.lSize.Name = "lSize"
         Me.lSize.Size = New System.Drawing.Size(136, 24)
         Me.lSize.TabIndex = 5
         Me.lSize.Text = "0 kb"
         Me.lSize.TextAlign = System.Drawing.ContentAlignment.MiddleCenter
         '
         'Label6
         '
         Me.Label6.Location = New System.Drawing.Point(8, 173)
         Me.Label6.Name = "Label6"
         Me.Label6.Size = New System.Drawing.Size(104, 40)
         Me.Label6.TabIndex = 5
         Me.Label6.Text = "Name for split files"
         Me.Label6.TextAlign = System.Drawing.ContentAlignment.MiddleCenter
         '
         'cSplitBrw
         '
         Me.cSplitBrw.Enabled = False
         Me.cSplitBrw.Location = New System.Drawing.Point(464, 181)
         Me.cSplitBrw.Name = "cSplitBrw"
         Me.cSplitBrw.Size = New System.Drawing.Size(56, 22)
         Me.cSplitBrw.TabIndex = 4
         Me.cSplitBrw.Text = "Browse"
         '
         'tSplitName
         '
         Me.tSplitName.Location = New System.Drawing.Point(120, 181)
         Me.tSplitName.Name = "tSplitName"
         Me.tSplitName.Size = New System.Drawing.Size(336, 20)
         Me.tSplitName.TabIndex = 3
         '
         'cSplit
         '
         Me.cSplit.Enabled = False
         Me.cSplit.Location = New System.Drawing.Point(16, 269)
         Me.cSplit.Name = "cSplit"
         Me.cSplit.Size = New System.Drawing.Size(504, 32)
         Me.cSplit.TabIndex = 2
         Me.cSplit.Text = "&Split the file"
         '
         'GroupBox1
         '
         Me.GroupBox1.Controls.Add(Me.cbSize)
         Me.GroupBox1.Controls.Add(Me.numSec)
         Me.GroupBox1.Controls.Add(Me.Label2)
         Me.GroupBox1.Controls.Add(Me.radTime)
         Me.GroupBox1.Controls.Add(Me.radPieces)
         Me.GroupBox1.Controls.Add(Me.radSize)
         Me.GroupBox1.Controls.Add(Me.Label3)
         Me.GroupBox1.Controls.Add(Me.Label4)
         Me.GroupBox1.Controls.Add(Me.numMin)
         Me.GroupBox1.Controls.Add(Me.numHr)
         Me.GroupBox1.Controls.Add(Me.numPcs)
         Me.GroupBox1.Controls.Add(Me.Label5)
         Me.GroupBox1.Location = New System.Drawing.Point(8, 48)
         Me.GroupBox1.Name = "GroupBox1"
         Me.GroupBox1.Size = New System.Drawing.Size(512, 120)
         Me.GroupBox1.TabIndex = 1
         Me.GroupBox1.TabStop = False
         Me.GroupBox1.Text = "Select splitting method"
         '
         'cbSize
         '
         Me.cbSize.Location = New System.Drawing.Point(128, 84)
         Me.cbSize.Name = "cbSize"
         Me.cbSize.Size = New System.Drawing.Size(72, 21)
         Me.cbSize.Sorted = True
         Me.cbSize.TabIndex = 7
         '
         'numSec
         '
         Me.numSec.Location = New System.Drawing.Point(273, 24)
         Me.numSec.Maximum = New Decimal(New Integer() {60, 0, 0, 0})
         Me.numSec.Minimum = New Decimal(New Integer() {1, 0, 0, 0})
         Me.numSec.Name = "numSec"
         Me.numSec.Size = New System.Drawing.Size(40, 20)
         Me.numSec.TabIndex = 5
         Me.numSec.Value = New Decimal(New Integer() {1, 0, 0, 0})
         '
         'Label2
         '
         Me.Label2.Location = New System.Drawing.Point(162, 27)
         Me.Label2.Name = "Label2"
         Me.Label2.Size = New System.Drawing.Size(16, 23)
         Me.Label2.TabIndex = 2
         Me.Label2.Text = "hr"
         '
         'radTime
         '
         Me.radTime.Checked = True
         Me.radTime.Location = New System.Drawing.Point(16, 24)
         Me.radTime.Name = "radTime"
         Me.radTime.Size = New System.Drawing.Size(104, 24)
         Me.radTime.TabIndex = 0
         Me.radTime.TabStop = True
         Me.radTime.Text = "Play Duration"
         '
         'radPieces
         '
         Me.radPieces.Location = New System.Drawing.Point(16, 53)
         Me.radPieces.Name = "radPieces"
         Me.radPieces.Size = New System.Drawing.Size(104, 24)
         Me.radPieces.TabIndex = 0
         Me.radPieces.Text = "Pieces"
         '
         'radSize
         '
         Me.radSize.Location = New System.Drawing.Point(16, 84)
         Me.radSize.Name = "radSize"
         Me.radSize.Size = New System.Drawing.Size(104, 24)
         Me.radSize.TabIndex = 0
         Me.radSize.Text = "Size"
         '
         'Label3
         '
         Me.Label3.Location = New System.Drawing.Point(237, 26)
         Me.Label3.Name = "Label3"
         Me.Label3.Size = New System.Drawing.Size(24, 23)
         Me.Label3.TabIndex = 2
         Me.Label3.Text = "min"
         '
         'Label4
         '
         Me.Label4.Location = New System.Drawing.Point(318, 27)
         Me.Label4.Name = "Label4"
         Me.Label4.Size = New System.Drawing.Size(35, 23)
         Me.Label4.TabIndex = 2
         Me.Label4.Text = "sec"
         '
         'numMin
         '
         Me.numMin.Location = New System.Drawing.Point(194, 24)
         Me.numMin.Maximum = New Decimal(New Integer() {60, 0, 0, 0})
         Me.numMin.Name = "numMin"
         Me.numMin.Size = New System.Drawing.Size(40, 20)
         Me.numMin.TabIndex = 4
         '
         'numHr
         '
         Me.numHr.Location = New System.Drawing.Point(128, 24)
         Me.numHr.Maximum = New Decimal(New Integer() {4, 0, 0, 0})
         Me.numHr.Name = "numHr"
         Me.numHr.Size = New System.Drawing.Size(32, 20)
         Me.numHr.TabIndex = 3
         '
         'numPcs
         '
         Me.numPcs.Location = New System.Drawing.Point(128, 53)
         Me.numPcs.Maximum = New Decimal(New Integer() {50, 0, 0, 0})
         Me.numPcs.Minimum = New Decimal(New Integer() {2, 0, 0, 0})
         Me.numPcs.Name = "numPcs"
         Me.numPcs.Size = New System.Drawing.Size(40, 20)
         Me.numPcs.TabIndex = 6
         Me.numPcs.Value = New Decimal(New Integer() {2, 0, 0, 0})
         '
         'Label5
         '
         Me.Label5.Location = New System.Drawing.Point(204, 90)
         Me.Label5.Name = "Label5"
         Me.Label5.Size = New System.Drawing.Size(35, 23)
         Me.Label5.TabIndex = 2
         Me.Label5.Text = "kb"
         '
         'tFile2Split
         '
         Me.tFile2Split.Location = New System.Drawing.Point(8, 16)
         Me.tFile2Split.Name = "tFile2Split"
         Me.tFile2Split.ReadOnly = True
         Me.tFile2Split.Size = New System.Drawing.Size(512, 20)
         Me.tFile2Split.TabIndex = 0
         '
         'Label1
         '
         Me.Label1.Location = New System.Drawing.Point(168, 205)
         Me.Label1.Name = "Label1"
         Me.Label1.Size = New System.Drawing.Size(352, 64)
         Me.Label1.TabIndex = 2
         Me.Label1.Text = "Note
             "ries of the peices may not co-incide with those inferred from the settings above" & _
             "."
         Me.Label1.TextAlign = System.Drawing.ContentAlignment.MiddleCenter
         '
         'Label7
         '
         Me.Label7.Location = New System.Drawing.Point(8, 217)
         Me.Label7.Name = "Label7"
         Me.Label7.Size = New System.Drawing.Size(160, 16)
         Me.Label7.TabIndex = 5
         Me.Label7.Text = "Estimated file size"
         Me.Label7.TextAlign = System.Drawing.ContentAlignment.MiddleCenter
         '
         'tabTrace
         '
         Me.tabTrace.Controls.Add(Me.panStatus)
         Me.tabTrace.Controls.Add(Me.CheckBox1)
         Me.tabTrace.Controls.Add(Me.rtfTrace)
         Me.tabTrace.Controls.Add(Me.tbTrace)
         Me.tabTrace.Location = New System.Drawing.Point(4, 22)
         Me.tabTrace.Name = "tabTrace"
         Me.tabTrace.Size = New System.Drawing.Size(586, 387)
         Me.tabTrace.TabIndex = 1
         Me.tabTrace.Text = "Trace"
         Me.tabTrace.UseVisualStyleBackColor = True
         '
         'panStatus
         '
         Me.panStatus.BackColor = System.Drawing.SystemColors.Info
         Me.panStatus.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.panStatus.Controls.Add(Me.lMsgStat)
         Me.panStatus.Controls.Add(Me.picStat)
         Me.panStatus.Location = New System.Drawing.Point(96, 5)
         Me.panStatus.Name = "panStatus"
         Me.Helper.SetShowHelp(Me.panStatus, True)
         Me.panStatus.Size = New System.Drawing.Size(232, 20)
         Me.panStatus.TabIndex = 2
         '
         'lMsgStat
         '
         Me.lMsgStat.Dock = System.Windows.Forms.DockStyle.Fill
         Me.lMsgStat.Font = New System.Drawing.Font("Microsoft Sans Serif", 8.25!, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.lMsgStat.Location = New System.Drawing.Point(16, 0)
         Me.lMsgStat.Name = "lMsgStat"
         Me.lMsgStat.Size = New System.Drawing.Size(212, 16)
         Me.lMsgStat.TabIndex = 1
         Me.lMsgStat.Text = "Status of last operation"
         Me.lMsgStat.TextAlign = System.Drawing.ContentAlignment.MiddleLeft
         '
         'picStat
         '
         Me.picStat.Dock = System.Windows.Forms.DockStyle.Left
         Me.picStat.Location = New System.Drawing.Point(0, 0)
         Me.picStat.Name = "picStat"
         Me.picStat.Size = New System.Drawing.Size(16, 16)
         Me.picStat.TabIndex = 0
         Me.picStat.TabStop = False
         '
         'CheckBox1
         '
         Me.CheckBox1.Anchor = CType((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.CheckBox1.BackColor = System.Drawing.SystemColors.Control
         Me.CheckBox1.Checked = True
         Me.CheckBox1.CheckState = System.Windows.Forms.CheckState.Checked
         Me.CheckBox1.Enabled = False
         Me.CheckBox1.Location = New System.Drawing.Point(408, 8)
         Me.CheckBox1.Name = "CheckBox1"
         Me.CheckBox1.Size = New System.Drawing.Size(160, 16)
         Me.CheckBox1.TabIndex = 0
         Me.CheckBox1.Text = "Show detailed results"
         Me.CheckBox1.UseVisualStyleBackColor = False
         '
         'rtfTrace
         '
         Me.rtfTrace.DetectUrls = False
         Me.rtfTrace.Dock = System.Windows.Forms.DockStyle.Fill
         Me.rtfTrace.Location = New System.Drawing.Point(0, 28)
         Me.rtfTrace.Name = "rtfTrace"
         Me.rtfTrace.ReadOnly = True
         Me.rtfTrace.Size = New System.Drawing.Size(586, 359)
         Me.rtfTrace.TabIndex = 0
         Me.rtfTrace.Text = "Output from converter shown here"
         '
         'tbTrace
         '
         Me.tbTrace.Buttons.AddRange(New System.Windows.Forms.ToolBarButton() {Me.tcClearTrace, Me.tcSaveTrace})
         Me.tbTrace.ButtonSize = New System.Drawing.Size(23, 22)
         Me.tbTrace.DropDownArrows = True
         Me.tbTrace.ImageList = Me.ImageList1
         Me.tbTrace.Location = New System.Drawing.Point(0, 0)
         Me.tbTrace.Name = "tbTrace"
         Me.tbTrace.ShowToolTips = True
         Me.tbTrace.Size = New System.Drawing.Size(586, 28)
         Me.tbTrace.TabIndex = 1
         '
         'tcClearTrace
         '
         Me.tcClearTrace.ImageIndex = 0
         Me.tcClearTrace.Name = "tcClearTrace"
         Me.tcClearTrace.Tag = "Clear"
         Me.tcClearTrace.ToolTipText = "Clear the log displayed below"
         '
         'tcSaveTrace
         '
         Me.tcSaveTrace.ImageIndex = 11
         Me.tcSaveTrace.Name = "tcSaveTrace"
         Me.tcSaveTrace.Tag = "Save"
         Me.tcSaveTrace.ToolTipText = "Save the log shown below"
         '
         'tabSettings
         '
         Me.tabSettings.Controls.Add(Me.GroupBox3)
         Me.tabSettings.Controls.Add(Me.GroupBox2)
         Me.tabSettings.Controls.Add(Me.GroupBox4)
         Me.tabSettings.Location = New System.Drawing.Point(4, 22)
         Me.tabSettings.Name = "tabSettings"
         Me.tabSettings.Size = New System.Drawing.Size(586, 387)
         Me.tabSettings.TabIndex = 4
         Me.tabSettings.Text = "Advanced"
         Me.tabSettings.UseVisualStyleBackColor = True
         '
         'GroupBox3
         '
         Me.GroupBox3.Controls.Add(Me.chkForceJoin)
         Me.GroupBox3.Controls.Add(Me.chkKeepMRU)
         Me.GroupBox3.Controls.Add(Me.chkDialogView)
         Me.GroupBox3.Controls.Add(Me.chkBeep)
         Me.GroupBox3.Controls.Add(Me.chkOnTop)
         Me.GroupBox3.Controls.Add(Me.chkUpdate)
         Me.GroupBox3.Location = New System.Drawing.Point(16, 15)
         Me.GroupBox3.Name = "GroupBox3"
         Me.GroupBox3.Size = New System.Drawing.Size(552, 165)
         Me.GroupBox3.TabIndex = 2
         Me.GroupBox3.TabStop = False
         Me.GroupBox3.Text = "General"
         '
         'chkForceJoin
         '
         Me.chkForceJoin.Location = New System.Drawing.Point(8, 15)
         Me.chkForceJoin.Name = "chkForceJoin"
         Me.chkForceJoin.Size = New System.Drawing.Size(538, 30)
         Me.chkForceJoin.TabIndex = 0
         Me.chkForceJoin.Text = "Force joining of incompatible files. As the name suggests the results will be unp" & _
             "redictable."
         '
         'chkKeepMRU
         '
         Me.chkKeepMRU.Location = New System.Drawing.Point(8, 114)
         Me.chkKeepMRU.Name = "chkKeepMRU"
         Me.chkKeepMRU.Size = New System.Drawing.Size(538, 23)
         Me.chkKeepMRU.TabIndex = 0
         Me.chkKeepMRU.Text = "Keep history"
         '
         'chkDialogView
         '
         Me.chkDialogView.Checked = True
         Me.chkDialogView.CheckState = System.Windows.Forms.CheckState.Checked
         Me.chkDialogView.Location = New System.Drawing.Point(8, 41)
         Me.chkDialogView.Name = "chkDialogView"
         Me.chkDialogView.Size = New System.Drawing.Size(538, 23)
         Me.chkDialogView.TabIndex = 0
         Me.chkDialogView.Text = "Show thumbnails when selecting video files"
         '
         'chkBeep
         '
         Me.chkBeep.Location = New System.Drawing.Point(8, 90)
         Me.chkBeep.Name = "chkBeep"
         Me.chkBeep.Size = New System.Drawing.Size(538, 23)
         Me.chkBeep.TabIndex = 0
         Me.chkBeep.Text = "Beep when done"
         '
         'chkOnTop
         '
         Me.chkOnTop.Location = New System.Drawing.Point(8, 66)
         Me.chkOnTop.Name = "chkOnTop"
         Me.chkOnTop.Size = New System.Drawing.Size(538, 23)
         Me.chkOnTop.TabIndex = 0
         Me.chkOnTop.Text = "Keep Movica window on top when playing"
         '
         'chkUpdate
         '
         Me.chkUpdate.Location = New System.Drawing.Point(8, 138)
         Me.chkUpdate.Name = "chkUpdate"
         Me.chkUpdate.Size = New System.Drawing.Size(538, 23)
         Me.chkUpdate.TabIndex = 0
         Me.chkUpdate.Text = "Check for updates at startup"
         '
         'GroupBox2
         '
         Me.GroupBox2.Controls.Add(Me.chkFrameAccurate)
         Me.GroupBox2.Location = New System.Drawing.Point(16, 186)
         Me.GroupBox2.Name = "GroupBox2"
         Me.GroupBox2.Size = New System.Drawing.Size(552, 62)
         Me.GroupBox2.TabIndex = 1
         Me.GroupBox2.TabStop = False
         Me.GroupBox2.Text = "Windows Media (.wmv / .asf)"
         '
         'chkFrameAccurate
         '
         Me.chkFrameAccurate.Location = New System.Drawing.Point(8, 22)
         Me.chkFrameAccurate.Name = "chkFrameAccurate"
         Me.chkFrameAccurate.Size = New System.Drawing.Size(512, 32)
         Me.chkFrameAccurate.TabIndex = 0
         Me.chkFrameAccurate.Text = "Enable frame accurate editing (This does not work on all files; turn this option " & _
             "off if your edit is not successful)"
         '
         'GroupBox4
         '
         Me.GroupBox4.Controls.Add(Me.LinkLabel1)
         Me.GroupBox4.Controls.Add(Me.cTransleditor)
         Me.GroupBox4.Controls.Add(Me.Label8)
         Me.GroupBox4.Controls.Add(Me.cbLang)
         Me.GroupBox4.Location = New System.Drawing.Point(16, 256)
         Me.GroupBox4.Name = "GroupBox4"
         Me.GroupBox4.Size = New System.Drawing.Size(552, 104)
         Me.GroupBox4.TabIndex = 3
         Me.GroupBox4.TabStop = False
         Me.GroupBox4.Text = "Language"
         '
         'LinkLabel1
         '
         Me.LinkLabel1.Location = New System.Drawing.Point(392, 72)
         Me.LinkLabel1.Name = "LinkLabel1"
         Me.LinkLabel1.Size = New System.Drawing.Size(100, 23)
         Me.LinkLabel1.TabIndex = 3
         Me.LinkLabel1.TabStop = True
         Me.LinkLabel1.Text = "Send it to Movica"
         Me.ToolTips.SetToolTip(Me.LinkLabel1, "email your translations for addition in the next version")
         '
         'cTransleditor
         '
         Me.cTransleditor.Location = New System.Drawing.Point(232, 72)
         Me.cTransleditor.Name = "cTransleditor"
         Me.cTransleditor.Size = New System.Drawing.Size(152, 24)
         Me.cTransleditor.TabIndex = 2
         Me.cTransleditor.Text = "Edit Languages"
         '
         'Label8
         '
         Me.Label8.Location = New System.Drawing.Point(232, 24)
         Me.Label8.Name = "Label8"
         Me.Label8.Size = New System.Drawing.Size(248, 48)
         Me.Label8.TabIndex = 1
         Me.Label8.Text = "Please do not laugh too hard at the translations. Help me by sending me your tran" & _
             "slations. Use button below to edit."
         '
         'cbLang
         '
         Me.cbLang.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList
         Me.cbLang.Location = New System.Drawing.Point(8, 32)
         Me.cbLang.Name = "cbLang"
         Me.cbLang.Size = New System.Drawing.Size(192, 21)
         Me.cbLang.TabIndex = 0
         '
         'tabTools
         '
         Me.tabTools.Controls.Add(Me.GroupBox6)
         Me.tabTools.Controls.Add(Me.GroupBox5)
         Me.tabTools.Location = New System.Drawing.Point(4, 22)
         Me.tabTools.Name = "tabTools"
         Me.tabTools.Padding = New System.Windows.Forms.Padding(3)
         Me.tabTools.Size = New System.Drawing.Size(586, 387)
         Me.tabTools.TabIndex = 5
         Me.tabTools.Text = "Add Tools"
         Me.tabTools.ToolTipText = "Add support for more tools"
         Me.tabTools.UseVisualStyleBackColor = True
         '
         'GroupBox6
         '
         Me.GroupBox6.Controls.Add(Me.Label12)
         Me.GroupBox6.Location = New System.Drawing.Point(6, 230)
         Me.GroupBox6.Name = "GroupBox6"
         Me.GroupBox6.Size = New System.Drawing.Size(574, 156)
         Me.GroupBox6.TabIndex = 1
         Me.GroupBox6.TabStop = False
         Me.GroupBox6.Text = "Any command-line tool"
         '
         'Label12
         '
         Me.Label12.AutoSize = True
         Me.Label12.Location = New System.Drawing.Point(13, 30)
         Me.Label12.Name = "Label12"
         Me.Label12.Size = New System.Drawing.Size(86, 13)
         Me.Label12.TabIndex = 0
         Me.Label12.Text = "Still working on it"
         '
         'GroupBox5
         '
         Me.GroupBox5.Controls.Add(Me.cDShow)
         Me.GroupBox5.Controls.Add(Me.tStdToolPath)
         Me.GroupBox5.Controls.Add(Me.Label10)
         Me.GroupBox5.Controls.Add(Me.chkEnabled)
         Me.GroupBox5.Controls.Add(Me.cDetect)
         Me.GroupBox5.Controls.Add(Me.cToolFind)
         Me.GroupBox5.Controls.Add(Me.linkToolURL)
         Me.GroupBox5.Controls.Add(Me.lblToolDesc)
         Me.GroupBox5.Controls.Add(Me.lbStdTools)
         Me.GroupBox5.Location = New System.Drawing.Point(6, 6)
         Me.GroupBox5.Name = "GroupBox5"
         Me.GroupBox5.Size = New System.Drawing.Size(574, 218)
         Me.GroupBox5.TabIndex = 0
         Me.GroupBox5.TabStop = False
         Me.GroupBox5.Text = "Standard tools"
         '
         'cDShow
         '
         Me.cDShow.Location = New System.Drawing.Point(174, 183)
         Me.cDShow.Name = "cDShow"
         Me.cDShow.Size = New System.Drawing.Size(387, 22)
         Me.cDShow.TabIndex = 8
         Me.cDShow.Text = "List filters"
         Me.cDShow.UseVisualStyleBackColor = True
         '
         'tStdToolPath
         '
         Me.tStdToolPath.Location = New System.Drawing.Point(206, 157)
         Me.tStdToolPath.Name = "tStdToolPath"
         Me.tStdToolPath.ReadOnly = True
         Me.tStdToolPath.Size = New System.Drawing.Size(300, 20)
         Me.tStdToolPath.TabIndex = 3
         '
         'Label10
         '
         Me.Label10.AutoSize = True
         Me.Label10.Location = New System.Drawing.Point(171, 160)
         Me.Label10.Name = "Label10"
         Me.Label10.Size = New System.Drawing.Size(29, 13)
         Me.Label10.TabIndex = 7
         Me.Label10.Text = "Path"
         '
         'chkEnabled
         '
         Me.chkEnabled.AutoSize = True
         Me.chkEnabled.Location = New System.Drawing.Point(174, 20)
         Me.chkEnabled.Name = "chkEnabled"
         Me.chkEnabled.Size = New System.Drawing.Size(98, 17)
         Me.chkEnabled.TabIndex = 6
         Me.chkEnabled.Text = "Enable this tool"
         Me.chkEnabled.UseVisualStyleBackColor = True
         '
         'cDetect
         '
         Me.cDetect.Enabled = False
         Me.cDetect.Location = New System.Drawing.Point(513, 16)
         Me.cDetect.Name = "cDetect"
         Me.cDetect.Size = New System.Drawing.Size(49, 47)
         Me.cDetect.TabIndex = 5
         Me.cDetect.Text = "Auto Detect"
         Me.cDetect.UseVisualStyleBackColor = True
         '
         'cToolFind
         '
         Me.cToolFind.Enabled = False
         Me.cToolFind.Location = New System.Drawing.Point(512, 156)
         Me.cToolFind.Name = "cToolFind"
         Me.cToolFind.Size = New System.Drawing.Size(50, 20)
         Me.cToolFind.TabIndex = 4
         Me.cToolFind.Text = "&Browse"
         Me.cToolFind.UseVisualStyleBackColor = True
         '
         'linkToolURL
         '
         Me.linkToolURL.AutoSize = True
         Me.linkToolURL.Location = New System.Drawing.Point(171, 134)
         Me.linkToolURL.Name = "linkToolURL"
         Me.linkToolURL.Size = New System.Drawing.Size(59, 13)
         Me.linkToolURL.TabIndex = 2
         Me.linkToolURL.TabStop = True
         Me.linkToolURL.Text = "LinkLabel2"
         '
         'lblToolDesc
         '
         Me.lblToolDesc.Location = New System.Drawing.Point(174, 45)
         Me.lblToolDesc.Name = "lblToolDesc"
         Me.lblToolDesc.Size = New System.Drawing.Size(332, 82)
         Me.lblToolDesc.TabIndex = 1
         Me.lblToolDesc.Text = "Label10"
         '
         'lbStdTools
         '
         Me.lbStdTools.DisplayMember = "DisplayName"
         Me.lbStdTools.FormattingEnabled = True
         Me.lbStdTools.Location = New System.Drawing.Point(14, 20)
         Me.lbStdTools.Name = "lbStdTools"
         Me.lbStdTools.Size = New System.Drawing.Size(151, 186)
         Me.lbStdTools.Sorted = True
         Me.lbStdTools.TabIndex = 0
         '
         'panSegments
         '
         Me.panSegments.Controls.Add(Me.lvPositions)
         Me.panSegments.Controls.Add(Me.tbPositions)
         Me.panSegments.Controls.Add(Me.Label11)
         Me.panSegments.Dock = System.Windows.Forms.DockStyle.Right
         Me.panSegments.Location = New System.Drawing.Point(597, 0)
         Me.panSegments.Name = "panSegments"
         Me.panSegments.Size = New System.Drawing.Size(139, 413)
         Me.panSegments.TabIndex = 6
         '
         'lvPositions
         '
         Me.lvPositions.Columns.AddRange(New System.Windows.Forms.ColumnHeader() {Me.colStart, Me.colEnd})
         Me.lvPositions.ContextMenu = Me.SegMenu
         Me.lvPositions.Dock = System.Windows.Forms.DockStyle.Fill
         Me.lvPositions.FullRowSelect = True
         Me.lvPositions.HideSelection = False
         Me.lvPositions.Location = New System.Drawing.Point(0, 44)
         Me.lvPositions.Name = "lvPositions"
         Me.lvPositions.Size = New System.Drawing.Size(139, 369)
         Me.lvPositions.TabIndex = 4
         Me.lvPositions.UseCompatibleStateImageBehavior = False
         Me.lvPositions.View = System.Windows.Forms.View.Details
         '
         'colStart
         '
         Me.colStart.Text = "Start"
         Me.colStart.Width = 67
         '
         'colEnd
         '
         Me.colEnd.Text = "End"
         Me.colEnd.Width = 68
         '
         'SegMenu
         '
         Me.SegMenu.MenuItems.AddRange(New System.Windows.Forms.MenuItem() {Me.MenuItem10, Me.MenuItem9, Me.MenuItem11})
         '
         'MenuItem10
         '
         Me.MenuItem10.Index = 0
         Me.MenuItem10.Text = "&Delete"
         '
         'MenuItem9
         '
         Me.MenuItem9.Index = 1
         Me.MenuItem9.Text = "&Copy"
         '
         'MenuItem11
         '
         Me.MenuItem11.Index = 2
         Me.MenuItem11.Text = "&Paste"
         '
         'tbPositions
         '
         Me.tbPositions.Appearance = System.Windows.Forms.ToolBarAppearance.Flat
         Me.tbPositions.Buttons.AddRange(New System.Windows.Forms.ToolBarButton() {Me.cPlayAll, Me.cPlayNotSelected, Me.cPlaySelected, Me.cSaveMask, Me.cOpenMask, Me.cLoop})
         Me.tbPositions.ButtonSize = New System.Drawing.Size(22, 22)
         Me.tbPositions.DropDownArrows = True
         Me.tbPositions.ImageList = Me.ImageList1
         Me.tbPositions.Location = New System.Drawing.Point(0, 16)
         Me.tbPositions.Name = "tbPositions"
         Me.tbPositions.ShowToolTips = True
         Me.tbPositions.Size = New System.Drawing.Size(139, 28)
         Me.tbPositions.TabIndex = 6
         '
         'cPlayAll
         '
         Me.cPlayAll.ImageIndex = 14
         Me.cPlayAll.Name = "cPlayAll"
         Me.cPlayAll.Tag = "Play"
         Me.cPlayAll.ToolTipText = "Play all the selected parts. Closest thing to a proof test [Ctrl + P]"
         '
         'cPlayNotSelected
         '
         Me.cPlayNotSelected.ImageIndex = 15
         Me.cPlayNotSelected.Name = "cPlayNotSelected"
         Me.cPlayNotSelected.Tag = "PlayNotSelected"
         Me.cPlayNotSelected.ToolTipText = "Plays all those parts of the movie that are not selected [Shift + Ctrl + P]"
         '
         'cPlaySelected
         '
         Me.cPlaySelected.ImageIndex = 16
         Me.cPlaySelected.Name = "cPlaySelected"
         Me.cPlaySelected.Tag = "PlaySelected"
         Me.cPlaySelected.ToolTipText = "Play just the highlighted parts from the list below [Ctrl + T]"
         '
         'cSaveMask
         '
         Me.cSaveMask.ImageIndex = 11
         Me.cSaveMask.Name = "cSaveMask"
         Me.cSaveMask.Tag = "Save"
         Me.cSaveMask.ToolTipText = "Save the parts as a MoviClip (er..cliplist?) [Ctrl + M]"
         '
         'cOpenMask
         '
         Me.cOpenMask.ImageIndex = 4
         Me.cOpenMask.Name = "cOpenMask"
         Me.cOpenMask.Tag = "Open"
         Me.cOpenMask.ToolTipText = "Open a MoviClip"
         '
         'cLoop
         '
         Me.cLoop.ImageIndex = 17
         Me.cLoop.Name = "cLoop"
         Me.cLoop.Style = System.Windows.Forms.ToolBarButtonStyle.ToggleButton
         Me.cLoop.Tag = "ToggleRepeat"
         Me.cLoop.ToolTipText = "Repeat play (Ctrl + L)"
         '
         'Label11
         '
         Me.Label11.Dock = System.Windows.Forms.DockStyle.Top
         Me.Label11.Location = New System.Drawing.Point(0, 0)
         Me.Label11.Name = "Label11"
         Me.Label11.Size = New System.Drawing.Size(139, 16)
         Me.Label11.TabIndex = 5
         Me.Label11.Text = "Selected Parts"
         Me.Label11.TextAlign = System.Drawing.ContentAlignment.MiddleCenter
         '
         'Splitter1
         '
         Me.Splitter1.Dock = System.Windows.Forms.DockStyle.Right
         Me.Splitter1.Location = New System.Drawing.Point(594, 0)
         Me.Splitter1.Name = "Splitter1"
         Me.Splitter1.Size = New System.Drawing.Size(3, 413)
         Me.Splitter1.TabIndex = 8
         Me.Splitter1.TabStop = False
         '
         'Timer
         '
         '
         'Panel1
         '
         Me.Panel1.Controls.Add(Me.statBar)
         Me.Panel1.Controls.Add(Me.picStatus)
         Me.Panel1.Dock = System.Windows.Forms.DockStyle.Bottom
         Me.Panel1.Location = New System.Drawing.Point(0, 429)
         Me.Panel1.Name = "Panel1"
         Me.Helper.SetShowHelp(Me.Panel1, True)
         Me.Panel1.Size = New System.Drawing.Size(736, 22)
         Me.Panel1.TabIndex = 9
         '
         'statBar
         '
         Me.statBar.Location = New System.Drawing.Point(22, 0)
         Me.statBar.Name = "statBar"
         Me.statBar.Panels.AddRange(New System.Windows.Forms.StatusBarPanel() {Me.statMain, Me.statSel, Me.statDur})
         Me.statBar.ShowPanels = True
         Me.statBar.Size = New System.Drawing.Size(714, 22)
         Me.statBar.TabIndex = 3
         '
         'statMain
         '
         Me.statMain.AutoSize = System.Windows.Forms.StatusBarPanelAutoSize.Spring
         Me.statMain.Name = "statMain"
         Me.statMain.Text = "Status displayed here"
         Me.statMain.Width = 617
         '
         'statSel
         '
         Me.statSel.AutoSize = System.Windows.Forms.StatusBarPanelAutoSize.Contents
         Me.statSel.MinWidth = 40
         Me.statSel.Name = "statSel"
         Me.statSel.Width = 40
         '
         'statDur
         '
         Me.statDur.AutoSize = System.Windows.Forms.StatusBarPanelAutoSize.Contents
         Me.statDur.MinWidth = 40
         Me.statDur.Name = "statDur"
         Me.statDur.Width = 40
         '
         'picStatus
         '
         Me.picStatus.BackgroundImageLayout = System.Windows.Forms.ImageLayout.None
         Me.picStatus.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.picStatus.Dock = System.Windows.Forms.DockStyle.Left
         Me.picStatus.Image = CType(resources.GetObject("picStatus.Image"), System.Drawing.Image)
         Me.picStatus.ImageLocation = ""
         Me.picStatus.InitialImage = Nothing
         Me.picStatus.Location = New System.Drawing.Point(0, 0)
         Me.picStatus.Name = "picStatus"
         Me.picStatus.Padding = New System.Windows.Forms.Padding(2)
         Me.picStatus.Size = New System.Drawing.Size(22, 22)
         Me.picStatus.TabIndex = 1
         Me.picStatus.TabStop = False
         Me.picStatus.Visible = False
         '
         'PanelFine
         '
         Me.PanelFine.Controls.Add(Me.FineResolution)
         Me.PanelFine.Controls.Add(Me.Label9)
         Me.PanelFine.Controls.Add(Me.cEndFrRev)
         Me.PanelFine.Controls.Add(Me.cEndFrFwd)
         Me.PanelFine.Controls.Add(Me.cStrtFrFwd)
         Me.PanelFine.Controls.Add(Me.cStrtFrRev)
         Me.PanelFine.Controls.Add(Me.lpanFineText)
         Me.PanelFine.Dock = System.Windows.Forms.DockStyle.Bottom
         Me.PanelFine.Location = New System.Drawing.Point(0, 413)
         Me.PanelFine.Name = "PanelFine"
         Me.PanelFine.Size = New System.Drawing.Size(736, 16)
         Me.PanelFine.TabIndex = 3
         '
         'Label9
         '
         Me.Label9.BackColor = System.Drawing.SystemColors.ControlDark
         Me.Label9.Dock = System.Windows.Forms.DockStyle.Left
         Me.Label9.Location = New System.Drawing.Point(48, 0)
         Me.Label9.Name = "Label9"
         Me.Label9.Size = New System.Drawing.Size(72, 16)
         Me.Label9.TabIndex = 16
         Me.Label9.Text = "  Granularity"
         Me.Label9.TextAlign = System.Drawing.ContentAlignment.MiddleCenter
         Me.ToolTips.SetToolTip(Me.Label9, "Please use the slider to set the granularity of the fine tuning arrow buttons")
         '
         'cEndFrRev
         '
         Me.cEndFrRev.BackColor = System.Drawing.SystemColors.ControlDark
         Me.cEndFrRev.Dock = System.Windows.Forms.DockStyle.Right
         Me.cEndFrRev.FlatStyle = System.Windows.Forms.FlatStyle.Popup
         Me.cEndFrRev.ImageIndex = 9
         Me.cEndFrRev.ImageList = Me.ImageList1
         Me.cEndFrRev.Location = New System.Drawing.Point(688, 0)
         Me.cEndFrRev.Name = "cEndFrRev"
         Me.cEndFrRev.Size = New System.Drawing.Size(24, 16)
         Me.cEndFrRev.TabIndex = 14
         Me.ToolTips.SetToolTip(Me.cEndFrRev, "Move end point earlier")
         Me.cEndFrRev.UseVisualStyleBackColor = False
         '
         'cEndFrFwd
         '
         Me.cEndFrFwd.BackColor = System.Drawing.SystemColors.ControlDark
         Me.cEndFrFwd.Dock = System.Windows.Forms.DockStyle.Right
         Me.cEndFrFwd.FlatStyle = System.Windows.Forms.FlatStyle.Popup
         Me.cEndFrFwd.ImageIndex = 8
         Me.cEndFrFwd.ImageList = Me.ImageList1
         Me.cEndFrFwd.Location = New System.Drawing.Point(712, 0)
         Me.cEndFrFwd.Name = "cEndFrFwd"
         Me.cEndFrFwd.Size = New System.Drawing.Size(24, 16)
         Me.cEndFrFwd.TabIndex = 13
         Me.ToolTips.SetToolTip(Me.cEndFrFwd, "Move end point later")
         Me.cEndFrFwd.UseVisualStyleBackColor = False
         '
         'cStrtFrFwd
         '
         Me.cStrtFrFwd.BackColor = System.Drawing.SystemColors.ControlDark
         Me.cStrtFrFwd.Dock = System.Windows.Forms.DockStyle.Left
         Me.cStrtFrFwd.FlatStyle = System.Windows.Forms.FlatStyle.Popup
         Me.cStrtFrFwd.ImageIndex = 8
         Me.cStrtFrFwd.ImageList = Me.ImageList1
         Me.cStrtFrFwd.Location = New System.Drawing.Point(24, 0)
         Me.cStrtFrFwd.Name = "cStrtFrFwd"
         Me.cStrtFrFwd.Size = New System.Drawing.Size(24, 16)
         Me.cStrtFrFwd.TabIndex = 12
         Me.ToolTips.SetToolTip(Me.cStrtFrFwd, "Move starting point later")
         Me.cStrtFrFwd.UseVisualStyleBackColor = False
         '
         'cStrtFrRev
         '
         Me.cStrtFrRev.BackColor = System.Drawing.SystemColors.ControlDark
         Me.cStrtFrRev.Dock = System.Windows.Forms.DockStyle.Left
         Me.cStrtFrRev.FlatStyle = System.Windows.Forms.FlatStyle.Popup
         Me.cStrtFrRev.ImageIndex = 9
         Me.cStrtFrRev.ImageList = Me.ImageList1
         Me.cStrtFrRev.Location = New System.Drawing.Point(0, 0)
         Me.cStrtFrRev.Name = "cStrtFrRev"
         Me.cStrtFrRev.Size = New System.Drawing.Size(24, 16)
         Me.cStrtFrRev.TabIndex = 11
         Me.ToolTips.SetToolTip(Me.cStrtFrRev, "Move starting point earlier")
         Me.cStrtFrRev.UseVisualStyleBackColor = False
         '
         'lpanFineText
         '
         Me.lpanFineText.Dock = System.Windows.Forms.DockStyle.Fill
         Me.lpanFineText.Location = New System.Drawing.Point(0, 0)
         Me.lpanFineText.Name = "lpanFineText"
         Me.lpanFineText.Size = New System.Drawing.Size(736, 16)
         Me.lpanFineText.TabIndex = 18
         Me.lpanFineText.Text = "The fine tuning controls will be available here when you highlight a particular s" & _
             "election from the right on the 'Player' tab."
         Me.lpanFineText.TextAlign = System.Drawing.ContentAlignment.MiddleCenter
         '
         'MPcontrols
         '
         Me.MPcontrols.BackColor = System.Drawing.SystemColors.Control
         Me.MPcontrols.DisplayMode = Editor.ucMPcontrols.MPCDisplayMode.Normal
         Me.MPcontrols.Dock = System.Windows.Forms.DockStyle.Bottom
         Me.MPcontrols.Location = New System.Drawing.Point(0, 331)
         Me.MPcontrols.Margin = New System.Windows.Forms.Padding(0)
         Me.MPcontrols.Mute = False
         Me.MPcontrols.Name = "MPcontrols"
         Me.MPcontrols.Padding = New System.Windows.Forms.Padding(3, 3, 3, 0)
         Me.MPcontrols.Size = New System.Drawing.Size(586, 56)
         Me.MPcontrols.TabIndex = 2
         Me.MPcontrols.Volume = 0
         '
         'FineResolution
         '
         Me.FineResolution.BackColor = System.Drawing.SystemColors.ControlDark
         Me.FineResolution.Dock = System.Windows.Forms.DockStyle.Bottom
         Me.FineResolution.Location = New System.Drawing.Point(120, 0)
         Me.FineResolution.Maximum = 1.0!
         Me.FineResolution.Minimum = 0.01!
         Me.FineResolution.Name = "FineResolution"
         Me.FineResolution.Padding = New System.Windows.Forms.Padding(2)
         Me.FineResolution.Size = New System.Drawing.Size(568, 16)
         Me.FineResolution.TabIndex = 15
         Me.ToolTips.SetToolTip(Me.FineResolution, "Please use the slider to set the granularity of the fine tuning arrow buttons")
         Me.FineResolution.Value = 0.15!
         '
         'frmMain
         '
         Me.AllowDrop = True
         Me.AutoScaleBaseSize = New System.Drawing.Size(5, 13)
         Me.BackColor = System.Drawing.SystemColors.Control
         Me.BackgroundImageLayout = System.Windows.Forms.ImageLayout.None
         Me.ClientSize = New System.Drawing.Size(736, 451)
         Me.Controls.Add(Me.mainTabs)
         Me.Controls.Add(Me.Splitter1)
         Me.Controls.Add(Me.panSegments)
         Me.Controls.Add(Me.PanelFine)
         Me.Controls.Add(Me.Panel1)
         Me.DoubleBuffered = True
         Me.Icon = CType(resources.GetObject("$this.Icon"), System.Drawing.Icon)
         Me.KeyPreview = True
         Me.Menu = Me.MainMenu1
         Me.MinimumSize = New System.Drawing.Size(600, 485)
         Me.Name = "frmMain"
         Me.Text = "Movica"
         Me.mainTabs.ResumeLayout(False)
         Me.tabPlayer.ResumeLayout(False)
         Me.panAudio.ResumeLayout(False)
         CType(Me.picAudioDetail, System.ComponentModel.ISupportInitialize).EndInit()
         CType(Me.picAudioSumm, System.ComponentModel.ISupportInitialize).EndInit()
         CType(Me.mPlayer, System.ComponentModel.ISupportInitialize).EndInit()
         Me.tabJoin.ResumeLayout(False)
         Me.tabJoin.PerformLayout()
         Me.tabSplit.ResumeLayout(False)
         Me.tabSplit.PerformLayout()
         Me.GroupBox1.ResumeLayout(False)
         CType(Me.numSec, System.ComponentModel.ISupportInitialize).EndInit()
         CType(Me.numMin, System.ComponentModel.ISupportInitialize).EndInit()
         CType(Me.numHr, System.ComponentModel.ISupportInitialize).EndInit()
         CType(Me.numPcs, System.ComponentModel.ISupportInitialize).EndInit()
         Me.tabTrace.ResumeLayout(False)
         Me.tabTrace.PerformLayout()
         Me.panStatus.ResumeLayout(False)
         CType(Me.picStat, System.ComponentModel.ISupportInitialize).EndInit()
         Me.tabSettings.ResumeLayout(False)
         Me.GroupBox3.ResumeLayout(False)
         Me.GroupBox2.ResumeLayout(False)
         Me.GroupBox4.ResumeLayout(False)
         Me.tabTools.ResumeLayout(False)
         Me.GroupBox6.ResumeLayout(False)
         Me.GroupBox6.PerformLayout()
         Me.GroupBox5.ResumeLayout(False)
         Me.GroupBox5.PerformLayout()
         Me.panSegments.ResumeLayout(False)
         Me.panSegments.PerformLayout()
         Me.Panel1.ResumeLayout(False)
         CType(Me.statMain, System.ComponentModel.ISupportInitialize).EndInit()
         CType(Me.statSel, System.ComponentModel.ISupportInitialize).EndInit()
         CType(Me.statDur, System.ComponentModel.ISupportInitialize).EndInit()
         CType(Me.picStatus, System.ComponentModel.ISupportInitialize).EndInit()
         Me.PanelFine.ResumeLayout(False)
         Me.ResumeLayout(False)
 
     End Sub
]]>
</clone_fragment>
</clone_group>
</clones>
